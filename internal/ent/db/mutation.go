// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/openmeterio/openmeter/internal/credit/balance"
	"github.com/openmeterio/openmeter/internal/credit/grant"
	"github.com/openmeterio/openmeter/internal/ent/db/balancesnapshot"
	"github.com/openmeterio/openmeter/internal/ent/db/entitlement"
	"github.com/openmeterio/openmeter/internal/ent/db/feature"
	dbgrant "github.com/openmeterio/openmeter/internal/ent/db/grant"
	"github.com/openmeterio/openmeter/internal/ent/db/notificationchannel"
	"github.com/openmeterio/openmeter/internal/ent/db/notificationevent"
	"github.com/openmeterio/openmeter/internal/ent/db/notificationeventdeliverystatus"
	"github.com/openmeterio/openmeter/internal/ent/db/notificationrule"
	"github.com/openmeterio/openmeter/internal/ent/db/predicate"
	"github.com/openmeterio/openmeter/internal/ent/db/usagereset"
	"github.com/openmeterio/openmeter/internal/notification"
	"github.com/openmeterio/openmeter/pkg/recurrence"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBalanceSnapshot                 = "BalanceSnapshot"
	TypeEntitlement                     = "Entitlement"
	TypeFeature                         = "Feature"
	TypeGrant                           = "Grant"
	TypeNotificationChannel             = "NotificationChannel"
	TypeNotificationEvent               = "NotificationEvent"
	TypeNotificationEventDeliveryStatus = "NotificationEventDeliveryStatus"
	TypeNotificationRule                = "NotificationRule"
	TypeUsageReset                      = "UsageReset"
)

// BalanceSnapshotMutation represents an operation that mutates the BalanceSnapshot nodes in the graph.
type BalanceSnapshotMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	namespace          *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	grant_balances     *balance.Map
	balance            *float64
	addbalance         *float64
	overage            *float64
	addoverage         *float64
	at                 *time.Time
	clearedFields      map[string]struct{}
	entitlement        *string
	clearedentitlement bool
	done               bool
	oldValue           func(context.Context) (*BalanceSnapshot, error)
	predicates         []predicate.BalanceSnapshot
}

var _ ent.Mutation = (*BalanceSnapshotMutation)(nil)

// balancesnapshotOption allows management of the mutation configuration using functional options.
type balancesnapshotOption func(*BalanceSnapshotMutation)

// newBalanceSnapshotMutation creates new mutation for the BalanceSnapshot entity.
func newBalanceSnapshotMutation(c config, op Op, opts ...balancesnapshotOption) *BalanceSnapshotMutation {
	m := &BalanceSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeBalanceSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBalanceSnapshotID sets the ID field of the mutation.
func withBalanceSnapshotID(id int) balancesnapshotOption {
	return func(m *BalanceSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *BalanceSnapshot
		)
		m.oldValue = func(ctx context.Context) (*BalanceSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BalanceSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBalanceSnapshot sets the old BalanceSnapshot of the mutation.
func withBalanceSnapshot(node *BalanceSnapshot) balancesnapshotOption {
	return func(m *BalanceSnapshotMutation) {
		m.oldValue = func(context.Context) (*BalanceSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BalanceSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BalanceSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BalanceSnapshotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BalanceSnapshotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BalanceSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BalanceSnapshotMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BalanceSnapshotMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BalanceSnapshotMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BalanceSnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BalanceSnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BalanceSnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BalanceSnapshotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BalanceSnapshotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BalanceSnapshotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BalanceSnapshotMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BalanceSnapshotMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BalanceSnapshotMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[balancesnapshot.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BalanceSnapshotMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[balancesnapshot.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BalanceSnapshotMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, balancesnapshot.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *BalanceSnapshotMutation) SetOwnerID(s string) {
	m.entitlement = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *BalanceSnapshotMutation) OwnerID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *BalanceSnapshotMutation) ResetOwnerID() {
	m.entitlement = nil
}

// SetGrantBalances sets the "grant_balances" field.
func (m *BalanceSnapshotMutation) SetGrantBalances(b balance.Map) {
	m.grant_balances = &b
}

// GrantBalances returns the value of the "grant_balances" field in the mutation.
func (m *BalanceSnapshotMutation) GrantBalances() (r balance.Map, exists bool) {
	v := m.grant_balances
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantBalances returns the old "grant_balances" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldGrantBalances(ctx context.Context) (v balance.Map, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantBalances is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantBalances requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantBalances: %w", err)
	}
	return oldValue.GrantBalances, nil
}

// ResetGrantBalances resets all changes to the "grant_balances" field.
func (m *BalanceSnapshotMutation) ResetGrantBalances() {
	m.grant_balances = nil
}

// SetBalance sets the "balance" field.
func (m *BalanceSnapshotMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *BalanceSnapshotMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *BalanceSnapshotMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *BalanceSnapshotMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *BalanceSnapshotMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetOverage sets the "overage" field.
func (m *BalanceSnapshotMutation) SetOverage(f float64) {
	m.overage = &f
	m.addoverage = nil
}

// Overage returns the value of the "overage" field in the mutation.
func (m *BalanceSnapshotMutation) Overage() (r float64, exists bool) {
	v := m.overage
	if v == nil {
		return
	}
	return *v, true
}

// OldOverage returns the old "overage" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldOverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverage: %w", err)
	}
	return oldValue.Overage, nil
}

// AddOverage adds f to the "overage" field.
func (m *BalanceSnapshotMutation) AddOverage(f float64) {
	if m.addoverage != nil {
		*m.addoverage += f
	} else {
		m.addoverage = &f
	}
}

// AddedOverage returns the value that was added to the "overage" field in this mutation.
func (m *BalanceSnapshotMutation) AddedOverage() (r float64, exists bool) {
	v := m.addoverage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverage resets all changes to the "overage" field.
func (m *BalanceSnapshotMutation) ResetOverage() {
	m.overage = nil
	m.addoverage = nil
}

// SetAt sets the "at" field.
func (m *BalanceSnapshotMutation) SetAt(t time.Time) {
	m.at = &t
}

// At returns the value of the "at" field in the mutation.
func (m *BalanceSnapshotMutation) At() (r time.Time, exists bool) {
	v := m.at
	if v == nil {
		return
	}
	return *v, true
}

// OldAt returns the old "at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAt: %w", err)
	}
	return oldValue.At, nil
}

// ResetAt resets all changes to the "at" field.
func (m *BalanceSnapshotMutation) ResetAt() {
	m.at = nil
}

// SetEntitlementID sets the "entitlement" edge to the Entitlement entity by id.
func (m *BalanceSnapshotMutation) SetEntitlementID(id string) {
	m.entitlement = &id
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *BalanceSnapshotMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[balancesnapshot.FieldOwnerID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *BalanceSnapshotMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementID returns the "entitlement" edge ID in the mutation.
func (m *BalanceSnapshotMutation) EntitlementID() (id string, exists bool) {
	if m.entitlement != nil {
		return *m.entitlement, true
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *BalanceSnapshotMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *BalanceSnapshotMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the BalanceSnapshotMutation builder.
func (m *BalanceSnapshotMutation) Where(ps ...predicate.BalanceSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BalanceSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BalanceSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BalanceSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BalanceSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BalanceSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BalanceSnapshot).
func (m *BalanceSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BalanceSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.namespace != nil {
		fields = append(fields, balancesnapshot.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, balancesnapshot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, balancesnapshot.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, balancesnapshot.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, balancesnapshot.FieldOwnerID)
	}
	if m.grant_balances != nil {
		fields = append(fields, balancesnapshot.FieldGrantBalances)
	}
	if m.balance != nil {
		fields = append(fields, balancesnapshot.FieldBalance)
	}
	if m.overage != nil {
		fields = append(fields, balancesnapshot.FieldOverage)
	}
	if m.at != nil {
		fields = append(fields, balancesnapshot.FieldAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BalanceSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case balancesnapshot.FieldNamespace:
		return m.Namespace()
	case balancesnapshot.FieldCreatedAt:
		return m.CreatedAt()
	case balancesnapshot.FieldUpdatedAt:
		return m.UpdatedAt()
	case balancesnapshot.FieldDeletedAt:
		return m.DeletedAt()
	case balancesnapshot.FieldOwnerID:
		return m.OwnerID()
	case balancesnapshot.FieldGrantBalances:
		return m.GrantBalances()
	case balancesnapshot.FieldBalance:
		return m.Balance()
	case balancesnapshot.FieldOverage:
		return m.Overage()
	case balancesnapshot.FieldAt:
		return m.At()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BalanceSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case balancesnapshot.FieldNamespace:
		return m.OldNamespace(ctx)
	case balancesnapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case balancesnapshot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case balancesnapshot.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case balancesnapshot.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case balancesnapshot.FieldGrantBalances:
		return m.OldGrantBalances(ctx)
	case balancesnapshot.FieldBalance:
		return m.OldBalance(ctx)
	case balancesnapshot.FieldOverage:
		return m.OldOverage(ctx)
	case balancesnapshot.FieldAt:
		return m.OldAt(ctx)
	}
	return nil, fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case balancesnapshot.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case balancesnapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case balancesnapshot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case balancesnapshot.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case balancesnapshot.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case balancesnapshot.FieldGrantBalances:
		v, ok := value.(balance.Map)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantBalances(v)
		return nil
	case balancesnapshot.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case balancesnapshot.FieldOverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverage(v)
		return nil
	case balancesnapshot.FieldAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAt(v)
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BalanceSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, balancesnapshot.FieldBalance)
	}
	if m.addoverage != nil {
		fields = append(fields, balancesnapshot.FieldOverage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BalanceSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case balancesnapshot.FieldBalance:
		return m.AddedBalance()
	case balancesnapshot.FieldOverage:
		return m.AddedOverage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case balancesnapshot.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case balancesnapshot.FieldOverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverage(v)
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BalanceSnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(balancesnapshot.FieldDeletedAt) {
		fields = append(fields, balancesnapshot.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BalanceSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BalanceSnapshotMutation) ClearField(name string) error {
	switch name {
	case balancesnapshot.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BalanceSnapshotMutation) ResetField(name string) error {
	switch name {
	case balancesnapshot.FieldNamespace:
		m.ResetNamespace()
		return nil
	case balancesnapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case balancesnapshot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case balancesnapshot.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case balancesnapshot.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case balancesnapshot.FieldGrantBalances:
		m.ResetGrantBalances()
		return nil
	case balancesnapshot.FieldBalance:
		m.ResetBalance()
		return nil
	case balancesnapshot.FieldOverage:
		m.ResetOverage()
		return nil
	case balancesnapshot.FieldAt:
		m.ResetAt()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BalanceSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, balancesnapshot.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BalanceSnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BalanceSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BalanceSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BalanceSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, balancesnapshot.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BalanceSnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BalanceSnapshotMutation) ClearEdge(name string) error {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BalanceSnapshotMutation) ResetEdge(name string) error {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot edge %s", name)
}

// EntitlementMutation represents an operation that mutates the Entitlement nodes in the graph.
type EntitlementMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	namespace                     *string
	metadata                      *map[string]string
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	entitlement_type              *entitlement.EntitlementType
	feature_key                   *string
	subject_key                   *string
	measure_usage_from            *time.Time
	issue_after_reset             *float64
	addissue_after_reset          *float64
	issue_after_reset_priority    *uint8
	addissue_after_reset_priority *int8
	is_soft_limit                 *bool
	preserve_overage_at_reset     *bool
	_config                       *[]uint8
	append_config                 []uint8
	usage_period_interval         *entitlement.UsagePeriodInterval
	usage_period_anchor           *time.Time
	current_usage_period_start    *time.Time
	current_usage_period_end      *time.Time
	clearedFields                 map[string]struct{}
	usage_reset                   map[string]struct{}
	removedusage_reset            map[string]struct{}
	clearedusage_reset            bool
	grant                         map[string]struct{}
	removedgrant                  map[string]struct{}
	clearedgrant                  bool
	balance_snapshot              map[int]struct{}
	removedbalance_snapshot       map[int]struct{}
	clearedbalance_snapshot       bool
	feature                       *string
	clearedfeature                bool
	done                          bool
	oldValue                      func(context.Context) (*Entitlement, error)
	predicates                    []predicate.Entitlement
}

var _ ent.Mutation = (*EntitlementMutation)(nil)

// entitlementOption allows management of the mutation configuration using functional options.
type entitlementOption func(*EntitlementMutation)

// newEntitlementMutation creates new mutation for the Entitlement entity.
func newEntitlementMutation(c config, op Op, opts ...entitlementOption) *EntitlementMutation {
	m := &EntitlementMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementID sets the ID field of the mutation.
func withEntitlementID(id string) entitlementOption {
	return func(m *EntitlementMutation) {
		var (
			err   error
			once  sync.Once
			value *Entitlement
		)
		m.oldValue = func(ctx context.Context) (*Entitlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entitlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlement sets the old Entitlement of the mutation.
func withEntitlement(node *Entitlement) entitlementOption {
	return func(m *EntitlementMutation) {
		m.oldValue = func(context.Context) (*Entitlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entitlement entities.
func (m *EntitlementMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entitlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *EntitlementMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *EntitlementMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *EntitlementMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *EntitlementMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EntitlementMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EntitlementMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[entitlement.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EntitlementMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EntitlementMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, entitlement.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitlementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitlementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitlementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitlement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitlementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitlementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitlement.FieldDeletedAt)
}

// SetEntitlementType sets the "entitlement_type" field.
func (m *EntitlementMutation) SetEntitlementType(et entitlement.EntitlementType) {
	m.entitlement_type = &et
}

// EntitlementType returns the value of the "entitlement_type" field in the mutation.
func (m *EntitlementMutation) EntitlementType() (r entitlement.EntitlementType, exists bool) {
	v := m.entitlement_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementType returns the old "entitlement_type" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldEntitlementType(ctx context.Context) (v entitlement.EntitlementType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementType: %w", err)
	}
	return oldValue.EntitlementType, nil
}

// ResetEntitlementType resets all changes to the "entitlement_type" field.
func (m *EntitlementMutation) ResetEntitlementType() {
	m.entitlement_type = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *EntitlementMutation) SetFeatureID(s string) {
	m.feature = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *EntitlementMutation) FeatureID() (r string, exists bool) {
	v := m.feature
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldFeatureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *EntitlementMutation) ResetFeatureID() {
	m.feature = nil
}

// SetFeatureKey sets the "feature_key" field.
func (m *EntitlementMutation) SetFeatureKey(s string) {
	m.feature_key = &s
}

// FeatureKey returns the value of the "feature_key" field in the mutation.
func (m *EntitlementMutation) FeatureKey() (r string, exists bool) {
	v := m.feature_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureKey returns the old "feature_key" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldFeatureKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureKey: %w", err)
	}
	return oldValue.FeatureKey, nil
}

// ResetFeatureKey resets all changes to the "feature_key" field.
func (m *EntitlementMutation) ResetFeatureKey() {
	m.feature_key = nil
}

// SetSubjectKey sets the "subject_key" field.
func (m *EntitlementMutation) SetSubjectKey(s string) {
	m.subject_key = &s
}

// SubjectKey returns the value of the "subject_key" field in the mutation.
func (m *EntitlementMutation) SubjectKey() (r string, exists bool) {
	v := m.subject_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectKey returns the old "subject_key" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldSubjectKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectKey: %w", err)
	}
	return oldValue.SubjectKey, nil
}

// ResetSubjectKey resets all changes to the "subject_key" field.
func (m *EntitlementMutation) ResetSubjectKey() {
	m.subject_key = nil
}

// SetMeasureUsageFrom sets the "measure_usage_from" field.
func (m *EntitlementMutation) SetMeasureUsageFrom(t time.Time) {
	m.measure_usage_from = &t
}

// MeasureUsageFrom returns the value of the "measure_usage_from" field in the mutation.
func (m *EntitlementMutation) MeasureUsageFrom() (r time.Time, exists bool) {
	v := m.measure_usage_from
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasureUsageFrom returns the old "measure_usage_from" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldMeasureUsageFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasureUsageFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasureUsageFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasureUsageFrom: %w", err)
	}
	return oldValue.MeasureUsageFrom, nil
}

// ClearMeasureUsageFrom clears the value of the "measure_usage_from" field.
func (m *EntitlementMutation) ClearMeasureUsageFrom() {
	m.measure_usage_from = nil
	m.clearedFields[entitlement.FieldMeasureUsageFrom] = struct{}{}
}

// MeasureUsageFromCleared returns if the "measure_usage_from" field was cleared in this mutation.
func (m *EntitlementMutation) MeasureUsageFromCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldMeasureUsageFrom]
	return ok
}

// ResetMeasureUsageFrom resets all changes to the "measure_usage_from" field.
func (m *EntitlementMutation) ResetMeasureUsageFrom() {
	m.measure_usage_from = nil
	delete(m.clearedFields, entitlement.FieldMeasureUsageFrom)
}

// SetIssueAfterReset sets the "issue_after_reset" field.
func (m *EntitlementMutation) SetIssueAfterReset(f float64) {
	m.issue_after_reset = &f
	m.addissue_after_reset = nil
}

// IssueAfterReset returns the value of the "issue_after_reset" field in the mutation.
func (m *EntitlementMutation) IssueAfterReset() (r float64, exists bool) {
	v := m.issue_after_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueAfterReset returns the old "issue_after_reset" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIssueAfterReset(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueAfterReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueAfterReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueAfterReset: %w", err)
	}
	return oldValue.IssueAfterReset, nil
}

// AddIssueAfterReset adds f to the "issue_after_reset" field.
func (m *EntitlementMutation) AddIssueAfterReset(f float64) {
	if m.addissue_after_reset != nil {
		*m.addissue_after_reset += f
	} else {
		m.addissue_after_reset = &f
	}
}

// AddedIssueAfterReset returns the value that was added to the "issue_after_reset" field in this mutation.
func (m *EntitlementMutation) AddedIssueAfterReset() (r float64, exists bool) {
	v := m.addissue_after_reset
	if v == nil {
		return
	}
	return *v, true
}

// ClearIssueAfterReset clears the value of the "issue_after_reset" field.
func (m *EntitlementMutation) ClearIssueAfterReset() {
	m.issue_after_reset = nil
	m.addissue_after_reset = nil
	m.clearedFields[entitlement.FieldIssueAfterReset] = struct{}{}
}

// IssueAfterResetCleared returns if the "issue_after_reset" field was cleared in this mutation.
func (m *EntitlementMutation) IssueAfterResetCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIssueAfterReset]
	return ok
}

// ResetIssueAfterReset resets all changes to the "issue_after_reset" field.
func (m *EntitlementMutation) ResetIssueAfterReset() {
	m.issue_after_reset = nil
	m.addissue_after_reset = nil
	delete(m.clearedFields, entitlement.FieldIssueAfterReset)
}

// SetIssueAfterResetPriority sets the "issue_after_reset_priority" field.
func (m *EntitlementMutation) SetIssueAfterResetPriority(u uint8) {
	m.issue_after_reset_priority = &u
	m.addissue_after_reset_priority = nil
}

// IssueAfterResetPriority returns the value of the "issue_after_reset_priority" field in the mutation.
func (m *EntitlementMutation) IssueAfterResetPriority() (r uint8, exists bool) {
	v := m.issue_after_reset_priority
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueAfterResetPriority returns the old "issue_after_reset_priority" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIssueAfterResetPriority(ctx context.Context) (v *uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueAfterResetPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueAfterResetPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueAfterResetPriority: %w", err)
	}
	return oldValue.IssueAfterResetPriority, nil
}

// AddIssueAfterResetPriority adds u to the "issue_after_reset_priority" field.
func (m *EntitlementMutation) AddIssueAfterResetPriority(u int8) {
	if m.addissue_after_reset_priority != nil {
		*m.addissue_after_reset_priority += u
	} else {
		m.addissue_after_reset_priority = &u
	}
}

// AddedIssueAfterResetPriority returns the value that was added to the "issue_after_reset_priority" field in this mutation.
func (m *EntitlementMutation) AddedIssueAfterResetPriority() (r int8, exists bool) {
	v := m.addissue_after_reset_priority
	if v == nil {
		return
	}
	return *v, true
}

// ClearIssueAfterResetPriority clears the value of the "issue_after_reset_priority" field.
func (m *EntitlementMutation) ClearIssueAfterResetPriority() {
	m.issue_after_reset_priority = nil
	m.addissue_after_reset_priority = nil
	m.clearedFields[entitlement.FieldIssueAfterResetPriority] = struct{}{}
}

// IssueAfterResetPriorityCleared returns if the "issue_after_reset_priority" field was cleared in this mutation.
func (m *EntitlementMutation) IssueAfterResetPriorityCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIssueAfterResetPriority]
	return ok
}

// ResetIssueAfterResetPriority resets all changes to the "issue_after_reset_priority" field.
func (m *EntitlementMutation) ResetIssueAfterResetPriority() {
	m.issue_after_reset_priority = nil
	m.addissue_after_reset_priority = nil
	delete(m.clearedFields, entitlement.FieldIssueAfterResetPriority)
}

// SetIsSoftLimit sets the "is_soft_limit" field.
func (m *EntitlementMutation) SetIsSoftLimit(b bool) {
	m.is_soft_limit = &b
}

// IsSoftLimit returns the value of the "is_soft_limit" field in the mutation.
func (m *EntitlementMutation) IsSoftLimit() (r bool, exists bool) {
	v := m.is_soft_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSoftLimit returns the old "is_soft_limit" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIsSoftLimit(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSoftLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSoftLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSoftLimit: %w", err)
	}
	return oldValue.IsSoftLimit, nil
}

// ClearIsSoftLimit clears the value of the "is_soft_limit" field.
func (m *EntitlementMutation) ClearIsSoftLimit() {
	m.is_soft_limit = nil
	m.clearedFields[entitlement.FieldIsSoftLimit] = struct{}{}
}

// IsSoftLimitCleared returns if the "is_soft_limit" field was cleared in this mutation.
func (m *EntitlementMutation) IsSoftLimitCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIsSoftLimit]
	return ok
}

// ResetIsSoftLimit resets all changes to the "is_soft_limit" field.
func (m *EntitlementMutation) ResetIsSoftLimit() {
	m.is_soft_limit = nil
	delete(m.clearedFields, entitlement.FieldIsSoftLimit)
}

// SetPreserveOverageAtReset sets the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) SetPreserveOverageAtReset(b bool) {
	m.preserve_overage_at_reset = &b
}

// PreserveOverageAtReset returns the value of the "preserve_overage_at_reset" field in the mutation.
func (m *EntitlementMutation) PreserveOverageAtReset() (r bool, exists bool) {
	v := m.preserve_overage_at_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldPreserveOverageAtReset returns the old "preserve_overage_at_reset" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldPreserveOverageAtReset(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreserveOverageAtReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreserveOverageAtReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreserveOverageAtReset: %w", err)
	}
	return oldValue.PreserveOverageAtReset, nil
}

// ClearPreserveOverageAtReset clears the value of the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) ClearPreserveOverageAtReset() {
	m.preserve_overage_at_reset = nil
	m.clearedFields[entitlement.FieldPreserveOverageAtReset] = struct{}{}
}

// PreserveOverageAtResetCleared returns if the "preserve_overage_at_reset" field was cleared in this mutation.
func (m *EntitlementMutation) PreserveOverageAtResetCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldPreserveOverageAtReset]
	return ok
}

// ResetPreserveOverageAtReset resets all changes to the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) ResetPreserveOverageAtReset() {
	m.preserve_overage_at_reset = nil
	delete(m.clearedFields, entitlement.FieldPreserveOverageAtReset)
}

// SetConfig sets the "config" field.
func (m *EntitlementMutation) SetConfig(u []uint8) {
	m._config = &u
	m.append_config = nil
}

// Config returns the value of the "config" field in the mutation.
func (m *EntitlementMutation) Config() (r []uint8, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldConfig(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// AppendConfig adds u to the "config" field.
func (m *EntitlementMutation) AppendConfig(u []uint8) {
	m.append_config = append(m.append_config, u...)
}

// AppendedConfig returns the list of values that were appended to the "config" field in this mutation.
func (m *EntitlementMutation) AppendedConfig() ([]uint8, bool) {
	if len(m.append_config) == 0 {
		return nil, false
	}
	return m.append_config, true
}

// ClearConfig clears the value of the "config" field.
func (m *EntitlementMutation) ClearConfig() {
	m._config = nil
	m.append_config = nil
	m.clearedFields[entitlement.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *EntitlementMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *EntitlementMutation) ResetConfig() {
	m._config = nil
	m.append_config = nil
	delete(m.clearedFields, entitlement.FieldConfig)
}

// SetUsagePeriodInterval sets the "usage_period_interval" field.
func (m *EntitlementMutation) SetUsagePeriodInterval(epi entitlement.UsagePeriodInterval) {
	m.usage_period_interval = &epi
}

// UsagePeriodInterval returns the value of the "usage_period_interval" field in the mutation.
func (m *EntitlementMutation) UsagePeriodInterval() (r entitlement.UsagePeriodInterval, exists bool) {
	v := m.usage_period_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldUsagePeriodInterval returns the old "usage_period_interval" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUsagePeriodInterval(ctx context.Context) (v *entitlement.UsagePeriodInterval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsagePeriodInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsagePeriodInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsagePeriodInterval: %w", err)
	}
	return oldValue.UsagePeriodInterval, nil
}

// ClearUsagePeriodInterval clears the value of the "usage_period_interval" field.
func (m *EntitlementMutation) ClearUsagePeriodInterval() {
	m.usage_period_interval = nil
	m.clearedFields[entitlement.FieldUsagePeriodInterval] = struct{}{}
}

// UsagePeriodIntervalCleared returns if the "usage_period_interval" field was cleared in this mutation.
func (m *EntitlementMutation) UsagePeriodIntervalCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldUsagePeriodInterval]
	return ok
}

// ResetUsagePeriodInterval resets all changes to the "usage_period_interval" field.
func (m *EntitlementMutation) ResetUsagePeriodInterval() {
	m.usage_period_interval = nil
	delete(m.clearedFields, entitlement.FieldUsagePeriodInterval)
}

// SetUsagePeriodAnchor sets the "usage_period_anchor" field.
func (m *EntitlementMutation) SetUsagePeriodAnchor(t time.Time) {
	m.usage_period_anchor = &t
}

// UsagePeriodAnchor returns the value of the "usage_period_anchor" field in the mutation.
func (m *EntitlementMutation) UsagePeriodAnchor() (r time.Time, exists bool) {
	v := m.usage_period_anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldUsagePeriodAnchor returns the old "usage_period_anchor" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUsagePeriodAnchor(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsagePeriodAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsagePeriodAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsagePeriodAnchor: %w", err)
	}
	return oldValue.UsagePeriodAnchor, nil
}

// ClearUsagePeriodAnchor clears the value of the "usage_period_anchor" field.
func (m *EntitlementMutation) ClearUsagePeriodAnchor() {
	m.usage_period_anchor = nil
	m.clearedFields[entitlement.FieldUsagePeriodAnchor] = struct{}{}
}

// UsagePeriodAnchorCleared returns if the "usage_period_anchor" field was cleared in this mutation.
func (m *EntitlementMutation) UsagePeriodAnchorCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldUsagePeriodAnchor]
	return ok
}

// ResetUsagePeriodAnchor resets all changes to the "usage_period_anchor" field.
func (m *EntitlementMutation) ResetUsagePeriodAnchor() {
	m.usage_period_anchor = nil
	delete(m.clearedFields, entitlement.FieldUsagePeriodAnchor)
}

// SetCurrentUsagePeriodStart sets the "current_usage_period_start" field.
func (m *EntitlementMutation) SetCurrentUsagePeriodStart(t time.Time) {
	m.current_usage_period_start = &t
}

// CurrentUsagePeriodStart returns the value of the "current_usage_period_start" field in the mutation.
func (m *EntitlementMutation) CurrentUsagePeriodStart() (r time.Time, exists bool) {
	v := m.current_usage_period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentUsagePeriodStart returns the old "current_usage_period_start" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCurrentUsagePeriodStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentUsagePeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentUsagePeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentUsagePeriodStart: %w", err)
	}
	return oldValue.CurrentUsagePeriodStart, nil
}

// ClearCurrentUsagePeriodStart clears the value of the "current_usage_period_start" field.
func (m *EntitlementMutation) ClearCurrentUsagePeriodStart() {
	m.current_usage_period_start = nil
	m.clearedFields[entitlement.FieldCurrentUsagePeriodStart] = struct{}{}
}

// CurrentUsagePeriodStartCleared returns if the "current_usage_period_start" field was cleared in this mutation.
func (m *EntitlementMutation) CurrentUsagePeriodStartCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldCurrentUsagePeriodStart]
	return ok
}

// ResetCurrentUsagePeriodStart resets all changes to the "current_usage_period_start" field.
func (m *EntitlementMutation) ResetCurrentUsagePeriodStart() {
	m.current_usage_period_start = nil
	delete(m.clearedFields, entitlement.FieldCurrentUsagePeriodStart)
}

// SetCurrentUsagePeriodEnd sets the "current_usage_period_end" field.
func (m *EntitlementMutation) SetCurrentUsagePeriodEnd(t time.Time) {
	m.current_usage_period_end = &t
}

// CurrentUsagePeriodEnd returns the value of the "current_usage_period_end" field in the mutation.
func (m *EntitlementMutation) CurrentUsagePeriodEnd() (r time.Time, exists bool) {
	v := m.current_usage_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentUsagePeriodEnd returns the old "current_usage_period_end" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCurrentUsagePeriodEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentUsagePeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentUsagePeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentUsagePeriodEnd: %w", err)
	}
	return oldValue.CurrentUsagePeriodEnd, nil
}

// ClearCurrentUsagePeriodEnd clears the value of the "current_usage_period_end" field.
func (m *EntitlementMutation) ClearCurrentUsagePeriodEnd() {
	m.current_usage_period_end = nil
	m.clearedFields[entitlement.FieldCurrentUsagePeriodEnd] = struct{}{}
}

// CurrentUsagePeriodEndCleared returns if the "current_usage_period_end" field was cleared in this mutation.
func (m *EntitlementMutation) CurrentUsagePeriodEndCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldCurrentUsagePeriodEnd]
	return ok
}

// ResetCurrentUsagePeriodEnd resets all changes to the "current_usage_period_end" field.
func (m *EntitlementMutation) ResetCurrentUsagePeriodEnd() {
	m.current_usage_period_end = nil
	delete(m.clearedFields, entitlement.FieldCurrentUsagePeriodEnd)
}

// AddUsageResetIDs adds the "usage_reset" edge to the UsageReset entity by ids.
func (m *EntitlementMutation) AddUsageResetIDs(ids ...string) {
	if m.usage_reset == nil {
		m.usage_reset = make(map[string]struct{})
	}
	for i := range ids {
		m.usage_reset[ids[i]] = struct{}{}
	}
}

// ClearUsageReset clears the "usage_reset" edge to the UsageReset entity.
func (m *EntitlementMutation) ClearUsageReset() {
	m.clearedusage_reset = true
}

// UsageResetCleared reports if the "usage_reset" edge to the UsageReset entity was cleared.
func (m *EntitlementMutation) UsageResetCleared() bool {
	return m.clearedusage_reset
}

// RemoveUsageResetIDs removes the "usage_reset" edge to the UsageReset entity by IDs.
func (m *EntitlementMutation) RemoveUsageResetIDs(ids ...string) {
	if m.removedusage_reset == nil {
		m.removedusage_reset = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.usage_reset, ids[i])
		m.removedusage_reset[ids[i]] = struct{}{}
	}
}

// RemovedUsageReset returns the removed IDs of the "usage_reset" edge to the UsageReset entity.
func (m *EntitlementMutation) RemovedUsageResetIDs() (ids []string) {
	for id := range m.removedusage_reset {
		ids = append(ids, id)
	}
	return
}

// UsageResetIDs returns the "usage_reset" edge IDs in the mutation.
func (m *EntitlementMutation) UsageResetIDs() (ids []string) {
	for id := range m.usage_reset {
		ids = append(ids, id)
	}
	return
}

// ResetUsageReset resets all changes to the "usage_reset" edge.
func (m *EntitlementMutation) ResetUsageReset() {
	m.usage_reset = nil
	m.clearedusage_reset = false
	m.removedusage_reset = nil
}

// AddGrantIDs adds the "grant" edge to the Grant entity by ids.
func (m *EntitlementMutation) AddGrantIDs(ids ...string) {
	if m.grant == nil {
		m.grant = make(map[string]struct{})
	}
	for i := range ids {
		m.grant[ids[i]] = struct{}{}
	}
}

// ClearGrant clears the "grant" edge to the Grant entity.
func (m *EntitlementMutation) ClearGrant() {
	m.clearedgrant = true
}

// GrantCleared reports if the "grant" edge to the Grant entity was cleared.
func (m *EntitlementMutation) GrantCleared() bool {
	return m.clearedgrant
}

// RemoveGrantIDs removes the "grant" edge to the Grant entity by IDs.
func (m *EntitlementMutation) RemoveGrantIDs(ids ...string) {
	if m.removedgrant == nil {
		m.removedgrant = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.grant, ids[i])
		m.removedgrant[ids[i]] = struct{}{}
	}
}

// RemovedGrant returns the removed IDs of the "grant" edge to the Grant entity.
func (m *EntitlementMutation) RemovedGrantIDs() (ids []string) {
	for id := range m.removedgrant {
		ids = append(ids, id)
	}
	return
}

// GrantIDs returns the "grant" edge IDs in the mutation.
func (m *EntitlementMutation) GrantIDs() (ids []string) {
	for id := range m.grant {
		ids = append(ids, id)
	}
	return
}

// ResetGrant resets all changes to the "grant" edge.
func (m *EntitlementMutation) ResetGrant() {
	m.grant = nil
	m.clearedgrant = false
	m.removedgrant = nil
}

// AddBalanceSnapshotIDs adds the "balance_snapshot" edge to the BalanceSnapshot entity by ids.
func (m *EntitlementMutation) AddBalanceSnapshotIDs(ids ...int) {
	if m.balance_snapshot == nil {
		m.balance_snapshot = make(map[int]struct{})
	}
	for i := range ids {
		m.balance_snapshot[ids[i]] = struct{}{}
	}
}

// ClearBalanceSnapshot clears the "balance_snapshot" edge to the BalanceSnapshot entity.
func (m *EntitlementMutation) ClearBalanceSnapshot() {
	m.clearedbalance_snapshot = true
}

// BalanceSnapshotCleared reports if the "balance_snapshot" edge to the BalanceSnapshot entity was cleared.
func (m *EntitlementMutation) BalanceSnapshotCleared() bool {
	return m.clearedbalance_snapshot
}

// RemoveBalanceSnapshotIDs removes the "balance_snapshot" edge to the BalanceSnapshot entity by IDs.
func (m *EntitlementMutation) RemoveBalanceSnapshotIDs(ids ...int) {
	if m.removedbalance_snapshot == nil {
		m.removedbalance_snapshot = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.balance_snapshot, ids[i])
		m.removedbalance_snapshot[ids[i]] = struct{}{}
	}
}

// RemovedBalanceSnapshot returns the removed IDs of the "balance_snapshot" edge to the BalanceSnapshot entity.
func (m *EntitlementMutation) RemovedBalanceSnapshotIDs() (ids []int) {
	for id := range m.removedbalance_snapshot {
		ids = append(ids, id)
	}
	return
}

// BalanceSnapshotIDs returns the "balance_snapshot" edge IDs in the mutation.
func (m *EntitlementMutation) BalanceSnapshotIDs() (ids []int) {
	for id := range m.balance_snapshot {
		ids = append(ids, id)
	}
	return
}

// ResetBalanceSnapshot resets all changes to the "balance_snapshot" edge.
func (m *EntitlementMutation) ResetBalanceSnapshot() {
	m.balance_snapshot = nil
	m.clearedbalance_snapshot = false
	m.removedbalance_snapshot = nil
}

// ClearFeature clears the "feature" edge to the Feature entity.
func (m *EntitlementMutation) ClearFeature() {
	m.clearedfeature = true
	m.clearedFields[entitlement.FieldFeatureID] = struct{}{}
}

// FeatureCleared reports if the "feature" edge to the Feature entity was cleared.
func (m *EntitlementMutation) FeatureCleared() bool {
	return m.clearedfeature
}

// FeatureIDs returns the "feature" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureID instead. It exists only for internal usage by the builders.
func (m *EntitlementMutation) FeatureIDs() (ids []string) {
	if id := m.feature; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeature resets all changes to the "feature" edge.
func (m *EntitlementMutation) ResetFeature() {
	m.feature = nil
	m.clearedfeature = false
}

// Where appends a list predicates to the EntitlementMutation builder.
func (m *EntitlementMutation) Where(ps ...predicate.Entitlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entitlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entitlement).
func (m *EntitlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.namespace != nil {
		fields = append(fields, entitlement.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, entitlement.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, entitlement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitlement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitlement.FieldDeletedAt)
	}
	if m.entitlement_type != nil {
		fields = append(fields, entitlement.FieldEntitlementType)
	}
	if m.feature != nil {
		fields = append(fields, entitlement.FieldFeatureID)
	}
	if m.feature_key != nil {
		fields = append(fields, entitlement.FieldFeatureKey)
	}
	if m.subject_key != nil {
		fields = append(fields, entitlement.FieldSubjectKey)
	}
	if m.measure_usage_from != nil {
		fields = append(fields, entitlement.FieldMeasureUsageFrom)
	}
	if m.issue_after_reset != nil {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.issue_after_reset_priority != nil {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	if m.is_soft_limit != nil {
		fields = append(fields, entitlement.FieldIsSoftLimit)
	}
	if m.preserve_overage_at_reset != nil {
		fields = append(fields, entitlement.FieldPreserveOverageAtReset)
	}
	if m._config != nil {
		fields = append(fields, entitlement.FieldConfig)
	}
	if m.usage_period_interval != nil {
		fields = append(fields, entitlement.FieldUsagePeriodInterval)
	}
	if m.usage_period_anchor != nil {
		fields = append(fields, entitlement.FieldUsagePeriodAnchor)
	}
	if m.current_usage_period_start != nil {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodStart)
	}
	if m.current_usage_period_end != nil {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodEnd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlement.FieldNamespace:
		return m.Namespace()
	case entitlement.FieldMetadata:
		return m.Metadata()
	case entitlement.FieldCreatedAt:
		return m.CreatedAt()
	case entitlement.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitlement.FieldDeletedAt:
		return m.DeletedAt()
	case entitlement.FieldEntitlementType:
		return m.EntitlementType()
	case entitlement.FieldFeatureID:
		return m.FeatureID()
	case entitlement.FieldFeatureKey:
		return m.FeatureKey()
	case entitlement.FieldSubjectKey:
		return m.SubjectKey()
	case entitlement.FieldMeasureUsageFrom:
		return m.MeasureUsageFrom()
	case entitlement.FieldIssueAfterReset:
		return m.IssueAfterReset()
	case entitlement.FieldIssueAfterResetPriority:
		return m.IssueAfterResetPriority()
	case entitlement.FieldIsSoftLimit:
		return m.IsSoftLimit()
	case entitlement.FieldPreserveOverageAtReset:
		return m.PreserveOverageAtReset()
	case entitlement.FieldConfig:
		return m.Config()
	case entitlement.FieldUsagePeriodInterval:
		return m.UsagePeriodInterval()
	case entitlement.FieldUsagePeriodAnchor:
		return m.UsagePeriodAnchor()
	case entitlement.FieldCurrentUsagePeriodStart:
		return m.CurrentUsagePeriodStart()
	case entitlement.FieldCurrentUsagePeriodEnd:
		return m.CurrentUsagePeriodEnd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlement.FieldNamespace:
		return m.OldNamespace(ctx)
	case entitlement.FieldMetadata:
		return m.OldMetadata(ctx)
	case entitlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitlement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitlement.FieldEntitlementType:
		return m.OldEntitlementType(ctx)
	case entitlement.FieldFeatureID:
		return m.OldFeatureID(ctx)
	case entitlement.FieldFeatureKey:
		return m.OldFeatureKey(ctx)
	case entitlement.FieldSubjectKey:
		return m.OldSubjectKey(ctx)
	case entitlement.FieldMeasureUsageFrom:
		return m.OldMeasureUsageFrom(ctx)
	case entitlement.FieldIssueAfterReset:
		return m.OldIssueAfterReset(ctx)
	case entitlement.FieldIssueAfterResetPriority:
		return m.OldIssueAfterResetPriority(ctx)
	case entitlement.FieldIsSoftLimit:
		return m.OldIsSoftLimit(ctx)
	case entitlement.FieldPreserveOverageAtReset:
		return m.OldPreserveOverageAtReset(ctx)
	case entitlement.FieldConfig:
		return m.OldConfig(ctx)
	case entitlement.FieldUsagePeriodInterval:
		return m.OldUsagePeriodInterval(ctx)
	case entitlement.FieldUsagePeriodAnchor:
		return m.OldUsagePeriodAnchor(ctx)
	case entitlement.FieldCurrentUsagePeriodStart:
		return m.OldCurrentUsagePeriodStart(ctx)
	case entitlement.FieldCurrentUsagePeriodEnd:
		return m.OldCurrentUsagePeriodEnd(ctx)
	}
	return nil, fmt.Errorf("unknown Entitlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlement.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case entitlement.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case entitlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitlement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitlement.FieldEntitlementType:
		v, ok := value.(entitlement.EntitlementType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementType(v)
		return nil
	case entitlement.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	case entitlement.FieldFeatureKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureKey(v)
		return nil
	case entitlement.FieldSubjectKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectKey(v)
		return nil
	case entitlement.FieldMeasureUsageFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasureUsageFrom(v)
		return nil
	case entitlement.FieldIssueAfterReset:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueAfterReset(v)
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueAfterResetPriority(v)
		return nil
	case entitlement.FieldIsSoftLimit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSoftLimit(v)
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreserveOverageAtReset(v)
		return nil
	case entitlement.FieldConfig:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case entitlement.FieldUsagePeriodInterval:
		v, ok := value.(entitlement.UsagePeriodInterval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsagePeriodInterval(v)
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsagePeriodAnchor(v)
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentUsagePeriodStart(v)
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentUsagePeriodEnd(v)
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementMutation) AddedFields() []string {
	var fields []string
	if m.addissue_after_reset != nil {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.addissue_after_reset_priority != nil {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entitlement.FieldIssueAfterReset:
		return m.AddedIssueAfterReset()
	case entitlement.FieldIssueAfterResetPriority:
		return m.AddedIssueAfterResetPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entitlement.FieldIssueAfterReset:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIssueAfterReset(v)
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIssueAfterResetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Entitlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlement.FieldMetadata) {
		fields = append(fields, entitlement.FieldMetadata)
	}
	if m.FieldCleared(entitlement.FieldDeletedAt) {
		fields = append(fields, entitlement.FieldDeletedAt)
	}
	if m.FieldCleared(entitlement.FieldMeasureUsageFrom) {
		fields = append(fields, entitlement.FieldMeasureUsageFrom)
	}
	if m.FieldCleared(entitlement.FieldIssueAfterReset) {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.FieldCleared(entitlement.FieldIssueAfterResetPriority) {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	if m.FieldCleared(entitlement.FieldIsSoftLimit) {
		fields = append(fields, entitlement.FieldIsSoftLimit)
	}
	if m.FieldCleared(entitlement.FieldPreserveOverageAtReset) {
		fields = append(fields, entitlement.FieldPreserveOverageAtReset)
	}
	if m.FieldCleared(entitlement.FieldConfig) {
		fields = append(fields, entitlement.FieldConfig)
	}
	if m.FieldCleared(entitlement.FieldUsagePeriodInterval) {
		fields = append(fields, entitlement.FieldUsagePeriodInterval)
	}
	if m.FieldCleared(entitlement.FieldUsagePeriodAnchor) {
		fields = append(fields, entitlement.FieldUsagePeriodAnchor)
	}
	if m.FieldCleared(entitlement.FieldCurrentUsagePeriodStart) {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodStart)
	}
	if m.FieldCleared(entitlement.FieldCurrentUsagePeriodEnd) {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodEnd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementMutation) ClearField(name string) error {
	switch name {
	case entitlement.FieldMetadata:
		m.ClearMetadata()
		return nil
	case entitlement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitlement.FieldMeasureUsageFrom:
		m.ClearMeasureUsageFrom()
		return nil
	case entitlement.FieldIssueAfterReset:
		m.ClearIssueAfterReset()
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		m.ClearIssueAfterResetPriority()
		return nil
	case entitlement.FieldIsSoftLimit:
		m.ClearIsSoftLimit()
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		m.ClearPreserveOverageAtReset()
		return nil
	case entitlement.FieldConfig:
		m.ClearConfig()
		return nil
	case entitlement.FieldUsagePeriodInterval:
		m.ClearUsagePeriodInterval()
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		m.ClearUsagePeriodAnchor()
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		m.ClearCurrentUsagePeriodStart()
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		m.ClearCurrentUsagePeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown Entitlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementMutation) ResetField(name string) error {
	switch name {
	case entitlement.FieldNamespace:
		m.ResetNamespace()
		return nil
	case entitlement.FieldMetadata:
		m.ResetMetadata()
		return nil
	case entitlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitlement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitlement.FieldEntitlementType:
		m.ResetEntitlementType()
		return nil
	case entitlement.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	case entitlement.FieldFeatureKey:
		m.ResetFeatureKey()
		return nil
	case entitlement.FieldSubjectKey:
		m.ResetSubjectKey()
		return nil
	case entitlement.FieldMeasureUsageFrom:
		m.ResetMeasureUsageFrom()
		return nil
	case entitlement.FieldIssueAfterReset:
		m.ResetIssueAfterReset()
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		m.ResetIssueAfterResetPriority()
		return nil
	case entitlement.FieldIsSoftLimit:
		m.ResetIsSoftLimit()
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		m.ResetPreserveOverageAtReset()
		return nil
	case entitlement.FieldConfig:
		m.ResetConfig()
		return nil
	case entitlement.FieldUsagePeriodInterval:
		m.ResetUsagePeriodInterval()
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		m.ResetUsagePeriodAnchor()
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		m.ResetCurrentUsagePeriodStart()
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		m.ResetCurrentUsagePeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.usage_reset != nil {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.grant != nil {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.balance_snapshot != nil {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	if m.feature != nil {
		edges = append(edges, entitlement.EdgeFeature)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgeUsageReset:
		ids := make([]ent.Value, 0, len(m.usage_reset))
		for id := range m.usage_reset {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeGrant:
		ids := make([]ent.Value, 0, len(m.grant))
		for id := range m.grant {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeBalanceSnapshot:
		ids := make([]ent.Value, 0, len(m.balance_snapshot))
		for id := range m.balance_snapshot {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeFeature:
		if id := m.feature; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedusage_reset != nil {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.removedgrant != nil {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.removedbalance_snapshot != nil {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgeUsageReset:
		ids := make([]ent.Value, 0, len(m.removedusage_reset))
		for id := range m.removedusage_reset {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeGrant:
		ids := make([]ent.Value, 0, len(m.removedgrant))
		for id := range m.removedgrant {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeBalanceSnapshot:
		ids := make([]ent.Value, 0, len(m.removedbalance_snapshot))
		for id := range m.removedbalance_snapshot {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedusage_reset {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.clearedgrant {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.clearedbalance_snapshot {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	if m.clearedfeature {
		edges = append(edges, entitlement.EdgeFeature)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementMutation) EdgeCleared(name string) bool {
	switch name {
	case entitlement.EdgeUsageReset:
		return m.clearedusage_reset
	case entitlement.EdgeGrant:
		return m.clearedgrant
	case entitlement.EdgeBalanceSnapshot:
		return m.clearedbalance_snapshot
	case entitlement.EdgeFeature:
		return m.clearedfeature
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementMutation) ClearEdge(name string) error {
	switch name {
	case entitlement.EdgeFeature:
		m.ClearFeature()
		return nil
	}
	return fmt.Errorf("unknown Entitlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementMutation) ResetEdge(name string) error {
	switch name {
	case entitlement.EdgeUsageReset:
		m.ResetUsageReset()
		return nil
	case entitlement.EdgeGrant:
		m.ResetGrant()
		return nil
	case entitlement.EdgeBalanceSnapshot:
		m.ResetBalanceSnapshot()
		return nil
	case entitlement.EdgeFeature:
		m.ResetFeature()
		return nil
	}
	return fmt.Errorf("unknown Entitlement edge %s", name)
}

// FeatureMutation represents an operation that mutates the Feature nodes in the graph.
type FeatureMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	metadata               *map[string]string
	namespace              *string
	name                   *string
	key                    *string
	meter_slug             *string
	meter_group_by_filters *map[string]string
	archived_at            *time.Time
	clearedFields          map[string]struct{}
	entitlement            map[string]struct{}
	removedentitlement     map[string]struct{}
	clearedentitlement     bool
	done                   bool
	oldValue               func(context.Context) (*Feature, error)
	predicates             []predicate.Feature
}

var _ ent.Mutation = (*FeatureMutation)(nil)

// featureOption allows management of the mutation configuration using functional options.
type featureOption func(*FeatureMutation)

// newFeatureMutation creates new mutation for the Feature entity.
func newFeatureMutation(c config, op Op, opts ...featureOption) *FeatureMutation {
	m := &FeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureID sets the ID field of the mutation.
func withFeatureID(id string) featureOption {
	return func(m *FeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *Feature
		)
		m.oldValue = func(ctx context.Context) (*Feature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeature sets the old Feature of the mutation.
func withFeature(node *Feature) featureOption {
	return func(m *FeatureMutation) {
		m.oldValue = func(context.Context) (*Feature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feature entities.
func (m *FeatureMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeatureMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeatureMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeatureMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[feature.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeatureMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeatureMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, feature.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *FeatureMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *FeatureMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *FeatureMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[feature.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *FeatureMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[feature.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *FeatureMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, feature.FieldMetadata)
}

// SetNamespace sets the "namespace" field.
func (m *FeatureMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *FeatureMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *FeatureMutation) ResetNamespace() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *FeatureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *FeatureMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *FeatureMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *FeatureMutation) ResetKey() {
	m.key = nil
}

// SetMeterSlug sets the "meter_slug" field.
func (m *FeatureMutation) SetMeterSlug(s string) {
	m.meter_slug = &s
}

// MeterSlug returns the value of the "meter_slug" field in the mutation.
func (m *FeatureMutation) MeterSlug() (r string, exists bool) {
	v := m.meter_slug
	if v == nil {
		return
	}
	return *v, true
}

// OldMeterSlug returns the old "meter_slug" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMeterSlug(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeterSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeterSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeterSlug: %w", err)
	}
	return oldValue.MeterSlug, nil
}

// ClearMeterSlug clears the value of the "meter_slug" field.
func (m *FeatureMutation) ClearMeterSlug() {
	m.meter_slug = nil
	m.clearedFields[feature.FieldMeterSlug] = struct{}{}
}

// MeterSlugCleared returns if the "meter_slug" field was cleared in this mutation.
func (m *FeatureMutation) MeterSlugCleared() bool {
	_, ok := m.clearedFields[feature.FieldMeterSlug]
	return ok
}

// ResetMeterSlug resets all changes to the "meter_slug" field.
func (m *FeatureMutation) ResetMeterSlug() {
	m.meter_slug = nil
	delete(m.clearedFields, feature.FieldMeterSlug)
}

// SetMeterGroupByFilters sets the "meter_group_by_filters" field.
func (m *FeatureMutation) SetMeterGroupByFilters(value map[string]string) {
	m.meter_group_by_filters = &value
}

// MeterGroupByFilters returns the value of the "meter_group_by_filters" field in the mutation.
func (m *FeatureMutation) MeterGroupByFilters() (r map[string]string, exists bool) {
	v := m.meter_group_by_filters
	if v == nil {
		return
	}
	return *v, true
}

// OldMeterGroupByFilters returns the old "meter_group_by_filters" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMeterGroupByFilters(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeterGroupByFilters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeterGroupByFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeterGroupByFilters: %w", err)
	}
	return oldValue.MeterGroupByFilters, nil
}

// ClearMeterGroupByFilters clears the value of the "meter_group_by_filters" field.
func (m *FeatureMutation) ClearMeterGroupByFilters() {
	m.meter_group_by_filters = nil
	m.clearedFields[feature.FieldMeterGroupByFilters] = struct{}{}
}

// MeterGroupByFiltersCleared returns if the "meter_group_by_filters" field was cleared in this mutation.
func (m *FeatureMutation) MeterGroupByFiltersCleared() bool {
	_, ok := m.clearedFields[feature.FieldMeterGroupByFilters]
	return ok
}

// ResetMeterGroupByFilters resets all changes to the "meter_group_by_filters" field.
func (m *FeatureMutation) ResetMeterGroupByFilters() {
	m.meter_group_by_filters = nil
	delete(m.clearedFields, feature.FieldMeterGroupByFilters)
}

// SetArchivedAt sets the "archived_at" field.
func (m *FeatureMutation) SetArchivedAt(t time.Time) {
	m.archived_at = &t
}

// ArchivedAt returns the value of the "archived_at" field in the mutation.
func (m *FeatureMutation) ArchivedAt() (r time.Time, exists bool) {
	v := m.archived_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedAt returns the old "archived_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldArchivedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedAt: %w", err)
	}
	return oldValue.ArchivedAt, nil
}

// ClearArchivedAt clears the value of the "archived_at" field.
func (m *FeatureMutation) ClearArchivedAt() {
	m.archived_at = nil
	m.clearedFields[feature.FieldArchivedAt] = struct{}{}
}

// ArchivedAtCleared returns if the "archived_at" field was cleared in this mutation.
func (m *FeatureMutation) ArchivedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldArchivedAt]
	return ok
}

// ResetArchivedAt resets all changes to the "archived_at" field.
func (m *FeatureMutation) ResetArchivedAt() {
	m.archived_at = nil
	delete(m.clearedFields, feature.FieldArchivedAt)
}

// AddEntitlementIDs adds the "entitlement" edge to the Entitlement entity by ids.
func (m *FeatureMutation) AddEntitlementIDs(ids ...string) {
	if m.entitlement == nil {
		m.entitlement = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlement[ids[i]] = struct{}{}
	}
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *FeatureMutation) ClearEntitlement() {
	m.clearedentitlement = true
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *FeatureMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// RemoveEntitlementIDs removes the "entitlement" edge to the Entitlement entity by IDs.
func (m *FeatureMutation) RemoveEntitlementIDs(ids ...string) {
	if m.removedentitlement == nil {
		m.removedentitlement = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlement, ids[i])
		m.removedentitlement[ids[i]] = struct{}{}
	}
}

// RemovedEntitlement returns the removed IDs of the "entitlement" edge to the Entitlement entity.
func (m *FeatureMutation) RemovedEntitlementIDs() (ids []string) {
	for id := range m.removedentitlement {
		ids = append(ids, id)
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
func (m *FeatureMutation) EntitlementIDs() (ids []string) {
	for id := range m.entitlement {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *FeatureMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
	m.removedentitlement = nil
}

// Where appends a list predicates to the FeatureMutation builder.
func (m *FeatureMutation) Where(ps ...predicate.Feature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feature).
func (m *FeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, feature.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feature.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, feature.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, feature.FieldMetadata)
	}
	if m.namespace != nil {
		fields = append(fields, feature.FieldNamespace)
	}
	if m.name != nil {
		fields = append(fields, feature.FieldName)
	}
	if m.key != nil {
		fields = append(fields, feature.FieldKey)
	}
	if m.meter_slug != nil {
		fields = append(fields, feature.FieldMeterSlug)
	}
	if m.meter_group_by_filters != nil {
		fields = append(fields, feature.FieldMeterGroupByFilters)
	}
	if m.archived_at != nil {
		fields = append(fields, feature.FieldArchivedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feature.FieldCreatedAt:
		return m.CreatedAt()
	case feature.FieldUpdatedAt:
		return m.UpdatedAt()
	case feature.FieldDeletedAt:
		return m.DeletedAt()
	case feature.FieldMetadata:
		return m.Metadata()
	case feature.FieldNamespace:
		return m.Namespace()
	case feature.FieldName:
		return m.Name()
	case feature.FieldKey:
		return m.Key()
	case feature.FieldMeterSlug:
		return m.MeterSlug()
	case feature.FieldMeterGroupByFilters:
		return m.MeterGroupByFilters()
	case feature.FieldArchivedAt:
		return m.ArchivedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feature.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feature.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case feature.FieldMetadata:
		return m.OldMetadata(ctx)
	case feature.FieldNamespace:
		return m.OldNamespace(ctx)
	case feature.FieldName:
		return m.OldName(ctx)
	case feature.FieldKey:
		return m.OldKey(ctx)
	case feature.FieldMeterSlug:
		return m.OldMeterSlug(ctx)
	case feature.FieldMeterGroupByFilters:
		return m.OldMeterGroupByFilters(ctx)
	case feature.FieldArchivedAt:
		return m.OldArchivedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Feature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feature.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feature.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case feature.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case feature.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case feature.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feature.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case feature.FieldMeterSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeterSlug(v)
		return nil
	case feature.FieldMeterGroupByFilters:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeterGroupByFilters(v)
		return nil
	case feature.FieldArchivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feature.FieldDeletedAt) {
		fields = append(fields, feature.FieldDeletedAt)
	}
	if m.FieldCleared(feature.FieldMetadata) {
		fields = append(fields, feature.FieldMetadata)
	}
	if m.FieldCleared(feature.FieldMeterSlug) {
		fields = append(fields, feature.FieldMeterSlug)
	}
	if m.FieldCleared(feature.FieldMeterGroupByFilters) {
		fields = append(fields, feature.FieldMeterGroupByFilters)
	}
	if m.FieldCleared(feature.FieldArchivedAt) {
		fields = append(fields, feature.FieldArchivedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureMutation) ClearField(name string) error {
	switch name {
	case feature.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case feature.FieldMetadata:
		m.ClearMetadata()
		return nil
	case feature.FieldMeterSlug:
		m.ClearMeterSlug()
		return nil
	case feature.FieldMeterGroupByFilters:
		m.ClearMeterGroupByFilters()
		return nil
	case feature.FieldArchivedAt:
		m.ClearArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Feature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureMutation) ResetField(name string) error {
	switch name {
	case feature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feature.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feature.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case feature.FieldMetadata:
		m.ResetMetadata()
		return nil
	case feature.FieldNamespace:
		m.ResetNamespace()
		return nil
	case feature.FieldName:
		m.ResetName()
		return nil
	case feature.FieldKey:
		m.ResetKey()
		return nil
	case feature.FieldMeterSlug:
		m.ResetMeterSlug()
		return nil
	case feature.FieldMeterGroupByFilters:
		m.ResetMeterGroupByFilters()
		return nil
	case feature.FieldArchivedAt:
		m.ResetArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, feature.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeEntitlement:
		ids := make([]ent.Value, 0, len(m.entitlement))
		for id := range m.entitlement {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedentitlement != nil {
		edges = append(edges, feature.EdgeEntitlement)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeEntitlement:
		ids := make([]ent.Value, 0, len(m.removedentitlement))
		for id := range m.removedentitlement {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, feature.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case feature.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureMutation) ResetEdge(name string) error {
	switch name {
	case feature.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown Feature edge %s", name)
}

// GrantMutation represents an operation that mutates the Grant nodes in the graph.
type GrantMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	namespace             *string
	metadata              *map[string]string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	amount                *float64
	addamount             *float64
	priority              *uint8
	addpriority           *int8
	effective_at          *time.Time
	expiration            *grant.ExpirationPeriod
	expires_at            *time.Time
	voided_at             *time.Time
	reset_max_rollover    *float64
	addreset_max_rollover *float64
	reset_min_rollover    *float64
	addreset_min_rollover *float64
	recurrence_period     *recurrence.RecurrenceInterval
	recurrence_anchor     *time.Time
	clearedFields         map[string]struct{}
	entitlement           *string
	clearedentitlement    bool
	done                  bool
	oldValue              func(context.Context) (*Grant, error)
	predicates            []predicate.Grant
}

var _ ent.Mutation = (*GrantMutation)(nil)

// grantOption allows management of the mutation configuration using functional options.
type grantOption func(*GrantMutation)

// newGrantMutation creates new mutation for the Grant entity.
func newGrantMutation(c config, op Op, opts ...grantOption) *GrantMutation {
	m := &GrantMutation{
		config:        c,
		op:            op,
		typ:           TypeGrant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrantID sets the ID field of the mutation.
func withGrantID(id string) grantOption {
	return func(m *GrantMutation) {
		var (
			err   error
			once  sync.Once
			value *Grant
		)
		m.oldValue = func(ctx context.Context) (*Grant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrant sets the old Grant of the mutation.
func withGrant(node *Grant) grantOption {
	return func(m *GrantMutation) {
		m.oldValue = func(context.Context) (*Grant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Grant entities.
func (m *GrantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GrantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GrantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Grant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *GrantMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *GrantMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *GrantMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *GrantMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *GrantMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *GrantMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[dbgrant.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *GrantMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *GrantMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, dbgrant.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *GrantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GrantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GrantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GrantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GrantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GrantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GrantMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GrantMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GrantMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dbgrant.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GrantMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GrantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dbgrant.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *GrantMutation) SetOwnerID(s string) {
	m.entitlement = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *GrantMutation) OwnerID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *GrantMutation) ResetOwnerID() {
	m.entitlement = nil
}

// SetAmount sets the "amount" field.
func (m *GrantMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GrantMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *GrantMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *GrantMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *GrantMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPriority sets the "priority" field.
func (m *GrantMutation) SetPriority(u uint8) {
	m.priority = &u
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *GrantMutation) Priority() (r uint8, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldPriority(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds u to the "priority" field.
func (m *GrantMutation) AddPriority(u int8) {
	if m.addpriority != nil {
		*m.addpriority += u
	} else {
		m.addpriority = &u
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *GrantMutation) AddedPriority() (r int8, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *GrantMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetEffectiveAt sets the "effective_at" field.
func (m *GrantMutation) SetEffectiveAt(t time.Time) {
	m.effective_at = &t
}

// EffectiveAt returns the value of the "effective_at" field in the mutation.
func (m *GrantMutation) EffectiveAt() (r time.Time, exists bool) {
	v := m.effective_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveAt returns the old "effective_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldEffectiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveAt: %w", err)
	}
	return oldValue.EffectiveAt, nil
}

// ResetEffectiveAt resets all changes to the "effective_at" field.
func (m *GrantMutation) ResetEffectiveAt() {
	m.effective_at = nil
}

// SetExpiration sets the "expiration" field.
func (m *GrantMutation) SetExpiration(gp grant.ExpirationPeriod) {
	m.expiration = &gp
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *GrantMutation) Expiration() (r grant.ExpirationPeriod, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldExpiration(ctx context.Context) (v grant.ExpirationPeriod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *GrantMutation) ResetExpiration() {
	m.expiration = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *GrantMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *GrantMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *GrantMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetVoidedAt sets the "voided_at" field.
func (m *GrantMutation) SetVoidedAt(t time.Time) {
	m.voided_at = &t
}

// VoidedAt returns the value of the "voided_at" field in the mutation.
func (m *GrantMutation) VoidedAt() (r time.Time, exists bool) {
	v := m.voided_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidedAt returns the old "voided_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldVoidedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidedAt: %w", err)
	}
	return oldValue.VoidedAt, nil
}

// ClearVoidedAt clears the value of the "voided_at" field.
func (m *GrantMutation) ClearVoidedAt() {
	m.voided_at = nil
	m.clearedFields[dbgrant.FieldVoidedAt] = struct{}{}
}

// VoidedAtCleared returns if the "voided_at" field was cleared in this mutation.
func (m *GrantMutation) VoidedAtCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldVoidedAt]
	return ok
}

// ResetVoidedAt resets all changes to the "voided_at" field.
func (m *GrantMutation) ResetVoidedAt() {
	m.voided_at = nil
	delete(m.clearedFields, dbgrant.FieldVoidedAt)
}

// SetResetMaxRollover sets the "reset_max_rollover" field.
func (m *GrantMutation) SetResetMaxRollover(f float64) {
	m.reset_max_rollover = &f
	m.addreset_max_rollover = nil
}

// ResetMaxRollover returns the value of the "reset_max_rollover" field in the mutation.
func (m *GrantMutation) ResetMaxRollover() (r float64, exists bool) {
	v := m.reset_max_rollover
	if v == nil {
		return
	}
	return *v, true
}

// OldResetMaxRollover returns the old "reset_max_rollover" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldResetMaxRollover(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetMaxRollover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetMaxRollover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetMaxRollover: %w", err)
	}
	return oldValue.ResetMaxRollover, nil
}

// AddResetMaxRollover adds f to the "reset_max_rollover" field.
func (m *GrantMutation) AddResetMaxRollover(f float64) {
	if m.addreset_max_rollover != nil {
		*m.addreset_max_rollover += f
	} else {
		m.addreset_max_rollover = &f
	}
}

// AddedResetMaxRollover returns the value that was added to the "reset_max_rollover" field in this mutation.
func (m *GrantMutation) AddedResetMaxRollover() (r float64, exists bool) {
	v := m.addreset_max_rollover
	if v == nil {
		return
	}
	return *v, true
}

// ResetResetMaxRollover resets all changes to the "reset_max_rollover" field.
func (m *GrantMutation) ResetResetMaxRollover() {
	m.reset_max_rollover = nil
	m.addreset_max_rollover = nil
}

// SetResetMinRollover sets the "reset_min_rollover" field.
func (m *GrantMutation) SetResetMinRollover(f float64) {
	m.reset_min_rollover = &f
	m.addreset_min_rollover = nil
}

// ResetMinRollover returns the value of the "reset_min_rollover" field in the mutation.
func (m *GrantMutation) ResetMinRollover() (r float64, exists bool) {
	v := m.reset_min_rollover
	if v == nil {
		return
	}
	return *v, true
}

// OldResetMinRollover returns the old "reset_min_rollover" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldResetMinRollover(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetMinRollover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetMinRollover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetMinRollover: %w", err)
	}
	return oldValue.ResetMinRollover, nil
}

// AddResetMinRollover adds f to the "reset_min_rollover" field.
func (m *GrantMutation) AddResetMinRollover(f float64) {
	if m.addreset_min_rollover != nil {
		*m.addreset_min_rollover += f
	} else {
		m.addreset_min_rollover = &f
	}
}

// AddedResetMinRollover returns the value that was added to the "reset_min_rollover" field in this mutation.
func (m *GrantMutation) AddedResetMinRollover() (r float64, exists bool) {
	v := m.addreset_min_rollover
	if v == nil {
		return
	}
	return *v, true
}

// ResetResetMinRollover resets all changes to the "reset_min_rollover" field.
func (m *GrantMutation) ResetResetMinRollover() {
	m.reset_min_rollover = nil
	m.addreset_min_rollover = nil
}

// SetRecurrencePeriod sets the "recurrence_period" field.
func (m *GrantMutation) SetRecurrencePeriod(ri recurrence.RecurrenceInterval) {
	m.recurrence_period = &ri
}

// RecurrencePeriod returns the value of the "recurrence_period" field in the mutation.
func (m *GrantMutation) RecurrencePeriod() (r recurrence.RecurrenceInterval, exists bool) {
	v := m.recurrence_period
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrencePeriod returns the old "recurrence_period" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRecurrencePeriod(ctx context.Context) (v *recurrence.RecurrenceInterval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrencePeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrencePeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrencePeriod: %w", err)
	}
	return oldValue.RecurrencePeriod, nil
}

// ClearRecurrencePeriod clears the value of the "recurrence_period" field.
func (m *GrantMutation) ClearRecurrencePeriod() {
	m.recurrence_period = nil
	m.clearedFields[dbgrant.FieldRecurrencePeriod] = struct{}{}
}

// RecurrencePeriodCleared returns if the "recurrence_period" field was cleared in this mutation.
func (m *GrantMutation) RecurrencePeriodCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldRecurrencePeriod]
	return ok
}

// ResetRecurrencePeriod resets all changes to the "recurrence_period" field.
func (m *GrantMutation) ResetRecurrencePeriod() {
	m.recurrence_period = nil
	delete(m.clearedFields, dbgrant.FieldRecurrencePeriod)
}

// SetRecurrenceAnchor sets the "recurrence_anchor" field.
func (m *GrantMutation) SetRecurrenceAnchor(t time.Time) {
	m.recurrence_anchor = &t
}

// RecurrenceAnchor returns the value of the "recurrence_anchor" field in the mutation.
func (m *GrantMutation) RecurrenceAnchor() (r time.Time, exists bool) {
	v := m.recurrence_anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrenceAnchor returns the old "recurrence_anchor" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRecurrenceAnchor(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrenceAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrenceAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrenceAnchor: %w", err)
	}
	return oldValue.RecurrenceAnchor, nil
}

// ClearRecurrenceAnchor clears the value of the "recurrence_anchor" field.
func (m *GrantMutation) ClearRecurrenceAnchor() {
	m.recurrence_anchor = nil
	m.clearedFields[dbgrant.FieldRecurrenceAnchor] = struct{}{}
}

// RecurrenceAnchorCleared returns if the "recurrence_anchor" field was cleared in this mutation.
func (m *GrantMutation) RecurrenceAnchorCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldRecurrenceAnchor]
	return ok
}

// ResetRecurrenceAnchor resets all changes to the "recurrence_anchor" field.
func (m *GrantMutation) ResetRecurrenceAnchor() {
	m.recurrence_anchor = nil
	delete(m.clearedFields, dbgrant.FieldRecurrenceAnchor)
}

// SetEntitlementID sets the "entitlement" edge to the Entitlement entity by id.
func (m *GrantMutation) SetEntitlementID(id string) {
	m.entitlement = &id
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *GrantMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[dbgrant.FieldOwnerID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *GrantMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementID returns the "entitlement" edge ID in the mutation.
func (m *GrantMutation) EntitlementID() (id string, exists bool) {
	if m.entitlement != nil {
		return *m.entitlement, true
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *GrantMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *GrantMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the GrantMutation builder.
func (m *GrantMutation) Where(ps ...predicate.Grant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GrantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GrantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Grant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GrantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GrantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Grant).
func (m *GrantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GrantMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.namespace != nil {
		fields = append(fields, dbgrant.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, dbgrant.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, dbgrant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dbgrant.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dbgrant.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, dbgrant.FieldOwnerID)
	}
	if m.amount != nil {
		fields = append(fields, dbgrant.FieldAmount)
	}
	if m.priority != nil {
		fields = append(fields, dbgrant.FieldPriority)
	}
	if m.effective_at != nil {
		fields = append(fields, dbgrant.FieldEffectiveAt)
	}
	if m.expiration != nil {
		fields = append(fields, dbgrant.FieldExpiration)
	}
	if m.expires_at != nil {
		fields = append(fields, dbgrant.FieldExpiresAt)
	}
	if m.voided_at != nil {
		fields = append(fields, dbgrant.FieldVoidedAt)
	}
	if m.reset_max_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMaxRollover)
	}
	if m.reset_min_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMinRollover)
	}
	if m.recurrence_period != nil {
		fields = append(fields, dbgrant.FieldRecurrencePeriod)
	}
	if m.recurrence_anchor != nil {
		fields = append(fields, dbgrant.FieldRecurrenceAnchor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GrantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbgrant.FieldNamespace:
		return m.Namespace()
	case dbgrant.FieldMetadata:
		return m.Metadata()
	case dbgrant.FieldCreatedAt:
		return m.CreatedAt()
	case dbgrant.FieldUpdatedAt:
		return m.UpdatedAt()
	case dbgrant.FieldDeletedAt:
		return m.DeletedAt()
	case dbgrant.FieldOwnerID:
		return m.OwnerID()
	case dbgrant.FieldAmount:
		return m.Amount()
	case dbgrant.FieldPriority:
		return m.Priority()
	case dbgrant.FieldEffectiveAt:
		return m.EffectiveAt()
	case dbgrant.FieldExpiration:
		return m.Expiration()
	case dbgrant.FieldExpiresAt:
		return m.ExpiresAt()
	case dbgrant.FieldVoidedAt:
		return m.VoidedAt()
	case dbgrant.FieldResetMaxRollover:
		return m.ResetMaxRollover()
	case dbgrant.FieldResetMinRollover:
		return m.ResetMinRollover()
	case dbgrant.FieldRecurrencePeriod:
		return m.RecurrencePeriod()
	case dbgrant.FieldRecurrenceAnchor:
		return m.RecurrenceAnchor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GrantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbgrant.FieldNamespace:
		return m.OldNamespace(ctx)
	case dbgrant.FieldMetadata:
		return m.OldMetadata(ctx)
	case dbgrant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dbgrant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dbgrant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dbgrant.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case dbgrant.FieldAmount:
		return m.OldAmount(ctx)
	case dbgrant.FieldPriority:
		return m.OldPriority(ctx)
	case dbgrant.FieldEffectiveAt:
		return m.OldEffectiveAt(ctx)
	case dbgrant.FieldExpiration:
		return m.OldExpiration(ctx)
	case dbgrant.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case dbgrant.FieldVoidedAt:
		return m.OldVoidedAt(ctx)
	case dbgrant.FieldResetMaxRollover:
		return m.OldResetMaxRollover(ctx)
	case dbgrant.FieldResetMinRollover:
		return m.OldResetMinRollover(ctx)
	case dbgrant.FieldRecurrencePeriod:
		return m.OldRecurrencePeriod(ctx)
	case dbgrant.FieldRecurrenceAnchor:
		return m.OldRecurrenceAnchor(ctx)
	}
	return nil, fmt.Errorf("unknown Grant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbgrant.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case dbgrant.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case dbgrant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dbgrant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dbgrant.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dbgrant.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case dbgrant.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case dbgrant.FieldPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case dbgrant.FieldEffectiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveAt(v)
		return nil
	case dbgrant.FieldExpiration:
		v, ok := value.(grant.ExpirationPeriod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case dbgrant.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case dbgrant.FieldVoidedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidedAt(v)
		return nil
	case dbgrant.FieldResetMaxRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetMaxRollover(v)
		return nil
	case dbgrant.FieldResetMinRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetMinRollover(v)
		return nil
	case dbgrant.FieldRecurrencePeriod:
		v, ok := value.(recurrence.RecurrenceInterval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrencePeriod(v)
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrenceAnchor(v)
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GrantMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, dbgrant.FieldAmount)
	}
	if m.addpriority != nil {
		fields = append(fields, dbgrant.FieldPriority)
	}
	if m.addreset_max_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMaxRollover)
	}
	if m.addreset_min_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMinRollover)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GrantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dbgrant.FieldAmount:
		return m.AddedAmount()
	case dbgrant.FieldPriority:
		return m.AddedPriority()
	case dbgrant.FieldResetMaxRollover:
		return m.AddedResetMaxRollover()
	case dbgrant.FieldResetMinRollover:
		return m.AddedResetMinRollover()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dbgrant.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case dbgrant.FieldPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case dbgrant.FieldResetMaxRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResetMaxRollover(v)
		return nil
	case dbgrant.FieldResetMinRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResetMinRollover(v)
		return nil
	}
	return fmt.Errorf("unknown Grant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GrantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbgrant.FieldMetadata) {
		fields = append(fields, dbgrant.FieldMetadata)
	}
	if m.FieldCleared(dbgrant.FieldDeletedAt) {
		fields = append(fields, dbgrant.FieldDeletedAt)
	}
	if m.FieldCleared(dbgrant.FieldVoidedAt) {
		fields = append(fields, dbgrant.FieldVoidedAt)
	}
	if m.FieldCleared(dbgrant.FieldRecurrencePeriod) {
		fields = append(fields, dbgrant.FieldRecurrencePeriod)
	}
	if m.FieldCleared(dbgrant.FieldRecurrenceAnchor) {
		fields = append(fields, dbgrant.FieldRecurrenceAnchor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GrantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrantMutation) ClearField(name string) error {
	switch name {
	case dbgrant.FieldMetadata:
		m.ClearMetadata()
		return nil
	case dbgrant.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dbgrant.FieldVoidedAt:
		m.ClearVoidedAt()
		return nil
	case dbgrant.FieldRecurrencePeriod:
		m.ClearRecurrencePeriod()
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		m.ClearRecurrenceAnchor()
		return nil
	}
	return fmt.Errorf("unknown Grant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GrantMutation) ResetField(name string) error {
	switch name {
	case dbgrant.FieldNamespace:
		m.ResetNamespace()
		return nil
	case dbgrant.FieldMetadata:
		m.ResetMetadata()
		return nil
	case dbgrant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dbgrant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dbgrant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dbgrant.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case dbgrant.FieldAmount:
		m.ResetAmount()
		return nil
	case dbgrant.FieldPriority:
		m.ResetPriority()
		return nil
	case dbgrant.FieldEffectiveAt:
		m.ResetEffectiveAt()
		return nil
	case dbgrant.FieldExpiration:
		m.ResetExpiration()
		return nil
	case dbgrant.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case dbgrant.FieldVoidedAt:
		m.ResetVoidedAt()
		return nil
	case dbgrant.FieldResetMaxRollover:
		m.ResetResetMaxRollover()
		return nil
	case dbgrant.FieldResetMinRollover:
		m.ResetResetMinRollover()
		return nil
	case dbgrant.FieldRecurrencePeriod:
		m.ResetRecurrencePeriod()
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		m.ResetRecurrenceAnchor()
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GrantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, dbgrant.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GrantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbgrant.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GrantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GrantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GrantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, dbgrant.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GrantMutation) EdgeCleared(name string) bool {
	switch name {
	case dbgrant.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GrantMutation) ClearEdge(name string) error {
	switch name {
	case dbgrant.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown Grant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GrantMutation) ResetEdge(name string) error {
	switch name {
	case dbgrant.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown Grant edge %s", name)
}

// NotificationChannelMutation represents an operation that mutates the NotificationChannel nodes in the graph.
type NotificationChannelMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	_type         *notification.ChannelType
	name          *string
	disabled      *bool
	_config       *notification.ChannelConfig
	clearedFields map[string]struct{}
	rules         map[string]struct{}
	removedrules  map[string]struct{}
	clearedrules  bool
	done          bool
	oldValue      func(context.Context) (*NotificationChannel, error)
	predicates    []predicate.NotificationChannel
}

var _ ent.Mutation = (*NotificationChannelMutation)(nil)

// notificationchannelOption allows management of the mutation configuration using functional options.
type notificationchannelOption func(*NotificationChannelMutation)

// newNotificationChannelMutation creates new mutation for the NotificationChannel entity.
func newNotificationChannelMutation(c config, op Op, opts ...notificationchannelOption) *NotificationChannelMutation {
	m := &NotificationChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationChannelID sets the ID field of the mutation.
func withNotificationChannelID(id string) notificationchannelOption {
	return func(m *NotificationChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationChannel
		)
		m.oldValue = func(ctx context.Context) (*NotificationChannel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationChannel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationChannel sets the old NotificationChannel of the mutation.
func withNotificationChannel(node *NotificationChannel) notificationchannelOption {
	return func(m *NotificationChannelMutation) {
		m.oldValue = func(context.Context) (*NotificationChannel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationChannel entities.
func (m *NotificationChannelMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationChannelMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationChannelMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationChannel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationChannelMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationChannelMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationChannelMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationChannelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationChannelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationChannelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationchannel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationChannelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationchannel.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *NotificationChannelMutation) SetType(nt notification.ChannelType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationChannelMutation) GetType() (r notification.ChannelType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldType(ctx context.Context) (v notification.ChannelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationChannelMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *NotificationChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationChannelMutation) ResetName() {
	m.name = nil
}

// SetDisabled sets the "disabled" field.
func (m *NotificationChannelMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *NotificationChannelMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *NotificationChannelMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[notificationchannel.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *NotificationChannelMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *NotificationChannelMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, notificationchannel.FieldDisabled)
}

// SetConfig sets the "config" field.
func (m *NotificationChannelMutation) SetConfig(nc notification.ChannelConfig) {
	m._config = &nc
}

// Config returns the value of the "config" field in the mutation.
func (m *NotificationChannelMutation) Config() (r notification.ChannelConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldConfig(ctx context.Context) (v notification.ChannelConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NotificationChannelMutation) ResetConfig() {
	m._config = nil
}

// AddRuleIDs adds the "rules" edge to the NotificationRule entity by ids.
func (m *NotificationChannelMutation) AddRuleIDs(ids ...string) {
	if m.rules == nil {
		m.rules = make(map[string]struct{})
	}
	for i := range ids {
		m.rules[ids[i]] = struct{}{}
	}
}

// ClearRules clears the "rules" edge to the NotificationRule entity.
func (m *NotificationChannelMutation) ClearRules() {
	m.clearedrules = true
}

// RulesCleared reports if the "rules" edge to the NotificationRule entity was cleared.
func (m *NotificationChannelMutation) RulesCleared() bool {
	return m.clearedrules
}

// RemoveRuleIDs removes the "rules" edge to the NotificationRule entity by IDs.
func (m *NotificationChannelMutation) RemoveRuleIDs(ids ...string) {
	if m.removedrules == nil {
		m.removedrules = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rules, ids[i])
		m.removedrules[ids[i]] = struct{}{}
	}
}

// RemovedRules returns the removed IDs of the "rules" edge to the NotificationRule entity.
func (m *NotificationChannelMutation) RemovedRulesIDs() (ids []string) {
	for id := range m.removedrules {
		ids = append(ids, id)
	}
	return
}

// RulesIDs returns the "rules" edge IDs in the mutation.
func (m *NotificationChannelMutation) RulesIDs() (ids []string) {
	for id := range m.rules {
		ids = append(ids, id)
	}
	return
}

// ResetRules resets all changes to the "rules" edge.
func (m *NotificationChannelMutation) ResetRules() {
	m.rules = nil
	m.clearedrules = false
	m.removedrules = nil
}

// Where appends a list predicates to the NotificationChannelMutation builder.
func (m *NotificationChannelMutation) Where(ps ...predicate.NotificationChannel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationChannel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationChannel).
func (m *NotificationChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationChannelMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, notificationchannel.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationchannel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationchannel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notificationchannel.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationchannel.FieldType)
	}
	if m.name != nil {
		fields = append(fields, notificationchannel.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, notificationchannel.FieldDisabled)
	}
	if m._config != nil {
		fields = append(fields, notificationchannel.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationchannel.FieldNamespace:
		return m.Namespace()
	case notificationchannel.FieldCreatedAt:
		return m.CreatedAt()
	case notificationchannel.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationchannel.FieldDeletedAt:
		return m.DeletedAt()
	case notificationchannel.FieldType:
		return m.GetType()
	case notificationchannel.FieldName:
		return m.Name()
	case notificationchannel.FieldDisabled:
		return m.Disabled()
	case notificationchannel.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationchannel.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationchannel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationchannel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationchannel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notificationchannel.FieldType:
		return m.OldType(ctx)
	case notificationchannel.FieldName:
		return m.OldName(ctx)
	case notificationchannel.FieldDisabled:
		return m.OldDisabled(ctx)
	case notificationchannel.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationChannel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationchannel.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationchannel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationchannel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationchannel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notificationchannel.FieldType:
		v, ok := value.(notification.ChannelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationchannel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationchannel.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case notificationchannel.FieldConfig:
		v, ok := value.(notification.ChannelConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationChannelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationChannelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationChannel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationchannel.FieldDeletedAt) {
		fields = append(fields, notificationchannel.FieldDeletedAt)
	}
	if m.FieldCleared(notificationchannel.FieldDisabled) {
		fields = append(fields, notificationchannel.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationChannelMutation) ClearField(name string) error {
	switch name {
	case notificationchannel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notificationchannel.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationChannelMutation) ResetField(name string) error {
	switch name {
	case notificationchannel.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationchannel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationchannel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationchannel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notificationchannel.FieldType:
		m.ResetType()
		return nil
	case notificationchannel.FieldName:
		m.ResetName()
		return nil
	case notificationchannel.FieldDisabled:
		m.ResetDisabled()
		return nil
	case notificationchannel.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rules != nil {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationchannel.EdgeRules:
		ids := make([]ent.Value, 0, len(m.rules))
		for id := range m.rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrules != nil {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationchannel.EdgeRules:
		ids := make([]ent.Value, 0, len(m.removedrules))
		for id := range m.removedrules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrules {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationchannel.EdgeRules:
		return m.clearedrules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationChannel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationChannelMutation) ResetEdge(name string) error {
	switch name {
	case notificationchannel.EdgeRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel edge %s", name)
}

// NotificationEventMutation represents an operation that mutates the NotificationEvent nodes in the graph.
type NotificationEventMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	namespace                *string
	created_at               *time.Time
	_type                    *notification.EventType
	payload                  *string
	clearedFields            map[string]struct{}
	delivery_statuses        map[string]struct{}
	removeddelivery_statuses map[string]struct{}
	cleareddelivery_statuses bool
	rules                    *string
	clearedrules             bool
	done                     bool
	oldValue                 func(context.Context) (*NotificationEvent, error)
	predicates               []predicate.NotificationEvent
}

var _ ent.Mutation = (*NotificationEventMutation)(nil)

// notificationeventOption allows management of the mutation configuration using functional options.
type notificationeventOption func(*NotificationEventMutation)

// newNotificationEventMutation creates new mutation for the NotificationEvent entity.
func newNotificationEventMutation(c config, op Op, opts ...notificationeventOption) *NotificationEventMutation {
	m := &NotificationEventMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationEventID sets the ID field of the mutation.
func withNotificationEventID(id string) notificationeventOption {
	return func(m *NotificationEventMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationEvent
		)
		m.oldValue = func(ctx context.Context) (*NotificationEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationEvent sets the old NotificationEvent of the mutation.
func withNotificationEvent(node *NotificationEvent) notificationeventOption {
	return func(m *NotificationEventMutation) {
		m.oldValue = func(context.Context) (*NotificationEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationEvent entities.
func (m *NotificationEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationEventMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationEventMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationEventMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetType sets the "type" field.
func (m *NotificationEventMutation) SetType(nt notification.EventType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationEventMutation) GetType() (r notification.EventType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldType(ctx context.Context) (v notification.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationEventMutation) ResetType() {
	m._type = nil
}

// SetRuleID sets the "rule_id" field.
func (m *NotificationEventMutation) SetRuleID(s string) {
	m.rules = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *NotificationEventMutation) RuleID() (r string, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *NotificationEventMutation) ResetRuleID() {
	m.rules = nil
}

// SetPayload sets the "payload" field.
func (m *NotificationEventMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *NotificationEventMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *NotificationEventMutation) ResetPayload() {
	m.payload = nil
}

// AddDeliveryStatusIDs adds the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity by ids.
func (m *NotificationEventMutation) AddDeliveryStatusIDs(ids ...string) {
	if m.delivery_statuses == nil {
		m.delivery_statuses = make(map[string]struct{})
	}
	for i := range ids {
		m.delivery_statuses[ids[i]] = struct{}{}
	}
}

// ClearDeliveryStatuses clears the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity.
func (m *NotificationEventMutation) ClearDeliveryStatuses() {
	m.cleareddelivery_statuses = true
}

// DeliveryStatusesCleared reports if the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity was cleared.
func (m *NotificationEventMutation) DeliveryStatusesCleared() bool {
	return m.cleareddelivery_statuses
}

// RemoveDeliveryStatusIDs removes the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity by IDs.
func (m *NotificationEventMutation) RemoveDeliveryStatusIDs(ids ...string) {
	if m.removeddelivery_statuses == nil {
		m.removeddelivery_statuses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.delivery_statuses, ids[i])
		m.removeddelivery_statuses[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryStatuses returns the removed IDs of the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity.
func (m *NotificationEventMutation) RemovedDeliveryStatusesIDs() (ids []string) {
	for id := range m.removeddelivery_statuses {
		ids = append(ids, id)
	}
	return
}

// DeliveryStatusesIDs returns the "delivery_statuses" edge IDs in the mutation.
func (m *NotificationEventMutation) DeliveryStatusesIDs() (ids []string) {
	for id := range m.delivery_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryStatuses resets all changes to the "delivery_statuses" edge.
func (m *NotificationEventMutation) ResetDeliveryStatuses() {
	m.delivery_statuses = nil
	m.cleareddelivery_statuses = false
	m.removeddelivery_statuses = nil
}

// SetRulesID sets the "rules" edge to the NotificationRule entity by id.
func (m *NotificationEventMutation) SetRulesID(id string) {
	m.rules = &id
}

// ClearRules clears the "rules" edge to the NotificationRule entity.
func (m *NotificationEventMutation) ClearRules() {
	m.clearedrules = true
	m.clearedFields[notificationevent.FieldRuleID] = struct{}{}
}

// RulesCleared reports if the "rules" edge to the NotificationRule entity was cleared.
func (m *NotificationEventMutation) RulesCleared() bool {
	return m.clearedrules
}

// RulesID returns the "rules" edge ID in the mutation.
func (m *NotificationEventMutation) RulesID() (id string, exists bool) {
	if m.rules != nil {
		return *m.rules, true
	}
	return
}

// RulesIDs returns the "rules" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RulesID instead. It exists only for internal usage by the builders.
func (m *NotificationEventMutation) RulesIDs() (ids []string) {
	if id := m.rules; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRules resets all changes to the "rules" edge.
func (m *NotificationEventMutation) ResetRules() {
	m.rules = nil
	m.clearedrules = false
}

// Where appends a list predicates to the NotificationEventMutation builder.
func (m *NotificationEventMutation) Where(ps ...predicate.NotificationEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationEvent).
func (m *NotificationEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationEventMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.namespace != nil {
		fields = append(fields, notificationevent.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationevent.FieldCreatedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationevent.FieldType)
	}
	if m.rules != nil {
		fields = append(fields, notificationevent.FieldRuleID)
	}
	if m.payload != nil {
		fields = append(fields, notificationevent.FieldPayload)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationevent.FieldNamespace:
		return m.Namespace()
	case notificationevent.FieldCreatedAt:
		return m.CreatedAt()
	case notificationevent.FieldType:
		return m.GetType()
	case notificationevent.FieldRuleID:
		return m.RuleID()
	case notificationevent.FieldPayload:
		return m.Payload()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationevent.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationevent.FieldType:
		return m.OldType(ctx)
	case notificationevent.FieldRuleID:
		return m.OldRuleID(ctx)
	case notificationevent.FieldPayload:
		return m.OldPayload(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationevent.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationevent.FieldType:
		v, ok := value.(notification.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationevent.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case notificationevent.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotificationEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationEventMutation) ResetField(name string) error {
	switch name {
	case notificationevent.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationevent.FieldType:
		m.ResetType()
		return nil
	case notificationevent.FieldRuleID:
		m.ResetRuleID()
		return nil
	case notificationevent.FieldPayload:
		m.ResetPayload()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.delivery_statuses != nil {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	if m.rules != nil {
		edges = append(edges, notificationevent.EdgeRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		ids := make([]ent.Value, 0, len(m.delivery_statuses))
		for id := range m.delivery_statuses {
			ids = append(ids, id)
		}
		return ids
	case notificationevent.EdgeRules:
		if id := m.rules; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddelivery_statuses != nil {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		ids := make([]ent.Value, 0, len(m.removeddelivery_statuses))
		for id := range m.removeddelivery_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddelivery_statuses {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	if m.clearedrules {
		edges = append(edges, notificationevent.EdgeRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationEventMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		return m.cleareddelivery_statuses
	case notificationevent.EdgeRules:
		return m.clearedrules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationEventMutation) ClearEdge(name string) error {
	switch name {
	case notificationevent.EdgeRules:
		m.ClearRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationEventMutation) ResetEdge(name string) error {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		m.ResetDeliveryStatuses()
		return nil
	case notificationevent.EdgeRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent edge %s", name)
}

// NotificationEventDeliveryStatusMutation represents an operation that mutates the NotificationEventDeliveryStatus nodes in the graph.
type NotificationEventDeliveryStatusMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	created_at    *time.Time
	updated_at    *time.Time
	event_id      *string
	channel_id    *string
	state         *notification.EventDeliveryStatusState
	reason        *string
	clearedFields map[string]struct{}
	events        map[string]struct{}
	removedevents map[string]struct{}
	clearedevents bool
	done          bool
	oldValue      func(context.Context) (*NotificationEventDeliveryStatus, error)
	predicates    []predicate.NotificationEventDeliveryStatus
}

var _ ent.Mutation = (*NotificationEventDeliveryStatusMutation)(nil)

// notificationeventdeliverystatusOption allows management of the mutation configuration using functional options.
type notificationeventdeliverystatusOption func(*NotificationEventDeliveryStatusMutation)

// newNotificationEventDeliveryStatusMutation creates new mutation for the NotificationEventDeliveryStatus entity.
func newNotificationEventDeliveryStatusMutation(c config, op Op, opts ...notificationeventdeliverystatusOption) *NotificationEventDeliveryStatusMutation {
	m := &NotificationEventDeliveryStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationEventDeliveryStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationEventDeliveryStatusID sets the ID field of the mutation.
func withNotificationEventDeliveryStatusID(id string) notificationeventdeliverystatusOption {
	return func(m *NotificationEventDeliveryStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationEventDeliveryStatus
		)
		m.oldValue = func(ctx context.Context) (*NotificationEventDeliveryStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationEventDeliveryStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationEventDeliveryStatus sets the old NotificationEventDeliveryStatus of the mutation.
func withNotificationEventDeliveryStatus(node *NotificationEventDeliveryStatus) notificationeventdeliverystatusOption {
	return func(m *NotificationEventDeliveryStatusMutation) {
		m.oldValue = func(context.Context) (*NotificationEventDeliveryStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationEventDeliveryStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationEventDeliveryStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationEventDeliveryStatus entities.
func (m *NotificationEventDeliveryStatusMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationEventDeliveryStatusMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationEventDeliveryStatusMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationEventDeliveryStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationEventDeliveryStatusMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationEventDeliveryStatusMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationEventDeliveryStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationEventDeliveryStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationEventDeliveryStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationEventDeliveryStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventID sets the "event_id" field.
func (m *NotificationEventDeliveryStatusMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *NotificationEventDeliveryStatusMutation) ResetEventID() {
	m.event_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *NotificationEventDeliveryStatusMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *NotificationEventDeliveryStatusMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetState sets the "state" field.
func (m *NotificationEventDeliveryStatusMutation) SetState(ndss notification.EventDeliveryStatusState) {
	m.state = &ndss
}

// State returns the value of the "state" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) State() (r notification.EventDeliveryStatusState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldState(ctx context.Context) (v notification.EventDeliveryStatusState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *NotificationEventDeliveryStatusMutation) ResetState() {
	m.state = nil
}

// SetReason sets the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[notificationeventdeliverystatus.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[notificationeventdeliverystatus.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, notificationeventdeliverystatus.FieldReason)
}

// AddEventIDs adds the "events" edge to the NotificationEvent entity by ids.
func (m *NotificationEventDeliveryStatusMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the NotificationEvent entity.
func (m *NotificationEventDeliveryStatusMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the NotificationEvent entity was cleared.
func (m *NotificationEventDeliveryStatusMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the NotificationEvent entity by IDs.
func (m *NotificationEventDeliveryStatusMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the NotificationEvent entity.
func (m *NotificationEventDeliveryStatusMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *NotificationEventDeliveryStatusMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *NotificationEventDeliveryStatusMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the NotificationEventDeliveryStatusMutation builder.
func (m *NotificationEventDeliveryStatusMutation) Where(ps ...predicate.NotificationEventDeliveryStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationEventDeliveryStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationEventDeliveryStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationEventDeliveryStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationEventDeliveryStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationEventDeliveryStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationEventDeliveryStatus).
func (m *NotificationEventDeliveryStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationEventDeliveryStatusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.namespace != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldUpdatedAt)
	}
	if m.event_id != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldEventID)
	}
	if m.channel_id != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldChannelID)
	}
	if m.state != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldState)
	}
	if m.reason != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationEventDeliveryStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		return m.Namespace()
	case notificationeventdeliverystatus.FieldCreatedAt:
		return m.CreatedAt()
	case notificationeventdeliverystatus.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationeventdeliverystatus.FieldEventID:
		return m.EventID()
	case notificationeventdeliverystatus.FieldChannelID:
		return m.ChannelID()
	case notificationeventdeliverystatus.FieldState:
		return m.State()
	case notificationeventdeliverystatus.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationEventDeliveryStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationeventdeliverystatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationeventdeliverystatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationeventdeliverystatus.FieldEventID:
		return m.OldEventID(ctx)
	case notificationeventdeliverystatus.FieldChannelID:
		return m.OldChannelID(ctx)
	case notificationeventdeliverystatus.FieldState:
		return m.OldState(ctx)
	case notificationeventdeliverystatus.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventDeliveryStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationeventdeliverystatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationeventdeliverystatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationeventdeliverystatus.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case notificationeventdeliverystatus.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case notificationeventdeliverystatus.FieldState:
		v, ok := value.(notification.EventDeliveryStatusState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case notificationeventdeliverystatus.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventDeliveryStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationEventDeliveryStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationeventdeliverystatus.FieldReason) {
		fields = append(fields, notificationeventdeliverystatus.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ClearField(name string) error {
	switch name {
	case notificationeventdeliverystatus.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ResetField(name string) error {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationeventdeliverystatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationeventdeliverystatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationeventdeliverystatus.FieldEventID:
		m.ResetEventID()
		return nil
	case notificationeventdeliverystatus.FieldChannelID:
		m.ResetChannelID()
		return nil
	case notificationeventdeliverystatus.FieldState:
		m.ResetState()
		return nil
	case notificationeventdeliverystatus.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationEventDeliveryStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationEventDeliveryStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ResetEdge(name string) error {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus edge %s", name)
}

// NotificationRuleMutation represents an operation that mutates the NotificationRule nodes in the graph.
type NotificationRuleMutation struct {
	config
	op              Op
	typ             string
	id              *string
	namespace       *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	_type           *notification.RuleType
	name            *string
	disabled        *bool
	_config         *notification.RuleConfig
	clearedFields   map[string]struct{}
	channels        map[string]struct{}
	removedchannels map[string]struct{}
	clearedchannels bool
	events          map[string]struct{}
	removedevents   map[string]struct{}
	clearedevents   bool
	done            bool
	oldValue        func(context.Context) (*NotificationRule, error)
	predicates      []predicate.NotificationRule
}

var _ ent.Mutation = (*NotificationRuleMutation)(nil)

// notificationruleOption allows management of the mutation configuration using functional options.
type notificationruleOption func(*NotificationRuleMutation)

// newNotificationRuleMutation creates new mutation for the NotificationRule entity.
func newNotificationRuleMutation(c config, op Op, opts ...notificationruleOption) *NotificationRuleMutation {
	m := &NotificationRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationRuleID sets the ID field of the mutation.
func withNotificationRuleID(id string) notificationruleOption {
	return func(m *NotificationRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationRule
		)
		m.oldValue = func(ctx context.Context) (*NotificationRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationRule sets the old NotificationRule of the mutation.
func withNotificationRule(node *NotificationRule) notificationruleOption {
	return func(m *NotificationRuleMutation) {
		m.oldValue = func(context.Context) (*NotificationRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationRule entities.
func (m *NotificationRuleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationRuleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationRuleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationRuleMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationRuleMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationRuleMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationRuleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationRuleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationRuleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationrule.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationRuleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationrule.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationRuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationrule.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *NotificationRuleMutation) SetType(nt notification.RuleType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationRuleMutation) GetType() (r notification.RuleType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldType(ctx context.Context) (v notification.RuleType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationRuleMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *NotificationRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationRuleMutation) ResetName() {
	m.name = nil
}

// SetDisabled sets the "disabled" field.
func (m *NotificationRuleMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *NotificationRuleMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *NotificationRuleMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[notificationrule.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *NotificationRuleMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[notificationrule.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *NotificationRuleMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, notificationrule.FieldDisabled)
}

// SetConfig sets the "config" field.
func (m *NotificationRuleMutation) SetConfig(nc notification.RuleConfig) {
	m._config = &nc
}

// Config returns the value of the "config" field in the mutation.
func (m *NotificationRuleMutation) Config() (r notification.RuleConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldConfig(ctx context.Context) (v notification.RuleConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NotificationRuleMutation) ResetConfig() {
	m._config = nil
}

// AddChannelIDs adds the "channels" edge to the NotificationChannel entity by ids.
func (m *NotificationRuleMutation) AddChannelIDs(ids ...string) {
	if m.channels == nil {
		m.channels = make(map[string]struct{})
	}
	for i := range ids {
		m.channels[ids[i]] = struct{}{}
	}
}

// ClearChannels clears the "channels" edge to the NotificationChannel entity.
func (m *NotificationRuleMutation) ClearChannels() {
	m.clearedchannels = true
}

// ChannelsCleared reports if the "channels" edge to the NotificationChannel entity was cleared.
func (m *NotificationRuleMutation) ChannelsCleared() bool {
	return m.clearedchannels
}

// RemoveChannelIDs removes the "channels" edge to the NotificationChannel entity by IDs.
func (m *NotificationRuleMutation) RemoveChannelIDs(ids ...string) {
	if m.removedchannels == nil {
		m.removedchannels = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.channels, ids[i])
		m.removedchannels[ids[i]] = struct{}{}
	}
}

// RemovedChannels returns the removed IDs of the "channels" edge to the NotificationChannel entity.
func (m *NotificationRuleMutation) RemovedChannelsIDs() (ids []string) {
	for id := range m.removedchannels {
		ids = append(ids, id)
	}
	return
}

// ChannelsIDs returns the "channels" edge IDs in the mutation.
func (m *NotificationRuleMutation) ChannelsIDs() (ids []string) {
	for id := range m.channels {
		ids = append(ids, id)
	}
	return
}

// ResetChannels resets all changes to the "channels" edge.
func (m *NotificationRuleMutation) ResetChannels() {
	m.channels = nil
	m.clearedchannels = false
	m.removedchannels = nil
}

// AddEventIDs adds the "events" edge to the NotificationEvent entity by ids.
func (m *NotificationRuleMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the NotificationEvent entity.
func (m *NotificationRuleMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the NotificationEvent entity was cleared.
func (m *NotificationRuleMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the NotificationEvent entity by IDs.
func (m *NotificationRuleMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the NotificationEvent entity.
func (m *NotificationRuleMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *NotificationRuleMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *NotificationRuleMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the NotificationRuleMutation builder.
func (m *NotificationRuleMutation) Where(ps ...predicate.NotificationRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationRule).
func (m *NotificationRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationRuleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, notificationrule.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationrule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notificationrule.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationrule.FieldType)
	}
	if m.name != nil {
		fields = append(fields, notificationrule.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, notificationrule.FieldDisabled)
	}
	if m._config != nil {
		fields = append(fields, notificationrule.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationrule.FieldNamespace:
		return m.Namespace()
	case notificationrule.FieldCreatedAt:
		return m.CreatedAt()
	case notificationrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationrule.FieldDeletedAt:
		return m.DeletedAt()
	case notificationrule.FieldType:
		return m.GetType()
	case notificationrule.FieldName:
		return m.Name()
	case notificationrule.FieldDisabled:
		return m.Disabled()
	case notificationrule.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationrule.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationrule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notificationrule.FieldType:
		return m.OldType(ctx)
	case notificationrule.FieldName:
		return m.OldName(ctx)
	case notificationrule.FieldDisabled:
		return m.OldDisabled(ctx)
	case notificationrule.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationrule.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationrule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notificationrule.FieldType:
		v, ok := value.(notification.RuleType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationrule.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case notificationrule.FieldConfig:
		v, ok := value.(notification.RuleConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationRuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationRuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationrule.FieldDeletedAt) {
		fields = append(fields, notificationrule.FieldDeletedAt)
	}
	if m.FieldCleared(notificationrule.FieldDisabled) {
		fields = append(fields, notificationrule.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationRuleMutation) ClearField(name string) error {
	switch name {
	case notificationrule.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notificationrule.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationRuleMutation) ResetField(name string) error {
	switch name {
	case notificationrule.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationrule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notificationrule.FieldType:
		m.ResetType()
		return nil
	case notificationrule.FieldName:
		m.ResetName()
		return nil
	case notificationrule.FieldDisabled:
		m.ResetDisabled()
		return nil
	case notificationrule.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.channels != nil {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.events != nil {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationrule.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.channels))
		for id := range m.channels {
			ids = append(ids, id)
		}
		return ids
	case notificationrule.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchannels != nil {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.removedevents != nil {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationrule.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.removedchannels))
		for id := range m.removedchannels {
			ids = append(ids, id)
		}
		return ids
	case notificationrule.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchannels {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.clearedevents {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationrule.EdgeChannels:
		return m.clearedchannels
	case notificationrule.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationRuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationRuleMutation) ResetEdge(name string) error {
	switch name {
	case notificationrule.EdgeChannels:
		m.ResetChannels()
		return nil
	case notificationrule.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule edge %s", name)
}

// UsageResetMutation represents an operation that mutates the UsageReset nodes in the graph.
type UsageResetMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	namespace          *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	reset_time         *time.Time
	clearedFields      map[string]struct{}
	entitlement        *string
	clearedentitlement bool
	done               bool
	oldValue           func(context.Context) (*UsageReset, error)
	predicates         []predicate.UsageReset
}

var _ ent.Mutation = (*UsageResetMutation)(nil)

// usageresetOption allows management of the mutation configuration using functional options.
type usageresetOption func(*UsageResetMutation)

// newUsageResetMutation creates new mutation for the UsageReset entity.
func newUsageResetMutation(c config, op Op, opts ...usageresetOption) *UsageResetMutation {
	m := &UsageResetMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageReset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageResetID sets the ID field of the mutation.
func withUsageResetID(id string) usageresetOption {
	return func(m *UsageResetMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageReset
		)
		m.oldValue = func(ctx context.Context) (*UsageReset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageReset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageReset sets the old UsageReset of the mutation.
func withUsageReset(node *UsageReset) usageresetOption {
	return func(m *UsageResetMutation) {
		m.oldValue = func(context.Context) (*UsageReset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageResetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageResetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UsageReset entities.
func (m *UsageResetMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageResetMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageResetMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageReset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *UsageResetMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *UsageResetMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *UsageResetMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageResetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageResetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageResetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageResetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageResetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageResetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UsageResetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UsageResetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UsageResetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usagereset.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UsageResetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usagereset.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UsageResetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usagereset.FieldDeletedAt)
}

// SetEntitlementID sets the "entitlement_id" field.
func (m *UsageResetMutation) SetEntitlementID(s string) {
	m.entitlement = &s
}

// EntitlementID returns the value of the "entitlement_id" field in the mutation.
func (m *UsageResetMutation) EntitlementID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementID returns the old "entitlement_id" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldEntitlementID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementID: %w", err)
	}
	return oldValue.EntitlementID, nil
}

// ResetEntitlementID resets all changes to the "entitlement_id" field.
func (m *UsageResetMutation) ResetEntitlementID() {
	m.entitlement = nil
}

// SetResetTime sets the "reset_time" field.
func (m *UsageResetMutation) SetResetTime(t time.Time) {
	m.reset_time = &t
}

// ResetTime returns the value of the "reset_time" field in the mutation.
func (m *UsageResetMutation) ResetTime() (r time.Time, exists bool) {
	v := m.reset_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResetTime returns the old "reset_time" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldResetTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetTime: %w", err)
	}
	return oldValue.ResetTime, nil
}

// ResetResetTime resets all changes to the "reset_time" field.
func (m *UsageResetMutation) ResetResetTime() {
	m.reset_time = nil
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *UsageResetMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[usagereset.FieldEntitlementID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *UsageResetMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *UsageResetMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *UsageResetMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the UsageResetMutation builder.
func (m *UsageResetMutation) Where(ps ...predicate.UsageReset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageResetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageResetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageReset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageResetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageResetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageReset).
func (m *UsageResetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageResetMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.namespace != nil {
		fields = append(fields, usagereset.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, usagereset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usagereset.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usagereset.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, usagereset.FieldEntitlementID)
	}
	if m.reset_time != nil {
		fields = append(fields, usagereset.FieldResetTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageResetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagereset.FieldNamespace:
		return m.Namespace()
	case usagereset.FieldCreatedAt:
		return m.CreatedAt()
	case usagereset.FieldUpdatedAt:
		return m.UpdatedAt()
	case usagereset.FieldDeletedAt:
		return m.DeletedAt()
	case usagereset.FieldEntitlementID:
		return m.EntitlementID()
	case usagereset.FieldResetTime:
		return m.ResetTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageResetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagereset.FieldNamespace:
		return m.OldNamespace(ctx)
	case usagereset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagereset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usagereset.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usagereset.FieldEntitlementID:
		return m.OldEntitlementID(ctx)
	case usagereset.FieldResetTime:
		return m.OldResetTime(ctx)
	}
	return nil, fmt.Errorf("unknown UsageReset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageResetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagereset.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case usagereset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagereset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usagereset.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usagereset.FieldEntitlementID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementID(v)
		return nil
	case usagereset.FieldResetTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetTime(v)
		return nil
	}
	return fmt.Errorf("unknown UsageReset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageResetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageResetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageResetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UsageReset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageResetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagereset.FieldDeletedAt) {
		fields = append(fields, usagereset.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageResetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageResetMutation) ClearField(name string) error {
	switch name {
	case usagereset.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageReset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageResetMutation) ResetField(name string) error {
	switch name {
	case usagereset.FieldNamespace:
		m.ResetNamespace()
		return nil
	case usagereset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagereset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usagereset.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usagereset.FieldEntitlementID:
		m.ResetEntitlementID()
		return nil
	case usagereset.FieldResetTime:
		m.ResetResetTime()
		return nil
	}
	return fmt.Errorf("unknown UsageReset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageResetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, usagereset.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageResetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagereset.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageResetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageResetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageResetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, usagereset.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageResetMutation) EdgeCleared(name string) bool {
	switch name {
	case usagereset.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageResetMutation) ClearEdge(name string) error {
	switch name {
	case usagereset.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown UsageReset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageResetMutation) ResetEdge(name string) error {
	switch name {
	case usagereset.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown UsageReset edge %s", name)
}
