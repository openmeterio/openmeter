// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/openmeterio/openmeter/internal/credit"
	"github.com/openmeterio/openmeter/internal/credit/postgresadapter/ent/db/balancesnapshot"
	"github.com/openmeterio/openmeter/internal/credit/postgresadapter/ent/db/grant"
	"github.com/openmeterio/openmeter/internal/credit/postgresadapter/ent/db/predicate"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBalanceSnapshot = "BalanceSnapshot"
	TypeGrant           = "Grant"
)

// BalanceSnapshotMutation represents an operation that mutates the BalanceSnapshot nodes in the graph.
type BalanceSnapshotMutation struct {
	config
	op             Op
	typ            string
	id             *int
	namespace      *string
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	owner_id       *credit.GrantOwner
	grant_balances *credit.GrantBalanceMap
	balance        *float64
	addbalance     *float64
	overage        *float64
	addoverage     *float64
	at             *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*BalanceSnapshot, error)
	predicates     []predicate.BalanceSnapshot
}

var _ ent.Mutation = (*BalanceSnapshotMutation)(nil)

// balancesnapshotOption allows management of the mutation configuration using functional options.
type balancesnapshotOption func(*BalanceSnapshotMutation)

// newBalanceSnapshotMutation creates new mutation for the BalanceSnapshot entity.
func newBalanceSnapshotMutation(c config, op Op, opts ...balancesnapshotOption) *BalanceSnapshotMutation {
	m := &BalanceSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeBalanceSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBalanceSnapshotID sets the ID field of the mutation.
func withBalanceSnapshotID(id int) balancesnapshotOption {
	return func(m *BalanceSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *BalanceSnapshot
		)
		m.oldValue = func(ctx context.Context) (*BalanceSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BalanceSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBalanceSnapshot sets the old BalanceSnapshot of the mutation.
func withBalanceSnapshot(node *BalanceSnapshot) balancesnapshotOption {
	return func(m *BalanceSnapshotMutation) {
		m.oldValue = func(context.Context) (*BalanceSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BalanceSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BalanceSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BalanceSnapshotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BalanceSnapshotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BalanceSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BalanceSnapshotMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BalanceSnapshotMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BalanceSnapshotMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BalanceSnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BalanceSnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BalanceSnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BalanceSnapshotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BalanceSnapshotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BalanceSnapshotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BalanceSnapshotMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BalanceSnapshotMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BalanceSnapshotMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[balancesnapshot.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BalanceSnapshotMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[balancesnapshot.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BalanceSnapshotMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, balancesnapshot.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *BalanceSnapshotMutation) SetOwnerID(co credit.GrantOwner) {
	m.owner_id = &co
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *BalanceSnapshotMutation) OwnerID() (r credit.GrantOwner, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldOwnerID(ctx context.Context) (v credit.GrantOwner, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *BalanceSnapshotMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetGrantBalances sets the "grant_balances" field.
func (m *BalanceSnapshotMutation) SetGrantBalances(cbm credit.GrantBalanceMap) {
	m.grant_balances = &cbm
}

// GrantBalances returns the value of the "grant_balances" field in the mutation.
func (m *BalanceSnapshotMutation) GrantBalances() (r credit.GrantBalanceMap, exists bool) {
	v := m.grant_balances
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantBalances returns the old "grant_balances" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldGrantBalances(ctx context.Context) (v credit.GrantBalanceMap, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantBalances is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantBalances requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantBalances: %w", err)
	}
	return oldValue.GrantBalances, nil
}

// ResetGrantBalances resets all changes to the "grant_balances" field.
func (m *BalanceSnapshotMutation) ResetGrantBalances() {
	m.grant_balances = nil
}

// SetBalance sets the "balance" field.
func (m *BalanceSnapshotMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *BalanceSnapshotMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *BalanceSnapshotMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *BalanceSnapshotMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *BalanceSnapshotMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetOverage sets the "overage" field.
func (m *BalanceSnapshotMutation) SetOverage(f float64) {
	m.overage = &f
	m.addoverage = nil
}

// Overage returns the value of the "overage" field in the mutation.
func (m *BalanceSnapshotMutation) Overage() (r float64, exists bool) {
	v := m.overage
	if v == nil {
		return
	}
	return *v, true
}

// OldOverage returns the old "overage" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldOverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverage: %w", err)
	}
	return oldValue.Overage, nil
}

// AddOverage adds f to the "overage" field.
func (m *BalanceSnapshotMutation) AddOverage(f float64) {
	if m.addoverage != nil {
		*m.addoverage += f
	} else {
		m.addoverage = &f
	}
}

// AddedOverage returns the value that was added to the "overage" field in this mutation.
func (m *BalanceSnapshotMutation) AddedOverage() (r float64, exists bool) {
	v := m.addoverage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverage resets all changes to the "overage" field.
func (m *BalanceSnapshotMutation) ResetOverage() {
	m.overage = nil
	m.addoverage = nil
}

// SetAt sets the "at" field.
func (m *BalanceSnapshotMutation) SetAt(t time.Time) {
	m.at = &t
}

// At returns the value of the "at" field in the mutation.
func (m *BalanceSnapshotMutation) At() (r time.Time, exists bool) {
	v := m.at
	if v == nil {
		return
	}
	return *v, true
}

// OldAt returns the old "at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAt: %w", err)
	}
	return oldValue.At, nil
}

// ResetAt resets all changes to the "at" field.
func (m *BalanceSnapshotMutation) ResetAt() {
	m.at = nil
}

// Where appends a list predicates to the BalanceSnapshotMutation builder.
func (m *BalanceSnapshotMutation) Where(ps ...predicate.BalanceSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BalanceSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BalanceSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BalanceSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BalanceSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BalanceSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BalanceSnapshot).
func (m *BalanceSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BalanceSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.namespace != nil {
		fields = append(fields, balancesnapshot.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, balancesnapshot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, balancesnapshot.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, balancesnapshot.FieldDeletedAt)
	}
	if m.owner_id != nil {
		fields = append(fields, balancesnapshot.FieldOwnerID)
	}
	if m.grant_balances != nil {
		fields = append(fields, balancesnapshot.FieldGrantBalances)
	}
	if m.balance != nil {
		fields = append(fields, balancesnapshot.FieldBalance)
	}
	if m.overage != nil {
		fields = append(fields, balancesnapshot.FieldOverage)
	}
	if m.at != nil {
		fields = append(fields, balancesnapshot.FieldAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BalanceSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case balancesnapshot.FieldNamespace:
		return m.Namespace()
	case balancesnapshot.FieldCreatedAt:
		return m.CreatedAt()
	case balancesnapshot.FieldUpdatedAt:
		return m.UpdatedAt()
	case balancesnapshot.FieldDeletedAt:
		return m.DeletedAt()
	case balancesnapshot.FieldOwnerID:
		return m.OwnerID()
	case balancesnapshot.FieldGrantBalances:
		return m.GrantBalances()
	case balancesnapshot.FieldBalance:
		return m.Balance()
	case balancesnapshot.FieldOverage:
		return m.Overage()
	case balancesnapshot.FieldAt:
		return m.At()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BalanceSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case balancesnapshot.FieldNamespace:
		return m.OldNamespace(ctx)
	case balancesnapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case balancesnapshot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case balancesnapshot.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case balancesnapshot.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case balancesnapshot.FieldGrantBalances:
		return m.OldGrantBalances(ctx)
	case balancesnapshot.FieldBalance:
		return m.OldBalance(ctx)
	case balancesnapshot.FieldOverage:
		return m.OldOverage(ctx)
	case balancesnapshot.FieldAt:
		return m.OldAt(ctx)
	}
	return nil, fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case balancesnapshot.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case balancesnapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case balancesnapshot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case balancesnapshot.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case balancesnapshot.FieldOwnerID:
		v, ok := value.(credit.GrantOwner)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case balancesnapshot.FieldGrantBalances:
		v, ok := value.(credit.GrantBalanceMap)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantBalances(v)
		return nil
	case balancesnapshot.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case balancesnapshot.FieldOverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverage(v)
		return nil
	case balancesnapshot.FieldAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAt(v)
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BalanceSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, balancesnapshot.FieldBalance)
	}
	if m.addoverage != nil {
		fields = append(fields, balancesnapshot.FieldOverage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BalanceSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case balancesnapshot.FieldBalance:
		return m.AddedBalance()
	case balancesnapshot.FieldOverage:
		return m.AddedOverage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case balancesnapshot.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case balancesnapshot.FieldOverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverage(v)
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BalanceSnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(balancesnapshot.FieldDeletedAt) {
		fields = append(fields, balancesnapshot.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BalanceSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BalanceSnapshotMutation) ClearField(name string) error {
	switch name {
	case balancesnapshot.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BalanceSnapshotMutation) ResetField(name string) error {
	switch name {
	case balancesnapshot.FieldNamespace:
		m.ResetNamespace()
		return nil
	case balancesnapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case balancesnapshot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case balancesnapshot.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case balancesnapshot.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case balancesnapshot.FieldGrantBalances:
		m.ResetGrantBalances()
		return nil
	case balancesnapshot.FieldBalance:
		m.ResetBalance()
		return nil
	case balancesnapshot.FieldOverage:
		m.ResetOverage()
		return nil
	case balancesnapshot.FieldAt:
		m.ResetAt()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BalanceSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BalanceSnapshotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BalanceSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BalanceSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BalanceSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BalanceSnapshotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BalanceSnapshotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BalanceSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BalanceSnapshotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BalanceSnapshot edge %s", name)
}

// GrantMutation represents an operation that mutates the Grant nodes in the graph.
type GrantMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	namespace             *string
	metadata              *map[string]string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	owner_id              *credit.GrantOwner
	amount                *float64
	addamount             *float64
	priority              *uint8
	addpriority           *int8
	effective_at          *time.Time
	expiration            *credit.ExpirationPeriod
	expires_at            *time.Time
	voided_at             *time.Time
	reset_max_rollover    *float64
	addreset_max_rollover *float64
	recurrence_period     *credit.RecurrencePeriod
	recurrence_anchor     *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Grant, error)
	predicates            []predicate.Grant
}

var _ ent.Mutation = (*GrantMutation)(nil)

// grantOption allows management of the mutation configuration using functional options.
type grantOption func(*GrantMutation)

// newGrantMutation creates new mutation for the Grant entity.
func newGrantMutation(c config, op Op, opts ...grantOption) *GrantMutation {
	m := &GrantMutation{
		config:        c,
		op:            op,
		typ:           TypeGrant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrantID sets the ID field of the mutation.
func withGrantID(id string) grantOption {
	return func(m *GrantMutation) {
		var (
			err   error
			once  sync.Once
			value *Grant
		)
		m.oldValue = func(ctx context.Context) (*Grant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrant sets the old Grant of the mutation.
func withGrant(node *Grant) grantOption {
	return func(m *GrantMutation) {
		m.oldValue = func(context.Context) (*Grant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Grant entities.
func (m *GrantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GrantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GrantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Grant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *GrantMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *GrantMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *GrantMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *GrantMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *GrantMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *GrantMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[grant.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *GrantMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[grant.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *GrantMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, grant.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *GrantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GrantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GrantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GrantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GrantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GrantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GrantMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GrantMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GrantMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[grant.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GrantMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[grant.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GrantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, grant.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *GrantMutation) SetOwnerID(co credit.GrantOwner) {
	m.owner_id = &co
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *GrantMutation) OwnerID() (r credit.GrantOwner, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldOwnerID(ctx context.Context) (v credit.GrantOwner, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *GrantMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetAmount sets the "amount" field.
func (m *GrantMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GrantMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *GrantMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *GrantMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *GrantMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPriority sets the "priority" field.
func (m *GrantMutation) SetPriority(u uint8) {
	m.priority = &u
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *GrantMutation) Priority() (r uint8, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldPriority(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds u to the "priority" field.
func (m *GrantMutation) AddPriority(u int8) {
	if m.addpriority != nil {
		*m.addpriority += u
	} else {
		m.addpriority = &u
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *GrantMutation) AddedPriority() (r int8, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *GrantMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetEffectiveAt sets the "effective_at" field.
func (m *GrantMutation) SetEffectiveAt(t time.Time) {
	m.effective_at = &t
}

// EffectiveAt returns the value of the "effective_at" field in the mutation.
func (m *GrantMutation) EffectiveAt() (r time.Time, exists bool) {
	v := m.effective_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveAt returns the old "effective_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldEffectiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveAt: %w", err)
	}
	return oldValue.EffectiveAt, nil
}

// ResetEffectiveAt resets all changes to the "effective_at" field.
func (m *GrantMutation) ResetEffectiveAt() {
	m.effective_at = nil
}

// SetExpiration sets the "expiration" field.
func (m *GrantMutation) SetExpiration(cp credit.ExpirationPeriod) {
	m.expiration = &cp
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *GrantMutation) Expiration() (r credit.ExpirationPeriod, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldExpiration(ctx context.Context) (v credit.ExpirationPeriod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *GrantMutation) ResetExpiration() {
	m.expiration = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *GrantMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *GrantMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *GrantMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetVoidedAt sets the "voided_at" field.
func (m *GrantMutation) SetVoidedAt(t time.Time) {
	m.voided_at = &t
}

// VoidedAt returns the value of the "voided_at" field in the mutation.
func (m *GrantMutation) VoidedAt() (r time.Time, exists bool) {
	v := m.voided_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidedAt returns the old "voided_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldVoidedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidedAt: %w", err)
	}
	return oldValue.VoidedAt, nil
}

// ClearVoidedAt clears the value of the "voided_at" field.
func (m *GrantMutation) ClearVoidedAt() {
	m.voided_at = nil
	m.clearedFields[grant.FieldVoidedAt] = struct{}{}
}

// VoidedAtCleared returns if the "voided_at" field was cleared in this mutation.
func (m *GrantMutation) VoidedAtCleared() bool {
	_, ok := m.clearedFields[grant.FieldVoidedAt]
	return ok
}

// ResetVoidedAt resets all changes to the "voided_at" field.
func (m *GrantMutation) ResetVoidedAt() {
	m.voided_at = nil
	delete(m.clearedFields, grant.FieldVoidedAt)
}

// SetResetMaxRollover sets the "reset_max_rollover" field.
func (m *GrantMutation) SetResetMaxRollover(f float64) {
	m.reset_max_rollover = &f
	m.addreset_max_rollover = nil
}

// ResetMaxRollover returns the value of the "reset_max_rollover" field in the mutation.
func (m *GrantMutation) ResetMaxRollover() (r float64, exists bool) {
	v := m.reset_max_rollover
	if v == nil {
		return
	}
	return *v, true
}

// OldResetMaxRollover returns the old "reset_max_rollover" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldResetMaxRollover(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetMaxRollover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetMaxRollover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetMaxRollover: %w", err)
	}
	return oldValue.ResetMaxRollover, nil
}

// AddResetMaxRollover adds f to the "reset_max_rollover" field.
func (m *GrantMutation) AddResetMaxRollover(f float64) {
	if m.addreset_max_rollover != nil {
		*m.addreset_max_rollover += f
	} else {
		m.addreset_max_rollover = &f
	}
}

// AddedResetMaxRollover returns the value that was added to the "reset_max_rollover" field in this mutation.
func (m *GrantMutation) AddedResetMaxRollover() (r float64, exists bool) {
	v := m.addreset_max_rollover
	if v == nil {
		return
	}
	return *v, true
}

// ResetResetMaxRollover resets all changes to the "reset_max_rollover" field.
func (m *GrantMutation) ResetResetMaxRollover() {
	m.reset_max_rollover = nil
	m.addreset_max_rollover = nil
}

// SetRecurrencePeriod sets the "recurrence_period" field.
func (m *GrantMutation) SetRecurrencePeriod(cp credit.RecurrencePeriod) {
	m.recurrence_period = &cp
}

// RecurrencePeriod returns the value of the "recurrence_period" field in the mutation.
func (m *GrantMutation) RecurrencePeriod() (r credit.RecurrencePeriod, exists bool) {
	v := m.recurrence_period
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrencePeriod returns the old "recurrence_period" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRecurrencePeriod(ctx context.Context) (v *credit.RecurrencePeriod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrencePeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrencePeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrencePeriod: %w", err)
	}
	return oldValue.RecurrencePeriod, nil
}

// ClearRecurrencePeriod clears the value of the "recurrence_period" field.
func (m *GrantMutation) ClearRecurrencePeriod() {
	m.recurrence_period = nil
	m.clearedFields[grant.FieldRecurrencePeriod] = struct{}{}
}

// RecurrencePeriodCleared returns if the "recurrence_period" field was cleared in this mutation.
func (m *GrantMutation) RecurrencePeriodCleared() bool {
	_, ok := m.clearedFields[grant.FieldRecurrencePeriod]
	return ok
}

// ResetRecurrencePeriod resets all changes to the "recurrence_period" field.
func (m *GrantMutation) ResetRecurrencePeriod() {
	m.recurrence_period = nil
	delete(m.clearedFields, grant.FieldRecurrencePeriod)
}

// SetRecurrenceAnchor sets the "recurrence_anchor" field.
func (m *GrantMutation) SetRecurrenceAnchor(t time.Time) {
	m.recurrence_anchor = &t
}

// RecurrenceAnchor returns the value of the "recurrence_anchor" field in the mutation.
func (m *GrantMutation) RecurrenceAnchor() (r time.Time, exists bool) {
	v := m.recurrence_anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrenceAnchor returns the old "recurrence_anchor" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRecurrenceAnchor(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrenceAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrenceAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrenceAnchor: %w", err)
	}
	return oldValue.RecurrenceAnchor, nil
}

// ClearRecurrenceAnchor clears the value of the "recurrence_anchor" field.
func (m *GrantMutation) ClearRecurrenceAnchor() {
	m.recurrence_anchor = nil
	m.clearedFields[grant.FieldRecurrenceAnchor] = struct{}{}
}

// RecurrenceAnchorCleared returns if the "recurrence_anchor" field was cleared in this mutation.
func (m *GrantMutation) RecurrenceAnchorCleared() bool {
	_, ok := m.clearedFields[grant.FieldRecurrenceAnchor]
	return ok
}

// ResetRecurrenceAnchor resets all changes to the "recurrence_anchor" field.
func (m *GrantMutation) ResetRecurrenceAnchor() {
	m.recurrence_anchor = nil
	delete(m.clearedFields, grant.FieldRecurrenceAnchor)
}

// Where appends a list predicates to the GrantMutation builder.
func (m *GrantMutation) Where(ps ...predicate.Grant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GrantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GrantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Grant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GrantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GrantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Grant).
func (m *GrantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GrantMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.namespace != nil {
		fields = append(fields, grant.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, grant.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, grant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, grant.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, grant.FieldDeletedAt)
	}
	if m.owner_id != nil {
		fields = append(fields, grant.FieldOwnerID)
	}
	if m.amount != nil {
		fields = append(fields, grant.FieldAmount)
	}
	if m.priority != nil {
		fields = append(fields, grant.FieldPriority)
	}
	if m.effective_at != nil {
		fields = append(fields, grant.FieldEffectiveAt)
	}
	if m.expiration != nil {
		fields = append(fields, grant.FieldExpiration)
	}
	if m.expires_at != nil {
		fields = append(fields, grant.FieldExpiresAt)
	}
	if m.voided_at != nil {
		fields = append(fields, grant.FieldVoidedAt)
	}
	if m.reset_max_rollover != nil {
		fields = append(fields, grant.FieldResetMaxRollover)
	}
	if m.recurrence_period != nil {
		fields = append(fields, grant.FieldRecurrencePeriod)
	}
	if m.recurrence_anchor != nil {
		fields = append(fields, grant.FieldRecurrenceAnchor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GrantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grant.FieldNamespace:
		return m.Namespace()
	case grant.FieldMetadata:
		return m.Metadata()
	case grant.FieldCreatedAt:
		return m.CreatedAt()
	case grant.FieldUpdatedAt:
		return m.UpdatedAt()
	case grant.FieldDeletedAt:
		return m.DeletedAt()
	case grant.FieldOwnerID:
		return m.OwnerID()
	case grant.FieldAmount:
		return m.Amount()
	case grant.FieldPriority:
		return m.Priority()
	case grant.FieldEffectiveAt:
		return m.EffectiveAt()
	case grant.FieldExpiration:
		return m.Expiration()
	case grant.FieldExpiresAt:
		return m.ExpiresAt()
	case grant.FieldVoidedAt:
		return m.VoidedAt()
	case grant.FieldResetMaxRollover:
		return m.ResetMaxRollover()
	case grant.FieldRecurrencePeriod:
		return m.RecurrencePeriod()
	case grant.FieldRecurrenceAnchor:
		return m.RecurrenceAnchor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GrantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grant.FieldNamespace:
		return m.OldNamespace(ctx)
	case grant.FieldMetadata:
		return m.OldMetadata(ctx)
	case grant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case grant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case grant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case grant.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case grant.FieldAmount:
		return m.OldAmount(ctx)
	case grant.FieldPriority:
		return m.OldPriority(ctx)
	case grant.FieldEffectiveAt:
		return m.OldEffectiveAt(ctx)
	case grant.FieldExpiration:
		return m.OldExpiration(ctx)
	case grant.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case grant.FieldVoidedAt:
		return m.OldVoidedAt(ctx)
	case grant.FieldResetMaxRollover:
		return m.OldResetMaxRollover(ctx)
	case grant.FieldRecurrencePeriod:
		return m.OldRecurrencePeriod(ctx)
	case grant.FieldRecurrenceAnchor:
		return m.OldRecurrenceAnchor(ctx)
	}
	return nil, fmt.Errorf("unknown Grant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grant.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case grant.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case grant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case grant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case grant.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case grant.FieldOwnerID:
		v, ok := value.(credit.GrantOwner)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case grant.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case grant.FieldPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case grant.FieldEffectiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveAt(v)
		return nil
	case grant.FieldExpiration:
		v, ok := value.(credit.ExpirationPeriod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case grant.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case grant.FieldVoidedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidedAt(v)
		return nil
	case grant.FieldResetMaxRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetMaxRollover(v)
		return nil
	case grant.FieldRecurrencePeriod:
		v, ok := value.(credit.RecurrencePeriod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrencePeriod(v)
		return nil
	case grant.FieldRecurrenceAnchor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrenceAnchor(v)
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GrantMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, grant.FieldAmount)
	}
	if m.addpriority != nil {
		fields = append(fields, grant.FieldPriority)
	}
	if m.addreset_max_rollover != nil {
		fields = append(fields, grant.FieldResetMaxRollover)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GrantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case grant.FieldAmount:
		return m.AddedAmount()
	case grant.FieldPriority:
		return m.AddedPriority()
	case grant.FieldResetMaxRollover:
		return m.AddedResetMaxRollover()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case grant.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case grant.FieldPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case grant.FieldResetMaxRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResetMaxRollover(v)
		return nil
	}
	return fmt.Errorf("unknown Grant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GrantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(grant.FieldMetadata) {
		fields = append(fields, grant.FieldMetadata)
	}
	if m.FieldCleared(grant.FieldDeletedAt) {
		fields = append(fields, grant.FieldDeletedAt)
	}
	if m.FieldCleared(grant.FieldVoidedAt) {
		fields = append(fields, grant.FieldVoidedAt)
	}
	if m.FieldCleared(grant.FieldRecurrencePeriod) {
		fields = append(fields, grant.FieldRecurrencePeriod)
	}
	if m.FieldCleared(grant.FieldRecurrenceAnchor) {
		fields = append(fields, grant.FieldRecurrenceAnchor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GrantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrantMutation) ClearField(name string) error {
	switch name {
	case grant.FieldMetadata:
		m.ClearMetadata()
		return nil
	case grant.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case grant.FieldVoidedAt:
		m.ClearVoidedAt()
		return nil
	case grant.FieldRecurrencePeriod:
		m.ClearRecurrencePeriod()
		return nil
	case grant.FieldRecurrenceAnchor:
		m.ClearRecurrenceAnchor()
		return nil
	}
	return fmt.Errorf("unknown Grant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GrantMutation) ResetField(name string) error {
	switch name {
	case grant.FieldNamespace:
		m.ResetNamespace()
		return nil
	case grant.FieldMetadata:
		m.ResetMetadata()
		return nil
	case grant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case grant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case grant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case grant.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case grant.FieldAmount:
		m.ResetAmount()
		return nil
	case grant.FieldPriority:
		m.ResetPriority()
		return nil
	case grant.FieldEffectiveAt:
		m.ResetEffectiveAt()
		return nil
	case grant.FieldExpiration:
		m.ResetExpiration()
		return nil
	case grant.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case grant.FieldVoidedAt:
		m.ResetVoidedAt()
		return nil
	case grant.FieldResetMaxRollover:
		m.ResetResetMaxRollover()
		return nil
	case grant.FieldRecurrencePeriod:
		m.ResetRecurrencePeriod()
		return nil
	case grant.FieldRecurrenceAnchor:
		m.ResetRecurrenceAnchor()
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GrantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GrantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GrantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GrantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GrantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GrantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GrantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Grant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GrantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Grant edge %s", name)
}
