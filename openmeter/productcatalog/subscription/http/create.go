package httpdriver

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/samber/lo"

	"github.com/openmeterio/openmeter/api"
	"github.com/openmeterio/openmeter/openmeter/customer"
	"github.com/openmeterio/openmeter/openmeter/productcatalog"
	"github.com/openmeterio/openmeter/openmeter/productcatalog/plan"
	plansubscription "github.com/openmeterio/openmeter/openmeter/productcatalog/subscription"
	"github.com/openmeterio/openmeter/openmeter/subscription"
	subscriptionworkflow "github.com/openmeterio/openmeter/openmeter/subscription/workflow"
	"github.com/openmeterio/openmeter/pkg/clock"
	"github.com/openmeterio/openmeter/pkg/defaultx"
	"github.com/openmeterio/openmeter/pkg/framework/commonhttp"
	"github.com/openmeterio/openmeter/pkg/framework/transport/httptransport"
	"github.com/openmeterio/openmeter/pkg/models"
)

type (
	CreateSubscriptionRequest = plansubscription.CreateSubscriptionRequest

	CreateSubscriptionResponse = api.Subscription
	CreateSubscriptionHandler  = httptransport.Handler[CreateSubscriptionRequest, CreateSubscriptionResponse]
)

func (h *handler) CreateSubscription() CreateSubscriptionHandler {
	return httptransport.NewHandler(
		func(ctx context.Context, r *http.Request) (CreateSubscriptionRequest, error) {
			body := api.CreateSubscriptionJSONRequestBody{}

			if err := commonhttp.JSONRequestBodyDecoder(r, &body); err != nil {
				return CreateSubscriptionRequest{}, err
			}

			ns, err := h.resolveNamespace(ctx)
			if err != nil {
				return CreateSubscriptionRequest{}, fmt.Errorf("failed to resolve namespace: %w", err)
			}

			workflowInput := subscriptionworkflow.CreateSubscriptionWorkflowInput{
				Namespace: ns,
			}

			planInput := plansubscription.PlanInput{}
			var customerID *string
			var customerKey *string
			var startingPhase *string

			// Any transformation function generated by the API will succeed if the body is serializable, so we have to check for the presence of
			// fields to determine what body type we're dealing with
			type testForCustomPlan struct {
				CustomPlan any `json:"customPlan"`
			}

			var t testForCustomPlan

			bodyBytes, err := json.Marshal(body)
			if err != nil {
				return CreateSubscriptionRequest{}, fmt.Errorf("failed to marshal request body: %w", err)
			}

			if err := json.Unmarshal(bodyBytes, &t); err != nil {
				return CreateSubscriptionRequest{}, fmt.Errorf("failed to unmarshal request body: %w", err)
			}

			if t.CustomPlan != nil {
				// Process as custom subscription
				b, err := body.AsCustomSubscriptionCreate()
				if err != nil {
					return CreateSubscriptionRequest{}, models.NewGenericValidationError(fmt.Errorf("invalid request body: %w", err))
				}

				// Convert API input to plan creation input using the mapping function
				createPlanInput, err := AsCustomPlanCreateInput(b.CustomPlan, ns)
				if err != nil {
					return CreateSubscriptionRequest{}, models.NewGenericValidationError(err)
				}

				// Create the custom plan and set the reference to it in the plan input
				customPlan, err := h.PlanService.CreatePlan(ctx, createPlanInput)
				if err != nil {
					return CreateSubscriptionRequest{}, fmt.Errorf("failed to create custom plan: %w", err)
				}

				// Publish the custom plan to make it active
				effectiveFrom := createPlanInput.EffectiveFrom
				if effectiveFrom == nil {
					effectiveFrom = lo.ToPtr(clock.Now())
				}
				customPlan, err = h.PlanService.PublishPlan(ctx, plan.PublishPlanInput{
					NamespacedID: customPlan.NamespacedID,
					EffectivePeriod: productcatalog.EffectivePeriod{
						EffectiveFrom: effectiveFrom,
						EffectiveTo:   createPlanInput.EffectiveTo,
					},
				})
				if err != nil {
					return CreateSubscriptionRequest{}, fmt.Errorf("failed to publish custom plan: %w", err)
				}

				planInput.FromRef(&plansubscription.PlanRefInput{
					Key:     customPlan.Key,
					Version: &customPlan.Version,
				})

				timing := subscription.Timing{
					Enum: lo.ToPtr(subscription.TimingImmediate),
				}
				if b.Timing != nil {
					timing, err = MapAPITimingToTiming(*b.Timing)
					if err != nil {
						return CreateSubscriptionRequest{}, err
					}
				}

				customerID = b.CustomerId
				customerKey = b.CustomerKey

				workflowInput.ChangeSubscriptionWorkflowInput = subscriptionworkflow.ChangeSubscriptionWorkflowInput{
					Timing:      timing,
					Name:        defaultx.IfZero(b.CustomPlan.Name, customPlan.Name),
					Description: b.CustomPlan.Description,
					MetadataModel: models.MetadataModel{
						Metadata: lo.FromPtrOr(b.CustomPlan.Metadata, make(map[string]string)),
					},
				}
			} else {
				// Process as plan subscription
				b, err := body.AsPlanSubscriptionCreate()
				if err != nil {
					return CreateSubscriptionRequest{}, models.NewGenericValidationError(fmt.Errorf("invalid request body: %w", err))
				}

				p, err := h.PlanService.GetPlan(ctx, plan.GetPlanInput{
					NamespacedID: models.NamespacedID{
						Namespace: ns,
					},
					Key:     b.Plan.Key,
					Version: lo.FromPtrOr(b.Plan.Version, 0),
				})
				if err != nil {
					return CreateSubscriptionRequest{}, err
				}

				// Handle as plan subscription (works for both original plan refs and modified custom plans)
				planInput.FromRef(&plansubscription.PlanRefInput{
					Key:     b.Plan.Key,
					Version: b.Plan.Version,
				})

				timing := subscription.Timing{
					Enum: lo.ToPtr(subscription.TimingImmediate),
				}
				if b.Timing != nil {
					timing, err = MapAPITimingToTiming(*b.Timing)
					if err != nil {
						return CreateSubscriptionRequest{}, err
					}
				}

				customerID = b.CustomerId
				customerKey = b.CustomerKey

				workflowInput.ChangeSubscriptionWorkflowInput = subscriptionworkflow.ChangeSubscriptionWorkflowInput{
					Timing:      timing,
					Name:        lo.FromPtrOr(b.Name, p.Name),
					Description: b.Description,
					MetadataModel: models.MetadataModel{
						Metadata: lo.FromPtrOr(b.Metadata, make(map[string]string)),
					},
				}
			}

			// Get the customer
			customer, err := h.getCustomer(ctx, ns, customerID, customerKey)
			if err != nil {
				return CreateSubscriptionRequest{}, err
			}
			workflowInput.CustomerID = customer.ID

			return CreateSubscriptionRequest{
				WorkflowInput: workflowInput,
				PlanInput:     planInput,
				StartingPhase: startingPhase,
			}, nil
		},
		func(ctx context.Context, request CreateSubscriptionRequest) (CreateSubscriptionResponse, error) {
			res, err := h.PlanSubscriptionService.Create(ctx, request)
			if err != nil {
				return CreateSubscriptionResponse{}, err
			}

			return MapSubscriptionToAPI(res), nil
		},
		commonhttp.JSONResponseEncoderWithStatus[CreateSubscriptionResponse](http.StatusCreated),
		httptransport.AppendOptions(
			h.Options,
			httptransport.WithOperationName("createSubscription"),
			httptransport.WithErrorEncoder(errorEncoder()),
		)...,
	)
}

// getCustomer gets a customer by ID or key.
func (h *handler) getCustomer(ctx context.Context, namespace string, id *string, key *string) (*customer.Customer, error) {
	if namespace == "" {
		return nil, fmt.Errorf("namespace is required")
	}

	if id == nil && key == nil {
		return nil, fmt.Errorf("id or key is required")
	}

	var (
		cus *customer.Customer
		err error
	)

	if id != nil {
		cus, err = h.CustomerService.GetCustomer(ctx, customer.GetCustomerInput{
			CustomerID: &customer.CustomerID{
				ID:        *id,
				Namespace: namespace,
			},
		})
	}

	if key != nil {
		cus, err = h.CustomerService.GetCustomer(ctx, customer.GetCustomerInput{
			CustomerKey: &customer.CustomerKey{
				Key:       *key,
				Namespace: namespace,
			},
		})
	}

	if err != nil {
		return nil, err
	}

	return cus, nil
}
