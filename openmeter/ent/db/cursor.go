// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"github.com/openmeterio/openmeter/pkg/pagination/v2"
	"github.com/samber/lo"
)

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *AddonQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*Addon], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*Addon]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*Addon]{}, err
	}

	if items == nil {
		items = make([]*Addon, 0)
	}

	result := pagination.Result[*Addon]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *AddonRateCardQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*AddonRateCard], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*AddonRateCard]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*AddonRateCard]{}, err
	}

	if items == nil {
		items = make([]*AddonRateCard, 0)
	}

	result := pagination.Result[*AddonRateCard]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *AppQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*App], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*App]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*App]{}, err
	}

	if items == nil {
		items = make([]*App, 0)
	}

	result := pagination.Result[*App]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *AppCustomInvoicingQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*AppCustomInvoicing], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*AppCustomInvoicing]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*AppCustomInvoicing]{}, err
	}

	if items == nil {
		items = make([]*AppCustomInvoicing, 0)
	}

	result := pagination.Result[*AppCustomInvoicing]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *AppCustomInvoicingCustomerQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*AppCustomInvoicingCustomer], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*AppCustomInvoicingCustomer]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*AppCustomInvoicingCustomer]{}, err
	}

	if items == nil {
		items = make([]*AppCustomInvoicingCustomer, 0)
	}

	result := pagination.Result[*AppCustomInvoicingCustomer]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *AppCustomerQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*AppCustomer], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*AppCustomer]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*AppCustomer]{}, err
	}

	if items == nil {
		items = make([]*AppCustomer, 0)
	}

	result := pagination.Result[*AppCustomer]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *AppStripeQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*AppStripe], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*AppStripe]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*AppStripe]{}, err
	}

	if items == nil {
		items = make([]*AppStripe, 0)
	}

	result := pagination.Result[*AppStripe]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *AppStripeCustomerQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*AppStripeCustomer], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*AppStripeCustomer]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*AppStripeCustomer]{}, err
	}

	if items == nil {
		items = make([]*AppStripeCustomer, 0)
	}

	result := pagination.Result[*AppStripeCustomer]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BalanceSnapshotQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BalanceSnapshot], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BalanceSnapshot]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BalanceSnapshot]{}, err
	}

	if items == nil {
		items = make([]*BalanceSnapshot, 0)
	}

	result := pagination.Result[*BalanceSnapshot]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingCustomerOverrideQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingCustomerOverride], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingCustomerOverride]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingCustomerOverride]{}, err
	}

	if items == nil {
		items = make([]*BillingCustomerOverride, 0)
	}

	result := pagination.Result[*BillingCustomerOverride]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingInvoiceQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingInvoice], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingInvoice]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingInvoice]{}, err
	}

	if items == nil {
		items = make([]*BillingInvoice, 0)
	}

	result := pagination.Result[*BillingInvoice]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingInvoiceLineQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingInvoiceLine], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingInvoiceLine]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingInvoiceLine]{}, err
	}

	if items == nil {
		items = make([]*BillingInvoiceLine, 0)
	}

	result := pagination.Result[*BillingInvoiceLine]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingInvoiceLineDiscountQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingInvoiceLineDiscount], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingInvoiceLineDiscount]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingInvoiceLineDiscount]{}, err
	}

	if items == nil {
		items = make([]*BillingInvoiceLineDiscount, 0)
	}

	result := pagination.Result[*BillingInvoiceLineDiscount]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingInvoiceLineUsageDiscountQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingInvoiceLineUsageDiscount], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingInvoiceLineUsageDiscount]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingInvoiceLineUsageDiscount]{}, err
	}

	if items == nil {
		items = make([]*BillingInvoiceLineUsageDiscount, 0)
	}

	result := pagination.Result[*BillingInvoiceLineUsageDiscount]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingInvoiceSplitLineGroupQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingInvoiceSplitLineGroup], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingInvoiceSplitLineGroup]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingInvoiceSplitLineGroup]{}, err
	}

	if items == nil {
		items = make([]*BillingInvoiceSplitLineGroup, 0)
	}

	result := pagination.Result[*BillingInvoiceSplitLineGroup]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingInvoiceValidationIssueQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingInvoiceValidationIssue], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingInvoiceValidationIssue]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingInvoiceValidationIssue]{}, err
	}

	if items == nil {
		items = make([]*BillingInvoiceValidationIssue, 0)
	}

	result := pagination.Result[*BillingInvoiceValidationIssue]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingProfileQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingProfile], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingProfile]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingProfile]{}, err
	}

	if items == nil {
		items = make([]*BillingProfile, 0)
	}

	result := pagination.Result[*BillingProfile]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingStandardInvoiceDetailedLineQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingStandardInvoiceDetailedLine], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingStandardInvoiceDetailedLine]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingStandardInvoiceDetailedLine]{}, err
	}

	if items == nil {
		items = make([]*BillingStandardInvoiceDetailedLine, 0)
	}

	result := pagination.Result[*BillingStandardInvoiceDetailedLine]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingStandardInvoiceDetailedLineAmountDiscountQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingStandardInvoiceDetailedLineAmountDiscount], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingStandardInvoiceDetailedLineAmountDiscount]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingStandardInvoiceDetailedLineAmountDiscount]{}, err
	}

	if items == nil {
		items = make([]*BillingStandardInvoiceDetailedLineAmountDiscount, 0)
	}

	result := pagination.Result[*BillingStandardInvoiceDetailedLineAmountDiscount]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *BillingWorkflowConfigQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*BillingWorkflowConfig], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*BillingWorkflowConfig]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*BillingWorkflowConfig]{}, err
	}

	if items == nil {
		items = make([]*BillingWorkflowConfig, 0)
	}

	result := pagination.Result[*BillingWorkflowConfig]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *CustomerQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*Customer], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*Customer]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*Customer]{}, err
	}

	if items == nil {
		items = make([]*Customer, 0)
	}

	result := pagination.Result[*Customer]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *CustomerSubjectsQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*CustomerSubjects], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*CustomerSubjects]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*CustomerSubjects]{}, err
	}

	if items == nil {
		items = make([]*CustomerSubjects, 0)
	}

	result := pagination.Result[*CustomerSubjects]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *EntitlementQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*Entitlement], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*Entitlement]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*Entitlement]{}, err
	}

	if items == nil {
		items = make([]*Entitlement, 0)
	}

	result := pagination.Result[*Entitlement]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *FeatureQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*Feature], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*Feature]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*Feature]{}, err
	}

	if items == nil {
		items = make([]*Feature, 0)
	}

	result := pagination.Result[*Feature]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *GrantQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*Grant], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*Grant]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*Grant]{}, err
	}

	if items == nil {
		items = make([]*Grant, 0)
	}

	result := pagination.Result[*Grant]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *LedgerAccountQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*LedgerAccount], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*LedgerAccount]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*LedgerAccount]{}, err
	}

	if items == nil {
		items = make([]*LedgerAccount, 0)
	}

	result := pagination.Result[*LedgerAccount]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *LedgerCustomerAccountQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*LedgerCustomerAccount], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*LedgerCustomerAccount]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*LedgerCustomerAccount]{}, err
	}

	if items == nil {
		items = make([]*LedgerCustomerAccount, 0)
	}

	result := pagination.Result[*LedgerCustomerAccount]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *LedgerDimensionQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*LedgerDimension], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*LedgerDimension]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*LedgerDimension]{}, err
	}

	if items == nil {
		items = make([]*LedgerDimension, 0)
	}

	result := pagination.Result[*LedgerDimension]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *LedgerEntryQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*LedgerEntry], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*LedgerEntry]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*LedgerEntry]{}, err
	}

	if items == nil {
		items = make([]*LedgerEntry, 0)
	}

	result := pagination.Result[*LedgerEntry]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *LedgerSubAccountQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*LedgerSubAccount], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*LedgerSubAccount]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*LedgerSubAccount]{}, err
	}

	if items == nil {
		items = make([]*LedgerSubAccount, 0)
	}

	result := pagination.Result[*LedgerSubAccount]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *LedgerTransactionQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*LedgerTransaction], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*LedgerTransaction]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*LedgerTransaction]{}, err
	}

	if items == nil {
		items = make([]*LedgerTransaction, 0)
	}

	result := pagination.Result[*LedgerTransaction]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *LedgerTransactionGroupQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*LedgerTransactionGroup], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*LedgerTransactionGroup]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*LedgerTransactionGroup]{}, err
	}

	if items == nil {
		items = make([]*LedgerTransactionGroup, 0)
	}

	result := pagination.Result[*LedgerTransactionGroup]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *MeterQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*Meter], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*Meter]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*Meter]{}, err
	}

	if items == nil {
		items = make([]*Meter, 0)
	}

	result := pagination.Result[*Meter]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *NotificationChannelQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*NotificationChannel], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*NotificationChannel]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*NotificationChannel]{}, err
	}

	if items == nil {
		items = make([]*NotificationChannel, 0)
	}

	result := pagination.Result[*NotificationChannel]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *NotificationEventQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*NotificationEvent], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*NotificationEvent]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*NotificationEvent]{}, err
	}

	if items == nil {
		items = make([]*NotificationEvent, 0)
	}

	result := pagination.Result[*NotificationEvent]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *NotificationEventDeliveryStatusQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*NotificationEventDeliveryStatus], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*NotificationEventDeliveryStatus]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*NotificationEventDeliveryStatus]{}, err
	}

	if items == nil {
		items = make([]*NotificationEventDeliveryStatus, 0)
	}

	result := pagination.Result[*NotificationEventDeliveryStatus]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *NotificationRuleQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*NotificationRule], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*NotificationRule]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*NotificationRule]{}, err
	}

	if items == nil {
		items = make([]*NotificationRule, 0)
	}

	result := pagination.Result[*NotificationRule]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *PlanQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*Plan], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*Plan]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*Plan]{}, err
	}

	if items == nil {
		items = make([]*Plan, 0)
	}

	result := pagination.Result[*Plan]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *PlanAddonQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*PlanAddon], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*PlanAddon]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*PlanAddon]{}, err
	}

	if items == nil {
		items = make([]*PlanAddon, 0)
	}

	result := pagination.Result[*PlanAddon]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *PlanPhaseQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*PlanPhase], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*PlanPhase]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*PlanPhase]{}, err
	}

	if items == nil {
		items = make([]*PlanPhase, 0)
	}

	result := pagination.Result[*PlanPhase]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *PlanRateCardQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*PlanRateCard], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*PlanRateCard]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*PlanRateCard]{}, err
	}

	if items == nil {
		items = make([]*PlanRateCard, 0)
	}

	result := pagination.Result[*PlanRateCard]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *SubjectQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*Subject], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*Subject]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*Subject]{}, err
	}

	if items == nil {
		items = make([]*Subject, 0)
	}

	result := pagination.Result[*Subject]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *SubscriptionQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*Subscription], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*Subscription]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*Subscription]{}, err
	}

	if items == nil {
		items = make([]*Subscription, 0)
	}

	result := pagination.Result[*Subscription]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *SubscriptionAddonQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*SubscriptionAddon], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*SubscriptionAddon]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*SubscriptionAddon]{}, err
	}

	if items == nil {
		items = make([]*SubscriptionAddon, 0)
	}

	result := pagination.Result[*SubscriptionAddon]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *SubscriptionAddonQuantityQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*SubscriptionAddonQuantity], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*SubscriptionAddonQuantity]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*SubscriptionAddonQuantity]{}, err
	}

	if items == nil {
		items = make([]*SubscriptionAddonQuantity, 0)
	}

	result := pagination.Result[*SubscriptionAddonQuantity]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *SubscriptionItemQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*SubscriptionItem], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*SubscriptionItem]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*SubscriptionItem]{}, err
	}

	if items == nil {
		items = make([]*SubscriptionItem, 0)
	}

	result := pagination.Result[*SubscriptionItem]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *SubscriptionPhaseQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*SubscriptionPhase], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*SubscriptionPhase]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*SubscriptionPhase]{}, err
	}

	if items == nil {
		items = make([]*SubscriptionPhase, 0)
	}

	result := pagination.Result[*SubscriptionPhase]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *TaxCodeQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*TaxCode], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*TaxCode]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*TaxCode]{}, err
	}

	if items == nil {
		items = make([]*TaxCode, 0)
	}

	result := pagination.Result[*TaxCode]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}

// Cursor runs the query and returns a cursor-paginated response.
// Ordering is always by created_at asc, id asc.
func (_m *UsageResetQuery) Cursor(ctx context.Context, cursor *pagination.Cursor) (pagination.Result[*UsageReset], error) {
	if cursor != nil {
		if err := cursor.Validate(); err != nil {
			return pagination.Result[*UsageReset]{}, fmt.Errorf("invalid cursor: %w", err)
		}

		_m.Where(func(s *sql.Selector) {
			s.Where(
				sql.Or(
					sql.GT(s.C("created_at"), cursor.Time),
					sql.And(
						sql.EQ(s.C("created_at"), cursor.Time),
						sql.P(func(b *sql.Builder) {
							b.WriteString("CAST(")
							b.WriteString(s.C("id"))
							b.WriteString(" AS TEXT) > ")
							b.Args(cursor.ID)
						}),
					),
				),
			)
		})
	}

	_m.Order(func(s *sql.Selector) {
		s.OrderBy(sql.Asc(s.C("created_at")), sql.Asc(s.C("id")))
	})

	items, err := _m.All(ctx)
	if err != nil {
		return pagination.Result[*UsageReset]{}, err
	}

	if items == nil {
		items = make([]*UsageReset, 0)
	}

	result := pagination.Result[*UsageReset]{
		Items: items,
	}

	if len(items) > 0 {
		last := items[len(items)-1]
		result.NextCursor = lo.ToPtr(pagination.NewCursor(last.CreatedAt, fmt.Sprint(last.ID)))
	}

	return result, nil
}
