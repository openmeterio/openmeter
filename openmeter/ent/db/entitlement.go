// Code generated by ent, DO NOT EDIT.

package db

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/openmeterio/openmeter/openmeter/ent/db/customer"
	"github.com/openmeterio/openmeter/openmeter/ent/db/entitlement"
	"github.com/openmeterio/openmeter/openmeter/ent/db/feature"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subject"
	"github.com/openmeterio/openmeter/pkg/datetime"
	"github.com/openmeterio/openmeter/pkg/models"
)

// Entitlement is the model entity for the Entitlement schema.
type Entitlement struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Namespace holds the value of the "namespace" field.
	Namespace string `json:"namespace,omitempty"`
	// Metadata holds the value of the "metadata" field.
	Metadata map[string]string `json:"metadata,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
	// EntitlementType holds the value of the "entitlement_type" field.
	EntitlementType entitlement.EntitlementType `json:"entitlement_type,omitempty"`
	// FeatureID holds the value of the "feature_id" field.
	FeatureID string `json:"feature_id,omitempty"`
	// ActiveFrom holds the value of the "active_from" field.
	ActiveFrom *time.Time `json:"active_from,omitempty"`
	// ActiveTo holds the value of the "active_to" field.
	ActiveTo *time.Time `json:"active_to,omitempty"`
	// FeatureKey holds the value of the "feature_key" field.
	FeatureKey string `json:"feature_key,omitempty"`
	// CustomerID holds the value of the "customer_id" field.
	CustomerID string `json:"customer_id,omitempty"`
	// SubjectID holds the value of the "subject_id" field.
	SubjectID string `json:"subject_id,omitempty"`
	// SubjectKey holds the value of the "subject_key" field.
	SubjectKey string `json:"subject_key,omitempty"`
	// MeasureUsageFrom holds the value of the "measure_usage_from" field.
	MeasureUsageFrom *time.Time `json:"measure_usage_from,omitempty"`
	// IssueAfterReset holds the value of the "issue_after_reset" field.
	IssueAfterReset *float64 `json:"issue_after_reset,omitempty"`
	// IssueAfterResetPriority holds the value of the "issue_after_reset_priority" field.
	IssueAfterResetPriority *uint8 `json:"issue_after_reset_priority,omitempty"`
	// IsSoftLimit holds the value of the "is_soft_limit" field.
	IsSoftLimit *bool `json:"is_soft_limit,omitempty"`
	// PreserveOverageAtReset holds the value of the "preserve_overage_at_reset" field.
	PreserveOverageAtReset *bool `json:"preserve_overage_at_reset,omitempty"`
	// Config holds the value of the "config" field.
	Config []uint8 `json:"config,omitempty"`
	// UsagePeriodInterval holds the value of the "usage_period_interval" field.
	UsagePeriodInterval *datetime.ISODurationString `json:"usage_period_interval,omitempty"`
	// Historically this field had been overwritten with each anchor reset, now we keep the original anchor time and the value is populated from the last reset which is queried dynamically
	UsagePeriodAnchor *time.Time `json:"usage_period_anchor,omitempty"`
	// CurrentUsagePeriodStart holds the value of the "current_usage_period_start" field.
	CurrentUsagePeriodStart *time.Time `json:"current_usage_period_start,omitempty"`
	// CurrentUsagePeriodEnd holds the value of the "current_usage_period_end" field.
	CurrentUsagePeriodEnd *time.Time `json:"current_usage_period_end,omitempty"`
	// Annotations holds the value of the "annotations" field.
	Annotations models.Annotations `json:"annotations,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the EntitlementQuery when eager-loading is set.
	Edges        EntitlementEdges `json:"edges"`
	selectValues sql.SelectValues
}

// EntitlementEdges holds the relations/edges for other nodes in the graph.
type EntitlementEdges struct {
	// UsageReset holds the value of the usage_reset edge.
	UsageReset []*UsageReset `json:"usage_reset,omitempty"`
	// Grant holds the value of the grant edge.
	Grant []*Grant `json:"grant,omitempty"`
	// BalanceSnapshot holds the value of the balance_snapshot edge.
	BalanceSnapshot []*BalanceSnapshot `json:"balance_snapshot,omitempty"`
	// SubscriptionItem holds the value of the subscription_item edge.
	SubscriptionItem []*SubscriptionItem `json:"subscription_item,omitempty"`
	// Feature holds the value of the feature edge.
	Feature *Feature `json:"feature,omitempty"`
	// Customer holds the value of the customer edge.
	Customer *Customer `json:"customer,omitempty"`
	// Subject holds the value of the subject edge.
	Subject *Subject `json:"subject,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [7]bool
}

// UsageResetOrErr returns the UsageReset value or an error if the edge
// was not loaded in eager-loading.
func (e EntitlementEdges) UsageResetOrErr() ([]*UsageReset, error) {
	if e.loadedTypes[0] {
		return e.UsageReset, nil
	}
	return nil, &NotLoadedError{edge: "usage_reset"}
}

// GrantOrErr returns the Grant value or an error if the edge
// was not loaded in eager-loading.
func (e EntitlementEdges) GrantOrErr() ([]*Grant, error) {
	if e.loadedTypes[1] {
		return e.Grant, nil
	}
	return nil, &NotLoadedError{edge: "grant"}
}

// BalanceSnapshotOrErr returns the BalanceSnapshot value or an error if the edge
// was not loaded in eager-loading.
func (e EntitlementEdges) BalanceSnapshotOrErr() ([]*BalanceSnapshot, error) {
	if e.loadedTypes[2] {
		return e.BalanceSnapshot, nil
	}
	return nil, &NotLoadedError{edge: "balance_snapshot"}
}

// SubscriptionItemOrErr returns the SubscriptionItem value or an error if the edge
// was not loaded in eager-loading.
func (e EntitlementEdges) SubscriptionItemOrErr() ([]*SubscriptionItem, error) {
	if e.loadedTypes[3] {
		return e.SubscriptionItem, nil
	}
	return nil, &NotLoadedError{edge: "subscription_item"}
}

// FeatureOrErr returns the Feature value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e EntitlementEdges) FeatureOrErr() (*Feature, error) {
	if e.Feature != nil {
		return e.Feature, nil
	} else if e.loadedTypes[4] {
		return nil, &NotFoundError{label: feature.Label}
	}
	return nil, &NotLoadedError{edge: "feature"}
}

// CustomerOrErr returns the Customer value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e EntitlementEdges) CustomerOrErr() (*Customer, error) {
	if e.Customer != nil {
		return e.Customer, nil
	} else if e.loadedTypes[5] {
		return nil, &NotFoundError{label: customer.Label}
	}
	return nil, &NotLoadedError{edge: "customer"}
}

// SubjectOrErr returns the Subject value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e EntitlementEdges) SubjectOrErr() (*Subject, error) {
	if e.Subject != nil {
		return e.Subject, nil
	} else if e.loadedTypes[6] {
		return nil, &NotFoundError{label: subject.Label}
	}
	return nil, &NotLoadedError{edge: "subject"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Entitlement) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case entitlement.FieldMetadata, entitlement.FieldConfig:
			values[i] = new([]byte)
		case entitlement.FieldIsSoftLimit, entitlement.FieldPreserveOverageAtReset:
			values[i] = new(sql.NullBool)
		case entitlement.FieldIssueAfterReset:
			values[i] = new(sql.NullFloat64)
		case entitlement.FieldIssueAfterResetPriority:
			values[i] = new(sql.NullInt64)
		case entitlement.FieldID, entitlement.FieldNamespace, entitlement.FieldEntitlementType, entitlement.FieldFeatureID, entitlement.FieldFeatureKey, entitlement.FieldCustomerID, entitlement.FieldSubjectID, entitlement.FieldSubjectKey, entitlement.FieldUsagePeriodInterval:
			values[i] = new(sql.NullString)
		case entitlement.FieldCreatedAt, entitlement.FieldUpdatedAt, entitlement.FieldDeletedAt, entitlement.FieldActiveFrom, entitlement.FieldActiveTo, entitlement.FieldMeasureUsageFrom, entitlement.FieldUsagePeriodAnchor, entitlement.FieldCurrentUsagePeriodStart, entitlement.FieldCurrentUsagePeriodEnd:
			values[i] = new(sql.NullTime)
		case entitlement.FieldAnnotations:
			values[i] = entitlement.ValueScanner.Annotations.ScanValue()
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Entitlement fields.
func (_m *Entitlement) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case entitlement.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				_m.ID = value.String
			}
		case entitlement.FieldNamespace:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field namespace", values[i])
			} else if value.Valid {
				_m.Namespace = value.String
			}
		case entitlement.FieldMetadata:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field metadata", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Metadata); err != nil {
					return fmt.Errorf("unmarshal field metadata: %w", err)
				}
			}
		case entitlement.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case entitlement.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case entitlement.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				_m.DeletedAt = new(time.Time)
				*_m.DeletedAt = value.Time
			}
		case entitlement.FieldEntitlementType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field entitlement_type", values[i])
			} else if value.Valid {
				_m.EntitlementType = entitlement.EntitlementType(value.String)
			}
		case entitlement.FieldFeatureID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field feature_id", values[i])
			} else if value.Valid {
				_m.FeatureID = value.String
			}
		case entitlement.FieldActiveFrom:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field active_from", values[i])
			} else if value.Valid {
				_m.ActiveFrom = new(time.Time)
				*_m.ActiveFrom = value.Time
			}
		case entitlement.FieldActiveTo:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field active_to", values[i])
			} else if value.Valid {
				_m.ActiveTo = new(time.Time)
				*_m.ActiveTo = value.Time
			}
		case entitlement.FieldFeatureKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field feature_key", values[i])
			} else if value.Valid {
				_m.FeatureKey = value.String
			}
		case entitlement.FieldCustomerID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field customer_id", values[i])
			} else if value.Valid {
				_m.CustomerID = value.String
			}
		case entitlement.FieldSubjectID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field subject_id", values[i])
			} else if value.Valid {
				_m.SubjectID = value.String
			}
		case entitlement.FieldSubjectKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field subject_key", values[i])
			} else if value.Valid {
				_m.SubjectKey = value.String
			}
		case entitlement.FieldMeasureUsageFrom:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field measure_usage_from", values[i])
			} else if value.Valid {
				_m.MeasureUsageFrom = new(time.Time)
				*_m.MeasureUsageFrom = value.Time
			}
		case entitlement.FieldIssueAfterReset:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field issue_after_reset", values[i])
			} else if value.Valid {
				_m.IssueAfterReset = new(float64)
				*_m.IssueAfterReset = value.Float64
			}
		case entitlement.FieldIssueAfterResetPriority:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field issue_after_reset_priority", values[i])
			} else if value.Valid {
				_m.IssueAfterResetPriority = new(uint8)
				*_m.IssueAfterResetPriority = uint8(value.Int64)
			}
		case entitlement.FieldIsSoftLimit:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_soft_limit", values[i])
			} else if value.Valid {
				_m.IsSoftLimit = new(bool)
				*_m.IsSoftLimit = value.Bool
			}
		case entitlement.FieldPreserveOverageAtReset:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field preserve_overage_at_reset", values[i])
			} else if value.Valid {
				_m.PreserveOverageAtReset = new(bool)
				*_m.PreserveOverageAtReset = value.Bool
			}
		case entitlement.FieldConfig:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field config", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Config); err != nil {
					return fmt.Errorf("unmarshal field config: %w", err)
				}
			}
		case entitlement.FieldUsagePeriodInterval:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field usage_period_interval", values[i])
			} else if value.Valid {
				_m.UsagePeriodInterval = new(datetime.ISODurationString)
				*_m.UsagePeriodInterval = datetime.ISODurationString(value.String)
			}
		case entitlement.FieldUsagePeriodAnchor:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field usage_period_anchor", values[i])
			} else if value.Valid {
				_m.UsagePeriodAnchor = new(time.Time)
				*_m.UsagePeriodAnchor = value.Time
			}
		case entitlement.FieldCurrentUsagePeriodStart:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field current_usage_period_start", values[i])
			} else if value.Valid {
				_m.CurrentUsagePeriodStart = new(time.Time)
				*_m.CurrentUsagePeriodStart = value.Time
			}
		case entitlement.FieldCurrentUsagePeriodEnd:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field current_usage_period_end", values[i])
			} else if value.Valid {
				_m.CurrentUsagePeriodEnd = new(time.Time)
				*_m.CurrentUsagePeriodEnd = value.Time
			}
		case entitlement.FieldAnnotations:
			if value, err := entitlement.ValueScanner.Annotations.FromValue(values[i]); err != nil {
				return err
			} else {
				_m.Annotations = value
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Entitlement.
// This includes values selected through modifiers, order, etc.
func (_m *Entitlement) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryUsageReset queries the "usage_reset" edge of the Entitlement entity.
func (_m *Entitlement) QueryUsageReset() *UsageResetQuery {
	return NewEntitlementClient(_m.config).QueryUsageReset(_m)
}

// QueryGrant queries the "grant" edge of the Entitlement entity.
func (_m *Entitlement) QueryGrant() *GrantQuery {
	return NewEntitlementClient(_m.config).QueryGrant(_m)
}

// QueryBalanceSnapshot queries the "balance_snapshot" edge of the Entitlement entity.
func (_m *Entitlement) QueryBalanceSnapshot() *BalanceSnapshotQuery {
	return NewEntitlementClient(_m.config).QueryBalanceSnapshot(_m)
}

// QuerySubscriptionItem queries the "subscription_item" edge of the Entitlement entity.
func (_m *Entitlement) QuerySubscriptionItem() *SubscriptionItemQuery {
	return NewEntitlementClient(_m.config).QuerySubscriptionItem(_m)
}

// QueryFeature queries the "feature" edge of the Entitlement entity.
func (_m *Entitlement) QueryFeature() *FeatureQuery {
	return NewEntitlementClient(_m.config).QueryFeature(_m)
}

// QueryCustomer queries the "customer" edge of the Entitlement entity.
func (_m *Entitlement) QueryCustomer() *CustomerQuery {
	return NewEntitlementClient(_m.config).QueryCustomer(_m)
}

// QuerySubject queries the "subject" edge of the Entitlement entity.
func (_m *Entitlement) QuerySubject() *SubjectQuery {
	return NewEntitlementClient(_m.config).QuerySubject(_m)
}

// Update returns a builder for updating this Entitlement.
// Note that you need to call Entitlement.Unwrap() before calling this method if this Entitlement
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Entitlement) Update() *EntitlementUpdateOne {
	return NewEntitlementClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the Entitlement entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Entitlement) Unwrap() *Entitlement {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("db: Entitlement is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *Entitlement) String() string {
	var builder strings.Builder
	builder.WriteString("Entitlement(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("namespace=")
	builder.WriteString(_m.Namespace)
	builder.WriteString(", ")
	builder.WriteString("metadata=")
	builder.WriteString(fmt.Sprintf("%v", _m.Metadata))
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := _m.DeletedAt; v != nil {
		builder.WriteString("deleted_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("entitlement_type=")
	builder.WriteString(fmt.Sprintf("%v", _m.EntitlementType))
	builder.WriteString(", ")
	builder.WriteString("feature_id=")
	builder.WriteString(_m.FeatureID)
	builder.WriteString(", ")
	if v := _m.ActiveFrom; v != nil {
		builder.WriteString("active_from=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.ActiveTo; v != nil {
		builder.WriteString("active_to=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("feature_key=")
	builder.WriteString(_m.FeatureKey)
	builder.WriteString(", ")
	builder.WriteString("customer_id=")
	builder.WriteString(_m.CustomerID)
	builder.WriteString(", ")
	builder.WriteString("subject_id=")
	builder.WriteString(_m.SubjectID)
	builder.WriteString(", ")
	builder.WriteString("subject_key=")
	builder.WriteString(_m.SubjectKey)
	builder.WriteString(", ")
	if v := _m.MeasureUsageFrom; v != nil {
		builder.WriteString("measure_usage_from=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.IssueAfterReset; v != nil {
		builder.WriteString("issue_after_reset=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := _m.IssueAfterResetPriority; v != nil {
		builder.WriteString("issue_after_reset_priority=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := _m.IsSoftLimit; v != nil {
		builder.WriteString("is_soft_limit=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := _m.PreserveOverageAtReset; v != nil {
		builder.WriteString("preserve_overage_at_reset=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("config=")
	builder.WriteString(fmt.Sprintf("%v", _m.Config))
	builder.WriteString(", ")
	if v := _m.UsagePeriodInterval; v != nil {
		builder.WriteString("usage_period_interval=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := _m.UsagePeriodAnchor; v != nil {
		builder.WriteString("usage_period_anchor=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.CurrentUsagePeriodStart; v != nil {
		builder.WriteString("current_usage_period_start=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.CurrentUsagePeriodEnd; v != nil {
		builder.WriteString("current_usage_period_end=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("annotations=")
	builder.WriteString(fmt.Sprintf("%v", _m.Annotations))
	builder.WriteByte(')')
	return builder.String()
}

// Entitlements is a parsable slice of Entitlement.
type Entitlements []*Entitlement
