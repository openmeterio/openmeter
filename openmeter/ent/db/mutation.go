// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/alpacahq/alpacadecimal"
	appentitybase "github.com/openmeterio/openmeter/openmeter/app/entity/base"
	billingentity "github.com/openmeterio/openmeter/openmeter/billing/entity"
	"github.com/openmeterio/openmeter/openmeter/credit/balance"
	"github.com/openmeterio/openmeter/openmeter/credit/grant"
	"github.com/openmeterio/openmeter/openmeter/ent/db/app"
	"github.com/openmeterio/openmeter/openmeter/ent/db/appcustomer"
	"github.com/openmeterio/openmeter/openmeter/ent/db/appstripe"
	"github.com/openmeterio/openmeter/openmeter/ent/db/appstripecustomer"
	"github.com/openmeterio/openmeter/openmeter/ent/db/balancesnapshot"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingcustomeroverride"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoice"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoiceline"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoicemanuallineconfig"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoicevalidationissue"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingprofile"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingworkflowconfig"
	"github.com/openmeterio/openmeter/openmeter/ent/db/customer"
	"github.com/openmeterio/openmeter/openmeter/ent/db/customersubjects"
	"github.com/openmeterio/openmeter/openmeter/ent/db/entitlement"
	"github.com/openmeterio/openmeter/openmeter/ent/db/feature"
	dbgrant "github.com/openmeterio/openmeter/openmeter/ent/db/grant"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationchannel"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationevent"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationeventdeliverystatus"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationrule"
	dbplan "github.com/openmeterio/openmeter/openmeter/ent/db/plan"
	"github.com/openmeterio/openmeter/openmeter/ent/db/planphase"
	"github.com/openmeterio/openmeter/openmeter/ent/db/planratecard"
	"github.com/openmeterio/openmeter/openmeter/ent/db/predicate"
	"github.com/openmeterio/openmeter/openmeter/ent/db/price"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscription"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscriptionentitlement"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscriptionpatch"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscriptionpatchvalueadditem"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscriptionpatchvalueaddphase"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscriptionpatchvalueextendphase"
	"github.com/openmeterio/openmeter/openmeter/ent/db/usagereset"
	"github.com/openmeterio/openmeter/openmeter/notification"
	"github.com/openmeterio/openmeter/openmeter/productcatalog/plan"
	"github.com/openmeterio/openmeter/pkg/currencyx"
	"github.com/openmeterio/openmeter/pkg/datex"
	"github.com/openmeterio/openmeter/pkg/models"
	"github.com/openmeterio/openmeter/pkg/recurrence"
	"github.com/openmeterio/openmeter/pkg/timezone"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp                               = "App"
	TypeAppCustomer                       = "AppCustomer"
	TypeAppStripe                         = "AppStripe"
	TypeAppStripeCustomer                 = "AppStripeCustomer"
	TypeBalanceSnapshot                   = "BalanceSnapshot"
	TypeBillingCustomerOverride           = "BillingCustomerOverride"
	TypeBillingInvoice                    = "BillingInvoice"
	TypeBillingInvoiceLine                = "BillingInvoiceLine"
	TypeBillingInvoiceManualLineConfig    = "BillingInvoiceManualLineConfig"
	TypeBillingInvoiceValidationIssue     = "BillingInvoiceValidationIssue"
	TypeBillingProfile                    = "BillingProfile"
	TypeBillingWorkflowConfig             = "BillingWorkflowConfig"
	TypeCustomer                          = "Customer"
	TypeCustomerSubjects                  = "CustomerSubjects"
	TypeEntitlement                       = "Entitlement"
	TypeFeature                           = "Feature"
	TypeGrant                             = "Grant"
	TypeNotificationChannel               = "NotificationChannel"
	TypeNotificationEvent                 = "NotificationEvent"
	TypeNotificationEventDeliveryStatus   = "NotificationEventDeliveryStatus"
	TypeNotificationRule                  = "NotificationRule"
	TypePlan                              = "Plan"
	TypePlanPhase                         = "PlanPhase"
	TypePlanRateCard                      = "PlanRateCard"
	TypePrice                             = "Price"
	TypeSubscription                      = "Subscription"
	TypeSubscriptionEntitlement           = "SubscriptionEntitlement"
	TypeSubscriptionPatch                 = "SubscriptionPatch"
	TypeSubscriptionPatchValueAddItem     = "SubscriptionPatchValueAddItem"
	TypeSubscriptionPatchValueAddPhase    = "SubscriptionPatchValueAddPhase"
	TypeSubscriptionPatchValueExtendPhase = "SubscriptionPatchValueExtendPhase"
	TypeUsageReset                        = "UsageReset"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *string
	namespace                            *string
	metadata                             *map[string]string
	created_at                           *time.Time
	updated_at                           *time.Time
	deleted_at                           *time.Time
	name                                 *string
	description                          *string
	_type                                *appentitybase.AppType
	status                               *appentitybase.AppStatus
	is_default                           *bool
	clearedFields                        map[string]struct{}
	customer_apps                        map[int]struct{}
	removedcustomer_apps                 map[int]struct{}
	clearedcustomer_apps                 bool
	billing_profile_tax_app              map[string]struct{}
	removedbilling_profile_tax_app       map[string]struct{}
	clearedbilling_profile_tax_app       bool
	billing_profile_invoicing_app        map[string]struct{}
	removedbilling_profile_invoicing_app map[string]struct{}
	clearedbilling_profile_invoicing_app bool
	billing_profile_payment_app          map[string]struct{}
	removedbilling_profile_payment_app   map[string]struct{}
	clearedbilling_profile_payment_app   bool
	billing_invoice_tax_app              map[string]struct{}
	removedbilling_invoice_tax_app       map[string]struct{}
	clearedbilling_invoice_tax_app       bool
	billing_invoice_invoicing_app        map[string]struct{}
	removedbilling_invoice_invoicing_app map[string]struct{}
	clearedbilling_invoice_invoicing_app bool
	billing_invoice_payment_app          map[string]struct{}
	removedbilling_invoice_payment_app   map[string]struct{}
	clearedbilling_invoice_payment_app   bool
	done                                 bool
	oldValue                             func(context.Context) (*App, error)
	predicates                           []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id string) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *AppMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AppMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AppMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[app.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AppMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[app.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AppMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, app.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[app.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[app.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, app.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[app.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[app.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, app.FieldDescription)
}

// SetType sets the "type" field.
func (m *AppMutation) SetType(at appentitybase.AppType) {
	m._type = &at
}

// GetType returns the value of the "type" field in the mutation.
func (m *AppMutation) GetType() (r appentitybase.AppType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldType(ctx context.Context) (v appentitybase.AppType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AppMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *AppMutation) SetStatus(as appentitybase.AppStatus) {
	m.status = &as
}

// Status returns the value of the "status" field in the mutation.
func (m *AppMutation) Status() (r appentitybase.AppStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStatus(ctx context.Context) (v appentitybase.AppStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AppMutation) ResetStatus() {
	m.status = nil
}

// SetIsDefault sets the "is_default" field.
func (m *AppMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *AppMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *AppMutation) ResetIsDefault() {
	m.is_default = nil
}

// AddCustomerAppIDs adds the "customer_apps" edge to the AppCustomer entity by ids.
func (m *AppMutation) AddCustomerAppIDs(ids ...int) {
	if m.customer_apps == nil {
		m.customer_apps = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_apps[ids[i]] = struct{}{}
	}
}

// ClearCustomerApps clears the "customer_apps" edge to the AppCustomer entity.
func (m *AppMutation) ClearCustomerApps() {
	m.clearedcustomer_apps = true
}

// CustomerAppsCleared reports if the "customer_apps" edge to the AppCustomer entity was cleared.
func (m *AppMutation) CustomerAppsCleared() bool {
	return m.clearedcustomer_apps
}

// RemoveCustomerAppIDs removes the "customer_apps" edge to the AppCustomer entity by IDs.
func (m *AppMutation) RemoveCustomerAppIDs(ids ...int) {
	if m.removedcustomer_apps == nil {
		m.removedcustomer_apps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_apps, ids[i])
		m.removedcustomer_apps[ids[i]] = struct{}{}
	}
}

// RemovedCustomerApps returns the removed IDs of the "customer_apps" edge to the AppCustomer entity.
func (m *AppMutation) RemovedCustomerAppsIDs() (ids []int) {
	for id := range m.removedcustomer_apps {
		ids = append(ids, id)
	}
	return
}

// CustomerAppsIDs returns the "customer_apps" edge IDs in the mutation.
func (m *AppMutation) CustomerAppsIDs() (ids []int) {
	for id := range m.customer_apps {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerApps resets all changes to the "customer_apps" edge.
func (m *AppMutation) ResetCustomerApps() {
	m.customer_apps = nil
	m.clearedcustomer_apps = false
	m.removedcustomer_apps = nil
}

// AddBillingProfileTaxAppIDs adds the "billing_profile_tax_app" edge to the BillingProfile entity by ids.
func (m *AppMutation) AddBillingProfileTaxAppIDs(ids ...string) {
	if m.billing_profile_tax_app == nil {
		m.billing_profile_tax_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_profile_tax_app[ids[i]] = struct{}{}
	}
}

// ClearBillingProfileTaxApp clears the "billing_profile_tax_app" edge to the BillingProfile entity.
func (m *AppMutation) ClearBillingProfileTaxApp() {
	m.clearedbilling_profile_tax_app = true
}

// BillingProfileTaxAppCleared reports if the "billing_profile_tax_app" edge to the BillingProfile entity was cleared.
func (m *AppMutation) BillingProfileTaxAppCleared() bool {
	return m.clearedbilling_profile_tax_app
}

// RemoveBillingProfileTaxAppIDs removes the "billing_profile_tax_app" edge to the BillingProfile entity by IDs.
func (m *AppMutation) RemoveBillingProfileTaxAppIDs(ids ...string) {
	if m.removedbilling_profile_tax_app == nil {
		m.removedbilling_profile_tax_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_profile_tax_app, ids[i])
		m.removedbilling_profile_tax_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingProfileTaxApp returns the removed IDs of the "billing_profile_tax_app" edge to the BillingProfile entity.
func (m *AppMutation) RemovedBillingProfileTaxAppIDs() (ids []string) {
	for id := range m.removedbilling_profile_tax_app {
		ids = append(ids, id)
	}
	return
}

// BillingProfileTaxAppIDs returns the "billing_profile_tax_app" edge IDs in the mutation.
func (m *AppMutation) BillingProfileTaxAppIDs() (ids []string) {
	for id := range m.billing_profile_tax_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingProfileTaxApp resets all changes to the "billing_profile_tax_app" edge.
func (m *AppMutation) ResetBillingProfileTaxApp() {
	m.billing_profile_tax_app = nil
	m.clearedbilling_profile_tax_app = false
	m.removedbilling_profile_tax_app = nil
}

// AddBillingProfileInvoicingAppIDs adds the "billing_profile_invoicing_app" edge to the BillingProfile entity by ids.
func (m *AppMutation) AddBillingProfileInvoicingAppIDs(ids ...string) {
	if m.billing_profile_invoicing_app == nil {
		m.billing_profile_invoicing_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_profile_invoicing_app[ids[i]] = struct{}{}
	}
}

// ClearBillingProfileInvoicingApp clears the "billing_profile_invoicing_app" edge to the BillingProfile entity.
func (m *AppMutation) ClearBillingProfileInvoicingApp() {
	m.clearedbilling_profile_invoicing_app = true
}

// BillingProfileInvoicingAppCleared reports if the "billing_profile_invoicing_app" edge to the BillingProfile entity was cleared.
func (m *AppMutation) BillingProfileInvoicingAppCleared() bool {
	return m.clearedbilling_profile_invoicing_app
}

// RemoveBillingProfileInvoicingAppIDs removes the "billing_profile_invoicing_app" edge to the BillingProfile entity by IDs.
func (m *AppMutation) RemoveBillingProfileInvoicingAppIDs(ids ...string) {
	if m.removedbilling_profile_invoicing_app == nil {
		m.removedbilling_profile_invoicing_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_profile_invoicing_app, ids[i])
		m.removedbilling_profile_invoicing_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingProfileInvoicingApp returns the removed IDs of the "billing_profile_invoicing_app" edge to the BillingProfile entity.
func (m *AppMutation) RemovedBillingProfileInvoicingAppIDs() (ids []string) {
	for id := range m.removedbilling_profile_invoicing_app {
		ids = append(ids, id)
	}
	return
}

// BillingProfileInvoicingAppIDs returns the "billing_profile_invoicing_app" edge IDs in the mutation.
func (m *AppMutation) BillingProfileInvoicingAppIDs() (ids []string) {
	for id := range m.billing_profile_invoicing_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingProfileInvoicingApp resets all changes to the "billing_profile_invoicing_app" edge.
func (m *AppMutation) ResetBillingProfileInvoicingApp() {
	m.billing_profile_invoicing_app = nil
	m.clearedbilling_profile_invoicing_app = false
	m.removedbilling_profile_invoicing_app = nil
}

// AddBillingProfilePaymentAppIDs adds the "billing_profile_payment_app" edge to the BillingProfile entity by ids.
func (m *AppMutation) AddBillingProfilePaymentAppIDs(ids ...string) {
	if m.billing_profile_payment_app == nil {
		m.billing_profile_payment_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_profile_payment_app[ids[i]] = struct{}{}
	}
}

// ClearBillingProfilePaymentApp clears the "billing_profile_payment_app" edge to the BillingProfile entity.
func (m *AppMutation) ClearBillingProfilePaymentApp() {
	m.clearedbilling_profile_payment_app = true
}

// BillingProfilePaymentAppCleared reports if the "billing_profile_payment_app" edge to the BillingProfile entity was cleared.
func (m *AppMutation) BillingProfilePaymentAppCleared() bool {
	return m.clearedbilling_profile_payment_app
}

// RemoveBillingProfilePaymentAppIDs removes the "billing_profile_payment_app" edge to the BillingProfile entity by IDs.
func (m *AppMutation) RemoveBillingProfilePaymentAppIDs(ids ...string) {
	if m.removedbilling_profile_payment_app == nil {
		m.removedbilling_profile_payment_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_profile_payment_app, ids[i])
		m.removedbilling_profile_payment_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingProfilePaymentApp returns the removed IDs of the "billing_profile_payment_app" edge to the BillingProfile entity.
func (m *AppMutation) RemovedBillingProfilePaymentAppIDs() (ids []string) {
	for id := range m.removedbilling_profile_payment_app {
		ids = append(ids, id)
	}
	return
}

// BillingProfilePaymentAppIDs returns the "billing_profile_payment_app" edge IDs in the mutation.
func (m *AppMutation) BillingProfilePaymentAppIDs() (ids []string) {
	for id := range m.billing_profile_payment_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingProfilePaymentApp resets all changes to the "billing_profile_payment_app" edge.
func (m *AppMutation) ResetBillingProfilePaymentApp() {
	m.billing_profile_payment_app = nil
	m.clearedbilling_profile_payment_app = false
	m.removedbilling_profile_payment_app = nil
}

// AddBillingInvoiceTaxAppIDs adds the "billing_invoice_tax_app" edge to the BillingInvoice entity by ids.
func (m *AppMutation) AddBillingInvoiceTaxAppIDs(ids ...string) {
	if m.billing_invoice_tax_app == nil {
		m.billing_invoice_tax_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_tax_app[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoiceTaxApp clears the "billing_invoice_tax_app" edge to the BillingInvoice entity.
func (m *AppMutation) ClearBillingInvoiceTaxApp() {
	m.clearedbilling_invoice_tax_app = true
}

// BillingInvoiceTaxAppCleared reports if the "billing_invoice_tax_app" edge to the BillingInvoice entity was cleared.
func (m *AppMutation) BillingInvoiceTaxAppCleared() bool {
	return m.clearedbilling_invoice_tax_app
}

// RemoveBillingInvoiceTaxAppIDs removes the "billing_invoice_tax_app" edge to the BillingInvoice entity by IDs.
func (m *AppMutation) RemoveBillingInvoiceTaxAppIDs(ids ...string) {
	if m.removedbilling_invoice_tax_app == nil {
		m.removedbilling_invoice_tax_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_tax_app, ids[i])
		m.removedbilling_invoice_tax_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoiceTaxApp returns the removed IDs of the "billing_invoice_tax_app" edge to the BillingInvoice entity.
func (m *AppMutation) RemovedBillingInvoiceTaxAppIDs() (ids []string) {
	for id := range m.removedbilling_invoice_tax_app {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceTaxAppIDs returns the "billing_invoice_tax_app" edge IDs in the mutation.
func (m *AppMutation) BillingInvoiceTaxAppIDs() (ids []string) {
	for id := range m.billing_invoice_tax_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoiceTaxApp resets all changes to the "billing_invoice_tax_app" edge.
func (m *AppMutation) ResetBillingInvoiceTaxApp() {
	m.billing_invoice_tax_app = nil
	m.clearedbilling_invoice_tax_app = false
	m.removedbilling_invoice_tax_app = nil
}

// AddBillingInvoiceInvoicingAppIDs adds the "billing_invoice_invoicing_app" edge to the BillingInvoice entity by ids.
func (m *AppMutation) AddBillingInvoiceInvoicingAppIDs(ids ...string) {
	if m.billing_invoice_invoicing_app == nil {
		m.billing_invoice_invoicing_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_invoicing_app[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoiceInvoicingApp clears the "billing_invoice_invoicing_app" edge to the BillingInvoice entity.
func (m *AppMutation) ClearBillingInvoiceInvoicingApp() {
	m.clearedbilling_invoice_invoicing_app = true
}

// BillingInvoiceInvoicingAppCleared reports if the "billing_invoice_invoicing_app" edge to the BillingInvoice entity was cleared.
func (m *AppMutation) BillingInvoiceInvoicingAppCleared() bool {
	return m.clearedbilling_invoice_invoicing_app
}

// RemoveBillingInvoiceInvoicingAppIDs removes the "billing_invoice_invoicing_app" edge to the BillingInvoice entity by IDs.
func (m *AppMutation) RemoveBillingInvoiceInvoicingAppIDs(ids ...string) {
	if m.removedbilling_invoice_invoicing_app == nil {
		m.removedbilling_invoice_invoicing_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_invoicing_app, ids[i])
		m.removedbilling_invoice_invoicing_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoiceInvoicingApp returns the removed IDs of the "billing_invoice_invoicing_app" edge to the BillingInvoice entity.
func (m *AppMutation) RemovedBillingInvoiceInvoicingAppIDs() (ids []string) {
	for id := range m.removedbilling_invoice_invoicing_app {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceInvoicingAppIDs returns the "billing_invoice_invoicing_app" edge IDs in the mutation.
func (m *AppMutation) BillingInvoiceInvoicingAppIDs() (ids []string) {
	for id := range m.billing_invoice_invoicing_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoiceInvoicingApp resets all changes to the "billing_invoice_invoicing_app" edge.
func (m *AppMutation) ResetBillingInvoiceInvoicingApp() {
	m.billing_invoice_invoicing_app = nil
	m.clearedbilling_invoice_invoicing_app = false
	m.removedbilling_invoice_invoicing_app = nil
}

// AddBillingInvoicePaymentAppIDs adds the "billing_invoice_payment_app" edge to the BillingInvoice entity by ids.
func (m *AppMutation) AddBillingInvoicePaymentAppIDs(ids ...string) {
	if m.billing_invoice_payment_app == nil {
		m.billing_invoice_payment_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_payment_app[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoicePaymentApp clears the "billing_invoice_payment_app" edge to the BillingInvoice entity.
func (m *AppMutation) ClearBillingInvoicePaymentApp() {
	m.clearedbilling_invoice_payment_app = true
}

// BillingInvoicePaymentAppCleared reports if the "billing_invoice_payment_app" edge to the BillingInvoice entity was cleared.
func (m *AppMutation) BillingInvoicePaymentAppCleared() bool {
	return m.clearedbilling_invoice_payment_app
}

// RemoveBillingInvoicePaymentAppIDs removes the "billing_invoice_payment_app" edge to the BillingInvoice entity by IDs.
func (m *AppMutation) RemoveBillingInvoicePaymentAppIDs(ids ...string) {
	if m.removedbilling_invoice_payment_app == nil {
		m.removedbilling_invoice_payment_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_payment_app, ids[i])
		m.removedbilling_invoice_payment_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoicePaymentApp returns the removed IDs of the "billing_invoice_payment_app" edge to the BillingInvoice entity.
func (m *AppMutation) RemovedBillingInvoicePaymentAppIDs() (ids []string) {
	for id := range m.removedbilling_invoice_payment_app {
		ids = append(ids, id)
	}
	return
}

// BillingInvoicePaymentAppIDs returns the "billing_invoice_payment_app" edge IDs in the mutation.
func (m *AppMutation) BillingInvoicePaymentAppIDs() (ids []string) {
	for id := range m.billing_invoice_payment_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoicePaymentApp resets all changes to the "billing_invoice_payment_app" edge.
func (m *AppMutation) ResetBillingInvoicePaymentApp() {
	m.billing_invoice_payment_app = nil
	m.clearedbilling_invoice_payment_app = false
	m.removedbilling_invoice_payment_app = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, app.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, app.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, app.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.description != nil {
		fields = append(fields, app.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, app.FieldType)
	}
	if m.status != nil {
		fields = append(fields, app.FieldStatus)
	}
	if m.is_default != nil {
		fields = append(fields, app.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldNamespace:
		return m.Namespace()
	case app.FieldMetadata:
		return m.Metadata()
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldDeletedAt:
		return m.DeletedAt()
	case app.FieldName:
		return m.Name()
	case app.FieldDescription:
		return m.Description()
	case app.FieldType:
		return m.GetType()
	case app.FieldStatus:
		return m.Status()
	case app.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldNamespace:
		return m.OldNamespace(ctx)
	case app.FieldMetadata:
		return m.OldMetadata(ctx)
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldDescription:
		return m.OldDescription(ctx)
	case app.FieldType:
		return m.OldType(ctx)
	case app.FieldStatus:
		return m.OldStatus(ctx)
	case app.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case app.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case app.FieldType:
		v, ok := value.(appentitybase.AppType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case app.FieldStatus:
		v, ok := value.(appentitybase.AppStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case app.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldMetadata) {
		fields = append(fields, app.FieldMetadata)
	}
	if m.FieldCleared(app.FieldDeletedAt) {
		fields = append(fields, app.FieldDeletedAt)
	}
	if m.FieldCleared(app.FieldDescription) {
		fields = append(fields, app.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldMetadata:
		m.ClearMetadata()
		return nil
	case app.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case app.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldNamespace:
		m.ResetNamespace()
		return nil
	case app.FieldMetadata:
		m.ResetMetadata()
		return nil
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldDescription:
		m.ResetDescription()
		return nil
	case app.FieldType:
		m.ResetType()
		return nil
	case app.FieldStatus:
		m.ResetStatus()
		return nil
	case app.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.customer_apps != nil {
		edges = append(edges, app.EdgeCustomerApps)
	}
	if m.billing_profile_tax_app != nil {
		edges = append(edges, app.EdgeBillingProfileTaxApp)
	}
	if m.billing_profile_invoicing_app != nil {
		edges = append(edges, app.EdgeBillingProfileInvoicingApp)
	}
	if m.billing_profile_payment_app != nil {
		edges = append(edges, app.EdgeBillingProfilePaymentApp)
	}
	if m.billing_invoice_tax_app != nil {
		edges = append(edges, app.EdgeBillingInvoiceTaxApp)
	}
	if m.billing_invoice_invoicing_app != nil {
		edges = append(edges, app.EdgeBillingInvoiceInvoicingApp)
	}
	if m.billing_invoice_payment_app != nil {
		edges = append(edges, app.EdgeBillingInvoicePaymentApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeCustomerApps:
		ids := make([]ent.Value, 0, len(m.customer_apps))
		for id := range m.customer_apps {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingProfileTaxApp:
		ids := make([]ent.Value, 0, len(m.billing_profile_tax_app))
		for id := range m.billing_profile_tax_app {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingProfileInvoicingApp:
		ids := make([]ent.Value, 0, len(m.billing_profile_invoicing_app))
		for id := range m.billing_profile_invoicing_app {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingProfilePaymentApp:
		ids := make([]ent.Value, 0, len(m.billing_profile_payment_app))
		for id := range m.billing_profile_payment_app {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingInvoiceTaxApp:
		ids := make([]ent.Value, 0, len(m.billing_invoice_tax_app))
		for id := range m.billing_invoice_tax_app {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingInvoiceInvoicingApp:
		ids := make([]ent.Value, 0, len(m.billing_invoice_invoicing_app))
		for id := range m.billing_invoice_invoicing_app {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingInvoicePaymentApp:
		ids := make([]ent.Value, 0, len(m.billing_invoice_payment_app))
		for id := range m.billing_invoice_payment_app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedcustomer_apps != nil {
		edges = append(edges, app.EdgeCustomerApps)
	}
	if m.removedbilling_profile_tax_app != nil {
		edges = append(edges, app.EdgeBillingProfileTaxApp)
	}
	if m.removedbilling_profile_invoicing_app != nil {
		edges = append(edges, app.EdgeBillingProfileInvoicingApp)
	}
	if m.removedbilling_profile_payment_app != nil {
		edges = append(edges, app.EdgeBillingProfilePaymentApp)
	}
	if m.removedbilling_invoice_tax_app != nil {
		edges = append(edges, app.EdgeBillingInvoiceTaxApp)
	}
	if m.removedbilling_invoice_invoicing_app != nil {
		edges = append(edges, app.EdgeBillingInvoiceInvoicingApp)
	}
	if m.removedbilling_invoice_payment_app != nil {
		edges = append(edges, app.EdgeBillingInvoicePaymentApp)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeCustomerApps:
		ids := make([]ent.Value, 0, len(m.removedcustomer_apps))
		for id := range m.removedcustomer_apps {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingProfileTaxApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_profile_tax_app))
		for id := range m.removedbilling_profile_tax_app {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingProfileInvoicingApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_profile_invoicing_app))
		for id := range m.removedbilling_profile_invoicing_app {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingProfilePaymentApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_profile_payment_app))
		for id := range m.removedbilling_profile_payment_app {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingInvoiceTaxApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_tax_app))
		for id := range m.removedbilling_invoice_tax_app {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingInvoiceInvoicingApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_invoicing_app))
		for id := range m.removedbilling_invoice_invoicing_app {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeBillingInvoicePaymentApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_payment_app))
		for id := range m.removedbilling_invoice_payment_app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcustomer_apps {
		edges = append(edges, app.EdgeCustomerApps)
	}
	if m.clearedbilling_profile_tax_app {
		edges = append(edges, app.EdgeBillingProfileTaxApp)
	}
	if m.clearedbilling_profile_invoicing_app {
		edges = append(edges, app.EdgeBillingProfileInvoicingApp)
	}
	if m.clearedbilling_profile_payment_app {
		edges = append(edges, app.EdgeBillingProfilePaymentApp)
	}
	if m.clearedbilling_invoice_tax_app {
		edges = append(edges, app.EdgeBillingInvoiceTaxApp)
	}
	if m.clearedbilling_invoice_invoicing_app {
		edges = append(edges, app.EdgeBillingInvoiceInvoicingApp)
	}
	if m.clearedbilling_invoice_payment_app {
		edges = append(edges, app.EdgeBillingInvoicePaymentApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeCustomerApps:
		return m.clearedcustomer_apps
	case app.EdgeBillingProfileTaxApp:
		return m.clearedbilling_profile_tax_app
	case app.EdgeBillingProfileInvoicingApp:
		return m.clearedbilling_profile_invoicing_app
	case app.EdgeBillingProfilePaymentApp:
		return m.clearedbilling_profile_payment_app
	case app.EdgeBillingInvoiceTaxApp:
		return m.clearedbilling_invoice_tax_app
	case app.EdgeBillingInvoiceInvoicingApp:
		return m.clearedbilling_invoice_invoicing_app
	case app.EdgeBillingInvoicePaymentApp:
		return m.clearedbilling_invoice_payment_app
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeCustomerApps:
		m.ResetCustomerApps()
		return nil
	case app.EdgeBillingProfileTaxApp:
		m.ResetBillingProfileTaxApp()
		return nil
	case app.EdgeBillingProfileInvoicingApp:
		m.ResetBillingProfileInvoicingApp()
		return nil
	case app.EdgeBillingProfilePaymentApp:
		m.ResetBillingProfilePaymentApp()
		return nil
	case app.EdgeBillingInvoiceTaxApp:
		m.ResetBillingInvoiceTaxApp()
		return nil
	case app.EdgeBillingInvoiceInvoicingApp:
		m.ResetBillingInvoiceInvoicingApp()
		return nil
	case app.EdgeBillingInvoicePaymentApp:
		m.ResetBillingInvoicePaymentApp()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppCustomerMutation represents an operation that mutates the AppCustomer nodes in the graph.
type AppCustomerMutation struct {
	config
	op              Op
	typ             string
	id              *int
	namespace       *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	clearedFields   map[string]struct{}
	app             *string
	clearedapp      bool
	customer        *string
	clearedcustomer bool
	done            bool
	oldValue        func(context.Context) (*AppCustomer, error)
	predicates      []predicate.AppCustomer
}

var _ ent.Mutation = (*AppCustomerMutation)(nil)

// appcustomerOption allows management of the mutation configuration using functional options.
type appcustomerOption func(*AppCustomerMutation)

// newAppCustomerMutation creates new mutation for the AppCustomer entity.
func newAppCustomerMutation(c config, op Op, opts ...appcustomerOption) *AppCustomerMutation {
	m := &AppCustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeAppCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppCustomerID sets the ID field of the mutation.
func withAppCustomerID(id int) appcustomerOption {
	return func(m *AppCustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *AppCustomer
		)
		m.oldValue = func(ctx context.Context) (*AppCustomer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppCustomer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppCustomer sets the old AppCustomer of the mutation.
func withAppCustomer(node *AppCustomer) appcustomerOption {
	return func(m *AppCustomerMutation) {
		m.oldValue = func(context.Context) (*AppCustomer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppCustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppCustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppCustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppCustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppCustomer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppCustomerMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppCustomerMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppCustomerMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppCustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppCustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppCustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppCustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppCustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppCustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppCustomerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppCustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppCustomerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appcustomer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppCustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appcustomer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppCustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appcustomer.FieldDeletedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppCustomerMutation) SetAppID(s string) {
	m.app = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppCustomerMutation) AppID() (r string, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppCustomerMutation) ResetAppID() {
	m.app = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *AppCustomerMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *AppCustomerMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *AppCustomerMutation) ResetCustomerID() {
	m.customer = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppCustomerMutation) ClearApp() {
	m.clearedapp = true
	m.clearedFields[appcustomer.FieldAppID] = struct{}{}
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppCustomerMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppCustomerMutation) AppIDs() (ids []string) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppCustomerMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *AppCustomerMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[appcustomer.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *AppCustomerMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *AppCustomerMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *AppCustomerMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the AppCustomerMutation builder.
func (m *AppCustomerMutation) Where(ps ...predicate.AppCustomer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppCustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppCustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppCustomer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppCustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppCustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppCustomer).
func (m *AppCustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppCustomerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.namespace != nil {
		fields = append(fields, appcustomer.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, appcustomer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appcustomer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appcustomer.FieldDeletedAt)
	}
	if m.app != nil {
		fields = append(fields, appcustomer.FieldAppID)
	}
	if m.customer != nil {
		fields = append(fields, appcustomer.FieldCustomerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppCustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appcustomer.FieldNamespace:
		return m.Namespace()
	case appcustomer.FieldCreatedAt:
		return m.CreatedAt()
	case appcustomer.FieldUpdatedAt:
		return m.UpdatedAt()
	case appcustomer.FieldDeletedAt:
		return m.DeletedAt()
	case appcustomer.FieldAppID:
		return m.AppID()
	case appcustomer.FieldCustomerID:
		return m.CustomerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppCustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appcustomer.FieldNamespace:
		return m.OldNamespace(ctx)
	case appcustomer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appcustomer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appcustomer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appcustomer.FieldAppID:
		return m.OldAppID(ctx)
	case appcustomer.FieldCustomerID:
		return m.OldCustomerID(ctx)
	}
	return nil, fmt.Errorf("unknown AppCustomer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appcustomer.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case appcustomer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appcustomer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appcustomer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appcustomer.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appcustomer.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	}
	return fmt.Errorf("unknown AppCustomer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppCustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppCustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppCustomer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppCustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appcustomer.FieldDeletedAt) {
		fields = append(fields, appcustomer.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppCustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppCustomerMutation) ClearField(name string) error {
	switch name {
	case appcustomer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AppCustomer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppCustomerMutation) ResetField(name string) error {
	switch name {
	case appcustomer.FieldNamespace:
		m.ResetNamespace()
		return nil
	case appcustomer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appcustomer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appcustomer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appcustomer.FieldAppID:
		m.ResetAppID()
		return nil
	case appcustomer.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	}
	return fmt.Errorf("unknown AppCustomer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppCustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, appcustomer.EdgeApp)
	}
	if m.customer != nil {
		edges = append(edges, appcustomer.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppCustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appcustomer.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appcustomer.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppCustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppCustomerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppCustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, appcustomer.EdgeApp)
	}
	if m.clearedcustomer {
		edges = append(edges, appcustomer.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppCustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case appcustomer.EdgeApp:
		return m.clearedapp
	case appcustomer.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppCustomerMutation) ClearEdge(name string) error {
	switch name {
	case appcustomer.EdgeApp:
		m.ClearApp()
		return nil
	case appcustomer.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown AppCustomer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppCustomerMutation) ResetEdge(name string) error {
	switch name {
	case appcustomer.EdgeApp:
		m.ResetApp()
		return nil
	case appcustomer.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown AppCustomer edge %s", name)
}

// AppStripeMutation represents an operation that mutates the AppStripe nodes in the graph.
type AppStripeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	namespace            *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	stripe_account_id    *string
	stripe_livemode      *bool
	api_key              *string
	stripe_webhook_id    *string
	webhook_secret       *string
	clearedFields        map[string]struct{}
	customer_apps        map[int]struct{}
	removedcustomer_apps map[int]struct{}
	clearedcustomer_apps bool
	app                  *string
	clearedapp           bool
	done                 bool
	oldValue             func(context.Context) (*AppStripe, error)
	predicates           []predicate.AppStripe
}

var _ ent.Mutation = (*AppStripeMutation)(nil)

// appstripeOption allows management of the mutation configuration using functional options.
type appstripeOption func(*AppStripeMutation)

// newAppStripeMutation creates new mutation for the AppStripe entity.
func newAppStripeMutation(c config, op Op, opts ...appstripeOption) *AppStripeMutation {
	m := &AppStripeMutation{
		config:        c,
		op:            op,
		typ:           TypeAppStripe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppStripeID sets the ID field of the mutation.
func withAppStripeID(id string) appstripeOption {
	return func(m *AppStripeMutation) {
		var (
			err   error
			once  sync.Once
			value *AppStripe
		)
		m.oldValue = func(ctx context.Context) (*AppStripe, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppStripe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppStripe sets the old AppStripe of the mutation.
func withAppStripe(node *AppStripe) appstripeOption {
	return func(m *AppStripeMutation) {
		m.oldValue = func(context.Context) (*AppStripe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppStripeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppStripeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppStripe entities.
func (m *AppStripeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppStripeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppStripeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppStripe.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppStripeMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppStripeMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppStripeMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppStripeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppStripeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppStripeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppStripeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppStripeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppStripeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppStripeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppStripeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppStripeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appstripe.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppStripeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appstripe.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppStripeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appstripe.FieldDeletedAt)
}

// SetStripeAccountID sets the "stripe_account_id" field.
func (m *AppStripeMutation) SetStripeAccountID(s string) {
	m.stripe_account_id = &s
}

// StripeAccountID returns the value of the "stripe_account_id" field in the mutation.
func (m *AppStripeMutation) StripeAccountID() (r string, exists bool) {
	v := m.stripe_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeAccountID returns the old "stripe_account_id" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldStripeAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeAccountID: %w", err)
	}
	return oldValue.StripeAccountID, nil
}

// ResetStripeAccountID resets all changes to the "stripe_account_id" field.
func (m *AppStripeMutation) ResetStripeAccountID() {
	m.stripe_account_id = nil
}

// SetStripeLivemode sets the "stripe_livemode" field.
func (m *AppStripeMutation) SetStripeLivemode(b bool) {
	m.stripe_livemode = &b
}

// StripeLivemode returns the value of the "stripe_livemode" field in the mutation.
func (m *AppStripeMutation) StripeLivemode() (r bool, exists bool) {
	v := m.stripe_livemode
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeLivemode returns the old "stripe_livemode" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldStripeLivemode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeLivemode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeLivemode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeLivemode: %w", err)
	}
	return oldValue.StripeLivemode, nil
}

// ResetStripeLivemode resets all changes to the "stripe_livemode" field.
func (m *AppStripeMutation) ResetStripeLivemode() {
	m.stripe_livemode = nil
}

// SetAPIKey sets the "api_key" field.
func (m *AppStripeMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *AppStripeMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *AppStripeMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetStripeWebhookID sets the "stripe_webhook_id" field.
func (m *AppStripeMutation) SetStripeWebhookID(s string) {
	m.stripe_webhook_id = &s
}

// StripeWebhookID returns the value of the "stripe_webhook_id" field in the mutation.
func (m *AppStripeMutation) StripeWebhookID() (r string, exists bool) {
	v := m.stripe_webhook_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeWebhookID returns the old "stripe_webhook_id" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldStripeWebhookID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeWebhookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeWebhookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeWebhookID: %w", err)
	}
	return oldValue.StripeWebhookID, nil
}

// ResetStripeWebhookID resets all changes to the "stripe_webhook_id" field.
func (m *AppStripeMutation) ResetStripeWebhookID() {
	m.stripe_webhook_id = nil
}

// SetWebhookSecret sets the "webhook_secret" field.
func (m *AppStripeMutation) SetWebhookSecret(s string) {
	m.webhook_secret = &s
}

// WebhookSecret returns the value of the "webhook_secret" field in the mutation.
func (m *AppStripeMutation) WebhookSecret() (r string, exists bool) {
	v := m.webhook_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldWebhookSecret returns the old "webhook_secret" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldWebhookSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebhookSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebhookSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebhookSecret: %w", err)
	}
	return oldValue.WebhookSecret, nil
}

// ResetWebhookSecret resets all changes to the "webhook_secret" field.
func (m *AppStripeMutation) ResetWebhookSecret() {
	m.webhook_secret = nil
}

// AddCustomerAppIDs adds the "customer_apps" edge to the AppStripeCustomer entity by ids.
func (m *AppStripeMutation) AddCustomerAppIDs(ids ...int) {
	if m.customer_apps == nil {
		m.customer_apps = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_apps[ids[i]] = struct{}{}
	}
}

// ClearCustomerApps clears the "customer_apps" edge to the AppStripeCustomer entity.
func (m *AppStripeMutation) ClearCustomerApps() {
	m.clearedcustomer_apps = true
}

// CustomerAppsCleared reports if the "customer_apps" edge to the AppStripeCustomer entity was cleared.
func (m *AppStripeMutation) CustomerAppsCleared() bool {
	return m.clearedcustomer_apps
}

// RemoveCustomerAppIDs removes the "customer_apps" edge to the AppStripeCustomer entity by IDs.
func (m *AppStripeMutation) RemoveCustomerAppIDs(ids ...int) {
	if m.removedcustomer_apps == nil {
		m.removedcustomer_apps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_apps, ids[i])
		m.removedcustomer_apps[ids[i]] = struct{}{}
	}
}

// RemovedCustomerApps returns the removed IDs of the "customer_apps" edge to the AppStripeCustomer entity.
func (m *AppStripeMutation) RemovedCustomerAppsIDs() (ids []int) {
	for id := range m.removedcustomer_apps {
		ids = append(ids, id)
	}
	return
}

// CustomerAppsIDs returns the "customer_apps" edge IDs in the mutation.
func (m *AppStripeMutation) CustomerAppsIDs() (ids []int) {
	for id := range m.customer_apps {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerApps resets all changes to the "customer_apps" edge.
func (m *AppStripeMutation) ResetCustomerApps() {
	m.customer_apps = nil
	m.clearedcustomer_apps = false
	m.removedcustomer_apps = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *AppStripeMutation) SetAppID(id string) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppStripeMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppStripeMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *AppStripeMutation) AppID() (id string, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppStripeMutation) AppIDs() (ids []string) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppStripeMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the AppStripeMutation builder.
func (m *AppStripeMutation) Where(ps ...predicate.AppStripe) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppStripeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppStripeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppStripe, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppStripeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppStripeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppStripe).
func (m *AppStripeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppStripeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.namespace != nil {
		fields = append(fields, appstripe.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, appstripe.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appstripe.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appstripe.FieldDeletedAt)
	}
	if m.stripe_account_id != nil {
		fields = append(fields, appstripe.FieldStripeAccountID)
	}
	if m.stripe_livemode != nil {
		fields = append(fields, appstripe.FieldStripeLivemode)
	}
	if m.api_key != nil {
		fields = append(fields, appstripe.FieldAPIKey)
	}
	if m.stripe_webhook_id != nil {
		fields = append(fields, appstripe.FieldStripeWebhookID)
	}
	if m.webhook_secret != nil {
		fields = append(fields, appstripe.FieldWebhookSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppStripeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appstripe.FieldNamespace:
		return m.Namespace()
	case appstripe.FieldCreatedAt:
		return m.CreatedAt()
	case appstripe.FieldUpdatedAt:
		return m.UpdatedAt()
	case appstripe.FieldDeletedAt:
		return m.DeletedAt()
	case appstripe.FieldStripeAccountID:
		return m.StripeAccountID()
	case appstripe.FieldStripeLivemode:
		return m.StripeLivemode()
	case appstripe.FieldAPIKey:
		return m.APIKey()
	case appstripe.FieldStripeWebhookID:
		return m.StripeWebhookID()
	case appstripe.FieldWebhookSecret:
		return m.WebhookSecret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppStripeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appstripe.FieldNamespace:
		return m.OldNamespace(ctx)
	case appstripe.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appstripe.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appstripe.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appstripe.FieldStripeAccountID:
		return m.OldStripeAccountID(ctx)
	case appstripe.FieldStripeLivemode:
		return m.OldStripeLivemode(ctx)
	case appstripe.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case appstripe.FieldStripeWebhookID:
		return m.OldStripeWebhookID(ctx)
	case appstripe.FieldWebhookSecret:
		return m.OldWebhookSecret(ctx)
	}
	return nil, fmt.Errorf("unknown AppStripe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStripeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appstripe.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case appstripe.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appstripe.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appstripe.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appstripe.FieldStripeAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeAccountID(v)
		return nil
	case appstripe.FieldStripeLivemode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeLivemode(v)
		return nil
	case appstripe.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case appstripe.FieldStripeWebhookID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeWebhookID(v)
		return nil
	case appstripe.FieldWebhookSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebhookSecret(v)
		return nil
	}
	return fmt.Errorf("unknown AppStripe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppStripeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppStripeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStripeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppStripe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppStripeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appstripe.FieldDeletedAt) {
		fields = append(fields, appstripe.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppStripeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppStripeMutation) ClearField(name string) error {
	switch name {
	case appstripe.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AppStripe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppStripeMutation) ResetField(name string) error {
	switch name {
	case appstripe.FieldNamespace:
		m.ResetNamespace()
		return nil
	case appstripe.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appstripe.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appstripe.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appstripe.FieldStripeAccountID:
		m.ResetStripeAccountID()
		return nil
	case appstripe.FieldStripeLivemode:
		m.ResetStripeLivemode()
		return nil
	case appstripe.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case appstripe.FieldStripeWebhookID:
		m.ResetStripeWebhookID()
		return nil
	case appstripe.FieldWebhookSecret:
		m.ResetWebhookSecret()
		return nil
	}
	return fmt.Errorf("unknown AppStripe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppStripeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.customer_apps != nil {
		edges = append(edges, appstripe.EdgeCustomerApps)
	}
	if m.app != nil {
		edges = append(edges, appstripe.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppStripeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appstripe.EdgeCustomerApps:
		ids := make([]ent.Value, 0, len(m.customer_apps))
		for id := range m.customer_apps {
			ids = append(ids, id)
		}
		return ids
	case appstripe.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppStripeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcustomer_apps != nil {
		edges = append(edges, appstripe.EdgeCustomerApps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppStripeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case appstripe.EdgeCustomerApps:
		ids := make([]ent.Value, 0, len(m.removedcustomer_apps))
		for id := range m.removedcustomer_apps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppStripeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcustomer_apps {
		edges = append(edges, appstripe.EdgeCustomerApps)
	}
	if m.clearedapp {
		edges = append(edges, appstripe.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppStripeMutation) EdgeCleared(name string) bool {
	switch name {
	case appstripe.EdgeCustomerApps:
		return m.clearedcustomer_apps
	case appstripe.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppStripeMutation) ClearEdge(name string) error {
	switch name {
	case appstripe.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppStripe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppStripeMutation) ResetEdge(name string) error {
	switch name {
	case appstripe.EdgeCustomerApps:
		m.ResetCustomerApps()
		return nil
	case appstripe.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AppStripe edge %s", name)
}

// AppStripeCustomerMutation represents an operation that mutates the AppStripeCustomer nodes in the graph.
type AppStripeCustomerMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	namespace                        *string
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	stripe_customer_id               *string
	stripe_default_payment_method_id *string
	clearedFields                    map[string]struct{}
	stripe_app                       *string
	clearedstripe_app                bool
	customer                         *string
	clearedcustomer                  bool
	done                             bool
	oldValue                         func(context.Context) (*AppStripeCustomer, error)
	predicates                       []predicate.AppStripeCustomer
}

var _ ent.Mutation = (*AppStripeCustomerMutation)(nil)

// appstripecustomerOption allows management of the mutation configuration using functional options.
type appstripecustomerOption func(*AppStripeCustomerMutation)

// newAppStripeCustomerMutation creates new mutation for the AppStripeCustomer entity.
func newAppStripeCustomerMutation(c config, op Op, opts ...appstripecustomerOption) *AppStripeCustomerMutation {
	m := &AppStripeCustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeAppStripeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppStripeCustomerID sets the ID field of the mutation.
func withAppStripeCustomerID(id int) appstripecustomerOption {
	return func(m *AppStripeCustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *AppStripeCustomer
		)
		m.oldValue = func(ctx context.Context) (*AppStripeCustomer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppStripeCustomer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppStripeCustomer sets the old AppStripeCustomer of the mutation.
func withAppStripeCustomer(node *AppStripeCustomer) appstripecustomerOption {
	return func(m *AppStripeCustomerMutation) {
		m.oldValue = func(context.Context) (*AppStripeCustomer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppStripeCustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppStripeCustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppStripeCustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppStripeCustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppStripeCustomer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppStripeCustomerMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppStripeCustomerMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppStripeCustomerMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppStripeCustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppStripeCustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppStripeCustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppStripeCustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppStripeCustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppStripeCustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppStripeCustomerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppStripeCustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppStripeCustomerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appstripecustomer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppStripeCustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appstripecustomer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppStripeCustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appstripecustomer.FieldDeletedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppStripeCustomerMutation) SetAppID(s string) {
	m.stripe_app = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppStripeCustomerMutation) AppID() (r string, exists bool) {
	v := m.stripe_app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppStripeCustomerMutation) ResetAppID() {
	m.stripe_app = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *AppStripeCustomerMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *AppStripeCustomerMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *AppStripeCustomerMutation) ResetCustomerID() {
	m.customer = nil
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *AppStripeCustomerMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *AppStripeCustomerMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldStripeCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *AppStripeCustomerMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
}

// SetStripeDefaultPaymentMethodID sets the "stripe_default_payment_method_id" field.
func (m *AppStripeCustomerMutation) SetStripeDefaultPaymentMethodID(s string) {
	m.stripe_default_payment_method_id = &s
}

// StripeDefaultPaymentMethodID returns the value of the "stripe_default_payment_method_id" field in the mutation.
func (m *AppStripeCustomerMutation) StripeDefaultPaymentMethodID() (r string, exists bool) {
	v := m.stripe_default_payment_method_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeDefaultPaymentMethodID returns the old "stripe_default_payment_method_id" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldStripeDefaultPaymentMethodID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeDefaultPaymentMethodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeDefaultPaymentMethodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeDefaultPaymentMethodID: %w", err)
	}
	return oldValue.StripeDefaultPaymentMethodID, nil
}

// ClearStripeDefaultPaymentMethodID clears the value of the "stripe_default_payment_method_id" field.
func (m *AppStripeCustomerMutation) ClearStripeDefaultPaymentMethodID() {
	m.stripe_default_payment_method_id = nil
	m.clearedFields[appstripecustomer.FieldStripeDefaultPaymentMethodID] = struct{}{}
}

// StripeDefaultPaymentMethodIDCleared returns if the "stripe_default_payment_method_id" field was cleared in this mutation.
func (m *AppStripeCustomerMutation) StripeDefaultPaymentMethodIDCleared() bool {
	_, ok := m.clearedFields[appstripecustomer.FieldStripeDefaultPaymentMethodID]
	return ok
}

// ResetStripeDefaultPaymentMethodID resets all changes to the "stripe_default_payment_method_id" field.
func (m *AppStripeCustomerMutation) ResetStripeDefaultPaymentMethodID() {
	m.stripe_default_payment_method_id = nil
	delete(m.clearedFields, appstripecustomer.FieldStripeDefaultPaymentMethodID)
}

// SetStripeAppID sets the "stripe_app" edge to the AppStripe entity by id.
func (m *AppStripeCustomerMutation) SetStripeAppID(id string) {
	m.stripe_app = &id
}

// ClearStripeApp clears the "stripe_app" edge to the AppStripe entity.
func (m *AppStripeCustomerMutation) ClearStripeApp() {
	m.clearedstripe_app = true
	m.clearedFields[appstripecustomer.FieldAppID] = struct{}{}
}

// StripeAppCleared reports if the "stripe_app" edge to the AppStripe entity was cleared.
func (m *AppStripeCustomerMutation) StripeAppCleared() bool {
	return m.clearedstripe_app
}

// StripeAppID returns the "stripe_app" edge ID in the mutation.
func (m *AppStripeCustomerMutation) StripeAppID() (id string, exists bool) {
	if m.stripe_app != nil {
		return *m.stripe_app, true
	}
	return
}

// StripeAppIDs returns the "stripe_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StripeAppID instead. It exists only for internal usage by the builders.
func (m *AppStripeCustomerMutation) StripeAppIDs() (ids []string) {
	if id := m.stripe_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStripeApp resets all changes to the "stripe_app" edge.
func (m *AppStripeCustomerMutation) ResetStripeApp() {
	m.stripe_app = nil
	m.clearedstripe_app = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *AppStripeCustomerMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[appstripecustomer.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *AppStripeCustomerMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *AppStripeCustomerMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *AppStripeCustomerMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the AppStripeCustomerMutation builder.
func (m *AppStripeCustomerMutation) Where(ps ...predicate.AppStripeCustomer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppStripeCustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppStripeCustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppStripeCustomer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppStripeCustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppStripeCustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppStripeCustomer).
func (m *AppStripeCustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppStripeCustomerMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, appstripecustomer.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, appstripecustomer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appstripecustomer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appstripecustomer.FieldDeletedAt)
	}
	if m.stripe_app != nil {
		fields = append(fields, appstripecustomer.FieldAppID)
	}
	if m.customer != nil {
		fields = append(fields, appstripecustomer.FieldCustomerID)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, appstripecustomer.FieldStripeCustomerID)
	}
	if m.stripe_default_payment_method_id != nil {
		fields = append(fields, appstripecustomer.FieldStripeDefaultPaymentMethodID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppStripeCustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appstripecustomer.FieldNamespace:
		return m.Namespace()
	case appstripecustomer.FieldCreatedAt:
		return m.CreatedAt()
	case appstripecustomer.FieldUpdatedAt:
		return m.UpdatedAt()
	case appstripecustomer.FieldDeletedAt:
		return m.DeletedAt()
	case appstripecustomer.FieldAppID:
		return m.AppID()
	case appstripecustomer.FieldCustomerID:
		return m.CustomerID()
	case appstripecustomer.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case appstripecustomer.FieldStripeDefaultPaymentMethodID:
		return m.StripeDefaultPaymentMethodID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppStripeCustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appstripecustomer.FieldNamespace:
		return m.OldNamespace(ctx)
	case appstripecustomer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appstripecustomer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appstripecustomer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appstripecustomer.FieldAppID:
		return m.OldAppID(ctx)
	case appstripecustomer.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case appstripecustomer.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case appstripecustomer.FieldStripeDefaultPaymentMethodID:
		return m.OldStripeDefaultPaymentMethodID(ctx)
	}
	return nil, fmt.Errorf("unknown AppStripeCustomer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStripeCustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appstripecustomer.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case appstripecustomer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appstripecustomer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appstripecustomer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appstripecustomer.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appstripecustomer.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case appstripecustomer.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case appstripecustomer.FieldStripeDefaultPaymentMethodID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeDefaultPaymentMethodID(v)
		return nil
	}
	return fmt.Errorf("unknown AppStripeCustomer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppStripeCustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppStripeCustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStripeCustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppStripeCustomer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppStripeCustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appstripecustomer.FieldDeletedAt) {
		fields = append(fields, appstripecustomer.FieldDeletedAt)
	}
	if m.FieldCleared(appstripecustomer.FieldStripeDefaultPaymentMethodID) {
		fields = append(fields, appstripecustomer.FieldStripeDefaultPaymentMethodID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppStripeCustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppStripeCustomerMutation) ClearField(name string) error {
	switch name {
	case appstripecustomer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case appstripecustomer.FieldStripeDefaultPaymentMethodID:
		m.ClearStripeDefaultPaymentMethodID()
		return nil
	}
	return fmt.Errorf("unknown AppStripeCustomer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppStripeCustomerMutation) ResetField(name string) error {
	switch name {
	case appstripecustomer.FieldNamespace:
		m.ResetNamespace()
		return nil
	case appstripecustomer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appstripecustomer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appstripecustomer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appstripecustomer.FieldAppID:
		m.ResetAppID()
		return nil
	case appstripecustomer.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case appstripecustomer.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case appstripecustomer.FieldStripeDefaultPaymentMethodID:
		m.ResetStripeDefaultPaymentMethodID()
		return nil
	}
	return fmt.Errorf("unknown AppStripeCustomer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppStripeCustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.stripe_app != nil {
		edges = append(edges, appstripecustomer.EdgeStripeApp)
	}
	if m.customer != nil {
		edges = append(edges, appstripecustomer.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppStripeCustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appstripecustomer.EdgeStripeApp:
		if id := m.stripe_app; id != nil {
			return []ent.Value{*id}
		}
	case appstripecustomer.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppStripeCustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppStripeCustomerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppStripeCustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstripe_app {
		edges = append(edges, appstripecustomer.EdgeStripeApp)
	}
	if m.clearedcustomer {
		edges = append(edges, appstripecustomer.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppStripeCustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case appstripecustomer.EdgeStripeApp:
		return m.clearedstripe_app
	case appstripecustomer.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppStripeCustomerMutation) ClearEdge(name string) error {
	switch name {
	case appstripecustomer.EdgeStripeApp:
		m.ClearStripeApp()
		return nil
	case appstripecustomer.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown AppStripeCustomer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppStripeCustomerMutation) ResetEdge(name string) error {
	switch name {
	case appstripecustomer.EdgeStripeApp:
		m.ResetStripeApp()
		return nil
	case appstripecustomer.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown AppStripeCustomer edge %s", name)
}

// BalanceSnapshotMutation represents an operation that mutates the BalanceSnapshot nodes in the graph.
type BalanceSnapshotMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	namespace          *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	grant_balances     *balance.Map
	balance            *float64
	addbalance         *float64
	overage            *float64
	addoverage         *float64
	at                 *time.Time
	clearedFields      map[string]struct{}
	entitlement        *string
	clearedentitlement bool
	done               bool
	oldValue           func(context.Context) (*BalanceSnapshot, error)
	predicates         []predicate.BalanceSnapshot
}

var _ ent.Mutation = (*BalanceSnapshotMutation)(nil)

// balancesnapshotOption allows management of the mutation configuration using functional options.
type balancesnapshotOption func(*BalanceSnapshotMutation)

// newBalanceSnapshotMutation creates new mutation for the BalanceSnapshot entity.
func newBalanceSnapshotMutation(c config, op Op, opts ...balancesnapshotOption) *BalanceSnapshotMutation {
	m := &BalanceSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeBalanceSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBalanceSnapshotID sets the ID field of the mutation.
func withBalanceSnapshotID(id int) balancesnapshotOption {
	return func(m *BalanceSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *BalanceSnapshot
		)
		m.oldValue = func(ctx context.Context) (*BalanceSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BalanceSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBalanceSnapshot sets the old BalanceSnapshot of the mutation.
func withBalanceSnapshot(node *BalanceSnapshot) balancesnapshotOption {
	return func(m *BalanceSnapshotMutation) {
		m.oldValue = func(context.Context) (*BalanceSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BalanceSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BalanceSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BalanceSnapshotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BalanceSnapshotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BalanceSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BalanceSnapshotMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BalanceSnapshotMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BalanceSnapshotMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BalanceSnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BalanceSnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BalanceSnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BalanceSnapshotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BalanceSnapshotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BalanceSnapshotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BalanceSnapshotMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BalanceSnapshotMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BalanceSnapshotMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[balancesnapshot.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BalanceSnapshotMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[balancesnapshot.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BalanceSnapshotMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, balancesnapshot.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *BalanceSnapshotMutation) SetOwnerID(s string) {
	m.entitlement = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *BalanceSnapshotMutation) OwnerID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *BalanceSnapshotMutation) ResetOwnerID() {
	m.entitlement = nil
}

// SetGrantBalances sets the "grant_balances" field.
func (m *BalanceSnapshotMutation) SetGrantBalances(b balance.Map) {
	m.grant_balances = &b
}

// GrantBalances returns the value of the "grant_balances" field in the mutation.
func (m *BalanceSnapshotMutation) GrantBalances() (r balance.Map, exists bool) {
	v := m.grant_balances
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantBalances returns the old "grant_balances" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldGrantBalances(ctx context.Context) (v balance.Map, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantBalances is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantBalances requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantBalances: %w", err)
	}
	return oldValue.GrantBalances, nil
}

// ResetGrantBalances resets all changes to the "grant_balances" field.
func (m *BalanceSnapshotMutation) ResetGrantBalances() {
	m.grant_balances = nil
}

// SetBalance sets the "balance" field.
func (m *BalanceSnapshotMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *BalanceSnapshotMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *BalanceSnapshotMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *BalanceSnapshotMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *BalanceSnapshotMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetOverage sets the "overage" field.
func (m *BalanceSnapshotMutation) SetOverage(f float64) {
	m.overage = &f
	m.addoverage = nil
}

// Overage returns the value of the "overage" field in the mutation.
func (m *BalanceSnapshotMutation) Overage() (r float64, exists bool) {
	v := m.overage
	if v == nil {
		return
	}
	return *v, true
}

// OldOverage returns the old "overage" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldOverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverage: %w", err)
	}
	return oldValue.Overage, nil
}

// AddOverage adds f to the "overage" field.
func (m *BalanceSnapshotMutation) AddOverage(f float64) {
	if m.addoverage != nil {
		*m.addoverage += f
	} else {
		m.addoverage = &f
	}
}

// AddedOverage returns the value that was added to the "overage" field in this mutation.
func (m *BalanceSnapshotMutation) AddedOverage() (r float64, exists bool) {
	v := m.addoverage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverage resets all changes to the "overage" field.
func (m *BalanceSnapshotMutation) ResetOverage() {
	m.overage = nil
	m.addoverage = nil
}

// SetAt sets the "at" field.
func (m *BalanceSnapshotMutation) SetAt(t time.Time) {
	m.at = &t
}

// At returns the value of the "at" field in the mutation.
func (m *BalanceSnapshotMutation) At() (r time.Time, exists bool) {
	v := m.at
	if v == nil {
		return
	}
	return *v, true
}

// OldAt returns the old "at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAt: %w", err)
	}
	return oldValue.At, nil
}

// ResetAt resets all changes to the "at" field.
func (m *BalanceSnapshotMutation) ResetAt() {
	m.at = nil
}

// SetEntitlementID sets the "entitlement" edge to the Entitlement entity by id.
func (m *BalanceSnapshotMutation) SetEntitlementID(id string) {
	m.entitlement = &id
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *BalanceSnapshotMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[balancesnapshot.FieldOwnerID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *BalanceSnapshotMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementID returns the "entitlement" edge ID in the mutation.
func (m *BalanceSnapshotMutation) EntitlementID() (id string, exists bool) {
	if m.entitlement != nil {
		return *m.entitlement, true
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *BalanceSnapshotMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *BalanceSnapshotMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the BalanceSnapshotMutation builder.
func (m *BalanceSnapshotMutation) Where(ps ...predicate.BalanceSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BalanceSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BalanceSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BalanceSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BalanceSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BalanceSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BalanceSnapshot).
func (m *BalanceSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BalanceSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.namespace != nil {
		fields = append(fields, balancesnapshot.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, balancesnapshot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, balancesnapshot.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, balancesnapshot.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, balancesnapshot.FieldOwnerID)
	}
	if m.grant_balances != nil {
		fields = append(fields, balancesnapshot.FieldGrantBalances)
	}
	if m.balance != nil {
		fields = append(fields, balancesnapshot.FieldBalance)
	}
	if m.overage != nil {
		fields = append(fields, balancesnapshot.FieldOverage)
	}
	if m.at != nil {
		fields = append(fields, balancesnapshot.FieldAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BalanceSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case balancesnapshot.FieldNamespace:
		return m.Namespace()
	case balancesnapshot.FieldCreatedAt:
		return m.CreatedAt()
	case balancesnapshot.FieldUpdatedAt:
		return m.UpdatedAt()
	case balancesnapshot.FieldDeletedAt:
		return m.DeletedAt()
	case balancesnapshot.FieldOwnerID:
		return m.OwnerID()
	case balancesnapshot.FieldGrantBalances:
		return m.GrantBalances()
	case balancesnapshot.FieldBalance:
		return m.Balance()
	case balancesnapshot.FieldOverage:
		return m.Overage()
	case balancesnapshot.FieldAt:
		return m.At()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BalanceSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case balancesnapshot.FieldNamespace:
		return m.OldNamespace(ctx)
	case balancesnapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case balancesnapshot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case balancesnapshot.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case balancesnapshot.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case balancesnapshot.FieldGrantBalances:
		return m.OldGrantBalances(ctx)
	case balancesnapshot.FieldBalance:
		return m.OldBalance(ctx)
	case balancesnapshot.FieldOverage:
		return m.OldOverage(ctx)
	case balancesnapshot.FieldAt:
		return m.OldAt(ctx)
	}
	return nil, fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case balancesnapshot.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case balancesnapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case balancesnapshot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case balancesnapshot.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case balancesnapshot.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case balancesnapshot.FieldGrantBalances:
		v, ok := value.(balance.Map)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantBalances(v)
		return nil
	case balancesnapshot.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case balancesnapshot.FieldOverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverage(v)
		return nil
	case balancesnapshot.FieldAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAt(v)
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BalanceSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, balancesnapshot.FieldBalance)
	}
	if m.addoverage != nil {
		fields = append(fields, balancesnapshot.FieldOverage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BalanceSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case balancesnapshot.FieldBalance:
		return m.AddedBalance()
	case balancesnapshot.FieldOverage:
		return m.AddedOverage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case balancesnapshot.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case balancesnapshot.FieldOverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverage(v)
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BalanceSnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(balancesnapshot.FieldDeletedAt) {
		fields = append(fields, balancesnapshot.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BalanceSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BalanceSnapshotMutation) ClearField(name string) error {
	switch name {
	case balancesnapshot.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BalanceSnapshotMutation) ResetField(name string) error {
	switch name {
	case balancesnapshot.FieldNamespace:
		m.ResetNamespace()
		return nil
	case balancesnapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case balancesnapshot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case balancesnapshot.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case balancesnapshot.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case balancesnapshot.FieldGrantBalances:
		m.ResetGrantBalances()
		return nil
	case balancesnapshot.FieldBalance:
		m.ResetBalance()
		return nil
	case balancesnapshot.FieldOverage:
		m.ResetOverage()
		return nil
	case balancesnapshot.FieldAt:
		m.ResetAt()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BalanceSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, balancesnapshot.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BalanceSnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BalanceSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BalanceSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BalanceSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, balancesnapshot.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BalanceSnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BalanceSnapshotMutation) ClearEdge(name string) error {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BalanceSnapshotMutation) ResetEdge(name string) error {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot edge %s", name)
}

// BillingCustomerOverrideMutation represents an operation that mutates the BillingCustomerOverride nodes in the graph.
type BillingCustomerOverrideMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	namespace                 *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	collection_alignment      *billingentity.AlignmentKind
	line_collection_period    *datex.ISOString
	invoice_auto_advance      *bool
	invoice_draft_period      *datex.ISOString
	invoice_due_after         *datex.ISOString
	invoice_collection_method *billingentity.CollectionMethod
	clearedFields             map[string]struct{}
	customer                  *string
	clearedcustomer           bool
	billing_profile           *string
	clearedbilling_profile    bool
	done                      bool
	oldValue                  func(context.Context) (*BillingCustomerOverride, error)
	predicates                []predicate.BillingCustomerOverride
}

var _ ent.Mutation = (*BillingCustomerOverrideMutation)(nil)

// billingcustomeroverrideOption allows management of the mutation configuration using functional options.
type billingcustomeroverrideOption func(*BillingCustomerOverrideMutation)

// newBillingCustomerOverrideMutation creates new mutation for the BillingCustomerOverride entity.
func newBillingCustomerOverrideMutation(c config, op Op, opts ...billingcustomeroverrideOption) *BillingCustomerOverrideMutation {
	m := &BillingCustomerOverrideMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingCustomerOverride,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingCustomerOverrideID sets the ID field of the mutation.
func withBillingCustomerOverrideID(id string) billingcustomeroverrideOption {
	return func(m *BillingCustomerOverrideMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingCustomerOverride
		)
		m.oldValue = func(ctx context.Context) (*BillingCustomerOverride, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingCustomerOverride.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingCustomerOverride sets the old BillingCustomerOverride of the mutation.
func withBillingCustomerOverride(node *BillingCustomerOverride) billingcustomeroverrideOption {
	return func(m *BillingCustomerOverrideMutation) {
		m.oldValue = func(context.Context) (*BillingCustomerOverride, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingCustomerOverrideMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingCustomerOverrideMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingCustomerOverride entities.
func (m *BillingCustomerOverrideMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingCustomerOverrideMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingCustomerOverrideMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingCustomerOverride.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingCustomerOverrideMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingCustomerOverrideMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingCustomerOverrideMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingCustomerOverrideMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingCustomerOverrideMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingCustomerOverrideMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingCustomerOverrideMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingCustomerOverrideMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingCustomerOverrideMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingCustomerOverrideMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingCustomerOverrideMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingCustomerOverrideMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billingcustomeroverride.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingCustomerOverrideMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billingcustomeroverride.FieldDeletedAt)
}

// SetCustomerID sets the "customer_id" field.
func (m *BillingCustomerOverrideMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *BillingCustomerOverrideMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *BillingCustomerOverrideMutation) ResetCustomerID() {
	m.customer = nil
}

// SetBillingProfileID sets the "billing_profile_id" field.
func (m *BillingCustomerOverrideMutation) SetBillingProfileID(s string) {
	m.billing_profile = &s
}

// BillingProfileID returns the value of the "billing_profile_id" field in the mutation.
func (m *BillingCustomerOverrideMutation) BillingProfileID() (r string, exists bool) {
	v := m.billing_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingProfileID returns the old "billing_profile_id" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldBillingProfileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingProfileID: %w", err)
	}
	return oldValue.BillingProfileID, nil
}

// ClearBillingProfileID clears the value of the "billing_profile_id" field.
func (m *BillingCustomerOverrideMutation) ClearBillingProfileID() {
	m.billing_profile = nil
	m.clearedFields[billingcustomeroverride.FieldBillingProfileID] = struct{}{}
}

// BillingProfileIDCleared returns if the "billing_profile_id" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) BillingProfileIDCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldBillingProfileID]
	return ok
}

// ResetBillingProfileID resets all changes to the "billing_profile_id" field.
func (m *BillingCustomerOverrideMutation) ResetBillingProfileID() {
	m.billing_profile = nil
	delete(m.clearedFields, billingcustomeroverride.FieldBillingProfileID)
}

// SetCollectionAlignment sets the "collection_alignment" field.
func (m *BillingCustomerOverrideMutation) SetCollectionAlignment(bk billingentity.AlignmentKind) {
	m.collection_alignment = &bk
}

// CollectionAlignment returns the value of the "collection_alignment" field in the mutation.
func (m *BillingCustomerOverrideMutation) CollectionAlignment() (r billingentity.AlignmentKind, exists bool) {
	v := m.collection_alignment
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionAlignment returns the old "collection_alignment" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldCollectionAlignment(ctx context.Context) (v *billingentity.AlignmentKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionAlignment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionAlignment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionAlignment: %w", err)
	}
	return oldValue.CollectionAlignment, nil
}

// ClearCollectionAlignment clears the value of the "collection_alignment" field.
func (m *BillingCustomerOverrideMutation) ClearCollectionAlignment() {
	m.collection_alignment = nil
	m.clearedFields[billingcustomeroverride.FieldCollectionAlignment] = struct{}{}
}

// CollectionAlignmentCleared returns if the "collection_alignment" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) CollectionAlignmentCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldCollectionAlignment]
	return ok
}

// ResetCollectionAlignment resets all changes to the "collection_alignment" field.
func (m *BillingCustomerOverrideMutation) ResetCollectionAlignment() {
	m.collection_alignment = nil
	delete(m.clearedFields, billingcustomeroverride.FieldCollectionAlignment)
}

// SetLineCollectionPeriod sets the "line_collection_period" field.
func (m *BillingCustomerOverrideMutation) SetLineCollectionPeriod(ds datex.ISOString) {
	m.line_collection_period = &ds
}

// LineCollectionPeriod returns the value of the "line_collection_period" field in the mutation.
func (m *BillingCustomerOverrideMutation) LineCollectionPeriod() (r datex.ISOString, exists bool) {
	v := m.line_collection_period
	if v == nil {
		return
	}
	return *v, true
}

// OldLineCollectionPeriod returns the old "line_collection_period" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldLineCollectionPeriod(ctx context.Context) (v *datex.ISOString, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineCollectionPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineCollectionPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineCollectionPeriod: %w", err)
	}
	return oldValue.LineCollectionPeriod, nil
}

// ClearLineCollectionPeriod clears the value of the "line_collection_period" field.
func (m *BillingCustomerOverrideMutation) ClearLineCollectionPeriod() {
	m.line_collection_period = nil
	m.clearedFields[billingcustomeroverride.FieldLineCollectionPeriod] = struct{}{}
}

// LineCollectionPeriodCleared returns if the "line_collection_period" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) LineCollectionPeriodCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldLineCollectionPeriod]
	return ok
}

// ResetLineCollectionPeriod resets all changes to the "line_collection_period" field.
func (m *BillingCustomerOverrideMutation) ResetLineCollectionPeriod() {
	m.line_collection_period = nil
	delete(m.clearedFields, billingcustomeroverride.FieldLineCollectionPeriod)
}

// SetInvoiceAutoAdvance sets the "invoice_auto_advance" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceAutoAdvance(b bool) {
	m.invoice_auto_advance = &b
}

// InvoiceAutoAdvance returns the value of the "invoice_auto_advance" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceAutoAdvance() (r bool, exists bool) {
	v := m.invoice_auto_advance
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceAutoAdvance returns the old "invoice_auto_advance" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceAutoAdvance(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceAutoAdvance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceAutoAdvance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceAutoAdvance: %w", err)
	}
	return oldValue.InvoiceAutoAdvance, nil
}

// ClearInvoiceAutoAdvance clears the value of the "invoice_auto_advance" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceAutoAdvance() {
	m.invoice_auto_advance = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceAutoAdvance] = struct{}{}
}

// InvoiceAutoAdvanceCleared returns if the "invoice_auto_advance" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceAutoAdvanceCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceAutoAdvance]
	return ok
}

// ResetInvoiceAutoAdvance resets all changes to the "invoice_auto_advance" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceAutoAdvance() {
	m.invoice_auto_advance = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceAutoAdvance)
}

// SetInvoiceDraftPeriod sets the "invoice_draft_period" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceDraftPeriod(ds datex.ISOString) {
	m.invoice_draft_period = &ds
}

// InvoiceDraftPeriod returns the value of the "invoice_draft_period" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDraftPeriod() (r datex.ISOString, exists bool) {
	v := m.invoice_draft_period
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDraftPeriod returns the old "invoice_draft_period" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceDraftPeriod(ctx context.Context) (v *datex.ISOString, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDraftPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDraftPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDraftPeriod: %w", err)
	}
	return oldValue.InvoiceDraftPeriod, nil
}

// ClearInvoiceDraftPeriod clears the value of the "invoice_draft_period" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceDraftPeriod() {
	m.invoice_draft_period = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceDraftPeriod] = struct{}{}
}

// InvoiceDraftPeriodCleared returns if the "invoice_draft_period" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDraftPeriodCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceDraftPeriod]
	return ok
}

// ResetInvoiceDraftPeriod resets all changes to the "invoice_draft_period" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceDraftPeriod() {
	m.invoice_draft_period = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceDraftPeriod)
}

// SetInvoiceDueAfter sets the "invoice_due_after" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceDueAfter(ds datex.ISOString) {
	m.invoice_due_after = &ds
}

// InvoiceDueAfter returns the value of the "invoice_due_after" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDueAfter() (r datex.ISOString, exists bool) {
	v := m.invoice_due_after
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDueAfter returns the old "invoice_due_after" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceDueAfter(ctx context.Context) (v *datex.ISOString, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDueAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDueAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDueAfter: %w", err)
	}
	return oldValue.InvoiceDueAfter, nil
}

// ClearInvoiceDueAfter clears the value of the "invoice_due_after" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceDueAfter() {
	m.invoice_due_after = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceDueAfter] = struct{}{}
}

// InvoiceDueAfterCleared returns if the "invoice_due_after" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDueAfterCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceDueAfter]
	return ok
}

// ResetInvoiceDueAfter resets all changes to the "invoice_due_after" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceDueAfter() {
	m.invoice_due_after = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceDueAfter)
}

// SetInvoiceCollectionMethod sets the "invoice_collection_method" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceCollectionMethod(bm billingentity.CollectionMethod) {
	m.invoice_collection_method = &bm
}

// InvoiceCollectionMethod returns the value of the "invoice_collection_method" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceCollectionMethod() (r billingentity.CollectionMethod, exists bool) {
	v := m.invoice_collection_method
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceCollectionMethod returns the old "invoice_collection_method" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceCollectionMethod(ctx context.Context) (v *billingentity.CollectionMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceCollectionMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceCollectionMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceCollectionMethod: %w", err)
	}
	return oldValue.InvoiceCollectionMethod, nil
}

// ClearInvoiceCollectionMethod clears the value of the "invoice_collection_method" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceCollectionMethod() {
	m.invoice_collection_method = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceCollectionMethod] = struct{}{}
}

// InvoiceCollectionMethodCleared returns if the "invoice_collection_method" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceCollectionMethodCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceCollectionMethod]
	return ok
}

// ResetInvoiceCollectionMethod resets all changes to the "invoice_collection_method" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceCollectionMethod() {
	m.invoice_collection_method = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceCollectionMethod)
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *BillingCustomerOverrideMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[billingcustomeroverride.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *BillingCustomerOverrideMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *BillingCustomerOverrideMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *BillingCustomerOverrideMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearBillingProfile clears the "billing_profile" edge to the BillingProfile entity.
func (m *BillingCustomerOverrideMutation) ClearBillingProfile() {
	m.clearedbilling_profile = true
	m.clearedFields[billingcustomeroverride.FieldBillingProfileID] = struct{}{}
}

// BillingProfileCleared reports if the "billing_profile" edge to the BillingProfile entity was cleared.
func (m *BillingCustomerOverrideMutation) BillingProfileCleared() bool {
	return m.BillingProfileIDCleared() || m.clearedbilling_profile
}

// BillingProfileIDs returns the "billing_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingProfileID instead. It exists only for internal usage by the builders.
func (m *BillingCustomerOverrideMutation) BillingProfileIDs() (ids []string) {
	if id := m.billing_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingProfile resets all changes to the "billing_profile" edge.
func (m *BillingCustomerOverrideMutation) ResetBillingProfile() {
	m.billing_profile = nil
	m.clearedbilling_profile = false
}

// Where appends a list predicates to the BillingCustomerOverrideMutation builder.
func (m *BillingCustomerOverrideMutation) Where(ps ...predicate.BillingCustomerOverride) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingCustomerOverrideMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingCustomerOverrideMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingCustomerOverride, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingCustomerOverrideMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingCustomerOverrideMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingCustomerOverride).
func (m *BillingCustomerOverrideMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingCustomerOverrideMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.namespace != nil {
		fields = append(fields, billingcustomeroverride.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billingcustomeroverride.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingcustomeroverride.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billingcustomeroverride.FieldDeletedAt)
	}
	if m.customer != nil {
		fields = append(fields, billingcustomeroverride.FieldCustomerID)
	}
	if m.billing_profile != nil {
		fields = append(fields, billingcustomeroverride.FieldBillingProfileID)
	}
	if m.collection_alignment != nil {
		fields = append(fields, billingcustomeroverride.FieldCollectionAlignment)
	}
	if m.line_collection_period != nil {
		fields = append(fields, billingcustomeroverride.FieldLineCollectionPeriod)
	}
	if m.invoice_auto_advance != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceAutoAdvance)
	}
	if m.invoice_draft_period != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDraftPeriod)
	}
	if m.invoice_due_after != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDueAfter)
	}
	if m.invoice_collection_method != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceCollectionMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingCustomerOverrideMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		return m.Namespace()
	case billingcustomeroverride.FieldCreatedAt:
		return m.CreatedAt()
	case billingcustomeroverride.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingcustomeroverride.FieldDeletedAt:
		return m.DeletedAt()
	case billingcustomeroverride.FieldCustomerID:
		return m.CustomerID()
	case billingcustomeroverride.FieldBillingProfileID:
		return m.BillingProfileID()
	case billingcustomeroverride.FieldCollectionAlignment:
		return m.CollectionAlignment()
	case billingcustomeroverride.FieldLineCollectionPeriod:
		return m.LineCollectionPeriod()
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		return m.InvoiceAutoAdvance()
	case billingcustomeroverride.FieldInvoiceDraftPeriod:
		return m.InvoiceDraftPeriod()
	case billingcustomeroverride.FieldInvoiceDueAfter:
		return m.InvoiceDueAfter()
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		return m.InvoiceCollectionMethod()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingCustomerOverrideMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingcustomeroverride.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingcustomeroverride.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingcustomeroverride.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billingcustomeroverride.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case billingcustomeroverride.FieldBillingProfileID:
		return m.OldBillingProfileID(ctx)
	case billingcustomeroverride.FieldCollectionAlignment:
		return m.OldCollectionAlignment(ctx)
	case billingcustomeroverride.FieldLineCollectionPeriod:
		return m.OldLineCollectionPeriod(ctx)
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		return m.OldInvoiceAutoAdvance(ctx)
	case billingcustomeroverride.FieldInvoiceDraftPeriod:
		return m.OldInvoiceDraftPeriod(ctx)
	case billingcustomeroverride.FieldInvoiceDueAfter:
		return m.OldInvoiceDueAfter(ctx)
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		return m.OldInvoiceCollectionMethod(ctx)
	}
	return nil, fmt.Errorf("unknown BillingCustomerOverride field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingCustomerOverrideMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingcustomeroverride.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingcustomeroverride.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingcustomeroverride.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billingcustomeroverride.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case billingcustomeroverride.FieldBillingProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingProfileID(v)
		return nil
	case billingcustomeroverride.FieldCollectionAlignment:
		v, ok := value.(billingentity.AlignmentKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionAlignment(v)
		return nil
	case billingcustomeroverride.FieldLineCollectionPeriod:
		v, ok := value.(datex.ISOString)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineCollectionPeriod(v)
		return nil
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceAutoAdvance(v)
		return nil
	case billingcustomeroverride.FieldInvoiceDraftPeriod:
		v, ok := value.(datex.ISOString)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDraftPeriod(v)
		return nil
	case billingcustomeroverride.FieldInvoiceDueAfter:
		v, ok := value.(datex.ISOString)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDueAfter(v)
		return nil
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		v, ok := value.(billingentity.CollectionMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceCollectionMethod(v)
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingCustomerOverrideMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingCustomerOverrideMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingCustomerOverrideMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingCustomerOverride numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingCustomerOverrideMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billingcustomeroverride.FieldDeletedAt) {
		fields = append(fields, billingcustomeroverride.FieldDeletedAt)
	}
	if m.FieldCleared(billingcustomeroverride.FieldBillingProfileID) {
		fields = append(fields, billingcustomeroverride.FieldBillingProfileID)
	}
	if m.FieldCleared(billingcustomeroverride.FieldCollectionAlignment) {
		fields = append(fields, billingcustomeroverride.FieldCollectionAlignment)
	}
	if m.FieldCleared(billingcustomeroverride.FieldLineCollectionPeriod) {
		fields = append(fields, billingcustomeroverride.FieldLineCollectionPeriod)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceAutoAdvance) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceAutoAdvance)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceDraftPeriod) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDraftPeriod)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceDueAfter) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDueAfter)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceCollectionMethod) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceCollectionMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingCustomerOverrideMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ClearField(name string) error {
	switch name {
	case billingcustomeroverride.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billingcustomeroverride.FieldBillingProfileID:
		m.ClearBillingProfileID()
		return nil
	case billingcustomeroverride.FieldCollectionAlignment:
		m.ClearCollectionAlignment()
		return nil
	case billingcustomeroverride.FieldLineCollectionPeriod:
		m.ClearLineCollectionPeriod()
		return nil
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		m.ClearInvoiceAutoAdvance()
		return nil
	case billingcustomeroverride.FieldInvoiceDraftPeriod:
		m.ClearInvoiceDraftPeriod()
		return nil
	case billingcustomeroverride.FieldInvoiceDueAfter:
		m.ClearInvoiceDueAfter()
		return nil
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		m.ClearInvoiceCollectionMethod()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ResetField(name string) error {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingcustomeroverride.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingcustomeroverride.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingcustomeroverride.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billingcustomeroverride.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case billingcustomeroverride.FieldBillingProfileID:
		m.ResetBillingProfileID()
		return nil
	case billingcustomeroverride.FieldCollectionAlignment:
		m.ResetCollectionAlignment()
		return nil
	case billingcustomeroverride.FieldLineCollectionPeriod:
		m.ResetLineCollectionPeriod()
		return nil
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		m.ResetInvoiceAutoAdvance()
		return nil
	case billingcustomeroverride.FieldInvoiceDraftPeriod:
		m.ResetInvoiceDraftPeriod()
		return nil
	case billingcustomeroverride.FieldInvoiceDueAfter:
		m.ResetInvoiceDueAfter()
		return nil
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		m.ResetInvoiceCollectionMethod()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingCustomerOverrideMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.customer != nil {
		edges = append(edges, billingcustomeroverride.EdgeCustomer)
	}
	if m.billing_profile != nil {
		edges = append(edges, billingcustomeroverride.EdgeBillingProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingCustomerOverrideMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case billingcustomeroverride.EdgeBillingProfile:
		if id := m.billing_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingCustomerOverrideMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingCustomerOverrideMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingCustomerOverrideMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcustomer {
		edges = append(edges, billingcustomeroverride.EdgeCustomer)
	}
	if m.clearedbilling_profile {
		edges = append(edges, billingcustomeroverride.EdgeBillingProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) EdgeCleared(name string) bool {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		return m.clearedcustomer
	case billingcustomeroverride.EdgeBillingProfile:
		return m.clearedbilling_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ClearEdge(name string) error {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case billingcustomeroverride.EdgeBillingProfile:
		m.ClearBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ResetEdge(name string) error {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case billingcustomeroverride.EdgeBillingProfile:
		m.ResetBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride edge %s", name)
}

// BillingInvoiceMutation represents an operation that mutates the BillingInvoice nodes in the graph.
type BillingInvoiceMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *string
	namespace                                *string
	metadata                                 *map[string]string
	created_at                               *time.Time
	updated_at                               *time.Time
	deleted_at                               *time.Time
	supplier_address_country                 *models.CountryCode
	supplier_address_postal_code             *string
	supplier_address_state                   *string
	supplier_address_city                    *string
	supplier_address_line1                   *string
	supplier_address_line2                   *string
	supplier_address_phone_number            *string
	customer_address_country                 *models.CountryCode
	customer_address_postal_code             *string
	customer_address_state                   *string
	customer_address_city                    *string
	customer_address_line1                   *string
	customer_address_line2                   *string
	customer_address_phone_number            *string
	supplier_name                            *string
	supplier_tax_code                        *string
	customer_name                            *string
	customer_timezone                        *timezone.Timezone
	number                                   *string
	_type                                    *billingentity.InvoiceType
	description                              *string
	voided_at                                *time.Time
	issued_at                                *time.Time
	draft_until                              *time.Time
	currency                                 *currencyx.Code
	due_at                                   *time.Time
	status                                   *billingentity.InvoiceStatus
	period_start                             *time.Time
	period_end                               *time.Time
	clearedFields                            map[string]struct{}
	source_billing_profile                   *string
	clearedsource_billing_profile            bool
	billing_workflow_config                  *string
	clearedbilling_workflow_config           bool
	billing_invoice_lines                    map[string]struct{}
	removedbilling_invoice_lines             map[string]struct{}
	clearedbilling_invoice_lines             bool
	billing_invoice_validation_issues        map[string]struct{}
	removedbilling_invoice_validation_issues map[string]struct{}
	clearedbilling_invoice_validation_issues bool
	billing_invoice_customer                 *string
	clearedbilling_invoice_customer          bool
	tax_app                                  *string
	clearedtax_app                           bool
	invoicing_app                            *string
	clearedinvoicing_app                     bool
	payment_app                              *string
	clearedpayment_app                       bool
	done                                     bool
	oldValue                                 func(context.Context) (*BillingInvoice, error)
	predicates                               []predicate.BillingInvoice
}

var _ ent.Mutation = (*BillingInvoiceMutation)(nil)

// billinginvoiceOption allows management of the mutation configuration using functional options.
type billinginvoiceOption func(*BillingInvoiceMutation)

// newBillingInvoiceMutation creates new mutation for the BillingInvoice entity.
func newBillingInvoiceMutation(c config, op Op, opts ...billinginvoiceOption) *BillingInvoiceMutation {
	m := &BillingInvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceID sets the ID field of the mutation.
func withBillingInvoiceID(id string) billinginvoiceOption {
	return func(m *BillingInvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoice
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoice sets the old BillingInvoice of the mutation.
func withBillingInvoice(node *BillingInvoice) billinginvoiceOption {
	return func(m *BillingInvoiceMutation) {
		m.oldValue = func(context.Context) (*BillingInvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoice entities.
func (m *BillingInvoiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *BillingInvoiceMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *BillingInvoiceMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *BillingInvoiceMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[billinginvoice.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *BillingInvoiceMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *BillingInvoiceMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, billinginvoice.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingInvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingInvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingInvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingInvoiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingInvoiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingInvoiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingInvoiceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingInvoiceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingInvoiceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billinginvoice.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingInvoiceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billinginvoice.FieldDeletedAt)
}

// SetSupplierAddressCountry sets the "supplier_address_country" field.
func (m *BillingInvoiceMutation) SetSupplierAddressCountry(mc models.CountryCode) {
	m.supplier_address_country = &mc
}

// SupplierAddressCountry returns the value of the "supplier_address_country" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressCountry() (r models.CountryCode, exists bool) {
	v := m.supplier_address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressCountry returns the old "supplier_address_country" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressCountry(ctx context.Context) (v *models.CountryCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressCountry: %w", err)
	}
	return oldValue.SupplierAddressCountry, nil
}

// ClearSupplierAddressCountry clears the value of the "supplier_address_country" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressCountry() {
	m.supplier_address_country = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressCountry] = struct{}{}
}

// SupplierAddressCountryCleared returns if the "supplier_address_country" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressCountryCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressCountry]
	return ok
}

// ResetSupplierAddressCountry resets all changes to the "supplier_address_country" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressCountry() {
	m.supplier_address_country = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressCountry)
}

// SetSupplierAddressPostalCode sets the "supplier_address_postal_code" field.
func (m *BillingInvoiceMutation) SetSupplierAddressPostalCode(s string) {
	m.supplier_address_postal_code = &s
}

// SupplierAddressPostalCode returns the value of the "supplier_address_postal_code" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressPostalCode() (r string, exists bool) {
	v := m.supplier_address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressPostalCode returns the old "supplier_address_postal_code" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressPostalCode: %w", err)
	}
	return oldValue.SupplierAddressPostalCode, nil
}

// ClearSupplierAddressPostalCode clears the value of the "supplier_address_postal_code" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressPostalCode() {
	m.supplier_address_postal_code = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressPostalCode] = struct{}{}
}

// SupplierAddressPostalCodeCleared returns if the "supplier_address_postal_code" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressPostalCode]
	return ok
}

// ResetSupplierAddressPostalCode resets all changes to the "supplier_address_postal_code" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressPostalCode() {
	m.supplier_address_postal_code = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressPostalCode)
}

// SetSupplierAddressState sets the "supplier_address_state" field.
func (m *BillingInvoiceMutation) SetSupplierAddressState(s string) {
	m.supplier_address_state = &s
}

// SupplierAddressState returns the value of the "supplier_address_state" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressState() (r string, exists bool) {
	v := m.supplier_address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressState returns the old "supplier_address_state" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressState: %w", err)
	}
	return oldValue.SupplierAddressState, nil
}

// ClearSupplierAddressState clears the value of the "supplier_address_state" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressState() {
	m.supplier_address_state = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressState] = struct{}{}
}

// SupplierAddressStateCleared returns if the "supplier_address_state" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressStateCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressState]
	return ok
}

// ResetSupplierAddressState resets all changes to the "supplier_address_state" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressState() {
	m.supplier_address_state = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressState)
}

// SetSupplierAddressCity sets the "supplier_address_city" field.
func (m *BillingInvoiceMutation) SetSupplierAddressCity(s string) {
	m.supplier_address_city = &s
}

// SupplierAddressCity returns the value of the "supplier_address_city" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressCity() (r string, exists bool) {
	v := m.supplier_address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressCity returns the old "supplier_address_city" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressCity: %w", err)
	}
	return oldValue.SupplierAddressCity, nil
}

// ClearSupplierAddressCity clears the value of the "supplier_address_city" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressCity() {
	m.supplier_address_city = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressCity] = struct{}{}
}

// SupplierAddressCityCleared returns if the "supplier_address_city" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressCityCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressCity]
	return ok
}

// ResetSupplierAddressCity resets all changes to the "supplier_address_city" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressCity() {
	m.supplier_address_city = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressCity)
}

// SetSupplierAddressLine1 sets the "supplier_address_line1" field.
func (m *BillingInvoiceMutation) SetSupplierAddressLine1(s string) {
	m.supplier_address_line1 = &s
}

// SupplierAddressLine1 returns the value of the "supplier_address_line1" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressLine1() (r string, exists bool) {
	v := m.supplier_address_line1
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressLine1 returns the old "supplier_address_line1" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressLine1: %w", err)
	}
	return oldValue.SupplierAddressLine1, nil
}

// ClearSupplierAddressLine1 clears the value of the "supplier_address_line1" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressLine1() {
	m.supplier_address_line1 = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressLine1] = struct{}{}
}

// SupplierAddressLine1Cleared returns if the "supplier_address_line1" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressLine1Cleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressLine1]
	return ok
}

// ResetSupplierAddressLine1 resets all changes to the "supplier_address_line1" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressLine1() {
	m.supplier_address_line1 = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressLine1)
}

// SetSupplierAddressLine2 sets the "supplier_address_line2" field.
func (m *BillingInvoiceMutation) SetSupplierAddressLine2(s string) {
	m.supplier_address_line2 = &s
}

// SupplierAddressLine2 returns the value of the "supplier_address_line2" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressLine2() (r string, exists bool) {
	v := m.supplier_address_line2
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressLine2 returns the old "supplier_address_line2" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressLine2: %w", err)
	}
	return oldValue.SupplierAddressLine2, nil
}

// ClearSupplierAddressLine2 clears the value of the "supplier_address_line2" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressLine2() {
	m.supplier_address_line2 = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressLine2] = struct{}{}
}

// SupplierAddressLine2Cleared returns if the "supplier_address_line2" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressLine2Cleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressLine2]
	return ok
}

// ResetSupplierAddressLine2 resets all changes to the "supplier_address_line2" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressLine2() {
	m.supplier_address_line2 = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressLine2)
}

// SetSupplierAddressPhoneNumber sets the "supplier_address_phone_number" field.
func (m *BillingInvoiceMutation) SetSupplierAddressPhoneNumber(s string) {
	m.supplier_address_phone_number = &s
}

// SupplierAddressPhoneNumber returns the value of the "supplier_address_phone_number" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressPhoneNumber() (r string, exists bool) {
	v := m.supplier_address_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressPhoneNumber returns the old "supplier_address_phone_number" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressPhoneNumber: %w", err)
	}
	return oldValue.SupplierAddressPhoneNumber, nil
}

// ClearSupplierAddressPhoneNumber clears the value of the "supplier_address_phone_number" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressPhoneNumber() {
	m.supplier_address_phone_number = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressPhoneNumber] = struct{}{}
}

// SupplierAddressPhoneNumberCleared returns if the "supplier_address_phone_number" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressPhoneNumberCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressPhoneNumber]
	return ok
}

// ResetSupplierAddressPhoneNumber resets all changes to the "supplier_address_phone_number" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressPhoneNumber() {
	m.supplier_address_phone_number = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressPhoneNumber)
}

// SetCustomerAddressCountry sets the "customer_address_country" field.
func (m *BillingInvoiceMutation) SetCustomerAddressCountry(mc models.CountryCode) {
	m.customer_address_country = &mc
}

// CustomerAddressCountry returns the value of the "customer_address_country" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressCountry() (r models.CountryCode, exists bool) {
	v := m.customer_address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressCountry returns the old "customer_address_country" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressCountry(ctx context.Context) (v *models.CountryCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressCountry: %w", err)
	}
	return oldValue.CustomerAddressCountry, nil
}

// ClearCustomerAddressCountry clears the value of the "customer_address_country" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressCountry() {
	m.customer_address_country = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressCountry] = struct{}{}
}

// CustomerAddressCountryCleared returns if the "customer_address_country" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressCountryCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressCountry]
	return ok
}

// ResetCustomerAddressCountry resets all changes to the "customer_address_country" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressCountry() {
	m.customer_address_country = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressCountry)
}

// SetCustomerAddressPostalCode sets the "customer_address_postal_code" field.
func (m *BillingInvoiceMutation) SetCustomerAddressPostalCode(s string) {
	m.customer_address_postal_code = &s
}

// CustomerAddressPostalCode returns the value of the "customer_address_postal_code" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressPostalCode() (r string, exists bool) {
	v := m.customer_address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressPostalCode returns the old "customer_address_postal_code" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressPostalCode: %w", err)
	}
	return oldValue.CustomerAddressPostalCode, nil
}

// ClearCustomerAddressPostalCode clears the value of the "customer_address_postal_code" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressPostalCode() {
	m.customer_address_postal_code = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressPostalCode] = struct{}{}
}

// CustomerAddressPostalCodeCleared returns if the "customer_address_postal_code" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressPostalCode]
	return ok
}

// ResetCustomerAddressPostalCode resets all changes to the "customer_address_postal_code" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressPostalCode() {
	m.customer_address_postal_code = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressPostalCode)
}

// SetCustomerAddressState sets the "customer_address_state" field.
func (m *BillingInvoiceMutation) SetCustomerAddressState(s string) {
	m.customer_address_state = &s
}

// CustomerAddressState returns the value of the "customer_address_state" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressState() (r string, exists bool) {
	v := m.customer_address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressState returns the old "customer_address_state" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressState: %w", err)
	}
	return oldValue.CustomerAddressState, nil
}

// ClearCustomerAddressState clears the value of the "customer_address_state" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressState() {
	m.customer_address_state = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressState] = struct{}{}
}

// CustomerAddressStateCleared returns if the "customer_address_state" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressStateCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressState]
	return ok
}

// ResetCustomerAddressState resets all changes to the "customer_address_state" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressState() {
	m.customer_address_state = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressState)
}

// SetCustomerAddressCity sets the "customer_address_city" field.
func (m *BillingInvoiceMutation) SetCustomerAddressCity(s string) {
	m.customer_address_city = &s
}

// CustomerAddressCity returns the value of the "customer_address_city" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressCity() (r string, exists bool) {
	v := m.customer_address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressCity returns the old "customer_address_city" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressCity: %w", err)
	}
	return oldValue.CustomerAddressCity, nil
}

// ClearCustomerAddressCity clears the value of the "customer_address_city" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressCity() {
	m.customer_address_city = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressCity] = struct{}{}
}

// CustomerAddressCityCleared returns if the "customer_address_city" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressCityCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressCity]
	return ok
}

// ResetCustomerAddressCity resets all changes to the "customer_address_city" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressCity() {
	m.customer_address_city = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressCity)
}

// SetCustomerAddressLine1 sets the "customer_address_line1" field.
func (m *BillingInvoiceMutation) SetCustomerAddressLine1(s string) {
	m.customer_address_line1 = &s
}

// CustomerAddressLine1 returns the value of the "customer_address_line1" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressLine1() (r string, exists bool) {
	v := m.customer_address_line1
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressLine1 returns the old "customer_address_line1" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressLine1: %w", err)
	}
	return oldValue.CustomerAddressLine1, nil
}

// ClearCustomerAddressLine1 clears the value of the "customer_address_line1" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressLine1() {
	m.customer_address_line1 = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressLine1] = struct{}{}
}

// CustomerAddressLine1Cleared returns if the "customer_address_line1" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressLine1Cleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressLine1]
	return ok
}

// ResetCustomerAddressLine1 resets all changes to the "customer_address_line1" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressLine1() {
	m.customer_address_line1 = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressLine1)
}

// SetCustomerAddressLine2 sets the "customer_address_line2" field.
func (m *BillingInvoiceMutation) SetCustomerAddressLine2(s string) {
	m.customer_address_line2 = &s
}

// CustomerAddressLine2 returns the value of the "customer_address_line2" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressLine2() (r string, exists bool) {
	v := m.customer_address_line2
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressLine2 returns the old "customer_address_line2" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressLine2: %w", err)
	}
	return oldValue.CustomerAddressLine2, nil
}

// ClearCustomerAddressLine2 clears the value of the "customer_address_line2" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressLine2() {
	m.customer_address_line2 = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressLine2] = struct{}{}
}

// CustomerAddressLine2Cleared returns if the "customer_address_line2" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressLine2Cleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressLine2]
	return ok
}

// ResetCustomerAddressLine2 resets all changes to the "customer_address_line2" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressLine2() {
	m.customer_address_line2 = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressLine2)
}

// SetCustomerAddressPhoneNumber sets the "customer_address_phone_number" field.
func (m *BillingInvoiceMutation) SetCustomerAddressPhoneNumber(s string) {
	m.customer_address_phone_number = &s
}

// CustomerAddressPhoneNumber returns the value of the "customer_address_phone_number" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressPhoneNumber() (r string, exists bool) {
	v := m.customer_address_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressPhoneNumber returns the old "customer_address_phone_number" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressPhoneNumber: %w", err)
	}
	return oldValue.CustomerAddressPhoneNumber, nil
}

// ClearCustomerAddressPhoneNumber clears the value of the "customer_address_phone_number" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressPhoneNumber() {
	m.customer_address_phone_number = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressPhoneNumber] = struct{}{}
}

// CustomerAddressPhoneNumberCleared returns if the "customer_address_phone_number" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressPhoneNumberCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressPhoneNumber]
	return ok
}

// ResetCustomerAddressPhoneNumber resets all changes to the "customer_address_phone_number" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressPhoneNumber() {
	m.customer_address_phone_number = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressPhoneNumber)
}

// SetSupplierName sets the "supplier_name" field.
func (m *BillingInvoiceMutation) SetSupplierName(s string) {
	m.supplier_name = &s
}

// SupplierName returns the value of the "supplier_name" field in the mutation.
func (m *BillingInvoiceMutation) SupplierName() (r string, exists bool) {
	v := m.supplier_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierName returns the old "supplier_name" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierName: %w", err)
	}
	return oldValue.SupplierName, nil
}

// ResetSupplierName resets all changes to the "supplier_name" field.
func (m *BillingInvoiceMutation) ResetSupplierName() {
	m.supplier_name = nil
}

// SetSupplierTaxCode sets the "supplier_tax_code" field.
func (m *BillingInvoiceMutation) SetSupplierTaxCode(s string) {
	m.supplier_tax_code = &s
}

// SupplierTaxCode returns the value of the "supplier_tax_code" field in the mutation.
func (m *BillingInvoiceMutation) SupplierTaxCode() (r string, exists bool) {
	v := m.supplier_tax_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierTaxCode returns the old "supplier_tax_code" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierTaxCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierTaxCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierTaxCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierTaxCode: %w", err)
	}
	return oldValue.SupplierTaxCode, nil
}

// ClearSupplierTaxCode clears the value of the "supplier_tax_code" field.
func (m *BillingInvoiceMutation) ClearSupplierTaxCode() {
	m.supplier_tax_code = nil
	m.clearedFields[billinginvoice.FieldSupplierTaxCode] = struct{}{}
}

// SupplierTaxCodeCleared returns if the "supplier_tax_code" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierTaxCodeCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierTaxCode]
	return ok
}

// ResetSupplierTaxCode resets all changes to the "supplier_tax_code" field.
func (m *BillingInvoiceMutation) ResetSupplierTaxCode() {
	m.supplier_tax_code = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierTaxCode)
}

// SetCustomerName sets the "customer_name" field.
func (m *BillingInvoiceMutation) SetCustomerName(s string) {
	m.customer_name = &s
}

// CustomerName returns the value of the "customer_name" field in the mutation.
func (m *BillingInvoiceMutation) CustomerName() (r string, exists bool) {
	v := m.customer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerName returns the old "customer_name" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerName: %w", err)
	}
	return oldValue.CustomerName, nil
}

// ResetCustomerName resets all changes to the "customer_name" field.
func (m *BillingInvoiceMutation) ResetCustomerName() {
	m.customer_name = nil
}

// SetCustomerTimezone sets the "customer_timezone" field.
func (m *BillingInvoiceMutation) SetCustomerTimezone(t timezone.Timezone) {
	m.customer_timezone = &t
}

// CustomerTimezone returns the value of the "customer_timezone" field in the mutation.
func (m *BillingInvoiceMutation) CustomerTimezone() (r timezone.Timezone, exists bool) {
	v := m.customer_timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerTimezone returns the old "customer_timezone" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerTimezone(ctx context.Context) (v *timezone.Timezone, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerTimezone: %w", err)
	}
	return oldValue.CustomerTimezone, nil
}

// ClearCustomerTimezone clears the value of the "customer_timezone" field.
func (m *BillingInvoiceMutation) ClearCustomerTimezone() {
	m.customer_timezone = nil
	m.clearedFields[billinginvoice.FieldCustomerTimezone] = struct{}{}
}

// CustomerTimezoneCleared returns if the "customer_timezone" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerTimezoneCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerTimezone]
	return ok
}

// ResetCustomerTimezone resets all changes to the "customer_timezone" field.
func (m *BillingInvoiceMutation) ResetCustomerTimezone() {
	m.customer_timezone = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerTimezone)
}

// SetNumber sets the "number" field.
func (m *BillingInvoiceMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *BillingInvoiceMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ClearNumber clears the value of the "number" field.
func (m *BillingInvoiceMutation) ClearNumber() {
	m.number = nil
	m.clearedFields[billinginvoice.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *BillingInvoiceMutation) NumberCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *BillingInvoiceMutation) ResetNumber() {
	m.number = nil
	delete(m.clearedFields, billinginvoice.FieldNumber)
}

// SetType sets the "type" field.
func (m *BillingInvoiceMutation) SetType(bt billingentity.InvoiceType) {
	m._type = &bt
}

// GetType returns the value of the "type" field in the mutation.
func (m *BillingInvoiceMutation) GetType() (r billingentity.InvoiceType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldType(ctx context.Context) (v billingentity.InvoiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BillingInvoiceMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *BillingInvoiceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BillingInvoiceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BillingInvoiceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[billinginvoice.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BillingInvoiceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BillingInvoiceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, billinginvoice.FieldDescription)
}

// SetCustomerID sets the "customer_id" field.
func (m *BillingInvoiceMutation) SetCustomerID(s string) {
	m.billing_invoice_customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *BillingInvoiceMutation) CustomerID() (r string, exists bool) {
	v := m.billing_invoice_customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *BillingInvoiceMutation) ResetCustomerID() {
	m.billing_invoice_customer = nil
}

// SetSourceBillingProfileID sets the "source_billing_profile_id" field.
func (m *BillingInvoiceMutation) SetSourceBillingProfileID(s string) {
	m.source_billing_profile = &s
}

// SourceBillingProfileID returns the value of the "source_billing_profile_id" field in the mutation.
func (m *BillingInvoiceMutation) SourceBillingProfileID() (r string, exists bool) {
	v := m.source_billing_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceBillingProfileID returns the old "source_billing_profile_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSourceBillingProfileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceBillingProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceBillingProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceBillingProfileID: %w", err)
	}
	return oldValue.SourceBillingProfileID, nil
}

// ResetSourceBillingProfileID resets all changes to the "source_billing_profile_id" field.
func (m *BillingInvoiceMutation) ResetSourceBillingProfileID() {
	m.source_billing_profile = nil
}

// SetVoidedAt sets the "voided_at" field.
func (m *BillingInvoiceMutation) SetVoidedAt(t time.Time) {
	m.voided_at = &t
}

// VoidedAt returns the value of the "voided_at" field in the mutation.
func (m *BillingInvoiceMutation) VoidedAt() (r time.Time, exists bool) {
	v := m.voided_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidedAt returns the old "voided_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldVoidedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidedAt: %w", err)
	}
	return oldValue.VoidedAt, nil
}

// ClearVoidedAt clears the value of the "voided_at" field.
func (m *BillingInvoiceMutation) ClearVoidedAt() {
	m.voided_at = nil
	m.clearedFields[billinginvoice.FieldVoidedAt] = struct{}{}
}

// VoidedAtCleared returns if the "voided_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) VoidedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldVoidedAt]
	return ok
}

// ResetVoidedAt resets all changes to the "voided_at" field.
func (m *BillingInvoiceMutation) ResetVoidedAt() {
	m.voided_at = nil
	delete(m.clearedFields, billinginvoice.FieldVoidedAt)
}

// SetIssuedAt sets the "issued_at" field.
func (m *BillingInvoiceMutation) SetIssuedAt(t time.Time) {
	m.issued_at = &t
}

// IssuedAt returns the value of the "issued_at" field in the mutation.
func (m *BillingInvoiceMutation) IssuedAt() (r time.Time, exists bool) {
	v := m.issued_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedAt returns the old "issued_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldIssuedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedAt: %w", err)
	}
	return oldValue.IssuedAt, nil
}

// ClearIssuedAt clears the value of the "issued_at" field.
func (m *BillingInvoiceMutation) ClearIssuedAt() {
	m.issued_at = nil
	m.clearedFields[billinginvoice.FieldIssuedAt] = struct{}{}
}

// IssuedAtCleared returns if the "issued_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) IssuedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldIssuedAt]
	return ok
}

// ResetIssuedAt resets all changes to the "issued_at" field.
func (m *BillingInvoiceMutation) ResetIssuedAt() {
	m.issued_at = nil
	delete(m.clearedFields, billinginvoice.FieldIssuedAt)
}

// SetDraftUntil sets the "draft_until" field.
func (m *BillingInvoiceMutation) SetDraftUntil(t time.Time) {
	m.draft_until = &t
}

// DraftUntil returns the value of the "draft_until" field in the mutation.
func (m *BillingInvoiceMutation) DraftUntil() (r time.Time, exists bool) {
	v := m.draft_until
	if v == nil {
		return
	}
	return *v, true
}

// OldDraftUntil returns the old "draft_until" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDraftUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDraftUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDraftUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDraftUntil: %w", err)
	}
	return oldValue.DraftUntil, nil
}

// ClearDraftUntil clears the value of the "draft_until" field.
func (m *BillingInvoiceMutation) ClearDraftUntil() {
	m.draft_until = nil
	m.clearedFields[billinginvoice.FieldDraftUntil] = struct{}{}
}

// DraftUntilCleared returns if the "draft_until" field was cleared in this mutation.
func (m *BillingInvoiceMutation) DraftUntilCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldDraftUntil]
	return ok
}

// ResetDraftUntil resets all changes to the "draft_until" field.
func (m *BillingInvoiceMutation) ResetDraftUntil() {
	m.draft_until = nil
	delete(m.clearedFields, billinginvoice.FieldDraftUntil)
}

// SetCurrency sets the "currency" field.
func (m *BillingInvoiceMutation) SetCurrency(c currencyx.Code) {
	m.currency = &c
}

// Currency returns the value of the "currency" field in the mutation.
func (m *BillingInvoiceMutation) Currency() (r currencyx.Code, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCurrency(ctx context.Context) (v currencyx.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *BillingInvoiceMutation) ResetCurrency() {
	m.currency = nil
}

// SetDueAt sets the "due_at" field.
func (m *BillingInvoiceMutation) SetDueAt(t time.Time) {
	m.due_at = &t
}

// DueAt returns the value of the "due_at" field in the mutation.
func (m *BillingInvoiceMutation) DueAt() (r time.Time, exists bool) {
	v := m.due_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDueAt returns the old "due_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDueAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueAt: %w", err)
	}
	return oldValue.DueAt, nil
}

// ClearDueAt clears the value of the "due_at" field.
func (m *BillingInvoiceMutation) ClearDueAt() {
	m.due_at = nil
	m.clearedFields[billinginvoice.FieldDueAt] = struct{}{}
}

// DueAtCleared returns if the "due_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) DueAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldDueAt]
	return ok
}

// ResetDueAt resets all changes to the "due_at" field.
func (m *BillingInvoiceMutation) ResetDueAt() {
	m.due_at = nil
	delete(m.clearedFields, billinginvoice.FieldDueAt)
}

// SetStatus sets the "status" field.
func (m *BillingInvoiceMutation) SetStatus(bs billingentity.InvoiceStatus) {
	m.status = &bs
}

// Status returns the value of the "status" field in the mutation.
func (m *BillingInvoiceMutation) Status() (r billingentity.InvoiceStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldStatus(ctx context.Context) (v billingentity.InvoiceStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BillingInvoiceMutation) ResetStatus() {
	m.status = nil
}

// SetWorkflowConfigID sets the "workflow_config_id" field.
func (m *BillingInvoiceMutation) SetWorkflowConfigID(s string) {
	m.billing_workflow_config = &s
}

// WorkflowConfigID returns the value of the "workflow_config_id" field in the mutation.
func (m *BillingInvoiceMutation) WorkflowConfigID() (r string, exists bool) {
	v := m.billing_workflow_config
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowConfigID returns the old "workflow_config_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldWorkflowConfigID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowConfigID: %w", err)
	}
	return oldValue.WorkflowConfigID, nil
}

// ResetWorkflowConfigID resets all changes to the "workflow_config_id" field.
func (m *BillingInvoiceMutation) ResetWorkflowConfigID() {
	m.billing_workflow_config = nil
}

// SetTaxAppID sets the "tax_app_id" field.
func (m *BillingInvoiceMutation) SetTaxAppID(s string) {
	m.tax_app = &s
}

// TaxAppID returns the value of the "tax_app_id" field in the mutation.
func (m *BillingInvoiceMutation) TaxAppID() (r string, exists bool) {
	v := m.tax_app
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAppID returns the old "tax_app_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldTaxAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAppID: %w", err)
	}
	return oldValue.TaxAppID, nil
}

// ResetTaxAppID resets all changes to the "tax_app_id" field.
func (m *BillingInvoiceMutation) ResetTaxAppID() {
	m.tax_app = nil
}

// SetInvoicingAppID sets the "invoicing_app_id" field.
func (m *BillingInvoiceMutation) SetInvoicingAppID(s string) {
	m.invoicing_app = &s
}

// InvoicingAppID returns the value of the "invoicing_app_id" field in the mutation.
func (m *BillingInvoiceMutation) InvoicingAppID() (r string, exists bool) {
	v := m.invoicing_app
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingAppID returns the old "invoicing_app_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldInvoicingAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingAppID: %w", err)
	}
	return oldValue.InvoicingAppID, nil
}

// ResetInvoicingAppID resets all changes to the "invoicing_app_id" field.
func (m *BillingInvoiceMutation) ResetInvoicingAppID() {
	m.invoicing_app = nil
}

// SetPaymentAppID sets the "payment_app_id" field.
func (m *BillingInvoiceMutation) SetPaymentAppID(s string) {
	m.payment_app = &s
}

// PaymentAppID returns the value of the "payment_app_id" field in the mutation.
func (m *BillingInvoiceMutation) PaymentAppID() (r string, exists bool) {
	v := m.payment_app
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentAppID returns the old "payment_app_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldPaymentAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentAppID: %w", err)
	}
	return oldValue.PaymentAppID, nil
}

// ResetPaymentAppID resets all changes to the "payment_app_id" field.
func (m *BillingInvoiceMutation) ResetPaymentAppID() {
	m.payment_app = nil
}

// SetPeriodStart sets the "period_start" field.
func (m *BillingInvoiceMutation) SetPeriodStart(t time.Time) {
	m.period_start = &t
}

// PeriodStart returns the value of the "period_start" field in the mutation.
func (m *BillingInvoiceMutation) PeriodStart() (r time.Time, exists bool) {
	v := m.period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodStart returns the old "period_start" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldPeriodStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodStart: %w", err)
	}
	return oldValue.PeriodStart, nil
}

// ClearPeriodStart clears the value of the "period_start" field.
func (m *BillingInvoiceMutation) ClearPeriodStart() {
	m.period_start = nil
	m.clearedFields[billinginvoice.FieldPeriodStart] = struct{}{}
}

// PeriodStartCleared returns if the "period_start" field was cleared in this mutation.
func (m *BillingInvoiceMutation) PeriodStartCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldPeriodStart]
	return ok
}

// ResetPeriodStart resets all changes to the "period_start" field.
func (m *BillingInvoiceMutation) ResetPeriodStart() {
	m.period_start = nil
	delete(m.clearedFields, billinginvoice.FieldPeriodStart)
}

// SetPeriodEnd sets the "period_end" field.
func (m *BillingInvoiceMutation) SetPeriodEnd(t time.Time) {
	m.period_end = &t
}

// PeriodEnd returns the value of the "period_end" field in the mutation.
func (m *BillingInvoiceMutation) PeriodEnd() (r time.Time, exists bool) {
	v := m.period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodEnd returns the old "period_end" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldPeriodEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodEnd: %w", err)
	}
	return oldValue.PeriodEnd, nil
}

// ClearPeriodEnd clears the value of the "period_end" field.
func (m *BillingInvoiceMutation) ClearPeriodEnd() {
	m.period_end = nil
	m.clearedFields[billinginvoice.FieldPeriodEnd] = struct{}{}
}

// PeriodEndCleared returns if the "period_end" field was cleared in this mutation.
func (m *BillingInvoiceMutation) PeriodEndCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldPeriodEnd]
	return ok
}

// ResetPeriodEnd resets all changes to the "period_end" field.
func (m *BillingInvoiceMutation) ResetPeriodEnd() {
	m.period_end = nil
	delete(m.clearedFields, billinginvoice.FieldPeriodEnd)
}

// ClearSourceBillingProfile clears the "source_billing_profile" edge to the BillingProfile entity.
func (m *BillingInvoiceMutation) ClearSourceBillingProfile() {
	m.clearedsource_billing_profile = true
	m.clearedFields[billinginvoice.FieldSourceBillingProfileID] = struct{}{}
}

// SourceBillingProfileCleared reports if the "source_billing_profile" edge to the BillingProfile entity was cleared.
func (m *BillingInvoiceMutation) SourceBillingProfileCleared() bool {
	return m.clearedsource_billing_profile
}

// SourceBillingProfileIDs returns the "source_billing_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceBillingProfileID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) SourceBillingProfileIDs() (ids []string) {
	if id := m.source_billing_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceBillingProfile resets all changes to the "source_billing_profile" edge.
func (m *BillingInvoiceMutation) ResetSourceBillingProfile() {
	m.source_billing_profile = nil
	m.clearedsource_billing_profile = false
}

// SetBillingWorkflowConfigID sets the "billing_workflow_config" edge to the BillingWorkflowConfig entity by id.
func (m *BillingInvoiceMutation) SetBillingWorkflowConfigID(id string) {
	m.billing_workflow_config = &id
}

// ClearBillingWorkflowConfig clears the "billing_workflow_config" edge to the BillingWorkflowConfig entity.
func (m *BillingInvoiceMutation) ClearBillingWorkflowConfig() {
	m.clearedbilling_workflow_config = true
	m.clearedFields[billinginvoice.FieldWorkflowConfigID] = struct{}{}
}

// BillingWorkflowConfigCleared reports if the "billing_workflow_config" edge to the BillingWorkflowConfig entity was cleared.
func (m *BillingInvoiceMutation) BillingWorkflowConfigCleared() bool {
	return m.clearedbilling_workflow_config
}

// BillingWorkflowConfigID returns the "billing_workflow_config" edge ID in the mutation.
func (m *BillingInvoiceMutation) BillingWorkflowConfigID() (id string, exists bool) {
	if m.billing_workflow_config != nil {
		return *m.billing_workflow_config, true
	}
	return
}

// BillingWorkflowConfigIDs returns the "billing_workflow_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingWorkflowConfigID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) BillingWorkflowConfigIDs() (ids []string) {
	if id := m.billing_workflow_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingWorkflowConfig resets all changes to the "billing_workflow_config" edge.
func (m *BillingInvoiceMutation) ResetBillingWorkflowConfig() {
	m.billing_workflow_config = nil
	m.clearedbilling_workflow_config = false
}

// AddBillingInvoiceLineIDs adds the "billing_invoice_lines" edge to the BillingInvoiceLine entity by ids.
func (m *BillingInvoiceMutation) AddBillingInvoiceLineIDs(ids ...string) {
	if m.billing_invoice_lines == nil {
		m.billing_invoice_lines = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_lines[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoiceLines clears the "billing_invoice_lines" edge to the BillingInvoiceLine entity.
func (m *BillingInvoiceMutation) ClearBillingInvoiceLines() {
	m.clearedbilling_invoice_lines = true
}

// BillingInvoiceLinesCleared reports if the "billing_invoice_lines" edge to the BillingInvoiceLine entity was cleared.
func (m *BillingInvoiceMutation) BillingInvoiceLinesCleared() bool {
	return m.clearedbilling_invoice_lines
}

// RemoveBillingInvoiceLineIDs removes the "billing_invoice_lines" edge to the BillingInvoiceLine entity by IDs.
func (m *BillingInvoiceMutation) RemoveBillingInvoiceLineIDs(ids ...string) {
	if m.removedbilling_invoice_lines == nil {
		m.removedbilling_invoice_lines = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_lines, ids[i])
		m.removedbilling_invoice_lines[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoiceLines returns the removed IDs of the "billing_invoice_lines" edge to the BillingInvoiceLine entity.
func (m *BillingInvoiceMutation) RemovedBillingInvoiceLinesIDs() (ids []string) {
	for id := range m.removedbilling_invoice_lines {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceLinesIDs returns the "billing_invoice_lines" edge IDs in the mutation.
func (m *BillingInvoiceMutation) BillingInvoiceLinesIDs() (ids []string) {
	for id := range m.billing_invoice_lines {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoiceLines resets all changes to the "billing_invoice_lines" edge.
func (m *BillingInvoiceMutation) ResetBillingInvoiceLines() {
	m.billing_invoice_lines = nil
	m.clearedbilling_invoice_lines = false
	m.removedbilling_invoice_lines = nil
}

// AddBillingInvoiceValidationIssueIDs adds the "billing_invoice_validation_issues" edge to the BillingInvoiceValidationIssue entity by ids.
func (m *BillingInvoiceMutation) AddBillingInvoiceValidationIssueIDs(ids ...string) {
	if m.billing_invoice_validation_issues == nil {
		m.billing_invoice_validation_issues = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_validation_issues[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoiceValidationIssues clears the "billing_invoice_validation_issues" edge to the BillingInvoiceValidationIssue entity.
func (m *BillingInvoiceMutation) ClearBillingInvoiceValidationIssues() {
	m.clearedbilling_invoice_validation_issues = true
}

// BillingInvoiceValidationIssuesCleared reports if the "billing_invoice_validation_issues" edge to the BillingInvoiceValidationIssue entity was cleared.
func (m *BillingInvoiceMutation) BillingInvoiceValidationIssuesCleared() bool {
	return m.clearedbilling_invoice_validation_issues
}

// RemoveBillingInvoiceValidationIssueIDs removes the "billing_invoice_validation_issues" edge to the BillingInvoiceValidationIssue entity by IDs.
func (m *BillingInvoiceMutation) RemoveBillingInvoiceValidationIssueIDs(ids ...string) {
	if m.removedbilling_invoice_validation_issues == nil {
		m.removedbilling_invoice_validation_issues = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_validation_issues, ids[i])
		m.removedbilling_invoice_validation_issues[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoiceValidationIssues returns the removed IDs of the "billing_invoice_validation_issues" edge to the BillingInvoiceValidationIssue entity.
func (m *BillingInvoiceMutation) RemovedBillingInvoiceValidationIssuesIDs() (ids []string) {
	for id := range m.removedbilling_invoice_validation_issues {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceValidationIssuesIDs returns the "billing_invoice_validation_issues" edge IDs in the mutation.
func (m *BillingInvoiceMutation) BillingInvoiceValidationIssuesIDs() (ids []string) {
	for id := range m.billing_invoice_validation_issues {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoiceValidationIssues resets all changes to the "billing_invoice_validation_issues" edge.
func (m *BillingInvoiceMutation) ResetBillingInvoiceValidationIssues() {
	m.billing_invoice_validation_issues = nil
	m.clearedbilling_invoice_validation_issues = false
	m.removedbilling_invoice_validation_issues = nil
}

// SetBillingInvoiceCustomerID sets the "billing_invoice_customer" edge to the Customer entity by id.
func (m *BillingInvoiceMutation) SetBillingInvoiceCustomerID(id string) {
	m.billing_invoice_customer = &id
}

// ClearBillingInvoiceCustomer clears the "billing_invoice_customer" edge to the Customer entity.
func (m *BillingInvoiceMutation) ClearBillingInvoiceCustomer() {
	m.clearedbilling_invoice_customer = true
	m.clearedFields[billinginvoice.FieldCustomerID] = struct{}{}
}

// BillingInvoiceCustomerCleared reports if the "billing_invoice_customer" edge to the Customer entity was cleared.
func (m *BillingInvoiceMutation) BillingInvoiceCustomerCleared() bool {
	return m.clearedbilling_invoice_customer
}

// BillingInvoiceCustomerID returns the "billing_invoice_customer" edge ID in the mutation.
func (m *BillingInvoiceMutation) BillingInvoiceCustomerID() (id string, exists bool) {
	if m.billing_invoice_customer != nil {
		return *m.billing_invoice_customer, true
	}
	return
}

// BillingInvoiceCustomerIDs returns the "billing_invoice_customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoiceCustomerID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) BillingInvoiceCustomerIDs() (ids []string) {
	if id := m.billing_invoice_customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoiceCustomer resets all changes to the "billing_invoice_customer" edge.
func (m *BillingInvoiceMutation) ResetBillingInvoiceCustomer() {
	m.billing_invoice_customer = nil
	m.clearedbilling_invoice_customer = false
}

// ClearTaxApp clears the "tax_app" edge to the App entity.
func (m *BillingInvoiceMutation) ClearTaxApp() {
	m.clearedtax_app = true
	m.clearedFields[billinginvoice.FieldTaxAppID] = struct{}{}
}

// TaxAppCleared reports if the "tax_app" edge to the App entity was cleared.
func (m *BillingInvoiceMutation) TaxAppCleared() bool {
	return m.clearedtax_app
}

// TaxAppIDs returns the "tax_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaxAppID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) TaxAppIDs() (ids []string) {
	if id := m.tax_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaxApp resets all changes to the "tax_app" edge.
func (m *BillingInvoiceMutation) ResetTaxApp() {
	m.tax_app = nil
	m.clearedtax_app = false
}

// ClearInvoicingApp clears the "invoicing_app" edge to the App entity.
func (m *BillingInvoiceMutation) ClearInvoicingApp() {
	m.clearedinvoicing_app = true
	m.clearedFields[billinginvoice.FieldInvoicingAppID] = struct{}{}
}

// InvoicingAppCleared reports if the "invoicing_app" edge to the App entity was cleared.
func (m *BillingInvoiceMutation) InvoicingAppCleared() bool {
	return m.clearedinvoicing_app
}

// InvoicingAppIDs returns the "invoicing_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoicingAppID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) InvoicingAppIDs() (ids []string) {
	if id := m.invoicing_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoicingApp resets all changes to the "invoicing_app" edge.
func (m *BillingInvoiceMutation) ResetInvoicingApp() {
	m.invoicing_app = nil
	m.clearedinvoicing_app = false
}

// ClearPaymentApp clears the "payment_app" edge to the App entity.
func (m *BillingInvoiceMutation) ClearPaymentApp() {
	m.clearedpayment_app = true
	m.clearedFields[billinginvoice.FieldPaymentAppID] = struct{}{}
}

// PaymentAppCleared reports if the "payment_app" edge to the App entity was cleared.
func (m *BillingInvoiceMutation) PaymentAppCleared() bool {
	return m.clearedpayment_app
}

// PaymentAppIDs returns the "payment_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentAppID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) PaymentAppIDs() (ids []string) {
	if id := m.payment_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentApp resets all changes to the "payment_app" edge.
func (m *BillingInvoiceMutation) ResetPaymentApp() {
	m.payment_app = nil
	m.clearedpayment_app = false
}

// Where appends a list predicates to the BillingInvoiceMutation builder.
func (m *BillingInvoiceMutation) Where(ps ...predicate.BillingInvoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoice).
func (m *BillingInvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceMutation) Fields() []string {
	fields := make([]string, 0, 40)
	if m.namespace != nil {
		fields = append(fields, billinginvoice.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, billinginvoice.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, billinginvoice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billinginvoice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billinginvoice.FieldDeletedAt)
	}
	if m.supplier_address_country != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressCountry)
	}
	if m.supplier_address_postal_code != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressPostalCode)
	}
	if m.supplier_address_state != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressState)
	}
	if m.supplier_address_city != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressCity)
	}
	if m.supplier_address_line1 != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressLine1)
	}
	if m.supplier_address_line2 != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressLine2)
	}
	if m.supplier_address_phone_number != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressPhoneNumber)
	}
	if m.customer_address_country != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressCountry)
	}
	if m.customer_address_postal_code != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressPostalCode)
	}
	if m.customer_address_state != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressState)
	}
	if m.customer_address_city != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressCity)
	}
	if m.customer_address_line1 != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressLine1)
	}
	if m.customer_address_line2 != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressLine2)
	}
	if m.customer_address_phone_number != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressPhoneNumber)
	}
	if m.supplier_name != nil {
		fields = append(fields, billinginvoice.FieldSupplierName)
	}
	if m.supplier_tax_code != nil {
		fields = append(fields, billinginvoice.FieldSupplierTaxCode)
	}
	if m.customer_name != nil {
		fields = append(fields, billinginvoice.FieldCustomerName)
	}
	if m.customer_timezone != nil {
		fields = append(fields, billinginvoice.FieldCustomerTimezone)
	}
	if m.number != nil {
		fields = append(fields, billinginvoice.FieldNumber)
	}
	if m._type != nil {
		fields = append(fields, billinginvoice.FieldType)
	}
	if m.description != nil {
		fields = append(fields, billinginvoice.FieldDescription)
	}
	if m.billing_invoice_customer != nil {
		fields = append(fields, billinginvoice.FieldCustomerID)
	}
	if m.source_billing_profile != nil {
		fields = append(fields, billinginvoice.FieldSourceBillingProfileID)
	}
	if m.voided_at != nil {
		fields = append(fields, billinginvoice.FieldVoidedAt)
	}
	if m.issued_at != nil {
		fields = append(fields, billinginvoice.FieldIssuedAt)
	}
	if m.draft_until != nil {
		fields = append(fields, billinginvoice.FieldDraftUntil)
	}
	if m.currency != nil {
		fields = append(fields, billinginvoice.FieldCurrency)
	}
	if m.due_at != nil {
		fields = append(fields, billinginvoice.FieldDueAt)
	}
	if m.status != nil {
		fields = append(fields, billinginvoice.FieldStatus)
	}
	if m.billing_workflow_config != nil {
		fields = append(fields, billinginvoice.FieldWorkflowConfigID)
	}
	if m.tax_app != nil {
		fields = append(fields, billinginvoice.FieldTaxAppID)
	}
	if m.invoicing_app != nil {
		fields = append(fields, billinginvoice.FieldInvoicingAppID)
	}
	if m.payment_app != nil {
		fields = append(fields, billinginvoice.FieldPaymentAppID)
	}
	if m.period_start != nil {
		fields = append(fields, billinginvoice.FieldPeriodStart)
	}
	if m.period_end != nil {
		fields = append(fields, billinginvoice.FieldPeriodEnd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoice.FieldNamespace:
		return m.Namespace()
	case billinginvoice.FieldMetadata:
		return m.Metadata()
	case billinginvoice.FieldCreatedAt:
		return m.CreatedAt()
	case billinginvoice.FieldUpdatedAt:
		return m.UpdatedAt()
	case billinginvoice.FieldDeletedAt:
		return m.DeletedAt()
	case billinginvoice.FieldSupplierAddressCountry:
		return m.SupplierAddressCountry()
	case billinginvoice.FieldSupplierAddressPostalCode:
		return m.SupplierAddressPostalCode()
	case billinginvoice.FieldSupplierAddressState:
		return m.SupplierAddressState()
	case billinginvoice.FieldSupplierAddressCity:
		return m.SupplierAddressCity()
	case billinginvoice.FieldSupplierAddressLine1:
		return m.SupplierAddressLine1()
	case billinginvoice.FieldSupplierAddressLine2:
		return m.SupplierAddressLine2()
	case billinginvoice.FieldSupplierAddressPhoneNumber:
		return m.SupplierAddressPhoneNumber()
	case billinginvoice.FieldCustomerAddressCountry:
		return m.CustomerAddressCountry()
	case billinginvoice.FieldCustomerAddressPostalCode:
		return m.CustomerAddressPostalCode()
	case billinginvoice.FieldCustomerAddressState:
		return m.CustomerAddressState()
	case billinginvoice.FieldCustomerAddressCity:
		return m.CustomerAddressCity()
	case billinginvoice.FieldCustomerAddressLine1:
		return m.CustomerAddressLine1()
	case billinginvoice.FieldCustomerAddressLine2:
		return m.CustomerAddressLine2()
	case billinginvoice.FieldCustomerAddressPhoneNumber:
		return m.CustomerAddressPhoneNumber()
	case billinginvoice.FieldSupplierName:
		return m.SupplierName()
	case billinginvoice.FieldSupplierTaxCode:
		return m.SupplierTaxCode()
	case billinginvoice.FieldCustomerName:
		return m.CustomerName()
	case billinginvoice.FieldCustomerTimezone:
		return m.CustomerTimezone()
	case billinginvoice.FieldNumber:
		return m.Number()
	case billinginvoice.FieldType:
		return m.GetType()
	case billinginvoice.FieldDescription:
		return m.Description()
	case billinginvoice.FieldCustomerID:
		return m.CustomerID()
	case billinginvoice.FieldSourceBillingProfileID:
		return m.SourceBillingProfileID()
	case billinginvoice.FieldVoidedAt:
		return m.VoidedAt()
	case billinginvoice.FieldIssuedAt:
		return m.IssuedAt()
	case billinginvoice.FieldDraftUntil:
		return m.DraftUntil()
	case billinginvoice.FieldCurrency:
		return m.Currency()
	case billinginvoice.FieldDueAt:
		return m.DueAt()
	case billinginvoice.FieldStatus:
		return m.Status()
	case billinginvoice.FieldWorkflowConfigID:
		return m.WorkflowConfigID()
	case billinginvoice.FieldTaxAppID:
		return m.TaxAppID()
	case billinginvoice.FieldInvoicingAppID:
		return m.InvoicingAppID()
	case billinginvoice.FieldPaymentAppID:
		return m.PaymentAppID()
	case billinginvoice.FieldPeriodStart:
		return m.PeriodStart()
	case billinginvoice.FieldPeriodEnd:
		return m.PeriodEnd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoice.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoice.FieldMetadata:
		return m.OldMetadata(ctx)
	case billinginvoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billinginvoice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billinginvoice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billinginvoice.FieldSupplierAddressCountry:
		return m.OldSupplierAddressCountry(ctx)
	case billinginvoice.FieldSupplierAddressPostalCode:
		return m.OldSupplierAddressPostalCode(ctx)
	case billinginvoice.FieldSupplierAddressState:
		return m.OldSupplierAddressState(ctx)
	case billinginvoice.FieldSupplierAddressCity:
		return m.OldSupplierAddressCity(ctx)
	case billinginvoice.FieldSupplierAddressLine1:
		return m.OldSupplierAddressLine1(ctx)
	case billinginvoice.FieldSupplierAddressLine2:
		return m.OldSupplierAddressLine2(ctx)
	case billinginvoice.FieldSupplierAddressPhoneNumber:
		return m.OldSupplierAddressPhoneNumber(ctx)
	case billinginvoice.FieldCustomerAddressCountry:
		return m.OldCustomerAddressCountry(ctx)
	case billinginvoice.FieldCustomerAddressPostalCode:
		return m.OldCustomerAddressPostalCode(ctx)
	case billinginvoice.FieldCustomerAddressState:
		return m.OldCustomerAddressState(ctx)
	case billinginvoice.FieldCustomerAddressCity:
		return m.OldCustomerAddressCity(ctx)
	case billinginvoice.FieldCustomerAddressLine1:
		return m.OldCustomerAddressLine1(ctx)
	case billinginvoice.FieldCustomerAddressLine2:
		return m.OldCustomerAddressLine2(ctx)
	case billinginvoice.FieldCustomerAddressPhoneNumber:
		return m.OldCustomerAddressPhoneNumber(ctx)
	case billinginvoice.FieldSupplierName:
		return m.OldSupplierName(ctx)
	case billinginvoice.FieldSupplierTaxCode:
		return m.OldSupplierTaxCode(ctx)
	case billinginvoice.FieldCustomerName:
		return m.OldCustomerName(ctx)
	case billinginvoice.FieldCustomerTimezone:
		return m.OldCustomerTimezone(ctx)
	case billinginvoice.FieldNumber:
		return m.OldNumber(ctx)
	case billinginvoice.FieldType:
		return m.OldType(ctx)
	case billinginvoice.FieldDescription:
		return m.OldDescription(ctx)
	case billinginvoice.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case billinginvoice.FieldSourceBillingProfileID:
		return m.OldSourceBillingProfileID(ctx)
	case billinginvoice.FieldVoidedAt:
		return m.OldVoidedAt(ctx)
	case billinginvoice.FieldIssuedAt:
		return m.OldIssuedAt(ctx)
	case billinginvoice.FieldDraftUntil:
		return m.OldDraftUntil(ctx)
	case billinginvoice.FieldCurrency:
		return m.OldCurrency(ctx)
	case billinginvoice.FieldDueAt:
		return m.OldDueAt(ctx)
	case billinginvoice.FieldStatus:
		return m.OldStatus(ctx)
	case billinginvoice.FieldWorkflowConfigID:
		return m.OldWorkflowConfigID(ctx)
	case billinginvoice.FieldTaxAppID:
		return m.OldTaxAppID(ctx)
	case billinginvoice.FieldInvoicingAppID:
		return m.OldInvoicingAppID(ctx)
	case billinginvoice.FieldPaymentAppID:
		return m.OldPaymentAppID(ctx)
	case billinginvoice.FieldPeriodStart:
		return m.OldPeriodStart(ctx)
	case billinginvoice.FieldPeriodEnd:
		return m.OldPeriodEnd(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoice.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoice.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case billinginvoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billinginvoice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billinginvoice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billinginvoice.FieldSupplierAddressCountry:
		v, ok := value.(models.CountryCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressCountry(v)
		return nil
	case billinginvoice.FieldSupplierAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressPostalCode(v)
		return nil
	case billinginvoice.FieldSupplierAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressState(v)
		return nil
	case billinginvoice.FieldSupplierAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressCity(v)
		return nil
	case billinginvoice.FieldSupplierAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressLine1(v)
		return nil
	case billinginvoice.FieldSupplierAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressLine2(v)
		return nil
	case billinginvoice.FieldSupplierAddressPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressPhoneNumber(v)
		return nil
	case billinginvoice.FieldCustomerAddressCountry:
		v, ok := value.(models.CountryCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressCountry(v)
		return nil
	case billinginvoice.FieldCustomerAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressPostalCode(v)
		return nil
	case billinginvoice.FieldCustomerAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressState(v)
		return nil
	case billinginvoice.FieldCustomerAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressCity(v)
		return nil
	case billinginvoice.FieldCustomerAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressLine1(v)
		return nil
	case billinginvoice.FieldCustomerAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressLine2(v)
		return nil
	case billinginvoice.FieldCustomerAddressPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressPhoneNumber(v)
		return nil
	case billinginvoice.FieldSupplierName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierName(v)
		return nil
	case billinginvoice.FieldSupplierTaxCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierTaxCode(v)
		return nil
	case billinginvoice.FieldCustomerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerName(v)
		return nil
	case billinginvoice.FieldCustomerTimezone:
		v, ok := value.(timezone.Timezone)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerTimezone(v)
		return nil
	case billinginvoice.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case billinginvoice.FieldType:
		v, ok := value.(billingentity.InvoiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case billinginvoice.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case billinginvoice.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case billinginvoice.FieldSourceBillingProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceBillingProfileID(v)
		return nil
	case billinginvoice.FieldVoidedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidedAt(v)
		return nil
	case billinginvoice.FieldIssuedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedAt(v)
		return nil
	case billinginvoice.FieldDraftUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDraftUntil(v)
		return nil
	case billinginvoice.FieldCurrency:
		v, ok := value.(currencyx.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case billinginvoice.FieldDueAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueAt(v)
		return nil
	case billinginvoice.FieldStatus:
		v, ok := value.(billingentity.InvoiceStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case billinginvoice.FieldWorkflowConfigID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowConfigID(v)
		return nil
	case billinginvoice.FieldTaxAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAppID(v)
		return nil
	case billinginvoice.FieldInvoicingAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingAppID(v)
		return nil
	case billinginvoice.FieldPaymentAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentAppID(v)
		return nil
	case billinginvoice.FieldPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodStart(v)
		return nil
	case billinginvoice.FieldPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodEnd(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoice.FieldMetadata) {
		fields = append(fields, billinginvoice.FieldMetadata)
	}
	if m.FieldCleared(billinginvoice.FieldDeletedAt) {
		fields = append(fields, billinginvoice.FieldDeletedAt)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressCountry) {
		fields = append(fields, billinginvoice.FieldSupplierAddressCountry)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressPostalCode) {
		fields = append(fields, billinginvoice.FieldSupplierAddressPostalCode)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressState) {
		fields = append(fields, billinginvoice.FieldSupplierAddressState)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressCity) {
		fields = append(fields, billinginvoice.FieldSupplierAddressCity)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressLine1) {
		fields = append(fields, billinginvoice.FieldSupplierAddressLine1)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressLine2) {
		fields = append(fields, billinginvoice.FieldSupplierAddressLine2)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressPhoneNumber) {
		fields = append(fields, billinginvoice.FieldSupplierAddressPhoneNumber)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressCountry) {
		fields = append(fields, billinginvoice.FieldCustomerAddressCountry)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressPostalCode) {
		fields = append(fields, billinginvoice.FieldCustomerAddressPostalCode)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressState) {
		fields = append(fields, billinginvoice.FieldCustomerAddressState)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressCity) {
		fields = append(fields, billinginvoice.FieldCustomerAddressCity)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressLine1) {
		fields = append(fields, billinginvoice.FieldCustomerAddressLine1)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressLine2) {
		fields = append(fields, billinginvoice.FieldCustomerAddressLine2)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressPhoneNumber) {
		fields = append(fields, billinginvoice.FieldCustomerAddressPhoneNumber)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierTaxCode) {
		fields = append(fields, billinginvoice.FieldSupplierTaxCode)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerTimezone) {
		fields = append(fields, billinginvoice.FieldCustomerTimezone)
	}
	if m.FieldCleared(billinginvoice.FieldNumber) {
		fields = append(fields, billinginvoice.FieldNumber)
	}
	if m.FieldCleared(billinginvoice.FieldDescription) {
		fields = append(fields, billinginvoice.FieldDescription)
	}
	if m.FieldCleared(billinginvoice.FieldVoidedAt) {
		fields = append(fields, billinginvoice.FieldVoidedAt)
	}
	if m.FieldCleared(billinginvoice.FieldIssuedAt) {
		fields = append(fields, billinginvoice.FieldIssuedAt)
	}
	if m.FieldCleared(billinginvoice.FieldDraftUntil) {
		fields = append(fields, billinginvoice.FieldDraftUntil)
	}
	if m.FieldCleared(billinginvoice.FieldDueAt) {
		fields = append(fields, billinginvoice.FieldDueAt)
	}
	if m.FieldCleared(billinginvoice.FieldPeriodStart) {
		fields = append(fields, billinginvoice.FieldPeriodStart)
	}
	if m.FieldCleared(billinginvoice.FieldPeriodEnd) {
		fields = append(fields, billinginvoice.FieldPeriodEnd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceMutation) ClearField(name string) error {
	switch name {
	case billinginvoice.FieldMetadata:
		m.ClearMetadata()
		return nil
	case billinginvoice.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billinginvoice.FieldSupplierAddressCountry:
		m.ClearSupplierAddressCountry()
		return nil
	case billinginvoice.FieldSupplierAddressPostalCode:
		m.ClearSupplierAddressPostalCode()
		return nil
	case billinginvoice.FieldSupplierAddressState:
		m.ClearSupplierAddressState()
		return nil
	case billinginvoice.FieldSupplierAddressCity:
		m.ClearSupplierAddressCity()
		return nil
	case billinginvoice.FieldSupplierAddressLine1:
		m.ClearSupplierAddressLine1()
		return nil
	case billinginvoice.FieldSupplierAddressLine2:
		m.ClearSupplierAddressLine2()
		return nil
	case billinginvoice.FieldSupplierAddressPhoneNumber:
		m.ClearSupplierAddressPhoneNumber()
		return nil
	case billinginvoice.FieldCustomerAddressCountry:
		m.ClearCustomerAddressCountry()
		return nil
	case billinginvoice.FieldCustomerAddressPostalCode:
		m.ClearCustomerAddressPostalCode()
		return nil
	case billinginvoice.FieldCustomerAddressState:
		m.ClearCustomerAddressState()
		return nil
	case billinginvoice.FieldCustomerAddressCity:
		m.ClearCustomerAddressCity()
		return nil
	case billinginvoice.FieldCustomerAddressLine1:
		m.ClearCustomerAddressLine1()
		return nil
	case billinginvoice.FieldCustomerAddressLine2:
		m.ClearCustomerAddressLine2()
		return nil
	case billinginvoice.FieldCustomerAddressPhoneNumber:
		m.ClearCustomerAddressPhoneNumber()
		return nil
	case billinginvoice.FieldSupplierTaxCode:
		m.ClearSupplierTaxCode()
		return nil
	case billinginvoice.FieldCustomerTimezone:
		m.ClearCustomerTimezone()
		return nil
	case billinginvoice.FieldNumber:
		m.ClearNumber()
		return nil
	case billinginvoice.FieldDescription:
		m.ClearDescription()
		return nil
	case billinginvoice.FieldVoidedAt:
		m.ClearVoidedAt()
		return nil
	case billinginvoice.FieldIssuedAt:
		m.ClearIssuedAt()
		return nil
	case billinginvoice.FieldDraftUntil:
		m.ClearDraftUntil()
		return nil
	case billinginvoice.FieldDueAt:
		m.ClearDueAt()
		return nil
	case billinginvoice.FieldPeriodStart:
		m.ClearPeriodStart()
		return nil
	case billinginvoice.FieldPeriodEnd:
		m.ClearPeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceMutation) ResetField(name string) error {
	switch name {
	case billinginvoice.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoice.FieldMetadata:
		m.ResetMetadata()
		return nil
	case billinginvoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billinginvoice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billinginvoice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billinginvoice.FieldSupplierAddressCountry:
		m.ResetSupplierAddressCountry()
		return nil
	case billinginvoice.FieldSupplierAddressPostalCode:
		m.ResetSupplierAddressPostalCode()
		return nil
	case billinginvoice.FieldSupplierAddressState:
		m.ResetSupplierAddressState()
		return nil
	case billinginvoice.FieldSupplierAddressCity:
		m.ResetSupplierAddressCity()
		return nil
	case billinginvoice.FieldSupplierAddressLine1:
		m.ResetSupplierAddressLine1()
		return nil
	case billinginvoice.FieldSupplierAddressLine2:
		m.ResetSupplierAddressLine2()
		return nil
	case billinginvoice.FieldSupplierAddressPhoneNumber:
		m.ResetSupplierAddressPhoneNumber()
		return nil
	case billinginvoice.FieldCustomerAddressCountry:
		m.ResetCustomerAddressCountry()
		return nil
	case billinginvoice.FieldCustomerAddressPostalCode:
		m.ResetCustomerAddressPostalCode()
		return nil
	case billinginvoice.FieldCustomerAddressState:
		m.ResetCustomerAddressState()
		return nil
	case billinginvoice.FieldCustomerAddressCity:
		m.ResetCustomerAddressCity()
		return nil
	case billinginvoice.FieldCustomerAddressLine1:
		m.ResetCustomerAddressLine1()
		return nil
	case billinginvoice.FieldCustomerAddressLine2:
		m.ResetCustomerAddressLine2()
		return nil
	case billinginvoice.FieldCustomerAddressPhoneNumber:
		m.ResetCustomerAddressPhoneNumber()
		return nil
	case billinginvoice.FieldSupplierName:
		m.ResetSupplierName()
		return nil
	case billinginvoice.FieldSupplierTaxCode:
		m.ResetSupplierTaxCode()
		return nil
	case billinginvoice.FieldCustomerName:
		m.ResetCustomerName()
		return nil
	case billinginvoice.FieldCustomerTimezone:
		m.ResetCustomerTimezone()
		return nil
	case billinginvoice.FieldNumber:
		m.ResetNumber()
		return nil
	case billinginvoice.FieldType:
		m.ResetType()
		return nil
	case billinginvoice.FieldDescription:
		m.ResetDescription()
		return nil
	case billinginvoice.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case billinginvoice.FieldSourceBillingProfileID:
		m.ResetSourceBillingProfileID()
		return nil
	case billinginvoice.FieldVoidedAt:
		m.ResetVoidedAt()
		return nil
	case billinginvoice.FieldIssuedAt:
		m.ResetIssuedAt()
		return nil
	case billinginvoice.FieldDraftUntil:
		m.ResetDraftUntil()
		return nil
	case billinginvoice.FieldCurrency:
		m.ResetCurrency()
		return nil
	case billinginvoice.FieldDueAt:
		m.ResetDueAt()
		return nil
	case billinginvoice.FieldStatus:
		m.ResetStatus()
		return nil
	case billinginvoice.FieldWorkflowConfigID:
		m.ResetWorkflowConfigID()
		return nil
	case billinginvoice.FieldTaxAppID:
		m.ResetTaxAppID()
		return nil
	case billinginvoice.FieldInvoicingAppID:
		m.ResetInvoicingAppID()
		return nil
	case billinginvoice.FieldPaymentAppID:
		m.ResetPaymentAppID()
		return nil
	case billinginvoice.FieldPeriodStart:
		m.ResetPeriodStart()
		return nil
	case billinginvoice.FieldPeriodEnd:
		m.ResetPeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.source_billing_profile != nil {
		edges = append(edges, billinginvoice.EdgeSourceBillingProfile)
	}
	if m.billing_workflow_config != nil {
		edges = append(edges, billinginvoice.EdgeBillingWorkflowConfig)
	}
	if m.billing_invoice_lines != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceLines)
	}
	if m.billing_invoice_validation_issues != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceValidationIssues)
	}
	if m.billing_invoice_customer != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceCustomer)
	}
	if m.tax_app != nil {
		edges = append(edges, billinginvoice.EdgeTaxApp)
	}
	if m.invoicing_app != nil {
		edges = append(edges, billinginvoice.EdgeInvoicingApp)
	}
	if m.payment_app != nil {
		edges = append(edges, billinginvoice.EdgePaymentApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billinginvoice.EdgeSourceBillingProfile:
		if id := m.source_billing_profile; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgeBillingWorkflowConfig:
		if id := m.billing_workflow_config; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgeBillingInvoiceLines:
		ids := make([]ent.Value, 0, len(m.billing_invoice_lines))
		for id := range m.billing_invoice_lines {
			ids = append(ids, id)
		}
		return ids
	case billinginvoice.EdgeBillingInvoiceValidationIssues:
		ids := make([]ent.Value, 0, len(m.billing_invoice_validation_issues))
		for id := range m.billing_invoice_validation_issues {
			ids = append(ids, id)
		}
		return ids
	case billinginvoice.EdgeBillingInvoiceCustomer:
		if id := m.billing_invoice_customer; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgeTaxApp:
		if id := m.tax_app; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgeInvoicingApp:
		if id := m.invoicing_app; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgePaymentApp:
		if id := m.payment_app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedbilling_invoice_lines != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceLines)
	}
	if m.removedbilling_invoice_validation_issues != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceValidationIssues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billinginvoice.EdgeBillingInvoiceLines:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_lines))
		for id := range m.removedbilling_invoice_lines {
			ids = append(ids, id)
		}
		return ids
	case billinginvoice.EdgeBillingInvoiceValidationIssues:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_validation_issues))
		for id := range m.removedbilling_invoice_validation_issues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedsource_billing_profile {
		edges = append(edges, billinginvoice.EdgeSourceBillingProfile)
	}
	if m.clearedbilling_workflow_config {
		edges = append(edges, billinginvoice.EdgeBillingWorkflowConfig)
	}
	if m.clearedbilling_invoice_lines {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceLines)
	}
	if m.clearedbilling_invoice_validation_issues {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceValidationIssues)
	}
	if m.clearedbilling_invoice_customer {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceCustomer)
	}
	if m.clearedtax_app {
		edges = append(edges, billinginvoice.EdgeTaxApp)
	}
	if m.clearedinvoicing_app {
		edges = append(edges, billinginvoice.EdgeInvoicingApp)
	}
	if m.clearedpayment_app {
		edges = append(edges, billinginvoice.EdgePaymentApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case billinginvoice.EdgeSourceBillingProfile:
		return m.clearedsource_billing_profile
	case billinginvoice.EdgeBillingWorkflowConfig:
		return m.clearedbilling_workflow_config
	case billinginvoice.EdgeBillingInvoiceLines:
		return m.clearedbilling_invoice_lines
	case billinginvoice.EdgeBillingInvoiceValidationIssues:
		return m.clearedbilling_invoice_validation_issues
	case billinginvoice.EdgeBillingInvoiceCustomer:
		return m.clearedbilling_invoice_customer
	case billinginvoice.EdgeTaxApp:
		return m.clearedtax_app
	case billinginvoice.EdgeInvoicingApp:
		return m.clearedinvoicing_app
	case billinginvoice.EdgePaymentApp:
		return m.clearedpayment_app
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceMutation) ClearEdge(name string) error {
	switch name {
	case billinginvoice.EdgeSourceBillingProfile:
		m.ClearSourceBillingProfile()
		return nil
	case billinginvoice.EdgeBillingWorkflowConfig:
		m.ClearBillingWorkflowConfig()
		return nil
	case billinginvoice.EdgeBillingInvoiceCustomer:
		m.ClearBillingInvoiceCustomer()
		return nil
	case billinginvoice.EdgeTaxApp:
		m.ClearTaxApp()
		return nil
	case billinginvoice.EdgeInvoicingApp:
		m.ClearInvoicingApp()
		return nil
	case billinginvoice.EdgePaymentApp:
		m.ClearPaymentApp()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceMutation) ResetEdge(name string) error {
	switch name {
	case billinginvoice.EdgeSourceBillingProfile:
		m.ResetSourceBillingProfile()
		return nil
	case billinginvoice.EdgeBillingWorkflowConfig:
		m.ResetBillingWorkflowConfig()
		return nil
	case billinginvoice.EdgeBillingInvoiceLines:
		m.ResetBillingInvoiceLines()
		return nil
	case billinginvoice.EdgeBillingInvoiceValidationIssues:
		m.ResetBillingInvoiceValidationIssues()
		return nil
	case billinginvoice.EdgeBillingInvoiceCustomer:
		m.ResetBillingInvoiceCustomer()
		return nil
	case billinginvoice.EdgeTaxApp:
		m.ResetTaxApp()
		return nil
	case billinginvoice.EdgeInvoicingApp:
		m.ResetInvoicingApp()
		return nil
	case billinginvoice.EdgePaymentApp:
		m.ResetPaymentApp()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice edge %s", name)
}

// BillingInvoiceLineMutation represents an operation that mutates the BillingInvoiceLine nodes in the graph.
type BillingInvoiceLineMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *string
	namespace                           *string
	metadata                            *map[string]string
	created_at                          *time.Time
	updated_at                          *time.Time
	deleted_at                          *time.Time
	name                                *string
	description                         *string
	period_start                        *time.Time
	period_end                          *time.Time
	invoice_at                          *time.Time
	_type                               *billingentity.InvoiceLineType
	status                              *billingentity.InvoiceLineStatus
	currency                            *currencyx.Code
	quantity                            *alpacadecimal.Decimal
	tax_overrides                       **billingentity.TaxOverrides
	clearedFields                       map[string]struct{}
	billing_invoice                     *string
	clearedbilling_invoice              bool
	billing_invoice_manual_lines        *string
	clearedbilling_invoice_manual_lines bool
	done                                bool
	oldValue                            func(context.Context) (*BillingInvoiceLine, error)
	predicates                          []predicate.BillingInvoiceLine
}

var _ ent.Mutation = (*BillingInvoiceLineMutation)(nil)

// billinginvoicelineOption allows management of the mutation configuration using functional options.
type billinginvoicelineOption func(*BillingInvoiceLineMutation)

// newBillingInvoiceLineMutation creates new mutation for the BillingInvoiceLine entity.
func newBillingInvoiceLineMutation(c config, op Op, opts ...billinginvoicelineOption) *BillingInvoiceLineMutation {
	m := &BillingInvoiceLineMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoiceLine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceLineID sets the ID field of the mutation.
func withBillingInvoiceLineID(id string) billinginvoicelineOption {
	return func(m *BillingInvoiceLineMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoiceLine
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoiceLine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoiceLine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoiceLine sets the old BillingInvoiceLine of the mutation.
func withBillingInvoiceLine(node *BillingInvoiceLine) billinginvoicelineOption {
	return func(m *BillingInvoiceLineMutation) {
		m.oldValue = func(context.Context) (*BillingInvoiceLine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceLineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceLineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoiceLine entities.
func (m *BillingInvoiceLineMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceLineMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceLineMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoiceLine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceLineMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceLineMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceLineMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *BillingInvoiceLineMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *BillingInvoiceLineMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *BillingInvoiceLineMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[billinginvoiceline.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *BillingInvoiceLineMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, billinginvoiceline.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingInvoiceLineMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingInvoiceLineMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingInvoiceLineMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingInvoiceLineMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingInvoiceLineMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingInvoiceLineMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingInvoiceLineMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingInvoiceLineMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingInvoiceLineMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billinginvoiceline.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingInvoiceLineMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billinginvoiceline.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BillingInvoiceLineMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BillingInvoiceLineMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BillingInvoiceLineMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BillingInvoiceLineMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BillingInvoiceLineMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BillingInvoiceLineMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[billinginvoiceline.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BillingInvoiceLineMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, billinginvoiceline.FieldDescription)
}

// SetInvoiceID sets the "invoice_id" field.
func (m *BillingInvoiceLineMutation) SetInvoiceID(s string) {
	m.billing_invoice = &s
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *BillingInvoiceLineMutation) InvoiceID() (r string, exists bool) {
	v := m.billing_invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldInvoiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *BillingInvoiceLineMutation) ResetInvoiceID() {
	m.billing_invoice = nil
}

// SetPeriodStart sets the "period_start" field.
func (m *BillingInvoiceLineMutation) SetPeriodStart(t time.Time) {
	m.period_start = &t
}

// PeriodStart returns the value of the "period_start" field in the mutation.
func (m *BillingInvoiceLineMutation) PeriodStart() (r time.Time, exists bool) {
	v := m.period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodStart returns the old "period_start" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldPeriodStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodStart: %w", err)
	}
	return oldValue.PeriodStart, nil
}

// ResetPeriodStart resets all changes to the "period_start" field.
func (m *BillingInvoiceLineMutation) ResetPeriodStart() {
	m.period_start = nil
}

// SetPeriodEnd sets the "period_end" field.
func (m *BillingInvoiceLineMutation) SetPeriodEnd(t time.Time) {
	m.period_end = &t
}

// PeriodEnd returns the value of the "period_end" field in the mutation.
func (m *BillingInvoiceLineMutation) PeriodEnd() (r time.Time, exists bool) {
	v := m.period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodEnd returns the old "period_end" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldPeriodEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodEnd: %w", err)
	}
	return oldValue.PeriodEnd, nil
}

// ResetPeriodEnd resets all changes to the "period_end" field.
func (m *BillingInvoiceLineMutation) ResetPeriodEnd() {
	m.period_end = nil
}

// SetInvoiceAt sets the "invoice_at" field.
func (m *BillingInvoiceLineMutation) SetInvoiceAt(t time.Time) {
	m.invoice_at = &t
}

// InvoiceAt returns the value of the "invoice_at" field in the mutation.
func (m *BillingInvoiceLineMutation) InvoiceAt() (r time.Time, exists bool) {
	v := m.invoice_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceAt returns the old "invoice_at" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldInvoiceAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceAt: %w", err)
	}
	return oldValue.InvoiceAt, nil
}

// ResetInvoiceAt resets all changes to the "invoice_at" field.
func (m *BillingInvoiceLineMutation) ResetInvoiceAt() {
	m.invoice_at = nil
}

// SetType sets the "type" field.
func (m *BillingInvoiceLineMutation) SetType(blt billingentity.InvoiceLineType) {
	m._type = &blt
}

// GetType returns the value of the "type" field in the mutation.
func (m *BillingInvoiceLineMutation) GetType() (r billingentity.InvoiceLineType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldType(ctx context.Context) (v billingentity.InvoiceLineType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BillingInvoiceLineMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *BillingInvoiceLineMutation) SetStatus(bls billingentity.InvoiceLineStatus) {
	m.status = &bls
}

// Status returns the value of the "status" field in the mutation.
func (m *BillingInvoiceLineMutation) Status() (r billingentity.InvoiceLineStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldStatus(ctx context.Context) (v billingentity.InvoiceLineStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BillingInvoiceLineMutation) ResetStatus() {
	m.status = nil
}

// SetCurrency sets the "currency" field.
func (m *BillingInvoiceLineMutation) SetCurrency(c currencyx.Code) {
	m.currency = &c
}

// Currency returns the value of the "currency" field in the mutation.
func (m *BillingInvoiceLineMutation) Currency() (r currencyx.Code, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldCurrency(ctx context.Context) (v currencyx.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *BillingInvoiceLineMutation) ResetCurrency() {
	m.currency = nil
}

// SetQuantity sets the "quantity" field.
func (m *BillingInvoiceLineMutation) SetQuantity(a alpacadecimal.Decimal) {
	m.quantity = &a
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *BillingInvoiceLineMutation) Quantity() (r alpacadecimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldQuantity(ctx context.Context) (v *alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ClearQuantity clears the value of the "quantity" field.
func (m *BillingInvoiceLineMutation) ClearQuantity() {
	m.quantity = nil
	m.clearedFields[billinginvoiceline.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *BillingInvoiceLineMutation) ResetQuantity() {
	m.quantity = nil
	delete(m.clearedFields, billinginvoiceline.FieldQuantity)
}

// SetTaxOverrides sets the "tax_overrides" field.
func (m *BillingInvoiceLineMutation) SetTaxOverrides(bo *billingentity.TaxOverrides) {
	m.tax_overrides = &bo
}

// TaxOverrides returns the value of the "tax_overrides" field in the mutation.
func (m *BillingInvoiceLineMutation) TaxOverrides() (r *billingentity.TaxOverrides, exists bool) {
	v := m.tax_overrides
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxOverrides returns the old "tax_overrides" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldTaxOverrides(ctx context.Context) (v *billingentity.TaxOverrides, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxOverrides is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxOverrides requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxOverrides: %w", err)
	}
	return oldValue.TaxOverrides, nil
}

// ClearTaxOverrides clears the value of the "tax_overrides" field.
func (m *BillingInvoiceLineMutation) ClearTaxOverrides() {
	m.tax_overrides = nil
	m.clearedFields[billinginvoiceline.FieldTaxOverrides] = struct{}{}
}

// TaxOverridesCleared returns if the "tax_overrides" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) TaxOverridesCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldTaxOverrides]
	return ok
}

// ResetTaxOverrides resets all changes to the "tax_overrides" field.
func (m *BillingInvoiceLineMutation) ResetTaxOverrides() {
	m.tax_overrides = nil
	delete(m.clearedFields, billinginvoiceline.FieldTaxOverrides)
}

// SetBillingInvoiceID sets the "billing_invoice" edge to the BillingInvoice entity by id.
func (m *BillingInvoiceLineMutation) SetBillingInvoiceID(id string) {
	m.billing_invoice = &id
}

// ClearBillingInvoice clears the "billing_invoice" edge to the BillingInvoice entity.
func (m *BillingInvoiceLineMutation) ClearBillingInvoice() {
	m.clearedbilling_invoice = true
	m.clearedFields[billinginvoiceline.FieldInvoiceID] = struct{}{}
}

// BillingInvoiceCleared reports if the "billing_invoice" edge to the BillingInvoice entity was cleared.
func (m *BillingInvoiceLineMutation) BillingInvoiceCleared() bool {
	return m.clearedbilling_invoice
}

// BillingInvoiceID returns the "billing_invoice" edge ID in the mutation.
func (m *BillingInvoiceLineMutation) BillingInvoiceID() (id string, exists bool) {
	if m.billing_invoice != nil {
		return *m.billing_invoice, true
	}
	return
}

// BillingInvoiceIDs returns the "billing_invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoiceID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineMutation) BillingInvoiceIDs() (ids []string) {
	if id := m.billing_invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoice resets all changes to the "billing_invoice" edge.
func (m *BillingInvoiceLineMutation) ResetBillingInvoice() {
	m.billing_invoice = nil
	m.clearedbilling_invoice = false
}

// SetBillingInvoiceManualLinesID sets the "billing_invoice_manual_lines" edge to the BillingInvoiceManualLineConfig entity by id.
func (m *BillingInvoiceLineMutation) SetBillingInvoiceManualLinesID(id string) {
	m.billing_invoice_manual_lines = &id
}

// ClearBillingInvoiceManualLines clears the "billing_invoice_manual_lines" edge to the BillingInvoiceManualLineConfig entity.
func (m *BillingInvoiceLineMutation) ClearBillingInvoiceManualLines() {
	m.clearedbilling_invoice_manual_lines = true
}

// BillingInvoiceManualLinesCleared reports if the "billing_invoice_manual_lines" edge to the BillingInvoiceManualLineConfig entity was cleared.
func (m *BillingInvoiceLineMutation) BillingInvoiceManualLinesCleared() bool {
	return m.clearedbilling_invoice_manual_lines
}

// BillingInvoiceManualLinesID returns the "billing_invoice_manual_lines" edge ID in the mutation.
func (m *BillingInvoiceLineMutation) BillingInvoiceManualLinesID() (id string, exists bool) {
	if m.billing_invoice_manual_lines != nil {
		return *m.billing_invoice_manual_lines, true
	}
	return
}

// BillingInvoiceManualLinesIDs returns the "billing_invoice_manual_lines" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoiceManualLinesID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineMutation) BillingInvoiceManualLinesIDs() (ids []string) {
	if id := m.billing_invoice_manual_lines; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoiceManualLines resets all changes to the "billing_invoice_manual_lines" edge.
func (m *BillingInvoiceLineMutation) ResetBillingInvoiceManualLines() {
	m.billing_invoice_manual_lines = nil
	m.clearedbilling_invoice_manual_lines = false
}

// Where appends a list predicates to the BillingInvoiceLineMutation builder.
func (m *BillingInvoiceLineMutation) Where(ps ...predicate.BillingInvoiceLine) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceLineMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceLineMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoiceLine, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceLineMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceLineMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoiceLine).
func (m *BillingInvoiceLineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceLineMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.namespace != nil {
		fields = append(fields, billinginvoiceline.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, billinginvoiceline.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, billinginvoiceline.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billinginvoiceline.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billinginvoiceline.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, billinginvoiceline.FieldName)
	}
	if m.description != nil {
		fields = append(fields, billinginvoiceline.FieldDescription)
	}
	if m.billing_invoice != nil {
		fields = append(fields, billinginvoiceline.FieldInvoiceID)
	}
	if m.period_start != nil {
		fields = append(fields, billinginvoiceline.FieldPeriodStart)
	}
	if m.period_end != nil {
		fields = append(fields, billinginvoiceline.FieldPeriodEnd)
	}
	if m.invoice_at != nil {
		fields = append(fields, billinginvoiceline.FieldInvoiceAt)
	}
	if m._type != nil {
		fields = append(fields, billinginvoiceline.FieldType)
	}
	if m.status != nil {
		fields = append(fields, billinginvoiceline.FieldStatus)
	}
	if m.currency != nil {
		fields = append(fields, billinginvoiceline.FieldCurrency)
	}
	if m.quantity != nil {
		fields = append(fields, billinginvoiceline.FieldQuantity)
	}
	if m.tax_overrides != nil {
		fields = append(fields, billinginvoiceline.FieldTaxOverrides)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceLineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoiceline.FieldNamespace:
		return m.Namespace()
	case billinginvoiceline.FieldMetadata:
		return m.Metadata()
	case billinginvoiceline.FieldCreatedAt:
		return m.CreatedAt()
	case billinginvoiceline.FieldUpdatedAt:
		return m.UpdatedAt()
	case billinginvoiceline.FieldDeletedAt:
		return m.DeletedAt()
	case billinginvoiceline.FieldName:
		return m.Name()
	case billinginvoiceline.FieldDescription:
		return m.Description()
	case billinginvoiceline.FieldInvoiceID:
		return m.InvoiceID()
	case billinginvoiceline.FieldPeriodStart:
		return m.PeriodStart()
	case billinginvoiceline.FieldPeriodEnd:
		return m.PeriodEnd()
	case billinginvoiceline.FieldInvoiceAt:
		return m.InvoiceAt()
	case billinginvoiceline.FieldType:
		return m.GetType()
	case billinginvoiceline.FieldStatus:
		return m.Status()
	case billinginvoiceline.FieldCurrency:
		return m.Currency()
	case billinginvoiceline.FieldQuantity:
		return m.Quantity()
	case billinginvoiceline.FieldTaxOverrides:
		return m.TaxOverrides()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceLineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoiceline.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoiceline.FieldMetadata:
		return m.OldMetadata(ctx)
	case billinginvoiceline.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billinginvoiceline.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billinginvoiceline.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billinginvoiceline.FieldName:
		return m.OldName(ctx)
	case billinginvoiceline.FieldDescription:
		return m.OldDescription(ctx)
	case billinginvoiceline.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	case billinginvoiceline.FieldPeriodStart:
		return m.OldPeriodStart(ctx)
	case billinginvoiceline.FieldPeriodEnd:
		return m.OldPeriodEnd(ctx)
	case billinginvoiceline.FieldInvoiceAt:
		return m.OldInvoiceAt(ctx)
	case billinginvoiceline.FieldType:
		return m.OldType(ctx)
	case billinginvoiceline.FieldStatus:
		return m.OldStatus(ctx)
	case billinginvoiceline.FieldCurrency:
		return m.OldCurrency(ctx)
	case billinginvoiceline.FieldQuantity:
		return m.OldQuantity(ctx)
	case billinginvoiceline.FieldTaxOverrides:
		return m.OldTaxOverrides(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoiceLine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceLineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoiceline.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoiceline.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case billinginvoiceline.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billinginvoiceline.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billinginvoiceline.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billinginvoiceline.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case billinginvoiceline.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case billinginvoiceline.FieldInvoiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	case billinginvoiceline.FieldPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodStart(v)
		return nil
	case billinginvoiceline.FieldPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodEnd(v)
		return nil
	case billinginvoiceline.FieldInvoiceAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceAt(v)
		return nil
	case billinginvoiceline.FieldType:
		v, ok := value.(billingentity.InvoiceLineType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case billinginvoiceline.FieldStatus:
		v, ok := value.(billingentity.InvoiceLineStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case billinginvoiceline.FieldCurrency:
		v, ok := value.(currencyx.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case billinginvoiceline.FieldQuantity:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case billinginvoiceline.FieldTaxOverrides:
		v, ok := value.(*billingentity.TaxOverrides)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxOverrides(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceLineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceLineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceLineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoiceLine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceLineMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoiceline.FieldMetadata) {
		fields = append(fields, billinginvoiceline.FieldMetadata)
	}
	if m.FieldCleared(billinginvoiceline.FieldDeletedAt) {
		fields = append(fields, billinginvoiceline.FieldDeletedAt)
	}
	if m.FieldCleared(billinginvoiceline.FieldDescription) {
		fields = append(fields, billinginvoiceline.FieldDescription)
	}
	if m.FieldCleared(billinginvoiceline.FieldQuantity) {
		fields = append(fields, billinginvoiceline.FieldQuantity)
	}
	if m.FieldCleared(billinginvoiceline.FieldTaxOverrides) {
		fields = append(fields, billinginvoiceline.FieldTaxOverrides)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceLineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceLineMutation) ClearField(name string) error {
	switch name {
	case billinginvoiceline.FieldMetadata:
		m.ClearMetadata()
		return nil
	case billinginvoiceline.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billinginvoiceline.FieldDescription:
		m.ClearDescription()
		return nil
	case billinginvoiceline.FieldQuantity:
		m.ClearQuantity()
		return nil
	case billinginvoiceline.FieldTaxOverrides:
		m.ClearTaxOverrides()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceLineMutation) ResetField(name string) error {
	switch name {
	case billinginvoiceline.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoiceline.FieldMetadata:
		m.ResetMetadata()
		return nil
	case billinginvoiceline.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billinginvoiceline.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billinginvoiceline.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billinginvoiceline.FieldName:
		m.ResetName()
		return nil
	case billinginvoiceline.FieldDescription:
		m.ResetDescription()
		return nil
	case billinginvoiceline.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	case billinginvoiceline.FieldPeriodStart:
		m.ResetPeriodStart()
		return nil
	case billinginvoiceline.FieldPeriodEnd:
		m.ResetPeriodEnd()
		return nil
	case billinginvoiceline.FieldInvoiceAt:
		m.ResetInvoiceAt()
		return nil
	case billinginvoiceline.FieldType:
		m.ResetType()
		return nil
	case billinginvoiceline.FieldStatus:
		m.ResetStatus()
		return nil
	case billinginvoiceline.FieldCurrency:
		m.ResetCurrency()
		return nil
	case billinginvoiceline.FieldQuantity:
		m.ResetQuantity()
		return nil
	case billinginvoiceline.FieldTaxOverrides:
		m.ResetTaxOverrides()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceLineMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.billing_invoice != nil {
		edges = append(edges, billinginvoiceline.EdgeBillingInvoice)
	}
	if m.billing_invoice_manual_lines != nil {
		edges = append(edges, billinginvoiceline.EdgeBillingInvoiceManualLines)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceLineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billinginvoiceline.EdgeBillingInvoice:
		if id := m.billing_invoice; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoiceline.EdgeBillingInvoiceManualLines:
		if id := m.billing_invoice_manual_lines; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceLineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceLineMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceLineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbilling_invoice {
		edges = append(edges, billinginvoiceline.EdgeBillingInvoice)
	}
	if m.clearedbilling_invoice_manual_lines {
		edges = append(edges, billinginvoiceline.EdgeBillingInvoiceManualLines)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceLineMutation) EdgeCleared(name string) bool {
	switch name {
	case billinginvoiceline.EdgeBillingInvoice:
		return m.clearedbilling_invoice
	case billinginvoiceline.EdgeBillingInvoiceManualLines:
		return m.clearedbilling_invoice_manual_lines
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceLineMutation) ClearEdge(name string) error {
	switch name {
	case billinginvoiceline.EdgeBillingInvoice:
		m.ClearBillingInvoice()
		return nil
	case billinginvoiceline.EdgeBillingInvoiceManualLines:
		m.ClearBillingInvoiceManualLines()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceLineMutation) ResetEdge(name string) error {
	switch name {
	case billinginvoiceline.EdgeBillingInvoice:
		m.ResetBillingInvoice()
		return nil
	case billinginvoiceline.EdgeBillingInvoiceManualLines:
		m.ResetBillingInvoiceManualLines()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLine edge %s", name)
}

// BillingInvoiceManualLineConfigMutation represents an operation that mutates the BillingInvoiceManualLineConfig nodes in the graph.
type BillingInvoiceManualLineConfigMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	unit_price    *alpacadecimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BillingInvoiceManualLineConfig, error)
	predicates    []predicate.BillingInvoiceManualLineConfig
}

var _ ent.Mutation = (*BillingInvoiceManualLineConfigMutation)(nil)

// billinginvoicemanuallineconfigOption allows management of the mutation configuration using functional options.
type billinginvoicemanuallineconfigOption func(*BillingInvoiceManualLineConfigMutation)

// newBillingInvoiceManualLineConfigMutation creates new mutation for the BillingInvoiceManualLineConfig entity.
func newBillingInvoiceManualLineConfigMutation(c config, op Op, opts ...billinginvoicemanuallineconfigOption) *BillingInvoiceManualLineConfigMutation {
	m := &BillingInvoiceManualLineConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoiceManualLineConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceManualLineConfigID sets the ID field of the mutation.
func withBillingInvoiceManualLineConfigID(id string) billinginvoicemanuallineconfigOption {
	return func(m *BillingInvoiceManualLineConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoiceManualLineConfig
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoiceManualLineConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoiceManualLineConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoiceManualLineConfig sets the old BillingInvoiceManualLineConfig of the mutation.
func withBillingInvoiceManualLineConfig(node *BillingInvoiceManualLineConfig) billinginvoicemanuallineconfigOption {
	return func(m *BillingInvoiceManualLineConfigMutation) {
		m.oldValue = func(context.Context) (*BillingInvoiceManualLineConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceManualLineConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceManualLineConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoiceManualLineConfig entities.
func (m *BillingInvoiceManualLineConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceManualLineConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceManualLineConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoiceManualLineConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceManualLineConfigMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceManualLineConfigMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoiceManualLineConfig entity.
// If the BillingInvoiceManualLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceManualLineConfigMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceManualLineConfigMutation) ResetNamespace() {
	m.namespace = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *BillingInvoiceManualLineConfigMutation) SetUnitPrice(a alpacadecimal.Decimal) {
	m.unit_price = &a
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *BillingInvoiceManualLineConfigMutation) UnitPrice() (r alpacadecimal.Decimal, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the BillingInvoiceManualLineConfig entity.
// If the BillingInvoiceManualLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceManualLineConfigMutation) OldUnitPrice(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *BillingInvoiceManualLineConfigMutation) ResetUnitPrice() {
	m.unit_price = nil
}

// Where appends a list predicates to the BillingInvoiceManualLineConfigMutation builder.
func (m *BillingInvoiceManualLineConfigMutation) Where(ps ...predicate.BillingInvoiceManualLineConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceManualLineConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceManualLineConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoiceManualLineConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceManualLineConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceManualLineConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoiceManualLineConfig).
func (m *BillingInvoiceManualLineConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceManualLineConfigMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.namespace != nil {
		fields = append(fields, billinginvoicemanuallineconfig.FieldNamespace)
	}
	if m.unit_price != nil {
		fields = append(fields, billinginvoicemanuallineconfig.FieldUnitPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceManualLineConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoicemanuallineconfig.FieldNamespace:
		return m.Namespace()
	case billinginvoicemanuallineconfig.FieldUnitPrice:
		return m.UnitPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceManualLineConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoicemanuallineconfig.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoicemanuallineconfig.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoiceManualLineConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceManualLineConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoicemanuallineconfig.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoicemanuallineconfig.FieldUnitPrice:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceManualLineConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceManualLineConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceManualLineConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceManualLineConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoiceManualLineConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceManualLineConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceManualLineConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceManualLineConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BillingInvoiceManualLineConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceManualLineConfigMutation) ResetField(name string) error {
	switch name {
	case billinginvoicemanuallineconfig.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoicemanuallineconfig.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceManualLineConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceManualLineConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceManualLineConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceManualLineConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceManualLineConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceManualLineConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceManualLineConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceManualLineConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BillingInvoiceManualLineConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceManualLineConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BillingInvoiceManualLineConfig edge %s", name)
}

// BillingInvoiceValidationIssueMutation represents an operation that mutates the BillingInvoiceValidationIssue nodes in the graph.
type BillingInvoiceValidationIssueMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	namespace              *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	severity               *billingentity.ValidationIssueSeverity
	code                   *string
	message                *string
	_path                  *string
	component              *string
	dedupe_hash            *[]byte
	clearedFields          map[string]struct{}
	billing_invoice        *string
	clearedbilling_invoice bool
	done                   bool
	oldValue               func(context.Context) (*BillingInvoiceValidationIssue, error)
	predicates             []predicate.BillingInvoiceValidationIssue
}

var _ ent.Mutation = (*BillingInvoiceValidationIssueMutation)(nil)

// billinginvoicevalidationissueOption allows management of the mutation configuration using functional options.
type billinginvoicevalidationissueOption func(*BillingInvoiceValidationIssueMutation)

// newBillingInvoiceValidationIssueMutation creates new mutation for the BillingInvoiceValidationIssue entity.
func newBillingInvoiceValidationIssueMutation(c config, op Op, opts ...billinginvoicevalidationissueOption) *BillingInvoiceValidationIssueMutation {
	m := &BillingInvoiceValidationIssueMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoiceValidationIssue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceValidationIssueID sets the ID field of the mutation.
func withBillingInvoiceValidationIssueID(id string) billinginvoicevalidationissueOption {
	return func(m *BillingInvoiceValidationIssueMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoiceValidationIssue
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoiceValidationIssue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoiceValidationIssue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoiceValidationIssue sets the old BillingInvoiceValidationIssue of the mutation.
func withBillingInvoiceValidationIssue(node *BillingInvoiceValidationIssue) billinginvoicevalidationissueOption {
	return func(m *BillingInvoiceValidationIssueMutation) {
		m.oldValue = func(context.Context) (*BillingInvoiceValidationIssue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceValidationIssueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceValidationIssueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoiceValidationIssue entities.
func (m *BillingInvoiceValidationIssueMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceValidationIssueMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceValidationIssueMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoiceValidationIssue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceValidationIssueMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceValidationIssueMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingInvoiceValidationIssueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingInvoiceValidationIssueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingInvoiceValidationIssueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingInvoiceValidationIssueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingInvoiceValidationIssueMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingInvoiceValidationIssueMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billinginvoicevalidationissue.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoicevalidationissue.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingInvoiceValidationIssueMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billinginvoicevalidationissue.FieldDeletedAt)
}

// SetInvoiceID sets the "invoice_id" field.
func (m *BillingInvoiceValidationIssueMutation) SetInvoiceID(s string) {
	m.billing_invoice = &s
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) InvoiceID() (r string, exists bool) {
	v := m.billing_invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldInvoiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *BillingInvoiceValidationIssueMutation) ResetInvoiceID() {
	m.billing_invoice = nil
}

// SetSeverity sets the "severity" field.
func (m *BillingInvoiceValidationIssueMutation) SetSeverity(bis billingentity.ValidationIssueSeverity) {
	m.severity = &bis
}

// Severity returns the value of the "severity" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Severity() (r billingentity.ValidationIssueSeverity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldSeverity(ctx context.Context) (v billingentity.ValidationIssueSeverity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *BillingInvoiceValidationIssueMutation) ResetSeverity() {
	m.severity = nil
}

// SetCode sets the "code" field.
func (m *BillingInvoiceValidationIssueMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *BillingInvoiceValidationIssueMutation) ClearCode() {
	m.code = nil
	m.clearedFields[billinginvoicevalidationissue.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) CodeCleared() bool {
	_, ok := m.clearedFields[billinginvoicevalidationissue.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *BillingInvoiceValidationIssueMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, billinginvoicevalidationissue.FieldCode)
}

// SetMessage sets the "message" field.
func (m *BillingInvoiceValidationIssueMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *BillingInvoiceValidationIssueMutation) ResetMessage() {
	m.message = nil
}

// SetPath sets the "path" field.
func (m *BillingInvoiceValidationIssueMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *BillingInvoiceValidationIssueMutation) ClearPath() {
	m._path = nil
	m.clearedFields[billinginvoicevalidationissue.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) PathCleared() bool {
	_, ok := m.clearedFields[billinginvoicevalidationissue.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *BillingInvoiceValidationIssueMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, billinginvoicevalidationissue.FieldPath)
}

// SetComponent sets the "component" field.
func (m *BillingInvoiceValidationIssueMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldComponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ResetComponent resets all changes to the "component" field.
func (m *BillingInvoiceValidationIssueMutation) ResetComponent() {
	m.component = nil
}

// SetDedupeHash sets the "dedupe_hash" field.
func (m *BillingInvoiceValidationIssueMutation) SetDedupeHash(b []byte) {
	m.dedupe_hash = &b
}

// DedupeHash returns the value of the "dedupe_hash" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) DedupeHash() (r []byte, exists bool) {
	v := m.dedupe_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldDedupeHash returns the old "dedupe_hash" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldDedupeHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDedupeHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDedupeHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDedupeHash: %w", err)
	}
	return oldValue.DedupeHash, nil
}

// ResetDedupeHash resets all changes to the "dedupe_hash" field.
func (m *BillingInvoiceValidationIssueMutation) ResetDedupeHash() {
	m.dedupe_hash = nil
}

// SetBillingInvoiceID sets the "billing_invoice" edge to the BillingInvoice entity by id.
func (m *BillingInvoiceValidationIssueMutation) SetBillingInvoiceID(id string) {
	m.billing_invoice = &id
}

// ClearBillingInvoice clears the "billing_invoice" edge to the BillingInvoice entity.
func (m *BillingInvoiceValidationIssueMutation) ClearBillingInvoice() {
	m.clearedbilling_invoice = true
	m.clearedFields[billinginvoicevalidationissue.FieldInvoiceID] = struct{}{}
}

// BillingInvoiceCleared reports if the "billing_invoice" edge to the BillingInvoice entity was cleared.
func (m *BillingInvoiceValidationIssueMutation) BillingInvoiceCleared() bool {
	return m.clearedbilling_invoice
}

// BillingInvoiceID returns the "billing_invoice" edge ID in the mutation.
func (m *BillingInvoiceValidationIssueMutation) BillingInvoiceID() (id string, exists bool) {
	if m.billing_invoice != nil {
		return *m.billing_invoice, true
	}
	return
}

// BillingInvoiceIDs returns the "billing_invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoiceID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceValidationIssueMutation) BillingInvoiceIDs() (ids []string) {
	if id := m.billing_invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoice resets all changes to the "billing_invoice" edge.
func (m *BillingInvoiceValidationIssueMutation) ResetBillingInvoice() {
	m.billing_invoice = nil
	m.clearedbilling_invoice = false
}

// Where appends a list predicates to the BillingInvoiceValidationIssueMutation builder.
func (m *BillingInvoiceValidationIssueMutation) Where(ps ...predicate.BillingInvoiceValidationIssue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceValidationIssueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceValidationIssueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoiceValidationIssue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceValidationIssueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceValidationIssueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoiceValidationIssue).
func (m *BillingInvoiceValidationIssueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceValidationIssueMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.namespace != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldDeletedAt)
	}
	if m.billing_invoice != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldInvoiceID)
	}
	if m.severity != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldSeverity)
	}
	if m.code != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldCode)
	}
	if m.message != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldMessage)
	}
	if m._path != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldPath)
	}
	if m.component != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldComponent)
	}
	if m.dedupe_hash != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldDedupeHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceValidationIssueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoicevalidationissue.FieldNamespace:
		return m.Namespace()
	case billinginvoicevalidationissue.FieldCreatedAt:
		return m.CreatedAt()
	case billinginvoicevalidationissue.FieldUpdatedAt:
		return m.UpdatedAt()
	case billinginvoicevalidationissue.FieldDeletedAt:
		return m.DeletedAt()
	case billinginvoicevalidationissue.FieldInvoiceID:
		return m.InvoiceID()
	case billinginvoicevalidationissue.FieldSeverity:
		return m.Severity()
	case billinginvoicevalidationissue.FieldCode:
		return m.Code()
	case billinginvoicevalidationissue.FieldMessage:
		return m.Message()
	case billinginvoicevalidationissue.FieldPath:
		return m.Path()
	case billinginvoicevalidationissue.FieldComponent:
		return m.Component()
	case billinginvoicevalidationissue.FieldDedupeHash:
		return m.DedupeHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceValidationIssueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoicevalidationissue.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoicevalidationissue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billinginvoicevalidationissue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billinginvoicevalidationissue.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billinginvoicevalidationissue.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	case billinginvoicevalidationissue.FieldSeverity:
		return m.OldSeverity(ctx)
	case billinginvoicevalidationissue.FieldCode:
		return m.OldCode(ctx)
	case billinginvoicevalidationissue.FieldMessage:
		return m.OldMessage(ctx)
	case billinginvoicevalidationissue.FieldPath:
		return m.OldPath(ctx)
	case billinginvoicevalidationissue.FieldComponent:
		return m.OldComponent(ctx)
	case billinginvoicevalidationissue.FieldDedupeHash:
		return m.OldDedupeHash(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoiceValidationIssue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceValidationIssueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoicevalidationissue.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoicevalidationissue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billinginvoicevalidationissue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billinginvoicevalidationissue.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billinginvoicevalidationissue.FieldInvoiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	case billinginvoicevalidationissue.FieldSeverity:
		v, ok := value.(billingentity.ValidationIssueSeverity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case billinginvoicevalidationissue.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case billinginvoicevalidationissue.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case billinginvoicevalidationissue.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case billinginvoicevalidationissue.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case billinginvoicevalidationissue.FieldDedupeHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDedupeHash(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceValidationIssueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceValidationIssueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceValidationIssueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceValidationIssueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoicevalidationissue.FieldDeletedAt) {
		fields = append(fields, billinginvoicevalidationissue.FieldDeletedAt)
	}
	if m.FieldCleared(billinginvoicevalidationissue.FieldCode) {
		fields = append(fields, billinginvoicevalidationissue.FieldCode)
	}
	if m.FieldCleared(billinginvoicevalidationissue.FieldPath) {
		fields = append(fields, billinginvoicevalidationissue.FieldPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceValidationIssueMutation) ClearField(name string) error {
	switch name {
	case billinginvoicevalidationissue.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billinginvoicevalidationissue.FieldCode:
		m.ClearCode()
		return nil
	case billinginvoicevalidationissue.FieldPath:
		m.ClearPath()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceValidationIssueMutation) ResetField(name string) error {
	switch name {
	case billinginvoicevalidationissue.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoicevalidationissue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billinginvoicevalidationissue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billinginvoicevalidationissue.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billinginvoicevalidationissue.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	case billinginvoicevalidationissue.FieldSeverity:
		m.ResetSeverity()
		return nil
	case billinginvoicevalidationissue.FieldCode:
		m.ResetCode()
		return nil
	case billinginvoicevalidationissue.FieldMessage:
		m.ResetMessage()
		return nil
	case billinginvoicevalidationissue.FieldPath:
		m.ResetPath()
		return nil
	case billinginvoicevalidationissue.FieldComponent:
		m.ResetComponent()
		return nil
	case billinginvoicevalidationissue.FieldDedupeHash:
		m.ResetDedupeHash()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceValidationIssueMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.billing_invoice != nil {
		edges = append(edges, billinginvoicevalidationissue.EdgeBillingInvoice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceValidationIssueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billinginvoicevalidationissue.EdgeBillingInvoice:
		if id := m.billing_invoice; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceValidationIssueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceValidationIssueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbilling_invoice {
		edges = append(edges, billinginvoicevalidationissue.EdgeBillingInvoice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) EdgeCleared(name string) bool {
	switch name {
	case billinginvoicevalidationissue.EdgeBillingInvoice:
		return m.clearedbilling_invoice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceValidationIssueMutation) ClearEdge(name string) error {
	switch name {
	case billinginvoicevalidationissue.EdgeBillingInvoice:
		m.ClearBillingInvoice()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceValidationIssueMutation) ResetEdge(name string) error {
	switch name {
	case billinginvoicevalidationissue.EdgeBillingInvoice:
		m.ResetBillingInvoice()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue edge %s", name)
}

// BillingProfileMutation represents an operation that mutates the BillingProfile nodes in the graph.
type BillingProfileMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	namespace                        *string
	metadata                         *map[string]string
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	name                             *string
	description                      *string
	supplier_address_country         *models.CountryCode
	supplier_address_postal_code     *string
	supplier_address_state           *string
	supplier_address_city            *string
	supplier_address_line1           *string
	supplier_address_line2           *string
	supplier_address_phone_number    *string
	_default                         *bool
	supplier_name                    *string
	supplier_tax_code                *string
	clearedFields                    map[string]struct{}
	billing_invoices                 map[string]struct{}
	removedbilling_invoices          map[string]struct{}
	clearedbilling_invoices          bool
	billing_customer_override        map[string]struct{}
	removedbilling_customer_override map[string]struct{}
	clearedbilling_customer_override bool
	workflow_config                  *string
	clearedworkflow_config           bool
	tax_app                          *string
	clearedtax_app                   bool
	invoicing_app                    *string
	clearedinvoicing_app             bool
	payment_app                      *string
	clearedpayment_app               bool
	done                             bool
	oldValue                         func(context.Context) (*BillingProfile, error)
	predicates                       []predicate.BillingProfile
}

var _ ent.Mutation = (*BillingProfileMutation)(nil)

// billingprofileOption allows management of the mutation configuration using functional options.
type billingprofileOption func(*BillingProfileMutation)

// newBillingProfileMutation creates new mutation for the BillingProfile entity.
func newBillingProfileMutation(c config, op Op, opts ...billingprofileOption) *BillingProfileMutation {
	m := &BillingProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingProfileID sets the ID field of the mutation.
func withBillingProfileID(id string) billingprofileOption {
	return func(m *BillingProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingProfile
		)
		m.oldValue = func(ctx context.Context) (*BillingProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingProfile sets the old BillingProfile of the mutation.
func withBillingProfile(node *BillingProfile) billingprofileOption {
	return func(m *BillingProfileMutation) {
		m.oldValue = func(context.Context) (*BillingProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingProfile entities.
func (m *BillingProfileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingProfileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingProfileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingProfileMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingProfileMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingProfileMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *BillingProfileMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *BillingProfileMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *BillingProfileMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[billingprofile.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *BillingProfileMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *BillingProfileMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, billingprofile.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingProfileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingProfileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingProfileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billingprofile.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingProfileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingProfileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billingprofile.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BillingProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BillingProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BillingProfileMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BillingProfileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BillingProfileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BillingProfileMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[billingprofile.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BillingProfileMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BillingProfileMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, billingprofile.FieldDescription)
}

// SetSupplierAddressCountry sets the "supplier_address_country" field.
func (m *BillingProfileMutation) SetSupplierAddressCountry(mc models.CountryCode) {
	m.supplier_address_country = &mc
}

// SupplierAddressCountry returns the value of the "supplier_address_country" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressCountry() (r models.CountryCode, exists bool) {
	v := m.supplier_address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressCountry returns the old "supplier_address_country" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressCountry(ctx context.Context) (v *models.CountryCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressCountry: %w", err)
	}
	return oldValue.SupplierAddressCountry, nil
}

// ClearSupplierAddressCountry clears the value of the "supplier_address_country" field.
func (m *BillingProfileMutation) ClearSupplierAddressCountry() {
	m.supplier_address_country = nil
	m.clearedFields[billingprofile.FieldSupplierAddressCountry] = struct{}{}
}

// SupplierAddressCountryCleared returns if the "supplier_address_country" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressCountryCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressCountry]
	return ok
}

// ResetSupplierAddressCountry resets all changes to the "supplier_address_country" field.
func (m *BillingProfileMutation) ResetSupplierAddressCountry() {
	m.supplier_address_country = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressCountry)
}

// SetSupplierAddressPostalCode sets the "supplier_address_postal_code" field.
func (m *BillingProfileMutation) SetSupplierAddressPostalCode(s string) {
	m.supplier_address_postal_code = &s
}

// SupplierAddressPostalCode returns the value of the "supplier_address_postal_code" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressPostalCode() (r string, exists bool) {
	v := m.supplier_address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressPostalCode returns the old "supplier_address_postal_code" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressPostalCode: %w", err)
	}
	return oldValue.SupplierAddressPostalCode, nil
}

// ClearSupplierAddressPostalCode clears the value of the "supplier_address_postal_code" field.
func (m *BillingProfileMutation) ClearSupplierAddressPostalCode() {
	m.supplier_address_postal_code = nil
	m.clearedFields[billingprofile.FieldSupplierAddressPostalCode] = struct{}{}
}

// SupplierAddressPostalCodeCleared returns if the "supplier_address_postal_code" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressPostalCode]
	return ok
}

// ResetSupplierAddressPostalCode resets all changes to the "supplier_address_postal_code" field.
func (m *BillingProfileMutation) ResetSupplierAddressPostalCode() {
	m.supplier_address_postal_code = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressPostalCode)
}

// SetSupplierAddressState sets the "supplier_address_state" field.
func (m *BillingProfileMutation) SetSupplierAddressState(s string) {
	m.supplier_address_state = &s
}

// SupplierAddressState returns the value of the "supplier_address_state" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressState() (r string, exists bool) {
	v := m.supplier_address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressState returns the old "supplier_address_state" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressState: %w", err)
	}
	return oldValue.SupplierAddressState, nil
}

// ClearSupplierAddressState clears the value of the "supplier_address_state" field.
func (m *BillingProfileMutation) ClearSupplierAddressState() {
	m.supplier_address_state = nil
	m.clearedFields[billingprofile.FieldSupplierAddressState] = struct{}{}
}

// SupplierAddressStateCleared returns if the "supplier_address_state" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressStateCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressState]
	return ok
}

// ResetSupplierAddressState resets all changes to the "supplier_address_state" field.
func (m *BillingProfileMutation) ResetSupplierAddressState() {
	m.supplier_address_state = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressState)
}

// SetSupplierAddressCity sets the "supplier_address_city" field.
func (m *BillingProfileMutation) SetSupplierAddressCity(s string) {
	m.supplier_address_city = &s
}

// SupplierAddressCity returns the value of the "supplier_address_city" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressCity() (r string, exists bool) {
	v := m.supplier_address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressCity returns the old "supplier_address_city" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressCity: %w", err)
	}
	return oldValue.SupplierAddressCity, nil
}

// ClearSupplierAddressCity clears the value of the "supplier_address_city" field.
func (m *BillingProfileMutation) ClearSupplierAddressCity() {
	m.supplier_address_city = nil
	m.clearedFields[billingprofile.FieldSupplierAddressCity] = struct{}{}
}

// SupplierAddressCityCleared returns if the "supplier_address_city" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressCityCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressCity]
	return ok
}

// ResetSupplierAddressCity resets all changes to the "supplier_address_city" field.
func (m *BillingProfileMutation) ResetSupplierAddressCity() {
	m.supplier_address_city = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressCity)
}

// SetSupplierAddressLine1 sets the "supplier_address_line1" field.
func (m *BillingProfileMutation) SetSupplierAddressLine1(s string) {
	m.supplier_address_line1 = &s
}

// SupplierAddressLine1 returns the value of the "supplier_address_line1" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressLine1() (r string, exists bool) {
	v := m.supplier_address_line1
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressLine1 returns the old "supplier_address_line1" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressLine1: %w", err)
	}
	return oldValue.SupplierAddressLine1, nil
}

// ClearSupplierAddressLine1 clears the value of the "supplier_address_line1" field.
func (m *BillingProfileMutation) ClearSupplierAddressLine1() {
	m.supplier_address_line1 = nil
	m.clearedFields[billingprofile.FieldSupplierAddressLine1] = struct{}{}
}

// SupplierAddressLine1Cleared returns if the "supplier_address_line1" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressLine1Cleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressLine1]
	return ok
}

// ResetSupplierAddressLine1 resets all changes to the "supplier_address_line1" field.
func (m *BillingProfileMutation) ResetSupplierAddressLine1() {
	m.supplier_address_line1 = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressLine1)
}

// SetSupplierAddressLine2 sets the "supplier_address_line2" field.
func (m *BillingProfileMutation) SetSupplierAddressLine2(s string) {
	m.supplier_address_line2 = &s
}

// SupplierAddressLine2 returns the value of the "supplier_address_line2" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressLine2() (r string, exists bool) {
	v := m.supplier_address_line2
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressLine2 returns the old "supplier_address_line2" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressLine2: %w", err)
	}
	return oldValue.SupplierAddressLine2, nil
}

// ClearSupplierAddressLine2 clears the value of the "supplier_address_line2" field.
func (m *BillingProfileMutation) ClearSupplierAddressLine2() {
	m.supplier_address_line2 = nil
	m.clearedFields[billingprofile.FieldSupplierAddressLine2] = struct{}{}
}

// SupplierAddressLine2Cleared returns if the "supplier_address_line2" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressLine2Cleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressLine2]
	return ok
}

// ResetSupplierAddressLine2 resets all changes to the "supplier_address_line2" field.
func (m *BillingProfileMutation) ResetSupplierAddressLine2() {
	m.supplier_address_line2 = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressLine2)
}

// SetSupplierAddressPhoneNumber sets the "supplier_address_phone_number" field.
func (m *BillingProfileMutation) SetSupplierAddressPhoneNumber(s string) {
	m.supplier_address_phone_number = &s
}

// SupplierAddressPhoneNumber returns the value of the "supplier_address_phone_number" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressPhoneNumber() (r string, exists bool) {
	v := m.supplier_address_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressPhoneNumber returns the old "supplier_address_phone_number" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressPhoneNumber: %w", err)
	}
	return oldValue.SupplierAddressPhoneNumber, nil
}

// ClearSupplierAddressPhoneNumber clears the value of the "supplier_address_phone_number" field.
func (m *BillingProfileMutation) ClearSupplierAddressPhoneNumber() {
	m.supplier_address_phone_number = nil
	m.clearedFields[billingprofile.FieldSupplierAddressPhoneNumber] = struct{}{}
}

// SupplierAddressPhoneNumberCleared returns if the "supplier_address_phone_number" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressPhoneNumberCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressPhoneNumber]
	return ok
}

// ResetSupplierAddressPhoneNumber resets all changes to the "supplier_address_phone_number" field.
func (m *BillingProfileMutation) ResetSupplierAddressPhoneNumber() {
	m.supplier_address_phone_number = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressPhoneNumber)
}

// SetTaxAppID sets the "tax_app_id" field.
func (m *BillingProfileMutation) SetTaxAppID(s string) {
	m.tax_app = &s
}

// TaxAppID returns the value of the "tax_app_id" field in the mutation.
func (m *BillingProfileMutation) TaxAppID() (r string, exists bool) {
	v := m.tax_app
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAppID returns the old "tax_app_id" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldTaxAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAppID: %w", err)
	}
	return oldValue.TaxAppID, nil
}

// ResetTaxAppID resets all changes to the "tax_app_id" field.
func (m *BillingProfileMutation) ResetTaxAppID() {
	m.tax_app = nil
}

// SetInvoicingAppID sets the "invoicing_app_id" field.
func (m *BillingProfileMutation) SetInvoicingAppID(s string) {
	m.invoicing_app = &s
}

// InvoicingAppID returns the value of the "invoicing_app_id" field in the mutation.
func (m *BillingProfileMutation) InvoicingAppID() (r string, exists bool) {
	v := m.invoicing_app
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingAppID returns the old "invoicing_app_id" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldInvoicingAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingAppID: %w", err)
	}
	return oldValue.InvoicingAppID, nil
}

// ResetInvoicingAppID resets all changes to the "invoicing_app_id" field.
func (m *BillingProfileMutation) ResetInvoicingAppID() {
	m.invoicing_app = nil
}

// SetPaymentAppID sets the "payment_app_id" field.
func (m *BillingProfileMutation) SetPaymentAppID(s string) {
	m.payment_app = &s
}

// PaymentAppID returns the value of the "payment_app_id" field in the mutation.
func (m *BillingProfileMutation) PaymentAppID() (r string, exists bool) {
	v := m.payment_app
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentAppID returns the old "payment_app_id" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldPaymentAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentAppID: %w", err)
	}
	return oldValue.PaymentAppID, nil
}

// ResetPaymentAppID resets all changes to the "payment_app_id" field.
func (m *BillingProfileMutation) ResetPaymentAppID() {
	m.payment_app = nil
}

// SetWorkflowConfigID sets the "workflow_config_id" field.
func (m *BillingProfileMutation) SetWorkflowConfigID(s string) {
	m.workflow_config = &s
}

// WorkflowConfigID returns the value of the "workflow_config_id" field in the mutation.
func (m *BillingProfileMutation) WorkflowConfigID() (r string, exists bool) {
	v := m.workflow_config
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowConfigID returns the old "workflow_config_id" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldWorkflowConfigID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowConfigID: %w", err)
	}
	return oldValue.WorkflowConfigID, nil
}

// ResetWorkflowConfigID resets all changes to the "workflow_config_id" field.
func (m *BillingProfileMutation) ResetWorkflowConfigID() {
	m.workflow_config = nil
}

// SetDefault sets the "default" field.
func (m *BillingProfileMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *BillingProfileMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *BillingProfileMutation) ResetDefault() {
	m._default = nil
}

// SetSupplierName sets the "supplier_name" field.
func (m *BillingProfileMutation) SetSupplierName(s string) {
	m.supplier_name = &s
}

// SupplierName returns the value of the "supplier_name" field in the mutation.
func (m *BillingProfileMutation) SupplierName() (r string, exists bool) {
	v := m.supplier_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierName returns the old "supplier_name" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierName: %w", err)
	}
	return oldValue.SupplierName, nil
}

// ResetSupplierName resets all changes to the "supplier_name" field.
func (m *BillingProfileMutation) ResetSupplierName() {
	m.supplier_name = nil
}

// SetSupplierTaxCode sets the "supplier_tax_code" field.
func (m *BillingProfileMutation) SetSupplierTaxCode(s string) {
	m.supplier_tax_code = &s
}

// SupplierTaxCode returns the value of the "supplier_tax_code" field in the mutation.
func (m *BillingProfileMutation) SupplierTaxCode() (r string, exists bool) {
	v := m.supplier_tax_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierTaxCode returns the old "supplier_tax_code" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierTaxCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierTaxCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierTaxCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierTaxCode: %w", err)
	}
	return oldValue.SupplierTaxCode, nil
}

// ClearSupplierTaxCode clears the value of the "supplier_tax_code" field.
func (m *BillingProfileMutation) ClearSupplierTaxCode() {
	m.supplier_tax_code = nil
	m.clearedFields[billingprofile.FieldSupplierTaxCode] = struct{}{}
}

// SupplierTaxCodeCleared returns if the "supplier_tax_code" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierTaxCodeCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierTaxCode]
	return ok
}

// ResetSupplierTaxCode resets all changes to the "supplier_tax_code" field.
func (m *BillingProfileMutation) ResetSupplierTaxCode() {
	m.supplier_tax_code = nil
	delete(m.clearedFields, billingprofile.FieldSupplierTaxCode)
}

// AddBillingInvoiceIDs adds the "billing_invoices" edge to the BillingInvoice entity by ids.
func (m *BillingProfileMutation) AddBillingInvoiceIDs(ids ...string) {
	if m.billing_invoices == nil {
		m.billing_invoices = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoices[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoices clears the "billing_invoices" edge to the BillingInvoice entity.
func (m *BillingProfileMutation) ClearBillingInvoices() {
	m.clearedbilling_invoices = true
}

// BillingInvoicesCleared reports if the "billing_invoices" edge to the BillingInvoice entity was cleared.
func (m *BillingProfileMutation) BillingInvoicesCleared() bool {
	return m.clearedbilling_invoices
}

// RemoveBillingInvoiceIDs removes the "billing_invoices" edge to the BillingInvoice entity by IDs.
func (m *BillingProfileMutation) RemoveBillingInvoiceIDs(ids ...string) {
	if m.removedbilling_invoices == nil {
		m.removedbilling_invoices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoices, ids[i])
		m.removedbilling_invoices[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoices returns the removed IDs of the "billing_invoices" edge to the BillingInvoice entity.
func (m *BillingProfileMutation) RemovedBillingInvoicesIDs() (ids []string) {
	for id := range m.removedbilling_invoices {
		ids = append(ids, id)
	}
	return
}

// BillingInvoicesIDs returns the "billing_invoices" edge IDs in the mutation.
func (m *BillingProfileMutation) BillingInvoicesIDs() (ids []string) {
	for id := range m.billing_invoices {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoices resets all changes to the "billing_invoices" edge.
func (m *BillingProfileMutation) ResetBillingInvoices() {
	m.billing_invoices = nil
	m.clearedbilling_invoices = false
	m.removedbilling_invoices = nil
}

// AddBillingCustomerOverrideIDs adds the "billing_customer_override" edge to the BillingCustomerOverride entity by ids.
func (m *BillingProfileMutation) AddBillingCustomerOverrideIDs(ids ...string) {
	if m.billing_customer_override == nil {
		m.billing_customer_override = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_customer_override[ids[i]] = struct{}{}
	}
}

// ClearBillingCustomerOverride clears the "billing_customer_override" edge to the BillingCustomerOverride entity.
func (m *BillingProfileMutation) ClearBillingCustomerOverride() {
	m.clearedbilling_customer_override = true
}

// BillingCustomerOverrideCleared reports if the "billing_customer_override" edge to the BillingCustomerOverride entity was cleared.
func (m *BillingProfileMutation) BillingCustomerOverrideCleared() bool {
	return m.clearedbilling_customer_override
}

// RemoveBillingCustomerOverrideIDs removes the "billing_customer_override" edge to the BillingCustomerOverride entity by IDs.
func (m *BillingProfileMutation) RemoveBillingCustomerOverrideIDs(ids ...string) {
	if m.removedbilling_customer_override == nil {
		m.removedbilling_customer_override = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_customer_override, ids[i])
		m.removedbilling_customer_override[ids[i]] = struct{}{}
	}
}

// RemovedBillingCustomerOverride returns the removed IDs of the "billing_customer_override" edge to the BillingCustomerOverride entity.
func (m *BillingProfileMutation) RemovedBillingCustomerOverrideIDs() (ids []string) {
	for id := range m.removedbilling_customer_override {
		ids = append(ids, id)
	}
	return
}

// BillingCustomerOverrideIDs returns the "billing_customer_override" edge IDs in the mutation.
func (m *BillingProfileMutation) BillingCustomerOverrideIDs() (ids []string) {
	for id := range m.billing_customer_override {
		ids = append(ids, id)
	}
	return
}

// ResetBillingCustomerOverride resets all changes to the "billing_customer_override" edge.
func (m *BillingProfileMutation) ResetBillingCustomerOverride() {
	m.billing_customer_override = nil
	m.clearedbilling_customer_override = false
	m.removedbilling_customer_override = nil
}

// ClearWorkflowConfig clears the "workflow_config" edge to the BillingWorkflowConfig entity.
func (m *BillingProfileMutation) ClearWorkflowConfig() {
	m.clearedworkflow_config = true
	m.clearedFields[billingprofile.FieldWorkflowConfigID] = struct{}{}
}

// WorkflowConfigCleared reports if the "workflow_config" edge to the BillingWorkflowConfig entity was cleared.
func (m *BillingProfileMutation) WorkflowConfigCleared() bool {
	return m.clearedworkflow_config
}

// WorkflowConfigIDs returns the "workflow_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowConfigID instead. It exists only for internal usage by the builders.
func (m *BillingProfileMutation) WorkflowConfigIDs() (ids []string) {
	if id := m.workflow_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowConfig resets all changes to the "workflow_config" edge.
func (m *BillingProfileMutation) ResetWorkflowConfig() {
	m.workflow_config = nil
	m.clearedworkflow_config = false
}

// ClearTaxApp clears the "tax_app" edge to the App entity.
func (m *BillingProfileMutation) ClearTaxApp() {
	m.clearedtax_app = true
	m.clearedFields[billingprofile.FieldTaxAppID] = struct{}{}
}

// TaxAppCleared reports if the "tax_app" edge to the App entity was cleared.
func (m *BillingProfileMutation) TaxAppCleared() bool {
	return m.clearedtax_app
}

// TaxAppIDs returns the "tax_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaxAppID instead. It exists only for internal usage by the builders.
func (m *BillingProfileMutation) TaxAppIDs() (ids []string) {
	if id := m.tax_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaxApp resets all changes to the "tax_app" edge.
func (m *BillingProfileMutation) ResetTaxApp() {
	m.tax_app = nil
	m.clearedtax_app = false
}

// ClearInvoicingApp clears the "invoicing_app" edge to the App entity.
func (m *BillingProfileMutation) ClearInvoicingApp() {
	m.clearedinvoicing_app = true
	m.clearedFields[billingprofile.FieldInvoicingAppID] = struct{}{}
}

// InvoicingAppCleared reports if the "invoicing_app" edge to the App entity was cleared.
func (m *BillingProfileMutation) InvoicingAppCleared() bool {
	return m.clearedinvoicing_app
}

// InvoicingAppIDs returns the "invoicing_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoicingAppID instead. It exists only for internal usage by the builders.
func (m *BillingProfileMutation) InvoicingAppIDs() (ids []string) {
	if id := m.invoicing_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoicingApp resets all changes to the "invoicing_app" edge.
func (m *BillingProfileMutation) ResetInvoicingApp() {
	m.invoicing_app = nil
	m.clearedinvoicing_app = false
}

// ClearPaymentApp clears the "payment_app" edge to the App entity.
func (m *BillingProfileMutation) ClearPaymentApp() {
	m.clearedpayment_app = true
	m.clearedFields[billingprofile.FieldPaymentAppID] = struct{}{}
}

// PaymentAppCleared reports if the "payment_app" edge to the App entity was cleared.
func (m *BillingProfileMutation) PaymentAppCleared() bool {
	return m.clearedpayment_app
}

// PaymentAppIDs returns the "payment_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentAppID instead. It exists only for internal usage by the builders.
func (m *BillingProfileMutation) PaymentAppIDs() (ids []string) {
	if id := m.payment_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentApp resets all changes to the "payment_app" edge.
func (m *BillingProfileMutation) ResetPaymentApp() {
	m.payment_app = nil
	m.clearedpayment_app = false
}

// Where appends a list predicates to the BillingProfileMutation builder.
func (m *BillingProfileMutation) Where(ps ...predicate.BillingProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingProfile).
func (m *BillingProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingProfileMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.namespace != nil {
		fields = append(fields, billingprofile.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, billingprofile.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, billingprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingprofile.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billingprofile.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, billingprofile.FieldName)
	}
	if m.description != nil {
		fields = append(fields, billingprofile.FieldDescription)
	}
	if m.supplier_address_country != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressCountry)
	}
	if m.supplier_address_postal_code != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressPostalCode)
	}
	if m.supplier_address_state != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressState)
	}
	if m.supplier_address_city != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressCity)
	}
	if m.supplier_address_line1 != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressLine1)
	}
	if m.supplier_address_line2 != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressLine2)
	}
	if m.supplier_address_phone_number != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressPhoneNumber)
	}
	if m.tax_app != nil {
		fields = append(fields, billingprofile.FieldTaxAppID)
	}
	if m.invoicing_app != nil {
		fields = append(fields, billingprofile.FieldInvoicingAppID)
	}
	if m.payment_app != nil {
		fields = append(fields, billingprofile.FieldPaymentAppID)
	}
	if m.workflow_config != nil {
		fields = append(fields, billingprofile.FieldWorkflowConfigID)
	}
	if m._default != nil {
		fields = append(fields, billingprofile.FieldDefault)
	}
	if m.supplier_name != nil {
		fields = append(fields, billingprofile.FieldSupplierName)
	}
	if m.supplier_tax_code != nil {
		fields = append(fields, billingprofile.FieldSupplierTaxCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingprofile.FieldNamespace:
		return m.Namespace()
	case billingprofile.FieldMetadata:
		return m.Metadata()
	case billingprofile.FieldCreatedAt:
		return m.CreatedAt()
	case billingprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingprofile.FieldDeletedAt:
		return m.DeletedAt()
	case billingprofile.FieldName:
		return m.Name()
	case billingprofile.FieldDescription:
		return m.Description()
	case billingprofile.FieldSupplierAddressCountry:
		return m.SupplierAddressCountry()
	case billingprofile.FieldSupplierAddressPostalCode:
		return m.SupplierAddressPostalCode()
	case billingprofile.FieldSupplierAddressState:
		return m.SupplierAddressState()
	case billingprofile.FieldSupplierAddressCity:
		return m.SupplierAddressCity()
	case billingprofile.FieldSupplierAddressLine1:
		return m.SupplierAddressLine1()
	case billingprofile.FieldSupplierAddressLine2:
		return m.SupplierAddressLine2()
	case billingprofile.FieldSupplierAddressPhoneNumber:
		return m.SupplierAddressPhoneNumber()
	case billingprofile.FieldTaxAppID:
		return m.TaxAppID()
	case billingprofile.FieldInvoicingAppID:
		return m.InvoicingAppID()
	case billingprofile.FieldPaymentAppID:
		return m.PaymentAppID()
	case billingprofile.FieldWorkflowConfigID:
		return m.WorkflowConfigID()
	case billingprofile.FieldDefault:
		return m.Default()
	case billingprofile.FieldSupplierName:
		return m.SupplierName()
	case billingprofile.FieldSupplierTaxCode:
		return m.SupplierTaxCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingprofile.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingprofile.FieldMetadata:
		return m.OldMetadata(ctx)
	case billingprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingprofile.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billingprofile.FieldName:
		return m.OldName(ctx)
	case billingprofile.FieldDescription:
		return m.OldDescription(ctx)
	case billingprofile.FieldSupplierAddressCountry:
		return m.OldSupplierAddressCountry(ctx)
	case billingprofile.FieldSupplierAddressPostalCode:
		return m.OldSupplierAddressPostalCode(ctx)
	case billingprofile.FieldSupplierAddressState:
		return m.OldSupplierAddressState(ctx)
	case billingprofile.FieldSupplierAddressCity:
		return m.OldSupplierAddressCity(ctx)
	case billingprofile.FieldSupplierAddressLine1:
		return m.OldSupplierAddressLine1(ctx)
	case billingprofile.FieldSupplierAddressLine2:
		return m.OldSupplierAddressLine2(ctx)
	case billingprofile.FieldSupplierAddressPhoneNumber:
		return m.OldSupplierAddressPhoneNumber(ctx)
	case billingprofile.FieldTaxAppID:
		return m.OldTaxAppID(ctx)
	case billingprofile.FieldInvoicingAppID:
		return m.OldInvoicingAppID(ctx)
	case billingprofile.FieldPaymentAppID:
		return m.OldPaymentAppID(ctx)
	case billingprofile.FieldWorkflowConfigID:
		return m.OldWorkflowConfigID(ctx)
	case billingprofile.FieldDefault:
		return m.OldDefault(ctx)
	case billingprofile.FieldSupplierName:
		return m.OldSupplierName(ctx)
	case billingprofile.FieldSupplierTaxCode:
		return m.OldSupplierTaxCode(ctx)
	}
	return nil, fmt.Errorf("unknown BillingProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingprofile.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingprofile.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case billingprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingprofile.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billingprofile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case billingprofile.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case billingprofile.FieldSupplierAddressCountry:
		v, ok := value.(models.CountryCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressCountry(v)
		return nil
	case billingprofile.FieldSupplierAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressPostalCode(v)
		return nil
	case billingprofile.FieldSupplierAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressState(v)
		return nil
	case billingprofile.FieldSupplierAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressCity(v)
		return nil
	case billingprofile.FieldSupplierAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressLine1(v)
		return nil
	case billingprofile.FieldSupplierAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressLine2(v)
		return nil
	case billingprofile.FieldSupplierAddressPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressPhoneNumber(v)
		return nil
	case billingprofile.FieldTaxAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAppID(v)
		return nil
	case billingprofile.FieldInvoicingAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingAppID(v)
		return nil
	case billingprofile.FieldPaymentAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentAppID(v)
		return nil
	case billingprofile.FieldWorkflowConfigID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowConfigID(v)
		return nil
	case billingprofile.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	case billingprofile.FieldSupplierName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierName(v)
		return nil
	case billingprofile.FieldSupplierTaxCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierTaxCode(v)
		return nil
	}
	return fmt.Errorf("unknown BillingProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billingprofile.FieldMetadata) {
		fields = append(fields, billingprofile.FieldMetadata)
	}
	if m.FieldCleared(billingprofile.FieldDeletedAt) {
		fields = append(fields, billingprofile.FieldDeletedAt)
	}
	if m.FieldCleared(billingprofile.FieldDescription) {
		fields = append(fields, billingprofile.FieldDescription)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressCountry) {
		fields = append(fields, billingprofile.FieldSupplierAddressCountry)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressPostalCode) {
		fields = append(fields, billingprofile.FieldSupplierAddressPostalCode)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressState) {
		fields = append(fields, billingprofile.FieldSupplierAddressState)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressCity) {
		fields = append(fields, billingprofile.FieldSupplierAddressCity)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressLine1) {
		fields = append(fields, billingprofile.FieldSupplierAddressLine1)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressLine2) {
		fields = append(fields, billingprofile.FieldSupplierAddressLine2)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressPhoneNumber) {
		fields = append(fields, billingprofile.FieldSupplierAddressPhoneNumber)
	}
	if m.FieldCleared(billingprofile.FieldSupplierTaxCode) {
		fields = append(fields, billingprofile.FieldSupplierTaxCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingProfileMutation) ClearField(name string) error {
	switch name {
	case billingprofile.FieldMetadata:
		m.ClearMetadata()
		return nil
	case billingprofile.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billingprofile.FieldDescription:
		m.ClearDescription()
		return nil
	case billingprofile.FieldSupplierAddressCountry:
		m.ClearSupplierAddressCountry()
		return nil
	case billingprofile.FieldSupplierAddressPostalCode:
		m.ClearSupplierAddressPostalCode()
		return nil
	case billingprofile.FieldSupplierAddressState:
		m.ClearSupplierAddressState()
		return nil
	case billingprofile.FieldSupplierAddressCity:
		m.ClearSupplierAddressCity()
		return nil
	case billingprofile.FieldSupplierAddressLine1:
		m.ClearSupplierAddressLine1()
		return nil
	case billingprofile.FieldSupplierAddressLine2:
		m.ClearSupplierAddressLine2()
		return nil
	case billingprofile.FieldSupplierAddressPhoneNumber:
		m.ClearSupplierAddressPhoneNumber()
		return nil
	case billingprofile.FieldSupplierTaxCode:
		m.ClearSupplierTaxCode()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingProfileMutation) ResetField(name string) error {
	switch name {
	case billingprofile.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingprofile.FieldMetadata:
		m.ResetMetadata()
		return nil
	case billingprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingprofile.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billingprofile.FieldName:
		m.ResetName()
		return nil
	case billingprofile.FieldDescription:
		m.ResetDescription()
		return nil
	case billingprofile.FieldSupplierAddressCountry:
		m.ResetSupplierAddressCountry()
		return nil
	case billingprofile.FieldSupplierAddressPostalCode:
		m.ResetSupplierAddressPostalCode()
		return nil
	case billingprofile.FieldSupplierAddressState:
		m.ResetSupplierAddressState()
		return nil
	case billingprofile.FieldSupplierAddressCity:
		m.ResetSupplierAddressCity()
		return nil
	case billingprofile.FieldSupplierAddressLine1:
		m.ResetSupplierAddressLine1()
		return nil
	case billingprofile.FieldSupplierAddressLine2:
		m.ResetSupplierAddressLine2()
		return nil
	case billingprofile.FieldSupplierAddressPhoneNumber:
		m.ResetSupplierAddressPhoneNumber()
		return nil
	case billingprofile.FieldTaxAppID:
		m.ResetTaxAppID()
		return nil
	case billingprofile.FieldInvoicingAppID:
		m.ResetInvoicingAppID()
		return nil
	case billingprofile.FieldPaymentAppID:
		m.ResetPaymentAppID()
		return nil
	case billingprofile.FieldWorkflowConfigID:
		m.ResetWorkflowConfigID()
		return nil
	case billingprofile.FieldDefault:
		m.ResetDefault()
		return nil
	case billingprofile.FieldSupplierName:
		m.ResetSupplierName()
		return nil
	case billingprofile.FieldSupplierTaxCode:
		m.ResetSupplierTaxCode()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.billing_invoices != nil {
		edges = append(edges, billingprofile.EdgeBillingInvoices)
	}
	if m.billing_customer_override != nil {
		edges = append(edges, billingprofile.EdgeBillingCustomerOverride)
	}
	if m.workflow_config != nil {
		edges = append(edges, billingprofile.EdgeWorkflowConfig)
	}
	if m.tax_app != nil {
		edges = append(edges, billingprofile.EdgeTaxApp)
	}
	if m.invoicing_app != nil {
		edges = append(edges, billingprofile.EdgeInvoicingApp)
	}
	if m.payment_app != nil {
		edges = append(edges, billingprofile.EdgePaymentApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		ids := make([]ent.Value, 0, len(m.billing_invoices))
		for id := range m.billing_invoices {
			ids = append(ids, id)
		}
		return ids
	case billingprofile.EdgeBillingCustomerOverride:
		ids := make([]ent.Value, 0, len(m.billing_customer_override))
		for id := range m.billing_customer_override {
			ids = append(ids, id)
		}
		return ids
	case billingprofile.EdgeWorkflowConfig:
		if id := m.workflow_config; id != nil {
			return []ent.Value{*id}
		}
	case billingprofile.EdgeTaxApp:
		if id := m.tax_app; id != nil {
			return []ent.Value{*id}
		}
	case billingprofile.EdgeInvoicingApp:
		if id := m.invoicing_app; id != nil {
			return []ent.Value{*id}
		}
	case billingprofile.EdgePaymentApp:
		if id := m.payment_app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedbilling_invoices != nil {
		edges = append(edges, billingprofile.EdgeBillingInvoices)
	}
	if m.removedbilling_customer_override != nil {
		edges = append(edges, billingprofile.EdgeBillingCustomerOverride)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoices))
		for id := range m.removedbilling_invoices {
			ids = append(ids, id)
		}
		return ids
	case billingprofile.EdgeBillingCustomerOverride:
		ids := make([]ent.Value, 0, len(m.removedbilling_customer_override))
		for id := range m.removedbilling_customer_override {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedbilling_invoices {
		edges = append(edges, billingprofile.EdgeBillingInvoices)
	}
	if m.clearedbilling_customer_override {
		edges = append(edges, billingprofile.EdgeBillingCustomerOverride)
	}
	if m.clearedworkflow_config {
		edges = append(edges, billingprofile.EdgeWorkflowConfig)
	}
	if m.clearedtax_app {
		edges = append(edges, billingprofile.EdgeTaxApp)
	}
	if m.clearedinvoicing_app {
		edges = append(edges, billingprofile.EdgeInvoicingApp)
	}
	if m.clearedpayment_app {
		edges = append(edges, billingprofile.EdgePaymentApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		return m.clearedbilling_invoices
	case billingprofile.EdgeBillingCustomerOverride:
		return m.clearedbilling_customer_override
	case billingprofile.EdgeWorkflowConfig:
		return m.clearedworkflow_config
	case billingprofile.EdgeTaxApp:
		return m.clearedtax_app
	case billingprofile.EdgeInvoicingApp:
		return m.clearedinvoicing_app
	case billingprofile.EdgePaymentApp:
		return m.clearedpayment_app
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingProfileMutation) ClearEdge(name string) error {
	switch name {
	case billingprofile.EdgeWorkflowConfig:
		m.ClearWorkflowConfig()
		return nil
	case billingprofile.EdgeTaxApp:
		m.ClearTaxApp()
		return nil
	case billingprofile.EdgeInvoicingApp:
		m.ClearInvoicingApp()
		return nil
	case billingprofile.EdgePaymentApp:
		m.ClearPaymentApp()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingProfileMutation) ResetEdge(name string) error {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		m.ResetBillingInvoices()
		return nil
	case billingprofile.EdgeBillingCustomerOverride:
		m.ResetBillingCustomerOverride()
		return nil
	case billingprofile.EdgeWorkflowConfig:
		m.ResetWorkflowConfig()
		return nil
	case billingprofile.EdgeTaxApp:
		m.ResetTaxApp()
		return nil
	case billingprofile.EdgeInvoicingApp:
		m.ResetInvoicingApp()
		return nil
	case billingprofile.EdgePaymentApp:
		m.ResetPaymentApp()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile edge %s", name)
}

// BillingWorkflowConfigMutation represents an operation that mutates the BillingWorkflowConfig nodes in the graph.
type BillingWorkflowConfigMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	namespace                 *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	collection_alignment      *billingentity.AlignmentKind
	line_collection_period    *datex.ISOString
	invoice_auto_advance      *bool
	invoice_draft_period      *datex.ISOString
	invoice_due_after         *datex.ISOString
	invoice_collection_method *billingentity.CollectionMethod
	clearedFields             map[string]struct{}
	billing_invoices          *string
	clearedbilling_invoices   bool
	billing_profile           *string
	clearedbilling_profile    bool
	done                      bool
	oldValue                  func(context.Context) (*BillingWorkflowConfig, error)
	predicates                []predicate.BillingWorkflowConfig
}

var _ ent.Mutation = (*BillingWorkflowConfigMutation)(nil)

// billingworkflowconfigOption allows management of the mutation configuration using functional options.
type billingworkflowconfigOption func(*BillingWorkflowConfigMutation)

// newBillingWorkflowConfigMutation creates new mutation for the BillingWorkflowConfig entity.
func newBillingWorkflowConfigMutation(c config, op Op, opts ...billingworkflowconfigOption) *BillingWorkflowConfigMutation {
	m := &BillingWorkflowConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingWorkflowConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingWorkflowConfigID sets the ID field of the mutation.
func withBillingWorkflowConfigID(id string) billingworkflowconfigOption {
	return func(m *BillingWorkflowConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingWorkflowConfig
		)
		m.oldValue = func(ctx context.Context) (*BillingWorkflowConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingWorkflowConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingWorkflowConfig sets the old BillingWorkflowConfig of the mutation.
func withBillingWorkflowConfig(node *BillingWorkflowConfig) billingworkflowconfigOption {
	return func(m *BillingWorkflowConfigMutation) {
		m.oldValue = func(context.Context) (*BillingWorkflowConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingWorkflowConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingWorkflowConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingWorkflowConfig entities.
func (m *BillingWorkflowConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingWorkflowConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingWorkflowConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingWorkflowConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingWorkflowConfigMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingWorkflowConfigMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingWorkflowConfigMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingWorkflowConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingWorkflowConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingWorkflowConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingWorkflowConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingWorkflowConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingWorkflowConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingWorkflowConfigMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingWorkflowConfigMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingWorkflowConfigMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billingworkflowconfig.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingWorkflowConfigMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billingworkflowconfig.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingWorkflowConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billingworkflowconfig.FieldDeletedAt)
}

// SetCollectionAlignment sets the "collection_alignment" field.
func (m *BillingWorkflowConfigMutation) SetCollectionAlignment(bk billingentity.AlignmentKind) {
	m.collection_alignment = &bk
}

// CollectionAlignment returns the value of the "collection_alignment" field in the mutation.
func (m *BillingWorkflowConfigMutation) CollectionAlignment() (r billingentity.AlignmentKind, exists bool) {
	v := m.collection_alignment
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionAlignment returns the old "collection_alignment" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldCollectionAlignment(ctx context.Context) (v billingentity.AlignmentKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionAlignment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionAlignment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionAlignment: %w", err)
	}
	return oldValue.CollectionAlignment, nil
}

// ResetCollectionAlignment resets all changes to the "collection_alignment" field.
func (m *BillingWorkflowConfigMutation) ResetCollectionAlignment() {
	m.collection_alignment = nil
}

// SetLineCollectionPeriod sets the "line_collection_period" field.
func (m *BillingWorkflowConfigMutation) SetLineCollectionPeriod(ds datex.ISOString) {
	m.line_collection_period = &ds
}

// LineCollectionPeriod returns the value of the "line_collection_period" field in the mutation.
func (m *BillingWorkflowConfigMutation) LineCollectionPeriod() (r datex.ISOString, exists bool) {
	v := m.line_collection_period
	if v == nil {
		return
	}
	return *v, true
}

// OldLineCollectionPeriod returns the old "line_collection_period" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldLineCollectionPeriod(ctx context.Context) (v datex.ISOString, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineCollectionPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineCollectionPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineCollectionPeriod: %w", err)
	}
	return oldValue.LineCollectionPeriod, nil
}

// ResetLineCollectionPeriod resets all changes to the "line_collection_period" field.
func (m *BillingWorkflowConfigMutation) ResetLineCollectionPeriod() {
	m.line_collection_period = nil
}

// SetInvoiceAutoAdvance sets the "invoice_auto_advance" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceAutoAdvance(b bool) {
	m.invoice_auto_advance = &b
}

// InvoiceAutoAdvance returns the value of the "invoice_auto_advance" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceAutoAdvance() (r bool, exists bool) {
	v := m.invoice_auto_advance
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceAutoAdvance returns the old "invoice_auto_advance" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceAutoAdvance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceAutoAdvance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceAutoAdvance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceAutoAdvance: %w", err)
	}
	return oldValue.InvoiceAutoAdvance, nil
}

// ResetInvoiceAutoAdvance resets all changes to the "invoice_auto_advance" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceAutoAdvance() {
	m.invoice_auto_advance = nil
}

// SetInvoiceDraftPeriod sets the "invoice_draft_period" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceDraftPeriod(ds datex.ISOString) {
	m.invoice_draft_period = &ds
}

// InvoiceDraftPeriod returns the value of the "invoice_draft_period" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceDraftPeriod() (r datex.ISOString, exists bool) {
	v := m.invoice_draft_period
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDraftPeriod returns the old "invoice_draft_period" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceDraftPeriod(ctx context.Context) (v datex.ISOString, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDraftPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDraftPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDraftPeriod: %w", err)
	}
	return oldValue.InvoiceDraftPeriod, nil
}

// ResetInvoiceDraftPeriod resets all changes to the "invoice_draft_period" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceDraftPeriod() {
	m.invoice_draft_period = nil
}

// SetInvoiceDueAfter sets the "invoice_due_after" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceDueAfter(ds datex.ISOString) {
	m.invoice_due_after = &ds
}

// InvoiceDueAfter returns the value of the "invoice_due_after" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceDueAfter() (r datex.ISOString, exists bool) {
	v := m.invoice_due_after
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDueAfter returns the old "invoice_due_after" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceDueAfter(ctx context.Context) (v datex.ISOString, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDueAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDueAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDueAfter: %w", err)
	}
	return oldValue.InvoiceDueAfter, nil
}

// ResetInvoiceDueAfter resets all changes to the "invoice_due_after" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceDueAfter() {
	m.invoice_due_after = nil
}

// SetInvoiceCollectionMethod sets the "invoice_collection_method" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceCollectionMethod(bm billingentity.CollectionMethod) {
	m.invoice_collection_method = &bm
}

// InvoiceCollectionMethod returns the value of the "invoice_collection_method" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceCollectionMethod() (r billingentity.CollectionMethod, exists bool) {
	v := m.invoice_collection_method
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceCollectionMethod returns the old "invoice_collection_method" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceCollectionMethod(ctx context.Context) (v billingentity.CollectionMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceCollectionMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceCollectionMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceCollectionMethod: %w", err)
	}
	return oldValue.InvoiceCollectionMethod, nil
}

// ResetInvoiceCollectionMethod resets all changes to the "invoice_collection_method" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceCollectionMethod() {
	m.invoice_collection_method = nil
}

// SetBillingInvoicesID sets the "billing_invoices" edge to the BillingInvoice entity by id.
func (m *BillingWorkflowConfigMutation) SetBillingInvoicesID(id string) {
	m.billing_invoices = &id
}

// ClearBillingInvoices clears the "billing_invoices" edge to the BillingInvoice entity.
func (m *BillingWorkflowConfigMutation) ClearBillingInvoices() {
	m.clearedbilling_invoices = true
}

// BillingInvoicesCleared reports if the "billing_invoices" edge to the BillingInvoice entity was cleared.
func (m *BillingWorkflowConfigMutation) BillingInvoicesCleared() bool {
	return m.clearedbilling_invoices
}

// BillingInvoicesID returns the "billing_invoices" edge ID in the mutation.
func (m *BillingWorkflowConfigMutation) BillingInvoicesID() (id string, exists bool) {
	if m.billing_invoices != nil {
		return *m.billing_invoices, true
	}
	return
}

// BillingInvoicesIDs returns the "billing_invoices" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoicesID instead. It exists only for internal usage by the builders.
func (m *BillingWorkflowConfigMutation) BillingInvoicesIDs() (ids []string) {
	if id := m.billing_invoices; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoices resets all changes to the "billing_invoices" edge.
func (m *BillingWorkflowConfigMutation) ResetBillingInvoices() {
	m.billing_invoices = nil
	m.clearedbilling_invoices = false
}

// SetBillingProfileID sets the "billing_profile" edge to the BillingProfile entity by id.
func (m *BillingWorkflowConfigMutation) SetBillingProfileID(id string) {
	m.billing_profile = &id
}

// ClearBillingProfile clears the "billing_profile" edge to the BillingProfile entity.
func (m *BillingWorkflowConfigMutation) ClearBillingProfile() {
	m.clearedbilling_profile = true
}

// BillingProfileCleared reports if the "billing_profile" edge to the BillingProfile entity was cleared.
func (m *BillingWorkflowConfigMutation) BillingProfileCleared() bool {
	return m.clearedbilling_profile
}

// BillingProfileID returns the "billing_profile" edge ID in the mutation.
func (m *BillingWorkflowConfigMutation) BillingProfileID() (id string, exists bool) {
	if m.billing_profile != nil {
		return *m.billing_profile, true
	}
	return
}

// BillingProfileIDs returns the "billing_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingProfileID instead. It exists only for internal usage by the builders.
func (m *BillingWorkflowConfigMutation) BillingProfileIDs() (ids []string) {
	if id := m.billing_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingProfile resets all changes to the "billing_profile" edge.
func (m *BillingWorkflowConfigMutation) ResetBillingProfile() {
	m.billing_profile = nil
	m.clearedbilling_profile = false
}

// Where appends a list predicates to the BillingWorkflowConfigMutation builder.
func (m *BillingWorkflowConfigMutation) Where(ps ...predicate.BillingWorkflowConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingWorkflowConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingWorkflowConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingWorkflowConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingWorkflowConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingWorkflowConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingWorkflowConfig).
func (m *BillingWorkflowConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingWorkflowConfigMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, billingworkflowconfig.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billingworkflowconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingworkflowconfig.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billingworkflowconfig.FieldDeletedAt)
	}
	if m.collection_alignment != nil {
		fields = append(fields, billingworkflowconfig.FieldCollectionAlignment)
	}
	if m.line_collection_period != nil {
		fields = append(fields, billingworkflowconfig.FieldLineCollectionPeriod)
	}
	if m.invoice_auto_advance != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceAutoAdvance)
	}
	if m.invoice_draft_period != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceDraftPeriod)
	}
	if m.invoice_due_after != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceDueAfter)
	}
	if m.invoice_collection_method != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceCollectionMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingWorkflowConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		return m.Namespace()
	case billingworkflowconfig.FieldCreatedAt:
		return m.CreatedAt()
	case billingworkflowconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingworkflowconfig.FieldDeletedAt:
		return m.DeletedAt()
	case billingworkflowconfig.FieldCollectionAlignment:
		return m.CollectionAlignment()
	case billingworkflowconfig.FieldLineCollectionPeriod:
		return m.LineCollectionPeriod()
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		return m.InvoiceAutoAdvance()
	case billingworkflowconfig.FieldInvoiceDraftPeriod:
		return m.InvoiceDraftPeriod()
	case billingworkflowconfig.FieldInvoiceDueAfter:
		return m.InvoiceDueAfter()
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		return m.InvoiceCollectionMethod()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingWorkflowConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingworkflowconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingworkflowconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingworkflowconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billingworkflowconfig.FieldCollectionAlignment:
		return m.OldCollectionAlignment(ctx)
	case billingworkflowconfig.FieldLineCollectionPeriod:
		return m.OldLineCollectionPeriod(ctx)
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		return m.OldInvoiceAutoAdvance(ctx)
	case billingworkflowconfig.FieldInvoiceDraftPeriod:
		return m.OldInvoiceDraftPeriod(ctx)
	case billingworkflowconfig.FieldInvoiceDueAfter:
		return m.OldInvoiceDueAfter(ctx)
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		return m.OldInvoiceCollectionMethod(ctx)
	}
	return nil, fmt.Errorf("unknown BillingWorkflowConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingWorkflowConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingworkflowconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingworkflowconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingworkflowconfig.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billingworkflowconfig.FieldCollectionAlignment:
		v, ok := value.(billingentity.AlignmentKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionAlignment(v)
		return nil
	case billingworkflowconfig.FieldLineCollectionPeriod:
		v, ok := value.(datex.ISOString)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineCollectionPeriod(v)
		return nil
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceAutoAdvance(v)
		return nil
	case billingworkflowconfig.FieldInvoiceDraftPeriod:
		v, ok := value.(datex.ISOString)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDraftPeriod(v)
		return nil
	case billingworkflowconfig.FieldInvoiceDueAfter:
		v, ok := value.(datex.ISOString)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDueAfter(v)
		return nil
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		v, ok := value.(billingentity.CollectionMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceCollectionMethod(v)
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingWorkflowConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingWorkflowConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingWorkflowConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingWorkflowConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingWorkflowConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billingworkflowconfig.FieldDeletedAt) {
		fields = append(fields, billingworkflowconfig.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingWorkflowConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ClearField(name string) error {
	switch name {
	case billingworkflowconfig.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ResetField(name string) error {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingworkflowconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingworkflowconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingworkflowconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billingworkflowconfig.FieldCollectionAlignment:
		m.ResetCollectionAlignment()
		return nil
	case billingworkflowconfig.FieldLineCollectionPeriod:
		m.ResetLineCollectionPeriod()
		return nil
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		m.ResetInvoiceAutoAdvance()
		return nil
	case billingworkflowconfig.FieldInvoiceDraftPeriod:
		m.ResetInvoiceDraftPeriod()
		return nil
	case billingworkflowconfig.FieldInvoiceDueAfter:
		m.ResetInvoiceDueAfter()
		return nil
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		m.ResetInvoiceCollectionMethod()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingWorkflowConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.billing_invoices != nil {
		edges = append(edges, billingworkflowconfig.EdgeBillingInvoices)
	}
	if m.billing_profile != nil {
		edges = append(edges, billingworkflowconfig.EdgeBillingProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingWorkflowConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		if id := m.billing_invoices; id != nil {
			return []ent.Value{*id}
		}
	case billingworkflowconfig.EdgeBillingProfile:
		if id := m.billing_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingWorkflowConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingWorkflowConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingWorkflowConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbilling_invoices {
		edges = append(edges, billingworkflowconfig.EdgeBillingInvoices)
	}
	if m.clearedbilling_profile {
		edges = append(edges, billingworkflowconfig.EdgeBillingProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingWorkflowConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		return m.clearedbilling_invoices
	case billingworkflowconfig.EdgeBillingProfile:
		return m.clearedbilling_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ClearEdge(name string) error {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		m.ClearBillingInvoices()
		return nil
	case billingworkflowconfig.EdgeBillingProfile:
		m.ClearBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ResetEdge(name string) error {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		m.ResetBillingInvoices()
		return nil
	case billingworkflowconfig.EdgeBillingProfile:
		m.ResetBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	namespace                        *string
	metadata                         *map[string]string
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	name                             *string
	description                      *string
	billing_address_country          *models.CountryCode
	billing_address_postal_code      *string
	billing_address_state            *string
	billing_address_city             *string
	billing_address_line1            *string
	billing_address_line2            *string
	billing_address_phone_number     *string
	primary_email                    *string
	timezone                         *timezone.Timezone
	currency                         *currencyx.Code
	clearedFields                    map[string]struct{}
	apps                             map[int]struct{}
	removedapps                      map[int]struct{}
	clearedapps                      bool
	subjects                         map[int]struct{}
	removedsubjects                  map[int]struct{}
	clearedsubjects                  bool
	billing_customer_override        *string
	clearedbilling_customer_override bool
	billing_invoice                  map[string]struct{}
	removedbilling_invoice           map[string]struct{}
	clearedbilling_invoice           bool
	subscription                     map[string]struct{}
	removedsubscription              map[string]struct{}
	clearedsubscription              bool
	done                             bool
	oldValue                         func(context.Context) (*Customer, error)
	predicates                       []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id string) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Customer entities.
func (m *CustomerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *CustomerMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *CustomerMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *CustomerMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *CustomerMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CustomerMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CustomerMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[customer.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CustomerMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[customer.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CustomerMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, customer.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CustomerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CustomerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[customer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, customer.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CustomerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CustomerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CustomerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[customer.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CustomerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[customer.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CustomerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, customer.FieldDescription)
}

// SetBillingAddressCountry sets the "billing_address_country" field.
func (m *CustomerMutation) SetBillingAddressCountry(mc models.CountryCode) {
	m.billing_address_country = &mc
}

// BillingAddressCountry returns the value of the "billing_address_country" field in the mutation.
func (m *CustomerMutation) BillingAddressCountry() (r models.CountryCode, exists bool) {
	v := m.billing_address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressCountry returns the old "billing_address_country" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressCountry(ctx context.Context) (v *models.CountryCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressCountry: %w", err)
	}
	return oldValue.BillingAddressCountry, nil
}

// ClearBillingAddressCountry clears the value of the "billing_address_country" field.
func (m *CustomerMutation) ClearBillingAddressCountry() {
	m.billing_address_country = nil
	m.clearedFields[customer.FieldBillingAddressCountry] = struct{}{}
}

// BillingAddressCountryCleared returns if the "billing_address_country" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressCountryCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressCountry]
	return ok
}

// ResetBillingAddressCountry resets all changes to the "billing_address_country" field.
func (m *CustomerMutation) ResetBillingAddressCountry() {
	m.billing_address_country = nil
	delete(m.clearedFields, customer.FieldBillingAddressCountry)
}

// SetBillingAddressPostalCode sets the "billing_address_postal_code" field.
func (m *CustomerMutation) SetBillingAddressPostalCode(s string) {
	m.billing_address_postal_code = &s
}

// BillingAddressPostalCode returns the value of the "billing_address_postal_code" field in the mutation.
func (m *CustomerMutation) BillingAddressPostalCode() (r string, exists bool) {
	v := m.billing_address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressPostalCode returns the old "billing_address_postal_code" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressPostalCode: %w", err)
	}
	return oldValue.BillingAddressPostalCode, nil
}

// ClearBillingAddressPostalCode clears the value of the "billing_address_postal_code" field.
func (m *CustomerMutation) ClearBillingAddressPostalCode() {
	m.billing_address_postal_code = nil
	m.clearedFields[customer.FieldBillingAddressPostalCode] = struct{}{}
}

// BillingAddressPostalCodeCleared returns if the "billing_address_postal_code" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressPostalCode]
	return ok
}

// ResetBillingAddressPostalCode resets all changes to the "billing_address_postal_code" field.
func (m *CustomerMutation) ResetBillingAddressPostalCode() {
	m.billing_address_postal_code = nil
	delete(m.clearedFields, customer.FieldBillingAddressPostalCode)
}

// SetBillingAddressState sets the "billing_address_state" field.
func (m *CustomerMutation) SetBillingAddressState(s string) {
	m.billing_address_state = &s
}

// BillingAddressState returns the value of the "billing_address_state" field in the mutation.
func (m *CustomerMutation) BillingAddressState() (r string, exists bool) {
	v := m.billing_address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressState returns the old "billing_address_state" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressState: %w", err)
	}
	return oldValue.BillingAddressState, nil
}

// ClearBillingAddressState clears the value of the "billing_address_state" field.
func (m *CustomerMutation) ClearBillingAddressState() {
	m.billing_address_state = nil
	m.clearedFields[customer.FieldBillingAddressState] = struct{}{}
}

// BillingAddressStateCleared returns if the "billing_address_state" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressStateCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressState]
	return ok
}

// ResetBillingAddressState resets all changes to the "billing_address_state" field.
func (m *CustomerMutation) ResetBillingAddressState() {
	m.billing_address_state = nil
	delete(m.clearedFields, customer.FieldBillingAddressState)
}

// SetBillingAddressCity sets the "billing_address_city" field.
func (m *CustomerMutation) SetBillingAddressCity(s string) {
	m.billing_address_city = &s
}

// BillingAddressCity returns the value of the "billing_address_city" field in the mutation.
func (m *CustomerMutation) BillingAddressCity() (r string, exists bool) {
	v := m.billing_address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressCity returns the old "billing_address_city" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressCity: %w", err)
	}
	return oldValue.BillingAddressCity, nil
}

// ClearBillingAddressCity clears the value of the "billing_address_city" field.
func (m *CustomerMutation) ClearBillingAddressCity() {
	m.billing_address_city = nil
	m.clearedFields[customer.FieldBillingAddressCity] = struct{}{}
}

// BillingAddressCityCleared returns if the "billing_address_city" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressCityCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressCity]
	return ok
}

// ResetBillingAddressCity resets all changes to the "billing_address_city" field.
func (m *CustomerMutation) ResetBillingAddressCity() {
	m.billing_address_city = nil
	delete(m.clearedFields, customer.FieldBillingAddressCity)
}

// SetBillingAddressLine1 sets the "billing_address_line1" field.
func (m *CustomerMutation) SetBillingAddressLine1(s string) {
	m.billing_address_line1 = &s
}

// BillingAddressLine1 returns the value of the "billing_address_line1" field in the mutation.
func (m *CustomerMutation) BillingAddressLine1() (r string, exists bool) {
	v := m.billing_address_line1
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressLine1 returns the old "billing_address_line1" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressLine1: %w", err)
	}
	return oldValue.BillingAddressLine1, nil
}

// ClearBillingAddressLine1 clears the value of the "billing_address_line1" field.
func (m *CustomerMutation) ClearBillingAddressLine1() {
	m.billing_address_line1 = nil
	m.clearedFields[customer.FieldBillingAddressLine1] = struct{}{}
}

// BillingAddressLine1Cleared returns if the "billing_address_line1" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressLine1Cleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressLine1]
	return ok
}

// ResetBillingAddressLine1 resets all changes to the "billing_address_line1" field.
func (m *CustomerMutation) ResetBillingAddressLine1() {
	m.billing_address_line1 = nil
	delete(m.clearedFields, customer.FieldBillingAddressLine1)
}

// SetBillingAddressLine2 sets the "billing_address_line2" field.
func (m *CustomerMutation) SetBillingAddressLine2(s string) {
	m.billing_address_line2 = &s
}

// BillingAddressLine2 returns the value of the "billing_address_line2" field in the mutation.
func (m *CustomerMutation) BillingAddressLine2() (r string, exists bool) {
	v := m.billing_address_line2
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressLine2 returns the old "billing_address_line2" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressLine2: %w", err)
	}
	return oldValue.BillingAddressLine2, nil
}

// ClearBillingAddressLine2 clears the value of the "billing_address_line2" field.
func (m *CustomerMutation) ClearBillingAddressLine2() {
	m.billing_address_line2 = nil
	m.clearedFields[customer.FieldBillingAddressLine2] = struct{}{}
}

// BillingAddressLine2Cleared returns if the "billing_address_line2" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressLine2Cleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressLine2]
	return ok
}

// ResetBillingAddressLine2 resets all changes to the "billing_address_line2" field.
func (m *CustomerMutation) ResetBillingAddressLine2() {
	m.billing_address_line2 = nil
	delete(m.clearedFields, customer.FieldBillingAddressLine2)
}

// SetBillingAddressPhoneNumber sets the "billing_address_phone_number" field.
func (m *CustomerMutation) SetBillingAddressPhoneNumber(s string) {
	m.billing_address_phone_number = &s
}

// BillingAddressPhoneNumber returns the value of the "billing_address_phone_number" field in the mutation.
func (m *CustomerMutation) BillingAddressPhoneNumber() (r string, exists bool) {
	v := m.billing_address_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressPhoneNumber returns the old "billing_address_phone_number" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressPhoneNumber: %w", err)
	}
	return oldValue.BillingAddressPhoneNumber, nil
}

// ClearBillingAddressPhoneNumber clears the value of the "billing_address_phone_number" field.
func (m *CustomerMutation) ClearBillingAddressPhoneNumber() {
	m.billing_address_phone_number = nil
	m.clearedFields[customer.FieldBillingAddressPhoneNumber] = struct{}{}
}

// BillingAddressPhoneNumberCleared returns if the "billing_address_phone_number" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressPhoneNumberCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressPhoneNumber]
	return ok
}

// ResetBillingAddressPhoneNumber resets all changes to the "billing_address_phone_number" field.
func (m *CustomerMutation) ResetBillingAddressPhoneNumber() {
	m.billing_address_phone_number = nil
	delete(m.clearedFields, customer.FieldBillingAddressPhoneNumber)
}

// SetPrimaryEmail sets the "primary_email" field.
func (m *CustomerMutation) SetPrimaryEmail(s string) {
	m.primary_email = &s
}

// PrimaryEmail returns the value of the "primary_email" field in the mutation.
func (m *CustomerMutation) PrimaryEmail() (r string, exists bool) {
	v := m.primary_email
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryEmail returns the old "primary_email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPrimaryEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryEmail: %w", err)
	}
	return oldValue.PrimaryEmail, nil
}

// ClearPrimaryEmail clears the value of the "primary_email" field.
func (m *CustomerMutation) ClearPrimaryEmail() {
	m.primary_email = nil
	m.clearedFields[customer.FieldPrimaryEmail] = struct{}{}
}

// PrimaryEmailCleared returns if the "primary_email" field was cleared in this mutation.
func (m *CustomerMutation) PrimaryEmailCleared() bool {
	_, ok := m.clearedFields[customer.FieldPrimaryEmail]
	return ok
}

// ResetPrimaryEmail resets all changes to the "primary_email" field.
func (m *CustomerMutation) ResetPrimaryEmail() {
	m.primary_email = nil
	delete(m.clearedFields, customer.FieldPrimaryEmail)
}

// SetTimezone sets the "timezone" field.
func (m *CustomerMutation) SetTimezone(t timezone.Timezone) {
	m.timezone = &t
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *CustomerMutation) Timezone() (r timezone.Timezone, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldTimezone(ctx context.Context) (v *timezone.Timezone, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *CustomerMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[customer.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *CustomerMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[customer.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *CustomerMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, customer.FieldTimezone)
}

// SetCurrency sets the "currency" field.
func (m *CustomerMutation) SetCurrency(c currencyx.Code) {
	m.currency = &c
}

// Currency returns the value of the "currency" field in the mutation.
func (m *CustomerMutation) Currency() (r currencyx.Code, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCurrency(ctx context.Context) (v *currencyx.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *CustomerMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[customer.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *CustomerMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[customer.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *CustomerMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, customer.FieldCurrency)
}

// AddAppIDs adds the "apps" edge to the AppCustomer entity by ids.
func (m *CustomerMutation) AddAppIDs(ids ...int) {
	if m.apps == nil {
		m.apps = make(map[int]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the AppCustomer entity.
func (m *CustomerMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the AppCustomer entity was cleared.
func (m *CustomerMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the AppCustomer entity by IDs.
func (m *CustomerMutation) RemoveAppIDs(ids ...int) {
	if m.removedapps == nil {
		m.removedapps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the AppCustomer entity.
func (m *CustomerMutation) RemovedAppsIDs() (ids []int) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *CustomerMutation) AppsIDs() (ids []int) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *CustomerMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// AddSubjectIDs adds the "subjects" edge to the CustomerSubjects entity by ids.
func (m *CustomerMutation) AddSubjectIDs(ids ...int) {
	if m.subjects == nil {
		m.subjects = make(map[int]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the CustomerSubjects entity.
func (m *CustomerMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the CustomerSubjects entity was cleared.
func (m *CustomerMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the CustomerSubjects entity by IDs.
func (m *CustomerMutation) RemoveSubjectIDs(ids ...int) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the CustomerSubjects entity.
func (m *CustomerMutation) RemovedSubjectsIDs() (ids []int) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *CustomerMutation) SubjectsIDs() (ids []int) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *CustomerMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// SetBillingCustomerOverrideID sets the "billing_customer_override" edge to the BillingCustomerOverride entity by id.
func (m *CustomerMutation) SetBillingCustomerOverrideID(id string) {
	m.billing_customer_override = &id
}

// ClearBillingCustomerOverride clears the "billing_customer_override" edge to the BillingCustomerOverride entity.
func (m *CustomerMutation) ClearBillingCustomerOverride() {
	m.clearedbilling_customer_override = true
}

// BillingCustomerOverrideCleared reports if the "billing_customer_override" edge to the BillingCustomerOverride entity was cleared.
func (m *CustomerMutation) BillingCustomerOverrideCleared() bool {
	return m.clearedbilling_customer_override
}

// BillingCustomerOverrideID returns the "billing_customer_override" edge ID in the mutation.
func (m *CustomerMutation) BillingCustomerOverrideID() (id string, exists bool) {
	if m.billing_customer_override != nil {
		return *m.billing_customer_override, true
	}
	return
}

// BillingCustomerOverrideIDs returns the "billing_customer_override" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingCustomerOverrideID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) BillingCustomerOverrideIDs() (ids []string) {
	if id := m.billing_customer_override; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingCustomerOverride resets all changes to the "billing_customer_override" edge.
func (m *CustomerMutation) ResetBillingCustomerOverride() {
	m.billing_customer_override = nil
	m.clearedbilling_customer_override = false
}

// AddBillingInvoiceIDs adds the "billing_invoice" edge to the BillingInvoice entity by ids.
func (m *CustomerMutation) AddBillingInvoiceIDs(ids ...string) {
	if m.billing_invoice == nil {
		m.billing_invoice = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoice clears the "billing_invoice" edge to the BillingInvoice entity.
func (m *CustomerMutation) ClearBillingInvoice() {
	m.clearedbilling_invoice = true
}

// BillingInvoiceCleared reports if the "billing_invoice" edge to the BillingInvoice entity was cleared.
func (m *CustomerMutation) BillingInvoiceCleared() bool {
	return m.clearedbilling_invoice
}

// RemoveBillingInvoiceIDs removes the "billing_invoice" edge to the BillingInvoice entity by IDs.
func (m *CustomerMutation) RemoveBillingInvoiceIDs(ids ...string) {
	if m.removedbilling_invoice == nil {
		m.removedbilling_invoice = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice, ids[i])
		m.removedbilling_invoice[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoice returns the removed IDs of the "billing_invoice" edge to the BillingInvoice entity.
func (m *CustomerMutation) RemovedBillingInvoiceIDs() (ids []string) {
	for id := range m.removedbilling_invoice {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceIDs returns the "billing_invoice" edge IDs in the mutation.
func (m *CustomerMutation) BillingInvoiceIDs() (ids []string) {
	for id := range m.billing_invoice {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoice resets all changes to the "billing_invoice" edge.
func (m *CustomerMutation) ResetBillingInvoice() {
	m.billing_invoice = nil
	m.clearedbilling_invoice = false
	m.removedbilling_invoice = nil
}

// AddSubscriptionIDs adds the "subscription" edge to the Subscription entity by ids.
func (m *CustomerMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscription == nil {
		m.subscription = make(map[string]struct{})
	}
	for i := range ids {
		m.subscription[ids[i]] = struct{}{}
	}
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *CustomerMutation) ClearSubscription() {
	m.clearedsubscription = true
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *CustomerMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// RemoveSubscriptionIDs removes the "subscription" edge to the Subscription entity by IDs.
func (m *CustomerMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscription == nil {
		m.removedsubscription = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscription, ids[i])
		m.removedsubscription[ids[i]] = struct{}{}
	}
}

// RemovedSubscription returns the removed IDs of the "subscription" edge to the Subscription entity.
func (m *CustomerMutation) RemovedSubscriptionIDs() (ids []string) {
	for id := range m.removedsubscription {
		ids = append(ids, id)
	}
	return
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
func (m *CustomerMutation) SubscriptionIDs() (ids []string) {
	for id := range m.subscription {
		ids = append(ids, id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *CustomerMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
	m.removedsubscription = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.namespace != nil {
		fields = append(fields, customer.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, customer.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.description != nil {
		fields = append(fields, customer.FieldDescription)
	}
	if m.billing_address_country != nil {
		fields = append(fields, customer.FieldBillingAddressCountry)
	}
	if m.billing_address_postal_code != nil {
		fields = append(fields, customer.FieldBillingAddressPostalCode)
	}
	if m.billing_address_state != nil {
		fields = append(fields, customer.FieldBillingAddressState)
	}
	if m.billing_address_city != nil {
		fields = append(fields, customer.FieldBillingAddressCity)
	}
	if m.billing_address_line1 != nil {
		fields = append(fields, customer.FieldBillingAddressLine1)
	}
	if m.billing_address_line2 != nil {
		fields = append(fields, customer.FieldBillingAddressLine2)
	}
	if m.billing_address_phone_number != nil {
		fields = append(fields, customer.FieldBillingAddressPhoneNumber)
	}
	if m.primary_email != nil {
		fields = append(fields, customer.FieldPrimaryEmail)
	}
	if m.timezone != nil {
		fields = append(fields, customer.FieldTimezone)
	}
	if m.currency != nil {
		fields = append(fields, customer.FieldCurrency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldNamespace:
		return m.Namespace()
	case customer.FieldMetadata:
		return m.Metadata()
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldDeletedAt:
		return m.DeletedAt()
	case customer.FieldName:
		return m.Name()
	case customer.FieldDescription:
		return m.Description()
	case customer.FieldBillingAddressCountry:
		return m.BillingAddressCountry()
	case customer.FieldBillingAddressPostalCode:
		return m.BillingAddressPostalCode()
	case customer.FieldBillingAddressState:
		return m.BillingAddressState()
	case customer.FieldBillingAddressCity:
		return m.BillingAddressCity()
	case customer.FieldBillingAddressLine1:
		return m.BillingAddressLine1()
	case customer.FieldBillingAddressLine2:
		return m.BillingAddressLine2()
	case customer.FieldBillingAddressPhoneNumber:
		return m.BillingAddressPhoneNumber()
	case customer.FieldPrimaryEmail:
		return m.PrimaryEmail()
	case customer.FieldTimezone:
		return m.Timezone()
	case customer.FieldCurrency:
		return m.Currency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldNamespace:
		return m.OldNamespace(ctx)
	case customer.FieldMetadata:
		return m.OldMetadata(ctx)
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldDescription:
		return m.OldDescription(ctx)
	case customer.FieldBillingAddressCountry:
		return m.OldBillingAddressCountry(ctx)
	case customer.FieldBillingAddressPostalCode:
		return m.OldBillingAddressPostalCode(ctx)
	case customer.FieldBillingAddressState:
		return m.OldBillingAddressState(ctx)
	case customer.FieldBillingAddressCity:
		return m.OldBillingAddressCity(ctx)
	case customer.FieldBillingAddressLine1:
		return m.OldBillingAddressLine1(ctx)
	case customer.FieldBillingAddressLine2:
		return m.OldBillingAddressLine2(ctx)
	case customer.FieldBillingAddressPhoneNumber:
		return m.OldBillingAddressPhoneNumber(ctx)
	case customer.FieldPrimaryEmail:
		return m.OldPrimaryEmail(ctx)
	case customer.FieldTimezone:
		return m.OldTimezone(ctx)
	case customer.FieldCurrency:
		return m.OldCurrency(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case customer.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case customer.FieldBillingAddressCountry:
		v, ok := value.(models.CountryCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressCountry(v)
		return nil
	case customer.FieldBillingAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressPostalCode(v)
		return nil
	case customer.FieldBillingAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressState(v)
		return nil
	case customer.FieldBillingAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressCity(v)
		return nil
	case customer.FieldBillingAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressLine1(v)
		return nil
	case customer.FieldBillingAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressLine2(v)
		return nil
	case customer.FieldBillingAddressPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressPhoneNumber(v)
		return nil
	case customer.FieldPrimaryEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryEmail(v)
		return nil
	case customer.FieldTimezone:
		v, ok := value.(timezone.Timezone)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case customer.FieldCurrency:
		v, ok := value.(currencyx.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldMetadata) {
		fields = append(fields, customer.FieldMetadata)
	}
	if m.FieldCleared(customer.FieldDeletedAt) {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.FieldCleared(customer.FieldDescription) {
		fields = append(fields, customer.FieldDescription)
	}
	if m.FieldCleared(customer.FieldBillingAddressCountry) {
		fields = append(fields, customer.FieldBillingAddressCountry)
	}
	if m.FieldCleared(customer.FieldBillingAddressPostalCode) {
		fields = append(fields, customer.FieldBillingAddressPostalCode)
	}
	if m.FieldCleared(customer.FieldBillingAddressState) {
		fields = append(fields, customer.FieldBillingAddressState)
	}
	if m.FieldCleared(customer.FieldBillingAddressCity) {
		fields = append(fields, customer.FieldBillingAddressCity)
	}
	if m.FieldCleared(customer.FieldBillingAddressLine1) {
		fields = append(fields, customer.FieldBillingAddressLine1)
	}
	if m.FieldCleared(customer.FieldBillingAddressLine2) {
		fields = append(fields, customer.FieldBillingAddressLine2)
	}
	if m.FieldCleared(customer.FieldBillingAddressPhoneNumber) {
		fields = append(fields, customer.FieldBillingAddressPhoneNumber)
	}
	if m.FieldCleared(customer.FieldPrimaryEmail) {
		fields = append(fields, customer.FieldPrimaryEmail)
	}
	if m.FieldCleared(customer.FieldTimezone) {
		fields = append(fields, customer.FieldTimezone)
	}
	if m.FieldCleared(customer.FieldCurrency) {
		fields = append(fields, customer.FieldCurrency)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldMetadata:
		m.ClearMetadata()
		return nil
	case customer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case customer.FieldDescription:
		m.ClearDescription()
		return nil
	case customer.FieldBillingAddressCountry:
		m.ClearBillingAddressCountry()
		return nil
	case customer.FieldBillingAddressPostalCode:
		m.ClearBillingAddressPostalCode()
		return nil
	case customer.FieldBillingAddressState:
		m.ClearBillingAddressState()
		return nil
	case customer.FieldBillingAddressCity:
		m.ClearBillingAddressCity()
		return nil
	case customer.FieldBillingAddressLine1:
		m.ClearBillingAddressLine1()
		return nil
	case customer.FieldBillingAddressLine2:
		m.ClearBillingAddressLine2()
		return nil
	case customer.FieldBillingAddressPhoneNumber:
		m.ClearBillingAddressPhoneNumber()
		return nil
	case customer.FieldPrimaryEmail:
		m.ClearPrimaryEmail()
		return nil
	case customer.FieldTimezone:
		m.ClearTimezone()
		return nil
	case customer.FieldCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldNamespace:
		m.ResetNamespace()
		return nil
	case customer.FieldMetadata:
		m.ResetMetadata()
		return nil
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldDescription:
		m.ResetDescription()
		return nil
	case customer.FieldBillingAddressCountry:
		m.ResetBillingAddressCountry()
		return nil
	case customer.FieldBillingAddressPostalCode:
		m.ResetBillingAddressPostalCode()
		return nil
	case customer.FieldBillingAddressState:
		m.ResetBillingAddressState()
		return nil
	case customer.FieldBillingAddressCity:
		m.ResetBillingAddressCity()
		return nil
	case customer.FieldBillingAddressLine1:
		m.ResetBillingAddressLine1()
		return nil
	case customer.FieldBillingAddressLine2:
		m.ResetBillingAddressLine2()
		return nil
	case customer.FieldBillingAddressPhoneNumber:
		m.ResetBillingAddressPhoneNumber()
		return nil
	case customer.FieldPrimaryEmail:
		m.ResetPrimaryEmail()
		return nil
	case customer.FieldTimezone:
		m.ResetTimezone()
		return nil
	case customer.FieldCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.apps != nil {
		edges = append(edges, customer.EdgeApps)
	}
	if m.subjects != nil {
		edges = append(edges, customer.EdgeSubjects)
	}
	if m.billing_customer_override != nil {
		edges = append(edges, customer.EdgeBillingCustomerOverride)
	}
	if m.billing_invoice != nil {
		edges = append(edges, customer.EdgeBillingInvoice)
	}
	if m.subscription != nil {
		edges = append(edges, customer.EdgeSubscription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeBillingCustomerOverride:
		if id := m.billing_customer_override; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeBillingInvoice:
		ids := make([]ent.Value, 0, len(m.billing_invoice))
		for id := range m.billing_invoice {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSubscription:
		ids := make([]ent.Value, 0, len(m.subscription))
		for id := range m.subscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedapps != nil {
		edges = append(edges, customer.EdgeApps)
	}
	if m.removedsubjects != nil {
		edges = append(edges, customer.EdgeSubjects)
	}
	if m.removedbilling_invoice != nil {
		edges = append(edges, customer.EdgeBillingInvoice)
	}
	if m.removedsubscription != nil {
		edges = append(edges, customer.EdgeSubscription)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeBillingInvoice:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice))
		for id := range m.removedbilling_invoice {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSubscription:
		ids := make([]ent.Value, 0, len(m.removedsubscription))
		for id := range m.removedsubscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedapps {
		edges = append(edges, customer.EdgeApps)
	}
	if m.clearedsubjects {
		edges = append(edges, customer.EdgeSubjects)
	}
	if m.clearedbilling_customer_override {
		edges = append(edges, customer.EdgeBillingCustomerOverride)
	}
	if m.clearedbilling_invoice {
		edges = append(edges, customer.EdgeBillingInvoice)
	}
	if m.clearedsubscription {
		edges = append(edges, customer.EdgeSubscription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeApps:
		return m.clearedapps
	case customer.EdgeSubjects:
		return m.clearedsubjects
	case customer.EdgeBillingCustomerOverride:
		return m.clearedbilling_customer_override
	case customer.EdgeBillingInvoice:
		return m.clearedbilling_invoice
	case customer.EdgeSubscription:
		return m.clearedsubscription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeBillingCustomerOverride:
		m.ClearBillingCustomerOverride()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeApps:
		m.ResetApps()
		return nil
	case customer.EdgeSubjects:
		m.ResetSubjects()
		return nil
	case customer.EdgeBillingCustomerOverride:
		m.ResetBillingCustomerOverride()
		return nil
	case customer.EdgeBillingInvoice:
		m.ResetBillingInvoice()
		return nil
	case customer.EdgeSubscription:
		m.ResetSubscription()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// CustomerSubjectsMutation represents an operation that mutates the CustomerSubjects nodes in the graph.
type CustomerSubjectsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	namespace       *string
	subject_key     *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	customer        *string
	clearedcustomer bool
	done            bool
	oldValue        func(context.Context) (*CustomerSubjects, error)
	predicates      []predicate.CustomerSubjects
}

var _ ent.Mutation = (*CustomerSubjectsMutation)(nil)

// customersubjectsOption allows management of the mutation configuration using functional options.
type customersubjectsOption func(*CustomerSubjectsMutation)

// newCustomerSubjectsMutation creates new mutation for the CustomerSubjects entity.
func newCustomerSubjectsMutation(c config, op Op, opts ...customersubjectsOption) *CustomerSubjectsMutation {
	m := &CustomerSubjectsMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerSubjects,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerSubjectsID sets the ID field of the mutation.
func withCustomerSubjectsID(id int) customersubjectsOption {
	return func(m *CustomerSubjectsMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerSubjects
		)
		m.oldValue = func(ctx context.Context) (*CustomerSubjects, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerSubjects.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerSubjects sets the old CustomerSubjects of the mutation.
func withCustomerSubjects(node *CustomerSubjects) customersubjectsOption {
	return func(m *CustomerSubjectsMutation) {
		m.oldValue = func(context.Context) (*CustomerSubjects, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerSubjectsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerSubjectsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerSubjectsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerSubjectsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerSubjects.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *CustomerSubjectsMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *CustomerSubjectsMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *CustomerSubjectsMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerSubjectsMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerSubjectsMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerSubjectsMutation) ResetCustomerID() {
	m.customer = nil
}

// SetSubjectKey sets the "subject_key" field.
func (m *CustomerSubjectsMutation) SetSubjectKey(s string) {
	m.subject_key = &s
}

// SubjectKey returns the value of the "subject_key" field in the mutation.
func (m *CustomerSubjectsMutation) SubjectKey() (r string, exists bool) {
	v := m.subject_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectKey returns the old "subject_key" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldSubjectKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectKey: %w", err)
	}
	return oldValue.SubjectKey, nil
}

// ResetSubjectKey resets all changes to the "subject_key" field.
func (m *CustomerSubjectsMutation) ResetSubjectKey() {
	m.subject_key = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerSubjectsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerSubjectsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerSubjectsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerSubjectsMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customersubjects.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerSubjectsMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerSubjectsMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerSubjectsMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the CustomerSubjectsMutation builder.
func (m *CustomerSubjectsMutation) Where(ps ...predicate.CustomerSubjects) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerSubjectsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerSubjectsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerSubjects, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerSubjectsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerSubjectsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerSubjects).
func (m *CustomerSubjectsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerSubjectsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.namespace != nil {
		fields = append(fields, customersubjects.FieldNamespace)
	}
	if m.customer != nil {
		fields = append(fields, customersubjects.FieldCustomerID)
	}
	if m.subject_key != nil {
		fields = append(fields, customersubjects.FieldSubjectKey)
	}
	if m.created_at != nil {
		fields = append(fields, customersubjects.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerSubjectsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customersubjects.FieldNamespace:
		return m.Namespace()
	case customersubjects.FieldCustomerID:
		return m.CustomerID()
	case customersubjects.FieldSubjectKey:
		return m.SubjectKey()
	case customersubjects.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerSubjectsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customersubjects.FieldNamespace:
		return m.OldNamespace(ctx)
	case customersubjects.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customersubjects.FieldSubjectKey:
		return m.OldSubjectKey(ctx)
	case customersubjects.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerSubjects field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerSubjectsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customersubjects.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case customersubjects.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customersubjects.FieldSubjectKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectKey(v)
		return nil
	case customersubjects.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerSubjectsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerSubjectsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerSubjectsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomerSubjects numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerSubjectsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerSubjectsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerSubjectsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CustomerSubjects nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerSubjectsMutation) ResetField(name string) error {
	switch name {
	case customersubjects.FieldNamespace:
		m.ResetNamespace()
		return nil
	case customersubjects.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customersubjects.FieldSubjectKey:
		m.ResetSubjectKey()
		return nil
	case customersubjects.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerSubjectsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.customer != nil {
		edges = append(edges, customersubjects.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerSubjectsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customersubjects.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerSubjectsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerSubjectsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerSubjectsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcustomer {
		edges = append(edges, customersubjects.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerSubjectsMutation) EdgeCleared(name string) bool {
	switch name {
	case customersubjects.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerSubjectsMutation) ClearEdge(name string) error {
	switch name {
	case customersubjects.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerSubjectsMutation) ResetEdge(name string) error {
	switch name {
	case customersubjects.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects edge %s", name)
}

// EntitlementMutation represents an operation that mutates the Entitlement nodes in the graph.
type EntitlementMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	namespace                     *string
	metadata                      *map[string]string
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	entitlement_type              *entitlement.EntitlementType
	active_from                   *time.Time
	active_to                     *time.Time
	feature_key                   *string
	subject_key                   *string
	measure_usage_from            *time.Time
	issue_after_reset             *float64
	addissue_after_reset          *float64
	issue_after_reset_priority    *uint8
	addissue_after_reset_priority *int8
	is_soft_limit                 *bool
	preserve_overage_at_reset     *bool
	_config                       *[]uint8
	append_config                 []uint8
	usage_period_interval         *entitlement.UsagePeriodInterval
	usage_period_anchor           *time.Time
	current_usage_period_start    *time.Time
	current_usage_period_end      *time.Time
	clearedFields                 map[string]struct{}
	usage_reset                   map[string]struct{}
	removedusage_reset            map[string]struct{}
	clearedusage_reset            bool
	grant                         map[string]struct{}
	removedgrant                  map[string]struct{}
	clearedgrant                  bool
	balance_snapshot              map[int]struct{}
	removedbalance_snapshot       map[int]struct{}
	clearedbalance_snapshot       bool
	subscription                  *string
	clearedsubscription           bool
	feature                       *string
	clearedfeature                bool
	done                          bool
	oldValue                      func(context.Context) (*Entitlement, error)
	predicates                    []predicate.Entitlement
}

var _ ent.Mutation = (*EntitlementMutation)(nil)

// entitlementOption allows management of the mutation configuration using functional options.
type entitlementOption func(*EntitlementMutation)

// newEntitlementMutation creates new mutation for the Entitlement entity.
func newEntitlementMutation(c config, op Op, opts ...entitlementOption) *EntitlementMutation {
	m := &EntitlementMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementID sets the ID field of the mutation.
func withEntitlementID(id string) entitlementOption {
	return func(m *EntitlementMutation) {
		var (
			err   error
			once  sync.Once
			value *Entitlement
		)
		m.oldValue = func(ctx context.Context) (*Entitlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entitlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlement sets the old Entitlement of the mutation.
func withEntitlement(node *Entitlement) entitlementOption {
	return func(m *EntitlementMutation) {
		m.oldValue = func(context.Context) (*Entitlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entitlement entities.
func (m *EntitlementMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entitlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *EntitlementMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *EntitlementMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *EntitlementMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *EntitlementMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EntitlementMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EntitlementMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[entitlement.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EntitlementMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EntitlementMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, entitlement.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitlementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitlementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitlementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitlement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitlementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitlementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitlement.FieldDeletedAt)
}

// SetEntitlementType sets the "entitlement_type" field.
func (m *EntitlementMutation) SetEntitlementType(et entitlement.EntitlementType) {
	m.entitlement_type = &et
}

// EntitlementType returns the value of the "entitlement_type" field in the mutation.
func (m *EntitlementMutation) EntitlementType() (r entitlement.EntitlementType, exists bool) {
	v := m.entitlement_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementType returns the old "entitlement_type" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldEntitlementType(ctx context.Context) (v entitlement.EntitlementType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementType: %w", err)
	}
	return oldValue.EntitlementType, nil
}

// ResetEntitlementType resets all changes to the "entitlement_type" field.
func (m *EntitlementMutation) ResetEntitlementType() {
	m.entitlement_type = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *EntitlementMutation) SetFeatureID(s string) {
	m.feature = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *EntitlementMutation) FeatureID() (r string, exists bool) {
	v := m.feature
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldFeatureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *EntitlementMutation) ResetFeatureID() {
	m.feature = nil
}

// SetActiveFrom sets the "active_from" field.
func (m *EntitlementMutation) SetActiveFrom(t time.Time) {
	m.active_from = &t
}

// ActiveFrom returns the value of the "active_from" field in the mutation.
func (m *EntitlementMutation) ActiveFrom() (r time.Time, exists bool) {
	v := m.active_from
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveFrom returns the old "active_from" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldActiveFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveFrom: %w", err)
	}
	return oldValue.ActiveFrom, nil
}

// ClearActiveFrom clears the value of the "active_from" field.
func (m *EntitlementMutation) ClearActiveFrom() {
	m.active_from = nil
	m.clearedFields[entitlement.FieldActiveFrom] = struct{}{}
}

// ActiveFromCleared returns if the "active_from" field was cleared in this mutation.
func (m *EntitlementMutation) ActiveFromCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldActiveFrom]
	return ok
}

// ResetActiveFrom resets all changes to the "active_from" field.
func (m *EntitlementMutation) ResetActiveFrom() {
	m.active_from = nil
	delete(m.clearedFields, entitlement.FieldActiveFrom)
}

// SetActiveTo sets the "active_to" field.
func (m *EntitlementMutation) SetActiveTo(t time.Time) {
	m.active_to = &t
}

// ActiveTo returns the value of the "active_to" field in the mutation.
func (m *EntitlementMutation) ActiveTo() (r time.Time, exists bool) {
	v := m.active_to
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveTo returns the old "active_to" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldActiveTo(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveTo: %w", err)
	}
	return oldValue.ActiveTo, nil
}

// ClearActiveTo clears the value of the "active_to" field.
func (m *EntitlementMutation) ClearActiveTo() {
	m.active_to = nil
	m.clearedFields[entitlement.FieldActiveTo] = struct{}{}
}

// ActiveToCleared returns if the "active_to" field was cleared in this mutation.
func (m *EntitlementMutation) ActiveToCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldActiveTo]
	return ok
}

// ResetActiveTo resets all changes to the "active_to" field.
func (m *EntitlementMutation) ResetActiveTo() {
	m.active_to = nil
	delete(m.clearedFields, entitlement.FieldActiveTo)
}

// SetFeatureKey sets the "feature_key" field.
func (m *EntitlementMutation) SetFeatureKey(s string) {
	m.feature_key = &s
}

// FeatureKey returns the value of the "feature_key" field in the mutation.
func (m *EntitlementMutation) FeatureKey() (r string, exists bool) {
	v := m.feature_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureKey returns the old "feature_key" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldFeatureKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureKey: %w", err)
	}
	return oldValue.FeatureKey, nil
}

// ResetFeatureKey resets all changes to the "feature_key" field.
func (m *EntitlementMutation) ResetFeatureKey() {
	m.feature_key = nil
}

// SetSubjectKey sets the "subject_key" field.
func (m *EntitlementMutation) SetSubjectKey(s string) {
	m.subject_key = &s
}

// SubjectKey returns the value of the "subject_key" field in the mutation.
func (m *EntitlementMutation) SubjectKey() (r string, exists bool) {
	v := m.subject_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectKey returns the old "subject_key" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldSubjectKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectKey: %w", err)
	}
	return oldValue.SubjectKey, nil
}

// ResetSubjectKey resets all changes to the "subject_key" field.
func (m *EntitlementMutation) ResetSubjectKey() {
	m.subject_key = nil
}

// SetMeasureUsageFrom sets the "measure_usage_from" field.
func (m *EntitlementMutation) SetMeasureUsageFrom(t time.Time) {
	m.measure_usage_from = &t
}

// MeasureUsageFrom returns the value of the "measure_usage_from" field in the mutation.
func (m *EntitlementMutation) MeasureUsageFrom() (r time.Time, exists bool) {
	v := m.measure_usage_from
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasureUsageFrom returns the old "measure_usage_from" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldMeasureUsageFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasureUsageFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasureUsageFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasureUsageFrom: %w", err)
	}
	return oldValue.MeasureUsageFrom, nil
}

// ClearMeasureUsageFrom clears the value of the "measure_usage_from" field.
func (m *EntitlementMutation) ClearMeasureUsageFrom() {
	m.measure_usage_from = nil
	m.clearedFields[entitlement.FieldMeasureUsageFrom] = struct{}{}
}

// MeasureUsageFromCleared returns if the "measure_usage_from" field was cleared in this mutation.
func (m *EntitlementMutation) MeasureUsageFromCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldMeasureUsageFrom]
	return ok
}

// ResetMeasureUsageFrom resets all changes to the "measure_usage_from" field.
func (m *EntitlementMutation) ResetMeasureUsageFrom() {
	m.measure_usage_from = nil
	delete(m.clearedFields, entitlement.FieldMeasureUsageFrom)
}

// SetIssueAfterReset sets the "issue_after_reset" field.
func (m *EntitlementMutation) SetIssueAfterReset(f float64) {
	m.issue_after_reset = &f
	m.addissue_after_reset = nil
}

// IssueAfterReset returns the value of the "issue_after_reset" field in the mutation.
func (m *EntitlementMutation) IssueAfterReset() (r float64, exists bool) {
	v := m.issue_after_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueAfterReset returns the old "issue_after_reset" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIssueAfterReset(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueAfterReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueAfterReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueAfterReset: %w", err)
	}
	return oldValue.IssueAfterReset, nil
}

// AddIssueAfterReset adds f to the "issue_after_reset" field.
func (m *EntitlementMutation) AddIssueAfterReset(f float64) {
	if m.addissue_after_reset != nil {
		*m.addissue_after_reset += f
	} else {
		m.addissue_after_reset = &f
	}
}

// AddedIssueAfterReset returns the value that was added to the "issue_after_reset" field in this mutation.
func (m *EntitlementMutation) AddedIssueAfterReset() (r float64, exists bool) {
	v := m.addissue_after_reset
	if v == nil {
		return
	}
	return *v, true
}

// ClearIssueAfterReset clears the value of the "issue_after_reset" field.
func (m *EntitlementMutation) ClearIssueAfterReset() {
	m.issue_after_reset = nil
	m.addissue_after_reset = nil
	m.clearedFields[entitlement.FieldIssueAfterReset] = struct{}{}
}

// IssueAfterResetCleared returns if the "issue_after_reset" field was cleared in this mutation.
func (m *EntitlementMutation) IssueAfterResetCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIssueAfterReset]
	return ok
}

// ResetIssueAfterReset resets all changes to the "issue_after_reset" field.
func (m *EntitlementMutation) ResetIssueAfterReset() {
	m.issue_after_reset = nil
	m.addissue_after_reset = nil
	delete(m.clearedFields, entitlement.FieldIssueAfterReset)
}

// SetIssueAfterResetPriority sets the "issue_after_reset_priority" field.
func (m *EntitlementMutation) SetIssueAfterResetPriority(u uint8) {
	m.issue_after_reset_priority = &u
	m.addissue_after_reset_priority = nil
}

// IssueAfterResetPriority returns the value of the "issue_after_reset_priority" field in the mutation.
func (m *EntitlementMutation) IssueAfterResetPriority() (r uint8, exists bool) {
	v := m.issue_after_reset_priority
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueAfterResetPriority returns the old "issue_after_reset_priority" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIssueAfterResetPriority(ctx context.Context) (v *uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueAfterResetPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueAfterResetPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueAfterResetPriority: %w", err)
	}
	return oldValue.IssueAfterResetPriority, nil
}

// AddIssueAfterResetPriority adds u to the "issue_after_reset_priority" field.
func (m *EntitlementMutation) AddIssueAfterResetPriority(u int8) {
	if m.addissue_after_reset_priority != nil {
		*m.addissue_after_reset_priority += u
	} else {
		m.addissue_after_reset_priority = &u
	}
}

// AddedIssueAfterResetPriority returns the value that was added to the "issue_after_reset_priority" field in this mutation.
func (m *EntitlementMutation) AddedIssueAfterResetPriority() (r int8, exists bool) {
	v := m.addissue_after_reset_priority
	if v == nil {
		return
	}
	return *v, true
}

// ClearIssueAfterResetPriority clears the value of the "issue_after_reset_priority" field.
func (m *EntitlementMutation) ClearIssueAfterResetPriority() {
	m.issue_after_reset_priority = nil
	m.addissue_after_reset_priority = nil
	m.clearedFields[entitlement.FieldIssueAfterResetPriority] = struct{}{}
}

// IssueAfterResetPriorityCleared returns if the "issue_after_reset_priority" field was cleared in this mutation.
func (m *EntitlementMutation) IssueAfterResetPriorityCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIssueAfterResetPriority]
	return ok
}

// ResetIssueAfterResetPriority resets all changes to the "issue_after_reset_priority" field.
func (m *EntitlementMutation) ResetIssueAfterResetPriority() {
	m.issue_after_reset_priority = nil
	m.addissue_after_reset_priority = nil
	delete(m.clearedFields, entitlement.FieldIssueAfterResetPriority)
}

// SetIsSoftLimit sets the "is_soft_limit" field.
func (m *EntitlementMutation) SetIsSoftLimit(b bool) {
	m.is_soft_limit = &b
}

// IsSoftLimit returns the value of the "is_soft_limit" field in the mutation.
func (m *EntitlementMutation) IsSoftLimit() (r bool, exists bool) {
	v := m.is_soft_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSoftLimit returns the old "is_soft_limit" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIsSoftLimit(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSoftLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSoftLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSoftLimit: %w", err)
	}
	return oldValue.IsSoftLimit, nil
}

// ClearIsSoftLimit clears the value of the "is_soft_limit" field.
func (m *EntitlementMutation) ClearIsSoftLimit() {
	m.is_soft_limit = nil
	m.clearedFields[entitlement.FieldIsSoftLimit] = struct{}{}
}

// IsSoftLimitCleared returns if the "is_soft_limit" field was cleared in this mutation.
func (m *EntitlementMutation) IsSoftLimitCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIsSoftLimit]
	return ok
}

// ResetIsSoftLimit resets all changes to the "is_soft_limit" field.
func (m *EntitlementMutation) ResetIsSoftLimit() {
	m.is_soft_limit = nil
	delete(m.clearedFields, entitlement.FieldIsSoftLimit)
}

// SetPreserveOverageAtReset sets the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) SetPreserveOverageAtReset(b bool) {
	m.preserve_overage_at_reset = &b
}

// PreserveOverageAtReset returns the value of the "preserve_overage_at_reset" field in the mutation.
func (m *EntitlementMutation) PreserveOverageAtReset() (r bool, exists bool) {
	v := m.preserve_overage_at_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldPreserveOverageAtReset returns the old "preserve_overage_at_reset" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldPreserveOverageAtReset(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreserveOverageAtReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreserveOverageAtReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreserveOverageAtReset: %w", err)
	}
	return oldValue.PreserveOverageAtReset, nil
}

// ClearPreserveOverageAtReset clears the value of the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) ClearPreserveOverageAtReset() {
	m.preserve_overage_at_reset = nil
	m.clearedFields[entitlement.FieldPreserveOverageAtReset] = struct{}{}
}

// PreserveOverageAtResetCleared returns if the "preserve_overage_at_reset" field was cleared in this mutation.
func (m *EntitlementMutation) PreserveOverageAtResetCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldPreserveOverageAtReset]
	return ok
}

// ResetPreserveOverageAtReset resets all changes to the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) ResetPreserveOverageAtReset() {
	m.preserve_overage_at_reset = nil
	delete(m.clearedFields, entitlement.FieldPreserveOverageAtReset)
}

// SetConfig sets the "config" field.
func (m *EntitlementMutation) SetConfig(u []uint8) {
	m._config = &u
	m.append_config = nil
}

// Config returns the value of the "config" field in the mutation.
func (m *EntitlementMutation) Config() (r []uint8, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldConfig(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// AppendConfig adds u to the "config" field.
func (m *EntitlementMutation) AppendConfig(u []uint8) {
	m.append_config = append(m.append_config, u...)
}

// AppendedConfig returns the list of values that were appended to the "config" field in this mutation.
func (m *EntitlementMutation) AppendedConfig() ([]uint8, bool) {
	if len(m.append_config) == 0 {
		return nil, false
	}
	return m.append_config, true
}

// ClearConfig clears the value of the "config" field.
func (m *EntitlementMutation) ClearConfig() {
	m._config = nil
	m.append_config = nil
	m.clearedFields[entitlement.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *EntitlementMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *EntitlementMutation) ResetConfig() {
	m._config = nil
	m.append_config = nil
	delete(m.clearedFields, entitlement.FieldConfig)
}

// SetUsagePeriodInterval sets the "usage_period_interval" field.
func (m *EntitlementMutation) SetUsagePeriodInterval(epi entitlement.UsagePeriodInterval) {
	m.usage_period_interval = &epi
}

// UsagePeriodInterval returns the value of the "usage_period_interval" field in the mutation.
func (m *EntitlementMutation) UsagePeriodInterval() (r entitlement.UsagePeriodInterval, exists bool) {
	v := m.usage_period_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldUsagePeriodInterval returns the old "usage_period_interval" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUsagePeriodInterval(ctx context.Context) (v *entitlement.UsagePeriodInterval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsagePeriodInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsagePeriodInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsagePeriodInterval: %w", err)
	}
	return oldValue.UsagePeriodInterval, nil
}

// ClearUsagePeriodInterval clears the value of the "usage_period_interval" field.
func (m *EntitlementMutation) ClearUsagePeriodInterval() {
	m.usage_period_interval = nil
	m.clearedFields[entitlement.FieldUsagePeriodInterval] = struct{}{}
}

// UsagePeriodIntervalCleared returns if the "usage_period_interval" field was cleared in this mutation.
func (m *EntitlementMutation) UsagePeriodIntervalCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldUsagePeriodInterval]
	return ok
}

// ResetUsagePeriodInterval resets all changes to the "usage_period_interval" field.
func (m *EntitlementMutation) ResetUsagePeriodInterval() {
	m.usage_period_interval = nil
	delete(m.clearedFields, entitlement.FieldUsagePeriodInterval)
}

// SetUsagePeriodAnchor sets the "usage_period_anchor" field.
func (m *EntitlementMutation) SetUsagePeriodAnchor(t time.Time) {
	m.usage_period_anchor = &t
}

// UsagePeriodAnchor returns the value of the "usage_period_anchor" field in the mutation.
func (m *EntitlementMutation) UsagePeriodAnchor() (r time.Time, exists bool) {
	v := m.usage_period_anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldUsagePeriodAnchor returns the old "usage_period_anchor" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUsagePeriodAnchor(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsagePeriodAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsagePeriodAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsagePeriodAnchor: %w", err)
	}
	return oldValue.UsagePeriodAnchor, nil
}

// ClearUsagePeriodAnchor clears the value of the "usage_period_anchor" field.
func (m *EntitlementMutation) ClearUsagePeriodAnchor() {
	m.usage_period_anchor = nil
	m.clearedFields[entitlement.FieldUsagePeriodAnchor] = struct{}{}
}

// UsagePeriodAnchorCleared returns if the "usage_period_anchor" field was cleared in this mutation.
func (m *EntitlementMutation) UsagePeriodAnchorCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldUsagePeriodAnchor]
	return ok
}

// ResetUsagePeriodAnchor resets all changes to the "usage_period_anchor" field.
func (m *EntitlementMutation) ResetUsagePeriodAnchor() {
	m.usage_period_anchor = nil
	delete(m.clearedFields, entitlement.FieldUsagePeriodAnchor)
}

// SetCurrentUsagePeriodStart sets the "current_usage_period_start" field.
func (m *EntitlementMutation) SetCurrentUsagePeriodStart(t time.Time) {
	m.current_usage_period_start = &t
}

// CurrentUsagePeriodStart returns the value of the "current_usage_period_start" field in the mutation.
func (m *EntitlementMutation) CurrentUsagePeriodStart() (r time.Time, exists bool) {
	v := m.current_usage_period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentUsagePeriodStart returns the old "current_usage_period_start" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCurrentUsagePeriodStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentUsagePeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentUsagePeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentUsagePeriodStart: %w", err)
	}
	return oldValue.CurrentUsagePeriodStart, nil
}

// ClearCurrentUsagePeriodStart clears the value of the "current_usage_period_start" field.
func (m *EntitlementMutation) ClearCurrentUsagePeriodStart() {
	m.current_usage_period_start = nil
	m.clearedFields[entitlement.FieldCurrentUsagePeriodStart] = struct{}{}
}

// CurrentUsagePeriodStartCleared returns if the "current_usage_period_start" field was cleared in this mutation.
func (m *EntitlementMutation) CurrentUsagePeriodStartCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldCurrentUsagePeriodStart]
	return ok
}

// ResetCurrentUsagePeriodStart resets all changes to the "current_usage_period_start" field.
func (m *EntitlementMutation) ResetCurrentUsagePeriodStart() {
	m.current_usage_period_start = nil
	delete(m.clearedFields, entitlement.FieldCurrentUsagePeriodStart)
}

// SetCurrentUsagePeriodEnd sets the "current_usage_period_end" field.
func (m *EntitlementMutation) SetCurrentUsagePeriodEnd(t time.Time) {
	m.current_usage_period_end = &t
}

// CurrentUsagePeriodEnd returns the value of the "current_usage_period_end" field in the mutation.
func (m *EntitlementMutation) CurrentUsagePeriodEnd() (r time.Time, exists bool) {
	v := m.current_usage_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentUsagePeriodEnd returns the old "current_usage_period_end" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCurrentUsagePeriodEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentUsagePeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentUsagePeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentUsagePeriodEnd: %w", err)
	}
	return oldValue.CurrentUsagePeriodEnd, nil
}

// ClearCurrentUsagePeriodEnd clears the value of the "current_usage_period_end" field.
func (m *EntitlementMutation) ClearCurrentUsagePeriodEnd() {
	m.current_usage_period_end = nil
	m.clearedFields[entitlement.FieldCurrentUsagePeriodEnd] = struct{}{}
}

// CurrentUsagePeriodEndCleared returns if the "current_usage_period_end" field was cleared in this mutation.
func (m *EntitlementMutation) CurrentUsagePeriodEndCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldCurrentUsagePeriodEnd]
	return ok
}

// ResetCurrentUsagePeriodEnd resets all changes to the "current_usage_period_end" field.
func (m *EntitlementMutation) ResetCurrentUsagePeriodEnd() {
	m.current_usage_period_end = nil
	delete(m.clearedFields, entitlement.FieldCurrentUsagePeriodEnd)
}

// AddUsageResetIDs adds the "usage_reset" edge to the UsageReset entity by ids.
func (m *EntitlementMutation) AddUsageResetIDs(ids ...string) {
	if m.usage_reset == nil {
		m.usage_reset = make(map[string]struct{})
	}
	for i := range ids {
		m.usage_reset[ids[i]] = struct{}{}
	}
}

// ClearUsageReset clears the "usage_reset" edge to the UsageReset entity.
func (m *EntitlementMutation) ClearUsageReset() {
	m.clearedusage_reset = true
}

// UsageResetCleared reports if the "usage_reset" edge to the UsageReset entity was cleared.
func (m *EntitlementMutation) UsageResetCleared() bool {
	return m.clearedusage_reset
}

// RemoveUsageResetIDs removes the "usage_reset" edge to the UsageReset entity by IDs.
func (m *EntitlementMutation) RemoveUsageResetIDs(ids ...string) {
	if m.removedusage_reset == nil {
		m.removedusage_reset = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.usage_reset, ids[i])
		m.removedusage_reset[ids[i]] = struct{}{}
	}
}

// RemovedUsageReset returns the removed IDs of the "usage_reset" edge to the UsageReset entity.
func (m *EntitlementMutation) RemovedUsageResetIDs() (ids []string) {
	for id := range m.removedusage_reset {
		ids = append(ids, id)
	}
	return
}

// UsageResetIDs returns the "usage_reset" edge IDs in the mutation.
func (m *EntitlementMutation) UsageResetIDs() (ids []string) {
	for id := range m.usage_reset {
		ids = append(ids, id)
	}
	return
}

// ResetUsageReset resets all changes to the "usage_reset" edge.
func (m *EntitlementMutation) ResetUsageReset() {
	m.usage_reset = nil
	m.clearedusage_reset = false
	m.removedusage_reset = nil
}

// AddGrantIDs adds the "grant" edge to the Grant entity by ids.
func (m *EntitlementMutation) AddGrantIDs(ids ...string) {
	if m.grant == nil {
		m.grant = make(map[string]struct{})
	}
	for i := range ids {
		m.grant[ids[i]] = struct{}{}
	}
}

// ClearGrant clears the "grant" edge to the Grant entity.
func (m *EntitlementMutation) ClearGrant() {
	m.clearedgrant = true
}

// GrantCleared reports if the "grant" edge to the Grant entity was cleared.
func (m *EntitlementMutation) GrantCleared() bool {
	return m.clearedgrant
}

// RemoveGrantIDs removes the "grant" edge to the Grant entity by IDs.
func (m *EntitlementMutation) RemoveGrantIDs(ids ...string) {
	if m.removedgrant == nil {
		m.removedgrant = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.grant, ids[i])
		m.removedgrant[ids[i]] = struct{}{}
	}
}

// RemovedGrant returns the removed IDs of the "grant" edge to the Grant entity.
func (m *EntitlementMutation) RemovedGrantIDs() (ids []string) {
	for id := range m.removedgrant {
		ids = append(ids, id)
	}
	return
}

// GrantIDs returns the "grant" edge IDs in the mutation.
func (m *EntitlementMutation) GrantIDs() (ids []string) {
	for id := range m.grant {
		ids = append(ids, id)
	}
	return
}

// ResetGrant resets all changes to the "grant" edge.
func (m *EntitlementMutation) ResetGrant() {
	m.grant = nil
	m.clearedgrant = false
	m.removedgrant = nil
}

// AddBalanceSnapshotIDs adds the "balance_snapshot" edge to the BalanceSnapshot entity by ids.
func (m *EntitlementMutation) AddBalanceSnapshotIDs(ids ...int) {
	if m.balance_snapshot == nil {
		m.balance_snapshot = make(map[int]struct{})
	}
	for i := range ids {
		m.balance_snapshot[ids[i]] = struct{}{}
	}
}

// ClearBalanceSnapshot clears the "balance_snapshot" edge to the BalanceSnapshot entity.
func (m *EntitlementMutation) ClearBalanceSnapshot() {
	m.clearedbalance_snapshot = true
}

// BalanceSnapshotCleared reports if the "balance_snapshot" edge to the BalanceSnapshot entity was cleared.
func (m *EntitlementMutation) BalanceSnapshotCleared() bool {
	return m.clearedbalance_snapshot
}

// RemoveBalanceSnapshotIDs removes the "balance_snapshot" edge to the BalanceSnapshot entity by IDs.
func (m *EntitlementMutation) RemoveBalanceSnapshotIDs(ids ...int) {
	if m.removedbalance_snapshot == nil {
		m.removedbalance_snapshot = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.balance_snapshot, ids[i])
		m.removedbalance_snapshot[ids[i]] = struct{}{}
	}
}

// RemovedBalanceSnapshot returns the removed IDs of the "balance_snapshot" edge to the BalanceSnapshot entity.
func (m *EntitlementMutation) RemovedBalanceSnapshotIDs() (ids []int) {
	for id := range m.removedbalance_snapshot {
		ids = append(ids, id)
	}
	return
}

// BalanceSnapshotIDs returns the "balance_snapshot" edge IDs in the mutation.
func (m *EntitlementMutation) BalanceSnapshotIDs() (ids []int) {
	for id := range m.balance_snapshot {
		ids = append(ids, id)
	}
	return
}

// ResetBalanceSnapshot resets all changes to the "balance_snapshot" edge.
func (m *EntitlementMutation) ResetBalanceSnapshot() {
	m.balance_snapshot = nil
	m.clearedbalance_snapshot = false
	m.removedbalance_snapshot = nil
}

// SetSubscriptionID sets the "subscription" edge to the SubscriptionEntitlement entity by id.
func (m *EntitlementMutation) SetSubscriptionID(id string) {
	m.subscription = &id
}

// ClearSubscription clears the "subscription" edge to the SubscriptionEntitlement entity.
func (m *EntitlementMutation) ClearSubscription() {
	m.clearedsubscription = true
}

// SubscriptionCleared reports if the "subscription" edge to the SubscriptionEntitlement entity was cleared.
func (m *EntitlementMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// SubscriptionID returns the "subscription" edge ID in the mutation.
func (m *EntitlementMutation) SubscriptionID() (id string, exists bool) {
	if m.subscription != nil {
		return *m.subscription, true
	}
	return
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *EntitlementMutation) SubscriptionIDs() (ids []string) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *EntitlementMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// ClearFeature clears the "feature" edge to the Feature entity.
func (m *EntitlementMutation) ClearFeature() {
	m.clearedfeature = true
	m.clearedFields[entitlement.FieldFeatureID] = struct{}{}
}

// FeatureCleared reports if the "feature" edge to the Feature entity was cleared.
func (m *EntitlementMutation) FeatureCleared() bool {
	return m.clearedfeature
}

// FeatureIDs returns the "feature" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureID instead. It exists only for internal usage by the builders.
func (m *EntitlementMutation) FeatureIDs() (ids []string) {
	if id := m.feature; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeature resets all changes to the "feature" edge.
func (m *EntitlementMutation) ResetFeature() {
	m.feature = nil
	m.clearedfeature = false
}

// Where appends a list predicates to the EntitlementMutation builder.
func (m *EntitlementMutation) Where(ps ...predicate.Entitlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entitlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entitlement).
func (m *EntitlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.namespace != nil {
		fields = append(fields, entitlement.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, entitlement.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, entitlement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitlement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitlement.FieldDeletedAt)
	}
	if m.entitlement_type != nil {
		fields = append(fields, entitlement.FieldEntitlementType)
	}
	if m.feature != nil {
		fields = append(fields, entitlement.FieldFeatureID)
	}
	if m.active_from != nil {
		fields = append(fields, entitlement.FieldActiveFrom)
	}
	if m.active_to != nil {
		fields = append(fields, entitlement.FieldActiveTo)
	}
	if m.feature_key != nil {
		fields = append(fields, entitlement.FieldFeatureKey)
	}
	if m.subject_key != nil {
		fields = append(fields, entitlement.FieldSubjectKey)
	}
	if m.measure_usage_from != nil {
		fields = append(fields, entitlement.FieldMeasureUsageFrom)
	}
	if m.issue_after_reset != nil {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.issue_after_reset_priority != nil {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	if m.is_soft_limit != nil {
		fields = append(fields, entitlement.FieldIsSoftLimit)
	}
	if m.preserve_overage_at_reset != nil {
		fields = append(fields, entitlement.FieldPreserveOverageAtReset)
	}
	if m._config != nil {
		fields = append(fields, entitlement.FieldConfig)
	}
	if m.usage_period_interval != nil {
		fields = append(fields, entitlement.FieldUsagePeriodInterval)
	}
	if m.usage_period_anchor != nil {
		fields = append(fields, entitlement.FieldUsagePeriodAnchor)
	}
	if m.current_usage_period_start != nil {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodStart)
	}
	if m.current_usage_period_end != nil {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodEnd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlement.FieldNamespace:
		return m.Namespace()
	case entitlement.FieldMetadata:
		return m.Metadata()
	case entitlement.FieldCreatedAt:
		return m.CreatedAt()
	case entitlement.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitlement.FieldDeletedAt:
		return m.DeletedAt()
	case entitlement.FieldEntitlementType:
		return m.EntitlementType()
	case entitlement.FieldFeatureID:
		return m.FeatureID()
	case entitlement.FieldActiveFrom:
		return m.ActiveFrom()
	case entitlement.FieldActiveTo:
		return m.ActiveTo()
	case entitlement.FieldFeatureKey:
		return m.FeatureKey()
	case entitlement.FieldSubjectKey:
		return m.SubjectKey()
	case entitlement.FieldMeasureUsageFrom:
		return m.MeasureUsageFrom()
	case entitlement.FieldIssueAfterReset:
		return m.IssueAfterReset()
	case entitlement.FieldIssueAfterResetPriority:
		return m.IssueAfterResetPriority()
	case entitlement.FieldIsSoftLimit:
		return m.IsSoftLimit()
	case entitlement.FieldPreserveOverageAtReset:
		return m.PreserveOverageAtReset()
	case entitlement.FieldConfig:
		return m.Config()
	case entitlement.FieldUsagePeriodInterval:
		return m.UsagePeriodInterval()
	case entitlement.FieldUsagePeriodAnchor:
		return m.UsagePeriodAnchor()
	case entitlement.FieldCurrentUsagePeriodStart:
		return m.CurrentUsagePeriodStart()
	case entitlement.FieldCurrentUsagePeriodEnd:
		return m.CurrentUsagePeriodEnd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlement.FieldNamespace:
		return m.OldNamespace(ctx)
	case entitlement.FieldMetadata:
		return m.OldMetadata(ctx)
	case entitlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitlement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitlement.FieldEntitlementType:
		return m.OldEntitlementType(ctx)
	case entitlement.FieldFeatureID:
		return m.OldFeatureID(ctx)
	case entitlement.FieldActiveFrom:
		return m.OldActiveFrom(ctx)
	case entitlement.FieldActiveTo:
		return m.OldActiveTo(ctx)
	case entitlement.FieldFeatureKey:
		return m.OldFeatureKey(ctx)
	case entitlement.FieldSubjectKey:
		return m.OldSubjectKey(ctx)
	case entitlement.FieldMeasureUsageFrom:
		return m.OldMeasureUsageFrom(ctx)
	case entitlement.FieldIssueAfterReset:
		return m.OldIssueAfterReset(ctx)
	case entitlement.FieldIssueAfterResetPriority:
		return m.OldIssueAfterResetPriority(ctx)
	case entitlement.FieldIsSoftLimit:
		return m.OldIsSoftLimit(ctx)
	case entitlement.FieldPreserveOverageAtReset:
		return m.OldPreserveOverageAtReset(ctx)
	case entitlement.FieldConfig:
		return m.OldConfig(ctx)
	case entitlement.FieldUsagePeriodInterval:
		return m.OldUsagePeriodInterval(ctx)
	case entitlement.FieldUsagePeriodAnchor:
		return m.OldUsagePeriodAnchor(ctx)
	case entitlement.FieldCurrentUsagePeriodStart:
		return m.OldCurrentUsagePeriodStart(ctx)
	case entitlement.FieldCurrentUsagePeriodEnd:
		return m.OldCurrentUsagePeriodEnd(ctx)
	}
	return nil, fmt.Errorf("unknown Entitlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlement.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case entitlement.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case entitlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitlement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitlement.FieldEntitlementType:
		v, ok := value.(entitlement.EntitlementType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementType(v)
		return nil
	case entitlement.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	case entitlement.FieldActiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveFrom(v)
		return nil
	case entitlement.FieldActiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveTo(v)
		return nil
	case entitlement.FieldFeatureKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureKey(v)
		return nil
	case entitlement.FieldSubjectKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectKey(v)
		return nil
	case entitlement.FieldMeasureUsageFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasureUsageFrom(v)
		return nil
	case entitlement.FieldIssueAfterReset:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueAfterReset(v)
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueAfterResetPriority(v)
		return nil
	case entitlement.FieldIsSoftLimit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSoftLimit(v)
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreserveOverageAtReset(v)
		return nil
	case entitlement.FieldConfig:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case entitlement.FieldUsagePeriodInterval:
		v, ok := value.(entitlement.UsagePeriodInterval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsagePeriodInterval(v)
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsagePeriodAnchor(v)
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentUsagePeriodStart(v)
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentUsagePeriodEnd(v)
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementMutation) AddedFields() []string {
	var fields []string
	if m.addissue_after_reset != nil {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.addissue_after_reset_priority != nil {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entitlement.FieldIssueAfterReset:
		return m.AddedIssueAfterReset()
	case entitlement.FieldIssueAfterResetPriority:
		return m.AddedIssueAfterResetPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entitlement.FieldIssueAfterReset:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIssueAfterReset(v)
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIssueAfterResetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Entitlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlement.FieldMetadata) {
		fields = append(fields, entitlement.FieldMetadata)
	}
	if m.FieldCleared(entitlement.FieldDeletedAt) {
		fields = append(fields, entitlement.FieldDeletedAt)
	}
	if m.FieldCleared(entitlement.FieldActiveFrom) {
		fields = append(fields, entitlement.FieldActiveFrom)
	}
	if m.FieldCleared(entitlement.FieldActiveTo) {
		fields = append(fields, entitlement.FieldActiveTo)
	}
	if m.FieldCleared(entitlement.FieldMeasureUsageFrom) {
		fields = append(fields, entitlement.FieldMeasureUsageFrom)
	}
	if m.FieldCleared(entitlement.FieldIssueAfterReset) {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.FieldCleared(entitlement.FieldIssueAfterResetPriority) {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	if m.FieldCleared(entitlement.FieldIsSoftLimit) {
		fields = append(fields, entitlement.FieldIsSoftLimit)
	}
	if m.FieldCleared(entitlement.FieldPreserveOverageAtReset) {
		fields = append(fields, entitlement.FieldPreserveOverageAtReset)
	}
	if m.FieldCleared(entitlement.FieldConfig) {
		fields = append(fields, entitlement.FieldConfig)
	}
	if m.FieldCleared(entitlement.FieldUsagePeriodInterval) {
		fields = append(fields, entitlement.FieldUsagePeriodInterval)
	}
	if m.FieldCleared(entitlement.FieldUsagePeriodAnchor) {
		fields = append(fields, entitlement.FieldUsagePeriodAnchor)
	}
	if m.FieldCleared(entitlement.FieldCurrentUsagePeriodStart) {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodStart)
	}
	if m.FieldCleared(entitlement.FieldCurrentUsagePeriodEnd) {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodEnd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementMutation) ClearField(name string) error {
	switch name {
	case entitlement.FieldMetadata:
		m.ClearMetadata()
		return nil
	case entitlement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitlement.FieldActiveFrom:
		m.ClearActiveFrom()
		return nil
	case entitlement.FieldActiveTo:
		m.ClearActiveTo()
		return nil
	case entitlement.FieldMeasureUsageFrom:
		m.ClearMeasureUsageFrom()
		return nil
	case entitlement.FieldIssueAfterReset:
		m.ClearIssueAfterReset()
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		m.ClearIssueAfterResetPriority()
		return nil
	case entitlement.FieldIsSoftLimit:
		m.ClearIsSoftLimit()
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		m.ClearPreserveOverageAtReset()
		return nil
	case entitlement.FieldConfig:
		m.ClearConfig()
		return nil
	case entitlement.FieldUsagePeriodInterval:
		m.ClearUsagePeriodInterval()
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		m.ClearUsagePeriodAnchor()
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		m.ClearCurrentUsagePeriodStart()
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		m.ClearCurrentUsagePeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown Entitlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementMutation) ResetField(name string) error {
	switch name {
	case entitlement.FieldNamespace:
		m.ResetNamespace()
		return nil
	case entitlement.FieldMetadata:
		m.ResetMetadata()
		return nil
	case entitlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitlement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitlement.FieldEntitlementType:
		m.ResetEntitlementType()
		return nil
	case entitlement.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	case entitlement.FieldActiveFrom:
		m.ResetActiveFrom()
		return nil
	case entitlement.FieldActiveTo:
		m.ResetActiveTo()
		return nil
	case entitlement.FieldFeatureKey:
		m.ResetFeatureKey()
		return nil
	case entitlement.FieldSubjectKey:
		m.ResetSubjectKey()
		return nil
	case entitlement.FieldMeasureUsageFrom:
		m.ResetMeasureUsageFrom()
		return nil
	case entitlement.FieldIssueAfterReset:
		m.ResetIssueAfterReset()
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		m.ResetIssueAfterResetPriority()
		return nil
	case entitlement.FieldIsSoftLimit:
		m.ResetIsSoftLimit()
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		m.ResetPreserveOverageAtReset()
		return nil
	case entitlement.FieldConfig:
		m.ResetConfig()
		return nil
	case entitlement.FieldUsagePeriodInterval:
		m.ResetUsagePeriodInterval()
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		m.ResetUsagePeriodAnchor()
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		m.ResetCurrentUsagePeriodStart()
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		m.ResetCurrentUsagePeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.usage_reset != nil {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.grant != nil {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.balance_snapshot != nil {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	if m.subscription != nil {
		edges = append(edges, entitlement.EdgeSubscription)
	}
	if m.feature != nil {
		edges = append(edges, entitlement.EdgeFeature)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgeUsageReset:
		ids := make([]ent.Value, 0, len(m.usage_reset))
		for id := range m.usage_reset {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeGrant:
		ids := make([]ent.Value, 0, len(m.grant))
		for id := range m.grant {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeBalanceSnapshot:
		ids := make([]ent.Value, 0, len(m.balance_snapshot))
		for id := range m.balance_snapshot {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	case entitlement.EdgeFeature:
		if id := m.feature; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedusage_reset != nil {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.removedgrant != nil {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.removedbalance_snapshot != nil {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgeUsageReset:
		ids := make([]ent.Value, 0, len(m.removedusage_reset))
		for id := range m.removedusage_reset {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeGrant:
		ids := make([]ent.Value, 0, len(m.removedgrant))
		for id := range m.removedgrant {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeBalanceSnapshot:
		ids := make([]ent.Value, 0, len(m.removedbalance_snapshot))
		for id := range m.removedbalance_snapshot {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedusage_reset {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.clearedgrant {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.clearedbalance_snapshot {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	if m.clearedsubscription {
		edges = append(edges, entitlement.EdgeSubscription)
	}
	if m.clearedfeature {
		edges = append(edges, entitlement.EdgeFeature)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementMutation) EdgeCleared(name string) bool {
	switch name {
	case entitlement.EdgeUsageReset:
		return m.clearedusage_reset
	case entitlement.EdgeGrant:
		return m.clearedgrant
	case entitlement.EdgeBalanceSnapshot:
		return m.clearedbalance_snapshot
	case entitlement.EdgeSubscription:
		return m.clearedsubscription
	case entitlement.EdgeFeature:
		return m.clearedfeature
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementMutation) ClearEdge(name string) error {
	switch name {
	case entitlement.EdgeSubscription:
		m.ClearSubscription()
		return nil
	case entitlement.EdgeFeature:
		m.ClearFeature()
		return nil
	}
	return fmt.Errorf("unknown Entitlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementMutation) ResetEdge(name string) error {
	switch name {
	case entitlement.EdgeUsageReset:
		m.ResetUsageReset()
		return nil
	case entitlement.EdgeGrant:
		m.ResetGrant()
		return nil
	case entitlement.EdgeBalanceSnapshot:
		m.ResetBalanceSnapshot()
		return nil
	case entitlement.EdgeSubscription:
		m.ResetSubscription()
		return nil
	case entitlement.EdgeFeature:
		m.ResetFeature()
		return nil
	}
	return fmt.Errorf("unknown Entitlement edge %s", name)
}

// FeatureMutation represents an operation that mutates the Feature nodes in the graph.
type FeatureMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	metadata               *map[string]string
	namespace              *string
	name                   *string
	key                    *string
	meter_slug             *string
	meter_group_by_filters *map[string]string
	archived_at            *time.Time
	clearedFields          map[string]struct{}
	entitlement            map[string]struct{}
	removedentitlement     map[string]struct{}
	clearedentitlement     bool
	ratecard               map[string]struct{}
	removedratecard        map[string]struct{}
	clearedratecard        bool
	done                   bool
	oldValue               func(context.Context) (*Feature, error)
	predicates             []predicate.Feature
}

var _ ent.Mutation = (*FeatureMutation)(nil)

// featureOption allows management of the mutation configuration using functional options.
type featureOption func(*FeatureMutation)

// newFeatureMutation creates new mutation for the Feature entity.
func newFeatureMutation(c config, op Op, opts ...featureOption) *FeatureMutation {
	m := &FeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureID sets the ID field of the mutation.
func withFeatureID(id string) featureOption {
	return func(m *FeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *Feature
		)
		m.oldValue = func(ctx context.Context) (*Feature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeature sets the old Feature of the mutation.
func withFeature(node *Feature) featureOption {
	return func(m *FeatureMutation) {
		m.oldValue = func(context.Context) (*Feature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feature entities.
func (m *FeatureMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeatureMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeatureMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeatureMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[feature.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeatureMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeatureMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, feature.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *FeatureMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *FeatureMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *FeatureMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[feature.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *FeatureMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[feature.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *FeatureMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, feature.FieldMetadata)
}

// SetNamespace sets the "namespace" field.
func (m *FeatureMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *FeatureMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *FeatureMutation) ResetNamespace() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *FeatureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *FeatureMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *FeatureMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *FeatureMutation) ResetKey() {
	m.key = nil
}

// SetMeterSlug sets the "meter_slug" field.
func (m *FeatureMutation) SetMeterSlug(s string) {
	m.meter_slug = &s
}

// MeterSlug returns the value of the "meter_slug" field in the mutation.
func (m *FeatureMutation) MeterSlug() (r string, exists bool) {
	v := m.meter_slug
	if v == nil {
		return
	}
	return *v, true
}

// OldMeterSlug returns the old "meter_slug" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMeterSlug(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeterSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeterSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeterSlug: %w", err)
	}
	return oldValue.MeterSlug, nil
}

// ClearMeterSlug clears the value of the "meter_slug" field.
func (m *FeatureMutation) ClearMeterSlug() {
	m.meter_slug = nil
	m.clearedFields[feature.FieldMeterSlug] = struct{}{}
}

// MeterSlugCleared returns if the "meter_slug" field was cleared in this mutation.
func (m *FeatureMutation) MeterSlugCleared() bool {
	_, ok := m.clearedFields[feature.FieldMeterSlug]
	return ok
}

// ResetMeterSlug resets all changes to the "meter_slug" field.
func (m *FeatureMutation) ResetMeterSlug() {
	m.meter_slug = nil
	delete(m.clearedFields, feature.FieldMeterSlug)
}

// SetMeterGroupByFilters sets the "meter_group_by_filters" field.
func (m *FeatureMutation) SetMeterGroupByFilters(value map[string]string) {
	m.meter_group_by_filters = &value
}

// MeterGroupByFilters returns the value of the "meter_group_by_filters" field in the mutation.
func (m *FeatureMutation) MeterGroupByFilters() (r map[string]string, exists bool) {
	v := m.meter_group_by_filters
	if v == nil {
		return
	}
	return *v, true
}

// OldMeterGroupByFilters returns the old "meter_group_by_filters" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMeterGroupByFilters(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeterGroupByFilters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeterGroupByFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeterGroupByFilters: %w", err)
	}
	return oldValue.MeterGroupByFilters, nil
}

// ClearMeterGroupByFilters clears the value of the "meter_group_by_filters" field.
func (m *FeatureMutation) ClearMeterGroupByFilters() {
	m.meter_group_by_filters = nil
	m.clearedFields[feature.FieldMeterGroupByFilters] = struct{}{}
}

// MeterGroupByFiltersCleared returns if the "meter_group_by_filters" field was cleared in this mutation.
func (m *FeatureMutation) MeterGroupByFiltersCleared() bool {
	_, ok := m.clearedFields[feature.FieldMeterGroupByFilters]
	return ok
}

// ResetMeterGroupByFilters resets all changes to the "meter_group_by_filters" field.
func (m *FeatureMutation) ResetMeterGroupByFilters() {
	m.meter_group_by_filters = nil
	delete(m.clearedFields, feature.FieldMeterGroupByFilters)
}

// SetArchivedAt sets the "archived_at" field.
func (m *FeatureMutation) SetArchivedAt(t time.Time) {
	m.archived_at = &t
}

// ArchivedAt returns the value of the "archived_at" field in the mutation.
func (m *FeatureMutation) ArchivedAt() (r time.Time, exists bool) {
	v := m.archived_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedAt returns the old "archived_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldArchivedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedAt: %w", err)
	}
	return oldValue.ArchivedAt, nil
}

// ClearArchivedAt clears the value of the "archived_at" field.
func (m *FeatureMutation) ClearArchivedAt() {
	m.archived_at = nil
	m.clearedFields[feature.FieldArchivedAt] = struct{}{}
}

// ArchivedAtCleared returns if the "archived_at" field was cleared in this mutation.
func (m *FeatureMutation) ArchivedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldArchivedAt]
	return ok
}

// ResetArchivedAt resets all changes to the "archived_at" field.
func (m *FeatureMutation) ResetArchivedAt() {
	m.archived_at = nil
	delete(m.clearedFields, feature.FieldArchivedAt)
}

// AddEntitlementIDs adds the "entitlement" edge to the Entitlement entity by ids.
func (m *FeatureMutation) AddEntitlementIDs(ids ...string) {
	if m.entitlement == nil {
		m.entitlement = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlement[ids[i]] = struct{}{}
	}
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *FeatureMutation) ClearEntitlement() {
	m.clearedentitlement = true
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *FeatureMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// RemoveEntitlementIDs removes the "entitlement" edge to the Entitlement entity by IDs.
func (m *FeatureMutation) RemoveEntitlementIDs(ids ...string) {
	if m.removedentitlement == nil {
		m.removedentitlement = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlement, ids[i])
		m.removedentitlement[ids[i]] = struct{}{}
	}
}

// RemovedEntitlement returns the removed IDs of the "entitlement" edge to the Entitlement entity.
func (m *FeatureMutation) RemovedEntitlementIDs() (ids []string) {
	for id := range m.removedentitlement {
		ids = append(ids, id)
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
func (m *FeatureMutation) EntitlementIDs() (ids []string) {
	for id := range m.entitlement {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *FeatureMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
	m.removedentitlement = nil
}

// AddRatecardIDs adds the "ratecard" edge to the PlanRateCard entity by ids.
func (m *FeatureMutation) AddRatecardIDs(ids ...string) {
	if m.ratecard == nil {
		m.ratecard = make(map[string]struct{})
	}
	for i := range ids {
		m.ratecard[ids[i]] = struct{}{}
	}
}

// ClearRatecard clears the "ratecard" edge to the PlanRateCard entity.
func (m *FeatureMutation) ClearRatecard() {
	m.clearedratecard = true
}

// RatecardCleared reports if the "ratecard" edge to the PlanRateCard entity was cleared.
func (m *FeatureMutation) RatecardCleared() bool {
	return m.clearedratecard
}

// RemoveRatecardIDs removes the "ratecard" edge to the PlanRateCard entity by IDs.
func (m *FeatureMutation) RemoveRatecardIDs(ids ...string) {
	if m.removedratecard == nil {
		m.removedratecard = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ratecard, ids[i])
		m.removedratecard[ids[i]] = struct{}{}
	}
}

// RemovedRatecard returns the removed IDs of the "ratecard" edge to the PlanRateCard entity.
func (m *FeatureMutation) RemovedRatecardIDs() (ids []string) {
	for id := range m.removedratecard {
		ids = append(ids, id)
	}
	return
}

// RatecardIDs returns the "ratecard" edge IDs in the mutation.
func (m *FeatureMutation) RatecardIDs() (ids []string) {
	for id := range m.ratecard {
		ids = append(ids, id)
	}
	return
}

// ResetRatecard resets all changes to the "ratecard" edge.
func (m *FeatureMutation) ResetRatecard() {
	m.ratecard = nil
	m.clearedratecard = false
	m.removedratecard = nil
}

// Where appends a list predicates to the FeatureMutation builder.
func (m *FeatureMutation) Where(ps ...predicate.Feature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feature).
func (m *FeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, feature.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feature.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, feature.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, feature.FieldMetadata)
	}
	if m.namespace != nil {
		fields = append(fields, feature.FieldNamespace)
	}
	if m.name != nil {
		fields = append(fields, feature.FieldName)
	}
	if m.key != nil {
		fields = append(fields, feature.FieldKey)
	}
	if m.meter_slug != nil {
		fields = append(fields, feature.FieldMeterSlug)
	}
	if m.meter_group_by_filters != nil {
		fields = append(fields, feature.FieldMeterGroupByFilters)
	}
	if m.archived_at != nil {
		fields = append(fields, feature.FieldArchivedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feature.FieldCreatedAt:
		return m.CreatedAt()
	case feature.FieldUpdatedAt:
		return m.UpdatedAt()
	case feature.FieldDeletedAt:
		return m.DeletedAt()
	case feature.FieldMetadata:
		return m.Metadata()
	case feature.FieldNamespace:
		return m.Namespace()
	case feature.FieldName:
		return m.Name()
	case feature.FieldKey:
		return m.Key()
	case feature.FieldMeterSlug:
		return m.MeterSlug()
	case feature.FieldMeterGroupByFilters:
		return m.MeterGroupByFilters()
	case feature.FieldArchivedAt:
		return m.ArchivedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feature.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feature.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case feature.FieldMetadata:
		return m.OldMetadata(ctx)
	case feature.FieldNamespace:
		return m.OldNamespace(ctx)
	case feature.FieldName:
		return m.OldName(ctx)
	case feature.FieldKey:
		return m.OldKey(ctx)
	case feature.FieldMeterSlug:
		return m.OldMeterSlug(ctx)
	case feature.FieldMeterGroupByFilters:
		return m.OldMeterGroupByFilters(ctx)
	case feature.FieldArchivedAt:
		return m.OldArchivedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Feature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feature.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feature.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case feature.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case feature.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case feature.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feature.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case feature.FieldMeterSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeterSlug(v)
		return nil
	case feature.FieldMeterGroupByFilters:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeterGroupByFilters(v)
		return nil
	case feature.FieldArchivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feature.FieldDeletedAt) {
		fields = append(fields, feature.FieldDeletedAt)
	}
	if m.FieldCleared(feature.FieldMetadata) {
		fields = append(fields, feature.FieldMetadata)
	}
	if m.FieldCleared(feature.FieldMeterSlug) {
		fields = append(fields, feature.FieldMeterSlug)
	}
	if m.FieldCleared(feature.FieldMeterGroupByFilters) {
		fields = append(fields, feature.FieldMeterGroupByFilters)
	}
	if m.FieldCleared(feature.FieldArchivedAt) {
		fields = append(fields, feature.FieldArchivedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureMutation) ClearField(name string) error {
	switch name {
	case feature.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case feature.FieldMetadata:
		m.ClearMetadata()
		return nil
	case feature.FieldMeterSlug:
		m.ClearMeterSlug()
		return nil
	case feature.FieldMeterGroupByFilters:
		m.ClearMeterGroupByFilters()
		return nil
	case feature.FieldArchivedAt:
		m.ClearArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Feature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureMutation) ResetField(name string) error {
	switch name {
	case feature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feature.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feature.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case feature.FieldMetadata:
		m.ResetMetadata()
		return nil
	case feature.FieldNamespace:
		m.ResetNamespace()
		return nil
	case feature.FieldName:
		m.ResetName()
		return nil
	case feature.FieldKey:
		m.ResetKey()
		return nil
	case feature.FieldMeterSlug:
		m.ResetMeterSlug()
		return nil
	case feature.FieldMeterGroupByFilters:
		m.ResetMeterGroupByFilters()
		return nil
	case feature.FieldArchivedAt:
		m.ResetArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.entitlement != nil {
		edges = append(edges, feature.EdgeEntitlement)
	}
	if m.ratecard != nil {
		edges = append(edges, feature.EdgeRatecard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeEntitlement:
		ids := make([]ent.Value, 0, len(m.entitlement))
		for id := range m.entitlement {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeRatecard:
		ids := make([]ent.Value, 0, len(m.ratecard))
		for id := range m.ratecard {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedentitlement != nil {
		edges = append(edges, feature.EdgeEntitlement)
	}
	if m.removedratecard != nil {
		edges = append(edges, feature.EdgeRatecard)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeEntitlement:
		ids := make([]ent.Value, 0, len(m.removedentitlement))
		for id := range m.removedentitlement {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeRatecard:
		ids := make([]ent.Value, 0, len(m.removedratecard))
		for id := range m.removedratecard {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedentitlement {
		edges = append(edges, feature.EdgeEntitlement)
	}
	if m.clearedratecard {
		edges = append(edges, feature.EdgeRatecard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case feature.EdgeEntitlement:
		return m.clearedentitlement
	case feature.EdgeRatecard:
		return m.clearedratecard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureMutation) ResetEdge(name string) error {
	switch name {
	case feature.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	case feature.EdgeRatecard:
		m.ResetRatecard()
		return nil
	}
	return fmt.Errorf("unknown Feature edge %s", name)
}

// GrantMutation represents an operation that mutates the Grant nodes in the graph.
type GrantMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	namespace             *string
	metadata              *map[string]string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	amount                *float64
	addamount             *float64
	priority              *uint8
	addpriority           *int8
	effective_at          *time.Time
	expiration            *grant.ExpirationPeriod
	expires_at            *time.Time
	voided_at             *time.Time
	reset_max_rollover    *float64
	addreset_max_rollover *float64
	reset_min_rollover    *float64
	addreset_min_rollover *float64
	recurrence_period     *recurrence.RecurrenceInterval
	recurrence_anchor     *time.Time
	clearedFields         map[string]struct{}
	entitlement           *string
	clearedentitlement    bool
	done                  bool
	oldValue              func(context.Context) (*Grant, error)
	predicates            []predicate.Grant
}

var _ ent.Mutation = (*GrantMutation)(nil)

// grantOption allows management of the mutation configuration using functional options.
type grantOption func(*GrantMutation)

// newGrantMutation creates new mutation for the Grant entity.
func newGrantMutation(c config, op Op, opts ...grantOption) *GrantMutation {
	m := &GrantMutation{
		config:        c,
		op:            op,
		typ:           TypeGrant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrantID sets the ID field of the mutation.
func withGrantID(id string) grantOption {
	return func(m *GrantMutation) {
		var (
			err   error
			once  sync.Once
			value *Grant
		)
		m.oldValue = func(ctx context.Context) (*Grant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrant sets the old Grant of the mutation.
func withGrant(node *Grant) grantOption {
	return func(m *GrantMutation) {
		m.oldValue = func(context.Context) (*Grant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Grant entities.
func (m *GrantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GrantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GrantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Grant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *GrantMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *GrantMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *GrantMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *GrantMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *GrantMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *GrantMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[dbgrant.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *GrantMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *GrantMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, dbgrant.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *GrantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GrantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GrantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GrantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GrantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GrantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GrantMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GrantMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GrantMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dbgrant.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GrantMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GrantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dbgrant.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *GrantMutation) SetOwnerID(s string) {
	m.entitlement = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *GrantMutation) OwnerID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *GrantMutation) ResetOwnerID() {
	m.entitlement = nil
}

// SetAmount sets the "amount" field.
func (m *GrantMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GrantMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *GrantMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *GrantMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *GrantMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPriority sets the "priority" field.
func (m *GrantMutation) SetPriority(u uint8) {
	m.priority = &u
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *GrantMutation) Priority() (r uint8, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldPriority(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds u to the "priority" field.
func (m *GrantMutation) AddPriority(u int8) {
	if m.addpriority != nil {
		*m.addpriority += u
	} else {
		m.addpriority = &u
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *GrantMutation) AddedPriority() (r int8, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *GrantMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetEffectiveAt sets the "effective_at" field.
func (m *GrantMutation) SetEffectiveAt(t time.Time) {
	m.effective_at = &t
}

// EffectiveAt returns the value of the "effective_at" field in the mutation.
func (m *GrantMutation) EffectiveAt() (r time.Time, exists bool) {
	v := m.effective_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveAt returns the old "effective_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldEffectiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveAt: %w", err)
	}
	return oldValue.EffectiveAt, nil
}

// ResetEffectiveAt resets all changes to the "effective_at" field.
func (m *GrantMutation) ResetEffectiveAt() {
	m.effective_at = nil
}

// SetExpiration sets the "expiration" field.
func (m *GrantMutation) SetExpiration(gp grant.ExpirationPeriod) {
	m.expiration = &gp
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *GrantMutation) Expiration() (r grant.ExpirationPeriod, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldExpiration(ctx context.Context) (v grant.ExpirationPeriod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *GrantMutation) ResetExpiration() {
	m.expiration = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *GrantMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *GrantMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *GrantMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetVoidedAt sets the "voided_at" field.
func (m *GrantMutation) SetVoidedAt(t time.Time) {
	m.voided_at = &t
}

// VoidedAt returns the value of the "voided_at" field in the mutation.
func (m *GrantMutation) VoidedAt() (r time.Time, exists bool) {
	v := m.voided_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidedAt returns the old "voided_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldVoidedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidedAt: %w", err)
	}
	return oldValue.VoidedAt, nil
}

// ClearVoidedAt clears the value of the "voided_at" field.
func (m *GrantMutation) ClearVoidedAt() {
	m.voided_at = nil
	m.clearedFields[dbgrant.FieldVoidedAt] = struct{}{}
}

// VoidedAtCleared returns if the "voided_at" field was cleared in this mutation.
func (m *GrantMutation) VoidedAtCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldVoidedAt]
	return ok
}

// ResetVoidedAt resets all changes to the "voided_at" field.
func (m *GrantMutation) ResetVoidedAt() {
	m.voided_at = nil
	delete(m.clearedFields, dbgrant.FieldVoidedAt)
}

// SetResetMaxRollover sets the "reset_max_rollover" field.
func (m *GrantMutation) SetResetMaxRollover(f float64) {
	m.reset_max_rollover = &f
	m.addreset_max_rollover = nil
}

// ResetMaxRollover returns the value of the "reset_max_rollover" field in the mutation.
func (m *GrantMutation) ResetMaxRollover() (r float64, exists bool) {
	v := m.reset_max_rollover
	if v == nil {
		return
	}
	return *v, true
}

// OldResetMaxRollover returns the old "reset_max_rollover" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldResetMaxRollover(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetMaxRollover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetMaxRollover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetMaxRollover: %w", err)
	}
	return oldValue.ResetMaxRollover, nil
}

// AddResetMaxRollover adds f to the "reset_max_rollover" field.
func (m *GrantMutation) AddResetMaxRollover(f float64) {
	if m.addreset_max_rollover != nil {
		*m.addreset_max_rollover += f
	} else {
		m.addreset_max_rollover = &f
	}
}

// AddedResetMaxRollover returns the value that was added to the "reset_max_rollover" field in this mutation.
func (m *GrantMutation) AddedResetMaxRollover() (r float64, exists bool) {
	v := m.addreset_max_rollover
	if v == nil {
		return
	}
	return *v, true
}

// ResetResetMaxRollover resets all changes to the "reset_max_rollover" field.
func (m *GrantMutation) ResetResetMaxRollover() {
	m.reset_max_rollover = nil
	m.addreset_max_rollover = nil
}

// SetResetMinRollover sets the "reset_min_rollover" field.
func (m *GrantMutation) SetResetMinRollover(f float64) {
	m.reset_min_rollover = &f
	m.addreset_min_rollover = nil
}

// ResetMinRollover returns the value of the "reset_min_rollover" field in the mutation.
func (m *GrantMutation) ResetMinRollover() (r float64, exists bool) {
	v := m.reset_min_rollover
	if v == nil {
		return
	}
	return *v, true
}

// OldResetMinRollover returns the old "reset_min_rollover" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldResetMinRollover(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetMinRollover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetMinRollover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetMinRollover: %w", err)
	}
	return oldValue.ResetMinRollover, nil
}

// AddResetMinRollover adds f to the "reset_min_rollover" field.
func (m *GrantMutation) AddResetMinRollover(f float64) {
	if m.addreset_min_rollover != nil {
		*m.addreset_min_rollover += f
	} else {
		m.addreset_min_rollover = &f
	}
}

// AddedResetMinRollover returns the value that was added to the "reset_min_rollover" field in this mutation.
func (m *GrantMutation) AddedResetMinRollover() (r float64, exists bool) {
	v := m.addreset_min_rollover
	if v == nil {
		return
	}
	return *v, true
}

// ResetResetMinRollover resets all changes to the "reset_min_rollover" field.
func (m *GrantMutation) ResetResetMinRollover() {
	m.reset_min_rollover = nil
	m.addreset_min_rollover = nil
}

// SetRecurrencePeriod sets the "recurrence_period" field.
func (m *GrantMutation) SetRecurrencePeriod(ri recurrence.RecurrenceInterval) {
	m.recurrence_period = &ri
}

// RecurrencePeriod returns the value of the "recurrence_period" field in the mutation.
func (m *GrantMutation) RecurrencePeriod() (r recurrence.RecurrenceInterval, exists bool) {
	v := m.recurrence_period
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrencePeriod returns the old "recurrence_period" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRecurrencePeriod(ctx context.Context) (v *recurrence.RecurrenceInterval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrencePeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrencePeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrencePeriod: %w", err)
	}
	return oldValue.RecurrencePeriod, nil
}

// ClearRecurrencePeriod clears the value of the "recurrence_period" field.
func (m *GrantMutation) ClearRecurrencePeriod() {
	m.recurrence_period = nil
	m.clearedFields[dbgrant.FieldRecurrencePeriod] = struct{}{}
}

// RecurrencePeriodCleared returns if the "recurrence_period" field was cleared in this mutation.
func (m *GrantMutation) RecurrencePeriodCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldRecurrencePeriod]
	return ok
}

// ResetRecurrencePeriod resets all changes to the "recurrence_period" field.
func (m *GrantMutation) ResetRecurrencePeriod() {
	m.recurrence_period = nil
	delete(m.clearedFields, dbgrant.FieldRecurrencePeriod)
}

// SetRecurrenceAnchor sets the "recurrence_anchor" field.
func (m *GrantMutation) SetRecurrenceAnchor(t time.Time) {
	m.recurrence_anchor = &t
}

// RecurrenceAnchor returns the value of the "recurrence_anchor" field in the mutation.
func (m *GrantMutation) RecurrenceAnchor() (r time.Time, exists bool) {
	v := m.recurrence_anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrenceAnchor returns the old "recurrence_anchor" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRecurrenceAnchor(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrenceAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrenceAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrenceAnchor: %w", err)
	}
	return oldValue.RecurrenceAnchor, nil
}

// ClearRecurrenceAnchor clears the value of the "recurrence_anchor" field.
func (m *GrantMutation) ClearRecurrenceAnchor() {
	m.recurrence_anchor = nil
	m.clearedFields[dbgrant.FieldRecurrenceAnchor] = struct{}{}
}

// RecurrenceAnchorCleared returns if the "recurrence_anchor" field was cleared in this mutation.
func (m *GrantMutation) RecurrenceAnchorCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldRecurrenceAnchor]
	return ok
}

// ResetRecurrenceAnchor resets all changes to the "recurrence_anchor" field.
func (m *GrantMutation) ResetRecurrenceAnchor() {
	m.recurrence_anchor = nil
	delete(m.clearedFields, dbgrant.FieldRecurrenceAnchor)
}

// SetEntitlementID sets the "entitlement" edge to the Entitlement entity by id.
func (m *GrantMutation) SetEntitlementID(id string) {
	m.entitlement = &id
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *GrantMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[dbgrant.FieldOwnerID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *GrantMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementID returns the "entitlement" edge ID in the mutation.
func (m *GrantMutation) EntitlementID() (id string, exists bool) {
	if m.entitlement != nil {
		return *m.entitlement, true
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *GrantMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *GrantMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the GrantMutation builder.
func (m *GrantMutation) Where(ps ...predicate.Grant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GrantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GrantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Grant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GrantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GrantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Grant).
func (m *GrantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GrantMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.namespace != nil {
		fields = append(fields, dbgrant.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, dbgrant.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, dbgrant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dbgrant.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dbgrant.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, dbgrant.FieldOwnerID)
	}
	if m.amount != nil {
		fields = append(fields, dbgrant.FieldAmount)
	}
	if m.priority != nil {
		fields = append(fields, dbgrant.FieldPriority)
	}
	if m.effective_at != nil {
		fields = append(fields, dbgrant.FieldEffectiveAt)
	}
	if m.expiration != nil {
		fields = append(fields, dbgrant.FieldExpiration)
	}
	if m.expires_at != nil {
		fields = append(fields, dbgrant.FieldExpiresAt)
	}
	if m.voided_at != nil {
		fields = append(fields, dbgrant.FieldVoidedAt)
	}
	if m.reset_max_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMaxRollover)
	}
	if m.reset_min_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMinRollover)
	}
	if m.recurrence_period != nil {
		fields = append(fields, dbgrant.FieldRecurrencePeriod)
	}
	if m.recurrence_anchor != nil {
		fields = append(fields, dbgrant.FieldRecurrenceAnchor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GrantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbgrant.FieldNamespace:
		return m.Namespace()
	case dbgrant.FieldMetadata:
		return m.Metadata()
	case dbgrant.FieldCreatedAt:
		return m.CreatedAt()
	case dbgrant.FieldUpdatedAt:
		return m.UpdatedAt()
	case dbgrant.FieldDeletedAt:
		return m.DeletedAt()
	case dbgrant.FieldOwnerID:
		return m.OwnerID()
	case dbgrant.FieldAmount:
		return m.Amount()
	case dbgrant.FieldPriority:
		return m.Priority()
	case dbgrant.FieldEffectiveAt:
		return m.EffectiveAt()
	case dbgrant.FieldExpiration:
		return m.Expiration()
	case dbgrant.FieldExpiresAt:
		return m.ExpiresAt()
	case dbgrant.FieldVoidedAt:
		return m.VoidedAt()
	case dbgrant.FieldResetMaxRollover:
		return m.ResetMaxRollover()
	case dbgrant.FieldResetMinRollover:
		return m.ResetMinRollover()
	case dbgrant.FieldRecurrencePeriod:
		return m.RecurrencePeriod()
	case dbgrant.FieldRecurrenceAnchor:
		return m.RecurrenceAnchor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GrantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbgrant.FieldNamespace:
		return m.OldNamespace(ctx)
	case dbgrant.FieldMetadata:
		return m.OldMetadata(ctx)
	case dbgrant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dbgrant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dbgrant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dbgrant.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case dbgrant.FieldAmount:
		return m.OldAmount(ctx)
	case dbgrant.FieldPriority:
		return m.OldPriority(ctx)
	case dbgrant.FieldEffectiveAt:
		return m.OldEffectiveAt(ctx)
	case dbgrant.FieldExpiration:
		return m.OldExpiration(ctx)
	case dbgrant.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case dbgrant.FieldVoidedAt:
		return m.OldVoidedAt(ctx)
	case dbgrant.FieldResetMaxRollover:
		return m.OldResetMaxRollover(ctx)
	case dbgrant.FieldResetMinRollover:
		return m.OldResetMinRollover(ctx)
	case dbgrant.FieldRecurrencePeriod:
		return m.OldRecurrencePeriod(ctx)
	case dbgrant.FieldRecurrenceAnchor:
		return m.OldRecurrenceAnchor(ctx)
	}
	return nil, fmt.Errorf("unknown Grant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbgrant.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case dbgrant.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case dbgrant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dbgrant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dbgrant.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dbgrant.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case dbgrant.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case dbgrant.FieldPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case dbgrant.FieldEffectiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveAt(v)
		return nil
	case dbgrant.FieldExpiration:
		v, ok := value.(grant.ExpirationPeriod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case dbgrant.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case dbgrant.FieldVoidedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidedAt(v)
		return nil
	case dbgrant.FieldResetMaxRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetMaxRollover(v)
		return nil
	case dbgrant.FieldResetMinRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetMinRollover(v)
		return nil
	case dbgrant.FieldRecurrencePeriod:
		v, ok := value.(recurrence.RecurrenceInterval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrencePeriod(v)
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrenceAnchor(v)
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GrantMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, dbgrant.FieldAmount)
	}
	if m.addpriority != nil {
		fields = append(fields, dbgrant.FieldPriority)
	}
	if m.addreset_max_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMaxRollover)
	}
	if m.addreset_min_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMinRollover)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GrantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dbgrant.FieldAmount:
		return m.AddedAmount()
	case dbgrant.FieldPriority:
		return m.AddedPriority()
	case dbgrant.FieldResetMaxRollover:
		return m.AddedResetMaxRollover()
	case dbgrant.FieldResetMinRollover:
		return m.AddedResetMinRollover()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dbgrant.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case dbgrant.FieldPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case dbgrant.FieldResetMaxRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResetMaxRollover(v)
		return nil
	case dbgrant.FieldResetMinRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResetMinRollover(v)
		return nil
	}
	return fmt.Errorf("unknown Grant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GrantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbgrant.FieldMetadata) {
		fields = append(fields, dbgrant.FieldMetadata)
	}
	if m.FieldCleared(dbgrant.FieldDeletedAt) {
		fields = append(fields, dbgrant.FieldDeletedAt)
	}
	if m.FieldCleared(dbgrant.FieldVoidedAt) {
		fields = append(fields, dbgrant.FieldVoidedAt)
	}
	if m.FieldCleared(dbgrant.FieldRecurrencePeriod) {
		fields = append(fields, dbgrant.FieldRecurrencePeriod)
	}
	if m.FieldCleared(dbgrant.FieldRecurrenceAnchor) {
		fields = append(fields, dbgrant.FieldRecurrenceAnchor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GrantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrantMutation) ClearField(name string) error {
	switch name {
	case dbgrant.FieldMetadata:
		m.ClearMetadata()
		return nil
	case dbgrant.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dbgrant.FieldVoidedAt:
		m.ClearVoidedAt()
		return nil
	case dbgrant.FieldRecurrencePeriod:
		m.ClearRecurrencePeriod()
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		m.ClearRecurrenceAnchor()
		return nil
	}
	return fmt.Errorf("unknown Grant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GrantMutation) ResetField(name string) error {
	switch name {
	case dbgrant.FieldNamespace:
		m.ResetNamespace()
		return nil
	case dbgrant.FieldMetadata:
		m.ResetMetadata()
		return nil
	case dbgrant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dbgrant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dbgrant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dbgrant.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case dbgrant.FieldAmount:
		m.ResetAmount()
		return nil
	case dbgrant.FieldPriority:
		m.ResetPriority()
		return nil
	case dbgrant.FieldEffectiveAt:
		m.ResetEffectiveAt()
		return nil
	case dbgrant.FieldExpiration:
		m.ResetExpiration()
		return nil
	case dbgrant.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case dbgrant.FieldVoidedAt:
		m.ResetVoidedAt()
		return nil
	case dbgrant.FieldResetMaxRollover:
		m.ResetResetMaxRollover()
		return nil
	case dbgrant.FieldResetMinRollover:
		m.ResetResetMinRollover()
		return nil
	case dbgrant.FieldRecurrencePeriod:
		m.ResetRecurrencePeriod()
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		m.ResetRecurrenceAnchor()
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GrantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, dbgrant.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GrantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbgrant.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GrantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GrantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GrantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, dbgrant.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GrantMutation) EdgeCleared(name string) bool {
	switch name {
	case dbgrant.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GrantMutation) ClearEdge(name string) error {
	switch name {
	case dbgrant.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown Grant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GrantMutation) ResetEdge(name string) error {
	switch name {
	case dbgrant.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown Grant edge %s", name)
}

// NotificationChannelMutation represents an operation that mutates the NotificationChannel nodes in the graph.
type NotificationChannelMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	_type         *notification.ChannelType
	name          *string
	disabled      *bool
	_config       *notification.ChannelConfig
	clearedFields map[string]struct{}
	rules         map[string]struct{}
	removedrules  map[string]struct{}
	clearedrules  bool
	done          bool
	oldValue      func(context.Context) (*NotificationChannel, error)
	predicates    []predicate.NotificationChannel
}

var _ ent.Mutation = (*NotificationChannelMutation)(nil)

// notificationchannelOption allows management of the mutation configuration using functional options.
type notificationchannelOption func(*NotificationChannelMutation)

// newNotificationChannelMutation creates new mutation for the NotificationChannel entity.
func newNotificationChannelMutation(c config, op Op, opts ...notificationchannelOption) *NotificationChannelMutation {
	m := &NotificationChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationChannelID sets the ID field of the mutation.
func withNotificationChannelID(id string) notificationchannelOption {
	return func(m *NotificationChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationChannel
		)
		m.oldValue = func(ctx context.Context) (*NotificationChannel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationChannel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationChannel sets the old NotificationChannel of the mutation.
func withNotificationChannel(node *NotificationChannel) notificationchannelOption {
	return func(m *NotificationChannelMutation) {
		m.oldValue = func(context.Context) (*NotificationChannel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationChannel entities.
func (m *NotificationChannelMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationChannelMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationChannelMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationChannel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationChannelMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationChannelMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationChannelMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationChannelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationChannelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationChannelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationchannel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationChannelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationchannel.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *NotificationChannelMutation) SetType(nt notification.ChannelType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationChannelMutation) GetType() (r notification.ChannelType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldType(ctx context.Context) (v notification.ChannelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationChannelMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *NotificationChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationChannelMutation) ResetName() {
	m.name = nil
}

// SetDisabled sets the "disabled" field.
func (m *NotificationChannelMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *NotificationChannelMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *NotificationChannelMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[notificationchannel.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *NotificationChannelMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *NotificationChannelMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, notificationchannel.FieldDisabled)
}

// SetConfig sets the "config" field.
func (m *NotificationChannelMutation) SetConfig(nc notification.ChannelConfig) {
	m._config = &nc
}

// Config returns the value of the "config" field in the mutation.
func (m *NotificationChannelMutation) Config() (r notification.ChannelConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldConfig(ctx context.Context) (v notification.ChannelConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NotificationChannelMutation) ResetConfig() {
	m._config = nil
}

// AddRuleIDs adds the "rules" edge to the NotificationRule entity by ids.
func (m *NotificationChannelMutation) AddRuleIDs(ids ...string) {
	if m.rules == nil {
		m.rules = make(map[string]struct{})
	}
	for i := range ids {
		m.rules[ids[i]] = struct{}{}
	}
}

// ClearRules clears the "rules" edge to the NotificationRule entity.
func (m *NotificationChannelMutation) ClearRules() {
	m.clearedrules = true
}

// RulesCleared reports if the "rules" edge to the NotificationRule entity was cleared.
func (m *NotificationChannelMutation) RulesCleared() bool {
	return m.clearedrules
}

// RemoveRuleIDs removes the "rules" edge to the NotificationRule entity by IDs.
func (m *NotificationChannelMutation) RemoveRuleIDs(ids ...string) {
	if m.removedrules == nil {
		m.removedrules = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rules, ids[i])
		m.removedrules[ids[i]] = struct{}{}
	}
}

// RemovedRules returns the removed IDs of the "rules" edge to the NotificationRule entity.
func (m *NotificationChannelMutation) RemovedRulesIDs() (ids []string) {
	for id := range m.removedrules {
		ids = append(ids, id)
	}
	return
}

// RulesIDs returns the "rules" edge IDs in the mutation.
func (m *NotificationChannelMutation) RulesIDs() (ids []string) {
	for id := range m.rules {
		ids = append(ids, id)
	}
	return
}

// ResetRules resets all changes to the "rules" edge.
func (m *NotificationChannelMutation) ResetRules() {
	m.rules = nil
	m.clearedrules = false
	m.removedrules = nil
}

// Where appends a list predicates to the NotificationChannelMutation builder.
func (m *NotificationChannelMutation) Where(ps ...predicate.NotificationChannel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationChannel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationChannel).
func (m *NotificationChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationChannelMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, notificationchannel.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationchannel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationchannel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notificationchannel.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationchannel.FieldType)
	}
	if m.name != nil {
		fields = append(fields, notificationchannel.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, notificationchannel.FieldDisabled)
	}
	if m._config != nil {
		fields = append(fields, notificationchannel.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationchannel.FieldNamespace:
		return m.Namespace()
	case notificationchannel.FieldCreatedAt:
		return m.CreatedAt()
	case notificationchannel.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationchannel.FieldDeletedAt:
		return m.DeletedAt()
	case notificationchannel.FieldType:
		return m.GetType()
	case notificationchannel.FieldName:
		return m.Name()
	case notificationchannel.FieldDisabled:
		return m.Disabled()
	case notificationchannel.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationchannel.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationchannel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationchannel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationchannel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notificationchannel.FieldType:
		return m.OldType(ctx)
	case notificationchannel.FieldName:
		return m.OldName(ctx)
	case notificationchannel.FieldDisabled:
		return m.OldDisabled(ctx)
	case notificationchannel.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationChannel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationchannel.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationchannel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationchannel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationchannel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notificationchannel.FieldType:
		v, ok := value.(notification.ChannelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationchannel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationchannel.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case notificationchannel.FieldConfig:
		v, ok := value.(notification.ChannelConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationChannelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationChannelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationChannel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationchannel.FieldDeletedAt) {
		fields = append(fields, notificationchannel.FieldDeletedAt)
	}
	if m.FieldCleared(notificationchannel.FieldDisabled) {
		fields = append(fields, notificationchannel.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationChannelMutation) ClearField(name string) error {
	switch name {
	case notificationchannel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notificationchannel.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationChannelMutation) ResetField(name string) error {
	switch name {
	case notificationchannel.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationchannel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationchannel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationchannel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notificationchannel.FieldType:
		m.ResetType()
		return nil
	case notificationchannel.FieldName:
		m.ResetName()
		return nil
	case notificationchannel.FieldDisabled:
		m.ResetDisabled()
		return nil
	case notificationchannel.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rules != nil {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationchannel.EdgeRules:
		ids := make([]ent.Value, 0, len(m.rules))
		for id := range m.rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrules != nil {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationchannel.EdgeRules:
		ids := make([]ent.Value, 0, len(m.removedrules))
		for id := range m.removedrules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrules {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationchannel.EdgeRules:
		return m.clearedrules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationChannel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationChannelMutation) ResetEdge(name string) error {
	switch name {
	case notificationchannel.EdgeRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel edge %s", name)
}

// NotificationEventMutation represents an operation that mutates the NotificationEvent nodes in the graph.
type NotificationEventMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	namespace                *string
	created_at               *time.Time
	_type                    *notification.EventType
	payload                  *string
	annotations              *map[string]interface{}
	clearedFields            map[string]struct{}
	delivery_statuses        map[string]struct{}
	removeddelivery_statuses map[string]struct{}
	cleareddelivery_statuses bool
	rules                    *string
	clearedrules             bool
	done                     bool
	oldValue                 func(context.Context) (*NotificationEvent, error)
	predicates               []predicate.NotificationEvent
}

var _ ent.Mutation = (*NotificationEventMutation)(nil)

// notificationeventOption allows management of the mutation configuration using functional options.
type notificationeventOption func(*NotificationEventMutation)

// newNotificationEventMutation creates new mutation for the NotificationEvent entity.
func newNotificationEventMutation(c config, op Op, opts ...notificationeventOption) *NotificationEventMutation {
	m := &NotificationEventMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationEventID sets the ID field of the mutation.
func withNotificationEventID(id string) notificationeventOption {
	return func(m *NotificationEventMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationEvent
		)
		m.oldValue = func(ctx context.Context) (*NotificationEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationEvent sets the old NotificationEvent of the mutation.
func withNotificationEvent(node *NotificationEvent) notificationeventOption {
	return func(m *NotificationEventMutation) {
		m.oldValue = func(context.Context) (*NotificationEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationEvent entities.
func (m *NotificationEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationEventMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationEventMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationEventMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetType sets the "type" field.
func (m *NotificationEventMutation) SetType(nt notification.EventType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationEventMutation) GetType() (r notification.EventType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldType(ctx context.Context) (v notification.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationEventMutation) ResetType() {
	m._type = nil
}

// SetRuleID sets the "rule_id" field.
func (m *NotificationEventMutation) SetRuleID(s string) {
	m.rules = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *NotificationEventMutation) RuleID() (r string, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *NotificationEventMutation) ResetRuleID() {
	m.rules = nil
}

// SetPayload sets the "payload" field.
func (m *NotificationEventMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *NotificationEventMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *NotificationEventMutation) ResetPayload() {
	m.payload = nil
}

// SetAnnotations sets the "annotations" field.
func (m *NotificationEventMutation) SetAnnotations(value map[string]interface{}) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *NotificationEventMutation) Annotations() (r map[string]interface{}, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldAnnotations(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *NotificationEventMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[notificationevent.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *NotificationEventMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[notificationevent.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *NotificationEventMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, notificationevent.FieldAnnotations)
}

// AddDeliveryStatusIDs adds the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity by ids.
func (m *NotificationEventMutation) AddDeliveryStatusIDs(ids ...string) {
	if m.delivery_statuses == nil {
		m.delivery_statuses = make(map[string]struct{})
	}
	for i := range ids {
		m.delivery_statuses[ids[i]] = struct{}{}
	}
}

// ClearDeliveryStatuses clears the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity.
func (m *NotificationEventMutation) ClearDeliveryStatuses() {
	m.cleareddelivery_statuses = true
}

// DeliveryStatusesCleared reports if the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity was cleared.
func (m *NotificationEventMutation) DeliveryStatusesCleared() bool {
	return m.cleareddelivery_statuses
}

// RemoveDeliveryStatusIDs removes the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity by IDs.
func (m *NotificationEventMutation) RemoveDeliveryStatusIDs(ids ...string) {
	if m.removeddelivery_statuses == nil {
		m.removeddelivery_statuses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.delivery_statuses, ids[i])
		m.removeddelivery_statuses[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryStatuses returns the removed IDs of the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity.
func (m *NotificationEventMutation) RemovedDeliveryStatusesIDs() (ids []string) {
	for id := range m.removeddelivery_statuses {
		ids = append(ids, id)
	}
	return
}

// DeliveryStatusesIDs returns the "delivery_statuses" edge IDs in the mutation.
func (m *NotificationEventMutation) DeliveryStatusesIDs() (ids []string) {
	for id := range m.delivery_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryStatuses resets all changes to the "delivery_statuses" edge.
func (m *NotificationEventMutation) ResetDeliveryStatuses() {
	m.delivery_statuses = nil
	m.cleareddelivery_statuses = false
	m.removeddelivery_statuses = nil
}

// SetRulesID sets the "rules" edge to the NotificationRule entity by id.
func (m *NotificationEventMutation) SetRulesID(id string) {
	m.rules = &id
}

// ClearRules clears the "rules" edge to the NotificationRule entity.
func (m *NotificationEventMutation) ClearRules() {
	m.clearedrules = true
	m.clearedFields[notificationevent.FieldRuleID] = struct{}{}
}

// RulesCleared reports if the "rules" edge to the NotificationRule entity was cleared.
func (m *NotificationEventMutation) RulesCleared() bool {
	return m.clearedrules
}

// RulesID returns the "rules" edge ID in the mutation.
func (m *NotificationEventMutation) RulesID() (id string, exists bool) {
	if m.rules != nil {
		return *m.rules, true
	}
	return
}

// RulesIDs returns the "rules" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RulesID instead. It exists only for internal usage by the builders.
func (m *NotificationEventMutation) RulesIDs() (ids []string) {
	if id := m.rules; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRules resets all changes to the "rules" edge.
func (m *NotificationEventMutation) ResetRules() {
	m.rules = nil
	m.clearedrules = false
}

// Where appends a list predicates to the NotificationEventMutation builder.
func (m *NotificationEventMutation) Where(ps ...predicate.NotificationEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationEvent).
func (m *NotificationEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationEventMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.namespace != nil {
		fields = append(fields, notificationevent.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationevent.FieldCreatedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationevent.FieldType)
	}
	if m.rules != nil {
		fields = append(fields, notificationevent.FieldRuleID)
	}
	if m.payload != nil {
		fields = append(fields, notificationevent.FieldPayload)
	}
	if m.annotations != nil {
		fields = append(fields, notificationevent.FieldAnnotations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationevent.FieldNamespace:
		return m.Namespace()
	case notificationevent.FieldCreatedAt:
		return m.CreatedAt()
	case notificationevent.FieldType:
		return m.GetType()
	case notificationevent.FieldRuleID:
		return m.RuleID()
	case notificationevent.FieldPayload:
		return m.Payload()
	case notificationevent.FieldAnnotations:
		return m.Annotations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationevent.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationevent.FieldType:
		return m.OldType(ctx)
	case notificationevent.FieldRuleID:
		return m.OldRuleID(ctx)
	case notificationevent.FieldPayload:
		return m.OldPayload(ctx)
	case notificationevent.FieldAnnotations:
		return m.OldAnnotations(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationevent.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationevent.FieldType:
		v, ok := value.(notification.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationevent.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case notificationevent.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case notificationevent.FieldAnnotations:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationevent.FieldAnnotations) {
		fields = append(fields, notificationevent.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationEventMutation) ClearField(name string) error {
	switch name {
	case notificationevent.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationEventMutation) ResetField(name string) error {
	switch name {
	case notificationevent.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationevent.FieldType:
		m.ResetType()
		return nil
	case notificationevent.FieldRuleID:
		m.ResetRuleID()
		return nil
	case notificationevent.FieldPayload:
		m.ResetPayload()
		return nil
	case notificationevent.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.delivery_statuses != nil {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	if m.rules != nil {
		edges = append(edges, notificationevent.EdgeRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		ids := make([]ent.Value, 0, len(m.delivery_statuses))
		for id := range m.delivery_statuses {
			ids = append(ids, id)
		}
		return ids
	case notificationevent.EdgeRules:
		if id := m.rules; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddelivery_statuses != nil {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		ids := make([]ent.Value, 0, len(m.removeddelivery_statuses))
		for id := range m.removeddelivery_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddelivery_statuses {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	if m.clearedrules {
		edges = append(edges, notificationevent.EdgeRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationEventMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		return m.cleareddelivery_statuses
	case notificationevent.EdgeRules:
		return m.clearedrules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationEventMutation) ClearEdge(name string) error {
	switch name {
	case notificationevent.EdgeRules:
		m.ClearRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationEventMutation) ResetEdge(name string) error {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		m.ResetDeliveryStatuses()
		return nil
	case notificationevent.EdgeRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent edge %s", name)
}

// NotificationEventDeliveryStatusMutation represents an operation that mutates the NotificationEventDeliveryStatus nodes in the graph.
type NotificationEventDeliveryStatusMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	created_at    *time.Time
	updated_at    *time.Time
	event_id      *string
	channel_id    *string
	state         *notification.EventDeliveryStatusState
	reason        *string
	clearedFields map[string]struct{}
	events        map[string]struct{}
	removedevents map[string]struct{}
	clearedevents bool
	done          bool
	oldValue      func(context.Context) (*NotificationEventDeliveryStatus, error)
	predicates    []predicate.NotificationEventDeliveryStatus
}

var _ ent.Mutation = (*NotificationEventDeliveryStatusMutation)(nil)

// notificationeventdeliverystatusOption allows management of the mutation configuration using functional options.
type notificationeventdeliverystatusOption func(*NotificationEventDeliveryStatusMutation)

// newNotificationEventDeliveryStatusMutation creates new mutation for the NotificationEventDeliveryStatus entity.
func newNotificationEventDeliveryStatusMutation(c config, op Op, opts ...notificationeventdeliverystatusOption) *NotificationEventDeliveryStatusMutation {
	m := &NotificationEventDeliveryStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationEventDeliveryStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationEventDeliveryStatusID sets the ID field of the mutation.
func withNotificationEventDeliveryStatusID(id string) notificationeventdeliverystatusOption {
	return func(m *NotificationEventDeliveryStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationEventDeliveryStatus
		)
		m.oldValue = func(ctx context.Context) (*NotificationEventDeliveryStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationEventDeliveryStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationEventDeliveryStatus sets the old NotificationEventDeliveryStatus of the mutation.
func withNotificationEventDeliveryStatus(node *NotificationEventDeliveryStatus) notificationeventdeliverystatusOption {
	return func(m *NotificationEventDeliveryStatusMutation) {
		m.oldValue = func(context.Context) (*NotificationEventDeliveryStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationEventDeliveryStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationEventDeliveryStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationEventDeliveryStatus entities.
func (m *NotificationEventDeliveryStatusMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationEventDeliveryStatusMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationEventDeliveryStatusMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationEventDeliveryStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationEventDeliveryStatusMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationEventDeliveryStatusMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationEventDeliveryStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationEventDeliveryStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationEventDeliveryStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationEventDeliveryStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventID sets the "event_id" field.
func (m *NotificationEventDeliveryStatusMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *NotificationEventDeliveryStatusMutation) ResetEventID() {
	m.event_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *NotificationEventDeliveryStatusMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *NotificationEventDeliveryStatusMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetState sets the "state" field.
func (m *NotificationEventDeliveryStatusMutation) SetState(ndss notification.EventDeliveryStatusState) {
	m.state = &ndss
}

// State returns the value of the "state" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) State() (r notification.EventDeliveryStatusState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldState(ctx context.Context) (v notification.EventDeliveryStatusState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *NotificationEventDeliveryStatusMutation) ResetState() {
	m.state = nil
}

// SetReason sets the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[notificationeventdeliverystatus.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[notificationeventdeliverystatus.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, notificationeventdeliverystatus.FieldReason)
}

// AddEventIDs adds the "events" edge to the NotificationEvent entity by ids.
func (m *NotificationEventDeliveryStatusMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the NotificationEvent entity.
func (m *NotificationEventDeliveryStatusMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the NotificationEvent entity was cleared.
func (m *NotificationEventDeliveryStatusMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the NotificationEvent entity by IDs.
func (m *NotificationEventDeliveryStatusMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the NotificationEvent entity.
func (m *NotificationEventDeliveryStatusMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *NotificationEventDeliveryStatusMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *NotificationEventDeliveryStatusMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the NotificationEventDeliveryStatusMutation builder.
func (m *NotificationEventDeliveryStatusMutation) Where(ps ...predicate.NotificationEventDeliveryStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationEventDeliveryStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationEventDeliveryStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationEventDeliveryStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationEventDeliveryStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationEventDeliveryStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationEventDeliveryStatus).
func (m *NotificationEventDeliveryStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationEventDeliveryStatusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.namespace != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldUpdatedAt)
	}
	if m.event_id != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldEventID)
	}
	if m.channel_id != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldChannelID)
	}
	if m.state != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldState)
	}
	if m.reason != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationEventDeliveryStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		return m.Namespace()
	case notificationeventdeliverystatus.FieldCreatedAt:
		return m.CreatedAt()
	case notificationeventdeliverystatus.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationeventdeliverystatus.FieldEventID:
		return m.EventID()
	case notificationeventdeliverystatus.FieldChannelID:
		return m.ChannelID()
	case notificationeventdeliverystatus.FieldState:
		return m.State()
	case notificationeventdeliverystatus.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationEventDeliveryStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationeventdeliverystatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationeventdeliverystatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationeventdeliverystatus.FieldEventID:
		return m.OldEventID(ctx)
	case notificationeventdeliverystatus.FieldChannelID:
		return m.OldChannelID(ctx)
	case notificationeventdeliverystatus.FieldState:
		return m.OldState(ctx)
	case notificationeventdeliverystatus.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventDeliveryStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationeventdeliverystatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationeventdeliverystatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationeventdeliverystatus.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case notificationeventdeliverystatus.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case notificationeventdeliverystatus.FieldState:
		v, ok := value.(notification.EventDeliveryStatusState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case notificationeventdeliverystatus.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventDeliveryStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationEventDeliveryStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationeventdeliverystatus.FieldReason) {
		fields = append(fields, notificationeventdeliverystatus.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ClearField(name string) error {
	switch name {
	case notificationeventdeliverystatus.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ResetField(name string) error {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationeventdeliverystatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationeventdeliverystatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationeventdeliverystatus.FieldEventID:
		m.ResetEventID()
		return nil
	case notificationeventdeliverystatus.FieldChannelID:
		m.ResetChannelID()
		return nil
	case notificationeventdeliverystatus.FieldState:
		m.ResetState()
		return nil
	case notificationeventdeliverystatus.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationEventDeliveryStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationEventDeliveryStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ResetEdge(name string) error {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus edge %s", name)
}

// NotificationRuleMutation represents an operation that mutates the NotificationRule nodes in the graph.
type NotificationRuleMutation struct {
	config
	op              Op
	typ             string
	id              *string
	namespace       *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	_type           *notification.RuleType
	name            *string
	disabled        *bool
	_config         *notification.RuleConfig
	clearedFields   map[string]struct{}
	channels        map[string]struct{}
	removedchannels map[string]struct{}
	clearedchannels bool
	events          map[string]struct{}
	removedevents   map[string]struct{}
	clearedevents   bool
	done            bool
	oldValue        func(context.Context) (*NotificationRule, error)
	predicates      []predicate.NotificationRule
}

var _ ent.Mutation = (*NotificationRuleMutation)(nil)

// notificationruleOption allows management of the mutation configuration using functional options.
type notificationruleOption func(*NotificationRuleMutation)

// newNotificationRuleMutation creates new mutation for the NotificationRule entity.
func newNotificationRuleMutation(c config, op Op, opts ...notificationruleOption) *NotificationRuleMutation {
	m := &NotificationRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationRuleID sets the ID field of the mutation.
func withNotificationRuleID(id string) notificationruleOption {
	return func(m *NotificationRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationRule
		)
		m.oldValue = func(ctx context.Context) (*NotificationRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationRule sets the old NotificationRule of the mutation.
func withNotificationRule(node *NotificationRule) notificationruleOption {
	return func(m *NotificationRuleMutation) {
		m.oldValue = func(context.Context) (*NotificationRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationRule entities.
func (m *NotificationRuleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationRuleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationRuleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationRuleMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationRuleMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationRuleMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationRuleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationRuleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationRuleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationrule.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationRuleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationrule.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationRuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationrule.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *NotificationRuleMutation) SetType(nt notification.RuleType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationRuleMutation) GetType() (r notification.RuleType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldType(ctx context.Context) (v notification.RuleType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationRuleMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *NotificationRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationRuleMutation) ResetName() {
	m.name = nil
}

// SetDisabled sets the "disabled" field.
func (m *NotificationRuleMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *NotificationRuleMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *NotificationRuleMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[notificationrule.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *NotificationRuleMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[notificationrule.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *NotificationRuleMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, notificationrule.FieldDisabled)
}

// SetConfig sets the "config" field.
func (m *NotificationRuleMutation) SetConfig(nc notification.RuleConfig) {
	m._config = &nc
}

// Config returns the value of the "config" field in the mutation.
func (m *NotificationRuleMutation) Config() (r notification.RuleConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldConfig(ctx context.Context) (v notification.RuleConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NotificationRuleMutation) ResetConfig() {
	m._config = nil
}

// AddChannelIDs adds the "channels" edge to the NotificationChannel entity by ids.
func (m *NotificationRuleMutation) AddChannelIDs(ids ...string) {
	if m.channels == nil {
		m.channels = make(map[string]struct{})
	}
	for i := range ids {
		m.channels[ids[i]] = struct{}{}
	}
}

// ClearChannels clears the "channels" edge to the NotificationChannel entity.
func (m *NotificationRuleMutation) ClearChannels() {
	m.clearedchannels = true
}

// ChannelsCleared reports if the "channels" edge to the NotificationChannel entity was cleared.
func (m *NotificationRuleMutation) ChannelsCleared() bool {
	return m.clearedchannels
}

// RemoveChannelIDs removes the "channels" edge to the NotificationChannel entity by IDs.
func (m *NotificationRuleMutation) RemoveChannelIDs(ids ...string) {
	if m.removedchannels == nil {
		m.removedchannels = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.channels, ids[i])
		m.removedchannels[ids[i]] = struct{}{}
	}
}

// RemovedChannels returns the removed IDs of the "channels" edge to the NotificationChannel entity.
func (m *NotificationRuleMutation) RemovedChannelsIDs() (ids []string) {
	for id := range m.removedchannels {
		ids = append(ids, id)
	}
	return
}

// ChannelsIDs returns the "channels" edge IDs in the mutation.
func (m *NotificationRuleMutation) ChannelsIDs() (ids []string) {
	for id := range m.channels {
		ids = append(ids, id)
	}
	return
}

// ResetChannels resets all changes to the "channels" edge.
func (m *NotificationRuleMutation) ResetChannels() {
	m.channels = nil
	m.clearedchannels = false
	m.removedchannels = nil
}

// AddEventIDs adds the "events" edge to the NotificationEvent entity by ids.
func (m *NotificationRuleMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the NotificationEvent entity.
func (m *NotificationRuleMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the NotificationEvent entity was cleared.
func (m *NotificationRuleMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the NotificationEvent entity by IDs.
func (m *NotificationRuleMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the NotificationEvent entity.
func (m *NotificationRuleMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *NotificationRuleMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *NotificationRuleMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the NotificationRuleMutation builder.
func (m *NotificationRuleMutation) Where(ps ...predicate.NotificationRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationRule).
func (m *NotificationRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationRuleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, notificationrule.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationrule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notificationrule.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationrule.FieldType)
	}
	if m.name != nil {
		fields = append(fields, notificationrule.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, notificationrule.FieldDisabled)
	}
	if m._config != nil {
		fields = append(fields, notificationrule.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationrule.FieldNamespace:
		return m.Namespace()
	case notificationrule.FieldCreatedAt:
		return m.CreatedAt()
	case notificationrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationrule.FieldDeletedAt:
		return m.DeletedAt()
	case notificationrule.FieldType:
		return m.GetType()
	case notificationrule.FieldName:
		return m.Name()
	case notificationrule.FieldDisabled:
		return m.Disabled()
	case notificationrule.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationrule.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationrule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notificationrule.FieldType:
		return m.OldType(ctx)
	case notificationrule.FieldName:
		return m.OldName(ctx)
	case notificationrule.FieldDisabled:
		return m.OldDisabled(ctx)
	case notificationrule.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationrule.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationrule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notificationrule.FieldType:
		v, ok := value.(notification.RuleType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationrule.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case notificationrule.FieldConfig:
		v, ok := value.(notification.RuleConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationRuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationRuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationrule.FieldDeletedAt) {
		fields = append(fields, notificationrule.FieldDeletedAt)
	}
	if m.FieldCleared(notificationrule.FieldDisabled) {
		fields = append(fields, notificationrule.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationRuleMutation) ClearField(name string) error {
	switch name {
	case notificationrule.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notificationrule.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationRuleMutation) ResetField(name string) error {
	switch name {
	case notificationrule.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationrule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notificationrule.FieldType:
		m.ResetType()
		return nil
	case notificationrule.FieldName:
		m.ResetName()
		return nil
	case notificationrule.FieldDisabled:
		m.ResetDisabled()
		return nil
	case notificationrule.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.channels != nil {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.events != nil {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationrule.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.channels))
		for id := range m.channels {
			ids = append(ids, id)
		}
		return ids
	case notificationrule.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchannels != nil {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.removedevents != nil {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationrule.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.removedchannels))
		for id := range m.removedchannels {
			ids = append(ids, id)
		}
		return ids
	case notificationrule.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchannels {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.clearedevents {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationrule.EdgeChannels:
		return m.clearedchannels
	case notificationrule.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationRuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationRuleMutation) ResetEdge(name string) error {
	switch name {
	case notificationrule.EdgeChannels:
		m.ResetChannels()
		return nil
	case notificationrule.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op             Op
	typ            string
	id             *string
	namespace      *string
	metadata       *map[string]string
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	name           *string
	description    *string
	key            *string
	version        *int
	addversion     *int
	currency       *string
	effective_from *time.Time
	effective_to   *time.Time
	clearedFields  map[string]struct{}
	phases         map[string]struct{}
	removedphases  map[string]struct{}
	clearedphases  bool
	done           bool
	oldValue       func(context.Context) (*Plan, error)
	predicates     []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id string) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plan entities.
func (m *PlanMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *PlanMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PlanMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PlanMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *PlanMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PlanMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PlanMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[dbplan.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PlanMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[dbplan.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PlanMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, dbplan.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlanMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dbplan.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlanMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dbplan.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dbplan.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[dbplan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dbplan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, dbplan.FieldDescription)
}

// SetKey sets the "key" field.
func (m *PlanMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PlanMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PlanMutation) ResetKey() {
	m.key = nil
}

// SetVersion sets the "version" field.
func (m *PlanMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *PlanMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *PlanMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *PlanMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *PlanMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCurrency sets the "currency" field.
func (m *PlanMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PlanMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PlanMutation) ResetCurrency() {
	m.currency = nil
}

// SetEffectiveFrom sets the "effective_from" field.
func (m *PlanMutation) SetEffectiveFrom(t time.Time) {
	m.effective_from = &t
}

// EffectiveFrom returns the value of the "effective_from" field in the mutation.
func (m *PlanMutation) EffectiveFrom() (r time.Time, exists bool) {
	v := m.effective_from
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveFrom returns the old "effective_from" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldEffectiveFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveFrom: %w", err)
	}
	return oldValue.EffectiveFrom, nil
}

// ClearEffectiveFrom clears the value of the "effective_from" field.
func (m *PlanMutation) ClearEffectiveFrom() {
	m.effective_from = nil
	m.clearedFields[dbplan.FieldEffectiveFrom] = struct{}{}
}

// EffectiveFromCleared returns if the "effective_from" field was cleared in this mutation.
func (m *PlanMutation) EffectiveFromCleared() bool {
	_, ok := m.clearedFields[dbplan.FieldEffectiveFrom]
	return ok
}

// ResetEffectiveFrom resets all changes to the "effective_from" field.
func (m *PlanMutation) ResetEffectiveFrom() {
	m.effective_from = nil
	delete(m.clearedFields, dbplan.FieldEffectiveFrom)
}

// SetEffectiveTo sets the "effective_to" field.
func (m *PlanMutation) SetEffectiveTo(t time.Time) {
	m.effective_to = &t
}

// EffectiveTo returns the value of the "effective_to" field in the mutation.
func (m *PlanMutation) EffectiveTo() (r time.Time, exists bool) {
	v := m.effective_to
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveTo returns the old "effective_to" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldEffectiveTo(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveTo: %w", err)
	}
	return oldValue.EffectiveTo, nil
}

// ClearEffectiveTo clears the value of the "effective_to" field.
func (m *PlanMutation) ClearEffectiveTo() {
	m.effective_to = nil
	m.clearedFields[dbplan.FieldEffectiveTo] = struct{}{}
}

// EffectiveToCleared returns if the "effective_to" field was cleared in this mutation.
func (m *PlanMutation) EffectiveToCleared() bool {
	_, ok := m.clearedFields[dbplan.FieldEffectiveTo]
	return ok
}

// ResetEffectiveTo resets all changes to the "effective_to" field.
func (m *PlanMutation) ResetEffectiveTo() {
	m.effective_to = nil
	delete(m.clearedFields, dbplan.FieldEffectiveTo)
}

// AddPhaseIDs adds the "phases" edge to the PlanPhase entity by ids.
func (m *PlanMutation) AddPhaseIDs(ids ...string) {
	if m.phases == nil {
		m.phases = make(map[string]struct{})
	}
	for i := range ids {
		m.phases[ids[i]] = struct{}{}
	}
}

// ClearPhases clears the "phases" edge to the PlanPhase entity.
func (m *PlanMutation) ClearPhases() {
	m.clearedphases = true
}

// PhasesCleared reports if the "phases" edge to the PlanPhase entity was cleared.
func (m *PlanMutation) PhasesCleared() bool {
	return m.clearedphases
}

// RemovePhaseIDs removes the "phases" edge to the PlanPhase entity by IDs.
func (m *PlanMutation) RemovePhaseIDs(ids ...string) {
	if m.removedphases == nil {
		m.removedphases = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.phases, ids[i])
		m.removedphases[ids[i]] = struct{}{}
	}
}

// RemovedPhases returns the removed IDs of the "phases" edge to the PlanPhase entity.
func (m *PlanMutation) RemovedPhasesIDs() (ids []string) {
	for id := range m.removedphases {
		ids = append(ids, id)
	}
	return
}

// PhasesIDs returns the "phases" edge IDs in the mutation.
func (m *PlanMutation) PhasesIDs() (ids []string) {
	for id := range m.phases {
		ids = append(ids, id)
	}
	return
}

// ResetPhases resets all changes to the "phases" edge.
func (m *PlanMutation) ResetPhases() {
	m.phases = nil
	m.clearedphases = false
	m.removedphases = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.namespace != nil {
		fields = append(fields, dbplan.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, dbplan.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, dbplan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dbplan.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dbplan.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, dbplan.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dbplan.FieldDescription)
	}
	if m.key != nil {
		fields = append(fields, dbplan.FieldKey)
	}
	if m.version != nil {
		fields = append(fields, dbplan.FieldVersion)
	}
	if m.currency != nil {
		fields = append(fields, dbplan.FieldCurrency)
	}
	if m.effective_from != nil {
		fields = append(fields, dbplan.FieldEffectiveFrom)
	}
	if m.effective_to != nil {
		fields = append(fields, dbplan.FieldEffectiveTo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbplan.FieldNamespace:
		return m.Namespace()
	case dbplan.FieldMetadata:
		return m.Metadata()
	case dbplan.FieldCreatedAt:
		return m.CreatedAt()
	case dbplan.FieldUpdatedAt:
		return m.UpdatedAt()
	case dbplan.FieldDeletedAt:
		return m.DeletedAt()
	case dbplan.FieldName:
		return m.Name()
	case dbplan.FieldDescription:
		return m.Description()
	case dbplan.FieldKey:
		return m.Key()
	case dbplan.FieldVersion:
		return m.Version()
	case dbplan.FieldCurrency:
		return m.Currency()
	case dbplan.FieldEffectiveFrom:
		return m.EffectiveFrom()
	case dbplan.FieldEffectiveTo:
		return m.EffectiveTo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbplan.FieldNamespace:
		return m.OldNamespace(ctx)
	case dbplan.FieldMetadata:
		return m.OldMetadata(ctx)
	case dbplan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dbplan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dbplan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dbplan.FieldName:
		return m.OldName(ctx)
	case dbplan.FieldDescription:
		return m.OldDescription(ctx)
	case dbplan.FieldKey:
		return m.OldKey(ctx)
	case dbplan.FieldVersion:
		return m.OldVersion(ctx)
	case dbplan.FieldCurrency:
		return m.OldCurrency(ctx)
	case dbplan.FieldEffectiveFrom:
		return m.OldEffectiveFrom(ctx)
	case dbplan.FieldEffectiveTo:
		return m.OldEffectiveTo(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbplan.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case dbplan.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case dbplan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dbplan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dbplan.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dbplan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbplan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dbplan.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dbplan.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case dbplan.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case dbplan.FieldEffectiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveFrom(v)
		return nil
	case dbplan.FieldEffectiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveTo(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, dbplan.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dbplan.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dbplan.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbplan.FieldMetadata) {
		fields = append(fields, dbplan.FieldMetadata)
	}
	if m.FieldCleared(dbplan.FieldDeletedAt) {
		fields = append(fields, dbplan.FieldDeletedAt)
	}
	if m.FieldCleared(dbplan.FieldDescription) {
		fields = append(fields, dbplan.FieldDescription)
	}
	if m.FieldCleared(dbplan.FieldEffectiveFrom) {
		fields = append(fields, dbplan.FieldEffectiveFrom)
	}
	if m.FieldCleared(dbplan.FieldEffectiveTo) {
		fields = append(fields, dbplan.FieldEffectiveTo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	switch name {
	case dbplan.FieldMetadata:
		m.ClearMetadata()
		return nil
	case dbplan.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dbplan.FieldDescription:
		m.ClearDescription()
		return nil
	case dbplan.FieldEffectiveFrom:
		m.ClearEffectiveFrom()
		return nil
	case dbplan.FieldEffectiveTo:
		m.ClearEffectiveTo()
		return nil
	}
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case dbplan.FieldNamespace:
		m.ResetNamespace()
		return nil
	case dbplan.FieldMetadata:
		m.ResetMetadata()
		return nil
	case dbplan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dbplan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dbplan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dbplan.FieldName:
		m.ResetName()
		return nil
	case dbplan.FieldDescription:
		m.ResetDescription()
		return nil
	case dbplan.FieldKey:
		m.ResetKey()
		return nil
	case dbplan.FieldVersion:
		m.ResetVersion()
		return nil
	case dbplan.FieldCurrency:
		m.ResetCurrency()
		return nil
	case dbplan.FieldEffectiveFrom:
		m.ResetEffectiveFrom()
		return nil
	case dbplan.FieldEffectiveTo:
		m.ResetEffectiveTo()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.phases != nil {
		edges = append(edges, dbplan.EdgePhases)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbplan.EdgePhases:
		ids := make([]ent.Value, 0, len(m.phases))
		for id := range m.phases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedphases != nil {
		edges = append(edges, dbplan.EdgePhases)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dbplan.EdgePhases:
		ids := make([]ent.Value, 0, len(m.removedphases))
		for id := range m.removedphases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedphases {
		edges = append(edges, dbplan.EdgePhases)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	switch name {
	case dbplan.EdgePhases:
		return m.clearedphases
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	switch name {
	case dbplan.EdgePhases:
		m.ResetPhases()
		return nil
	}
	return fmt.Errorf("unknown Plan edge %s", name)
}

// PlanPhaseMutation represents an operation that mutates the PlanPhase nodes in the graph.
type PlanPhaseMutation struct {
	config
	op               Op
	typ              string
	id               *string
	namespace        *string
	metadata         *map[string]string
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	name             *string
	description      *string
	key              *string
	start_after      *datex.ISOString
	discounts        *[]plan.Discount
	clearedFields    map[string]struct{}
	plan             *string
	clearedplan      bool
	ratecards        map[string]struct{}
	removedratecards map[string]struct{}
	clearedratecards bool
	done             bool
	oldValue         func(context.Context) (*PlanPhase, error)
	predicates       []predicate.PlanPhase
}

var _ ent.Mutation = (*PlanPhaseMutation)(nil)

// planphaseOption allows management of the mutation configuration using functional options.
type planphaseOption func(*PlanPhaseMutation)

// newPlanPhaseMutation creates new mutation for the PlanPhase entity.
func newPlanPhaseMutation(c config, op Op, opts ...planphaseOption) *PlanPhaseMutation {
	m := &PlanPhaseMutation{
		config:        c,
		op:            op,
		typ:           TypePlanPhase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanPhaseID sets the ID field of the mutation.
func withPlanPhaseID(id string) planphaseOption {
	return func(m *PlanPhaseMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanPhase
		)
		m.oldValue = func(ctx context.Context) (*PlanPhase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanPhase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanPhase sets the old PlanPhase of the mutation.
func withPlanPhase(node *PlanPhase) planphaseOption {
	return func(m *PlanPhaseMutation) {
		m.oldValue = func(context.Context) (*PlanPhase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanPhaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanPhaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlanPhase entities.
func (m *PlanPhaseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanPhaseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanPhaseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanPhase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *PlanPhaseMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PlanPhaseMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PlanPhaseMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *PlanPhaseMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PlanPhaseMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PlanPhaseMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[planphase.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PlanPhaseMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[planphase.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PlanPhaseMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, planphase.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanPhaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanPhaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanPhaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanPhaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanPhaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanPhaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanPhaseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanPhaseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlanPhaseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[planphase.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlanPhaseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[planphase.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanPhaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, planphase.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PlanPhaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanPhaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanPhaseMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PlanPhaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanPhaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanPhaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[planphase.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanPhaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[planphase.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanPhaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, planphase.FieldDescription)
}

// SetKey sets the "key" field.
func (m *PlanPhaseMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PlanPhaseMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PlanPhaseMutation) ResetKey() {
	m.key = nil
}

// SetStartAfter sets the "start_after" field.
func (m *PlanPhaseMutation) SetStartAfter(ds datex.ISOString) {
	m.start_after = &ds
}

// StartAfter returns the value of the "start_after" field in the mutation.
func (m *PlanPhaseMutation) StartAfter() (r datex.ISOString, exists bool) {
	v := m.start_after
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAfter returns the old "start_after" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldStartAfter(ctx context.Context) (v datex.ISOString, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAfter: %w", err)
	}
	return oldValue.StartAfter, nil
}

// ResetStartAfter resets all changes to the "start_after" field.
func (m *PlanPhaseMutation) ResetStartAfter() {
	m.start_after = nil
}

// SetDiscounts sets the "discounts" field.
func (m *PlanPhaseMutation) SetDiscounts(pl []plan.Discount) {
	m.discounts = &pl
}

// Discounts returns the value of the "discounts" field in the mutation.
func (m *PlanPhaseMutation) Discounts() (r []plan.Discount, exists bool) {
	v := m.discounts
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscounts returns the old "discounts" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldDiscounts(ctx context.Context) (v []plan.Discount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscounts: %w", err)
	}
	return oldValue.Discounts, nil
}

// ClearDiscounts clears the value of the "discounts" field.
func (m *PlanPhaseMutation) ClearDiscounts() {
	m.discounts = nil
	m.clearedFields[planphase.FieldDiscounts] = struct{}{}
}

// DiscountsCleared returns if the "discounts" field was cleared in this mutation.
func (m *PlanPhaseMutation) DiscountsCleared() bool {
	_, ok := m.clearedFields[planphase.FieldDiscounts]
	return ok
}

// ResetDiscounts resets all changes to the "discounts" field.
func (m *PlanPhaseMutation) ResetDiscounts() {
	m.discounts = nil
	delete(m.clearedFields, planphase.FieldDiscounts)
}

// SetPlanID sets the "plan_id" field.
func (m *PlanPhaseMutation) SetPlanID(s string) {
	m.plan = &s
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *PlanPhaseMutation) PlanID() (r string, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldPlanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *PlanPhaseMutation) ResetPlanID() {
	m.plan = nil
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *PlanPhaseMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[planphase.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *PlanPhaseMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *PlanPhaseMutation) PlanIDs() (ids []string) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *PlanPhaseMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// AddRatecardIDs adds the "ratecards" edge to the PlanRateCard entity by ids.
func (m *PlanPhaseMutation) AddRatecardIDs(ids ...string) {
	if m.ratecards == nil {
		m.ratecards = make(map[string]struct{})
	}
	for i := range ids {
		m.ratecards[ids[i]] = struct{}{}
	}
}

// ClearRatecards clears the "ratecards" edge to the PlanRateCard entity.
func (m *PlanPhaseMutation) ClearRatecards() {
	m.clearedratecards = true
}

// RatecardsCleared reports if the "ratecards" edge to the PlanRateCard entity was cleared.
func (m *PlanPhaseMutation) RatecardsCleared() bool {
	return m.clearedratecards
}

// RemoveRatecardIDs removes the "ratecards" edge to the PlanRateCard entity by IDs.
func (m *PlanPhaseMutation) RemoveRatecardIDs(ids ...string) {
	if m.removedratecards == nil {
		m.removedratecards = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ratecards, ids[i])
		m.removedratecards[ids[i]] = struct{}{}
	}
}

// RemovedRatecards returns the removed IDs of the "ratecards" edge to the PlanRateCard entity.
func (m *PlanPhaseMutation) RemovedRatecardsIDs() (ids []string) {
	for id := range m.removedratecards {
		ids = append(ids, id)
	}
	return
}

// RatecardsIDs returns the "ratecards" edge IDs in the mutation.
func (m *PlanPhaseMutation) RatecardsIDs() (ids []string) {
	for id := range m.ratecards {
		ids = append(ids, id)
	}
	return
}

// ResetRatecards resets all changes to the "ratecards" edge.
func (m *PlanPhaseMutation) ResetRatecards() {
	m.ratecards = nil
	m.clearedratecards = false
	m.removedratecards = nil
}

// Where appends a list predicates to the PlanPhaseMutation builder.
func (m *PlanPhaseMutation) Where(ps ...predicate.PlanPhase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanPhaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanPhaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlanPhase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanPhaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanPhaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlanPhase).
func (m *PlanPhaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanPhaseMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.namespace != nil {
		fields = append(fields, planphase.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, planphase.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, planphase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, planphase.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, planphase.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, planphase.FieldName)
	}
	if m.description != nil {
		fields = append(fields, planphase.FieldDescription)
	}
	if m.key != nil {
		fields = append(fields, planphase.FieldKey)
	}
	if m.start_after != nil {
		fields = append(fields, planphase.FieldStartAfter)
	}
	if m.discounts != nil {
		fields = append(fields, planphase.FieldDiscounts)
	}
	if m.plan != nil {
		fields = append(fields, planphase.FieldPlanID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanPhaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planphase.FieldNamespace:
		return m.Namespace()
	case planphase.FieldMetadata:
		return m.Metadata()
	case planphase.FieldCreatedAt:
		return m.CreatedAt()
	case planphase.FieldUpdatedAt:
		return m.UpdatedAt()
	case planphase.FieldDeletedAt:
		return m.DeletedAt()
	case planphase.FieldName:
		return m.Name()
	case planphase.FieldDescription:
		return m.Description()
	case planphase.FieldKey:
		return m.Key()
	case planphase.FieldStartAfter:
		return m.StartAfter()
	case planphase.FieldDiscounts:
		return m.Discounts()
	case planphase.FieldPlanID:
		return m.PlanID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanPhaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case planphase.FieldNamespace:
		return m.OldNamespace(ctx)
	case planphase.FieldMetadata:
		return m.OldMetadata(ctx)
	case planphase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case planphase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case planphase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case planphase.FieldName:
		return m.OldName(ctx)
	case planphase.FieldDescription:
		return m.OldDescription(ctx)
	case planphase.FieldKey:
		return m.OldKey(ctx)
	case planphase.FieldStartAfter:
		return m.OldStartAfter(ctx)
	case planphase.FieldDiscounts:
		return m.OldDiscounts(ctx)
	case planphase.FieldPlanID:
		return m.OldPlanID(ctx)
	}
	return nil, fmt.Errorf("unknown PlanPhase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanPhaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planphase.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case planphase.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case planphase.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case planphase.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case planphase.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case planphase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case planphase.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case planphase.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case planphase.FieldStartAfter:
		v, ok := value.(datex.ISOString)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAfter(v)
		return nil
	case planphase.FieldDiscounts:
		v, ok := value.([]plan.Discount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscounts(v)
		return nil
	case planphase.FieldPlanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	}
	return fmt.Errorf("unknown PlanPhase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanPhaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanPhaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanPhaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlanPhase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanPhaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(planphase.FieldMetadata) {
		fields = append(fields, planphase.FieldMetadata)
	}
	if m.FieldCleared(planphase.FieldDeletedAt) {
		fields = append(fields, planphase.FieldDeletedAt)
	}
	if m.FieldCleared(planphase.FieldDescription) {
		fields = append(fields, planphase.FieldDescription)
	}
	if m.FieldCleared(planphase.FieldDiscounts) {
		fields = append(fields, planphase.FieldDiscounts)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanPhaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanPhaseMutation) ClearField(name string) error {
	switch name {
	case planphase.FieldMetadata:
		m.ClearMetadata()
		return nil
	case planphase.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case planphase.FieldDescription:
		m.ClearDescription()
		return nil
	case planphase.FieldDiscounts:
		m.ClearDiscounts()
		return nil
	}
	return fmt.Errorf("unknown PlanPhase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanPhaseMutation) ResetField(name string) error {
	switch name {
	case planphase.FieldNamespace:
		m.ResetNamespace()
		return nil
	case planphase.FieldMetadata:
		m.ResetMetadata()
		return nil
	case planphase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case planphase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case planphase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case planphase.FieldName:
		m.ResetName()
		return nil
	case planphase.FieldDescription:
		m.ResetDescription()
		return nil
	case planphase.FieldKey:
		m.ResetKey()
		return nil
	case planphase.FieldStartAfter:
		m.ResetStartAfter()
		return nil
	case planphase.FieldDiscounts:
		m.ResetDiscounts()
		return nil
	case planphase.FieldPlanID:
		m.ResetPlanID()
		return nil
	}
	return fmt.Errorf("unknown PlanPhase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanPhaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.plan != nil {
		edges = append(edges, planphase.EdgePlan)
	}
	if m.ratecards != nil {
		edges = append(edges, planphase.EdgeRatecards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanPhaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case planphase.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case planphase.EdgeRatecards:
		ids := make([]ent.Value, 0, len(m.ratecards))
		for id := range m.ratecards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanPhaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedratecards != nil {
		edges = append(edges, planphase.EdgeRatecards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanPhaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case planphase.EdgeRatecards:
		ids := make([]ent.Value, 0, len(m.removedratecards))
		for id := range m.removedratecards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanPhaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplan {
		edges = append(edges, planphase.EdgePlan)
	}
	if m.clearedratecards {
		edges = append(edges, planphase.EdgeRatecards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanPhaseMutation) EdgeCleared(name string) bool {
	switch name {
	case planphase.EdgePlan:
		return m.clearedplan
	case planphase.EdgeRatecards:
		return m.clearedratecards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanPhaseMutation) ClearEdge(name string) error {
	switch name {
	case planphase.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown PlanPhase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanPhaseMutation) ResetEdge(name string) error {
	switch name {
	case planphase.EdgePlan:
		m.ResetPlan()
		return nil
	case planphase.EdgeRatecards:
		m.ResetRatecards()
		return nil
	}
	return fmt.Errorf("unknown PlanPhase edge %s", name)
}

// PlanRateCardMutation represents an operation that mutates the PlanRateCard nodes in the graph.
type PlanRateCardMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	namespace            *string
	metadata             *map[string]string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	description          *string
	key                  *string
	_type                *plan.RateCardType
	feature_key          *string
	entitlement_template **plan.EntitlementTemplate
	tax_config           **plan.TaxConfig
	billing_cadence      *datex.ISOString
	price                **plan.Price
	clearedFields        map[string]struct{}
	phase                *string
	clearedphase         bool
	features             *string
	clearedfeatures      bool
	done                 bool
	oldValue             func(context.Context) (*PlanRateCard, error)
	predicates           []predicate.PlanRateCard
}

var _ ent.Mutation = (*PlanRateCardMutation)(nil)

// planratecardOption allows management of the mutation configuration using functional options.
type planratecardOption func(*PlanRateCardMutation)

// newPlanRateCardMutation creates new mutation for the PlanRateCard entity.
func newPlanRateCardMutation(c config, op Op, opts ...planratecardOption) *PlanRateCardMutation {
	m := &PlanRateCardMutation{
		config:        c,
		op:            op,
		typ:           TypePlanRateCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanRateCardID sets the ID field of the mutation.
func withPlanRateCardID(id string) planratecardOption {
	return func(m *PlanRateCardMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanRateCard
		)
		m.oldValue = func(ctx context.Context) (*PlanRateCard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanRateCard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanRateCard sets the old PlanRateCard of the mutation.
func withPlanRateCard(node *PlanRateCard) planratecardOption {
	return func(m *PlanRateCardMutation) {
		m.oldValue = func(context.Context) (*PlanRateCard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanRateCardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanRateCardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlanRateCard entities.
func (m *PlanRateCardMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanRateCardMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanRateCardMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanRateCard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *PlanRateCardMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PlanRateCardMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PlanRateCardMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *PlanRateCardMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PlanRateCardMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PlanRateCardMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[planratecard.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PlanRateCardMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PlanRateCardMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, planratecard.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanRateCardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanRateCardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanRateCardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanRateCardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanRateCardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanRateCardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanRateCardMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanRateCardMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlanRateCardMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[planratecard.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlanRateCardMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanRateCardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, planratecard.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PlanRateCardMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanRateCardMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanRateCardMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PlanRateCardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanRateCardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanRateCardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[planratecard.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanRateCardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanRateCardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, planratecard.FieldDescription)
}

// SetKey sets the "key" field.
func (m *PlanRateCardMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PlanRateCardMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PlanRateCardMutation) ResetKey() {
	m.key = nil
}

// SetType sets the "type" field.
func (m *PlanRateCardMutation) SetType(pct plan.RateCardType) {
	m._type = &pct
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlanRateCardMutation) GetType() (r plan.RateCardType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldType(ctx context.Context) (v plan.RateCardType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PlanRateCardMutation) ResetType() {
	m._type = nil
}

// SetFeatureKey sets the "feature_key" field.
func (m *PlanRateCardMutation) SetFeatureKey(s string) {
	m.feature_key = &s
}

// FeatureKey returns the value of the "feature_key" field in the mutation.
func (m *PlanRateCardMutation) FeatureKey() (r string, exists bool) {
	v := m.feature_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureKey returns the old "feature_key" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldFeatureKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureKey: %w", err)
	}
	return oldValue.FeatureKey, nil
}

// ClearFeatureKey clears the value of the "feature_key" field.
func (m *PlanRateCardMutation) ClearFeatureKey() {
	m.feature_key = nil
	m.clearedFields[planratecard.FieldFeatureKey] = struct{}{}
}

// FeatureKeyCleared returns if the "feature_key" field was cleared in this mutation.
func (m *PlanRateCardMutation) FeatureKeyCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldFeatureKey]
	return ok
}

// ResetFeatureKey resets all changes to the "feature_key" field.
func (m *PlanRateCardMutation) ResetFeatureKey() {
	m.feature_key = nil
	delete(m.clearedFields, planratecard.FieldFeatureKey)
}

// SetEntitlementTemplate sets the "entitlement_template" field.
func (m *PlanRateCardMutation) SetEntitlementTemplate(pt *plan.EntitlementTemplate) {
	m.entitlement_template = &pt
}

// EntitlementTemplate returns the value of the "entitlement_template" field in the mutation.
func (m *PlanRateCardMutation) EntitlementTemplate() (r *plan.EntitlementTemplate, exists bool) {
	v := m.entitlement_template
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementTemplate returns the old "entitlement_template" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldEntitlementTemplate(ctx context.Context) (v *plan.EntitlementTemplate, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementTemplate: %w", err)
	}
	return oldValue.EntitlementTemplate, nil
}

// ClearEntitlementTemplate clears the value of the "entitlement_template" field.
func (m *PlanRateCardMutation) ClearEntitlementTemplate() {
	m.entitlement_template = nil
	m.clearedFields[planratecard.FieldEntitlementTemplate] = struct{}{}
}

// EntitlementTemplateCleared returns if the "entitlement_template" field was cleared in this mutation.
func (m *PlanRateCardMutation) EntitlementTemplateCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldEntitlementTemplate]
	return ok
}

// ResetEntitlementTemplate resets all changes to the "entitlement_template" field.
func (m *PlanRateCardMutation) ResetEntitlementTemplate() {
	m.entitlement_template = nil
	delete(m.clearedFields, planratecard.FieldEntitlementTemplate)
}

// SetTaxConfig sets the "tax_config" field.
func (m *PlanRateCardMutation) SetTaxConfig(pc *plan.TaxConfig) {
	m.tax_config = &pc
}

// TaxConfig returns the value of the "tax_config" field in the mutation.
func (m *PlanRateCardMutation) TaxConfig() (r *plan.TaxConfig, exists bool) {
	v := m.tax_config
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxConfig returns the old "tax_config" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldTaxConfig(ctx context.Context) (v *plan.TaxConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxConfig: %w", err)
	}
	return oldValue.TaxConfig, nil
}

// ClearTaxConfig clears the value of the "tax_config" field.
func (m *PlanRateCardMutation) ClearTaxConfig() {
	m.tax_config = nil
	m.clearedFields[planratecard.FieldTaxConfig] = struct{}{}
}

// TaxConfigCleared returns if the "tax_config" field was cleared in this mutation.
func (m *PlanRateCardMutation) TaxConfigCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldTaxConfig]
	return ok
}

// ResetTaxConfig resets all changes to the "tax_config" field.
func (m *PlanRateCardMutation) ResetTaxConfig() {
	m.tax_config = nil
	delete(m.clearedFields, planratecard.FieldTaxConfig)
}

// SetBillingCadence sets the "billing_cadence" field.
func (m *PlanRateCardMutation) SetBillingCadence(ds datex.ISOString) {
	m.billing_cadence = &ds
}

// BillingCadence returns the value of the "billing_cadence" field in the mutation.
func (m *PlanRateCardMutation) BillingCadence() (r datex.ISOString, exists bool) {
	v := m.billing_cadence
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingCadence returns the old "billing_cadence" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldBillingCadence(ctx context.Context) (v *datex.ISOString, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingCadence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingCadence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingCadence: %w", err)
	}
	return oldValue.BillingCadence, nil
}

// ClearBillingCadence clears the value of the "billing_cadence" field.
func (m *PlanRateCardMutation) ClearBillingCadence() {
	m.billing_cadence = nil
	m.clearedFields[planratecard.FieldBillingCadence] = struct{}{}
}

// BillingCadenceCleared returns if the "billing_cadence" field was cleared in this mutation.
func (m *PlanRateCardMutation) BillingCadenceCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldBillingCadence]
	return ok
}

// ResetBillingCadence resets all changes to the "billing_cadence" field.
func (m *PlanRateCardMutation) ResetBillingCadence() {
	m.billing_cadence = nil
	delete(m.clearedFields, planratecard.FieldBillingCadence)
}

// SetPrice sets the "price" field.
func (m *PlanRateCardMutation) SetPrice(pl *plan.Price) {
	m.price = &pl
}

// Price returns the value of the "price" field in the mutation.
func (m *PlanRateCardMutation) Price() (r *plan.Price, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldPrice(ctx context.Context) (v *plan.Price, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *PlanRateCardMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[planratecard.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *PlanRateCardMutation) PriceCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *PlanRateCardMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, planratecard.FieldPrice)
}

// SetPhaseID sets the "phase_id" field.
func (m *PlanRateCardMutation) SetPhaseID(s string) {
	m.phase = &s
}

// PhaseID returns the value of the "phase_id" field in the mutation.
func (m *PlanRateCardMutation) PhaseID() (r string, exists bool) {
	v := m.phase
	if v == nil {
		return
	}
	return *v, true
}

// OldPhaseID returns the old "phase_id" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldPhaseID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhaseID: %w", err)
	}
	return oldValue.PhaseID, nil
}

// ResetPhaseID resets all changes to the "phase_id" field.
func (m *PlanRateCardMutation) ResetPhaseID() {
	m.phase = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *PlanRateCardMutation) SetFeatureID(s string) {
	m.features = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *PlanRateCardMutation) FeatureID() (r string, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldFeatureID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ClearFeatureID clears the value of the "feature_id" field.
func (m *PlanRateCardMutation) ClearFeatureID() {
	m.features = nil
	m.clearedFields[planratecard.FieldFeatureID] = struct{}{}
}

// FeatureIDCleared returns if the "feature_id" field was cleared in this mutation.
func (m *PlanRateCardMutation) FeatureIDCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldFeatureID]
	return ok
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *PlanRateCardMutation) ResetFeatureID() {
	m.features = nil
	delete(m.clearedFields, planratecard.FieldFeatureID)
}

// ClearPhase clears the "phase" edge to the PlanPhase entity.
func (m *PlanRateCardMutation) ClearPhase() {
	m.clearedphase = true
	m.clearedFields[planratecard.FieldPhaseID] = struct{}{}
}

// PhaseCleared reports if the "phase" edge to the PlanPhase entity was cleared.
func (m *PlanRateCardMutation) PhaseCleared() bool {
	return m.clearedphase
}

// PhaseIDs returns the "phase" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PhaseID instead. It exists only for internal usage by the builders.
func (m *PlanRateCardMutation) PhaseIDs() (ids []string) {
	if id := m.phase; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPhase resets all changes to the "phase" edge.
func (m *PlanRateCardMutation) ResetPhase() {
	m.phase = nil
	m.clearedphase = false
}

// SetFeaturesID sets the "features" edge to the Feature entity by id.
func (m *PlanRateCardMutation) SetFeaturesID(id string) {
	m.features = &id
}

// ClearFeatures clears the "features" edge to the Feature entity.
func (m *PlanRateCardMutation) ClearFeatures() {
	m.clearedfeatures = true
	m.clearedFields[planratecard.FieldFeatureID] = struct{}{}
}

// FeaturesCleared reports if the "features" edge to the Feature entity was cleared.
func (m *PlanRateCardMutation) FeaturesCleared() bool {
	return m.FeatureIDCleared() || m.clearedfeatures
}

// FeaturesID returns the "features" edge ID in the mutation.
func (m *PlanRateCardMutation) FeaturesID() (id string, exists bool) {
	if m.features != nil {
		return *m.features, true
	}
	return
}

// FeaturesIDs returns the "features" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeaturesID instead. It exists only for internal usage by the builders.
func (m *PlanRateCardMutation) FeaturesIDs() (ids []string) {
	if id := m.features; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatures resets all changes to the "features" edge.
func (m *PlanRateCardMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
}

// Where appends a list predicates to the PlanRateCardMutation builder.
func (m *PlanRateCardMutation) Where(ps ...predicate.PlanRateCard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanRateCardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanRateCardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlanRateCard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanRateCardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanRateCardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlanRateCard).
func (m *PlanRateCardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanRateCardMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.namespace != nil {
		fields = append(fields, planratecard.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, planratecard.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, planratecard.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, planratecard.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, planratecard.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, planratecard.FieldName)
	}
	if m.description != nil {
		fields = append(fields, planratecard.FieldDescription)
	}
	if m.key != nil {
		fields = append(fields, planratecard.FieldKey)
	}
	if m._type != nil {
		fields = append(fields, planratecard.FieldType)
	}
	if m.feature_key != nil {
		fields = append(fields, planratecard.FieldFeatureKey)
	}
	if m.entitlement_template != nil {
		fields = append(fields, planratecard.FieldEntitlementTemplate)
	}
	if m.tax_config != nil {
		fields = append(fields, planratecard.FieldTaxConfig)
	}
	if m.billing_cadence != nil {
		fields = append(fields, planratecard.FieldBillingCadence)
	}
	if m.price != nil {
		fields = append(fields, planratecard.FieldPrice)
	}
	if m.phase != nil {
		fields = append(fields, planratecard.FieldPhaseID)
	}
	if m.features != nil {
		fields = append(fields, planratecard.FieldFeatureID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanRateCardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planratecard.FieldNamespace:
		return m.Namespace()
	case planratecard.FieldMetadata:
		return m.Metadata()
	case planratecard.FieldCreatedAt:
		return m.CreatedAt()
	case planratecard.FieldUpdatedAt:
		return m.UpdatedAt()
	case planratecard.FieldDeletedAt:
		return m.DeletedAt()
	case planratecard.FieldName:
		return m.Name()
	case planratecard.FieldDescription:
		return m.Description()
	case planratecard.FieldKey:
		return m.Key()
	case planratecard.FieldType:
		return m.GetType()
	case planratecard.FieldFeatureKey:
		return m.FeatureKey()
	case planratecard.FieldEntitlementTemplate:
		return m.EntitlementTemplate()
	case planratecard.FieldTaxConfig:
		return m.TaxConfig()
	case planratecard.FieldBillingCadence:
		return m.BillingCadence()
	case planratecard.FieldPrice:
		return m.Price()
	case planratecard.FieldPhaseID:
		return m.PhaseID()
	case planratecard.FieldFeatureID:
		return m.FeatureID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanRateCardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case planratecard.FieldNamespace:
		return m.OldNamespace(ctx)
	case planratecard.FieldMetadata:
		return m.OldMetadata(ctx)
	case planratecard.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case planratecard.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case planratecard.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case planratecard.FieldName:
		return m.OldName(ctx)
	case planratecard.FieldDescription:
		return m.OldDescription(ctx)
	case planratecard.FieldKey:
		return m.OldKey(ctx)
	case planratecard.FieldType:
		return m.OldType(ctx)
	case planratecard.FieldFeatureKey:
		return m.OldFeatureKey(ctx)
	case planratecard.FieldEntitlementTemplate:
		return m.OldEntitlementTemplate(ctx)
	case planratecard.FieldTaxConfig:
		return m.OldTaxConfig(ctx)
	case planratecard.FieldBillingCadence:
		return m.OldBillingCadence(ctx)
	case planratecard.FieldPrice:
		return m.OldPrice(ctx)
	case planratecard.FieldPhaseID:
		return m.OldPhaseID(ctx)
	case planratecard.FieldFeatureID:
		return m.OldFeatureID(ctx)
	}
	return nil, fmt.Errorf("unknown PlanRateCard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanRateCardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planratecard.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case planratecard.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case planratecard.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case planratecard.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case planratecard.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case planratecard.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case planratecard.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case planratecard.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case planratecard.FieldType:
		v, ok := value.(plan.RateCardType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case planratecard.FieldFeatureKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureKey(v)
		return nil
	case planratecard.FieldEntitlementTemplate:
		v, ok := value.(*plan.EntitlementTemplate)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementTemplate(v)
		return nil
	case planratecard.FieldTaxConfig:
		v, ok := value.(*plan.TaxConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxConfig(v)
		return nil
	case planratecard.FieldBillingCadence:
		v, ok := value.(datex.ISOString)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingCadence(v)
		return nil
	case planratecard.FieldPrice:
		v, ok := value.(*plan.Price)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case planratecard.FieldPhaseID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhaseID(v)
		return nil
	case planratecard.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	}
	return fmt.Errorf("unknown PlanRateCard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanRateCardMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanRateCardMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanRateCardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlanRateCard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanRateCardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(planratecard.FieldMetadata) {
		fields = append(fields, planratecard.FieldMetadata)
	}
	if m.FieldCleared(planratecard.FieldDeletedAt) {
		fields = append(fields, planratecard.FieldDeletedAt)
	}
	if m.FieldCleared(planratecard.FieldDescription) {
		fields = append(fields, planratecard.FieldDescription)
	}
	if m.FieldCleared(planratecard.FieldFeatureKey) {
		fields = append(fields, planratecard.FieldFeatureKey)
	}
	if m.FieldCleared(planratecard.FieldEntitlementTemplate) {
		fields = append(fields, planratecard.FieldEntitlementTemplate)
	}
	if m.FieldCleared(planratecard.FieldTaxConfig) {
		fields = append(fields, planratecard.FieldTaxConfig)
	}
	if m.FieldCleared(planratecard.FieldBillingCadence) {
		fields = append(fields, planratecard.FieldBillingCadence)
	}
	if m.FieldCleared(planratecard.FieldPrice) {
		fields = append(fields, planratecard.FieldPrice)
	}
	if m.FieldCleared(planratecard.FieldFeatureID) {
		fields = append(fields, planratecard.FieldFeatureID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanRateCardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanRateCardMutation) ClearField(name string) error {
	switch name {
	case planratecard.FieldMetadata:
		m.ClearMetadata()
		return nil
	case planratecard.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case planratecard.FieldDescription:
		m.ClearDescription()
		return nil
	case planratecard.FieldFeatureKey:
		m.ClearFeatureKey()
		return nil
	case planratecard.FieldEntitlementTemplate:
		m.ClearEntitlementTemplate()
		return nil
	case planratecard.FieldTaxConfig:
		m.ClearTaxConfig()
		return nil
	case planratecard.FieldBillingCadence:
		m.ClearBillingCadence()
		return nil
	case planratecard.FieldPrice:
		m.ClearPrice()
		return nil
	case planratecard.FieldFeatureID:
		m.ClearFeatureID()
		return nil
	}
	return fmt.Errorf("unknown PlanRateCard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanRateCardMutation) ResetField(name string) error {
	switch name {
	case planratecard.FieldNamespace:
		m.ResetNamespace()
		return nil
	case planratecard.FieldMetadata:
		m.ResetMetadata()
		return nil
	case planratecard.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case planratecard.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case planratecard.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case planratecard.FieldName:
		m.ResetName()
		return nil
	case planratecard.FieldDescription:
		m.ResetDescription()
		return nil
	case planratecard.FieldKey:
		m.ResetKey()
		return nil
	case planratecard.FieldType:
		m.ResetType()
		return nil
	case planratecard.FieldFeatureKey:
		m.ResetFeatureKey()
		return nil
	case planratecard.FieldEntitlementTemplate:
		m.ResetEntitlementTemplate()
		return nil
	case planratecard.FieldTaxConfig:
		m.ResetTaxConfig()
		return nil
	case planratecard.FieldBillingCadence:
		m.ResetBillingCadence()
		return nil
	case planratecard.FieldPrice:
		m.ResetPrice()
		return nil
	case planratecard.FieldPhaseID:
		m.ResetPhaseID()
		return nil
	case planratecard.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	}
	return fmt.Errorf("unknown PlanRateCard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanRateCardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.phase != nil {
		edges = append(edges, planratecard.EdgePhase)
	}
	if m.features != nil {
		edges = append(edges, planratecard.EdgeFeatures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanRateCardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case planratecard.EdgePhase:
		if id := m.phase; id != nil {
			return []ent.Value{*id}
		}
	case planratecard.EdgeFeatures:
		if id := m.features; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanRateCardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanRateCardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanRateCardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedphase {
		edges = append(edges, planratecard.EdgePhase)
	}
	if m.clearedfeatures {
		edges = append(edges, planratecard.EdgeFeatures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanRateCardMutation) EdgeCleared(name string) bool {
	switch name {
	case planratecard.EdgePhase:
		return m.clearedphase
	case planratecard.EdgeFeatures:
		return m.clearedfeatures
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanRateCardMutation) ClearEdge(name string) error {
	switch name {
	case planratecard.EdgePhase:
		m.ClearPhase()
		return nil
	case planratecard.EdgeFeatures:
		m.ClearFeatures()
		return nil
	}
	return fmt.Errorf("unknown PlanRateCard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanRateCardMutation) ResetEdge(name string) error {
	switch name {
	case planratecard.EdgePhase:
		m.ResetPhase()
		return nil
	case planratecard.EdgeFeatures:
		m.ResetFeatures()
		return nil
	}
	return fmt.Errorf("unknown PlanRateCard edge %s", name)
}

// PriceMutation represents an operation that mutates the Price nodes in the graph.
type PriceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	namespace           *string
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	active_from         *time.Time
	active_to           *time.Time
	key                 *string
	phase_key           *string
	item_key            *string
	value               *string
	clearedFields       map[string]struct{}
	subscription        *string
	clearedsubscription bool
	done                bool
	oldValue            func(context.Context) (*Price, error)
	predicates          []predicate.Price
}

var _ ent.Mutation = (*PriceMutation)(nil)

// priceOption allows management of the mutation configuration using functional options.
type priceOption func(*PriceMutation)

// newPriceMutation creates new mutation for the Price entity.
func newPriceMutation(c config, op Op, opts ...priceOption) *PriceMutation {
	m := &PriceMutation{
		config:        c,
		op:            op,
		typ:           TypePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPriceID sets the ID field of the mutation.
func withPriceID(id string) priceOption {
	return func(m *PriceMutation) {
		var (
			err   error
			once  sync.Once
			value *Price
		)
		m.oldValue = func(ctx context.Context) (*Price, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Price.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrice sets the old Price of the mutation.
func withPrice(node *Price) priceOption {
	return func(m *PriceMutation) {
		m.oldValue = func(context.Context) (*Price, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Price entities.
func (m *PriceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PriceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PriceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Price.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *PriceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PriceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PriceMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PriceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[price.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PriceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[price.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, price.FieldDeletedAt)
}

// SetActiveFrom sets the "active_from" field.
func (m *PriceMutation) SetActiveFrom(t time.Time) {
	m.active_from = &t
}

// ActiveFrom returns the value of the "active_from" field in the mutation.
func (m *PriceMutation) ActiveFrom() (r time.Time, exists bool) {
	v := m.active_from
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveFrom returns the old "active_from" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldActiveFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveFrom: %w", err)
	}
	return oldValue.ActiveFrom, nil
}

// ResetActiveFrom resets all changes to the "active_from" field.
func (m *PriceMutation) ResetActiveFrom() {
	m.active_from = nil
}

// SetActiveTo sets the "active_to" field.
func (m *PriceMutation) SetActiveTo(t time.Time) {
	m.active_to = &t
}

// ActiveTo returns the value of the "active_to" field in the mutation.
func (m *PriceMutation) ActiveTo() (r time.Time, exists bool) {
	v := m.active_to
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveTo returns the old "active_to" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldActiveTo(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveTo: %w", err)
	}
	return oldValue.ActiveTo, nil
}

// ClearActiveTo clears the value of the "active_to" field.
func (m *PriceMutation) ClearActiveTo() {
	m.active_to = nil
	m.clearedFields[price.FieldActiveTo] = struct{}{}
}

// ActiveToCleared returns if the "active_to" field was cleared in this mutation.
func (m *PriceMutation) ActiveToCleared() bool {
	_, ok := m.clearedFields[price.FieldActiveTo]
	return ok
}

// ResetActiveTo resets all changes to the "active_to" field.
func (m *PriceMutation) ResetActiveTo() {
	m.active_to = nil
	delete(m.clearedFields, price.FieldActiveTo)
}

// SetKey sets the "key" field.
func (m *PriceMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PriceMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PriceMutation) ResetKey() {
	m.key = nil
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *PriceMutation) SetSubscriptionID(s string) {
	m.subscription = &s
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *PriceMutation) SubscriptionID() (r string, exists bool) {
	v := m.subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *PriceMutation) ResetSubscriptionID() {
	m.subscription = nil
}

// SetPhaseKey sets the "phase_key" field.
func (m *PriceMutation) SetPhaseKey(s string) {
	m.phase_key = &s
}

// PhaseKey returns the value of the "phase_key" field in the mutation.
func (m *PriceMutation) PhaseKey() (r string, exists bool) {
	v := m.phase_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPhaseKey returns the old "phase_key" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldPhaseKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhaseKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhaseKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhaseKey: %w", err)
	}
	return oldValue.PhaseKey, nil
}

// ResetPhaseKey resets all changes to the "phase_key" field.
func (m *PriceMutation) ResetPhaseKey() {
	m.phase_key = nil
}

// SetItemKey sets the "item_key" field.
func (m *PriceMutation) SetItemKey(s string) {
	m.item_key = &s
}

// ItemKey returns the value of the "item_key" field in the mutation.
func (m *PriceMutation) ItemKey() (r string, exists bool) {
	v := m.item_key
	if v == nil {
		return
	}
	return *v, true
}

// OldItemKey returns the old "item_key" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldItemKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemKey: %w", err)
	}
	return oldValue.ItemKey, nil
}

// ResetItemKey resets all changes to the "item_key" field.
func (m *PriceMutation) ResetItemKey() {
	m.item_key = nil
}

// SetValue sets the "value" field.
func (m *PriceMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *PriceMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Price entity.
// If the Price object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PriceMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *PriceMutation) ResetValue() {
	m.value = nil
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *PriceMutation) ClearSubscription() {
	m.clearedsubscription = true
	m.clearedFields[price.FieldSubscriptionID] = struct{}{}
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *PriceMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *PriceMutation) SubscriptionIDs() (ids []string) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *PriceMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// Where appends a list predicates to the PriceMutation builder.
func (m *PriceMutation) Where(ps ...predicate.Price) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Price, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Price).
func (m *PriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PriceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.namespace != nil {
		fields = append(fields, price.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, price.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, price.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, price.FieldDeletedAt)
	}
	if m.active_from != nil {
		fields = append(fields, price.FieldActiveFrom)
	}
	if m.active_to != nil {
		fields = append(fields, price.FieldActiveTo)
	}
	if m.key != nil {
		fields = append(fields, price.FieldKey)
	}
	if m.subscription != nil {
		fields = append(fields, price.FieldSubscriptionID)
	}
	if m.phase_key != nil {
		fields = append(fields, price.FieldPhaseKey)
	}
	if m.item_key != nil {
		fields = append(fields, price.FieldItemKey)
	}
	if m.value != nil {
		fields = append(fields, price.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case price.FieldNamespace:
		return m.Namespace()
	case price.FieldCreatedAt:
		return m.CreatedAt()
	case price.FieldUpdatedAt:
		return m.UpdatedAt()
	case price.FieldDeletedAt:
		return m.DeletedAt()
	case price.FieldActiveFrom:
		return m.ActiveFrom()
	case price.FieldActiveTo:
		return m.ActiveTo()
	case price.FieldKey:
		return m.Key()
	case price.FieldSubscriptionID:
		return m.SubscriptionID()
	case price.FieldPhaseKey:
		return m.PhaseKey()
	case price.FieldItemKey:
		return m.ItemKey()
	case price.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case price.FieldNamespace:
		return m.OldNamespace(ctx)
	case price.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case price.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case price.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case price.FieldActiveFrom:
		return m.OldActiveFrom(ctx)
	case price.FieldActiveTo:
		return m.OldActiveTo(ctx)
	case price.FieldKey:
		return m.OldKey(ctx)
	case price.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case price.FieldPhaseKey:
		return m.OldPhaseKey(ctx)
	case price.FieldItemKey:
		return m.OldItemKey(ctx)
	case price.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Price field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case price.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case price.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case price.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case price.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case price.FieldActiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveFrom(v)
		return nil
	case price.FieldActiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveTo(v)
		return nil
	case price.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case price.FieldSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case price.FieldPhaseKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhaseKey(v)
		return nil
	case price.FieldItemKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemKey(v)
		return nil
	case price.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PriceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PriceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Price numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(price.FieldDeletedAt) {
		fields = append(fields, price.FieldDeletedAt)
	}
	if m.FieldCleared(price.FieldActiveTo) {
		fields = append(fields, price.FieldActiveTo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PriceMutation) ClearField(name string) error {
	switch name {
	case price.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case price.FieldActiveTo:
		m.ClearActiveTo()
		return nil
	}
	return fmt.Errorf("unknown Price nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PriceMutation) ResetField(name string) error {
	switch name {
	case price.FieldNamespace:
		m.ResetNamespace()
		return nil
	case price.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case price.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case price.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case price.FieldActiveFrom:
		m.ResetActiveFrom()
		return nil
	case price.FieldActiveTo:
		m.ResetActiveTo()
		return nil
	case price.FieldKey:
		m.ResetKey()
		return nil
	case price.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case price.FieldPhaseKey:
		m.ResetPhaseKey()
		return nil
	case price.FieldItemKey:
		m.ResetItemKey()
		return nil
	case price.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Price field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subscription != nil {
		edges = append(edges, price.EdgeSubscription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case price.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubscription {
		edges = append(edges, price.EdgeSubscription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PriceMutation) EdgeCleared(name string) bool {
	switch name {
	case price.EdgeSubscription:
		return m.clearedsubscription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PriceMutation) ClearEdge(name string) error {
	switch name {
	case price.EdgeSubscription:
		m.ClearSubscription()
		return nil
	}
	return fmt.Errorf("unknown Price unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PriceMutation) ResetEdge(name string) error {
	switch name {
	case price.EdgeSubscription:
		m.ResetSubscription()
		return nil
	}
	return fmt.Errorf("unknown Price edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	namespace                   *string
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	metadata                    *map[string]string
	active_from                 *time.Time
	active_to                   *time.Time
	plan_key                    *string
	plan_version                *int
	addplan_version             *int
	currency                    *currencyx.Code
	clearedFields               map[string]struct{}
	subscription_patches        map[string]struct{}
	removedsubscription_patches map[string]struct{}
	clearedsubscription_patches bool
	prices                      map[string]struct{}
	removedprices               map[string]struct{}
	clearedprices               bool
	entitlements                map[string]struct{}
	removedentitlements         map[string]struct{}
	clearedentitlements         bool
	customer                    *string
	clearedcustomer             bool
	done                        bool
	oldValue                    func(context.Context) (*Subscription, error)
	predicates                  []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id string) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscription entities.
func (m *SubscriptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscriptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscription.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscriptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscription.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *SubscriptionMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SubscriptionMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SubscriptionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[subscription.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SubscriptionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[subscription.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SubscriptionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, subscription.FieldMetadata)
}

// SetActiveFrom sets the "active_from" field.
func (m *SubscriptionMutation) SetActiveFrom(t time.Time) {
	m.active_from = &t
}

// ActiveFrom returns the value of the "active_from" field in the mutation.
func (m *SubscriptionMutation) ActiveFrom() (r time.Time, exists bool) {
	v := m.active_from
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveFrom returns the old "active_from" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldActiveFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveFrom: %w", err)
	}
	return oldValue.ActiveFrom, nil
}

// ResetActiveFrom resets all changes to the "active_from" field.
func (m *SubscriptionMutation) ResetActiveFrom() {
	m.active_from = nil
}

// SetActiveTo sets the "active_to" field.
func (m *SubscriptionMutation) SetActiveTo(t time.Time) {
	m.active_to = &t
}

// ActiveTo returns the value of the "active_to" field in the mutation.
func (m *SubscriptionMutation) ActiveTo() (r time.Time, exists bool) {
	v := m.active_to
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveTo returns the old "active_to" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldActiveTo(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveTo: %w", err)
	}
	return oldValue.ActiveTo, nil
}

// ClearActiveTo clears the value of the "active_to" field.
func (m *SubscriptionMutation) ClearActiveTo() {
	m.active_to = nil
	m.clearedFields[subscription.FieldActiveTo] = struct{}{}
}

// ActiveToCleared returns if the "active_to" field was cleared in this mutation.
func (m *SubscriptionMutation) ActiveToCleared() bool {
	_, ok := m.clearedFields[subscription.FieldActiveTo]
	return ok
}

// ResetActiveTo resets all changes to the "active_to" field.
func (m *SubscriptionMutation) ResetActiveTo() {
	m.active_to = nil
	delete(m.clearedFields, subscription.FieldActiveTo)
}

// SetPlanKey sets the "plan_key" field.
func (m *SubscriptionMutation) SetPlanKey(s string) {
	m.plan_key = &s
}

// PlanKey returns the value of the "plan_key" field in the mutation.
func (m *SubscriptionMutation) PlanKey() (r string, exists bool) {
	v := m.plan_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanKey returns the old "plan_key" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldPlanKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanKey: %w", err)
	}
	return oldValue.PlanKey, nil
}

// ResetPlanKey resets all changes to the "plan_key" field.
func (m *SubscriptionMutation) ResetPlanKey() {
	m.plan_key = nil
}

// SetPlanVersion sets the "plan_version" field.
func (m *SubscriptionMutation) SetPlanVersion(i int) {
	m.plan_version = &i
	m.addplan_version = nil
}

// PlanVersion returns the value of the "plan_version" field in the mutation.
func (m *SubscriptionMutation) PlanVersion() (r int, exists bool) {
	v := m.plan_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanVersion returns the old "plan_version" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldPlanVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanVersion: %w", err)
	}
	return oldValue.PlanVersion, nil
}

// AddPlanVersion adds i to the "plan_version" field.
func (m *SubscriptionMutation) AddPlanVersion(i int) {
	if m.addplan_version != nil {
		*m.addplan_version += i
	} else {
		m.addplan_version = &i
	}
}

// AddedPlanVersion returns the value that was added to the "plan_version" field in this mutation.
func (m *SubscriptionMutation) AddedPlanVersion() (r int, exists bool) {
	v := m.addplan_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlanVersion resets all changes to the "plan_version" field.
func (m *SubscriptionMutation) ResetPlanVersion() {
	m.plan_version = nil
	m.addplan_version = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *SubscriptionMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *SubscriptionMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *SubscriptionMutation) ResetCustomerID() {
	m.customer = nil
}

// SetCurrency sets the "currency" field.
func (m *SubscriptionMutation) SetCurrency(c currencyx.Code) {
	m.currency = &c
}

// Currency returns the value of the "currency" field in the mutation.
func (m *SubscriptionMutation) Currency() (r currencyx.Code, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCurrency(ctx context.Context) (v currencyx.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *SubscriptionMutation) ResetCurrency() {
	m.currency = nil
}

// AddSubscriptionPatchIDs adds the "subscription_patches" edge to the SubscriptionPatch entity by ids.
func (m *SubscriptionMutation) AddSubscriptionPatchIDs(ids ...string) {
	if m.subscription_patches == nil {
		m.subscription_patches = make(map[string]struct{})
	}
	for i := range ids {
		m.subscription_patches[ids[i]] = struct{}{}
	}
}

// ClearSubscriptionPatches clears the "subscription_patches" edge to the SubscriptionPatch entity.
func (m *SubscriptionMutation) ClearSubscriptionPatches() {
	m.clearedsubscription_patches = true
}

// SubscriptionPatchesCleared reports if the "subscription_patches" edge to the SubscriptionPatch entity was cleared.
func (m *SubscriptionMutation) SubscriptionPatchesCleared() bool {
	return m.clearedsubscription_patches
}

// RemoveSubscriptionPatchIDs removes the "subscription_patches" edge to the SubscriptionPatch entity by IDs.
func (m *SubscriptionMutation) RemoveSubscriptionPatchIDs(ids ...string) {
	if m.removedsubscription_patches == nil {
		m.removedsubscription_patches = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscription_patches, ids[i])
		m.removedsubscription_patches[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptionPatches returns the removed IDs of the "subscription_patches" edge to the SubscriptionPatch entity.
func (m *SubscriptionMutation) RemovedSubscriptionPatchesIDs() (ids []string) {
	for id := range m.removedsubscription_patches {
		ids = append(ids, id)
	}
	return
}

// SubscriptionPatchesIDs returns the "subscription_patches" edge IDs in the mutation.
func (m *SubscriptionMutation) SubscriptionPatchesIDs() (ids []string) {
	for id := range m.subscription_patches {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptionPatches resets all changes to the "subscription_patches" edge.
func (m *SubscriptionMutation) ResetSubscriptionPatches() {
	m.subscription_patches = nil
	m.clearedsubscription_patches = false
	m.removedsubscription_patches = nil
}

// AddPriceIDs adds the "prices" edge to the Price entity by ids.
func (m *SubscriptionMutation) AddPriceIDs(ids ...string) {
	if m.prices == nil {
		m.prices = make(map[string]struct{})
	}
	for i := range ids {
		m.prices[ids[i]] = struct{}{}
	}
}

// ClearPrices clears the "prices" edge to the Price entity.
func (m *SubscriptionMutation) ClearPrices() {
	m.clearedprices = true
}

// PricesCleared reports if the "prices" edge to the Price entity was cleared.
func (m *SubscriptionMutation) PricesCleared() bool {
	return m.clearedprices
}

// RemovePriceIDs removes the "prices" edge to the Price entity by IDs.
func (m *SubscriptionMutation) RemovePriceIDs(ids ...string) {
	if m.removedprices == nil {
		m.removedprices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.prices, ids[i])
		m.removedprices[ids[i]] = struct{}{}
	}
}

// RemovedPrices returns the removed IDs of the "prices" edge to the Price entity.
func (m *SubscriptionMutation) RemovedPricesIDs() (ids []string) {
	for id := range m.removedprices {
		ids = append(ids, id)
	}
	return
}

// PricesIDs returns the "prices" edge IDs in the mutation.
func (m *SubscriptionMutation) PricesIDs() (ids []string) {
	for id := range m.prices {
		ids = append(ids, id)
	}
	return
}

// ResetPrices resets all changes to the "prices" edge.
func (m *SubscriptionMutation) ResetPrices() {
	m.prices = nil
	m.clearedprices = false
	m.removedprices = nil
}

// AddEntitlementIDs adds the "entitlements" edge to the SubscriptionEntitlement entity by ids.
func (m *SubscriptionMutation) AddEntitlementIDs(ids ...string) {
	if m.entitlements == nil {
		m.entitlements = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlements[ids[i]] = struct{}{}
	}
}

// ClearEntitlements clears the "entitlements" edge to the SubscriptionEntitlement entity.
func (m *SubscriptionMutation) ClearEntitlements() {
	m.clearedentitlements = true
}

// EntitlementsCleared reports if the "entitlements" edge to the SubscriptionEntitlement entity was cleared.
func (m *SubscriptionMutation) EntitlementsCleared() bool {
	return m.clearedentitlements
}

// RemoveEntitlementIDs removes the "entitlements" edge to the SubscriptionEntitlement entity by IDs.
func (m *SubscriptionMutation) RemoveEntitlementIDs(ids ...string) {
	if m.removedentitlements == nil {
		m.removedentitlements = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlements, ids[i])
		m.removedentitlements[ids[i]] = struct{}{}
	}
}

// RemovedEntitlements returns the removed IDs of the "entitlements" edge to the SubscriptionEntitlement entity.
func (m *SubscriptionMutation) RemovedEntitlementsIDs() (ids []string) {
	for id := range m.removedentitlements {
		ids = append(ids, id)
	}
	return
}

// EntitlementsIDs returns the "entitlements" edge IDs in the mutation.
func (m *SubscriptionMutation) EntitlementsIDs() (ids []string) {
	for id := range m.entitlements {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlements resets all changes to the "entitlements" edge.
func (m *SubscriptionMutation) ResetEntitlements() {
	m.entitlements = nil
	m.clearedentitlements = false
	m.removedentitlements = nil
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *SubscriptionMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[subscription.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *SubscriptionMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *SubscriptionMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.namespace != nil {
		fields = append(fields, subscription.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, subscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscription.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscription.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, subscription.FieldMetadata)
	}
	if m.active_from != nil {
		fields = append(fields, subscription.FieldActiveFrom)
	}
	if m.active_to != nil {
		fields = append(fields, subscription.FieldActiveTo)
	}
	if m.plan_key != nil {
		fields = append(fields, subscription.FieldPlanKey)
	}
	if m.plan_version != nil {
		fields = append(fields, subscription.FieldPlanVersion)
	}
	if m.customer != nil {
		fields = append(fields, subscription.FieldCustomerID)
	}
	if m.currency != nil {
		fields = append(fields, subscription.FieldCurrency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldNamespace:
		return m.Namespace()
	case subscription.FieldCreatedAt:
		return m.CreatedAt()
	case subscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscription.FieldDeletedAt:
		return m.DeletedAt()
	case subscription.FieldMetadata:
		return m.Metadata()
	case subscription.FieldActiveFrom:
		return m.ActiveFrom()
	case subscription.FieldActiveTo:
		return m.ActiveTo()
	case subscription.FieldPlanKey:
		return m.PlanKey()
	case subscription.FieldPlanVersion:
		return m.PlanVersion()
	case subscription.FieldCustomerID:
		return m.CustomerID()
	case subscription.FieldCurrency:
		return m.Currency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscription.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscription.FieldMetadata:
		return m.OldMetadata(ctx)
	case subscription.FieldActiveFrom:
		return m.OldActiveFrom(ctx)
	case subscription.FieldActiveTo:
		return m.OldActiveTo(ctx)
	case subscription.FieldPlanKey:
		return m.OldPlanKey(ctx)
	case subscription.FieldPlanVersion:
		return m.OldPlanVersion(ctx)
	case subscription.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case subscription.FieldCurrency:
		return m.OldCurrency(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscription.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscription.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case subscription.FieldActiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveFrom(v)
		return nil
	case subscription.FieldActiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveTo(v)
		return nil
	case subscription.FieldPlanKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanKey(v)
		return nil
	case subscription.FieldPlanVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanVersion(v)
		return nil
	case subscription.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case subscription.FieldCurrency:
		v, ok := value.(currencyx.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.addplan_version != nil {
		fields = append(fields, subscription.FieldPlanVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldPlanVersion:
		return m.AddedPlanVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldPlanVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlanVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldDeletedAt) {
		fields = append(fields, subscription.FieldDeletedAt)
	}
	if m.FieldCleared(subscription.FieldMetadata) {
		fields = append(fields, subscription.FieldMetadata)
	}
	if m.FieldCleared(subscription.FieldActiveTo) {
		fields = append(fields, subscription.FieldActiveTo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscription.FieldMetadata:
		m.ClearMetadata()
		return nil
	case subscription.FieldActiveTo:
		m.ClearActiveTo()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscription.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscription.FieldMetadata:
		m.ResetMetadata()
		return nil
	case subscription.FieldActiveFrom:
		m.ResetActiveFrom()
		return nil
	case subscription.FieldActiveTo:
		m.ResetActiveTo()
		return nil
	case subscription.FieldPlanKey:
		m.ResetPlanKey()
		return nil
	case subscription.FieldPlanVersion:
		m.ResetPlanVersion()
		return nil
	case subscription.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case subscription.FieldCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.subscription_patches != nil {
		edges = append(edges, subscription.EdgeSubscriptionPatches)
	}
	if m.prices != nil {
		edges = append(edges, subscription.EdgePrices)
	}
	if m.entitlements != nil {
		edges = append(edges, subscription.EdgeEntitlements)
	}
	if m.customer != nil {
		edges = append(edges, subscription.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeSubscriptionPatches:
		ids := make([]ent.Value, 0, len(m.subscription_patches))
		for id := range m.subscription_patches {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgePrices:
		ids := make([]ent.Value, 0, len(m.prices))
		for id := range m.prices {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgeEntitlements:
		ids := make([]ent.Value, 0, len(m.entitlements))
		for id := range m.entitlements {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsubscription_patches != nil {
		edges = append(edges, subscription.EdgeSubscriptionPatches)
	}
	if m.removedprices != nil {
		edges = append(edges, subscription.EdgePrices)
	}
	if m.removedentitlements != nil {
		edges = append(edges, subscription.EdgeEntitlements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeSubscriptionPatches:
		ids := make([]ent.Value, 0, len(m.removedsubscription_patches))
		for id := range m.removedsubscription_patches {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgePrices:
		ids := make([]ent.Value, 0, len(m.removedprices))
		for id := range m.removedprices {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgeEntitlements:
		ids := make([]ent.Value, 0, len(m.removedentitlements))
		for id := range m.removedentitlements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsubscription_patches {
		edges = append(edges, subscription.EdgeSubscriptionPatches)
	}
	if m.clearedprices {
		edges = append(edges, subscription.EdgePrices)
	}
	if m.clearedentitlements {
		edges = append(edges, subscription.EdgeEntitlements)
	}
	if m.clearedcustomer {
		edges = append(edges, subscription.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case subscription.EdgeSubscriptionPatches:
		return m.clearedsubscription_patches
	case subscription.EdgePrices:
		return m.clearedprices
	case subscription.EdgeEntitlements:
		return m.clearedentitlements
	case subscription.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case subscription.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case subscription.EdgeSubscriptionPatches:
		m.ResetSubscriptionPatches()
		return nil
	case subscription.EdgePrices:
		m.ResetPrices()
		return nil
	case subscription.EdgeEntitlements:
		m.ResetEntitlements()
		return nil
	case subscription.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// SubscriptionEntitlementMutation represents an operation that mutates the SubscriptionEntitlement nodes in the graph.
type SubscriptionEntitlementMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	namespace              *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	subscription_phase_key *string
	subscription_item_key  *string
	clearedFields          map[string]struct{}
	subscription           *string
	clearedsubscription    bool
	entitlement            *string
	clearedentitlement     bool
	done                   bool
	oldValue               func(context.Context) (*SubscriptionEntitlement, error)
	predicates             []predicate.SubscriptionEntitlement
}

var _ ent.Mutation = (*SubscriptionEntitlementMutation)(nil)

// subscriptionentitlementOption allows management of the mutation configuration using functional options.
type subscriptionentitlementOption func(*SubscriptionEntitlementMutation)

// newSubscriptionEntitlementMutation creates new mutation for the SubscriptionEntitlement entity.
func newSubscriptionEntitlementMutation(c config, op Op, opts ...subscriptionentitlementOption) *SubscriptionEntitlementMutation {
	m := &SubscriptionEntitlementMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionEntitlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionEntitlementID sets the ID field of the mutation.
func withSubscriptionEntitlementID(id string) subscriptionentitlementOption {
	return func(m *SubscriptionEntitlementMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionEntitlement
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionEntitlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionEntitlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionEntitlement sets the old SubscriptionEntitlement of the mutation.
func withSubscriptionEntitlement(node *SubscriptionEntitlement) subscriptionentitlementOption {
	return func(m *SubscriptionEntitlementMutation) {
		m.oldValue = func(context.Context) (*SubscriptionEntitlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionEntitlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionEntitlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionEntitlement entities.
func (m *SubscriptionEntitlementMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionEntitlementMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionEntitlementMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionEntitlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionEntitlementMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionEntitlementMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SubscriptionEntitlement entity.
// If the SubscriptionEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionEntitlementMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionEntitlementMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionEntitlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionEntitlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscriptionEntitlement entity.
// If the SubscriptionEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionEntitlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionEntitlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionEntitlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionEntitlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscriptionEntitlement entity.
// If the SubscriptionEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionEntitlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionEntitlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriptionEntitlementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriptionEntitlementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubscriptionEntitlement entity.
// If the SubscriptionEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionEntitlementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscriptionEntitlementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscriptionentitlement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscriptionEntitlementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscriptionentitlement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriptionEntitlementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscriptionentitlement.FieldDeletedAt)
}

// SetEntitlementID sets the "entitlement_id" field.
func (m *SubscriptionEntitlementMutation) SetEntitlementID(s string) {
	m.entitlement = &s
}

// EntitlementID returns the value of the "entitlement_id" field in the mutation.
func (m *SubscriptionEntitlementMutation) EntitlementID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementID returns the old "entitlement_id" field's value of the SubscriptionEntitlement entity.
// If the SubscriptionEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionEntitlementMutation) OldEntitlementID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementID: %w", err)
	}
	return oldValue.EntitlementID, nil
}

// ResetEntitlementID resets all changes to the "entitlement_id" field.
func (m *SubscriptionEntitlementMutation) ResetEntitlementID() {
	m.entitlement = nil
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *SubscriptionEntitlementMutation) SetSubscriptionID(s string) {
	m.subscription = &s
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *SubscriptionEntitlementMutation) SubscriptionID() (r string, exists bool) {
	v := m.subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the SubscriptionEntitlement entity.
// If the SubscriptionEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionEntitlementMutation) OldSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *SubscriptionEntitlementMutation) ResetSubscriptionID() {
	m.subscription = nil
}

// SetSubscriptionPhaseKey sets the "subscription_phase_key" field.
func (m *SubscriptionEntitlementMutation) SetSubscriptionPhaseKey(s string) {
	m.subscription_phase_key = &s
}

// SubscriptionPhaseKey returns the value of the "subscription_phase_key" field in the mutation.
func (m *SubscriptionEntitlementMutation) SubscriptionPhaseKey() (r string, exists bool) {
	v := m.subscription_phase_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionPhaseKey returns the old "subscription_phase_key" field's value of the SubscriptionEntitlement entity.
// If the SubscriptionEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionEntitlementMutation) OldSubscriptionPhaseKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionPhaseKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionPhaseKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionPhaseKey: %w", err)
	}
	return oldValue.SubscriptionPhaseKey, nil
}

// ResetSubscriptionPhaseKey resets all changes to the "subscription_phase_key" field.
func (m *SubscriptionEntitlementMutation) ResetSubscriptionPhaseKey() {
	m.subscription_phase_key = nil
}

// SetSubscriptionItemKey sets the "subscription_item_key" field.
func (m *SubscriptionEntitlementMutation) SetSubscriptionItemKey(s string) {
	m.subscription_item_key = &s
}

// SubscriptionItemKey returns the value of the "subscription_item_key" field in the mutation.
func (m *SubscriptionEntitlementMutation) SubscriptionItemKey() (r string, exists bool) {
	v := m.subscription_item_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionItemKey returns the old "subscription_item_key" field's value of the SubscriptionEntitlement entity.
// If the SubscriptionEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionEntitlementMutation) OldSubscriptionItemKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionItemKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionItemKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionItemKey: %w", err)
	}
	return oldValue.SubscriptionItemKey, nil
}

// ResetSubscriptionItemKey resets all changes to the "subscription_item_key" field.
func (m *SubscriptionEntitlementMutation) ResetSubscriptionItemKey() {
	m.subscription_item_key = nil
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *SubscriptionEntitlementMutation) ClearSubscription() {
	m.clearedsubscription = true
	m.clearedFields[subscriptionentitlement.FieldSubscriptionID] = struct{}{}
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *SubscriptionEntitlementMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *SubscriptionEntitlementMutation) SubscriptionIDs() (ids []string) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *SubscriptionEntitlementMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *SubscriptionEntitlementMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[subscriptionentitlement.FieldEntitlementID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *SubscriptionEntitlementMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *SubscriptionEntitlementMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *SubscriptionEntitlementMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the SubscriptionEntitlementMutation builder.
func (m *SubscriptionEntitlementMutation) Where(ps ...predicate.SubscriptionEntitlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionEntitlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionEntitlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionEntitlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionEntitlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionEntitlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionEntitlement).
func (m *SubscriptionEntitlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionEntitlementMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, subscriptionentitlement.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, subscriptionentitlement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriptionentitlement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscriptionentitlement.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, subscriptionentitlement.FieldEntitlementID)
	}
	if m.subscription != nil {
		fields = append(fields, subscriptionentitlement.FieldSubscriptionID)
	}
	if m.subscription_phase_key != nil {
		fields = append(fields, subscriptionentitlement.FieldSubscriptionPhaseKey)
	}
	if m.subscription_item_key != nil {
		fields = append(fields, subscriptionentitlement.FieldSubscriptionItemKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionEntitlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptionentitlement.FieldNamespace:
		return m.Namespace()
	case subscriptionentitlement.FieldCreatedAt:
		return m.CreatedAt()
	case subscriptionentitlement.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscriptionentitlement.FieldDeletedAt:
		return m.DeletedAt()
	case subscriptionentitlement.FieldEntitlementID:
		return m.EntitlementID()
	case subscriptionentitlement.FieldSubscriptionID:
		return m.SubscriptionID()
	case subscriptionentitlement.FieldSubscriptionPhaseKey:
		return m.SubscriptionPhaseKey()
	case subscriptionentitlement.FieldSubscriptionItemKey:
		return m.SubscriptionItemKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionEntitlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptionentitlement.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscriptionentitlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriptionentitlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscriptionentitlement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscriptionentitlement.FieldEntitlementID:
		return m.OldEntitlementID(ctx)
	case subscriptionentitlement.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case subscriptionentitlement.FieldSubscriptionPhaseKey:
		return m.OldSubscriptionPhaseKey(ctx)
	case subscriptionentitlement.FieldSubscriptionItemKey:
		return m.OldSubscriptionItemKey(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionEntitlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionEntitlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptionentitlement.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscriptionentitlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriptionentitlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscriptionentitlement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscriptionentitlement.FieldEntitlementID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementID(v)
		return nil
	case subscriptionentitlement.FieldSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case subscriptionentitlement.FieldSubscriptionPhaseKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionPhaseKey(v)
		return nil
	case subscriptionentitlement.FieldSubscriptionItemKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionItemKey(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionEntitlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionEntitlementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionEntitlementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionEntitlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubscriptionEntitlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionEntitlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriptionentitlement.FieldDeletedAt) {
		fields = append(fields, subscriptionentitlement.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionEntitlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionEntitlementMutation) ClearField(name string) error {
	switch name {
	case subscriptionentitlement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionEntitlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionEntitlementMutation) ResetField(name string) error {
	switch name {
	case subscriptionentitlement.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscriptionentitlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriptionentitlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscriptionentitlement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscriptionentitlement.FieldEntitlementID:
		m.ResetEntitlementID()
		return nil
	case subscriptionentitlement.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case subscriptionentitlement.FieldSubscriptionPhaseKey:
		m.ResetSubscriptionPhaseKey()
		return nil
	case subscriptionentitlement.FieldSubscriptionItemKey:
		m.ResetSubscriptionItemKey()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionEntitlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionEntitlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.subscription != nil {
		edges = append(edges, subscriptionentitlement.EdgeSubscription)
	}
	if m.entitlement != nil {
		edges = append(edges, subscriptionentitlement.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionEntitlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptionentitlement.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	case subscriptionentitlement.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionEntitlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionEntitlementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionEntitlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsubscription {
		edges = append(edges, subscriptionentitlement.EdgeSubscription)
	}
	if m.clearedentitlement {
		edges = append(edges, subscriptionentitlement.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionEntitlementMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptionentitlement.EdgeSubscription:
		return m.clearedsubscription
	case subscriptionentitlement.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionEntitlementMutation) ClearEdge(name string) error {
	switch name {
	case subscriptionentitlement.EdgeSubscription:
		m.ClearSubscription()
		return nil
	case subscriptionentitlement.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionEntitlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionEntitlementMutation) ResetEdge(name string) error {
	switch name {
	case subscriptionentitlement.EdgeSubscription:
		m.ResetSubscription()
		return nil
	case subscriptionentitlement.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionEntitlement edge %s", name)
}

// SubscriptionPatchMutation represents an operation that mutates the SubscriptionPatch nodes in the graph.
type SubscriptionPatchMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	namespace                 *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	metadata                  *map[string]string
	applied_at                *time.Time
	batch_index               *int
	addbatch_index            *int
	operation                 *string
	_path                     *string
	clearedFields             map[string]struct{}
	subscription              *string
	clearedsubscription       bool
	value_add_item            *string
	clearedvalue_add_item     bool
	value_add_phase           *string
	clearedvalue_add_phase    bool
	value_extend_phase        *string
	clearedvalue_extend_phase bool
	done                      bool
	oldValue                  func(context.Context) (*SubscriptionPatch, error)
	predicates                []predicate.SubscriptionPatch
}

var _ ent.Mutation = (*SubscriptionPatchMutation)(nil)

// subscriptionpatchOption allows management of the mutation configuration using functional options.
type subscriptionpatchOption func(*SubscriptionPatchMutation)

// newSubscriptionPatchMutation creates new mutation for the SubscriptionPatch entity.
func newSubscriptionPatchMutation(c config, op Op, opts ...subscriptionpatchOption) *SubscriptionPatchMutation {
	m := &SubscriptionPatchMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionPatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionPatchID sets the ID field of the mutation.
func withSubscriptionPatchID(id string) subscriptionpatchOption {
	return func(m *SubscriptionPatchMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionPatch
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionPatch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionPatch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionPatch sets the old SubscriptionPatch of the mutation.
func withSubscriptionPatch(node *SubscriptionPatch) subscriptionpatchOption {
	return func(m *SubscriptionPatchMutation) {
		m.oldValue = func(context.Context) (*SubscriptionPatch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionPatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionPatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionPatch entities.
func (m *SubscriptionPatchMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionPatchMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionPatchMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionPatch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionPatchMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionPatchMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SubscriptionPatch entity.
// If the SubscriptionPatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionPatchMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionPatchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionPatchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscriptionPatch entity.
// If the SubscriptionPatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionPatchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionPatchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionPatchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscriptionPatch entity.
// If the SubscriptionPatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionPatchMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriptionPatchMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriptionPatchMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubscriptionPatch entity.
// If the SubscriptionPatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscriptionPatchMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscriptionpatch.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscriptionPatchMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscriptionpatch.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriptionPatchMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscriptionpatch.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *SubscriptionPatchMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SubscriptionPatchMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SubscriptionPatch entity.
// If the SubscriptionPatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SubscriptionPatchMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[subscriptionpatch.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SubscriptionPatchMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[subscriptionpatch.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SubscriptionPatchMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, subscriptionpatch.FieldMetadata)
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *SubscriptionPatchMutation) SetSubscriptionID(s string) {
	m.subscription = &s
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *SubscriptionPatchMutation) SubscriptionID() (r string, exists bool) {
	v := m.subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the SubscriptionPatch entity.
// If the SubscriptionPatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchMutation) OldSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *SubscriptionPatchMutation) ResetSubscriptionID() {
	m.subscription = nil
}

// SetAppliedAt sets the "applied_at" field.
func (m *SubscriptionPatchMutation) SetAppliedAt(t time.Time) {
	m.applied_at = &t
}

// AppliedAt returns the value of the "applied_at" field in the mutation.
func (m *SubscriptionPatchMutation) AppliedAt() (r time.Time, exists bool) {
	v := m.applied_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliedAt returns the old "applied_at" field's value of the SubscriptionPatch entity.
// If the SubscriptionPatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchMutation) OldAppliedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliedAt: %w", err)
	}
	return oldValue.AppliedAt, nil
}

// ResetAppliedAt resets all changes to the "applied_at" field.
func (m *SubscriptionPatchMutation) ResetAppliedAt() {
	m.applied_at = nil
}

// SetBatchIndex sets the "batch_index" field.
func (m *SubscriptionPatchMutation) SetBatchIndex(i int) {
	m.batch_index = &i
	m.addbatch_index = nil
}

// BatchIndex returns the value of the "batch_index" field in the mutation.
func (m *SubscriptionPatchMutation) BatchIndex() (r int, exists bool) {
	v := m.batch_index
	if v == nil {
		return
	}
	return *v, true
}

// OldBatchIndex returns the old "batch_index" field's value of the SubscriptionPatch entity.
// If the SubscriptionPatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchMutation) OldBatchIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatchIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatchIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatchIndex: %w", err)
	}
	return oldValue.BatchIndex, nil
}

// AddBatchIndex adds i to the "batch_index" field.
func (m *SubscriptionPatchMutation) AddBatchIndex(i int) {
	if m.addbatch_index != nil {
		*m.addbatch_index += i
	} else {
		m.addbatch_index = &i
	}
}

// AddedBatchIndex returns the value that was added to the "batch_index" field in this mutation.
func (m *SubscriptionPatchMutation) AddedBatchIndex() (r int, exists bool) {
	v := m.addbatch_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetBatchIndex resets all changes to the "batch_index" field.
func (m *SubscriptionPatchMutation) ResetBatchIndex() {
	m.batch_index = nil
	m.addbatch_index = nil
}

// SetOperation sets the "operation" field.
func (m *SubscriptionPatchMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *SubscriptionPatchMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the SubscriptionPatch entity.
// If the SubscriptionPatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchMutation) OldOperation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *SubscriptionPatchMutation) ResetOperation() {
	m.operation = nil
}

// SetPath sets the "path" field.
func (m *SubscriptionPatchMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *SubscriptionPatchMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the SubscriptionPatch entity.
// If the SubscriptionPatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *SubscriptionPatchMutation) ResetPath() {
	m._path = nil
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *SubscriptionPatchMutation) ClearSubscription() {
	m.clearedsubscription = true
	m.clearedFields[subscriptionpatch.FieldSubscriptionID] = struct{}{}
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *SubscriptionPatchMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *SubscriptionPatchMutation) SubscriptionIDs() (ids []string) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *SubscriptionPatchMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// SetValueAddItemID sets the "value_add_item" edge to the SubscriptionPatchValueAddItem entity by id.
func (m *SubscriptionPatchMutation) SetValueAddItemID(id string) {
	m.value_add_item = &id
}

// ClearValueAddItem clears the "value_add_item" edge to the SubscriptionPatchValueAddItem entity.
func (m *SubscriptionPatchMutation) ClearValueAddItem() {
	m.clearedvalue_add_item = true
}

// ValueAddItemCleared reports if the "value_add_item" edge to the SubscriptionPatchValueAddItem entity was cleared.
func (m *SubscriptionPatchMutation) ValueAddItemCleared() bool {
	return m.clearedvalue_add_item
}

// ValueAddItemID returns the "value_add_item" edge ID in the mutation.
func (m *SubscriptionPatchMutation) ValueAddItemID() (id string, exists bool) {
	if m.value_add_item != nil {
		return *m.value_add_item, true
	}
	return
}

// ValueAddItemIDs returns the "value_add_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValueAddItemID instead. It exists only for internal usage by the builders.
func (m *SubscriptionPatchMutation) ValueAddItemIDs() (ids []string) {
	if id := m.value_add_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValueAddItem resets all changes to the "value_add_item" edge.
func (m *SubscriptionPatchMutation) ResetValueAddItem() {
	m.value_add_item = nil
	m.clearedvalue_add_item = false
}

// SetValueAddPhaseID sets the "value_add_phase" edge to the SubscriptionPatchValueAddPhase entity by id.
func (m *SubscriptionPatchMutation) SetValueAddPhaseID(id string) {
	m.value_add_phase = &id
}

// ClearValueAddPhase clears the "value_add_phase" edge to the SubscriptionPatchValueAddPhase entity.
func (m *SubscriptionPatchMutation) ClearValueAddPhase() {
	m.clearedvalue_add_phase = true
}

// ValueAddPhaseCleared reports if the "value_add_phase" edge to the SubscriptionPatchValueAddPhase entity was cleared.
func (m *SubscriptionPatchMutation) ValueAddPhaseCleared() bool {
	return m.clearedvalue_add_phase
}

// ValueAddPhaseID returns the "value_add_phase" edge ID in the mutation.
func (m *SubscriptionPatchMutation) ValueAddPhaseID() (id string, exists bool) {
	if m.value_add_phase != nil {
		return *m.value_add_phase, true
	}
	return
}

// ValueAddPhaseIDs returns the "value_add_phase" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValueAddPhaseID instead. It exists only for internal usage by the builders.
func (m *SubscriptionPatchMutation) ValueAddPhaseIDs() (ids []string) {
	if id := m.value_add_phase; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValueAddPhase resets all changes to the "value_add_phase" edge.
func (m *SubscriptionPatchMutation) ResetValueAddPhase() {
	m.value_add_phase = nil
	m.clearedvalue_add_phase = false
}

// SetValueExtendPhaseID sets the "value_extend_phase" edge to the SubscriptionPatchValueExtendPhase entity by id.
func (m *SubscriptionPatchMutation) SetValueExtendPhaseID(id string) {
	m.value_extend_phase = &id
}

// ClearValueExtendPhase clears the "value_extend_phase" edge to the SubscriptionPatchValueExtendPhase entity.
func (m *SubscriptionPatchMutation) ClearValueExtendPhase() {
	m.clearedvalue_extend_phase = true
}

// ValueExtendPhaseCleared reports if the "value_extend_phase" edge to the SubscriptionPatchValueExtendPhase entity was cleared.
func (m *SubscriptionPatchMutation) ValueExtendPhaseCleared() bool {
	return m.clearedvalue_extend_phase
}

// ValueExtendPhaseID returns the "value_extend_phase" edge ID in the mutation.
func (m *SubscriptionPatchMutation) ValueExtendPhaseID() (id string, exists bool) {
	if m.value_extend_phase != nil {
		return *m.value_extend_phase, true
	}
	return
}

// ValueExtendPhaseIDs returns the "value_extend_phase" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValueExtendPhaseID instead. It exists only for internal usage by the builders.
func (m *SubscriptionPatchMutation) ValueExtendPhaseIDs() (ids []string) {
	if id := m.value_extend_phase; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValueExtendPhase resets all changes to the "value_extend_phase" edge.
func (m *SubscriptionPatchMutation) ResetValueExtendPhase() {
	m.value_extend_phase = nil
	m.clearedvalue_extend_phase = false
}

// Where appends a list predicates to the SubscriptionPatchMutation builder.
func (m *SubscriptionPatchMutation) Where(ps ...predicate.SubscriptionPatch) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionPatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionPatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionPatch, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionPatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionPatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionPatch).
func (m *SubscriptionPatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionPatchMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, subscriptionpatch.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, subscriptionpatch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriptionpatch.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscriptionpatch.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, subscriptionpatch.FieldMetadata)
	}
	if m.subscription != nil {
		fields = append(fields, subscriptionpatch.FieldSubscriptionID)
	}
	if m.applied_at != nil {
		fields = append(fields, subscriptionpatch.FieldAppliedAt)
	}
	if m.batch_index != nil {
		fields = append(fields, subscriptionpatch.FieldBatchIndex)
	}
	if m.operation != nil {
		fields = append(fields, subscriptionpatch.FieldOperation)
	}
	if m._path != nil {
		fields = append(fields, subscriptionpatch.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionPatchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptionpatch.FieldNamespace:
		return m.Namespace()
	case subscriptionpatch.FieldCreatedAt:
		return m.CreatedAt()
	case subscriptionpatch.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscriptionpatch.FieldDeletedAt:
		return m.DeletedAt()
	case subscriptionpatch.FieldMetadata:
		return m.Metadata()
	case subscriptionpatch.FieldSubscriptionID:
		return m.SubscriptionID()
	case subscriptionpatch.FieldAppliedAt:
		return m.AppliedAt()
	case subscriptionpatch.FieldBatchIndex:
		return m.BatchIndex()
	case subscriptionpatch.FieldOperation:
		return m.Operation()
	case subscriptionpatch.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionPatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptionpatch.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscriptionpatch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriptionpatch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscriptionpatch.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscriptionpatch.FieldMetadata:
		return m.OldMetadata(ctx)
	case subscriptionpatch.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case subscriptionpatch.FieldAppliedAt:
		return m.OldAppliedAt(ctx)
	case subscriptionpatch.FieldBatchIndex:
		return m.OldBatchIndex(ctx)
	case subscriptionpatch.FieldOperation:
		return m.OldOperation(ctx)
	case subscriptionpatch.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionPatch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionPatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptionpatch.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscriptionpatch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriptionpatch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscriptionpatch.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscriptionpatch.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case subscriptionpatch.FieldSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case subscriptionpatch.FieldAppliedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliedAt(v)
		return nil
	case subscriptionpatch.FieldBatchIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatchIndex(v)
		return nil
	case subscriptionpatch.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case subscriptionpatch.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionPatchMutation) AddedFields() []string {
	var fields []string
	if m.addbatch_index != nil {
		fields = append(fields, subscriptionpatch.FieldBatchIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionPatchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscriptionpatch.FieldBatchIndex:
		return m.AddedBatchIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionPatchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscriptionpatch.FieldBatchIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBatchIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionPatchMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriptionpatch.FieldDeletedAt) {
		fields = append(fields, subscriptionpatch.FieldDeletedAt)
	}
	if m.FieldCleared(subscriptionpatch.FieldMetadata) {
		fields = append(fields, subscriptionpatch.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionPatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionPatchMutation) ClearField(name string) error {
	switch name {
	case subscriptionpatch.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscriptionpatch.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionPatchMutation) ResetField(name string) error {
	switch name {
	case subscriptionpatch.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscriptionpatch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriptionpatch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscriptionpatch.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscriptionpatch.FieldMetadata:
		m.ResetMetadata()
		return nil
	case subscriptionpatch.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case subscriptionpatch.FieldAppliedAt:
		m.ResetAppliedAt()
		return nil
	case subscriptionpatch.FieldBatchIndex:
		m.ResetBatchIndex()
		return nil
	case subscriptionpatch.FieldOperation:
		m.ResetOperation()
		return nil
	case subscriptionpatch.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionPatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.subscription != nil {
		edges = append(edges, subscriptionpatch.EdgeSubscription)
	}
	if m.value_add_item != nil {
		edges = append(edges, subscriptionpatch.EdgeValueAddItem)
	}
	if m.value_add_phase != nil {
		edges = append(edges, subscriptionpatch.EdgeValueAddPhase)
	}
	if m.value_extend_phase != nil {
		edges = append(edges, subscriptionpatch.EdgeValueExtendPhase)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionPatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptionpatch.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	case subscriptionpatch.EdgeValueAddItem:
		if id := m.value_add_item; id != nil {
			return []ent.Value{*id}
		}
	case subscriptionpatch.EdgeValueAddPhase:
		if id := m.value_add_phase; id != nil {
			return []ent.Value{*id}
		}
	case subscriptionpatch.EdgeValueExtendPhase:
		if id := m.value_extend_phase; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionPatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionPatchMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionPatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsubscription {
		edges = append(edges, subscriptionpatch.EdgeSubscription)
	}
	if m.clearedvalue_add_item {
		edges = append(edges, subscriptionpatch.EdgeValueAddItem)
	}
	if m.clearedvalue_add_phase {
		edges = append(edges, subscriptionpatch.EdgeValueAddPhase)
	}
	if m.clearedvalue_extend_phase {
		edges = append(edges, subscriptionpatch.EdgeValueExtendPhase)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionPatchMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptionpatch.EdgeSubscription:
		return m.clearedsubscription
	case subscriptionpatch.EdgeValueAddItem:
		return m.clearedvalue_add_item
	case subscriptionpatch.EdgeValueAddPhase:
		return m.clearedvalue_add_phase
	case subscriptionpatch.EdgeValueExtendPhase:
		return m.clearedvalue_extend_phase
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionPatchMutation) ClearEdge(name string) error {
	switch name {
	case subscriptionpatch.EdgeSubscription:
		m.ClearSubscription()
		return nil
	case subscriptionpatch.EdgeValueAddItem:
		m.ClearValueAddItem()
		return nil
	case subscriptionpatch.EdgeValueAddPhase:
		m.ClearValueAddPhase()
		return nil
	case subscriptionpatch.EdgeValueExtendPhase:
		m.ClearValueExtendPhase()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionPatchMutation) ResetEdge(name string) error {
	switch name {
	case subscriptionpatch.EdgeSubscription:
		m.ResetSubscription()
		return nil
	case subscriptionpatch.EdgeValueAddItem:
		m.ResetValueAddItem()
		return nil
	case subscriptionpatch.EdgeValueAddPhase:
		m.ResetValueAddPhase()
		return nil
	case subscriptionpatch.EdgeValueExtendPhase:
		m.ResetValueExtendPhase()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatch edge %s", name)
}

// SubscriptionPatchValueAddItemMutation represents an operation that mutates the SubscriptionPatchValueAddItem nodes in the graph.
type SubscriptionPatchValueAddItemMutation struct {
	config
	op                                               Op
	typ                                              string
	id                                               *string
	namespace                                        *string
	phase_key                                        *string
	item_key                                         *string
	feature_key                                      *string
	create_entitlement_entitlement_type              *string
	create_entitlement_issue_after_reset             *float64
	addcreate_entitlement_issue_after_reset          *float64
	create_entitlement_issue_after_reset_priority    *uint8
	addcreate_entitlement_issue_after_reset_priority *int8
	create_entitlement_is_soft_limit                 *bool
	create_entitlement_preserve_overage_at_reset     *bool
	create_entitlement_usage_period_iso_duration     *string
	create_entitlement_config                        *[]uint8
	appendcreate_entitlement_config                  []uint8
	create_price_key                                 *string
	create_price_value                               *string
	clearedFields                                    map[string]struct{}
	subscription_patch                               *string
	clearedsubscription_patch                        bool
	done                                             bool
	oldValue                                         func(context.Context) (*SubscriptionPatchValueAddItem, error)
	predicates                                       []predicate.SubscriptionPatchValueAddItem
}

var _ ent.Mutation = (*SubscriptionPatchValueAddItemMutation)(nil)

// subscriptionpatchvalueadditemOption allows management of the mutation configuration using functional options.
type subscriptionpatchvalueadditemOption func(*SubscriptionPatchValueAddItemMutation)

// newSubscriptionPatchValueAddItemMutation creates new mutation for the SubscriptionPatchValueAddItem entity.
func newSubscriptionPatchValueAddItemMutation(c config, op Op, opts ...subscriptionpatchvalueadditemOption) *SubscriptionPatchValueAddItemMutation {
	m := &SubscriptionPatchValueAddItemMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionPatchValueAddItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionPatchValueAddItemID sets the ID field of the mutation.
func withSubscriptionPatchValueAddItemID(id string) subscriptionpatchvalueadditemOption {
	return func(m *SubscriptionPatchValueAddItemMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionPatchValueAddItem
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionPatchValueAddItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionPatchValueAddItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionPatchValueAddItem sets the old SubscriptionPatchValueAddItem of the mutation.
func withSubscriptionPatchValueAddItem(node *SubscriptionPatchValueAddItem) subscriptionpatchvalueadditemOption {
	return func(m *SubscriptionPatchValueAddItemMutation) {
		m.oldValue = func(context.Context) (*SubscriptionPatchValueAddItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionPatchValueAddItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionPatchValueAddItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionPatchValueAddItem entities.
func (m *SubscriptionPatchValueAddItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionPatchValueAddItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionPatchValueAddItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionPatchValueAddItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionPatchValueAddItemMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetNamespace() {
	m.namespace = nil
}

// SetSubscriptionPatchID sets the "subscription_patch_id" field.
func (m *SubscriptionPatchValueAddItemMutation) SetSubscriptionPatchID(s string) {
	m.subscription_patch = &s
}

// SubscriptionPatchID returns the value of the "subscription_patch_id" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) SubscriptionPatchID() (r string, exists bool) {
	v := m.subscription_patch
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionPatchID returns the old "subscription_patch_id" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldSubscriptionPatchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionPatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionPatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionPatchID: %w", err)
	}
	return oldValue.SubscriptionPatchID, nil
}

// ResetSubscriptionPatchID resets all changes to the "subscription_patch_id" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetSubscriptionPatchID() {
	m.subscription_patch = nil
}

// SetPhaseKey sets the "phase_key" field.
func (m *SubscriptionPatchValueAddItemMutation) SetPhaseKey(s string) {
	m.phase_key = &s
}

// PhaseKey returns the value of the "phase_key" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) PhaseKey() (r string, exists bool) {
	v := m.phase_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPhaseKey returns the old "phase_key" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldPhaseKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhaseKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhaseKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhaseKey: %w", err)
	}
	return oldValue.PhaseKey, nil
}

// ResetPhaseKey resets all changes to the "phase_key" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetPhaseKey() {
	m.phase_key = nil
}

// SetItemKey sets the "item_key" field.
func (m *SubscriptionPatchValueAddItemMutation) SetItemKey(s string) {
	m.item_key = &s
}

// ItemKey returns the value of the "item_key" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) ItemKey() (r string, exists bool) {
	v := m.item_key
	if v == nil {
		return
	}
	return *v, true
}

// OldItemKey returns the old "item_key" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldItemKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemKey: %w", err)
	}
	return oldValue.ItemKey, nil
}

// ResetItemKey resets all changes to the "item_key" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetItemKey() {
	m.item_key = nil
}

// SetFeatureKey sets the "feature_key" field.
func (m *SubscriptionPatchValueAddItemMutation) SetFeatureKey(s string) {
	m.feature_key = &s
}

// FeatureKey returns the value of the "feature_key" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) FeatureKey() (r string, exists bool) {
	v := m.feature_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureKey returns the old "feature_key" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldFeatureKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureKey: %w", err)
	}
	return oldValue.FeatureKey, nil
}

// ClearFeatureKey clears the value of the "feature_key" field.
func (m *SubscriptionPatchValueAddItemMutation) ClearFeatureKey() {
	m.feature_key = nil
	m.clearedFields[subscriptionpatchvalueadditem.FieldFeatureKey] = struct{}{}
}

// FeatureKeyCleared returns if the "feature_key" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) FeatureKeyCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueadditem.FieldFeatureKey]
	return ok
}

// ResetFeatureKey resets all changes to the "feature_key" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetFeatureKey() {
	m.feature_key = nil
	delete(m.clearedFields, subscriptionpatchvalueadditem.FieldFeatureKey)
}

// SetCreateEntitlementEntitlementType sets the "create_entitlement_entitlement_type" field.
func (m *SubscriptionPatchValueAddItemMutation) SetCreateEntitlementEntitlementType(s string) {
	m.create_entitlement_entitlement_type = &s
}

// CreateEntitlementEntitlementType returns the value of the "create_entitlement_entitlement_type" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementEntitlementType() (r string, exists bool) {
	v := m.create_entitlement_entitlement_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateEntitlementEntitlementType returns the old "create_entitlement_entitlement_type" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldCreateEntitlementEntitlementType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateEntitlementEntitlementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateEntitlementEntitlementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateEntitlementEntitlementType: %w", err)
	}
	return oldValue.CreateEntitlementEntitlementType, nil
}

// ClearCreateEntitlementEntitlementType clears the value of the "create_entitlement_entitlement_type" field.
func (m *SubscriptionPatchValueAddItemMutation) ClearCreateEntitlementEntitlementType() {
	m.create_entitlement_entitlement_type = nil
	m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType] = struct{}{}
}

// CreateEntitlementEntitlementTypeCleared returns if the "create_entitlement_entitlement_type" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementEntitlementTypeCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType]
	return ok
}

// ResetCreateEntitlementEntitlementType resets all changes to the "create_entitlement_entitlement_type" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetCreateEntitlementEntitlementType() {
	m.create_entitlement_entitlement_type = nil
	delete(m.clearedFields, subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType)
}

// SetCreateEntitlementIssueAfterReset sets the "create_entitlement_issue_after_reset" field.
func (m *SubscriptionPatchValueAddItemMutation) SetCreateEntitlementIssueAfterReset(f float64) {
	m.create_entitlement_issue_after_reset = &f
	m.addcreate_entitlement_issue_after_reset = nil
}

// CreateEntitlementIssueAfterReset returns the value of the "create_entitlement_issue_after_reset" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementIssueAfterReset() (r float64, exists bool) {
	v := m.create_entitlement_issue_after_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateEntitlementIssueAfterReset returns the old "create_entitlement_issue_after_reset" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldCreateEntitlementIssueAfterReset(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateEntitlementIssueAfterReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateEntitlementIssueAfterReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateEntitlementIssueAfterReset: %w", err)
	}
	return oldValue.CreateEntitlementIssueAfterReset, nil
}

// AddCreateEntitlementIssueAfterReset adds f to the "create_entitlement_issue_after_reset" field.
func (m *SubscriptionPatchValueAddItemMutation) AddCreateEntitlementIssueAfterReset(f float64) {
	if m.addcreate_entitlement_issue_after_reset != nil {
		*m.addcreate_entitlement_issue_after_reset += f
	} else {
		m.addcreate_entitlement_issue_after_reset = &f
	}
}

// AddedCreateEntitlementIssueAfterReset returns the value that was added to the "create_entitlement_issue_after_reset" field in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) AddedCreateEntitlementIssueAfterReset() (r float64, exists bool) {
	v := m.addcreate_entitlement_issue_after_reset
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateEntitlementIssueAfterReset clears the value of the "create_entitlement_issue_after_reset" field.
func (m *SubscriptionPatchValueAddItemMutation) ClearCreateEntitlementIssueAfterReset() {
	m.create_entitlement_issue_after_reset = nil
	m.addcreate_entitlement_issue_after_reset = nil
	m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset] = struct{}{}
}

// CreateEntitlementIssueAfterResetCleared returns if the "create_entitlement_issue_after_reset" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementIssueAfterResetCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset]
	return ok
}

// ResetCreateEntitlementIssueAfterReset resets all changes to the "create_entitlement_issue_after_reset" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetCreateEntitlementIssueAfterReset() {
	m.create_entitlement_issue_after_reset = nil
	m.addcreate_entitlement_issue_after_reset = nil
	delete(m.clearedFields, subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset)
}

// SetCreateEntitlementIssueAfterResetPriority sets the "create_entitlement_issue_after_reset_priority" field.
func (m *SubscriptionPatchValueAddItemMutation) SetCreateEntitlementIssueAfterResetPriority(u uint8) {
	m.create_entitlement_issue_after_reset_priority = &u
	m.addcreate_entitlement_issue_after_reset_priority = nil
}

// CreateEntitlementIssueAfterResetPriority returns the value of the "create_entitlement_issue_after_reset_priority" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementIssueAfterResetPriority() (r uint8, exists bool) {
	v := m.create_entitlement_issue_after_reset_priority
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateEntitlementIssueAfterResetPriority returns the old "create_entitlement_issue_after_reset_priority" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldCreateEntitlementIssueAfterResetPriority(ctx context.Context) (v *uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateEntitlementIssueAfterResetPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateEntitlementIssueAfterResetPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateEntitlementIssueAfterResetPriority: %w", err)
	}
	return oldValue.CreateEntitlementIssueAfterResetPriority, nil
}

// AddCreateEntitlementIssueAfterResetPriority adds u to the "create_entitlement_issue_after_reset_priority" field.
func (m *SubscriptionPatchValueAddItemMutation) AddCreateEntitlementIssueAfterResetPriority(u int8) {
	if m.addcreate_entitlement_issue_after_reset_priority != nil {
		*m.addcreate_entitlement_issue_after_reset_priority += u
	} else {
		m.addcreate_entitlement_issue_after_reset_priority = &u
	}
}

// AddedCreateEntitlementIssueAfterResetPriority returns the value that was added to the "create_entitlement_issue_after_reset_priority" field in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) AddedCreateEntitlementIssueAfterResetPriority() (r int8, exists bool) {
	v := m.addcreate_entitlement_issue_after_reset_priority
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateEntitlementIssueAfterResetPriority clears the value of the "create_entitlement_issue_after_reset_priority" field.
func (m *SubscriptionPatchValueAddItemMutation) ClearCreateEntitlementIssueAfterResetPriority() {
	m.create_entitlement_issue_after_reset_priority = nil
	m.addcreate_entitlement_issue_after_reset_priority = nil
	m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority] = struct{}{}
}

// CreateEntitlementIssueAfterResetPriorityCleared returns if the "create_entitlement_issue_after_reset_priority" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementIssueAfterResetPriorityCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority]
	return ok
}

// ResetCreateEntitlementIssueAfterResetPriority resets all changes to the "create_entitlement_issue_after_reset_priority" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetCreateEntitlementIssueAfterResetPriority() {
	m.create_entitlement_issue_after_reset_priority = nil
	m.addcreate_entitlement_issue_after_reset_priority = nil
	delete(m.clearedFields, subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority)
}

// SetCreateEntitlementIsSoftLimit sets the "create_entitlement_is_soft_limit" field.
func (m *SubscriptionPatchValueAddItemMutation) SetCreateEntitlementIsSoftLimit(b bool) {
	m.create_entitlement_is_soft_limit = &b
}

// CreateEntitlementIsSoftLimit returns the value of the "create_entitlement_is_soft_limit" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementIsSoftLimit() (r bool, exists bool) {
	v := m.create_entitlement_is_soft_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateEntitlementIsSoftLimit returns the old "create_entitlement_is_soft_limit" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldCreateEntitlementIsSoftLimit(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateEntitlementIsSoftLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateEntitlementIsSoftLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateEntitlementIsSoftLimit: %w", err)
	}
	return oldValue.CreateEntitlementIsSoftLimit, nil
}

// ClearCreateEntitlementIsSoftLimit clears the value of the "create_entitlement_is_soft_limit" field.
func (m *SubscriptionPatchValueAddItemMutation) ClearCreateEntitlementIsSoftLimit() {
	m.create_entitlement_is_soft_limit = nil
	m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit] = struct{}{}
}

// CreateEntitlementIsSoftLimitCleared returns if the "create_entitlement_is_soft_limit" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementIsSoftLimitCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit]
	return ok
}

// ResetCreateEntitlementIsSoftLimit resets all changes to the "create_entitlement_is_soft_limit" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetCreateEntitlementIsSoftLimit() {
	m.create_entitlement_is_soft_limit = nil
	delete(m.clearedFields, subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit)
}

// SetCreateEntitlementPreserveOverageAtReset sets the "create_entitlement_preserve_overage_at_reset" field.
func (m *SubscriptionPatchValueAddItemMutation) SetCreateEntitlementPreserveOverageAtReset(b bool) {
	m.create_entitlement_preserve_overage_at_reset = &b
}

// CreateEntitlementPreserveOverageAtReset returns the value of the "create_entitlement_preserve_overage_at_reset" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementPreserveOverageAtReset() (r bool, exists bool) {
	v := m.create_entitlement_preserve_overage_at_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateEntitlementPreserveOverageAtReset returns the old "create_entitlement_preserve_overage_at_reset" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldCreateEntitlementPreserveOverageAtReset(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateEntitlementPreserveOverageAtReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateEntitlementPreserveOverageAtReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateEntitlementPreserveOverageAtReset: %w", err)
	}
	return oldValue.CreateEntitlementPreserveOverageAtReset, nil
}

// ClearCreateEntitlementPreserveOverageAtReset clears the value of the "create_entitlement_preserve_overage_at_reset" field.
func (m *SubscriptionPatchValueAddItemMutation) ClearCreateEntitlementPreserveOverageAtReset() {
	m.create_entitlement_preserve_overage_at_reset = nil
	m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset] = struct{}{}
}

// CreateEntitlementPreserveOverageAtResetCleared returns if the "create_entitlement_preserve_overage_at_reset" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementPreserveOverageAtResetCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset]
	return ok
}

// ResetCreateEntitlementPreserveOverageAtReset resets all changes to the "create_entitlement_preserve_overage_at_reset" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetCreateEntitlementPreserveOverageAtReset() {
	m.create_entitlement_preserve_overage_at_reset = nil
	delete(m.clearedFields, subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset)
}

// SetCreateEntitlementUsagePeriodIsoDuration sets the "create_entitlement_usage_period_iso_duration" field.
func (m *SubscriptionPatchValueAddItemMutation) SetCreateEntitlementUsagePeriodIsoDuration(s string) {
	m.create_entitlement_usage_period_iso_duration = &s
}

// CreateEntitlementUsagePeriodIsoDuration returns the value of the "create_entitlement_usage_period_iso_duration" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementUsagePeriodIsoDuration() (r string, exists bool) {
	v := m.create_entitlement_usage_period_iso_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateEntitlementUsagePeriodIsoDuration returns the old "create_entitlement_usage_period_iso_duration" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldCreateEntitlementUsagePeriodIsoDuration(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateEntitlementUsagePeriodIsoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateEntitlementUsagePeriodIsoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateEntitlementUsagePeriodIsoDuration: %w", err)
	}
	return oldValue.CreateEntitlementUsagePeriodIsoDuration, nil
}

// ClearCreateEntitlementUsagePeriodIsoDuration clears the value of the "create_entitlement_usage_period_iso_duration" field.
func (m *SubscriptionPatchValueAddItemMutation) ClearCreateEntitlementUsagePeriodIsoDuration() {
	m.create_entitlement_usage_period_iso_duration = nil
	m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration] = struct{}{}
}

// CreateEntitlementUsagePeriodIsoDurationCleared returns if the "create_entitlement_usage_period_iso_duration" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementUsagePeriodIsoDurationCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration]
	return ok
}

// ResetCreateEntitlementUsagePeriodIsoDuration resets all changes to the "create_entitlement_usage_period_iso_duration" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetCreateEntitlementUsagePeriodIsoDuration() {
	m.create_entitlement_usage_period_iso_duration = nil
	delete(m.clearedFields, subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration)
}

// SetCreateEntitlementConfig sets the "create_entitlement_config" field.
func (m *SubscriptionPatchValueAddItemMutation) SetCreateEntitlementConfig(u []uint8) {
	m.create_entitlement_config = &u
	m.appendcreate_entitlement_config = nil
}

// CreateEntitlementConfig returns the value of the "create_entitlement_config" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementConfig() (r []uint8, exists bool) {
	v := m.create_entitlement_config
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateEntitlementConfig returns the old "create_entitlement_config" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldCreateEntitlementConfig(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateEntitlementConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateEntitlementConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateEntitlementConfig: %w", err)
	}
	return oldValue.CreateEntitlementConfig, nil
}

// AppendCreateEntitlementConfig adds u to the "create_entitlement_config" field.
func (m *SubscriptionPatchValueAddItemMutation) AppendCreateEntitlementConfig(u []uint8) {
	m.appendcreate_entitlement_config = append(m.appendcreate_entitlement_config, u...)
}

// AppendedCreateEntitlementConfig returns the list of values that were appended to the "create_entitlement_config" field in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) AppendedCreateEntitlementConfig() ([]uint8, bool) {
	if len(m.appendcreate_entitlement_config) == 0 {
		return nil, false
	}
	return m.appendcreate_entitlement_config, true
}

// ClearCreateEntitlementConfig clears the value of the "create_entitlement_config" field.
func (m *SubscriptionPatchValueAddItemMutation) ClearCreateEntitlementConfig() {
	m.create_entitlement_config = nil
	m.appendcreate_entitlement_config = nil
	m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementConfig] = struct{}{}
}

// CreateEntitlementConfigCleared returns if the "create_entitlement_config" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreateEntitlementConfigCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueadditem.FieldCreateEntitlementConfig]
	return ok
}

// ResetCreateEntitlementConfig resets all changes to the "create_entitlement_config" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetCreateEntitlementConfig() {
	m.create_entitlement_config = nil
	m.appendcreate_entitlement_config = nil
	delete(m.clearedFields, subscriptionpatchvalueadditem.FieldCreateEntitlementConfig)
}

// SetCreatePriceKey sets the "create_price_key" field.
func (m *SubscriptionPatchValueAddItemMutation) SetCreatePriceKey(s string) {
	m.create_price_key = &s
}

// CreatePriceKey returns the value of the "create_price_key" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreatePriceKey() (r string, exists bool) {
	v := m.create_price_key
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatePriceKey returns the old "create_price_key" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldCreatePriceKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatePriceKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatePriceKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatePriceKey: %w", err)
	}
	return oldValue.CreatePriceKey, nil
}

// ClearCreatePriceKey clears the value of the "create_price_key" field.
func (m *SubscriptionPatchValueAddItemMutation) ClearCreatePriceKey() {
	m.create_price_key = nil
	m.clearedFields[subscriptionpatchvalueadditem.FieldCreatePriceKey] = struct{}{}
}

// CreatePriceKeyCleared returns if the "create_price_key" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreatePriceKeyCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueadditem.FieldCreatePriceKey]
	return ok
}

// ResetCreatePriceKey resets all changes to the "create_price_key" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetCreatePriceKey() {
	m.create_price_key = nil
	delete(m.clearedFields, subscriptionpatchvalueadditem.FieldCreatePriceKey)
}

// SetCreatePriceValue sets the "create_price_value" field.
func (m *SubscriptionPatchValueAddItemMutation) SetCreatePriceValue(s string) {
	m.create_price_value = &s
}

// CreatePriceValue returns the value of the "create_price_value" field in the mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreatePriceValue() (r string, exists bool) {
	v := m.create_price_value
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatePriceValue returns the old "create_price_value" field's value of the SubscriptionPatchValueAddItem entity.
// If the SubscriptionPatchValueAddItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddItemMutation) OldCreatePriceValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatePriceValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatePriceValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatePriceValue: %w", err)
	}
	return oldValue.CreatePriceValue, nil
}

// ClearCreatePriceValue clears the value of the "create_price_value" field.
func (m *SubscriptionPatchValueAddItemMutation) ClearCreatePriceValue() {
	m.create_price_value = nil
	m.clearedFields[subscriptionpatchvalueadditem.FieldCreatePriceValue] = struct{}{}
}

// CreatePriceValueCleared returns if the "create_price_value" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) CreatePriceValueCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueadditem.FieldCreatePriceValue]
	return ok
}

// ResetCreatePriceValue resets all changes to the "create_price_value" field.
func (m *SubscriptionPatchValueAddItemMutation) ResetCreatePriceValue() {
	m.create_price_value = nil
	delete(m.clearedFields, subscriptionpatchvalueadditem.FieldCreatePriceValue)
}

// ClearSubscriptionPatch clears the "subscription_patch" edge to the SubscriptionPatch entity.
func (m *SubscriptionPatchValueAddItemMutation) ClearSubscriptionPatch() {
	m.clearedsubscription_patch = true
	m.clearedFields[subscriptionpatchvalueadditem.FieldSubscriptionPatchID] = struct{}{}
}

// SubscriptionPatchCleared reports if the "subscription_patch" edge to the SubscriptionPatch entity was cleared.
func (m *SubscriptionPatchValueAddItemMutation) SubscriptionPatchCleared() bool {
	return m.clearedsubscription_patch
}

// SubscriptionPatchIDs returns the "subscription_patch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionPatchID instead. It exists only for internal usage by the builders.
func (m *SubscriptionPatchValueAddItemMutation) SubscriptionPatchIDs() (ids []string) {
	if id := m.subscription_patch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscriptionPatch resets all changes to the "subscription_patch" edge.
func (m *SubscriptionPatchValueAddItemMutation) ResetSubscriptionPatch() {
	m.subscription_patch = nil
	m.clearedsubscription_patch = false
}

// Where appends a list predicates to the SubscriptionPatchValueAddItemMutation builder.
func (m *SubscriptionPatchValueAddItemMutation) Where(ps ...predicate.SubscriptionPatchValueAddItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionPatchValueAddItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionPatchValueAddItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionPatchValueAddItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionPatchValueAddItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionPatchValueAddItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionPatchValueAddItem).
func (m *SubscriptionPatchValueAddItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionPatchValueAddItemMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.namespace != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldNamespace)
	}
	if m.subscription_patch != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldSubscriptionPatchID)
	}
	if m.phase_key != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldPhaseKey)
	}
	if m.item_key != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldItemKey)
	}
	if m.feature_key != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldFeatureKey)
	}
	if m.create_entitlement_entitlement_type != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType)
	}
	if m.create_entitlement_issue_after_reset != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset)
	}
	if m.create_entitlement_issue_after_reset_priority != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority)
	}
	if m.create_entitlement_is_soft_limit != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit)
	}
	if m.create_entitlement_preserve_overage_at_reset != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset)
	}
	if m.create_entitlement_usage_period_iso_duration != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration)
	}
	if m.create_entitlement_config != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementConfig)
	}
	if m.create_price_key != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreatePriceKey)
	}
	if m.create_price_value != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreatePriceValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionPatchValueAddItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptionpatchvalueadditem.FieldNamespace:
		return m.Namespace()
	case subscriptionpatchvalueadditem.FieldSubscriptionPatchID:
		return m.SubscriptionPatchID()
	case subscriptionpatchvalueadditem.FieldPhaseKey:
		return m.PhaseKey()
	case subscriptionpatchvalueadditem.FieldItemKey:
		return m.ItemKey()
	case subscriptionpatchvalueadditem.FieldFeatureKey:
		return m.FeatureKey()
	case subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType:
		return m.CreateEntitlementEntitlementType()
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset:
		return m.CreateEntitlementIssueAfterReset()
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority:
		return m.CreateEntitlementIssueAfterResetPriority()
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit:
		return m.CreateEntitlementIsSoftLimit()
	case subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset:
		return m.CreateEntitlementPreserveOverageAtReset()
	case subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration:
		return m.CreateEntitlementUsagePeriodIsoDuration()
	case subscriptionpatchvalueadditem.FieldCreateEntitlementConfig:
		return m.CreateEntitlementConfig()
	case subscriptionpatchvalueadditem.FieldCreatePriceKey:
		return m.CreatePriceKey()
	case subscriptionpatchvalueadditem.FieldCreatePriceValue:
		return m.CreatePriceValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionPatchValueAddItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptionpatchvalueadditem.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscriptionpatchvalueadditem.FieldSubscriptionPatchID:
		return m.OldSubscriptionPatchID(ctx)
	case subscriptionpatchvalueadditem.FieldPhaseKey:
		return m.OldPhaseKey(ctx)
	case subscriptionpatchvalueadditem.FieldItemKey:
		return m.OldItemKey(ctx)
	case subscriptionpatchvalueadditem.FieldFeatureKey:
		return m.OldFeatureKey(ctx)
	case subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType:
		return m.OldCreateEntitlementEntitlementType(ctx)
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset:
		return m.OldCreateEntitlementIssueAfterReset(ctx)
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority:
		return m.OldCreateEntitlementIssueAfterResetPriority(ctx)
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit:
		return m.OldCreateEntitlementIsSoftLimit(ctx)
	case subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset:
		return m.OldCreateEntitlementPreserveOverageAtReset(ctx)
	case subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration:
		return m.OldCreateEntitlementUsagePeriodIsoDuration(ctx)
	case subscriptionpatchvalueadditem.FieldCreateEntitlementConfig:
		return m.OldCreateEntitlementConfig(ctx)
	case subscriptionpatchvalueadditem.FieldCreatePriceKey:
		return m.OldCreatePriceKey(ctx)
	case subscriptionpatchvalueadditem.FieldCreatePriceValue:
		return m.OldCreatePriceValue(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionPatchValueAddItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionPatchValueAddItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptionpatchvalueadditem.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscriptionpatchvalueadditem.FieldSubscriptionPatchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionPatchID(v)
		return nil
	case subscriptionpatchvalueadditem.FieldPhaseKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhaseKey(v)
		return nil
	case subscriptionpatchvalueadditem.FieldItemKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemKey(v)
		return nil
	case subscriptionpatchvalueadditem.FieldFeatureKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureKey(v)
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateEntitlementEntitlementType(v)
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateEntitlementIssueAfterReset(v)
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateEntitlementIssueAfterResetPriority(v)
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateEntitlementIsSoftLimit(v)
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateEntitlementPreserveOverageAtReset(v)
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateEntitlementUsagePeriodIsoDuration(v)
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementConfig:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateEntitlementConfig(v)
		return nil
	case subscriptionpatchvalueadditem.FieldCreatePriceKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatePriceKey(v)
		return nil
	case subscriptionpatchvalueadditem.FieldCreatePriceValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatePriceValue(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionPatchValueAddItemMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_entitlement_issue_after_reset != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset)
	}
	if m.addcreate_entitlement_issue_after_reset_priority != nil {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionPatchValueAddItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset:
		return m.AddedCreateEntitlementIssueAfterReset()
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority:
		return m.AddedCreateEntitlementIssueAfterResetPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionPatchValueAddItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateEntitlementIssueAfterReset(v)
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateEntitlementIssueAfterResetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionPatchValueAddItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriptionpatchvalueadditem.FieldFeatureKey) {
		fields = append(fields, subscriptionpatchvalueadditem.FieldFeatureKey)
	}
	if m.FieldCleared(subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType) {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType)
	}
	if m.FieldCleared(subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset) {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset)
	}
	if m.FieldCleared(subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority) {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority)
	}
	if m.FieldCleared(subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit) {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit)
	}
	if m.FieldCleared(subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset) {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset)
	}
	if m.FieldCleared(subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration) {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration)
	}
	if m.FieldCleared(subscriptionpatchvalueadditem.FieldCreateEntitlementConfig) {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreateEntitlementConfig)
	}
	if m.FieldCleared(subscriptionpatchvalueadditem.FieldCreatePriceKey) {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreatePriceKey)
	}
	if m.FieldCleared(subscriptionpatchvalueadditem.FieldCreatePriceValue) {
		fields = append(fields, subscriptionpatchvalueadditem.FieldCreatePriceValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionPatchValueAddItemMutation) ClearField(name string) error {
	switch name {
	case subscriptionpatchvalueadditem.FieldFeatureKey:
		m.ClearFeatureKey()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType:
		m.ClearCreateEntitlementEntitlementType()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset:
		m.ClearCreateEntitlementIssueAfterReset()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority:
		m.ClearCreateEntitlementIssueAfterResetPriority()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit:
		m.ClearCreateEntitlementIsSoftLimit()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset:
		m.ClearCreateEntitlementPreserveOverageAtReset()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration:
		m.ClearCreateEntitlementUsagePeriodIsoDuration()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementConfig:
		m.ClearCreateEntitlementConfig()
		return nil
	case subscriptionpatchvalueadditem.FieldCreatePriceKey:
		m.ClearCreatePriceKey()
		return nil
	case subscriptionpatchvalueadditem.FieldCreatePriceValue:
		m.ClearCreatePriceValue()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionPatchValueAddItemMutation) ResetField(name string) error {
	switch name {
	case subscriptionpatchvalueadditem.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscriptionpatchvalueadditem.FieldSubscriptionPatchID:
		m.ResetSubscriptionPatchID()
		return nil
	case subscriptionpatchvalueadditem.FieldPhaseKey:
		m.ResetPhaseKey()
		return nil
	case subscriptionpatchvalueadditem.FieldItemKey:
		m.ResetItemKey()
		return nil
	case subscriptionpatchvalueadditem.FieldFeatureKey:
		m.ResetFeatureKey()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementEntitlementType:
		m.ResetCreateEntitlementEntitlementType()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterReset:
		m.ResetCreateEntitlementIssueAfterReset()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIssueAfterResetPriority:
		m.ResetCreateEntitlementIssueAfterResetPriority()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementIsSoftLimit:
		m.ResetCreateEntitlementIsSoftLimit()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementPreserveOverageAtReset:
		m.ResetCreateEntitlementPreserveOverageAtReset()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementUsagePeriodIsoDuration:
		m.ResetCreateEntitlementUsagePeriodIsoDuration()
		return nil
	case subscriptionpatchvalueadditem.FieldCreateEntitlementConfig:
		m.ResetCreateEntitlementConfig()
		return nil
	case subscriptionpatchvalueadditem.FieldCreatePriceKey:
		m.ResetCreatePriceKey()
		return nil
	case subscriptionpatchvalueadditem.FieldCreatePriceValue:
		m.ResetCreatePriceValue()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subscription_patch != nil {
		edges = append(edges, subscriptionpatchvalueadditem.EdgeSubscriptionPatch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptionpatchvalueadditem.EdgeSubscriptionPatch:
		if id := m.subscription_patch; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubscription_patch {
		edges = append(edges, subscriptionpatchvalueadditem.EdgeSubscriptionPatch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionPatchValueAddItemMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptionpatchvalueadditem.EdgeSubscriptionPatch:
		return m.clearedsubscription_patch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionPatchValueAddItemMutation) ClearEdge(name string) error {
	switch name {
	case subscriptionpatchvalueadditem.EdgeSubscriptionPatch:
		m.ClearSubscriptionPatch()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionPatchValueAddItemMutation) ResetEdge(name string) error {
	switch name {
	case subscriptionpatchvalueadditem.EdgeSubscriptionPatch:
		m.ResetSubscriptionPatch()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddItem edge %s", name)
}

// SubscriptionPatchValueAddPhaseMutation represents an operation that mutates the SubscriptionPatchValueAddPhase nodes in the graph.
type SubscriptionPatchValueAddPhaseMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	namespace                        *string
	phase_key                        *string
	start_after_iso                  *string
	create_discount                  *bool
	create_discount_applies_to       *[]string
	appendcreate_discount_applies_to []string
	clearedFields                    map[string]struct{}
	subscription_patch               *string
	clearedsubscription_patch        bool
	done                             bool
	oldValue                         func(context.Context) (*SubscriptionPatchValueAddPhase, error)
	predicates                       []predicate.SubscriptionPatchValueAddPhase
}

var _ ent.Mutation = (*SubscriptionPatchValueAddPhaseMutation)(nil)

// subscriptionpatchvalueaddphaseOption allows management of the mutation configuration using functional options.
type subscriptionpatchvalueaddphaseOption func(*SubscriptionPatchValueAddPhaseMutation)

// newSubscriptionPatchValueAddPhaseMutation creates new mutation for the SubscriptionPatchValueAddPhase entity.
func newSubscriptionPatchValueAddPhaseMutation(c config, op Op, opts ...subscriptionpatchvalueaddphaseOption) *SubscriptionPatchValueAddPhaseMutation {
	m := &SubscriptionPatchValueAddPhaseMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionPatchValueAddPhase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionPatchValueAddPhaseID sets the ID field of the mutation.
func withSubscriptionPatchValueAddPhaseID(id string) subscriptionpatchvalueaddphaseOption {
	return func(m *SubscriptionPatchValueAddPhaseMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionPatchValueAddPhase
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionPatchValueAddPhase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionPatchValueAddPhase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionPatchValueAddPhase sets the old SubscriptionPatchValueAddPhase of the mutation.
func withSubscriptionPatchValueAddPhase(node *SubscriptionPatchValueAddPhase) subscriptionpatchvalueaddphaseOption {
	return func(m *SubscriptionPatchValueAddPhaseMutation) {
		m.oldValue = func(context.Context) (*SubscriptionPatchValueAddPhase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionPatchValueAddPhaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionPatchValueAddPhaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionPatchValueAddPhase entities.
func (m *SubscriptionPatchValueAddPhaseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionPatchValueAddPhaseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionPatchValueAddPhase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionPatchValueAddPhaseMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SubscriptionPatchValueAddPhase entity.
// If the SubscriptionPatchValueAddPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddPhaseMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionPatchValueAddPhaseMutation) ResetNamespace() {
	m.namespace = nil
}

// SetSubscriptionPatchID sets the "subscription_patch_id" field.
func (m *SubscriptionPatchValueAddPhaseMutation) SetSubscriptionPatchID(s string) {
	m.subscription_patch = &s
}

// SubscriptionPatchID returns the value of the "subscription_patch_id" field in the mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) SubscriptionPatchID() (r string, exists bool) {
	v := m.subscription_patch
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionPatchID returns the old "subscription_patch_id" field's value of the SubscriptionPatchValueAddPhase entity.
// If the SubscriptionPatchValueAddPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddPhaseMutation) OldSubscriptionPatchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionPatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionPatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionPatchID: %w", err)
	}
	return oldValue.SubscriptionPatchID, nil
}

// ResetSubscriptionPatchID resets all changes to the "subscription_patch_id" field.
func (m *SubscriptionPatchValueAddPhaseMutation) ResetSubscriptionPatchID() {
	m.subscription_patch = nil
}

// SetPhaseKey sets the "phase_key" field.
func (m *SubscriptionPatchValueAddPhaseMutation) SetPhaseKey(s string) {
	m.phase_key = &s
}

// PhaseKey returns the value of the "phase_key" field in the mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) PhaseKey() (r string, exists bool) {
	v := m.phase_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPhaseKey returns the old "phase_key" field's value of the SubscriptionPatchValueAddPhase entity.
// If the SubscriptionPatchValueAddPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddPhaseMutation) OldPhaseKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhaseKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhaseKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhaseKey: %w", err)
	}
	return oldValue.PhaseKey, nil
}

// ResetPhaseKey resets all changes to the "phase_key" field.
func (m *SubscriptionPatchValueAddPhaseMutation) ResetPhaseKey() {
	m.phase_key = nil
}

// SetStartAfterIso sets the "start_after_iso" field.
func (m *SubscriptionPatchValueAddPhaseMutation) SetStartAfterIso(s string) {
	m.start_after_iso = &s
}

// StartAfterIso returns the value of the "start_after_iso" field in the mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) StartAfterIso() (r string, exists bool) {
	v := m.start_after_iso
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAfterIso returns the old "start_after_iso" field's value of the SubscriptionPatchValueAddPhase entity.
// If the SubscriptionPatchValueAddPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddPhaseMutation) OldStartAfterIso(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAfterIso is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAfterIso requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAfterIso: %w", err)
	}
	return oldValue.StartAfterIso, nil
}

// ResetStartAfterIso resets all changes to the "start_after_iso" field.
func (m *SubscriptionPatchValueAddPhaseMutation) ResetStartAfterIso() {
	m.start_after_iso = nil
}

// SetCreateDiscount sets the "create_discount" field.
func (m *SubscriptionPatchValueAddPhaseMutation) SetCreateDiscount(b bool) {
	m.create_discount = &b
}

// CreateDiscount returns the value of the "create_discount" field in the mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) CreateDiscount() (r bool, exists bool) {
	v := m.create_discount
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateDiscount returns the old "create_discount" field's value of the SubscriptionPatchValueAddPhase entity.
// If the SubscriptionPatchValueAddPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddPhaseMutation) OldCreateDiscount(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateDiscount: %w", err)
	}
	return oldValue.CreateDiscount, nil
}

// ResetCreateDiscount resets all changes to the "create_discount" field.
func (m *SubscriptionPatchValueAddPhaseMutation) ResetCreateDiscount() {
	m.create_discount = nil
}

// SetCreateDiscountAppliesTo sets the "create_discount_applies_to" field.
func (m *SubscriptionPatchValueAddPhaseMutation) SetCreateDiscountAppliesTo(s []string) {
	m.create_discount_applies_to = &s
	m.appendcreate_discount_applies_to = nil
}

// CreateDiscountAppliesTo returns the value of the "create_discount_applies_to" field in the mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) CreateDiscountAppliesTo() (r []string, exists bool) {
	v := m.create_discount_applies_to
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateDiscountAppliesTo returns the old "create_discount_applies_to" field's value of the SubscriptionPatchValueAddPhase entity.
// If the SubscriptionPatchValueAddPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueAddPhaseMutation) OldCreateDiscountAppliesTo(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateDiscountAppliesTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateDiscountAppliesTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateDiscountAppliesTo: %w", err)
	}
	return oldValue.CreateDiscountAppliesTo, nil
}

// AppendCreateDiscountAppliesTo adds s to the "create_discount_applies_to" field.
func (m *SubscriptionPatchValueAddPhaseMutation) AppendCreateDiscountAppliesTo(s []string) {
	m.appendcreate_discount_applies_to = append(m.appendcreate_discount_applies_to, s...)
}

// AppendedCreateDiscountAppliesTo returns the list of values that were appended to the "create_discount_applies_to" field in this mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) AppendedCreateDiscountAppliesTo() ([]string, bool) {
	if len(m.appendcreate_discount_applies_to) == 0 {
		return nil, false
	}
	return m.appendcreate_discount_applies_to, true
}

// ClearCreateDiscountAppliesTo clears the value of the "create_discount_applies_to" field.
func (m *SubscriptionPatchValueAddPhaseMutation) ClearCreateDiscountAppliesTo() {
	m.create_discount_applies_to = nil
	m.appendcreate_discount_applies_to = nil
	m.clearedFields[subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo] = struct{}{}
}

// CreateDiscountAppliesToCleared returns if the "create_discount_applies_to" field was cleared in this mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) CreateDiscountAppliesToCleared() bool {
	_, ok := m.clearedFields[subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo]
	return ok
}

// ResetCreateDiscountAppliesTo resets all changes to the "create_discount_applies_to" field.
func (m *SubscriptionPatchValueAddPhaseMutation) ResetCreateDiscountAppliesTo() {
	m.create_discount_applies_to = nil
	m.appendcreate_discount_applies_to = nil
	delete(m.clearedFields, subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo)
}

// ClearSubscriptionPatch clears the "subscription_patch" edge to the SubscriptionPatch entity.
func (m *SubscriptionPatchValueAddPhaseMutation) ClearSubscriptionPatch() {
	m.clearedsubscription_patch = true
	m.clearedFields[subscriptionpatchvalueaddphase.FieldSubscriptionPatchID] = struct{}{}
}

// SubscriptionPatchCleared reports if the "subscription_patch" edge to the SubscriptionPatch entity was cleared.
func (m *SubscriptionPatchValueAddPhaseMutation) SubscriptionPatchCleared() bool {
	return m.clearedsubscription_patch
}

// SubscriptionPatchIDs returns the "subscription_patch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionPatchID instead. It exists only for internal usage by the builders.
func (m *SubscriptionPatchValueAddPhaseMutation) SubscriptionPatchIDs() (ids []string) {
	if id := m.subscription_patch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscriptionPatch resets all changes to the "subscription_patch" edge.
func (m *SubscriptionPatchValueAddPhaseMutation) ResetSubscriptionPatch() {
	m.subscription_patch = nil
	m.clearedsubscription_patch = false
}

// Where appends a list predicates to the SubscriptionPatchValueAddPhaseMutation builder.
func (m *SubscriptionPatchValueAddPhaseMutation) Where(ps ...predicate.SubscriptionPatchValueAddPhase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionPatchValueAddPhaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionPatchValueAddPhaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionPatchValueAddPhase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionPatchValueAddPhaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionPatchValueAddPhaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionPatchValueAddPhase).
func (m *SubscriptionPatchValueAddPhaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionPatchValueAddPhaseMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.namespace != nil {
		fields = append(fields, subscriptionpatchvalueaddphase.FieldNamespace)
	}
	if m.subscription_patch != nil {
		fields = append(fields, subscriptionpatchvalueaddphase.FieldSubscriptionPatchID)
	}
	if m.phase_key != nil {
		fields = append(fields, subscriptionpatchvalueaddphase.FieldPhaseKey)
	}
	if m.start_after_iso != nil {
		fields = append(fields, subscriptionpatchvalueaddphase.FieldStartAfterIso)
	}
	if m.create_discount != nil {
		fields = append(fields, subscriptionpatchvalueaddphase.FieldCreateDiscount)
	}
	if m.create_discount_applies_to != nil {
		fields = append(fields, subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionPatchValueAddPhaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptionpatchvalueaddphase.FieldNamespace:
		return m.Namespace()
	case subscriptionpatchvalueaddphase.FieldSubscriptionPatchID:
		return m.SubscriptionPatchID()
	case subscriptionpatchvalueaddphase.FieldPhaseKey:
		return m.PhaseKey()
	case subscriptionpatchvalueaddphase.FieldStartAfterIso:
		return m.StartAfterIso()
	case subscriptionpatchvalueaddphase.FieldCreateDiscount:
		return m.CreateDiscount()
	case subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo:
		return m.CreateDiscountAppliesTo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionPatchValueAddPhaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptionpatchvalueaddphase.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscriptionpatchvalueaddphase.FieldSubscriptionPatchID:
		return m.OldSubscriptionPatchID(ctx)
	case subscriptionpatchvalueaddphase.FieldPhaseKey:
		return m.OldPhaseKey(ctx)
	case subscriptionpatchvalueaddphase.FieldStartAfterIso:
		return m.OldStartAfterIso(ctx)
	case subscriptionpatchvalueaddphase.FieldCreateDiscount:
		return m.OldCreateDiscount(ctx)
	case subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo:
		return m.OldCreateDiscountAppliesTo(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionPatchValueAddPhase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionPatchValueAddPhaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptionpatchvalueaddphase.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscriptionpatchvalueaddphase.FieldSubscriptionPatchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionPatchID(v)
		return nil
	case subscriptionpatchvalueaddphase.FieldPhaseKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhaseKey(v)
		return nil
	case subscriptionpatchvalueaddphase.FieldStartAfterIso:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAfterIso(v)
		return nil
	case subscriptionpatchvalueaddphase.FieldCreateDiscount:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateDiscount(v)
		return nil
	case subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateDiscountAppliesTo(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddPhase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionPatchValueAddPhaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionPatchValueAddPhaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddPhase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo) {
		fields = append(fields, subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionPatchValueAddPhaseMutation) ClearField(name string) error {
	switch name {
	case subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo:
		m.ClearCreateDiscountAppliesTo()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddPhase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionPatchValueAddPhaseMutation) ResetField(name string) error {
	switch name {
	case subscriptionpatchvalueaddphase.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscriptionpatchvalueaddphase.FieldSubscriptionPatchID:
		m.ResetSubscriptionPatchID()
		return nil
	case subscriptionpatchvalueaddphase.FieldPhaseKey:
		m.ResetPhaseKey()
		return nil
	case subscriptionpatchvalueaddphase.FieldStartAfterIso:
		m.ResetStartAfterIso()
		return nil
	case subscriptionpatchvalueaddphase.FieldCreateDiscount:
		m.ResetCreateDiscount()
		return nil
	case subscriptionpatchvalueaddphase.FieldCreateDiscountAppliesTo:
		m.ResetCreateDiscountAppliesTo()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddPhase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subscription_patch != nil {
		edges = append(edges, subscriptionpatchvalueaddphase.EdgeSubscriptionPatch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptionpatchvalueaddphase.EdgeSubscriptionPatch:
		if id := m.subscription_patch; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubscription_patch {
		edges = append(edges, subscriptionpatchvalueaddphase.EdgeSubscriptionPatch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionPatchValueAddPhaseMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptionpatchvalueaddphase.EdgeSubscriptionPatch:
		return m.clearedsubscription_patch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionPatchValueAddPhaseMutation) ClearEdge(name string) error {
	switch name {
	case subscriptionpatchvalueaddphase.EdgeSubscriptionPatch:
		m.ClearSubscriptionPatch()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddPhase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionPatchValueAddPhaseMutation) ResetEdge(name string) error {
	switch name {
	case subscriptionpatchvalueaddphase.EdgeSubscriptionPatch:
		m.ResetSubscriptionPatch()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueAddPhase edge %s", name)
}

// SubscriptionPatchValueExtendPhaseMutation represents an operation that mutates the SubscriptionPatchValueExtendPhase nodes in the graph.
type SubscriptionPatchValueExtendPhaseMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	namespace                 *string
	phase_key                 *string
	extend_duration_iso       *string
	clearedFields             map[string]struct{}
	subscription_patch        *string
	clearedsubscription_patch bool
	done                      bool
	oldValue                  func(context.Context) (*SubscriptionPatchValueExtendPhase, error)
	predicates                []predicate.SubscriptionPatchValueExtendPhase
}

var _ ent.Mutation = (*SubscriptionPatchValueExtendPhaseMutation)(nil)

// subscriptionpatchvalueextendphaseOption allows management of the mutation configuration using functional options.
type subscriptionpatchvalueextendphaseOption func(*SubscriptionPatchValueExtendPhaseMutation)

// newSubscriptionPatchValueExtendPhaseMutation creates new mutation for the SubscriptionPatchValueExtendPhase entity.
func newSubscriptionPatchValueExtendPhaseMutation(c config, op Op, opts ...subscriptionpatchvalueextendphaseOption) *SubscriptionPatchValueExtendPhaseMutation {
	m := &SubscriptionPatchValueExtendPhaseMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionPatchValueExtendPhase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionPatchValueExtendPhaseID sets the ID field of the mutation.
func withSubscriptionPatchValueExtendPhaseID(id string) subscriptionpatchvalueextendphaseOption {
	return func(m *SubscriptionPatchValueExtendPhaseMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionPatchValueExtendPhase
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionPatchValueExtendPhase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionPatchValueExtendPhase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionPatchValueExtendPhase sets the old SubscriptionPatchValueExtendPhase of the mutation.
func withSubscriptionPatchValueExtendPhase(node *SubscriptionPatchValueExtendPhase) subscriptionpatchvalueextendphaseOption {
	return func(m *SubscriptionPatchValueExtendPhaseMutation) {
		m.oldValue = func(context.Context) (*SubscriptionPatchValueExtendPhase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionPatchValueExtendPhaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionPatchValueExtendPhaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionPatchValueExtendPhase entities.
func (m *SubscriptionPatchValueExtendPhaseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionPatchValueExtendPhaseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionPatchValueExtendPhase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionPatchValueExtendPhaseMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SubscriptionPatchValueExtendPhase entity.
// If the SubscriptionPatchValueExtendPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueExtendPhaseMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionPatchValueExtendPhaseMutation) ResetNamespace() {
	m.namespace = nil
}

// SetSubscriptionPatchID sets the "subscription_patch_id" field.
func (m *SubscriptionPatchValueExtendPhaseMutation) SetSubscriptionPatchID(s string) {
	m.subscription_patch = &s
}

// SubscriptionPatchID returns the value of the "subscription_patch_id" field in the mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) SubscriptionPatchID() (r string, exists bool) {
	v := m.subscription_patch
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionPatchID returns the old "subscription_patch_id" field's value of the SubscriptionPatchValueExtendPhase entity.
// If the SubscriptionPatchValueExtendPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueExtendPhaseMutation) OldSubscriptionPatchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionPatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionPatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionPatchID: %w", err)
	}
	return oldValue.SubscriptionPatchID, nil
}

// ResetSubscriptionPatchID resets all changes to the "subscription_patch_id" field.
func (m *SubscriptionPatchValueExtendPhaseMutation) ResetSubscriptionPatchID() {
	m.subscription_patch = nil
}

// SetPhaseKey sets the "phase_key" field.
func (m *SubscriptionPatchValueExtendPhaseMutation) SetPhaseKey(s string) {
	m.phase_key = &s
}

// PhaseKey returns the value of the "phase_key" field in the mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) PhaseKey() (r string, exists bool) {
	v := m.phase_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPhaseKey returns the old "phase_key" field's value of the SubscriptionPatchValueExtendPhase entity.
// If the SubscriptionPatchValueExtendPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueExtendPhaseMutation) OldPhaseKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhaseKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhaseKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhaseKey: %w", err)
	}
	return oldValue.PhaseKey, nil
}

// ResetPhaseKey resets all changes to the "phase_key" field.
func (m *SubscriptionPatchValueExtendPhaseMutation) ResetPhaseKey() {
	m.phase_key = nil
}

// SetExtendDurationIso sets the "extend_duration_iso" field.
func (m *SubscriptionPatchValueExtendPhaseMutation) SetExtendDurationIso(s string) {
	m.extend_duration_iso = &s
}

// ExtendDurationIso returns the value of the "extend_duration_iso" field in the mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) ExtendDurationIso() (r string, exists bool) {
	v := m.extend_duration_iso
	if v == nil {
		return
	}
	return *v, true
}

// OldExtendDurationIso returns the old "extend_duration_iso" field's value of the SubscriptionPatchValueExtendPhase entity.
// If the SubscriptionPatchValueExtendPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPatchValueExtendPhaseMutation) OldExtendDurationIso(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtendDurationIso is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtendDurationIso requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtendDurationIso: %w", err)
	}
	return oldValue.ExtendDurationIso, nil
}

// ResetExtendDurationIso resets all changes to the "extend_duration_iso" field.
func (m *SubscriptionPatchValueExtendPhaseMutation) ResetExtendDurationIso() {
	m.extend_duration_iso = nil
}

// ClearSubscriptionPatch clears the "subscription_patch" edge to the SubscriptionPatch entity.
func (m *SubscriptionPatchValueExtendPhaseMutation) ClearSubscriptionPatch() {
	m.clearedsubscription_patch = true
	m.clearedFields[subscriptionpatchvalueextendphase.FieldSubscriptionPatchID] = struct{}{}
}

// SubscriptionPatchCleared reports if the "subscription_patch" edge to the SubscriptionPatch entity was cleared.
func (m *SubscriptionPatchValueExtendPhaseMutation) SubscriptionPatchCleared() bool {
	return m.clearedsubscription_patch
}

// SubscriptionPatchIDs returns the "subscription_patch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionPatchID instead. It exists only for internal usage by the builders.
func (m *SubscriptionPatchValueExtendPhaseMutation) SubscriptionPatchIDs() (ids []string) {
	if id := m.subscription_patch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscriptionPatch resets all changes to the "subscription_patch" edge.
func (m *SubscriptionPatchValueExtendPhaseMutation) ResetSubscriptionPatch() {
	m.subscription_patch = nil
	m.clearedsubscription_patch = false
}

// Where appends a list predicates to the SubscriptionPatchValueExtendPhaseMutation builder.
func (m *SubscriptionPatchValueExtendPhaseMutation) Where(ps ...predicate.SubscriptionPatchValueExtendPhase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionPatchValueExtendPhaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionPatchValueExtendPhaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionPatchValueExtendPhase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionPatchValueExtendPhaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionPatchValueExtendPhaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionPatchValueExtendPhase).
func (m *SubscriptionPatchValueExtendPhaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionPatchValueExtendPhaseMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.namespace != nil {
		fields = append(fields, subscriptionpatchvalueextendphase.FieldNamespace)
	}
	if m.subscription_patch != nil {
		fields = append(fields, subscriptionpatchvalueextendphase.FieldSubscriptionPatchID)
	}
	if m.phase_key != nil {
		fields = append(fields, subscriptionpatchvalueextendphase.FieldPhaseKey)
	}
	if m.extend_duration_iso != nil {
		fields = append(fields, subscriptionpatchvalueextendphase.FieldExtendDurationIso)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionPatchValueExtendPhaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptionpatchvalueextendphase.FieldNamespace:
		return m.Namespace()
	case subscriptionpatchvalueextendphase.FieldSubscriptionPatchID:
		return m.SubscriptionPatchID()
	case subscriptionpatchvalueextendphase.FieldPhaseKey:
		return m.PhaseKey()
	case subscriptionpatchvalueextendphase.FieldExtendDurationIso:
		return m.ExtendDurationIso()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionPatchValueExtendPhaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptionpatchvalueextendphase.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscriptionpatchvalueextendphase.FieldSubscriptionPatchID:
		return m.OldSubscriptionPatchID(ctx)
	case subscriptionpatchvalueextendphase.FieldPhaseKey:
		return m.OldPhaseKey(ctx)
	case subscriptionpatchvalueextendphase.FieldExtendDurationIso:
		return m.OldExtendDurationIso(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionPatchValueExtendPhase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionPatchValueExtendPhaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptionpatchvalueextendphase.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscriptionpatchvalueextendphase.FieldSubscriptionPatchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionPatchID(v)
		return nil
	case subscriptionpatchvalueextendphase.FieldPhaseKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhaseKey(v)
		return nil
	case subscriptionpatchvalueextendphase.FieldExtendDurationIso:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtendDurationIso(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueExtendPhase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionPatchValueExtendPhaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionPatchValueExtendPhaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubscriptionPatchValueExtendPhase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionPatchValueExtendPhaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubscriptionPatchValueExtendPhase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionPatchValueExtendPhaseMutation) ResetField(name string) error {
	switch name {
	case subscriptionpatchvalueextendphase.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscriptionpatchvalueextendphase.FieldSubscriptionPatchID:
		m.ResetSubscriptionPatchID()
		return nil
	case subscriptionpatchvalueextendphase.FieldPhaseKey:
		m.ResetPhaseKey()
		return nil
	case subscriptionpatchvalueextendphase.FieldExtendDurationIso:
		m.ResetExtendDurationIso()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueExtendPhase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subscription_patch != nil {
		edges = append(edges, subscriptionpatchvalueextendphase.EdgeSubscriptionPatch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptionpatchvalueextendphase.EdgeSubscriptionPatch:
		if id := m.subscription_patch; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubscription_patch {
		edges = append(edges, subscriptionpatchvalueextendphase.EdgeSubscriptionPatch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionPatchValueExtendPhaseMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptionpatchvalueextendphase.EdgeSubscriptionPatch:
		return m.clearedsubscription_patch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionPatchValueExtendPhaseMutation) ClearEdge(name string) error {
	switch name {
	case subscriptionpatchvalueextendphase.EdgeSubscriptionPatch:
		m.ClearSubscriptionPatch()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueExtendPhase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionPatchValueExtendPhaseMutation) ResetEdge(name string) error {
	switch name {
	case subscriptionpatchvalueextendphase.EdgeSubscriptionPatch:
		m.ResetSubscriptionPatch()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPatchValueExtendPhase edge %s", name)
}

// UsageResetMutation represents an operation that mutates the UsageReset nodes in the graph.
type UsageResetMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	namespace          *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	reset_time         *time.Time
	clearedFields      map[string]struct{}
	entitlement        *string
	clearedentitlement bool
	done               bool
	oldValue           func(context.Context) (*UsageReset, error)
	predicates         []predicate.UsageReset
}

var _ ent.Mutation = (*UsageResetMutation)(nil)

// usageresetOption allows management of the mutation configuration using functional options.
type usageresetOption func(*UsageResetMutation)

// newUsageResetMutation creates new mutation for the UsageReset entity.
func newUsageResetMutation(c config, op Op, opts ...usageresetOption) *UsageResetMutation {
	m := &UsageResetMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageReset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageResetID sets the ID field of the mutation.
func withUsageResetID(id string) usageresetOption {
	return func(m *UsageResetMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageReset
		)
		m.oldValue = func(ctx context.Context) (*UsageReset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageReset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageReset sets the old UsageReset of the mutation.
func withUsageReset(node *UsageReset) usageresetOption {
	return func(m *UsageResetMutation) {
		m.oldValue = func(context.Context) (*UsageReset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageResetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageResetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UsageReset entities.
func (m *UsageResetMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageResetMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageResetMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageReset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *UsageResetMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *UsageResetMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *UsageResetMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageResetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageResetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageResetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageResetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageResetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageResetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UsageResetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UsageResetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UsageResetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usagereset.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UsageResetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usagereset.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UsageResetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usagereset.FieldDeletedAt)
}

// SetEntitlementID sets the "entitlement_id" field.
func (m *UsageResetMutation) SetEntitlementID(s string) {
	m.entitlement = &s
}

// EntitlementID returns the value of the "entitlement_id" field in the mutation.
func (m *UsageResetMutation) EntitlementID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementID returns the old "entitlement_id" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldEntitlementID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementID: %w", err)
	}
	return oldValue.EntitlementID, nil
}

// ResetEntitlementID resets all changes to the "entitlement_id" field.
func (m *UsageResetMutation) ResetEntitlementID() {
	m.entitlement = nil
}

// SetResetTime sets the "reset_time" field.
func (m *UsageResetMutation) SetResetTime(t time.Time) {
	m.reset_time = &t
}

// ResetTime returns the value of the "reset_time" field in the mutation.
func (m *UsageResetMutation) ResetTime() (r time.Time, exists bool) {
	v := m.reset_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResetTime returns the old "reset_time" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldResetTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetTime: %w", err)
	}
	return oldValue.ResetTime, nil
}

// ResetResetTime resets all changes to the "reset_time" field.
func (m *UsageResetMutation) ResetResetTime() {
	m.reset_time = nil
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *UsageResetMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[usagereset.FieldEntitlementID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *UsageResetMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *UsageResetMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *UsageResetMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the UsageResetMutation builder.
func (m *UsageResetMutation) Where(ps ...predicate.UsageReset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageResetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageResetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageReset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageResetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageResetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageReset).
func (m *UsageResetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageResetMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.namespace != nil {
		fields = append(fields, usagereset.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, usagereset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usagereset.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usagereset.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, usagereset.FieldEntitlementID)
	}
	if m.reset_time != nil {
		fields = append(fields, usagereset.FieldResetTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageResetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagereset.FieldNamespace:
		return m.Namespace()
	case usagereset.FieldCreatedAt:
		return m.CreatedAt()
	case usagereset.FieldUpdatedAt:
		return m.UpdatedAt()
	case usagereset.FieldDeletedAt:
		return m.DeletedAt()
	case usagereset.FieldEntitlementID:
		return m.EntitlementID()
	case usagereset.FieldResetTime:
		return m.ResetTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageResetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagereset.FieldNamespace:
		return m.OldNamespace(ctx)
	case usagereset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagereset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usagereset.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usagereset.FieldEntitlementID:
		return m.OldEntitlementID(ctx)
	case usagereset.FieldResetTime:
		return m.OldResetTime(ctx)
	}
	return nil, fmt.Errorf("unknown UsageReset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageResetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagereset.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case usagereset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagereset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usagereset.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usagereset.FieldEntitlementID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementID(v)
		return nil
	case usagereset.FieldResetTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetTime(v)
		return nil
	}
	return fmt.Errorf("unknown UsageReset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageResetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageResetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageResetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UsageReset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageResetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagereset.FieldDeletedAt) {
		fields = append(fields, usagereset.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageResetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageResetMutation) ClearField(name string) error {
	switch name {
	case usagereset.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageReset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageResetMutation) ResetField(name string) error {
	switch name {
	case usagereset.FieldNamespace:
		m.ResetNamespace()
		return nil
	case usagereset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagereset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usagereset.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usagereset.FieldEntitlementID:
		m.ResetEntitlementID()
		return nil
	case usagereset.FieldResetTime:
		m.ResetResetTime()
		return nil
	}
	return fmt.Errorf("unknown UsageReset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageResetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, usagereset.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageResetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagereset.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageResetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageResetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageResetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, usagereset.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageResetMutation) EdgeCleared(name string) bool {
	switch name {
	case usagereset.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageResetMutation) ClearEdge(name string) error {
	switch name {
	case usagereset.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown UsageReset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageResetMutation) ResetEdge(name string) error {
	switch name {
	case usagereset.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown UsageReset edge %s", name)
}
