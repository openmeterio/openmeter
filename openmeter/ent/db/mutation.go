// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/alpacahq/alpacadecimal"
	"github.com/openmeterio/openmeter/openmeter/app"
	"github.com/openmeterio/openmeter/openmeter/billing"
	"github.com/openmeterio/openmeter/openmeter/billing/provider"
	"github.com/openmeterio/openmeter/openmeter/credit/balance"
	"github.com/openmeterio/openmeter/openmeter/credit/grant"
	dbapp "github.com/openmeterio/openmeter/openmeter/ent/db/app"
	"github.com/openmeterio/openmeter/openmeter/ent/db/balancesnapshot"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingcustomeroverride"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoice"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoiceitem"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingprofile"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingworkflowconfig"
	"github.com/openmeterio/openmeter/openmeter/ent/db/customer"
	"github.com/openmeterio/openmeter/openmeter/ent/db/customersubjects"
	"github.com/openmeterio/openmeter/openmeter/ent/db/entitlement"
	"github.com/openmeterio/openmeter/openmeter/ent/db/feature"
	dbgrant "github.com/openmeterio/openmeter/openmeter/ent/db/grant"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationchannel"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationevent"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationeventdeliverystatus"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationrule"
	"github.com/openmeterio/openmeter/openmeter/ent/db/predicate"
	"github.com/openmeterio/openmeter/openmeter/ent/db/usagereset"
	"github.com/openmeterio/openmeter/openmeter/notification"
	"github.com/openmeterio/openmeter/pkg/currencyx"
	"github.com/openmeterio/openmeter/pkg/models"
	"github.com/openmeterio/openmeter/pkg/recurrence"
	"github.com/openmeterio/openmeter/pkg/timezone"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp                             = "App"
	TypeBalanceSnapshot                 = "BalanceSnapshot"
	TypeBillingCustomerOverride         = "BillingCustomerOverride"
	TypeBillingInvoice                  = "BillingInvoice"
	TypeBillingInvoiceItem              = "BillingInvoiceItem"
	TypeBillingProfile                  = "BillingProfile"
	TypeBillingWorkflowConfig           = "BillingWorkflowConfig"
	TypeCustomer                        = "Customer"
	TypeCustomerSubjects                = "CustomerSubjects"
	TypeEntitlement                     = "Entitlement"
	TypeFeature                         = "Feature"
	TypeGrant                           = "Grant"
	TypeNotificationChannel             = "NotificationChannel"
	TypeNotificationEvent               = "NotificationEvent"
	TypeNotificationEventDeliveryStatus = "NotificationEventDeliveryStatus"
	TypeNotificationRule                = "NotificationRule"
	TypeUsageReset                      = "UsageReset"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	metadata      *map[string]string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	description   *string
	_type         *app.AppType
	status        *app.AppStatus
	listing_key   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*App, error)
	predicates    []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id string) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *AppMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AppMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AppMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[dbapp.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AppMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[dbapp.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AppMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, dbapp.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dbapp.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dbapp.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dbapp.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
}

// SetType sets the "type" field.
func (m *AppMutation) SetType(at app.AppType) {
	m._type = &at
}

// GetType returns the value of the "type" field in the mutation.
func (m *AppMutation) GetType() (r app.AppType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldType(ctx context.Context) (v app.AppType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AppMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *AppMutation) SetStatus(as app.AppStatus) {
	m.status = &as
}

// Status returns the value of the "status" field in the mutation.
func (m *AppMutation) Status() (r app.AppStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStatus(ctx context.Context) (v app.AppStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AppMutation) ResetStatus() {
	m.status = nil
}

// SetListingKey sets the "listing_key" field.
func (m *AppMutation) SetListingKey(s string) {
	m.listing_key = &s
}

// ListingKey returns the value of the "listing_key" field in the mutation.
func (m *AppMutation) ListingKey() (r string, exists bool) {
	v := m.listing_key
	if v == nil {
		return
	}
	return *v, true
}

// OldListingKey returns the old "listing_key" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldListingKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListingKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListingKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListingKey: %w", err)
	}
	return oldValue.ListingKey, nil
}

// ResetListingKey resets all changes to the "listing_key" field.
func (m *AppMutation) ResetListingKey() {
	m.listing_key = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, dbapp.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, dbapp.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, dbapp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dbapp.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dbapp.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, dbapp.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dbapp.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, dbapp.FieldType)
	}
	if m.status != nil {
		fields = append(fields, dbapp.FieldStatus)
	}
	if m.listing_key != nil {
		fields = append(fields, dbapp.FieldListingKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbapp.FieldNamespace:
		return m.Namespace()
	case dbapp.FieldMetadata:
		return m.Metadata()
	case dbapp.FieldCreatedAt:
		return m.CreatedAt()
	case dbapp.FieldUpdatedAt:
		return m.UpdatedAt()
	case dbapp.FieldDeletedAt:
		return m.DeletedAt()
	case dbapp.FieldName:
		return m.Name()
	case dbapp.FieldDescription:
		return m.Description()
	case dbapp.FieldType:
		return m.GetType()
	case dbapp.FieldStatus:
		return m.Status()
	case dbapp.FieldListingKey:
		return m.ListingKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbapp.FieldNamespace:
		return m.OldNamespace(ctx)
	case dbapp.FieldMetadata:
		return m.OldMetadata(ctx)
	case dbapp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dbapp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dbapp.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dbapp.FieldName:
		return m.OldName(ctx)
	case dbapp.FieldDescription:
		return m.OldDescription(ctx)
	case dbapp.FieldType:
		return m.OldType(ctx)
	case dbapp.FieldStatus:
		return m.OldStatus(ctx)
	case dbapp.FieldListingKey:
		return m.OldListingKey(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbapp.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case dbapp.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case dbapp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dbapp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dbapp.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dbapp.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbapp.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dbapp.FieldType:
		v, ok := value.(app.AppType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dbapp.FieldStatus:
		v, ok := value.(app.AppStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dbapp.FieldListingKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListingKey(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbapp.FieldMetadata) {
		fields = append(fields, dbapp.FieldMetadata)
	}
	if m.FieldCleared(dbapp.FieldDeletedAt) {
		fields = append(fields, dbapp.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case dbapp.FieldMetadata:
		m.ClearMetadata()
		return nil
	case dbapp.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case dbapp.FieldNamespace:
		m.ResetNamespace()
		return nil
	case dbapp.FieldMetadata:
		m.ResetMetadata()
		return nil
	case dbapp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dbapp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dbapp.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dbapp.FieldName:
		m.ResetName()
		return nil
	case dbapp.FieldDescription:
		m.ResetDescription()
		return nil
	case dbapp.FieldType:
		m.ResetType()
		return nil
	case dbapp.FieldStatus:
		m.ResetStatus()
		return nil
	case dbapp.FieldListingKey:
		m.ResetListingKey()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown App edge %s", name)
}

// BalanceSnapshotMutation represents an operation that mutates the BalanceSnapshot nodes in the graph.
type BalanceSnapshotMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	namespace          *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	grant_balances     *balance.Map
	balance            *float64
	addbalance         *float64
	overage            *float64
	addoverage         *float64
	at                 *time.Time
	clearedFields      map[string]struct{}
	entitlement        *string
	clearedentitlement bool
	done               bool
	oldValue           func(context.Context) (*BalanceSnapshot, error)
	predicates         []predicate.BalanceSnapshot
}

var _ ent.Mutation = (*BalanceSnapshotMutation)(nil)

// balancesnapshotOption allows management of the mutation configuration using functional options.
type balancesnapshotOption func(*BalanceSnapshotMutation)

// newBalanceSnapshotMutation creates new mutation for the BalanceSnapshot entity.
func newBalanceSnapshotMutation(c config, op Op, opts ...balancesnapshotOption) *BalanceSnapshotMutation {
	m := &BalanceSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeBalanceSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBalanceSnapshotID sets the ID field of the mutation.
func withBalanceSnapshotID(id int) balancesnapshotOption {
	return func(m *BalanceSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *BalanceSnapshot
		)
		m.oldValue = func(ctx context.Context) (*BalanceSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BalanceSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBalanceSnapshot sets the old BalanceSnapshot of the mutation.
func withBalanceSnapshot(node *BalanceSnapshot) balancesnapshotOption {
	return func(m *BalanceSnapshotMutation) {
		m.oldValue = func(context.Context) (*BalanceSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BalanceSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BalanceSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BalanceSnapshotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BalanceSnapshotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BalanceSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BalanceSnapshotMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BalanceSnapshotMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BalanceSnapshotMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BalanceSnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BalanceSnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BalanceSnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BalanceSnapshotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BalanceSnapshotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BalanceSnapshotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BalanceSnapshotMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BalanceSnapshotMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BalanceSnapshotMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[balancesnapshot.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BalanceSnapshotMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[balancesnapshot.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BalanceSnapshotMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, balancesnapshot.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *BalanceSnapshotMutation) SetOwnerID(s string) {
	m.entitlement = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *BalanceSnapshotMutation) OwnerID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *BalanceSnapshotMutation) ResetOwnerID() {
	m.entitlement = nil
}

// SetGrantBalances sets the "grant_balances" field.
func (m *BalanceSnapshotMutation) SetGrantBalances(b balance.Map) {
	m.grant_balances = &b
}

// GrantBalances returns the value of the "grant_balances" field in the mutation.
func (m *BalanceSnapshotMutation) GrantBalances() (r balance.Map, exists bool) {
	v := m.grant_balances
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantBalances returns the old "grant_balances" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldGrantBalances(ctx context.Context) (v balance.Map, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantBalances is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantBalances requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantBalances: %w", err)
	}
	return oldValue.GrantBalances, nil
}

// ResetGrantBalances resets all changes to the "grant_balances" field.
func (m *BalanceSnapshotMutation) ResetGrantBalances() {
	m.grant_balances = nil
}

// SetBalance sets the "balance" field.
func (m *BalanceSnapshotMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *BalanceSnapshotMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *BalanceSnapshotMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *BalanceSnapshotMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *BalanceSnapshotMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetOverage sets the "overage" field.
func (m *BalanceSnapshotMutation) SetOverage(f float64) {
	m.overage = &f
	m.addoverage = nil
}

// Overage returns the value of the "overage" field in the mutation.
func (m *BalanceSnapshotMutation) Overage() (r float64, exists bool) {
	v := m.overage
	if v == nil {
		return
	}
	return *v, true
}

// OldOverage returns the old "overage" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldOverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverage: %w", err)
	}
	return oldValue.Overage, nil
}

// AddOverage adds f to the "overage" field.
func (m *BalanceSnapshotMutation) AddOverage(f float64) {
	if m.addoverage != nil {
		*m.addoverage += f
	} else {
		m.addoverage = &f
	}
}

// AddedOverage returns the value that was added to the "overage" field in this mutation.
func (m *BalanceSnapshotMutation) AddedOverage() (r float64, exists bool) {
	v := m.addoverage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverage resets all changes to the "overage" field.
func (m *BalanceSnapshotMutation) ResetOverage() {
	m.overage = nil
	m.addoverage = nil
}

// SetAt sets the "at" field.
func (m *BalanceSnapshotMutation) SetAt(t time.Time) {
	m.at = &t
}

// At returns the value of the "at" field in the mutation.
func (m *BalanceSnapshotMutation) At() (r time.Time, exists bool) {
	v := m.at
	if v == nil {
		return
	}
	return *v, true
}

// OldAt returns the old "at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAt: %w", err)
	}
	return oldValue.At, nil
}

// ResetAt resets all changes to the "at" field.
func (m *BalanceSnapshotMutation) ResetAt() {
	m.at = nil
}

// SetEntitlementID sets the "entitlement" edge to the Entitlement entity by id.
func (m *BalanceSnapshotMutation) SetEntitlementID(id string) {
	m.entitlement = &id
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *BalanceSnapshotMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[balancesnapshot.FieldOwnerID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *BalanceSnapshotMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementID returns the "entitlement" edge ID in the mutation.
func (m *BalanceSnapshotMutation) EntitlementID() (id string, exists bool) {
	if m.entitlement != nil {
		return *m.entitlement, true
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *BalanceSnapshotMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *BalanceSnapshotMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the BalanceSnapshotMutation builder.
func (m *BalanceSnapshotMutation) Where(ps ...predicate.BalanceSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BalanceSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BalanceSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BalanceSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BalanceSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BalanceSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BalanceSnapshot).
func (m *BalanceSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BalanceSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.namespace != nil {
		fields = append(fields, balancesnapshot.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, balancesnapshot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, balancesnapshot.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, balancesnapshot.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, balancesnapshot.FieldOwnerID)
	}
	if m.grant_balances != nil {
		fields = append(fields, balancesnapshot.FieldGrantBalances)
	}
	if m.balance != nil {
		fields = append(fields, balancesnapshot.FieldBalance)
	}
	if m.overage != nil {
		fields = append(fields, balancesnapshot.FieldOverage)
	}
	if m.at != nil {
		fields = append(fields, balancesnapshot.FieldAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BalanceSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case balancesnapshot.FieldNamespace:
		return m.Namespace()
	case balancesnapshot.FieldCreatedAt:
		return m.CreatedAt()
	case balancesnapshot.FieldUpdatedAt:
		return m.UpdatedAt()
	case balancesnapshot.FieldDeletedAt:
		return m.DeletedAt()
	case balancesnapshot.FieldOwnerID:
		return m.OwnerID()
	case balancesnapshot.FieldGrantBalances:
		return m.GrantBalances()
	case balancesnapshot.FieldBalance:
		return m.Balance()
	case balancesnapshot.FieldOverage:
		return m.Overage()
	case balancesnapshot.FieldAt:
		return m.At()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BalanceSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case balancesnapshot.FieldNamespace:
		return m.OldNamespace(ctx)
	case balancesnapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case balancesnapshot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case balancesnapshot.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case balancesnapshot.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case balancesnapshot.FieldGrantBalances:
		return m.OldGrantBalances(ctx)
	case balancesnapshot.FieldBalance:
		return m.OldBalance(ctx)
	case balancesnapshot.FieldOverage:
		return m.OldOverage(ctx)
	case balancesnapshot.FieldAt:
		return m.OldAt(ctx)
	}
	return nil, fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case balancesnapshot.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case balancesnapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case balancesnapshot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case balancesnapshot.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case balancesnapshot.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case balancesnapshot.FieldGrantBalances:
		v, ok := value.(balance.Map)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantBalances(v)
		return nil
	case balancesnapshot.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case balancesnapshot.FieldOverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverage(v)
		return nil
	case balancesnapshot.FieldAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAt(v)
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BalanceSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, balancesnapshot.FieldBalance)
	}
	if m.addoverage != nil {
		fields = append(fields, balancesnapshot.FieldOverage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BalanceSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case balancesnapshot.FieldBalance:
		return m.AddedBalance()
	case balancesnapshot.FieldOverage:
		return m.AddedOverage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case balancesnapshot.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case balancesnapshot.FieldOverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverage(v)
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BalanceSnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(balancesnapshot.FieldDeletedAt) {
		fields = append(fields, balancesnapshot.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BalanceSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BalanceSnapshotMutation) ClearField(name string) error {
	switch name {
	case balancesnapshot.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BalanceSnapshotMutation) ResetField(name string) error {
	switch name {
	case balancesnapshot.FieldNamespace:
		m.ResetNamespace()
		return nil
	case balancesnapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case balancesnapshot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case balancesnapshot.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case balancesnapshot.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case balancesnapshot.FieldGrantBalances:
		m.ResetGrantBalances()
		return nil
	case balancesnapshot.FieldBalance:
		m.ResetBalance()
		return nil
	case balancesnapshot.FieldOverage:
		m.ResetOverage()
		return nil
	case balancesnapshot.FieldAt:
		m.ResetAt()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BalanceSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, balancesnapshot.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BalanceSnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BalanceSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BalanceSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BalanceSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, balancesnapshot.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BalanceSnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BalanceSnapshotMutation) ClearEdge(name string) error {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BalanceSnapshotMutation) ResetEdge(name string) error {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot edge %s", name)
}

// BillingCustomerOverrideMutation represents an operation that mutates the BillingCustomerOverride nodes in the graph.
type BillingCustomerOverrideMutation struct {
	config
	op                                Op
	typ                               string
	id                                *string
	namespace                         *string
	created_at                        *time.Time
	updated_at                        *time.Time
	deleted_at                        *time.Time
	collection_alignment              *billing.AlignmentKind
	item_collection_period_seconds    *int64
	additem_collection_period_seconds *int64
	invoice_auto_advance              *bool
	invoice_draft_period_seconds      *int64
	addinvoice_draft_period_seconds   *int64
	invoice_due_after_seconds         *int64
	addinvoice_due_after_seconds      *int64
	invoice_collection_method         *billing.CollectionMethod
	invoice_item_resolution           *billing.GranularityResolution
	invoice_item_per_subject          *bool
	clearedFields                     map[string]struct{}
	customer                          *string
	clearedcustomer                   bool
	billing_profile                   *string
	clearedbilling_profile            bool
	done                              bool
	oldValue                          func(context.Context) (*BillingCustomerOverride, error)
	predicates                        []predicate.BillingCustomerOverride
}

var _ ent.Mutation = (*BillingCustomerOverrideMutation)(nil)

// billingcustomeroverrideOption allows management of the mutation configuration using functional options.
type billingcustomeroverrideOption func(*BillingCustomerOverrideMutation)

// newBillingCustomerOverrideMutation creates new mutation for the BillingCustomerOverride entity.
func newBillingCustomerOverrideMutation(c config, op Op, opts ...billingcustomeroverrideOption) *BillingCustomerOverrideMutation {
	m := &BillingCustomerOverrideMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingCustomerOverride,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingCustomerOverrideID sets the ID field of the mutation.
func withBillingCustomerOverrideID(id string) billingcustomeroverrideOption {
	return func(m *BillingCustomerOverrideMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingCustomerOverride
		)
		m.oldValue = func(ctx context.Context) (*BillingCustomerOverride, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingCustomerOverride.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingCustomerOverride sets the old BillingCustomerOverride of the mutation.
func withBillingCustomerOverride(node *BillingCustomerOverride) billingcustomeroverrideOption {
	return func(m *BillingCustomerOverrideMutation) {
		m.oldValue = func(context.Context) (*BillingCustomerOverride, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingCustomerOverrideMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingCustomerOverrideMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingCustomerOverride entities.
func (m *BillingCustomerOverrideMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingCustomerOverrideMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingCustomerOverrideMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingCustomerOverride.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingCustomerOverrideMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingCustomerOverrideMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingCustomerOverrideMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingCustomerOverrideMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingCustomerOverrideMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingCustomerOverrideMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingCustomerOverrideMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingCustomerOverrideMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingCustomerOverrideMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingCustomerOverrideMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingCustomerOverrideMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingCustomerOverrideMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billingcustomeroverride.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingCustomerOverrideMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billingcustomeroverride.FieldDeletedAt)
}

// SetCustomerID sets the "customer_id" field.
func (m *BillingCustomerOverrideMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *BillingCustomerOverrideMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *BillingCustomerOverrideMutation) ResetCustomerID() {
	m.customer = nil
}

// SetBillingProfileID sets the "billing_profile_id" field.
func (m *BillingCustomerOverrideMutation) SetBillingProfileID(s string) {
	m.billing_profile = &s
}

// BillingProfileID returns the value of the "billing_profile_id" field in the mutation.
func (m *BillingCustomerOverrideMutation) BillingProfileID() (r string, exists bool) {
	v := m.billing_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingProfileID returns the old "billing_profile_id" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldBillingProfileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingProfileID: %w", err)
	}
	return oldValue.BillingProfileID, nil
}

// ClearBillingProfileID clears the value of the "billing_profile_id" field.
func (m *BillingCustomerOverrideMutation) ClearBillingProfileID() {
	m.billing_profile = nil
	m.clearedFields[billingcustomeroverride.FieldBillingProfileID] = struct{}{}
}

// BillingProfileIDCleared returns if the "billing_profile_id" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) BillingProfileIDCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldBillingProfileID]
	return ok
}

// ResetBillingProfileID resets all changes to the "billing_profile_id" field.
func (m *BillingCustomerOverrideMutation) ResetBillingProfileID() {
	m.billing_profile = nil
	delete(m.clearedFields, billingcustomeroverride.FieldBillingProfileID)
}

// SetCollectionAlignment sets the "collection_alignment" field.
func (m *BillingCustomerOverrideMutation) SetCollectionAlignment(bk billing.AlignmentKind) {
	m.collection_alignment = &bk
}

// CollectionAlignment returns the value of the "collection_alignment" field in the mutation.
func (m *BillingCustomerOverrideMutation) CollectionAlignment() (r billing.AlignmentKind, exists bool) {
	v := m.collection_alignment
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionAlignment returns the old "collection_alignment" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldCollectionAlignment(ctx context.Context) (v *billing.AlignmentKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionAlignment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionAlignment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionAlignment: %w", err)
	}
	return oldValue.CollectionAlignment, nil
}

// ClearCollectionAlignment clears the value of the "collection_alignment" field.
func (m *BillingCustomerOverrideMutation) ClearCollectionAlignment() {
	m.collection_alignment = nil
	m.clearedFields[billingcustomeroverride.FieldCollectionAlignment] = struct{}{}
}

// CollectionAlignmentCleared returns if the "collection_alignment" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) CollectionAlignmentCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldCollectionAlignment]
	return ok
}

// ResetCollectionAlignment resets all changes to the "collection_alignment" field.
func (m *BillingCustomerOverrideMutation) ResetCollectionAlignment() {
	m.collection_alignment = nil
	delete(m.clearedFields, billingcustomeroverride.FieldCollectionAlignment)
}

// SetItemCollectionPeriodSeconds sets the "item_collection_period_seconds" field.
func (m *BillingCustomerOverrideMutation) SetItemCollectionPeriodSeconds(i int64) {
	m.item_collection_period_seconds = &i
	m.additem_collection_period_seconds = nil
}

// ItemCollectionPeriodSeconds returns the value of the "item_collection_period_seconds" field in the mutation.
func (m *BillingCustomerOverrideMutation) ItemCollectionPeriodSeconds() (r int64, exists bool) {
	v := m.item_collection_period_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldItemCollectionPeriodSeconds returns the old "item_collection_period_seconds" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldItemCollectionPeriodSeconds(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemCollectionPeriodSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemCollectionPeriodSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemCollectionPeriodSeconds: %w", err)
	}
	return oldValue.ItemCollectionPeriodSeconds, nil
}

// AddItemCollectionPeriodSeconds adds i to the "item_collection_period_seconds" field.
func (m *BillingCustomerOverrideMutation) AddItemCollectionPeriodSeconds(i int64) {
	if m.additem_collection_period_seconds != nil {
		*m.additem_collection_period_seconds += i
	} else {
		m.additem_collection_period_seconds = &i
	}
}

// AddedItemCollectionPeriodSeconds returns the value that was added to the "item_collection_period_seconds" field in this mutation.
func (m *BillingCustomerOverrideMutation) AddedItemCollectionPeriodSeconds() (r int64, exists bool) {
	v := m.additem_collection_period_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearItemCollectionPeriodSeconds clears the value of the "item_collection_period_seconds" field.
func (m *BillingCustomerOverrideMutation) ClearItemCollectionPeriodSeconds() {
	m.item_collection_period_seconds = nil
	m.additem_collection_period_seconds = nil
	m.clearedFields[billingcustomeroverride.FieldItemCollectionPeriodSeconds] = struct{}{}
}

// ItemCollectionPeriodSecondsCleared returns if the "item_collection_period_seconds" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) ItemCollectionPeriodSecondsCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldItemCollectionPeriodSeconds]
	return ok
}

// ResetItemCollectionPeriodSeconds resets all changes to the "item_collection_period_seconds" field.
func (m *BillingCustomerOverrideMutation) ResetItemCollectionPeriodSeconds() {
	m.item_collection_period_seconds = nil
	m.additem_collection_period_seconds = nil
	delete(m.clearedFields, billingcustomeroverride.FieldItemCollectionPeriodSeconds)
}

// SetInvoiceAutoAdvance sets the "invoice_auto_advance" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceAutoAdvance(b bool) {
	m.invoice_auto_advance = &b
}

// InvoiceAutoAdvance returns the value of the "invoice_auto_advance" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceAutoAdvance() (r bool, exists bool) {
	v := m.invoice_auto_advance
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceAutoAdvance returns the old "invoice_auto_advance" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceAutoAdvance(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceAutoAdvance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceAutoAdvance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceAutoAdvance: %w", err)
	}
	return oldValue.InvoiceAutoAdvance, nil
}

// ClearInvoiceAutoAdvance clears the value of the "invoice_auto_advance" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceAutoAdvance() {
	m.invoice_auto_advance = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceAutoAdvance] = struct{}{}
}

// InvoiceAutoAdvanceCleared returns if the "invoice_auto_advance" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceAutoAdvanceCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceAutoAdvance]
	return ok
}

// ResetInvoiceAutoAdvance resets all changes to the "invoice_auto_advance" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceAutoAdvance() {
	m.invoice_auto_advance = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceAutoAdvance)
}

// SetInvoiceDraftPeriodSeconds sets the "invoice_draft_period_seconds" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceDraftPeriodSeconds(i int64) {
	m.invoice_draft_period_seconds = &i
	m.addinvoice_draft_period_seconds = nil
}

// InvoiceDraftPeriodSeconds returns the value of the "invoice_draft_period_seconds" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDraftPeriodSeconds() (r int64, exists bool) {
	v := m.invoice_draft_period_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDraftPeriodSeconds returns the old "invoice_draft_period_seconds" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceDraftPeriodSeconds(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDraftPeriodSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDraftPeriodSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDraftPeriodSeconds: %w", err)
	}
	return oldValue.InvoiceDraftPeriodSeconds, nil
}

// AddInvoiceDraftPeriodSeconds adds i to the "invoice_draft_period_seconds" field.
func (m *BillingCustomerOverrideMutation) AddInvoiceDraftPeriodSeconds(i int64) {
	if m.addinvoice_draft_period_seconds != nil {
		*m.addinvoice_draft_period_seconds += i
	} else {
		m.addinvoice_draft_period_seconds = &i
	}
}

// AddedInvoiceDraftPeriodSeconds returns the value that was added to the "invoice_draft_period_seconds" field in this mutation.
func (m *BillingCustomerOverrideMutation) AddedInvoiceDraftPeriodSeconds() (r int64, exists bool) {
	v := m.addinvoice_draft_period_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearInvoiceDraftPeriodSeconds clears the value of the "invoice_draft_period_seconds" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceDraftPeriodSeconds() {
	m.invoice_draft_period_seconds = nil
	m.addinvoice_draft_period_seconds = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceDraftPeriodSeconds] = struct{}{}
}

// InvoiceDraftPeriodSecondsCleared returns if the "invoice_draft_period_seconds" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDraftPeriodSecondsCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceDraftPeriodSeconds]
	return ok
}

// ResetInvoiceDraftPeriodSeconds resets all changes to the "invoice_draft_period_seconds" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceDraftPeriodSeconds() {
	m.invoice_draft_period_seconds = nil
	m.addinvoice_draft_period_seconds = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceDraftPeriodSeconds)
}

// SetInvoiceDueAfterSeconds sets the "invoice_due_after_seconds" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceDueAfterSeconds(i int64) {
	m.invoice_due_after_seconds = &i
	m.addinvoice_due_after_seconds = nil
}

// InvoiceDueAfterSeconds returns the value of the "invoice_due_after_seconds" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDueAfterSeconds() (r int64, exists bool) {
	v := m.invoice_due_after_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDueAfterSeconds returns the old "invoice_due_after_seconds" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceDueAfterSeconds(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDueAfterSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDueAfterSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDueAfterSeconds: %w", err)
	}
	return oldValue.InvoiceDueAfterSeconds, nil
}

// AddInvoiceDueAfterSeconds adds i to the "invoice_due_after_seconds" field.
func (m *BillingCustomerOverrideMutation) AddInvoiceDueAfterSeconds(i int64) {
	if m.addinvoice_due_after_seconds != nil {
		*m.addinvoice_due_after_seconds += i
	} else {
		m.addinvoice_due_after_seconds = &i
	}
}

// AddedInvoiceDueAfterSeconds returns the value that was added to the "invoice_due_after_seconds" field in this mutation.
func (m *BillingCustomerOverrideMutation) AddedInvoiceDueAfterSeconds() (r int64, exists bool) {
	v := m.addinvoice_due_after_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearInvoiceDueAfterSeconds clears the value of the "invoice_due_after_seconds" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceDueAfterSeconds() {
	m.invoice_due_after_seconds = nil
	m.addinvoice_due_after_seconds = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceDueAfterSeconds] = struct{}{}
}

// InvoiceDueAfterSecondsCleared returns if the "invoice_due_after_seconds" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDueAfterSecondsCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceDueAfterSeconds]
	return ok
}

// ResetInvoiceDueAfterSeconds resets all changes to the "invoice_due_after_seconds" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceDueAfterSeconds() {
	m.invoice_due_after_seconds = nil
	m.addinvoice_due_after_seconds = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceDueAfterSeconds)
}

// SetInvoiceCollectionMethod sets the "invoice_collection_method" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceCollectionMethod(bm billing.CollectionMethod) {
	m.invoice_collection_method = &bm
}

// InvoiceCollectionMethod returns the value of the "invoice_collection_method" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceCollectionMethod() (r billing.CollectionMethod, exists bool) {
	v := m.invoice_collection_method
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceCollectionMethod returns the old "invoice_collection_method" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceCollectionMethod(ctx context.Context) (v *billing.CollectionMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceCollectionMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceCollectionMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceCollectionMethod: %w", err)
	}
	return oldValue.InvoiceCollectionMethod, nil
}

// ClearInvoiceCollectionMethod clears the value of the "invoice_collection_method" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceCollectionMethod() {
	m.invoice_collection_method = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceCollectionMethod] = struct{}{}
}

// InvoiceCollectionMethodCleared returns if the "invoice_collection_method" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceCollectionMethodCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceCollectionMethod]
	return ok
}

// ResetInvoiceCollectionMethod resets all changes to the "invoice_collection_method" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceCollectionMethod() {
	m.invoice_collection_method = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceCollectionMethod)
}

// SetInvoiceItemResolution sets the "invoice_item_resolution" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceItemResolution(br billing.GranularityResolution) {
	m.invoice_item_resolution = &br
}

// InvoiceItemResolution returns the value of the "invoice_item_resolution" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceItemResolution() (r billing.GranularityResolution, exists bool) {
	v := m.invoice_item_resolution
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceItemResolution returns the old "invoice_item_resolution" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceItemResolution(ctx context.Context) (v *billing.GranularityResolution, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceItemResolution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceItemResolution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceItemResolution: %w", err)
	}
	return oldValue.InvoiceItemResolution, nil
}

// ClearInvoiceItemResolution clears the value of the "invoice_item_resolution" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceItemResolution() {
	m.invoice_item_resolution = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceItemResolution] = struct{}{}
}

// InvoiceItemResolutionCleared returns if the "invoice_item_resolution" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceItemResolutionCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceItemResolution]
	return ok
}

// ResetInvoiceItemResolution resets all changes to the "invoice_item_resolution" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceItemResolution() {
	m.invoice_item_resolution = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceItemResolution)
}

// SetInvoiceItemPerSubject sets the "invoice_item_per_subject" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceItemPerSubject(b bool) {
	m.invoice_item_per_subject = &b
}

// InvoiceItemPerSubject returns the value of the "invoice_item_per_subject" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceItemPerSubject() (r bool, exists bool) {
	v := m.invoice_item_per_subject
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceItemPerSubject returns the old "invoice_item_per_subject" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceItemPerSubject(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceItemPerSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceItemPerSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceItemPerSubject: %w", err)
	}
	return oldValue.InvoiceItemPerSubject, nil
}

// ClearInvoiceItemPerSubject clears the value of the "invoice_item_per_subject" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceItemPerSubject() {
	m.invoice_item_per_subject = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceItemPerSubject] = struct{}{}
}

// InvoiceItemPerSubjectCleared returns if the "invoice_item_per_subject" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceItemPerSubjectCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceItemPerSubject]
	return ok
}

// ResetInvoiceItemPerSubject resets all changes to the "invoice_item_per_subject" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceItemPerSubject() {
	m.invoice_item_per_subject = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceItemPerSubject)
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *BillingCustomerOverrideMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[billingcustomeroverride.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *BillingCustomerOverrideMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *BillingCustomerOverrideMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *BillingCustomerOverrideMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearBillingProfile clears the "billing_profile" edge to the BillingProfile entity.
func (m *BillingCustomerOverrideMutation) ClearBillingProfile() {
	m.clearedbilling_profile = true
	m.clearedFields[billingcustomeroverride.FieldBillingProfileID] = struct{}{}
}

// BillingProfileCleared reports if the "billing_profile" edge to the BillingProfile entity was cleared.
func (m *BillingCustomerOverrideMutation) BillingProfileCleared() bool {
	return m.BillingProfileIDCleared() || m.clearedbilling_profile
}

// BillingProfileIDs returns the "billing_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingProfileID instead. It exists only for internal usage by the builders.
func (m *BillingCustomerOverrideMutation) BillingProfileIDs() (ids []string) {
	if id := m.billing_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingProfile resets all changes to the "billing_profile" edge.
func (m *BillingCustomerOverrideMutation) ResetBillingProfile() {
	m.billing_profile = nil
	m.clearedbilling_profile = false
}

// Where appends a list predicates to the BillingCustomerOverrideMutation builder.
func (m *BillingCustomerOverrideMutation) Where(ps ...predicate.BillingCustomerOverride) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingCustomerOverrideMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingCustomerOverrideMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingCustomerOverride, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingCustomerOverrideMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingCustomerOverrideMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingCustomerOverride).
func (m *BillingCustomerOverrideMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingCustomerOverrideMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.namespace != nil {
		fields = append(fields, billingcustomeroverride.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billingcustomeroverride.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingcustomeroverride.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billingcustomeroverride.FieldDeletedAt)
	}
	if m.customer != nil {
		fields = append(fields, billingcustomeroverride.FieldCustomerID)
	}
	if m.billing_profile != nil {
		fields = append(fields, billingcustomeroverride.FieldBillingProfileID)
	}
	if m.collection_alignment != nil {
		fields = append(fields, billingcustomeroverride.FieldCollectionAlignment)
	}
	if m.item_collection_period_seconds != nil {
		fields = append(fields, billingcustomeroverride.FieldItemCollectionPeriodSeconds)
	}
	if m.invoice_auto_advance != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceAutoAdvance)
	}
	if m.invoice_draft_period_seconds != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDraftPeriodSeconds)
	}
	if m.invoice_due_after_seconds != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDueAfterSeconds)
	}
	if m.invoice_collection_method != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceCollectionMethod)
	}
	if m.invoice_item_resolution != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceItemResolution)
	}
	if m.invoice_item_per_subject != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceItemPerSubject)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingCustomerOverrideMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		return m.Namespace()
	case billingcustomeroverride.FieldCreatedAt:
		return m.CreatedAt()
	case billingcustomeroverride.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingcustomeroverride.FieldDeletedAt:
		return m.DeletedAt()
	case billingcustomeroverride.FieldCustomerID:
		return m.CustomerID()
	case billingcustomeroverride.FieldBillingProfileID:
		return m.BillingProfileID()
	case billingcustomeroverride.FieldCollectionAlignment:
		return m.CollectionAlignment()
	case billingcustomeroverride.FieldItemCollectionPeriodSeconds:
		return m.ItemCollectionPeriodSeconds()
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		return m.InvoiceAutoAdvance()
	case billingcustomeroverride.FieldInvoiceDraftPeriodSeconds:
		return m.InvoiceDraftPeriodSeconds()
	case billingcustomeroverride.FieldInvoiceDueAfterSeconds:
		return m.InvoiceDueAfterSeconds()
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		return m.InvoiceCollectionMethod()
	case billingcustomeroverride.FieldInvoiceItemResolution:
		return m.InvoiceItemResolution()
	case billingcustomeroverride.FieldInvoiceItemPerSubject:
		return m.InvoiceItemPerSubject()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingCustomerOverrideMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingcustomeroverride.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingcustomeroverride.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingcustomeroverride.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billingcustomeroverride.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case billingcustomeroverride.FieldBillingProfileID:
		return m.OldBillingProfileID(ctx)
	case billingcustomeroverride.FieldCollectionAlignment:
		return m.OldCollectionAlignment(ctx)
	case billingcustomeroverride.FieldItemCollectionPeriodSeconds:
		return m.OldItemCollectionPeriodSeconds(ctx)
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		return m.OldInvoiceAutoAdvance(ctx)
	case billingcustomeroverride.FieldInvoiceDraftPeriodSeconds:
		return m.OldInvoiceDraftPeriodSeconds(ctx)
	case billingcustomeroverride.FieldInvoiceDueAfterSeconds:
		return m.OldInvoiceDueAfterSeconds(ctx)
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		return m.OldInvoiceCollectionMethod(ctx)
	case billingcustomeroverride.FieldInvoiceItemResolution:
		return m.OldInvoiceItemResolution(ctx)
	case billingcustomeroverride.FieldInvoiceItemPerSubject:
		return m.OldInvoiceItemPerSubject(ctx)
	}
	return nil, fmt.Errorf("unknown BillingCustomerOverride field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingCustomerOverrideMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingcustomeroverride.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingcustomeroverride.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingcustomeroverride.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billingcustomeroverride.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case billingcustomeroverride.FieldBillingProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingProfileID(v)
		return nil
	case billingcustomeroverride.FieldCollectionAlignment:
		v, ok := value.(billing.AlignmentKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionAlignment(v)
		return nil
	case billingcustomeroverride.FieldItemCollectionPeriodSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemCollectionPeriodSeconds(v)
		return nil
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceAutoAdvance(v)
		return nil
	case billingcustomeroverride.FieldInvoiceDraftPeriodSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDraftPeriodSeconds(v)
		return nil
	case billingcustomeroverride.FieldInvoiceDueAfterSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDueAfterSeconds(v)
		return nil
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		v, ok := value.(billing.CollectionMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceCollectionMethod(v)
		return nil
	case billingcustomeroverride.FieldInvoiceItemResolution:
		v, ok := value.(billing.GranularityResolution)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceItemResolution(v)
		return nil
	case billingcustomeroverride.FieldInvoiceItemPerSubject:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceItemPerSubject(v)
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingCustomerOverrideMutation) AddedFields() []string {
	var fields []string
	if m.additem_collection_period_seconds != nil {
		fields = append(fields, billingcustomeroverride.FieldItemCollectionPeriodSeconds)
	}
	if m.addinvoice_draft_period_seconds != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDraftPeriodSeconds)
	}
	if m.addinvoice_due_after_seconds != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDueAfterSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingCustomerOverrideMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case billingcustomeroverride.FieldItemCollectionPeriodSeconds:
		return m.AddedItemCollectionPeriodSeconds()
	case billingcustomeroverride.FieldInvoiceDraftPeriodSeconds:
		return m.AddedInvoiceDraftPeriodSeconds()
	case billingcustomeroverride.FieldInvoiceDueAfterSeconds:
		return m.AddedInvoiceDueAfterSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingCustomerOverrideMutation) AddField(name string, value ent.Value) error {
	switch name {
	case billingcustomeroverride.FieldItemCollectionPeriodSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemCollectionPeriodSeconds(v)
		return nil
	case billingcustomeroverride.FieldInvoiceDraftPeriodSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceDraftPeriodSeconds(v)
		return nil
	case billingcustomeroverride.FieldInvoiceDueAfterSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceDueAfterSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingCustomerOverrideMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billingcustomeroverride.FieldDeletedAt) {
		fields = append(fields, billingcustomeroverride.FieldDeletedAt)
	}
	if m.FieldCleared(billingcustomeroverride.FieldBillingProfileID) {
		fields = append(fields, billingcustomeroverride.FieldBillingProfileID)
	}
	if m.FieldCleared(billingcustomeroverride.FieldCollectionAlignment) {
		fields = append(fields, billingcustomeroverride.FieldCollectionAlignment)
	}
	if m.FieldCleared(billingcustomeroverride.FieldItemCollectionPeriodSeconds) {
		fields = append(fields, billingcustomeroverride.FieldItemCollectionPeriodSeconds)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceAutoAdvance) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceAutoAdvance)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceDraftPeriodSeconds) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDraftPeriodSeconds)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceDueAfterSeconds) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDueAfterSeconds)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceCollectionMethod) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceCollectionMethod)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceItemResolution) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceItemResolution)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceItemPerSubject) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceItemPerSubject)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingCustomerOverrideMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ClearField(name string) error {
	switch name {
	case billingcustomeroverride.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billingcustomeroverride.FieldBillingProfileID:
		m.ClearBillingProfileID()
		return nil
	case billingcustomeroverride.FieldCollectionAlignment:
		m.ClearCollectionAlignment()
		return nil
	case billingcustomeroverride.FieldItemCollectionPeriodSeconds:
		m.ClearItemCollectionPeriodSeconds()
		return nil
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		m.ClearInvoiceAutoAdvance()
		return nil
	case billingcustomeroverride.FieldInvoiceDraftPeriodSeconds:
		m.ClearInvoiceDraftPeriodSeconds()
		return nil
	case billingcustomeroverride.FieldInvoiceDueAfterSeconds:
		m.ClearInvoiceDueAfterSeconds()
		return nil
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		m.ClearInvoiceCollectionMethod()
		return nil
	case billingcustomeroverride.FieldInvoiceItemResolution:
		m.ClearInvoiceItemResolution()
		return nil
	case billingcustomeroverride.FieldInvoiceItemPerSubject:
		m.ClearInvoiceItemPerSubject()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ResetField(name string) error {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingcustomeroverride.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingcustomeroverride.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingcustomeroverride.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billingcustomeroverride.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case billingcustomeroverride.FieldBillingProfileID:
		m.ResetBillingProfileID()
		return nil
	case billingcustomeroverride.FieldCollectionAlignment:
		m.ResetCollectionAlignment()
		return nil
	case billingcustomeroverride.FieldItemCollectionPeriodSeconds:
		m.ResetItemCollectionPeriodSeconds()
		return nil
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		m.ResetInvoiceAutoAdvance()
		return nil
	case billingcustomeroverride.FieldInvoiceDraftPeriodSeconds:
		m.ResetInvoiceDraftPeriodSeconds()
		return nil
	case billingcustomeroverride.FieldInvoiceDueAfterSeconds:
		m.ResetInvoiceDueAfterSeconds()
		return nil
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		m.ResetInvoiceCollectionMethod()
		return nil
	case billingcustomeroverride.FieldInvoiceItemResolution:
		m.ResetInvoiceItemResolution()
		return nil
	case billingcustomeroverride.FieldInvoiceItemPerSubject:
		m.ResetInvoiceItemPerSubject()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingCustomerOverrideMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.customer != nil {
		edges = append(edges, billingcustomeroverride.EdgeCustomer)
	}
	if m.billing_profile != nil {
		edges = append(edges, billingcustomeroverride.EdgeBillingProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingCustomerOverrideMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case billingcustomeroverride.EdgeBillingProfile:
		if id := m.billing_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingCustomerOverrideMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingCustomerOverrideMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingCustomerOverrideMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcustomer {
		edges = append(edges, billingcustomeroverride.EdgeCustomer)
	}
	if m.clearedbilling_profile {
		edges = append(edges, billingcustomeroverride.EdgeBillingProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) EdgeCleared(name string) bool {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		return m.clearedcustomer
	case billingcustomeroverride.EdgeBillingProfile:
		return m.clearedbilling_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ClearEdge(name string) error {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case billingcustomeroverride.EdgeBillingProfile:
		m.ClearBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ResetEdge(name string) error {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case billingcustomeroverride.EdgeBillingProfile:
		m.ResetBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride edge %s", name)
}

// BillingInvoiceMutation represents an operation that mutates the BillingInvoice nodes in the graph.
type BillingInvoiceMutation struct {
	config
	op                             Op
	typ                            string
	id                             *string
	namespace                      *string
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	metadata                       *map[string]string
	series                         *string
	code                           *string
	customer_id                    *string
	voided_at                      *time.Time
	currency                       *string
	due_date                       *time.Time
	status                         *billing.InvoiceStatus
	tax_provider                   *provider.TaxProvider
	invoicing_provider             *provider.InvoicingProvider
	payment_provider               *provider.PaymentProvider
	period_start                   *time.Time
	period_end                     *time.Time
	clearedFields                  map[string]struct{}
	billing_profile                *string
	clearedbilling_profile         bool
	billing_workflow_config        *string
	clearedbilling_workflow_config bool
	billing_invoice_items          map[string]struct{}
	removedbilling_invoice_items   map[string]struct{}
	clearedbilling_invoice_items   bool
	done                           bool
	oldValue                       func(context.Context) (*BillingInvoice, error)
	predicates                     []predicate.BillingInvoice
}

var _ ent.Mutation = (*BillingInvoiceMutation)(nil)

// billinginvoiceOption allows management of the mutation configuration using functional options.
type billinginvoiceOption func(*BillingInvoiceMutation)

// newBillingInvoiceMutation creates new mutation for the BillingInvoice entity.
func newBillingInvoiceMutation(c config, op Op, opts ...billinginvoiceOption) *BillingInvoiceMutation {
	m := &BillingInvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceID sets the ID field of the mutation.
func withBillingInvoiceID(id string) billinginvoiceOption {
	return func(m *BillingInvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoice
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoice sets the old BillingInvoice of the mutation.
func withBillingInvoice(node *BillingInvoice) billinginvoiceOption {
	return func(m *BillingInvoiceMutation) {
		m.oldValue = func(context.Context) (*BillingInvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoice entities.
func (m *BillingInvoiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingInvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingInvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingInvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingInvoiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingInvoiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingInvoiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingInvoiceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingInvoiceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingInvoiceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billinginvoice.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingInvoiceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billinginvoice.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *BillingInvoiceMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *BillingInvoiceMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *BillingInvoiceMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[billinginvoice.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *BillingInvoiceMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *BillingInvoiceMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, billinginvoice.FieldMetadata)
}

// SetSeries sets the "series" field.
func (m *BillingInvoiceMutation) SetSeries(s string) {
	m.series = &s
}

// Series returns the value of the "series" field in the mutation.
func (m *BillingInvoiceMutation) Series() (r string, exists bool) {
	v := m.series
	if v == nil {
		return
	}
	return *v, true
}

// OldSeries returns the old "series" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSeries(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeries: %w", err)
	}
	return oldValue.Series, nil
}

// ClearSeries clears the value of the "series" field.
func (m *BillingInvoiceMutation) ClearSeries() {
	m.series = nil
	m.clearedFields[billinginvoice.FieldSeries] = struct{}{}
}

// SeriesCleared returns if the "series" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SeriesCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSeries]
	return ok
}

// ResetSeries resets all changes to the "series" field.
func (m *BillingInvoiceMutation) ResetSeries() {
	m.series = nil
	delete(m.clearedFields, billinginvoice.FieldSeries)
}

// SetCode sets the "code" field.
func (m *BillingInvoiceMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *BillingInvoiceMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *BillingInvoiceMutation) ClearCode() {
	m.code = nil
	m.clearedFields[billinginvoice.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CodeCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *BillingInvoiceMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, billinginvoice.FieldCode)
}

// SetCustomerID sets the "customer_id" field.
func (m *BillingInvoiceMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *BillingInvoiceMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *BillingInvoiceMutation) ResetCustomerID() {
	m.customer_id = nil
}

// SetBillingProfileID sets the "billing_profile_id" field.
func (m *BillingInvoiceMutation) SetBillingProfileID(s string) {
	m.billing_profile = &s
}

// BillingProfileID returns the value of the "billing_profile_id" field in the mutation.
func (m *BillingInvoiceMutation) BillingProfileID() (r string, exists bool) {
	v := m.billing_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingProfileID returns the old "billing_profile_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldBillingProfileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingProfileID: %w", err)
	}
	return oldValue.BillingProfileID, nil
}

// ResetBillingProfileID resets all changes to the "billing_profile_id" field.
func (m *BillingInvoiceMutation) ResetBillingProfileID() {
	m.billing_profile = nil
}

// SetVoidedAt sets the "voided_at" field.
func (m *BillingInvoiceMutation) SetVoidedAt(t time.Time) {
	m.voided_at = &t
}

// VoidedAt returns the value of the "voided_at" field in the mutation.
func (m *BillingInvoiceMutation) VoidedAt() (r time.Time, exists bool) {
	v := m.voided_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidedAt returns the old "voided_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldVoidedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidedAt: %w", err)
	}
	return oldValue.VoidedAt, nil
}

// ClearVoidedAt clears the value of the "voided_at" field.
func (m *BillingInvoiceMutation) ClearVoidedAt() {
	m.voided_at = nil
	m.clearedFields[billinginvoice.FieldVoidedAt] = struct{}{}
}

// VoidedAtCleared returns if the "voided_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) VoidedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldVoidedAt]
	return ok
}

// ResetVoidedAt resets all changes to the "voided_at" field.
func (m *BillingInvoiceMutation) ResetVoidedAt() {
	m.voided_at = nil
	delete(m.clearedFields, billinginvoice.FieldVoidedAt)
}

// SetCurrency sets the "currency" field.
func (m *BillingInvoiceMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *BillingInvoiceMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *BillingInvoiceMutation) ResetCurrency() {
	m.currency = nil
}

// SetDueDate sets the "due_date" field.
func (m *BillingInvoiceMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *BillingInvoiceMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *BillingInvoiceMutation) ResetDueDate() {
	m.due_date = nil
}

// SetStatus sets the "status" field.
func (m *BillingInvoiceMutation) SetStatus(bs billing.InvoiceStatus) {
	m.status = &bs
}

// Status returns the value of the "status" field in the mutation.
func (m *BillingInvoiceMutation) Status() (r billing.InvoiceStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldStatus(ctx context.Context) (v billing.InvoiceStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BillingInvoiceMutation) ResetStatus() {
	m.status = nil
}

// SetTaxProvider sets the "tax_provider" field.
func (m *BillingInvoiceMutation) SetTaxProvider(pp provider.TaxProvider) {
	m.tax_provider = &pp
}

// TaxProvider returns the value of the "tax_provider" field in the mutation.
func (m *BillingInvoiceMutation) TaxProvider() (r provider.TaxProvider, exists bool) {
	v := m.tax_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxProvider returns the old "tax_provider" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldTaxProvider(ctx context.Context) (v *provider.TaxProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxProvider: %w", err)
	}
	return oldValue.TaxProvider, nil
}

// ClearTaxProvider clears the value of the "tax_provider" field.
func (m *BillingInvoiceMutation) ClearTaxProvider() {
	m.tax_provider = nil
	m.clearedFields[billinginvoice.FieldTaxProvider] = struct{}{}
}

// TaxProviderCleared returns if the "tax_provider" field was cleared in this mutation.
func (m *BillingInvoiceMutation) TaxProviderCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldTaxProvider]
	return ok
}

// ResetTaxProvider resets all changes to the "tax_provider" field.
func (m *BillingInvoiceMutation) ResetTaxProvider() {
	m.tax_provider = nil
	delete(m.clearedFields, billinginvoice.FieldTaxProvider)
}

// SetInvoicingProvider sets the "invoicing_provider" field.
func (m *BillingInvoiceMutation) SetInvoicingProvider(pp provider.InvoicingProvider) {
	m.invoicing_provider = &pp
}

// InvoicingProvider returns the value of the "invoicing_provider" field in the mutation.
func (m *BillingInvoiceMutation) InvoicingProvider() (r provider.InvoicingProvider, exists bool) {
	v := m.invoicing_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingProvider returns the old "invoicing_provider" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldInvoicingProvider(ctx context.Context) (v *provider.InvoicingProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingProvider: %w", err)
	}
	return oldValue.InvoicingProvider, nil
}

// ClearInvoicingProvider clears the value of the "invoicing_provider" field.
func (m *BillingInvoiceMutation) ClearInvoicingProvider() {
	m.invoicing_provider = nil
	m.clearedFields[billinginvoice.FieldInvoicingProvider] = struct{}{}
}

// InvoicingProviderCleared returns if the "invoicing_provider" field was cleared in this mutation.
func (m *BillingInvoiceMutation) InvoicingProviderCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldInvoicingProvider]
	return ok
}

// ResetInvoicingProvider resets all changes to the "invoicing_provider" field.
func (m *BillingInvoiceMutation) ResetInvoicingProvider() {
	m.invoicing_provider = nil
	delete(m.clearedFields, billinginvoice.FieldInvoicingProvider)
}

// SetPaymentProvider sets the "payment_provider" field.
func (m *BillingInvoiceMutation) SetPaymentProvider(pp provider.PaymentProvider) {
	m.payment_provider = &pp
}

// PaymentProvider returns the value of the "payment_provider" field in the mutation.
func (m *BillingInvoiceMutation) PaymentProvider() (r provider.PaymentProvider, exists bool) {
	v := m.payment_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentProvider returns the old "payment_provider" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldPaymentProvider(ctx context.Context) (v *provider.PaymentProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentProvider: %w", err)
	}
	return oldValue.PaymentProvider, nil
}

// ClearPaymentProvider clears the value of the "payment_provider" field.
func (m *BillingInvoiceMutation) ClearPaymentProvider() {
	m.payment_provider = nil
	m.clearedFields[billinginvoice.FieldPaymentProvider] = struct{}{}
}

// PaymentProviderCleared returns if the "payment_provider" field was cleared in this mutation.
func (m *BillingInvoiceMutation) PaymentProviderCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldPaymentProvider]
	return ok
}

// ResetPaymentProvider resets all changes to the "payment_provider" field.
func (m *BillingInvoiceMutation) ResetPaymentProvider() {
	m.payment_provider = nil
	delete(m.clearedFields, billinginvoice.FieldPaymentProvider)
}

// SetWorkflowConfigID sets the "workflow_config_id" field.
func (m *BillingInvoiceMutation) SetWorkflowConfigID(s string) {
	m.billing_workflow_config = &s
}

// WorkflowConfigID returns the value of the "workflow_config_id" field in the mutation.
func (m *BillingInvoiceMutation) WorkflowConfigID() (r string, exists bool) {
	v := m.billing_workflow_config
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowConfigID returns the old "workflow_config_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldWorkflowConfigID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowConfigID: %w", err)
	}
	return oldValue.WorkflowConfigID, nil
}

// ResetWorkflowConfigID resets all changes to the "workflow_config_id" field.
func (m *BillingInvoiceMutation) ResetWorkflowConfigID() {
	m.billing_workflow_config = nil
}

// SetPeriodStart sets the "period_start" field.
func (m *BillingInvoiceMutation) SetPeriodStart(t time.Time) {
	m.period_start = &t
}

// PeriodStart returns the value of the "period_start" field in the mutation.
func (m *BillingInvoiceMutation) PeriodStart() (r time.Time, exists bool) {
	v := m.period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodStart returns the old "period_start" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldPeriodStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodStart: %w", err)
	}
	return oldValue.PeriodStart, nil
}

// ResetPeriodStart resets all changes to the "period_start" field.
func (m *BillingInvoiceMutation) ResetPeriodStart() {
	m.period_start = nil
}

// SetPeriodEnd sets the "period_end" field.
func (m *BillingInvoiceMutation) SetPeriodEnd(t time.Time) {
	m.period_end = &t
}

// PeriodEnd returns the value of the "period_end" field in the mutation.
func (m *BillingInvoiceMutation) PeriodEnd() (r time.Time, exists bool) {
	v := m.period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodEnd returns the old "period_end" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldPeriodEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodEnd: %w", err)
	}
	return oldValue.PeriodEnd, nil
}

// ResetPeriodEnd resets all changes to the "period_end" field.
func (m *BillingInvoiceMutation) ResetPeriodEnd() {
	m.period_end = nil
}

// ClearBillingProfile clears the "billing_profile" edge to the BillingProfile entity.
func (m *BillingInvoiceMutation) ClearBillingProfile() {
	m.clearedbilling_profile = true
	m.clearedFields[billinginvoice.FieldBillingProfileID] = struct{}{}
}

// BillingProfileCleared reports if the "billing_profile" edge to the BillingProfile entity was cleared.
func (m *BillingInvoiceMutation) BillingProfileCleared() bool {
	return m.clearedbilling_profile
}

// BillingProfileIDs returns the "billing_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingProfileID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) BillingProfileIDs() (ids []string) {
	if id := m.billing_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingProfile resets all changes to the "billing_profile" edge.
func (m *BillingInvoiceMutation) ResetBillingProfile() {
	m.billing_profile = nil
	m.clearedbilling_profile = false
}

// SetBillingWorkflowConfigID sets the "billing_workflow_config" edge to the BillingWorkflowConfig entity by id.
func (m *BillingInvoiceMutation) SetBillingWorkflowConfigID(id string) {
	m.billing_workflow_config = &id
}

// ClearBillingWorkflowConfig clears the "billing_workflow_config" edge to the BillingWorkflowConfig entity.
func (m *BillingInvoiceMutation) ClearBillingWorkflowConfig() {
	m.clearedbilling_workflow_config = true
	m.clearedFields[billinginvoice.FieldWorkflowConfigID] = struct{}{}
}

// BillingWorkflowConfigCleared reports if the "billing_workflow_config" edge to the BillingWorkflowConfig entity was cleared.
func (m *BillingInvoiceMutation) BillingWorkflowConfigCleared() bool {
	return m.clearedbilling_workflow_config
}

// BillingWorkflowConfigID returns the "billing_workflow_config" edge ID in the mutation.
func (m *BillingInvoiceMutation) BillingWorkflowConfigID() (id string, exists bool) {
	if m.billing_workflow_config != nil {
		return *m.billing_workflow_config, true
	}
	return
}

// BillingWorkflowConfigIDs returns the "billing_workflow_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingWorkflowConfigID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) BillingWorkflowConfigIDs() (ids []string) {
	if id := m.billing_workflow_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingWorkflowConfig resets all changes to the "billing_workflow_config" edge.
func (m *BillingInvoiceMutation) ResetBillingWorkflowConfig() {
	m.billing_workflow_config = nil
	m.clearedbilling_workflow_config = false
}

// AddBillingInvoiceItemIDs adds the "billing_invoice_items" edge to the BillingInvoiceItem entity by ids.
func (m *BillingInvoiceMutation) AddBillingInvoiceItemIDs(ids ...string) {
	if m.billing_invoice_items == nil {
		m.billing_invoice_items = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_items[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoiceItems clears the "billing_invoice_items" edge to the BillingInvoiceItem entity.
func (m *BillingInvoiceMutation) ClearBillingInvoiceItems() {
	m.clearedbilling_invoice_items = true
}

// BillingInvoiceItemsCleared reports if the "billing_invoice_items" edge to the BillingInvoiceItem entity was cleared.
func (m *BillingInvoiceMutation) BillingInvoiceItemsCleared() bool {
	return m.clearedbilling_invoice_items
}

// RemoveBillingInvoiceItemIDs removes the "billing_invoice_items" edge to the BillingInvoiceItem entity by IDs.
func (m *BillingInvoiceMutation) RemoveBillingInvoiceItemIDs(ids ...string) {
	if m.removedbilling_invoice_items == nil {
		m.removedbilling_invoice_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_items, ids[i])
		m.removedbilling_invoice_items[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoiceItems returns the removed IDs of the "billing_invoice_items" edge to the BillingInvoiceItem entity.
func (m *BillingInvoiceMutation) RemovedBillingInvoiceItemsIDs() (ids []string) {
	for id := range m.removedbilling_invoice_items {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceItemsIDs returns the "billing_invoice_items" edge IDs in the mutation.
func (m *BillingInvoiceMutation) BillingInvoiceItemsIDs() (ids []string) {
	for id := range m.billing_invoice_items {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoiceItems resets all changes to the "billing_invoice_items" edge.
func (m *BillingInvoiceMutation) ResetBillingInvoiceItems() {
	m.billing_invoice_items = nil
	m.clearedbilling_invoice_items = false
	m.removedbilling_invoice_items = nil
}

// Where appends a list predicates to the BillingInvoiceMutation builder.
func (m *BillingInvoiceMutation) Where(ps ...predicate.BillingInvoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoice).
func (m *BillingInvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.namespace != nil {
		fields = append(fields, billinginvoice.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billinginvoice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billinginvoice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billinginvoice.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, billinginvoice.FieldMetadata)
	}
	if m.series != nil {
		fields = append(fields, billinginvoice.FieldSeries)
	}
	if m.code != nil {
		fields = append(fields, billinginvoice.FieldCode)
	}
	if m.customer_id != nil {
		fields = append(fields, billinginvoice.FieldCustomerID)
	}
	if m.billing_profile != nil {
		fields = append(fields, billinginvoice.FieldBillingProfileID)
	}
	if m.voided_at != nil {
		fields = append(fields, billinginvoice.FieldVoidedAt)
	}
	if m.currency != nil {
		fields = append(fields, billinginvoice.FieldCurrency)
	}
	if m.due_date != nil {
		fields = append(fields, billinginvoice.FieldDueDate)
	}
	if m.status != nil {
		fields = append(fields, billinginvoice.FieldStatus)
	}
	if m.tax_provider != nil {
		fields = append(fields, billinginvoice.FieldTaxProvider)
	}
	if m.invoicing_provider != nil {
		fields = append(fields, billinginvoice.FieldInvoicingProvider)
	}
	if m.payment_provider != nil {
		fields = append(fields, billinginvoice.FieldPaymentProvider)
	}
	if m.billing_workflow_config != nil {
		fields = append(fields, billinginvoice.FieldWorkflowConfigID)
	}
	if m.period_start != nil {
		fields = append(fields, billinginvoice.FieldPeriodStart)
	}
	if m.period_end != nil {
		fields = append(fields, billinginvoice.FieldPeriodEnd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoice.FieldNamespace:
		return m.Namespace()
	case billinginvoice.FieldCreatedAt:
		return m.CreatedAt()
	case billinginvoice.FieldUpdatedAt:
		return m.UpdatedAt()
	case billinginvoice.FieldDeletedAt:
		return m.DeletedAt()
	case billinginvoice.FieldMetadata:
		return m.Metadata()
	case billinginvoice.FieldSeries:
		return m.Series()
	case billinginvoice.FieldCode:
		return m.Code()
	case billinginvoice.FieldCustomerID:
		return m.CustomerID()
	case billinginvoice.FieldBillingProfileID:
		return m.BillingProfileID()
	case billinginvoice.FieldVoidedAt:
		return m.VoidedAt()
	case billinginvoice.FieldCurrency:
		return m.Currency()
	case billinginvoice.FieldDueDate:
		return m.DueDate()
	case billinginvoice.FieldStatus:
		return m.Status()
	case billinginvoice.FieldTaxProvider:
		return m.TaxProvider()
	case billinginvoice.FieldInvoicingProvider:
		return m.InvoicingProvider()
	case billinginvoice.FieldPaymentProvider:
		return m.PaymentProvider()
	case billinginvoice.FieldWorkflowConfigID:
		return m.WorkflowConfigID()
	case billinginvoice.FieldPeriodStart:
		return m.PeriodStart()
	case billinginvoice.FieldPeriodEnd:
		return m.PeriodEnd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoice.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billinginvoice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billinginvoice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billinginvoice.FieldMetadata:
		return m.OldMetadata(ctx)
	case billinginvoice.FieldSeries:
		return m.OldSeries(ctx)
	case billinginvoice.FieldCode:
		return m.OldCode(ctx)
	case billinginvoice.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case billinginvoice.FieldBillingProfileID:
		return m.OldBillingProfileID(ctx)
	case billinginvoice.FieldVoidedAt:
		return m.OldVoidedAt(ctx)
	case billinginvoice.FieldCurrency:
		return m.OldCurrency(ctx)
	case billinginvoice.FieldDueDate:
		return m.OldDueDate(ctx)
	case billinginvoice.FieldStatus:
		return m.OldStatus(ctx)
	case billinginvoice.FieldTaxProvider:
		return m.OldTaxProvider(ctx)
	case billinginvoice.FieldInvoicingProvider:
		return m.OldInvoicingProvider(ctx)
	case billinginvoice.FieldPaymentProvider:
		return m.OldPaymentProvider(ctx)
	case billinginvoice.FieldWorkflowConfigID:
		return m.OldWorkflowConfigID(ctx)
	case billinginvoice.FieldPeriodStart:
		return m.OldPeriodStart(ctx)
	case billinginvoice.FieldPeriodEnd:
		return m.OldPeriodEnd(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoice.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billinginvoice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billinginvoice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billinginvoice.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case billinginvoice.FieldSeries:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeries(v)
		return nil
	case billinginvoice.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case billinginvoice.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case billinginvoice.FieldBillingProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingProfileID(v)
		return nil
	case billinginvoice.FieldVoidedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidedAt(v)
		return nil
	case billinginvoice.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case billinginvoice.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case billinginvoice.FieldStatus:
		v, ok := value.(billing.InvoiceStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case billinginvoice.FieldTaxProvider:
		v, ok := value.(provider.TaxProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxProvider(v)
		return nil
	case billinginvoice.FieldInvoicingProvider:
		v, ok := value.(provider.InvoicingProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingProvider(v)
		return nil
	case billinginvoice.FieldPaymentProvider:
		v, ok := value.(provider.PaymentProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentProvider(v)
		return nil
	case billinginvoice.FieldWorkflowConfigID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowConfigID(v)
		return nil
	case billinginvoice.FieldPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodStart(v)
		return nil
	case billinginvoice.FieldPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodEnd(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoice.FieldDeletedAt) {
		fields = append(fields, billinginvoice.FieldDeletedAt)
	}
	if m.FieldCleared(billinginvoice.FieldMetadata) {
		fields = append(fields, billinginvoice.FieldMetadata)
	}
	if m.FieldCleared(billinginvoice.FieldSeries) {
		fields = append(fields, billinginvoice.FieldSeries)
	}
	if m.FieldCleared(billinginvoice.FieldCode) {
		fields = append(fields, billinginvoice.FieldCode)
	}
	if m.FieldCleared(billinginvoice.FieldVoidedAt) {
		fields = append(fields, billinginvoice.FieldVoidedAt)
	}
	if m.FieldCleared(billinginvoice.FieldTaxProvider) {
		fields = append(fields, billinginvoice.FieldTaxProvider)
	}
	if m.FieldCleared(billinginvoice.FieldInvoicingProvider) {
		fields = append(fields, billinginvoice.FieldInvoicingProvider)
	}
	if m.FieldCleared(billinginvoice.FieldPaymentProvider) {
		fields = append(fields, billinginvoice.FieldPaymentProvider)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceMutation) ClearField(name string) error {
	switch name {
	case billinginvoice.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billinginvoice.FieldMetadata:
		m.ClearMetadata()
		return nil
	case billinginvoice.FieldSeries:
		m.ClearSeries()
		return nil
	case billinginvoice.FieldCode:
		m.ClearCode()
		return nil
	case billinginvoice.FieldVoidedAt:
		m.ClearVoidedAt()
		return nil
	case billinginvoice.FieldTaxProvider:
		m.ClearTaxProvider()
		return nil
	case billinginvoice.FieldInvoicingProvider:
		m.ClearInvoicingProvider()
		return nil
	case billinginvoice.FieldPaymentProvider:
		m.ClearPaymentProvider()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceMutation) ResetField(name string) error {
	switch name {
	case billinginvoice.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billinginvoice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billinginvoice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billinginvoice.FieldMetadata:
		m.ResetMetadata()
		return nil
	case billinginvoice.FieldSeries:
		m.ResetSeries()
		return nil
	case billinginvoice.FieldCode:
		m.ResetCode()
		return nil
	case billinginvoice.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case billinginvoice.FieldBillingProfileID:
		m.ResetBillingProfileID()
		return nil
	case billinginvoice.FieldVoidedAt:
		m.ResetVoidedAt()
		return nil
	case billinginvoice.FieldCurrency:
		m.ResetCurrency()
		return nil
	case billinginvoice.FieldDueDate:
		m.ResetDueDate()
		return nil
	case billinginvoice.FieldStatus:
		m.ResetStatus()
		return nil
	case billinginvoice.FieldTaxProvider:
		m.ResetTaxProvider()
		return nil
	case billinginvoice.FieldInvoicingProvider:
		m.ResetInvoicingProvider()
		return nil
	case billinginvoice.FieldPaymentProvider:
		m.ResetPaymentProvider()
		return nil
	case billinginvoice.FieldWorkflowConfigID:
		m.ResetWorkflowConfigID()
		return nil
	case billinginvoice.FieldPeriodStart:
		m.ResetPeriodStart()
		return nil
	case billinginvoice.FieldPeriodEnd:
		m.ResetPeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.billing_profile != nil {
		edges = append(edges, billinginvoice.EdgeBillingProfile)
	}
	if m.billing_workflow_config != nil {
		edges = append(edges, billinginvoice.EdgeBillingWorkflowConfig)
	}
	if m.billing_invoice_items != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billinginvoice.EdgeBillingProfile:
		if id := m.billing_profile; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgeBillingWorkflowConfig:
		if id := m.billing_workflow_config; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgeBillingInvoiceItems:
		ids := make([]ent.Value, 0, len(m.billing_invoice_items))
		for id := range m.billing_invoice_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbilling_invoice_items != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billinginvoice.EdgeBillingInvoiceItems:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_items))
		for id := range m.removedbilling_invoice_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbilling_profile {
		edges = append(edges, billinginvoice.EdgeBillingProfile)
	}
	if m.clearedbilling_workflow_config {
		edges = append(edges, billinginvoice.EdgeBillingWorkflowConfig)
	}
	if m.clearedbilling_invoice_items {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case billinginvoice.EdgeBillingProfile:
		return m.clearedbilling_profile
	case billinginvoice.EdgeBillingWorkflowConfig:
		return m.clearedbilling_workflow_config
	case billinginvoice.EdgeBillingInvoiceItems:
		return m.clearedbilling_invoice_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceMutation) ClearEdge(name string) error {
	switch name {
	case billinginvoice.EdgeBillingProfile:
		m.ClearBillingProfile()
		return nil
	case billinginvoice.EdgeBillingWorkflowConfig:
		m.ClearBillingWorkflowConfig()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceMutation) ResetEdge(name string) error {
	switch name {
	case billinginvoice.EdgeBillingProfile:
		m.ResetBillingProfile()
		return nil
	case billinginvoice.EdgeBillingWorkflowConfig:
		m.ResetBillingWorkflowConfig()
		return nil
	case billinginvoice.EdgeBillingInvoiceItems:
		m.ResetBillingInvoiceItems()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice edge %s", name)
}

// BillingInvoiceItemMutation represents an operation that mutates the BillingInvoiceItem nodes in the graph.
type BillingInvoiceItemMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	namespace              *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	metadata               *map[string]string
	customer_id            *string
	period_start           *time.Time
	period_end             *time.Time
	invoice_at             *time.Time
	_type                  *billing.InvoiceItemType
	name                   *string
	quantity               *alpacadecimal.Decimal
	unit_price             *alpacadecimal.Decimal
	currency               *currencyx.Code
	tax_code_override      *billing.TaxOverrides
	clearedFields          map[string]struct{}
	billing_invoice        *string
	clearedbilling_invoice bool
	done                   bool
	oldValue               func(context.Context) (*BillingInvoiceItem, error)
	predicates             []predicate.BillingInvoiceItem
}

var _ ent.Mutation = (*BillingInvoiceItemMutation)(nil)

// billinginvoiceitemOption allows management of the mutation configuration using functional options.
type billinginvoiceitemOption func(*BillingInvoiceItemMutation)

// newBillingInvoiceItemMutation creates new mutation for the BillingInvoiceItem entity.
func newBillingInvoiceItemMutation(c config, op Op, opts ...billinginvoiceitemOption) *BillingInvoiceItemMutation {
	m := &BillingInvoiceItemMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoiceItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceItemID sets the ID field of the mutation.
func withBillingInvoiceItemID(id string) billinginvoiceitemOption {
	return func(m *BillingInvoiceItemMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoiceItem
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoiceItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoiceItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoiceItem sets the old BillingInvoiceItem of the mutation.
func withBillingInvoiceItem(node *BillingInvoiceItem) billinginvoiceitemOption {
	return func(m *BillingInvoiceItemMutation) {
		m.oldValue = func(context.Context) (*BillingInvoiceItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoiceItem entities.
func (m *BillingInvoiceItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoiceItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceItemMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceItemMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceItemMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingInvoiceItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingInvoiceItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingInvoiceItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingInvoiceItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingInvoiceItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingInvoiceItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingInvoiceItemMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingInvoiceItemMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingInvoiceItemMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billinginvoiceitem.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingInvoiceItemMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoiceitem.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingInvoiceItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billinginvoiceitem.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *BillingInvoiceItemMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *BillingInvoiceItemMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *BillingInvoiceItemMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[billinginvoiceitem.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *BillingInvoiceItemMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[billinginvoiceitem.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *BillingInvoiceItemMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, billinginvoiceitem.FieldMetadata)
}

// SetInvoiceID sets the "invoice_id" field.
func (m *BillingInvoiceItemMutation) SetInvoiceID(s string) {
	m.billing_invoice = &s
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *BillingInvoiceItemMutation) InvoiceID() (r string, exists bool) {
	v := m.billing_invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldInvoiceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// ClearInvoiceID clears the value of the "invoice_id" field.
func (m *BillingInvoiceItemMutation) ClearInvoiceID() {
	m.billing_invoice = nil
	m.clearedFields[billinginvoiceitem.FieldInvoiceID] = struct{}{}
}

// InvoiceIDCleared returns if the "invoice_id" field was cleared in this mutation.
func (m *BillingInvoiceItemMutation) InvoiceIDCleared() bool {
	_, ok := m.clearedFields[billinginvoiceitem.FieldInvoiceID]
	return ok
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *BillingInvoiceItemMutation) ResetInvoiceID() {
	m.billing_invoice = nil
	delete(m.clearedFields, billinginvoiceitem.FieldInvoiceID)
}

// SetCustomerID sets the "customer_id" field.
func (m *BillingInvoiceItemMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *BillingInvoiceItemMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *BillingInvoiceItemMutation) ResetCustomerID() {
	m.customer_id = nil
}

// SetPeriodStart sets the "period_start" field.
func (m *BillingInvoiceItemMutation) SetPeriodStart(t time.Time) {
	m.period_start = &t
}

// PeriodStart returns the value of the "period_start" field in the mutation.
func (m *BillingInvoiceItemMutation) PeriodStart() (r time.Time, exists bool) {
	v := m.period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodStart returns the old "period_start" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldPeriodStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodStart: %w", err)
	}
	return oldValue.PeriodStart, nil
}

// ResetPeriodStart resets all changes to the "period_start" field.
func (m *BillingInvoiceItemMutation) ResetPeriodStart() {
	m.period_start = nil
}

// SetPeriodEnd sets the "period_end" field.
func (m *BillingInvoiceItemMutation) SetPeriodEnd(t time.Time) {
	m.period_end = &t
}

// PeriodEnd returns the value of the "period_end" field in the mutation.
func (m *BillingInvoiceItemMutation) PeriodEnd() (r time.Time, exists bool) {
	v := m.period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodEnd returns the old "period_end" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldPeriodEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodEnd: %w", err)
	}
	return oldValue.PeriodEnd, nil
}

// ResetPeriodEnd resets all changes to the "period_end" field.
func (m *BillingInvoiceItemMutation) ResetPeriodEnd() {
	m.period_end = nil
}

// SetInvoiceAt sets the "invoice_at" field.
func (m *BillingInvoiceItemMutation) SetInvoiceAt(t time.Time) {
	m.invoice_at = &t
}

// InvoiceAt returns the value of the "invoice_at" field in the mutation.
func (m *BillingInvoiceItemMutation) InvoiceAt() (r time.Time, exists bool) {
	v := m.invoice_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceAt returns the old "invoice_at" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldInvoiceAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceAt: %w", err)
	}
	return oldValue.InvoiceAt, nil
}

// ResetInvoiceAt resets all changes to the "invoice_at" field.
func (m *BillingInvoiceItemMutation) ResetInvoiceAt() {
	m.invoice_at = nil
}

// SetType sets the "type" field.
func (m *BillingInvoiceItemMutation) SetType(bit billing.InvoiceItemType) {
	m._type = &bit
}

// GetType returns the value of the "type" field in the mutation.
func (m *BillingInvoiceItemMutation) GetType() (r billing.InvoiceItemType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldType(ctx context.Context) (v billing.InvoiceItemType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BillingInvoiceItemMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *BillingInvoiceItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BillingInvoiceItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BillingInvoiceItemMutation) ResetName() {
	m.name = nil
}

// SetQuantity sets the "quantity" field.
func (m *BillingInvoiceItemMutation) SetQuantity(a alpacadecimal.Decimal) {
	m.quantity = &a
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *BillingInvoiceItemMutation) Quantity() (r alpacadecimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldQuantity(ctx context.Context) (v *alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ClearQuantity clears the value of the "quantity" field.
func (m *BillingInvoiceItemMutation) ClearQuantity() {
	m.quantity = nil
	m.clearedFields[billinginvoiceitem.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *BillingInvoiceItemMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[billinginvoiceitem.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *BillingInvoiceItemMutation) ResetQuantity() {
	m.quantity = nil
	delete(m.clearedFields, billinginvoiceitem.FieldQuantity)
}

// SetUnitPrice sets the "unit_price" field.
func (m *BillingInvoiceItemMutation) SetUnitPrice(a alpacadecimal.Decimal) {
	m.unit_price = &a
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *BillingInvoiceItemMutation) UnitPrice() (r alpacadecimal.Decimal, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldUnitPrice(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *BillingInvoiceItemMutation) ResetUnitPrice() {
	m.unit_price = nil
}

// SetCurrency sets the "currency" field.
func (m *BillingInvoiceItemMutation) SetCurrency(c currencyx.Code) {
	m.currency = &c
}

// Currency returns the value of the "currency" field in the mutation.
func (m *BillingInvoiceItemMutation) Currency() (r currencyx.Code, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldCurrency(ctx context.Context) (v currencyx.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *BillingInvoiceItemMutation) ResetCurrency() {
	m.currency = nil
}

// SetTaxCodeOverride sets the "tax_code_override" field.
func (m *BillingInvoiceItemMutation) SetTaxCodeOverride(bo billing.TaxOverrides) {
	m.tax_code_override = &bo
}

// TaxCodeOverride returns the value of the "tax_code_override" field in the mutation.
func (m *BillingInvoiceItemMutation) TaxCodeOverride() (r billing.TaxOverrides, exists bool) {
	v := m.tax_code_override
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxCodeOverride returns the old "tax_code_override" field's value of the BillingInvoiceItem entity.
// If the BillingInvoiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceItemMutation) OldTaxCodeOverride(ctx context.Context) (v billing.TaxOverrides, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxCodeOverride is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxCodeOverride requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxCodeOverride: %w", err)
	}
	return oldValue.TaxCodeOverride, nil
}

// ResetTaxCodeOverride resets all changes to the "tax_code_override" field.
func (m *BillingInvoiceItemMutation) ResetTaxCodeOverride() {
	m.tax_code_override = nil
}

// SetBillingInvoiceID sets the "billing_invoice" edge to the BillingInvoice entity by id.
func (m *BillingInvoiceItemMutation) SetBillingInvoiceID(id string) {
	m.billing_invoice = &id
}

// ClearBillingInvoice clears the "billing_invoice" edge to the BillingInvoice entity.
func (m *BillingInvoiceItemMutation) ClearBillingInvoice() {
	m.clearedbilling_invoice = true
	m.clearedFields[billinginvoiceitem.FieldInvoiceID] = struct{}{}
}

// BillingInvoiceCleared reports if the "billing_invoice" edge to the BillingInvoice entity was cleared.
func (m *BillingInvoiceItemMutation) BillingInvoiceCleared() bool {
	return m.InvoiceIDCleared() || m.clearedbilling_invoice
}

// BillingInvoiceID returns the "billing_invoice" edge ID in the mutation.
func (m *BillingInvoiceItemMutation) BillingInvoiceID() (id string, exists bool) {
	if m.billing_invoice != nil {
		return *m.billing_invoice, true
	}
	return
}

// BillingInvoiceIDs returns the "billing_invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoiceID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceItemMutation) BillingInvoiceIDs() (ids []string) {
	if id := m.billing_invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoice resets all changes to the "billing_invoice" edge.
func (m *BillingInvoiceItemMutation) ResetBillingInvoice() {
	m.billing_invoice = nil
	m.clearedbilling_invoice = false
}

// Where appends a list predicates to the BillingInvoiceItemMutation builder.
func (m *BillingInvoiceItemMutation) Where(ps ...predicate.BillingInvoiceItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoiceItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoiceItem).
func (m *BillingInvoiceItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceItemMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.namespace != nil {
		fields = append(fields, billinginvoiceitem.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billinginvoiceitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billinginvoiceitem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billinginvoiceitem.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, billinginvoiceitem.FieldMetadata)
	}
	if m.billing_invoice != nil {
		fields = append(fields, billinginvoiceitem.FieldInvoiceID)
	}
	if m.customer_id != nil {
		fields = append(fields, billinginvoiceitem.FieldCustomerID)
	}
	if m.period_start != nil {
		fields = append(fields, billinginvoiceitem.FieldPeriodStart)
	}
	if m.period_end != nil {
		fields = append(fields, billinginvoiceitem.FieldPeriodEnd)
	}
	if m.invoice_at != nil {
		fields = append(fields, billinginvoiceitem.FieldInvoiceAt)
	}
	if m._type != nil {
		fields = append(fields, billinginvoiceitem.FieldType)
	}
	if m.name != nil {
		fields = append(fields, billinginvoiceitem.FieldName)
	}
	if m.quantity != nil {
		fields = append(fields, billinginvoiceitem.FieldQuantity)
	}
	if m.unit_price != nil {
		fields = append(fields, billinginvoiceitem.FieldUnitPrice)
	}
	if m.currency != nil {
		fields = append(fields, billinginvoiceitem.FieldCurrency)
	}
	if m.tax_code_override != nil {
		fields = append(fields, billinginvoiceitem.FieldTaxCodeOverride)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoiceitem.FieldNamespace:
		return m.Namespace()
	case billinginvoiceitem.FieldCreatedAt:
		return m.CreatedAt()
	case billinginvoiceitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case billinginvoiceitem.FieldDeletedAt:
		return m.DeletedAt()
	case billinginvoiceitem.FieldMetadata:
		return m.Metadata()
	case billinginvoiceitem.FieldInvoiceID:
		return m.InvoiceID()
	case billinginvoiceitem.FieldCustomerID:
		return m.CustomerID()
	case billinginvoiceitem.FieldPeriodStart:
		return m.PeriodStart()
	case billinginvoiceitem.FieldPeriodEnd:
		return m.PeriodEnd()
	case billinginvoiceitem.FieldInvoiceAt:
		return m.InvoiceAt()
	case billinginvoiceitem.FieldType:
		return m.GetType()
	case billinginvoiceitem.FieldName:
		return m.Name()
	case billinginvoiceitem.FieldQuantity:
		return m.Quantity()
	case billinginvoiceitem.FieldUnitPrice:
		return m.UnitPrice()
	case billinginvoiceitem.FieldCurrency:
		return m.Currency()
	case billinginvoiceitem.FieldTaxCodeOverride:
		return m.TaxCodeOverride()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoiceitem.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoiceitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billinginvoiceitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billinginvoiceitem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billinginvoiceitem.FieldMetadata:
		return m.OldMetadata(ctx)
	case billinginvoiceitem.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	case billinginvoiceitem.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case billinginvoiceitem.FieldPeriodStart:
		return m.OldPeriodStart(ctx)
	case billinginvoiceitem.FieldPeriodEnd:
		return m.OldPeriodEnd(ctx)
	case billinginvoiceitem.FieldInvoiceAt:
		return m.OldInvoiceAt(ctx)
	case billinginvoiceitem.FieldType:
		return m.OldType(ctx)
	case billinginvoiceitem.FieldName:
		return m.OldName(ctx)
	case billinginvoiceitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case billinginvoiceitem.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case billinginvoiceitem.FieldCurrency:
		return m.OldCurrency(ctx)
	case billinginvoiceitem.FieldTaxCodeOverride:
		return m.OldTaxCodeOverride(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoiceItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoiceitem.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoiceitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billinginvoiceitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billinginvoiceitem.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billinginvoiceitem.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case billinginvoiceitem.FieldInvoiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	case billinginvoiceitem.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case billinginvoiceitem.FieldPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodStart(v)
		return nil
	case billinginvoiceitem.FieldPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodEnd(v)
		return nil
	case billinginvoiceitem.FieldInvoiceAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceAt(v)
		return nil
	case billinginvoiceitem.FieldType:
		v, ok := value.(billing.InvoiceItemType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case billinginvoiceitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case billinginvoiceitem.FieldQuantity:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case billinginvoiceitem.FieldUnitPrice:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case billinginvoiceitem.FieldCurrency:
		v, ok := value.(currencyx.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case billinginvoiceitem.FieldTaxCodeOverride:
		v, ok := value.(billing.TaxOverrides)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxCodeOverride(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoiceItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoiceitem.FieldDeletedAt) {
		fields = append(fields, billinginvoiceitem.FieldDeletedAt)
	}
	if m.FieldCleared(billinginvoiceitem.FieldMetadata) {
		fields = append(fields, billinginvoiceitem.FieldMetadata)
	}
	if m.FieldCleared(billinginvoiceitem.FieldInvoiceID) {
		fields = append(fields, billinginvoiceitem.FieldInvoiceID)
	}
	if m.FieldCleared(billinginvoiceitem.FieldQuantity) {
		fields = append(fields, billinginvoiceitem.FieldQuantity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceItemMutation) ClearField(name string) error {
	switch name {
	case billinginvoiceitem.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billinginvoiceitem.FieldMetadata:
		m.ClearMetadata()
		return nil
	case billinginvoiceitem.FieldInvoiceID:
		m.ClearInvoiceID()
		return nil
	case billinginvoiceitem.FieldQuantity:
		m.ClearQuantity()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceItemMutation) ResetField(name string) error {
	switch name {
	case billinginvoiceitem.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoiceitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billinginvoiceitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billinginvoiceitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billinginvoiceitem.FieldMetadata:
		m.ResetMetadata()
		return nil
	case billinginvoiceitem.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	case billinginvoiceitem.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case billinginvoiceitem.FieldPeriodStart:
		m.ResetPeriodStart()
		return nil
	case billinginvoiceitem.FieldPeriodEnd:
		m.ResetPeriodEnd()
		return nil
	case billinginvoiceitem.FieldInvoiceAt:
		m.ResetInvoiceAt()
		return nil
	case billinginvoiceitem.FieldType:
		m.ResetType()
		return nil
	case billinginvoiceitem.FieldName:
		m.ResetName()
		return nil
	case billinginvoiceitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case billinginvoiceitem.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case billinginvoiceitem.FieldCurrency:
		m.ResetCurrency()
		return nil
	case billinginvoiceitem.FieldTaxCodeOverride:
		m.ResetTaxCodeOverride()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.billing_invoice != nil {
		edges = append(edges, billinginvoiceitem.EdgeBillingInvoice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billinginvoiceitem.EdgeBillingInvoice:
		if id := m.billing_invoice; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbilling_invoice {
		edges = append(edges, billinginvoiceitem.EdgeBillingInvoice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceItemMutation) EdgeCleared(name string) bool {
	switch name {
	case billinginvoiceitem.EdgeBillingInvoice:
		return m.clearedbilling_invoice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceItemMutation) ClearEdge(name string) error {
	switch name {
	case billinginvoiceitem.EdgeBillingInvoice:
		m.ClearBillingInvoice()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceItemMutation) ResetEdge(name string) error {
	switch name {
	case billinginvoiceitem.EdgeBillingInvoice:
		m.ResetBillingInvoice()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceItem edge %s", name)
}

// BillingProfileMutation represents an operation that mutates the BillingProfile nodes in the graph.
type BillingProfileMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	namespace                        *string
	metadata                         *map[string]string
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	supplier_address_country         *models.CountryCode
	supplier_address_postal_code     *string
	supplier_address_state           *string
	supplier_address_city            *string
	supplier_address_line1           *string
	supplier_address_line2           *string
	supplier_address_phone_number    *string
	tax_provider                     *provider.TaxProvider
	invoicing_provider               *provider.InvoicingProvider
	payment_provider                 *provider.PaymentProvider
	_default                         *bool
	supplier_name                    *string
	clearedFields                    map[string]struct{}
	billing_invoices                 map[string]struct{}
	removedbilling_invoices          map[string]struct{}
	clearedbilling_invoices          bool
	billing_customer_override        map[string]struct{}
	removedbilling_customer_override map[string]struct{}
	clearedbilling_customer_override bool
	workflow_config                  *string
	clearedworkflow_config           bool
	done                             bool
	oldValue                         func(context.Context) (*BillingProfile, error)
	predicates                       []predicate.BillingProfile
}

var _ ent.Mutation = (*BillingProfileMutation)(nil)

// billingprofileOption allows management of the mutation configuration using functional options.
type billingprofileOption func(*BillingProfileMutation)

// newBillingProfileMutation creates new mutation for the BillingProfile entity.
func newBillingProfileMutation(c config, op Op, opts ...billingprofileOption) *BillingProfileMutation {
	m := &BillingProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingProfileID sets the ID field of the mutation.
func withBillingProfileID(id string) billingprofileOption {
	return func(m *BillingProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingProfile
		)
		m.oldValue = func(ctx context.Context) (*BillingProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingProfile sets the old BillingProfile of the mutation.
func withBillingProfile(node *BillingProfile) billingprofileOption {
	return func(m *BillingProfileMutation) {
		m.oldValue = func(context.Context) (*BillingProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingProfile entities.
func (m *BillingProfileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingProfileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingProfileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingProfileMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingProfileMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingProfileMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *BillingProfileMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *BillingProfileMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *BillingProfileMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[billingprofile.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *BillingProfileMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *BillingProfileMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, billingprofile.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingProfileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingProfileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingProfileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billingprofile.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingProfileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingProfileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billingprofile.FieldDeletedAt)
}

// SetSupplierAddressCountry sets the "supplier_address_country" field.
func (m *BillingProfileMutation) SetSupplierAddressCountry(mc models.CountryCode) {
	m.supplier_address_country = &mc
}

// SupplierAddressCountry returns the value of the "supplier_address_country" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressCountry() (r models.CountryCode, exists bool) {
	v := m.supplier_address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressCountry returns the old "supplier_address_country" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressCountry(ctx context.Context) (v *models.CountryCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressCountry: %w", err)
	}
	return oldValue.SupplierAddressCountry, nil
}

// ClearSupplierAddressCountry clears the value of the "supplier_address_country" field.
func (m *BillingProfileMutation) ClearSupplierAddressCountry() {
	m.supplier_address_country = nil
	m.clearedFields[billingprofile.FieldSupplierAddressCountry] = struct{}{}
}

// SupplierAddressCountryCleared returns if the "supplier_address_country" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressCountryCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressCountry]
	return ok
}

// ResetSupplierAddressCountry resets all changes to the "supplier_address_country" field.
func (m *BillingProfileMutation) ResetSupplierAddressCountry() {
	m.supplier_address_country = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressCountry)
}

// SetSupplierAddressPostalCode sets the "supplier_address_postal_code" field.
func (m *BillingProfileMutation) SetSupplierAddressPostalCode(s string) {
	m.supplier_address_postal_code = &s
}

// SupplierAddressPostalCode returns the value of the "supplier_address_postal_code" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressPostalCode() (r string, exists bool) {
	v := m.supplier_address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressPostalCode returns the old "supplier_address_postal_code" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressPostalCode: %w", err)
	}
	return oldValue.SupplierAddressPostalCode, nil
}

// ClearSupplierAddressPostalCode clears the value of the "supplier_address_postal_code" field.
func (m *BillingProfileMutation) ClearSupplierAddressPostalCode() {
	m.supplier_address_postal_code = nil
	m.clearedFields[billingprofile.FieldSupplierAddressPostalCode] = struct{}{}
}

// SupplierAddressPostalCodeCleared returns if the "supplier_address_postal_code" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressPostalCode]
	return ok
}

// ResetSupplierAddressPostalCode resets all changes to the "supplier_address_postal_code" field.
func (m *BillingProfileMutation) ResetSupplierAddressPostalCode() {
	m.supplier_address_postal_code = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressPostalCode)
}

// SetSupplierAddressState sets the "supplier_address_state" field.
func (m *BillingProfileMutation) SetSupplierAddressState(s string) {
	m.supplier_address_state = &s
}

// SupplierAddressState returns the value of the "supplier_address_state" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressState() (r string, exists bool) {
	v := m.supplier_address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressState returns the old "supplier_address_state" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressState: %w", err)
	}
	return oldValue.SupplierAddressState, nil
}

// ClearSupplierAddressState clears the value of the "supplier_address_state" field.
func (m *BillingProfileMutation) ClearSupplierAddressState() {
	m.supplier_address_state = nil
	m.clearedFields[billingprofile.FieldSupplierAddressState] = struct{}{}
}

// SupplierAddressStateCleared returns if the "supplier_address_state" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressStateCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressState]
	return ok
}

// ResetSupplierAddressState resets all changes to the "supplier_address_state" field.
func (m *BillingProfileMutation) ResetSupplierAddressState() {
	m.supplier_address_state = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressState)
}

// SetSupplierAddressCity sets the "supplier_address_city" field.
func (m *BillingProfileMutation) SetSupplierAddressCity(s string) {
	m.supplier_address_city = &s
}

// SupplierAddressCity returns the value of the "supplier_address_city" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressCity() (r string, exists bool) {
	v := m.supplier_address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressCity returns the old "supplier_address_city" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressCity: %w", err)
	}
	return oldValue.SupplierAddressCity, nil
}

// ClearSupplierAddressCity clears the value of the "supplier_address_city" field.
func (m *BillingProfileMutation) ClearSupplierAddressCity() {
	m.supplier_address_city = nil
	m.clearedFields[billingprofile.FieldSupplierAddressCity] = struct{}{}
}

// SupplierAddressCityCleared returns if the "supplier_address_city" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressCityCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressCity]
	return ok
}

// ResetSupplierAddressCity resets all changes to the "supplier_address_city" field.
func (m *BillingProfileMutation) ResetSupplierAddressCity() {
	m.supplier_address_city = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressCity)
}

// SetSupplierAddressLine1 sets the "supplier_address_line1" field.
func (m *BillingProfileMutation) SetSupplierAddressLine1(s string) {
	m.supplier_address_line1 = &s
}

// SupplierAddressLine1 returns the value of the "supplier_address_line1" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressLine1() (r string, exists bool) {
	v := m.supplier_address_line1
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressLine1 returns the old "supplier_address_line1" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressLine1: %w", err)
	}
	return oldValue.SupplierAddressLine1, nil
}

// ClearSupplierAddressLine1 clears the value of the "supplier_address_line1" field.
func (m *BillingProfileMutation) ClearSupplierAddressLine1() {
	m.supplier_address_line1 = nil
	m.clearedFields[billingprofile.FieldSupplierAddressLine1] = struct{}{}
}

// SupplierAddressLine1Cleared returns if the "supplier_address_line1" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressLine1Cleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressLine1]
	return ok
}

// ResetSupplierAddressLine1 resets all changes to the "supplier_address_line1" field.
func (m *BillingProfileMutation) ResetSupplierAddressLine1() {
	m.supplier_address_line1 = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressLine1)
}

// SetSupplierAddressLine2 sets the "supplier_address_line2" field.
func (m *BillingProfileMutation) SetSupplierAddressLine2(s string) {
	m.supplier_address_line2 = &s
}

// SupplierAddressLine2 returns the value of the "supplier_address_line2" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressLine2() (r string, exists bool) {
	v := m.supplier_address_line2
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressLine2 returns the old "supplier_address_line2" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressLine2: %w", err)
	}
	return oldValue.SupplierAddressLine2, nil
}

// ClearSupplierAddressLine2 clears the value of the "supplier_address_line2" field.
func (m *BillingProfileMutation) ClearSupplierAddressLine2() {
	m.supplier_address_line2 = nil
	m.clearedFields[billingprofile.FieldSupplierAddressLine2] = struct{}{}
}

// SupplierAddressLine2Cleared returns if the "supplier_address_line2" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressLine2Cleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressLine2]
	return ok
}

// ResetSupplierAddressLine2 resets all changes to the "supplier_address_line2" field.
func (m *BillingProfileMutation) ResetSupplierAddressLine2() {
	m.supplier_address_line2 = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressLine2)
}

// SetSupplierAddressPhoneNumber sets the "supplier_address_phone_number" field.
func (m *BillingProfileMutation) SetSupplierAddressPhoneNumber(s string) {
	m.supplier_address_phone_number = &s
}

// SupplierAddressPhoneNumber returns the value of the "supplier_address_phone_number" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressPhoneNumber() (r string, exists bool) {
	v := m.supplier_address_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressPhoneNumber returns the old "supplier_address_phone_number" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressPhoneNumber: %w", err)
	}
	return oldValue.SupplierAddressPhoneNumber, nil
}

// ClearSupplierAddressPhoneNumber clears the value of the "supplier_address_phone_number" field.
func (m *BillingProfileMutation) ClearSupplierAddressPhoneNumber() {
	m.supplier_address_phone_number = nil
	m.clearedFields[billingprofile.FieldSupplierAddressPhoneNumber] = struct{}{}
}

// SupplierAddressPhoneNumberCleared returns if the "supplier_address_phone_number" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressPhoneNumberCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressPhoneNumber]
	return ok
}

// ResetSupplierAddressPhoneNumber resets all changes to the "supplier_address_phone_number" field.
func (m *BillingProfileMutation) ResetSupplierAddressPhoneNumber() {
	m.supplier_address_phone_number = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressPhoneNumber)
}

// SetTaxProvider sets the "tax_provider" field.
func (m *BillingProfileMutation) SetTaxProvider(pp provider.TaxProvider) {
	m.tax_provider = &pp
}

// TaxProvider returns the value of the "tax_provider" field in the mutation.
func (m *BillingProfileMutation) TaxProvider() (r provider.TaxProvider, exists bool) {
	v := m.tax_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxProvider returns the old "tax_provider" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldTaxProvider(ctx context.Context) (v provider.TaxProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxProvider: %w", err)
	}
	return oldValue.TaxProvider, nil
}

// ResetTaxProvider resets all changes to the "tax_provider" field.
func (m *BillingProfileMutation) ResetTaxProvider() {
	m.tax_provider = nil
}

// SetInvoicingProvider sets the "invoicing_provider" field.
func (m *BillingProfileMutation) SetInvoicingProvider(pp provider.InvoicingProvider) {
	m.invoicing_provider = &pp
}

// InvoicingProvider returns the value of the "invoicing_provider" field in the mutation.
func (m *BillingProfileMutation) InvoicingProvider() (r provider.InvoicingProvider, exists bool) {
	v := m.invoicing_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingProvider returns the old "invoicing_provider" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldInvoicingProvider(ctx context.Context) (v provider.InvoicingProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingProvider: %w", err)
	}
	return oldValue.InvoicingProvider, nil
}

// ResetInvoicingProvider resets all changes to the "invoicing_provider" field.
func (m *BillingProfileMutation) ResetInvoicingProvider() {
	m.invoicing_provider = nil
}

// SetPaymentProvider sets the "payment_provider" field.
func (m *BillingProfileMutation) SetPaymentProvider(pp provider.PaymentProvider) {
	m.payment_provider = &pp
}

// PaymentProvider returns the value of the "payment_provider" field in the mutation.
func (m *BillingProfileMutation) PaymentProvider() (r provider.PaymentProvider, exists bool) {
	v := m.payment_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentProvider returns the old "payment_provider" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldPaymentProvider(ctx context.Context) (v provider.PaymentProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentProvider: %w", err)
	}
	return oldValue.PaymentProvider, nil
}

// ResetPaymentProvider resets all changes to the "payment_provider" field.
func (m *BillingProfileMutation) ResetPaymentProvider() {
	m.payment_provider = nil
}

// SetWorkflowConfigID sets the "workflow_config_id" field.
func (m *BillingProfileMutation) SetWorkflowConfigID(s string) {
	m.workflow_config = &s
}

// WorkflowConfigID returns the value of the "workflow_config_id" field in the mutation.
func (m *BillingProfileMutation) WorkflowConfigID() (r string, exists bool) {
	v := m.workflow_config
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowConfigID returns the old "workflow_config_id" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldWorkflowConfigID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowConfigID: %w", err)
	}
	return oldValue.WorkflowConfigID, nil
}

// ResetWorkflowConfigID resets all changes to the "workflow_config_id" field.
func (m *BillingProfileMutation) ResetWorkflowConfigID() {
	m.workflow_config = nil
}

// SetDefault sets the "default" field.
func (m *BillingProfileMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *BillingProfileMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *BillingProfileMutation) ResetDefault() {
	m._default = nil
}

// SetSupplierName sets the "supplier_name" field.
func (m *BillingProfileMutation) SetSupplierName(s string) {
	m.supplier_name = &s
}

// SupplierName returns the value of the "supplier_name" field in the mutation.
func (m *BillingProfileMutation) SupplierName() (r string, exists bool) {
	v := m.supplier_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierName returns the old "supplier_name" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierName: %w", err)
	}
	return oldValue.SupplierName, nil
}

// ResetSupplierName resets all changes to the "supplier_name" field.
func (m *BillingProfileMutation) ResetSupplierName() {
	m.supplier_name = nil
}

// AddBillingInvoiceIDs adds the "billing_invoices" edge to the BillingInvoice entity by ids.
func (m *BillingProfileMutation) AddBillingInvoiceIDs(ids ...string) {
	if m.billing_invoices == nil {
		m.billing_invoices = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoices[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoices clears the "billing_invoices" edge to the BillingInvoice entity.
func (m *BillingProfileMutation) ClearBillingInvoices() {
	m.clearedbilling_invoices = true
}

// BillingInvoicesCleared reports if the "billing_invoices" edge to the BillingInvoice entity was cleared.
func (m *BillingProfileMutation) BillingInvoicesCleared() bool {
	return m.clearedbilling_invoices
}

// RemoveBillingInvoiceIDs removes the "billing_invoices" edge to the BillingInvoice entity by IDs.
func (m *BillingProfileMutation) RemoveBillingInvoiceIDs(ids ...string) {
	if m.removedbilling_invoices == nil {
		m.removedbilling_invoices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoices, ids[i])
		m.removedbilling_invoices[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoices returns the removed IDs of the "billing_invoices" edge to the BillingInvoice entity.
func (m *BillingProfileMutation) RemovedBillingInvoicesIDs() (ids []string) {
	for id := range m.removedbilling_invoices {
		ids = append(ids, id)
	}
	return
}

// BillingInvoicesIDs returns the "billing_invoices" edge IDs in the mutation.
func (m *BillingProfileMutation) BillingInvoicesIDs() (ids []string) {
	for id := range m.billing_invoices {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoices resets all changes to the "billing_invoices" edge.
func (m *BillingProfileMutation) ResetBillingInvoices() {
	m.billing_invoices = nil
	m.clearedbilling_invoices = false
	m.removedbilling_invoices = nil
}

// AddBillingCustomerOverrideIDs adds the "billing_customer_override" edge to the BillingCustomerOverride entity by ids.
func (m *BillingProfileMutation) AddBillingCustomerOverrideIDs(ids ...string) {
	if m.billing_customer_override == nil {
		m.billing_customer_override = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_customer_override[ids[i]] = struct{}{}
	}
}

// ClearBillingCustomerOverride clears the "billing_customer_override" edge to the BillingCustomerOverride entity.
func (m *BillingProfileMutation) ClearBillingCustomerOverride() {
	m.clearedbilling_customer_override = true
}

// BillingCustomerOverrideCleared reports if the "billing_customer_override" edge to the BillingCustomerOverride entity was cleared.
func (m *BillingProfileMutation) BillingCustomerOverrideCleared() bool {
	return m.clearedbilling_customer_override
}

// RemoveBillingCustomerOverrideIDs removes the "billing_customer_override" edge to the BillingCustomerOverride entity by IDs.
func (m *BillingProfileMutation) RemoveBillingCustomerOverrideIDs(ids ...string) {
	if m.removedbilling_customer_override == nil {
		m.removedbilling_customer_override = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_customer_override, ids[i])
		m.removedbilling_customer_override[ids[i]] = struct{}{}
	}
}

// RemovedBillingCustomerOverride returns the removed IDs of the "billing_customer_override" edge to the BillingCustomerOverride entity.
func (m *BillingProfileMutation) RemovedBillingCustomerOverrideIDs() (ids []string) {
	for id := range m.removedbilling_customer_override {
		ids = append(ids, id)
	}
	return
}

// BillingCustomerOverrideIDs returns the "billing_customer_override" edge IDs in the mutation.
func (m *BillingProfileMutation) BillingCustomerOverrideIDs() (ids []string) {
	for id := range m.billing_customer_override {
		ids = append(ids, id)
	}
	return
}

// ResetBillingCustomerOverride resets all changes to the "billing_customer_override" edge.
func (m *BillingProfileMutation) ResetBillingCustomerOverride() {
	m.billing_customer_override = nil
	m.clearedbilling_customer_override = false
	m.removedbilling_customer_override = nil
}

// ClearWorkflowConfig clears the "workflow_config" edge to the BillingWorkflowConfig entity.
func (m *BillingProfileMutation) ClearWorkflowConfig() {
	m.clearedworkflow_config = true
	m.clearedFields[billingprofile.FieldWorkflowConfigID] = struct{}{}
}

// WorkflowConfigCleared reports if the "workflow_config" edge to the BillingWorkflowConfig entity was cleared.
func (m *BillingProfileMutation) WorkflowConfigCleared() bool {
	return m.clearedworkflow_config
}

// WorkflowConfigIDs returns the "workflow_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowConfigID instead. It exists only for internal usage by the builders.
func (m *BillingProfileMutation) WorkflowConfigIDs() (ids []string) {
	if id := m.workflow_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowConfig resets all changes to the "workflow_config" edge.
func (m *BillingProfileMutation) ResetWorkflowConfig() {
	m.workflow_config = nil
	m.clearedworkflow_config = false
}

// Where appends a list predicates to the BillingProfileMutation builder.
func (m *BillingProfileMutation) Where(ps ...predicate.BillingProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingProfile).
func (m *BillingProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingProfileMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.namespace != nil {
		fields = append(fields, billingprofile.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, billingprofile.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, billingprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingprofile.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billingprofile.FieldDeletedAt)
	}
	if m.supplier_address_country != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressCountry)
	}
	if m.supplier_address_postal_code != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressPostalCode)
	}
	if m.supplier_address_state != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressState)
	}
	if m.supplier_address_city != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressCity)
	}
	if m.supplier_address_line1 != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressLine1)
	}
	if m.supplier_address_line2 != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressLine2)
	}
	if m.supplier_address_phone_number != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressPhoneNumber)
	}
	if m.tax_provider != nil {
		fields = append(fields, billingprofile.FieldTaxProvider)
	}
	if m.invoicing_provider != nil {
		fields = append(fields, billingprofile.FieldInvoicingProvider)
	}
	if m.payment_provider != nil {
		fields = append(fields, billingprofile.FieldPaymentProvider)
	}
	if m.workflow_config != nil {
		fields = append(fields, billingprofile.FieldWorkflowConfigID)
	}
	if m._default != nil {
		fields = append(fields, billingprofile.FieldDefault)
	}
	if m.supplier_name != nil {
		fields = append(fields, billingprofile.FieldSupplierName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingprofile.FieldNamespace:
		return m.Namespace()
	case billingprofile.FieldMetadata:
		return m.Metadata()
	case billingprofile.FieldCreatedAt:
		return m.CreatedAt()
	case billingprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingprofile.FieldDeletedAt:
		return m.DeletedAt()
	case billingprofile.FieldSupplierAddressCountry:
		return m.SupplierAddressCountry()
	case billingprofile.FieldSupplierAddressPostalCode:
		return m.SupplierAddressPostalCode()
	case billingprofile.FieldSupplierAddressState:
		return m.SupplierAddressState()
	case billingprofile.FieldSupplierAddressCity:
		return m.SupplierAddressCity()
	case billingprofile.FieldSupplierAddressLine1:
		return m.SupplierAddressLine1()
	case billingprofile.FieldSupplierAddressLine2:
		return m.SupplierAddressLine2()
	case billingprofile.FieldSupplierAddressPhoneNumber:
		return m.SupplierAddressPhoneNumber()
	case billingprofile.FieldTaxProvider:
		return m.TaxProvider()
	case billingprofile.FieldInvoicingProvider:
		return m.InvoicingProvider()
	case billingprofile.FieldPaymentProvider:
		return m.PaymentProvider()
	case billingprofile.FieldWorkflowConfigID:
		return m.WorkflowConfigID()
	case billingprofile.FieldDefault:
		return m.Default()
	case billingprofile.FieldSupplierName:
		return m.SupplierName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingprofile.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingprofile.FieldMetadata:
		return m.OldMetadata(ctx)
	case billingprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingprofile.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billingprofile.FieldSupplierAddressCountry:
		return m.OldSupplierAddressCountry(ctx)
	case billingprofile.FieldSupplierAddressPostalCode:
		return m.OldSupplierAddressPostalCode(ctx)
	case billingprofile.FieldSupplierAddressState:
		return m.OldSupplierAddressState(ctx)
	case billingprofile.FieldSupplierAddressCity:
		return m.OldSupplierAddressCity(ctx)
	case billingprofile.FieldSupplierAddressLine1:
		return m.OldSupplierAddressLine1(ctx)
	case billingprofile.FieldSupplierAddressLine2:
		return m.OldSupplierAddressLine2(ctx)
	case billingprofile.FieldSupplierAddressPhoneNumber:
		return m.OldSupplierAddressPhoneNumber(ctx)
	case billingprofile.FieldTaxProvider:
		return m.OldTaxProvider(ctx)
	case billingprofile.FieldInvoicingProvider:
		return m.OldInvoicingProvider(ctx)
	case billingprofile.FieldPaymentProvider:
		return m.OldPaymentProvider(ctx)
	case billingprofile.FieldWorkflowConfigID:
		return m.OldWorkflowConfigID(ctx)
	case billingprofile.FieldDefault:
		return m.OldDefault(ctx)
	case billingprofile.FieldSupplierName:
		return m.OldSupplierName(ctx)
	}
	return nil, fmt.Errorf("unknown BillingProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingprofile.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingprofile.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case billingprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingprofile.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billingprofile.FieldSupplierAddressCountry:
		v, ok := value.(models.CountryCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressCountry(v)
		return nil
	case billingprofile.FieldSupplierAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressPostalCode(v)
		return nil
	case billingprofile.FieldSupplierAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressState(v)
		return nil
	case billingprofile.FieldSupplierAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressCity(v)
		return nil
	case billingprofile.FieldSupplierAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressLine1(v)
		return nil
	case billingprofile.FieldSupplierAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressLine2(v)
		return nil
	case billingprofile.FieldSupplierAddressPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressPhoneNumber(v)
		return nil
	case billingprofile.FieldTaxProvider:
		v, ok := value.(provider.TaxProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxProvider(v)
		return nil
	case billingprofile.FieldInvoicingProvider:
		v, ok := value.(provider.InvoicingProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingProvider(v)
		return nil
	case billingprofile.FieldPaymentProvider:
		v, ok := value.(provider.PaymentProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentProvider(v)
		return nil
	case billingprofile.FieldWorkflowConfigID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowConfigID(v)
		return nil
	case billingprofile.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	case billingprofile.FieldSupplierName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierName(v)
		return nil
	}
	return fmt.Errorf("unknown BillingProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billingprofile.FieldMetadata) {
		fields = append(fields, billingprofile.FieldMetadata)
	}
	if m.FieldCleared(billingprofile.FieldDeletedAt) {
		fields = append(fields, billingprofile.FieldDeletedAt)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressCountry) {
		fields = append(fields, billingprofile.FieldSupplierAddressCountry)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressPostalCode) {
		fields = append(fields, billingprofile.FieldSupplierAddressPostalCode)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressState) {
		fields = append(fields, billingprofile.FieldSupplierAddressState)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressCity) {
		fields = append(fields, billingprofile.FieldSupplierAddressCity)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressLine1) {
		fields = append(fields, billingprofile.FieldSupplierAddressLine1)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressLine2) {
		fields = append(fields, billingprofile.FieldSupplierAddressLine2)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressPhoneNumber) {
		fields = append(fields, billingprofile.FieldSupplierAddressPhoneNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingProfileMutation) ClearField(name string) error {
	switch name {
	case billingprofile.FieldMetadata:
		m.ClearMetadata()
		return nil
	case billingprofile.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billingprofile.FieldSupplierAddressCountry:
		m.ClearSupplierAddressCountry()
		return nil
	case billingprofile.FieldSupplierAddressPostalCode:
		m.ClearSupplierAddressPostalCode()
		return nil
	case billingprofile.FieldSupplierAddressState:
		m.ClearSupplierAddressState()
		return nil
	case billingprofile.FieldSupplierAddressCity:
		m.ClearSupplierAddressCity()
		return nil
	case billingprofile.FieldSupplierAddressLine1:
		m.ClearSupplierAddressLine1()
		return nil
	case billingprofile.FieldSupplierAddressLine2:
		m.ClearSupplierAddressLine2()
		return nil
	case billingprofile.FieldSupplierAddressPhoneNumber:
		m.ClearSupplierAddressPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingProfileMutation) ResetField(name string) error {
	switch name {
	case billingprofile.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingprofile.FieldMetadata:
		m.ResetMetadata()
		return nil
	case billingprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingprofile.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billingprofile.FieldSupplierAddressCountry:
		m.ResetSupplierAddressCountry()
		return nil
	case billingprofile.FieldSupplierAddressPostalCode:
		m.ResetSupplierAddressPostalCode()
		return nil
	case billingprofile.FieldSupplierAddressState:
		m.ResetSupplierAddressState()
		return nil
	case billingprofile.FieldSupplierAddressCity:
		m.ResetSupplierAddressCity()
		return nil
	case billingprofile.FieldSupplierAddressLine1:
		m.ResetSupplierAddressLine1()
		return nil
	case billingprofile.FieldSupplierAddressLine2:
		m.ResetSupplierAddressLine2()
		return nil
	case billingprofile.FieldSupplierAddressPhoneNumber:
		m.ResetSupplierAddressPhoneNumber()
		return nil
	case billingprofile.FieldTaxProvider:
		m.ResetTaxProvider()
		return nil
	case billingprofile.FieldInvoicingProvider:
		m.ResetInvoicingProvider()
		return nil
	case billingprofile.FieldPaymentProvider:
		m.ResetPaymentProvider()
		return nil
	case billingprofile.FieldWorkflowConfigID:
		m.ResetWorkflowConfigID()
		return nil
	case billingprofile.FieldDefault:
		m.ResetDefault()
		return nil
	case billingprofile.FieldSupplierName:
		m.ResetSupplierName()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.billing_invoices != nil {
		edges = append(edges, billingprofile.EdgeBillingInvoices)
	}
	if m.billing_customer_override != nil {
		edges = append(edges, billingprofile.EdgeBillingCustomerOverride)
	}
	if m.workflow_config != nil {
		edges = append(edges, billingprofile.EdgeWorkflowConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		ids := make([]ent.Value, 0, len(m.billing_invoices))
		for id := range m.billing_invoices {
			ids = append(ids, id)
		}
		return ids
	case billingprofile.EdgeBillingCustomerOverride:
		ids := make([]ent.Value, 0, len(m.billing_customer_override))
		for id := range m.billing_customer_override {
			ids = append(ids, id)
		}
		return ids
	case billingprofile.EdgeWorkflowConfig:
		if id := m.workflow_config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbilling_invoices != nil {
		edges = append(edges, billingprofile.EdgeBillingInvoices)
	}
	if m.removedbilling_customer_override != nil {
		edges = append(edges, billingprofile.EdgeBillingCustomerOverride)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoices))
		for id := range m.removedbilling_invoices {
			ids = append(ids, id)
		}
		return ids
	case billingprofile.EdgeBillingCustomerOverride:
		ids := make([]ent.Value, 0, len(m.removedbilling_customer_override))
		for id := range m.removedbilling_customer_override {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbilling_invoices {
		edges = append(edges, billingprofile.EdgeBillingInvoices)
	}
	if m.clearedbilling_customer_override {
		edges = append(edges, billingprofile.EdgeBillingCustomerOverride)
	}
	if m.clearedworkflow_config {
		edges = append(edges, billingprofile.EdgeWorkflowConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		return m.clearedbilling_invoices
	case billingprofile.EdgeBillingCustomerOverride:
		return m.clearedbilling_customer_override
	case billingprofile.EdgeWorkflowConfig:
		return m.clearedworkflow_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingProfileMutation) ClearEdge(name string) error {
	switch name {
	case billingprofile.EdgeWorkflowConfig:
		m.ClearWorkflowConfig()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingProfileMutation) ResetEdge(name string) error {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		m.ResetBillingInvoices()
		return nil
	case billingprofile.EdgeBillingCustomerOverride:
		m.ResetBillingCustomerOverride()
		return nil
	case billingprofile.EdgeWorkflowConfig:
		m.ResetWorkflowConfig()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile edge %s", name)
}

// BillingWorkflowConfigMutation represents an operation that mutates the BillingWorkflowConfig nodes in the graph.
type BillingWorkflowConfigMutation struct {
	config
	op                                Op
	typ                               string
	id                                *string
	namespace                         *string
	created_at                        *time.Time
	updated_at                        *time.Time
	deleted_at                        *time.Time
	timezone                          *timezone.Timezone
	collection_alignment              *billing.AlignmentKind
	item_collection_period_seconds    *int64
	additem_collection_period_seconds *int64
	invoice_auto_advance              *bool
	invoice_draft_period_seconds      *int64
	addinvoice_draft_period_seconds   *int64
	invoice_due_after_seconds         *int64
	addinvoice_due_after_seconds      *int64
	invoice_collection_method         *billing.CollectionMethod
	invoice_item_resolution           *billing.GranularityResolution
	invoice_item_per_subject          *bool
	clearedFields                     map[string]struct{}
	billing_invoices                  *string
	clearedbilling_invoices           bool
	billing_profile                   *string
	clearedbilling_profile            bool
	done                              bool
	oldValue                          func(context.Context) (*BillingWorkflowConfig, error)
	predicates                        []predicate.BillingWorkflowConfig
}

var _ ent.Mutation = (*BillingWorkflowConfigMutation)(nil)

// billingworkflowconfigOption allows management of the mutation configuration using functional options.
type billingworkflowconfigOption func(*BillingWorkflowConfigMutation)

// newBillingWorkflowConfigMutation creates new mutation for the BillingWorkflowConfig entity.
func newBillingWorkflowConfigMutation(c config, op Op, opts ...billingworkflowconfigOption) *BillingWorkflowConfigMutation {
	m := &BillingWorkflowConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingWorkflowConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingWorkflowConfigID sets the ID field of the mutation.
func withBillingWorkflowConfigID(id string) billingworkflowconfigOption {
	return func(m *BillingWorkflowConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingWorkflowConfig
		)
		m.oldValue = func(ctx context.Context) (*BillingWorkflowConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingWorkflowConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingWorkflowConfig sets the old BillingWorkflowConfig of the mutation.
func withBillingWorkflowConfig(node *BillingWorkflowConfig) billingworkflowconfigOption {
	return func(m *BillingWorkflowConfigMutation) {
		m.oldValue = func(context.Context) (*BillingWorkflowConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingWorkflowConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingWorkflowConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingWorkflowConfig entities.
func (m *BillingWorkflowConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingWorkflowConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingWorkflowConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingWorkflowConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingWorkflowConfigMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingWorkflowConfigMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingWorkflowConfigMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingWorkflowConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingWorkflowConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingWorkflowConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingWorkflowConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingWorkflowConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingWorkflowConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingWorkflowConfigMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingWorkflowConfigMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingWorkflowConfigMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billingworkflowconfig.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingWorkflowConfigMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billingworkflowconfig.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingWorkflowConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billingworkflowconfig.FieldDeletedAt)
}

// SetTimezone sets the "timezone" field.
func (m *BillingWorkflowConfigMutation) SetTimezone(t timezone.Timezone) {
	m.timezone = &t
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *BillingWorkflowConfigMutation) Timezone() (r timezone.Timezone, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldTimezone(ctx context.Context) (v *timezone.Timezone, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *BillingWorkflowConfigMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[billingworkflowconfig.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *BillingWorkflowConfigMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[billingworkflowconfig.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *BillingWorkflowConfigMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, billingworkflowconfig.FieldTimezone)
}

// SetCollectionAlignment sets the "collection_alignment" field.
func (m *BillingWorkflowConfigMutation) SetCollectionAlignment(bk billing.AlignmentKind) {
	m.collection_alignment = &bk
}

// CollectionAlignment returns the value of the "collection_alignment" field in the mutation.
func (m *BillingWorkflowConfigMutation) CollectionAlignment() (r billing.AlignmentKind, exists bool) {
	v := m.collection_alignment
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionAlignment returns the old "collection_alignment" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldCollectionAlignment(ctx context.Context) (v billing.AlignmentKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionAlignment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionAlignment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionAlignment: %w", err)
	}
	return oldValue.CollectionAlignment, nil
}

// ResetCollectionAlignment resets all changes to the "collection_alignment" field.
func (m *BillingWorkflowConfigMutation) ResetCollectionAlignment() {
	m.collection_alignment = nil
}

// SetItemCollectionPeriodSeconds sets the "item_collection_period_seconds" field.
func (m *BillingWorkflowConfigMutation) SetItemCollectionPeriodSeconds(i int64) {
	m.item_collection_period_seconds = &i
	m.additem_collection_period_seconds = nil
}

// ItemCollectionPeriodSeconds returns the value of the "item_collection_period_seconds" field in the mutation.
func (m *BillingWorkflowConfigMutation) ItemCollectionPeriodSeconds() (r int64, exists bool) {
	v := m.item_collection_period_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldItemCollectionPeriodSeconds returns the old "item_collection_period_seconds" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldItemCollectionPeriodSeconds(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemCollectionPeriodSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemCollectionPeriodSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemCollectionPeriodSeconds: %w", err)
	}
	return oldValue.ItemCollectionPeriodSeconds, nil
}

// AddItemCollectionPeriodSeconds adds i to the "item_collection_period_seconds" field.
func (m *BillingWorkflowConfigMutation) AddItemCollectionPeriodSeconds(i int64) {
	if m.additem_collection_period_seconds != nil {
		*m.additem_collection_period_seconds += i
	} else {
		m.additem_collection_period_seconds = &i
	}
}

// AddedItemCollectionPeriodSeconds returns the value that was added to the "item_collection_period_seconds" field in this mutation.
func (m *BillingWorkflowConfigMutation) AddedItemCollectionPeriodSeconds() (r int64, exists bool) {
	v := m.additem_collection_period_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemCollectionPeriodSeconds resets all changes to the "item_collection_period_seconds" field.
func (m *BillingWorkflowConfigMutation) ResetItemCollectionPeriodSeconds() {
	m.item_collection_period_seconds = nil
	m.additem_collection_period_seconds = nil
}

// SetInvoiceAutoAdvance sets the "invoice_auto_advance" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceAutoAdvance(b bool) {
	m.invoice_auto_advance = &b
}

// InvoiceAutoAdvance returns the value of the "invoice_auto_advance" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceAutoAdvance() (r bool, exists bool) {
	v := m.invoice_auto_advance
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceAutoAdvance returns the old "invoice_auto_advance" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceAutoAdvance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceAutoAdvance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceAutoAdvance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceAutoAdvance: %w", err)
	}
	return oldValue.InvoiceAutoAdvance, nil
}

// ResetInvoiceAutoAdvance resets all changes to the "invoice_auto_advance" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceAutoAdvance() {
	m.invoice_auto_advance = nil
}

// SetInvoiceDraftPeriodSeconds sets the "invoice_draft_period_seconds" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceDraftPeriodSeconds(i int64) {
	m.invoice_draft_period_seconds = &i
	m.addinvoice_draft_period_seconds = nil
}

// InvoiceDraftPeriodSeconds returns the value of the "invoice_draft_period_seconds" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceDraftPeriodSeconds() (r int64, exists bool) {
	v := m.invoice_draft_period_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDraftPeriodSeconds returns the old "invoice_draft_period_seconds" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceDraftPeriodSeconds(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDraftPeriodSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDraftPeriodSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDraftPeriodSeconds: %w", err)
	}
	return oldValue.InvoiceDraftPeriodSeconds, nil
}

// AddInvoiceDraftPeriodSeconds adds i to the "invoice_draft_period_seconds" field.
func (m *BillingWorkflowConfigMutation) AddInvoiceDraftPeriodSeconds(i int64) {
	if m.addinvoice_draft_period_seconds != nil {
		*m.addinvoice_draft_period_seconds += i
	} else {
		m.addinvoice_draft_period_seconds = &i
	}
}

// AddedInvoiceDraftPeriodSeconds returns the value that was added to the "invoice_draft_period_seconds" field in this mutation.
func (m *BillingWorkflowConfigMutation) AddedInvoiceDraftPeriodSeconds() (r int64, exists bool) {
	v := m.addinvoice_draft_period_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvoiceDraftPeriodSeconds resets all changes to the "invoice_draft_period_seconds" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceDraftPeriodSeconds() {
	m.invoice_draft_period_seconds = nil
	m.addinvoice_draft_period_seconds = nil
}

// SetInvoiceDueAfterSeconds sets the "invoice_due_after_seconds" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceDueAfterSeconds(i int64) {
	m.invoice_due_after_seconds = &i
	m.addinvoice_due_after_seconds = nil
}

// InvoiceDueAfterSeconds returns the value of the "invoice_due_after_seconds" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceDueAfterSeconds() (r int64, exists bool) {
	v := m.invoice_due_after_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDueAfterSeconds returns the old "invoice_due_after_seconds" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceDueAfterSeconds(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDueAfterSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDueAfterSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDueAfterSeconds: %w", err)
	}
	return oldValue.InvoiceDueAfterSeconds, nil
}

// AddInvoiceDueAfterSeconds adds i to the "invoice_due_after_seconds" field.
func (m *BillingWorkflowConfigMutation) AddInvoiceDueAfterSeconds(i int64) {
	if m.addinvoice_due_after_seconds != nil {
		*m.addinvoice_due_after_seconds += i
	} else {
		m.addinvoice_due_after_seconds = &i
	}
}

// AddedInvoiceDueAfterSeconds returns the value that was added to the "invoice_due_after_seconds" field in this mutation.
func (m *BillingWorkflowConfigMutation) AddedInvoiceDueAfterSeconds() (r int64, exists bool) {
	v := m.addinvoice_due_after_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvoiceDueAfterSeconds resets all changes to the "invoice_due_after_seconds" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceDueAfterSeconds() {
	m.invoice_due_after_seconds = nil
	m.addinvoice_due_after_seconds = nil
}

// SetInvoiceCollectionMethod sets the "invoice_collection_method" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceCollectionMethod(bm billing.CollectionMethod) {
	m.invoice_collection_method = &bm
}

// InvoiceCollectionMethod returns the value of the "invoice_collection_method" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceCollectionMethod() (r billing.CollectionMethod, exists bool) {
	v := m.invoice_collection_method
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceCollectionMethod returns the old "invoice_collection_method" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceCollectionMethod(ctx context.Context) (v billing.CollectionMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceCollectionMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceCollectionMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceCollectionMethod: %w", err)
	}
	return oldValue.InvoiceCollectionMethod, nil
}

// ResetInvoiceCollectionMethod resets all changes to the "invoice_collection_method" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceCollectionMethod() {
	m.invoice_collection_method = nil
}

// SetInvoiceItemResolution sets the "invoice_item_resolution" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceItemResolution(br billing.GranularityResolution) {
	m.invoice_item_resolution = &br
}

// InvoiceItemResolution returns the value of the "invoice_item_resolution" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceItemResolution() (r billing.GranularityResolution, exists bool) {
	v := m.invoice_item_resolution
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceItemResolution returns the old "invoice_item_resolution" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceItemResolution(ctx context.Context) (v billing.GranularityResolution, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceItemResolution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceItemResolution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceItemResolution: %w", err)
	}
	return oldValue.InvoiceItemResolution, nil
}

// ResetInvoiceItemResolution resets all changes to the "invoice_item_resolution" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceItemResolution() {
	m.invoice_item_resolution = nil
}

// SetInvoiceItemPerSubject sets the "invoice_item_per_subject" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceItemPerSubject(b bool) {
	m.invoice_item_per_subject = &b
}

// InvoiceItemPerSubject returns the value of the "invoice_item_per_subject" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceItemPerSubject() (r bool, exists bool) {
	v := m.invoice_item_per_subject
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceItemPerSubject returns the old "invoice_item_per_subject" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceItemPerSubject(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceItemPerSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceItemPerSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceItemPerSubject: %w", err)
	}
	return oldValue.InvoiceItemPerSubject, nil
}

// ResetInvoiceItemPerSubject resets all changes to the "invoice_item_per_subject" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceItemPerSubject() {
	m.invoice_item_per_subject = nil
}

// SetBillingInvoicesID sets the "billing_invoices" edge to the BillingInvoice entity by id.
func (m *BillingWorkflowConfigMutation) SetBillingInvoicesID(id string) {
	m.billing_invoices = &id
}

// ClearBillingInvoices clears the "billing_invoices" edge to the BillingInvoice entity.
func (m *BillingWorkflowConfigMutation) ClearBillingInvoices() {
	m.clearedbilling_invoices = true
}

// BillingInvoicesCleared reports if the "billing_invoices" edge to the BillingInvoice entity was cleared.
func (m *BillingWorkflowConfigMutation) BillingInvoicesCleared() bool {
	return m.clearedbilling_invoices
}

// BillingInvoicesID returns the "billing_invoices" edge ID in the mutation.
func (m *BillingWorkflowConfigMutation) BillingInvoicesID() (id string, exists bool) {
	if m.billing_invoices != nil {
		return *m.billing_invoices, true
	}
	return
}

// BillingInvoicesIDs returns the "billing_invoices" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoicesID instead. It exists only for internal usage by the builders.
func (m *BillingWorkflowConfigMutation) BillingInvoicesIDs() (ids []string) {
	if id := m.billing_invoices; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoices resets all changes to the "billing_invoices" edge.
func (m *BillingWorkflowConfigMutation) ResetBillingInvoices() {
	m.billing_invoices = nil
	m.clearedbilling_invoices = false
}

// SetBillingProfileID sets the "billing_profile" edge to the BillingProfile entity by id.
func (m *BillingWorkflowConfigMutation) SetBillingProfileID(id string) {
	m.billing_profile = &id
}

// ClearBillingProfile clears the "billing_profile" edge to the BillingProfile entity.
func (m *BillingWorkflowConfigMutation) ClearBillingProfile() {
	m.clearedbilling_profile = true
}

// BillingProfileCleared reports if the "billing_profile" edge to the BillingProfile entity was cleared.
func (m *BillingWorkflowConfigMutation) BillingProfileCleared() bool {
	return m.clearedbilling_profile
}

// BillingProfileID returns the "billing_profile" edge ID in the mutation.
func (m *BillingWorkflowConfigMutation) BillingProfileID() (id string, exists bool) {
	if m.billing_profile != nil {
		return *m.billing_profile, true
	}
	return
}

// BillingProfileIDs returns the "billing_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingProfileID instead. It exists only for internal usage by the builders.
func (m *BillingWorkflowConfigMutation) BillingProfileIDs() (ids []string) {
	if id := m.billing_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingProfile resets all changes to the "billing_profile" edge.
func (m *BillingWorkflowConfigMutation) ResetBillingProfile() {
	m.billing_profile = nil
	m.clearedbilling_profile = false
}

// Where appends a list predicates to the BillingWorkflowConfigMutation builder.
func (m *BillingWorkflowConfigMutation) Where(ps ...predicate.BillingWorkflowConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingWorkflowConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingWorkflowConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingWorkflowConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingWorkflowConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingWorkflowConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingWorkflowConfig).
func (m *BillingWorkflowConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingWorkflowConfigMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.namespace != nil {
		fields = append(fields, billingworkflowconfig.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billingworkflowconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingworkflowconfig.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billingworkflowconfig.FieldDeletedAt)
	}
	if m.timezone != nil {
		fields = append(fields, billingworkflowconfig.FieldTimezone)
	}
	if m.collection_alignment != nil {
		fields = append(fields, billingworkflowconfig.FieldCollectionAlignment)
	}
	if m.item_collection_period_seconds != nil {
		fields = append(fields, billingworkflowconfig.FieldItemCollectionPeriodSeconds)
	}
	if m.invoice_auto_advance != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceAutoAdvance)
	}
	if m.invoice_draft_period_seconds != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceDraftPeriodSeconds)
	}
	if m.invoice_due_after_seconds != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceDueAfterSeconds)
	}
	if m.invoice_collection_method != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceCollectionMethod)
	}
	if m.invoice_item_resolution != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceItemResolution)
	}
	if m.invoice_item_per_subject != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceItemPerSubject)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingWorkflowConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		return m.Namespace()
	case billingworkflowconfig.FieldCreatedAt:
		return m.CreatedAt()
	case billingworkflowconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingworkflowconfig.FieldDeletedAt:
		return m.DeletedAt()
	case billingworkflowconfig.FieldTimezone:
		return m.Timezone()
	case billingworkflowconfig.FieldCollectionAlignment:
		return m.CollectionAlignment()
	case billingworkflowconfig.FieldItemCollectionPeriodSeconds:
		return m.ItemCollectionPeriodSeconds()
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		return m.InvoiceAutoAdvance()
	case billingworkflowconfig.FieldInvoiceDraftPeriodSeconds:
		return m.InvoiceDraftPeriodSeconds()
	case billingworkflowconfig.FieldInvoiceDueAfterSeconds:
		return m.InvoiceDueAfterSeconds()
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		return m.InvoiceCollectionMethod()
	case billingworkflowconfig.FieldInvoiceItemResolution:
		return m.InvoiceItemResolution()
	case billingworkflowconfig.FieldInvoiceItemPerSubject:
		return m.InvoiceItemPerSubject()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingWorkflowConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingworkflowconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingworkflowconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingworkflowconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billingworkflowconfig.FieldTimezone:
		return m.OldTimezone(ctx)
	case billingworkflowconfig.FieldCollectionAlignment:
		return m.OldCollectionAlignment(ctx)
	case billingworkflowconfig.FieldItemCollectionPeriodSeconds:
		return m.OldItemCollectionPeriodSeconds(ctx)
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		return m.OldInvoiceAutoAdvance(ctx)
	case billingworkflowconfig.FieldInvoiceDraftPeriodSeconds:
		return m.OldInvoiceDraftPeriodSeconds(ctx)
	case billingworkflowconfig.FieldInvoiceDueAfterSeconds:
		return m.OldInvoiceDueAfterSeconds(ctx)
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		return m.OldInvoiceCollectionMethod(ctx)
	case billingworkflowconfig.FieldInvoiceItemResolution:
		return m.OldInvoiceItemResolution(ctx)
	case billingworkflowconfig.FieldInvoiceItemPerSubject:
		return m.OldInvoiceItemPerSubject(ctx)
	}
	return nil, fmt.Errorf("unknown BillingWorkflowConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingWorkflowConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingworkflowconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingworkflowconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingworkflowconfig.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billingworkflowconfig.FieldTimezone:
		v, ok := value.(timezone.Timezone)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case billingworkflowconfig.FieldCollectionAlignment:
		v, ok := value.(billing.AlignmentKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionAlignment(v)
		return nil
	case billingworkflowconfig.FieldItemCollectionPeriodSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemCollectionPeriodSeconds(v)
		return nil
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceAutoAdvance(v)
		return nil
	case billingworkflowconfig.FieldInvoiceDraftPeriodSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDraftPeriodSeconds(v)
		return nil
	case billingworkflowconfig.FieldInvoiceDueAfterSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDueAfterSeconds(v)
		return nil
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		v, ok := value.(billing.CollectionMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceCollectionMethod(v)
		return nil
	case billingworkflowconfig.FieldInvoiceItemResolution:
		v, ok := value.(billing.GranularityResolution)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceItemResolution(v)
		return nil
	case billingworkflowconfig.FieldInvoiceItemPerSubject:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceItemPerSubject(v)
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingWorkflowConfigMutation) AddedFields() []string {
	var fields []string
	if m.additem_collection_period_seconds != nil {
		fields = append(fields, billingworkflowconfig.FieldItemCollectionPeriodSeconds)
	}
	if m.addinvoice_draft_period_seconds != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceDraftPeriodSeconds)
	}
	if m.addinvoice_due_after_seconds != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceDueAfterSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingWorkflowConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case billingworkflowconfig.FieldItemCollectionPeriodSeconds:
		return m.AddedItemCollectionPeriodSeconds()
	case billingworkflowconfig.FieldInvoiceDraftPeriodSeconds:
		return m.AddedInvoiceDraftPeriodSeconds()
	case billingworkflowconfig.FieldInvoiceDueAfterSeconds:
		return m.AddedInvoiceDueAfterSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingWorkflowConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case billingworkflowconfig.FieldItemCollectionPeriodSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemCollectionPeriodSeconds(v)
		return nil
	case billingworkflowconfig.FieldInvoiceDraftPeriodSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceDraftPeriodSeconds(v)
		return nil
	case billingworkflowconfig.FieldInvoiceDueAfterSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceDueAfterSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingWorkflowConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billingworkflowconfig.FieldDeletedAt) {
		fields = append(fields, billingworkflowconfig.FieldDeletedAt)
	}
	if m.FieldCleared(billingworkflowconfig.FieldTimezone) {
		fields = append(fields, billingworkflowconfig.FieldTimezone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingWorkflowConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ClearField(name string) error {
	switch name {
	case billingworkflowconfig.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billingworkflowconfig.FieldTimezone:
		m.ClearTimezone()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ResetField(name string) error {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingworkflowconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingworkflowconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingworkflowconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billingworkflowconfig.FieldTimezone:
		m.ResetTimezone()
		return nil
	case billingworkflowconfig.FieldCollectionAlignment:
		m.ResetCollectionAlignment()
		return nil
	case billingworkflowconfig.FieldItemCollectionPeriodSeconds:
		m.ResetItemCollectionPeriodSeconds()
		return nil
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		m.ResetInvoiceAutoAdvance()
		return nil
	case billingworkflowconfig.FieldInvoiceDraftPeriodSeconds:
		m.ResetInvoiceDraftPeriodSeconds()
		return nil
	case billingworkflowconfig.FieldInvoiceDueAfterSeconds:
		m.ResetInvoiceDueAfterSeconds()
		return nil
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		m.ResetInvoiceCollectionMethod()
		return nil
	case billingworkflowconfig.FieldInvoiceItemResolution:
		m.ResetInvoiceItemResolution()
		return nil
	case billingworkflowconfig.FieldInvoiceItemPerSubject:
		m.ResetInvoiceItemPerSubject()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingWorkflowConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.billing_invoices != nil {
		edges = append(edges, billingworkflowconfig.EdgeBillingInvoices)
	}
	if m.billing_profile != nil {
		edges = append(edges, billingworkflowconfig.EdgeBillingProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingWorkflowConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		if id := m.billing_invoices; id != nil {
			return []ent.Value{*id}
		}
	case billingworkflowconfig.EdgeBillingProfile:
		if id := m.billing_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingWorkflowConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingWorkflowConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingWorkflowConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbilling_invoices {
		edges = append(edges, billingworkflowconfig.EdgeBillingInvoices)
	}
	if m.clearedbilling_profile {
		edges = append(edges, billingworkflowconfig.EdgeBillingProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingWorkflowConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		return m.clearedbilling_invoices
	case billingworkflowconfig.EdgeBillingProfile:
		return m.clearedbilling_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ClearEdge(name string) error {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		m.ClearBillingInvoices()
		return nil
	case billingworkflowconfig.EdgeBillingProfile:
		m.ClearBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ResetEdge(name string) error {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		m.ResetBillingInvoices()
		return nil
	case billingworkflowconfig.EdgeBillingProfile:
		m.ResetBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *string
	namespace                           *string
	metadata                            *map[string]string
	created_at                          *time.Time
	updated_at                          *time.Time
	deleted_at                          *time.Time
	billing_address_country             *models.CountryCode
	billing_address_postal_code         *string
	billing_address_state               *string
	billing_address_city                *string
	billing_address_line1               *string
	billing_address_line2               *string
	billing_address_phone_number        *string
	name                                *string
	primary_email                       *string
	timezone                            *timezone.Timezone
	currency                            *currencyx.Code
	external_mapping_stripe_customer_id *string
	clearedFields                       map[string]struct{}
	subjects                            map[int]struct{}
	removedsubjects                     map[int]struct{}
	clearedsubjects                     bool
	billing_customer_override           *string
	clearedbilling_customer_override    bool
	done                                bool
	oldValue                            func(context.Context) (*Customer, error)
	predicates                          []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id string) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Customer entities.
func (m *CustomerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *CustomerMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *CustomerMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *CustomerMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *CustomerMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CustomerMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CustomerMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[customer.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CustomerMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[customer.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CustomerMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, customer.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CustomerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CustomerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[customer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, customer.FieldDeletedAt)
}

// SetBillingAddressCountry sets the "billing_address_country" field.
func (m *CustomerMutation) SetBillingAddressCountry(mc models.CountryCode) {
	m.billing_address_country = &mc
}

// BillingAddressCountry returns the value of the "billing_address_country" field in the mutation.
func (m *CustomerMutation) BillingAddressCountry() (r models.CountryCode, exists bool) {
	v := m.billing_address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressCountry returns the old "billing_address_country" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressCountry(ctx context.Context) (v *models.CountryCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressCountry: %w", err)
	}
	return oldValue.BillingAddressCountry, nil
}

// ClearBillingAddressCountry clears the value of the "billing_address_country" field.
func (m *CustomerMutation) ClearBillingAddressCountry() {
	m.billing_address_country = nil
	m.clearedFields[customer.FieldBillingAddressCountry] = struct{}{}
}

// BillingAddressCountryCleared returns if the "billing_address_country" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressCountryCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressCountry]
	return ok
}

// ResetBillingAddressCountry resets all changes to the "billing_address_country" field.
func (m *CustomerMutation) ResetBillingAddressCountry() {
	m.billing_address_country = nil
	delete(m.clearedFields, customer.FieldBillingAddressCountry)
}

// SetBillingAddressPostalCode sets the "billing_address_postal_code" field.
func (m *CustomerMutation) SetBillingAddressPostalCode(s string) {
	m.billing_address_postal_code = &s
}

// BillingAddressPostalCode returns the value of the "billing_address_postal_code" field in the mutation.
func (m *CustomerMutation) BillingAddressPostalCode() (r string, exists bool) {
	v := m.billing_address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressPostalCode returns the old "billing_address_postal_code" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressPostalCode: %w", err)
	}
	return oldValue.BillingAddressPostalCode, nil
}

// ClearBillingAddressPostalCode clears the value of the "billing_address_postal_code" field.
func (m *CustomerMutation) ClearBillingAddressPostalCode() {
	m.billing_address_postal_code = nil
	m.clearedFields[customer.FieldBillingAddressPostalCode] = struct{}{}
}

// BillingAddressPostalCodeCleared returns if the "billing_address_postal_code" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressPostalCode]
	return ok
}

// ResetBillingAddressPostalCode resets all changes to the "billing_address_postal_code" field.
func (m *CustomerMutation) ResetBillingAddressPostalCode() {
	m.billing_address_postal_code = nil
	delete(m.clearedFields, customer.FieldBillingAddressPostalCode)
}

// SetBillingAddressState sets the "billing_address_state" field.
func (m *CustomerMutation) SetBillingAddressState(s string) {
	m.billing_address_state = &s
}

// BillingAddressState returns the value of the "billing_address_state" field in the mutation.
func (m *CustomerMutation) BillingAddressState() (r string, exists bool) {
	v := m.billing_address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressState returns the old "billing_address_state" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressState: %w", err)
	}
	return oldValue.BillingAddressState, nil
}

// ClearBillingAddressState clears the value of the "billing_address_state" field.
func (m *CustomerMutation) ClearBillingAddressState() {
	m.billing_address_state = nil
	m.clearedFields[customer.FieldBillingAddressState] = struct{}{}
}

// BillingAddressStateCleared returns if the "billing_address_state" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressStateCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressState]
	return ok
}

// ResetBillingAddressState resets all changes to the "billing_address_state" field.
func (m *CustomerMutation) ResetBillingAddressState() {
	m.billing_address_state = nil
	delete(m.clearedFields, customer.FieldBillingAddressState)
}

// SetBillingAddressCity sets the "billing_address_city" field.
func (m *CustomerMutation) SetBillingAddressCity(s string) {
	m.billing_address_city = &s
}

// BillingAddressCity returns the value of the "billing_address_city" field in the mutation.
func (m *CustomerMutation) BillingAddressCity() (r string, exists bool) {
	v := m.billing_address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressCity returns the old "billing_address_city" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressCity: %w", err)
	}
	return oldValue.BillingAddressCity, nil
}

// ClearBillingAddressCity clears the value of the "billing_address_city" field.
func (m *CustomerMutation) ClearBillingAddressCity() {
	m.billing_address_city = nil
	m.clearedFields[customer.FieldBillingAddressCity] = struct{}{}
}

// BillingAddressCityCleared returns if the "billing_address_city" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressCityCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressCity]
	return ok
}

// ResetBillingAddressCity resets all changes to the "billing_address_city" field.
func (m *CustomerMutation) ResetBillingAddressCity() {
	m.billing_address_city = nil
	delete(m.clearedFields, customer.FieldBillingAddressCity)
}

// SetBillingAddressLine1 sets the "billing_address_line1" field.
func (m *CustomerMutation) SetBillingAddressLine1(s string) {
	m.billing_address_line1 = &s
}

// BillingAddressLine1 returns the value of the "billing_address_line1" field in the mutation.
func (m *CustomerMutation) BillingAddressLine1() (r string, exists bool) {
	v := m.billing_address_line1
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressLine1 returns the old "billing_address_line1" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressLine1: %w", err)
	}
	return oldValue.BillingAddressLine1, nil
}

// ClearBillingAddressLine1 clears the value of the "billing_address_line1" field.
func (m *CustomerMutation) ClearBillingAddressLine1() {
	m.billing_address_line1 = nil
	m.clearedFields[customer.FieldBillingAddressLine1] = struct{}{}
}

// BillingAddressLine1Cleared returns if the "billing_address_line1" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressLine1Cleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressLine1]
	return ok
}

// ResetBillingAddressLine1 resets all changes to the "billing_address_line1" field.
func (m *CustomerMutation) ResetBillingAddressLine1() {
	m.billing_address_line1 = nil
	delete(m.clearedFields, customer.FieldBillingAddressLine1)
}

// SetBillingAddressLine2 sets the "billing_address_line2" field.
func (m *CustomerMutation) SetBillingAddressLine2(s string) {
	m.billing_address_line2 = &s
}

// BillingAddressLine2 returns the value of the "billing_address_line2" field in the mutation.
func (m *CustomerMutation) BillingAddressLine2() (r string, exists bool) {
	v := m.billing_address_line2
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressLine2 returns the old "billing_address_line2" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressLine2: %w", err)
	}
	return oldValue.BillingAddressLine2, nil
}

// ClearBillingAddressLine2 clears the value of the "billing_address_line2" field.
func (m *CustomerMutation) ClearBillingAddressLine2() {
	m.billing_address_line2 = nil
	m.clearedFields[customer.FieldBillingAddressLine2] = struct{}{}
}

// BillingAddressLine2Cleared returns if the "billing_address_line2" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressLine2Cleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressLine2]
	return ok
}

// ResetBillingAddressLine2 resets all changes to the "billing_address_line2" field.
func (m *CustomerMutation) ResetBillingAddressLine2() {
	m.billing_address_line2 = nil
	delete(m.clearedFields, customer.FieldBillingAddressLine2)
}

// SetBillingAddressPhoneNumber sets the "billing_address_phone_number" field.
func (m *CustomerMutation) SetBillingAddressPhoneNumber(s string) {
	m.billing_address_phone_number = &s
}

// BillingAddressPhoneNumber returns the value of the "billing_address_phone_number" field in the mutation.
func (m *CustomerMutation) BillingAddressPhoneNumber() (r string, exists bool) {
	v := m.billing_address_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressPhoneNumber returns the old "billing_address_phone_number" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressPhoneNumber: %w", err)
	}
	return oldValue.BillingAddressPhoneNumber, nil
}

// ClearBillingAddressPhoneNumber clears the value of the "billing_address_phone_number" field.
func (m *CustomerMutation) ClearBillingAddressPhoneNumber() {
	m.billing_address_phone_number = nil
	m.clearedFields[customer.FieldBillingAddressPhoneNumber] = struct{}{}
}

// BillingAddressPhoneNumberCleared returns if the "billing_address_phone_number" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressPhoneNumberCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressPhoneNumber]
	return ok
}

// ResetBillingAddressPhoneNumber resets all changes to the "billing_address_phone_number" field.
func (m *CustomerMutation) ResetBillingAddressPhoneNumber() {
	m.billing_address_phone_number = nil
	delete(m.clearedFields, customer.FieldBillingAddressPhoneNumber)
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetPrimaryEmail sets the "primary_email" field.
func (m *CustomerMutation) SetPrimaryEmail(s string) {
	m.primary_email = &s
}

// PrimaryEmail returns the value of the "primary_email" field in the mutation.
func (m *CustomerMutation) PrimaryEmail() (r string, exists bool) {
	v := m.primary_email
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryEmail returns the old "primary_email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPrimaryEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryEmail: %w", err)
	}
	return oldValue.PrimaryEmail, nil
}

// ClearPrimaryEmail clears the value of the "primary_email" field.
func (m *CustomerMutation) ClearPrimaryEmail() {
	m.primary_email = nil
	m.clearedFields[customer.FieldPrimaryEmail] = struct{}{}
}

// PrimaryEmailCleared returns if the "primary_email" field was cleared in this mutation.
func (m *CustomerMutation) PrimaryEmailCleared() bool {
	_, ok := m.clearedFields[customer.FieldPrimaryEmail]
	return ok
}

// ResetPrimaryEmail resets all changes to the "primary_email" field.
func (m *CustomerMutation) ResetPrimaryEmail() {
	m.primary_email = nil
	delete(m.clearedFields, customer.FieldPrimaryEmail)
}

// SetTimezone sets the "timezone" field.
func (m *CustomerMutation) SetTimezone(t timezone.Timezone) {
	m.timezone = &t
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *CustomerMutation) Timezone() (r timezone.Timezone, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldTimezone(ctx context.Context) (v *timezone.Timezone, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *CustomerMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[customer.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *CustomerMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[customer.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *CustomerMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, customer.FieldTimezone)
}

// SetCurrency sets the "currency" field.
func (m *CustomerMutation) SetCurrency(c currencyx.Code) {
	m.currency = &c
}

// Currency returns the value of the "currency" field in the mutation.
func (m *CustomerMutation) Currency() (r currencyx.Code, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCurrency(ctx context.Context) (v *currencyx.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *CustomerMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[customer.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *CustomerMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[customer.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *CustomerMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, customer.FieldCurrency)
}

// SetExternalMappingStripeCustomerID sets the "external_mapping_stripe_customer_id" field.
func (m *CustomerMutation) SetExternalMappingStripeCustomerID(s string) {
	m.external_mapping_stripe_customer_id = &s
}

// ExternalMappingStripeCustomerID returns the value of the "external_mapping_stripe_customer_id" field in the mutation.
func (m *CustomerMutation) ExternalMappingStripeCustomerID() (r string, exists bool) {
	v := m.external_mapping_stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalMappingStripeCustomerID returns the old "external_mapping_stripe_customer_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldExternalMappingStripeCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalMappingStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalMappingStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalMappingStripeCustomerID: %w", err)
	}
	return oldValue.ExternalMappingStripeCustomerID, nil
}

// ClearExternalMappingStripeCustomerID clears the value of the "external_mapping_stripe_customer_id" field.
func (m *CustomerMutation) ClearExternalMappingStripeCustomerID() {
	m.external_mapping_stripe_customer_id = nil
	m.clearedFields[customer.FieldExternalMappingStripeCustomerID] = struct{}{}
}

// ExternalMappingStripeCustomerIDCleared returns if the "external_mapping_stripe_customer_id" field was cleared in this mutation.
func (m *CustomerMutation) ExternalMappingStripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldExternalMappingStripeCustomerID]
	return ok
}

// ResetExternalMappingStripeCustomerID resets all changes to the "external_mapping_stripe_customer_id" field.
func (m *CustomerMutation) ResetExternalMappingStripeCustomerID() {
	m.external_mapping_stripe_customer_id = nil
	delete(m.clearedFields, customer.FieldExternalMappingStripeCustomerID)
}

// AddSubjectIDs adds the "subjects" edge to the CustomerSubjects entity by ids.
func (m *CustomerMutation) AddSubjectIDs(ids ...int) {
	if m.subjects == nil {
		m.subjects = make(map[int]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the CustomerSubjects entity.
func (m *CustomerMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the CustomerSubjects entity was cleared.
func (m *CustomerMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the CustomerSubjects entity by IDs.
func (m *CustomerMutation) RemoveSubjectIDs(ids ...int) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the CustomerSubjects entity.
func (m *CustomerMutation) RemovedSubjectsIDs() (ids []int) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *CustomerMutation) SubjectsIDs() (ids []int) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *CustomerMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// SetBillingCustomerOverrideID sets the "billing_customer_override" edge to the BillingCustomerOverride entity by id.
func (m *CustomerMutation) SetBillingCustomerOverrideID(id string) {
	m.billing_customer_override = &id
}

// ClearBillingCustomerOverride clears the "billing_customer_override" edge to the BillingCustomerOverride entity.
func (m *CustomerMutation) ClearBillingCustomerOverride() {
	m.clearedbilling_customer_override = true
}

// BillingCustomerOverrideCleared reports if the "billing_customer_override" edge to the BillingCustomerOverride entity was cleared.
func (m *CustomerMutation) BillingCustomerOverrideCleared() bool {
	return m.clearedbilling_customer_override
}

// BillingCustomerOverrideID returns the "billing_customer_override" edge ID in the mutation.
func (m *CustomerMutation) BillingCustomerOverrideID() (id string, exists bool) {
	if m.billing_customer_override != nil {
		return *m.billing_customer_override, true
	}
	return
}

// BillingCustomerOverrideIDs returns the "billing_customer_override" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingCustomerOverrideID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) BillingCustomerOverrideIDs() (ids []string) {
	if id := m.billing_customer_override; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingCustomerOverride resets all changes to the "billing_customer_override" edge.
func (m *CustomerMutation) ResetBillingCustomerOverride() {
	m.billing_customer_override = nil
	m.clearedbilling_customer_override = false
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.namespace != nil {
		fields = append(fields, customer.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, customer.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.billing_address_country != nil {
		fields = append(fields, customer.FieldBillingAddressCountry)
	}
	if m.billing_address_postal_code != nil {
		fields = append(fields, customer.FieldBillingAddressPostalCode)
	}
	if m.billing_address_state != nil {
		fields = append(fields, customer.FieldBillingAddressState)
	}
	if m.billing_address_city != nil {
		fields = append(fields, customer.FieldBillingAddressCity)
	}
	if m.billing_address_line1 != nil {
		fields = append(fields, customer.FieldBillingAddressLine1)
	}
	if m.billing_address_line2 != nil {
		fields = append(fields, customer.FieldBillingAddressLine2)
	}
	if m.billing_address_phone_number != nil {
		fields = append(fields, customer.FieldBillingAddressPhoneNumber)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.primary_email != nil {
		fields = append(fields, customer.FieldPrimaryEmail)
	}
	if m.timezone != nil {
		fields = append(fields, customer.FieldTimezone)
	}
	if m.currency != nil {
		fields = append(fields, customer.FieldCurrency)
	}
	if m.external_mapping_stripe_customer_id != nil {
		fields = append(fields, customer.FieldExternalMappingStripeCustomerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldNamespace:
		return m.Namespace()
	case customer.FieldMetadata:
		return m.Metadata()
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldDeletedAt:
		return m.DeletedAt()
	case customer.FieldBillingAddressCountry:
		return m.BillingAddressCountry()
	case customer.FieldBillingAddressPostalCode:
		return m.BillingAddressPostalCode()
	case customer.FieldBillingAddressState:
		return m.BillingAddressState()
	case customer.FieldBillingAddressCity:
		return m.BillingAddressCity()
	case customer.FieldBillingAddressLine1:
		return m.BillingAddressLine1()
	case customer.FieldBillingAddressLine2:
		return m.BillingAddressLine2()
	case customer.FieldBillingAddressPhoneNumber:
		return m.BillingAddressPhoneNumber()
	case customer.FieldName:
		return m.Name()
	case customer.FieldPrimaryEmail:
		return m.PrimaryEmail()
	case customer.FieldTimezone:
		return m.Timezone()
	case customer.FieldCurrency:
		return m.Currency()
	case customer.FieldExternalMappingStripeCustomerID:
		return m.ExternalMappingStripeCustomerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldNamespace:
		return m.OldNamespace(ctx)
	case customer.FieldMetadata:
		return m.OldMetadata(ctx)
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customer.FieldBillingAddressCountry:
		return m.OldBillingAddressCountry(ctx)
	case customer.FieldBillingAddressPostalCode:
		return m.OldBillingAddressPostalCode(ctx)
	case customer.FieldBillingAddressState:
		return m.OldBillingAddressState(ctx)
	case customer.FieldBillingAddressCity:
		return m.OldBillingAddressCity(ctx)
	case customer.FieldBillingAddressLine1:
		return m.OldBillingAddressLine1(ctx)
	case customer.FieldBillingAddressLine2:
		return m.OldBillingAddressLine2(ctx)
	case customer.FieldBillingAddressPhoneNumber:
		return m.OldBillingAddressPhoneNumber(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldPrimaryEmail:
		return m.OldPrimaryEmail(ctx)
	case customer.FieldTimezone:
		return m.OldTimezone(ctx)
	case customer.FieldCurrency:
		return m.OldCurrency(ctx)
	case customer.FieldExternalMappingStripeCustomerID:
		return m.OldExternalMappingStripeCustomerID(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case customer.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customer.FieldBillingAddressCountry:
		v, ok := value.(models.CountryCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressCountry(v)
		return nil
	case customer.FieldBillingAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressPostalCode(v)
		return nil
	case customer.FieldBillingAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressState(v)
		return nil
	case customer.FieldBillingAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressCity(v)
		return nil
	case customer.FieldBillingAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressLine1(v)
		return nil
	case customer.FieldBillingAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressLine2(v)
		return nil
	case customer.FieldBillingAddressPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressPhoneNumber(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldPrimaryEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryEmail(v)
		return nil
	case customer.FieldTimezone:
		v, ok := value.(timezone.Timezone)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case customer.FieldCurrency:
		v, ok := value.(currencyx.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case customer.FieldExternalMappingStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalMappingStripeCustomerID(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldMetadata) {
		fields = append(fields, customer.FieldMetadata)
	}
	if m.FieldCleared(customer.FieldDeletedAt) {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.FieldCleared(customer.FieldBillingAddressCountry) {
		fields = append(fields, customer.FieldBillingAddressCountry)
	}
	if m.FieldCleared(customer.FieldBillingAddressPostalCode) {
		fields = append(fields, customer.FieldBillingAddressPostalCode)
	}
	if m.FieldCleared(customer.FieldBillingAddressState) {
		fields = append(fields, customer.FieldBillingAddressState)
	}
	if m.FieldCleared(customer.FieldBillingAddressCity) {
		fields = append(fields, customer.FieldBillingAddressCity)
	}
	if m.FieldCleared(customer.FieldBillingAddressLine1) {
		fields = append(fields, customer.FieldBillingAddressLine1)
	}
	if m.FieldCleared(customer.FieldBillingAddressLine2) {
		fields = append(fields, customer.FieldBillingAddressLine2)
	}
	if m.FieldCleared(customer.FieldBillingAddressPhoneNumber) {
		fields = append(fields, customer.FieldBillingAddressPhoneNumber)
	}
	if m.FieldCleared(customer.FieldPrimaryEmail) {
		fields = append(fields, customer.FieldPrimaryEmail)
	}
	if m.FieldCleared(customer.FieldTimezone) {
		fields = append(fields, customer.FieldTimezone)
	}
	if m.FieldCleared(customer.FieldCurrency) {
		fields = append(fields, customer.FieldCurrency)
	}
	if m.FieldCleared(customer.FieldExternalMappingStripeCustomerID) {
		fields = append(fields, customer.FieldExternalMappingStripeCustomerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldMetadata:
		m.ClearMetadata()
		return nil
	case customer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case customer.FieldBillingAddressCountry:
		m.ClearBillingAddressCountry()
		return nil
	case customer.FieldBillingAddressPostalCode:
		m.ClearBillingAddressPostalCode()
		return nil
	case customer.FieldBillingAddressState:
		m.ClearBillingAddressState()
		return nil
	case customer.FieldBillingAddressCity:
		m.ClearBillingAddressCity()
		return nil
	case customer.FieldBillingAddressLine1:
		m.ClearBillingAddressLine1()
		return nil
	case customer.FieldBillingAddressLine2:
		m.ClearBillingAddressLine2()
		return nil
	case customer.FieldBillingAddressPhoneNumber:
		m.ClearBillingAddressPhoneNumber()
		return nil
	case customer.FieldPrimaryEmail:
		m.ClearPrimaryEmail()
		return nil
	case customer.FieldTimezone:
		m.ClearTimezone()
		return nil
	case customer.FieldCurrency:
		m.ClearCurrency()
		return nil
	case customer.FieldExternalMappingStripeCustomerID:
		m.ClearExternalMappingStripeCustomerID()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldNamespace:
		m.ResetNamespace()
		return nil
	case customer.FieldMetadata:
		m.ResetMetadata()
		return nil
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customer.FieldBillingAddressCountry:
		m.ResetBillingAddressCountry()
		return nil
	case customer.FieldBillingAddressPostalCode:
		m.ResetBillingAddressPostalCode()
		return nil
	case customer.FieldBillingAddressState:
		m.ResetBillingAddressState()
		return nil
	case customer.FieldBillingAddressCity:
		m.ResetBillingAddressCity()
		return nil
	case customer.FieldBillingAddressLine1:
		m.ResetBillingAddressLine1()
		return nil
	case customer.FieldBillingAddressLine2:
		m.ResetBillingAddressLine2()
		return nil
	case customer.FieldBillingAddressPhoneNumber:
		m.ResetBillingAddressPhoneNumber()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldPrimaryEmail:
		m.ResetPrimaryEmail()
		return nil
	case customer.FieldTimezone:
		m.ResetTimezone()
		return nil
	case customer.FieldCurrency:
		m.ResetCurrency()
		return nil
	case customer.FieldExternalMappingStripeCustomerID:
		m.ResetExternalMappingStripeCustomerID()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.subjects != nil {
		edges = append(edges, customer.EdgeSubjects)
	}
	if m.billing_customer_override != nil {
		edges = append(edges, customer.EdgeBillingCustomerOverride)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeBillingCustomerOverride:
		if id := m.billing_customer_override; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubjects != nil {
		edges = append(edges, customer.EdgeSubjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsubjects {
		edges = append(edges, customer.EdgeSubjects)
	}
	if m.clearedbilling_customer_override {
		edges = append(edges, customer.EdgeBillingCustomerOverride)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeSubjects:
		return m.clearedsubjects
	case customer.EdgeBillingCustomerOverride:
		return m.clearedbilling_customer_override
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeBillingCustomerOverride:
		m.ClearBillingCustomerOverride()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeSubjects:
		m.ResetSubjects()
		return nil
	case customer.EdgeBillingCustomerOverride:
		m.ResetBillingCustomerOverride()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// CustomerSubjectsMutation represents an operation that mutates the CustomerSubjects nodes in the graph.
type CustomerSubjectsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	namespace       *string
	subject_key     *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	customer        *string
	clearedcustomer bool
	done            bool
	oldValue        func(context.Context) (*CustomerSubjects, error)
	predicates      []predicate.CustomerSubjects
}

var _ ent.Mutation = (*CustomerSubjectsMutation)(nil)

// customersubjectsOption allows management of the mutation configuration using functional options.
type customersubjectsOption func(*CustomerSubjectsMutation)

// newCustomerSubjectsMutation creates new mutation for the CustomerSubjects entity.
func newCustomerSubjectsMutation(c config, op Op, opts ...customersubjectsOption) *CustomerSubjectsMutation {
	m := &CustomerSubjectsMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerSubjects,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerSubjectsID sets the ID field of the mutation.
func withCustomerSubjectsID(id int) customersubjectsOption {
	return func(m *CustomerSubjectsMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerSubjects
		)
		m.oldValue = func(ctx context.Context) (*CustomerSubjects, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerSubjects.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerSubjects sets the old CustomerSubjects of the mutation.
func withCustomerSubjects(node *CustomerSubjects) customersubjectsOption {
	return func(m *CustomerSubjectsMutation) {
		m.oldValue = func(context.Context) (*CustomerSubjects, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerSubjectsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerSubjectsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerSubjectsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerSubjectsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerSubjects.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *CustomerSubjectsMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *CustomerSubjectsMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *CustomerSubjectsMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerSubjectsMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerSubjectsMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerSubjectsMutation) ResetCustomerID() {
	m.customer = nil
}

// SetSubjectKey sets the "subject_key" field.
func (m *CustomerSubjectsMutation) SetSubjectKey(s string) {
	m.subject_key = &s
}

// SubjectKey returns the value of the "subject_key" field in the mutation.
func (m *CustomerSubjectsMutation) SubjectKey() (r string, exists bool) {
	v := m.subject_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectKey returns the old "subject_key" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldSubjectKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectKey: %w", err)
	}
	return oldValue.SubjectKey, nil
}

// ResetSubjectKey resets all changes to the "subject_key" field.
func (m *CustomerSubjectsMutation) ResetSubjectKey() {
	m.subject_key = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerSubjectsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerSubjectsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerSubjectsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerSubjectsMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customersubjects.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerSubjectsMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerSubjectsMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerSubjectsMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the CustomerSubjectsMutation builder.
func (m *CustomerSubjectsMutation) Where(ps ...predicate.CustomerSubjects) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerSubjectsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerSubjectsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerSubjects, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerSubjectsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerSubjectsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerSubjects).
func (m *CustomerSubjectsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerSubjectsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.namespace != nil {
		fields = append(fields, customersubjects.FieldNamespace)
	}
	if m.customer != nil {
		fields = append(fields, customersubjects.FieldCustomerID)
	}
	if m.subject_key != nil {
		fields = append(fields, customersubjects.FieldSubjectKey)
	}
	if m.created_at != nil {
		fields = append(fields, customersubjects.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerSubjectsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customersubjects.FieldNamespace:
		return m.Namespace()
	case customersubjects.FieldCustomerID:
		return m.CustomerID()
	case customersubjects.FieldSubjectKey:
		return m.SubjectKey()
	case customersubjects.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerSubjectsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customersubjects.FieldNamespace:
		return m.OldNamespace(ctx)
	case customersubjects.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customersubjects.FieldSubjectKey:
		return m.OldSubjectKey(ctx)
	case customersubjects.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerSubjects field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerSubjectsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customersubjects.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case customersubjects.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customersubjects.FieldSubjectKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectKey(v)
		return nil
	case customersubjects.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerSubjectsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerSubjectsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerSubjectsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomerSubjects numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerSubjectsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerSubjectsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerSubjectsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CustomerSubjects nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerSubjectsMutation) ResetField(name string) error {
	switch name {
	case customersubjects.FieldNamespace:
		m.ResetNamespace()
		return nil
	case customersubjects.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customersubjects.FieldSubjectKey:
		m.ResetSubjectKey()
		return nil
	case customersubjects.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerSubjectsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.customer != nil {
		edges = append(edges, customersubjects.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerSubjectsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customersubjects.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerSubjectsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerSubjectsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerSubjectsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcustomer {
		edges = append(edges, customersubjects.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerSubjectsMutation) EdgeCleared(name string) bool {
	switch name {
	case customersubjects.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerSubjectsMutation) ClearEdge(name string) error {
	switch name {
	case customersubjects.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerSubjectsMutation) ResetEdge(name string) error {
	switch name {
	case customersubjects.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects edge %s", name)
}

// EntitlementMutation represents an operation that mutates the Entitlement nodes in the graph.
type EntitlementMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	namespace                     *string
	metadata                      *map[string]string
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	entitlement_type              *entitlement.EntitlementType
	feature_key                   *string
	subject_key                   *string
	measure_usage_from            *time.Time
	issue_after_reset             *float64
	addissue_after_reset          *float64
	issue_after_reset_priority    *uint8
	addissue_after_reset_priority *int8
	is_soft_limit                 *bool
	preserve_overage_at_reset     *bool
	_config                       *[]uint8
	append_config                 []uint8
	usage_period_interval         *entitlement.UsagePeriodInterval
	usage_period_anchor           *time.Time
	current_usage_period_start    *time.Time
	current_usage_period_end      *time.Time
	clearedFields                 map[string]struct{}
	usage_reset                   map[string]struct{}
	removedusage_reset            map[string]struct{}
	clearedusage_reset            bool
	grant                         map[string]struct{}
	removedgrant                  map[string]struct{}
	clearedgrant                  bool
	balance_snapshot              map[int]struct{}
	removedbalance_snapshot       map[int]struct{}
	clearedbalance_snapshot       bool
	feature                       *string
	clearedfeature                bool
	done                          bool
	oldValue                      func(context.Context) (*Entitlement, error)
	predicates                    []predicate.Entitlement
}

var _ ent.Mutation = (*EntitlementMutation)(nil)

// entitlementOption allows management of the mutation configuration using functional options.
type entitlementOption func(*EntitlementMutation)

// newEntitlementMutation creates new mutation for the Entitlement entity.
func newEntitlementMutation(c config, op Op, opts ...entitlementOption) *EntitlementMutation {
	m := &EntitlementMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementID sets the ID field of the mutation.
func withEntitlementID(id string) entitlementOption {
	return func(m *EntitlementMutation) {
		var (
			err   error
			once  sync.Once
			value *Entitlement
		)
		m.oldValue = func(ctx context.Context) (*Entitlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entitlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlement sets the old Entitlement of the mutation.
func withEntitlement(node *Entitlement) entitlementOption {
	return func(m *EntitlementMutation) {
		m.oldValue = func(context.Context) (*Entitlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entitlement entities.
func (m *EntitlementMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entitlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *EntitlementMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *EntitlementMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *EntitlementMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *EntitlementMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EntitlementMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EntitlementMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[entitlement.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EntitlementMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EntitlementMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, entitlement.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitlementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitlementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitlementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitlement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitlementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitlementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitlement.FieldDeletedAt)
}

// SetEntitlementType sets the "entitlement_type" field.
func (m *EntitlementMutation) SetEntitlementType(et entitlement.EntitlementType) {
	m.entitlement_type = &et
}

// EntitlementType returns the value of the "entitlement_type" field in the mutation.
func (m *EntitlementMutation) EntitlementType() (r entitlement.EntitlementType, exists bool) {
	v := m.entitlement_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementType returns the old "entitlement_type" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldEntitlementType(ctx context.Context) (v entitlement.EntitlementType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementType: %w", err)
	}
	return oldValue.EntitlementType, nil
}

// ResetEntitlementType resets all changes to the "entitlement_type" field.
func (m *EntitlementMutation) ResetEntitlementType() {
	m.entitlement_type = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *EntitlementMutation) SetFeatureID(s string) {
	m.feature = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *EntitlementMutation) FeatureID() (r string, exists bool) {
	v := m.feature
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldFeatureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *EntitlementMutation) ResetFeatureID() {
	m.feature = nil
}

// SetFeatureKey sets the "feature_key" field.
func (m *EntitlementMutation) SetFeatureKey(s string) {
	m.feature_key = &s
}

// FeatureKey returns the value of the "feature_key" field in the mutation.
func (m *EntitlementMutation) FeatureKey() (r string, exists bool) {
	v := m.feature_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureKey returns the old "feature_key" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldFeatureKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureKey: %w", err)
	}
	return oldValue.FeatureKey, nil
}

// ResetFeatureKey resets all changes to the "feature_key" field.
func (m *EntitlementMutation) ResetFeatureKey() {
	m.feature_key = nil
}

// SetSubjectKey sets the "subject_key" field.
func (m *EntitlementMutation) SetSubjectKey(s string) {
	m.subject_key = &s
}

// SubjectKey returns the value of the "subject_key" field in the mutation.
func (m *EntitlementMutation) SubjectKey() (r string, exists bool) {
	v := m.subject_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectKey returns the old "subject_key" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldSubjectKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectKey: %w", err)
	}
	return oldValue.SubjectKey, nil
}

// ResetSubjectKey resets all changes to the "subject_key" field.
func (m *EntitlementMutation) ResetSubjectKey() {
	m.subject_key = nil
}

// SetMeasureUsageFrom sets the "measure_usage_from" field.
func (m *EntitlementMutation) SetMeasureUsageFrom(t time.Time) {
	m.measure_usage_from = &t
}

// MeasureUsageFrom returns the value of the "measure_usage_from" field in the mutation.
func (m *EntitlementMutation) MeasureUsageFrom() (r time.Time, exists bool) {
	v := m.measure_usage_from
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasureUsageFrom returns the old "measure_usage_from" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldMeasureUsageFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasureUsageFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasureUsageFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasureUsageFrom: %w", err)
	}
	return oldValue.MeasureUsageFrom, nil
}

// ClearMeasureUsageFrom clears the value of the "measure_usage_from" field.
func (m *EntitlementMutation) ClearMeasureUsageFrom() {
	m.measure_usage_from = nil
	m.clearedFields[entitlement.FieldMeasureUsageFrom] = struct{}{}
}

// MeasureUsageFromCleared returns if the "measure_usage_from" field was cleared in this mutation.
func (m *EntitlementMutation) MeasureUsageFromCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldMeasureUsageFrom]
	return ok
}

// ResetMeasureUsageFrom resets all changes to the "measure_usage_from" field.
func (m *EntitlementMutation) ResetMeasureUsageFrom() {
	m.measure_usage_from = nil
	delete(m.clearedFields, entitlement.FieldMeasureUsageFrom)
}

// SetIssueAfterReset sets the "issue_after_reset" field.
func (m *EntitlementMutation) SetIssueAfterReset(f float64) {
	m.issue_after_reset = &f
	m.addissue_after_reset = nil
}

// IssueAfterReset returns the value of the "issue_after_reset" field in the mutation.
func (m *EntitlementMutation) IssueAfterReset() (r float64, exists bool) {
	v := m.issue_after_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueAfterReset returns the old "issue_after_reset" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIssueAfterReset(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueAfterReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueAfterReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueAfterReset: %w", err)
	}
	return oldValue.IssueAfterReset, nil
}

// AddIssueAfterReset adds f to the "issue_after_reset" field.
func (m *EntitlementMutation) AddIssueAfterReset(f float64) {
	if m.addissue_after_reset != nil {
		*m.addissue_after_reset += f
	} else {
		m.addissue_after_reset = &f
	}
}

// AddedIssueAfterReset returns the value that was added to the "issue_after_reset" field in this mutation.
func (m *EntitlementMutation) AddedIssueAfterReset() (r float64, exists bool) {
	v := m.addissue_after_reset
	if v == nil {
		return
	}
	return *v, true
}

// ClearIssueAfterReset clears the value of the "issue_after_reset" field.
func (m *EntitlementMutation) ClearIssueAfterReset() {
	m.issue_after_reset = nil
	m.addissue_after_reset = nil
	m.clearedFields[entitlement.FieldIssueAfterReset] = struct{}{}
}

// IssueAfterResetCleared returns if the "issue_after_reset" field was cleared in this mutation.
func (m *EntitlementMutation) IssueAfterResetCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIssueAfterReset]
	return ok
}

// ResetIssueAfterReset resets all changes to the "issue_after_reset" field.
func (m *EntitlementMutation) ResetIssueAfterReset() {
	m.issue_after_reset = nil
	m.addissue_after_reset = nil
	delete(m.clearedFields, entitlement.FieldIssueAfterReset)
}

// SetIssueAfterResetPriority sets the "issue_after_reset_priority" field.
func (m *EntitlementMutation) SetIssueAfterResetPriority(u uint8) {
	m.issue_after_reset_priority = &u
	m.addissue_after_reset_priority = nil
}

// IssueAfterResetPriority returns the value of the "issue_after_reset_priority" field in the mutation.
func (m *EntitlementMutation) IssueAfterResetPriority() (r uint8, exists bool) {
	v := m.issue_after_reset_priority
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueAfterResetPriority returns the old "issue_after_reset_priority" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIssueAfterResetPriority(ctx context.Context) (v *uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueAfterResetPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueAfterResetPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueAfterResetPriority: %w", err)
	}
	return oldValue.IssueAfterResetPriority, nil
}

// AddIssueAfterResetPriority adds u to the "issue_after_reset_priority" field.
func (m *EntitlementMutation) AddIssueAfterResetPriority(u int8) {
	if m.addissue_after_reset_priority != nil {
		*m.addissue_after_reset_priority += u
	} else {
		m.addissue_after_reset_priority = &u
	}
}

// AddedIssueAfterResetPriority returns the value that was added to the "issue_after_reset_priority" field in this mutation.
func (m *EntitlementMutation) AddedIssueAfterResetPriority() (r int8, exists bool) {
	v := m.addissue_after_reset_priority
	if v == nil {
		return
	}
	return *v, true
}

// ClearIssueAfterResetPriority clears the value of the "issue_after_reset_priority" field.
func (m *EntitlementMutation) ClearIssueAfterResetPriority() {
	m.issue_after_reset_priority = nil
	m.addissue_after_reset_priority = nil
	m.clearedFields[entitlement.FieldIssueAfterResetPriority] = struct{}{}
}

// IssueAfterResetPriorityCleared returns if the "issue_after_reset_priority" field was cleared in this mutation.
func (m *EntitlementMutation) IssueAfterResetPriorityCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIssueAfterResetPriority]
	return ok
}

// ResetIssueAfterResetPriority resets all changes to the "issue_after_reset_priority" field.
func (m *EntitlementMutation) ResetIssueAfterResetPriority() {
	m.issue_after_reset_priority = nil
	m.addissue_after_reset_priority = nil
	delete(m.clearedFields, entitlement.FieldIssueAfterResetPriority)
}

// SetIsSoftLimit sets the "is_soft_limit" field.
func (m *EntitlementMutation) SetIsSoftLimit(b bool) {
	m.is_soft_limit = &b
}

// IsSoftLimit returns the value of the "is_soft_limit" field in the mutation.
func (m *EntitlementMutation) IsSoftLimit() (r bool, exists bool) {
	v := m.is_soft_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSoftLimit returns the old "is_soft_limit" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIsSoftLimit(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSoftLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSoftLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSoftLimit: %w", err)
	}
	return oldValue.IsSoftLimit, nil
}

// ClearIsSoftLimit clears the value of the "is_soft_limit" field.
func (m *EntitlementMutation) ClearIsSoftLimit() {
	m.is_soft_limit = nil
	m.clearedFields[entitlement.FieldIsSoftLimit] = struct{}{}
}

// IsSoftLimitCleared returns if the "is_soft_limit" field was cleared in this mutation.
func (m *EntitlementMutation) IsSoftLimitCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIsSoftLimit]
	return ok
}

// ResetIsSoftLimit resets all changes to the "is_soft_limit" field.
func (m *EntitlementMutation) ResetIsSoftLimit() {
	m.is_soft_limit = nil
	delete(m.clearedFields, entitlement.FieldIsSoftLimit)
}

// SetPreserveOverageAtReset sets the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) SetPreserveOverageAtReset(b bool) {
	m.preserve_overage_at_reset = &b
}

// PreserveOverageAtReset returns the value of the "preserve_overage_at_reset" field in the mutation.
func (m *EntitlementMutation) PreserveOverageAtReset() (r bool, exists bool) {
	v := m.preserve_overage_at_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldPreserveOverageAtReset returns the old "preserve_overage_at_reset" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldPreserveOverageAtReset(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreserveOverageAtReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreserveOverageAtReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreserveOverageAtReset: %w", err)
	}
	return oldValue.PreserveOverageAtReset, nil
}

// ClearPreserveOverageAtReset clears the value of the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) ClearPreserveOverageAtReset() {
	m.preserve_overage_at_reset = nil
	m.clearedFields[entitlement.FieldPreserveOverageAtReset] = struct{}{}
}

// PreserveOverageAtResetCleared returns if the "preserve_overage_at_reset" field was cleared in this mutation.
func (m *EntitlementMutation) PreserveOverageAtResetCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldPreserveOverageAtReset]
	return ok
}

// ResetPreserveOverageAtReset resets all changes to the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) ResetPreserveOverageAtReset() {
	m.preserve_overage_at_reset = nil
	delete(m.clearedFields, entitlement.FieldPreserveOverageAtReset)
}

// SetConfig sets the "config" field.
func (m *EntitlementMutation) SetConfig(u []uint8) {
	m._config = &u
	m.append_config = nil
}

// Config returns the value of the "config" field in the mutation.
func (m *EntitlementMutation) Config() (r []uint8, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldConfig(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// AppendConfig adds u to the "config" field.
func (m *EntitlementMutation) AppendConfig(u []uint8) {
	m.append_config = append(m.append_config, u...)
}

// AppendedConfig returns the list of values that were appended to the "config" field in this mutation.
func (m *EntitlementMutation) AppendedConfig() ([]uint8, bool) {
	if len(m.append_config) == 0 {
		return nil, false
	}
	return m.append_config, true
}

// ClearConfig clears the value of the "config" field.
func (m *EntitlementMutation) ClearConfig() {
	m._config = nil
	m.append_config = nil
	m.clearedFields[entitlement.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *EntitlementMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *EntitlementMutation) ResetConfig() {
	m._config = nil
	m.append_config = nil
	delete(m.clearedFields, entitlement.FieldConfig)
}

// SetUsagePeriodInterval sets the "usage_period_interval" field.
func (m *EntitlementMutation) SetUsagePeriodInterval(epi entitlement.UsagePeriodInterval) {
	m.usage_period_interval = &epi
}

// UsagePeriodInterval returns the value of the "usage_period_interval" field in the mutation.
func (m *EntitlementMutation) UsagePeriodInterval() (r entitlement.UsagePeriodInterval, exists bool) {
	v := m.usage_period_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldUsagePeriodInterval returns the old "usage_period_interval" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUsagePeriodInterval(ctx context.Context) (v *entitlement.UsagePeriodInterval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsagePeriodInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsagePeriodInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsagePeriodInterval: %w", err)
	}
	return oldValue.UsagePeriodInterval, nil
}

// ClearUsagePeriodInterval clears the value of the "usage_period_interval" field.
func (m *EntitlementMutation) ClearUsagePeriodInterval() {
	m.usage_period_interval = nil
	m.clearedFields[entitlement.FieldUsagePeriodInterval] = struct{}{}
}

// UsagePeriodIntervalCleared returns if the "usage_period_interval" field was cleared in this mutation.
func (m *EntitlementMutation) UsagePeriodIntervalCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldUsagePeriodInterval]
	return ok
}

// ResetUsagePeriodInterval resets all changes to the "usage_period_interval" field.
func (m *EntitlementMutation) ResetUsagePeriodInterval() {
	m.usage_period_interval = nil
	delete(m.clearedFields, entitlement.FieldUsagePeriodInterval)
}

// SetUsagePeriodAnchor sets the "usage_period_anchor" field.
func (m *EntitlementMutation) SetUsagePeriodAnchor(t time.Time) {
	m.usage_period_anchor = &t
}

// UsagePeriodAnchor returns the value of the "usage_period_anchor" field in the mutation.
func (m *EntitlementMutation) UsagePeriodAnchor() (r time.Time, exists bool) {
	v := m.usage_period_anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldUsagePeriodAnchor returns the old "usage_period_anchor" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUsagePeriodAnchor(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsagePeriodAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsagePeriodAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsagePeriodAnchor: %w", err)
	}
	return oldValue.UsagePeriodAnchor, nil
}

// ClearUsagePeriodAnchor clears the value of the "usage_period_anchor" field.
func (m *EntitlementMutation) ClearUsagePeriodAnchor() {
	m.usage_period_anchor = nil
	m.clearedFields[entitlement.FieldUsagePeriodAnchor] = struct{}{}
}

// UsagePeriodAnchorCleared returns if the "usage_period_anchor" field was cleared in this mutation.
func (m *EntitlementMutation) UsagePeriodAnchorCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldUsagePeriodAnchor]
	return ok
}

// ResetUsagePeriodAnchor resets all changes to the "usage_period_anchor" field.
func (m *EntitlementMutation) ResetUsagePeriodAnchor() {
	m.usage_period_anchor = nil
	delete(m.clearedFields, entitlement.FieldUsagePeriodAnchor)
}

// SetCurrentUsagePeriodStart sets the "current_usage_period_start" field.
func (m *EntitlementMutation) SetCurrentUsagePeriodStart(t time.Time) {
	m.current_usage_period_start = &t
}

// CurrentUsagePeriodStart returns the value of the "current_usage_period_start" field in the mutation.
func (m *EntitlementMutation) CurrentUsagePeriodStart() (r time.Time, exists bool) {
	v := m.current_usage_period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentUsagePeriodStart returns the old "current_usage_period_start" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCurrentUsagePeriodStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentUsagePeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentUsagePeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentUsagePeriodStart: %w", err)
	}
	return oldValue.CurrentUsagePeriodStart, nil
}

// ClearCurrentUsagePeriodStart clears the value of the "current_usage_period_start" field.
func (m *EntitlementMutation) ClearCurrentUsagePeriodStart() {
	m.current_usage_period_start = nil
	m.clearedFields[entitlement.FieldCurrentUsagePeriodStart] = struct{}{}
}

// CurrentUsagePeriodStartCleared returns if the "current_usage_period_start" field was cleared in this mutation.
func (m *EntitlementMutation) CurrentUsagePeriodStartCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldCurrentUsagePeriodStart]
	return ok
}

// ResetCurrentUsagePeriodStart resets all changes to the "current_usage_period_start" field.
func (m *EntitlementMutation) ResetCurrentUsagePeriodStart() {
	m.current_usage_period_start = nil
	delete(m.clearedFields, entitlement.FieldCurrentUsagePeriodStart)
}

// SetCurrentUsagePeriodEnd sets the "current_usage_period_end" field.
func (m *EntitlementMutation) SetCurrentUsagePeriodEnd(t time.Time) {
	m.current_usage_period_end = &t
}

// CurrentUsagePeriodEnd returns the value of the "current_usage_period_end" field in the mutation.
func (m *EntitlementMutation) CurrentUsagePeriodEnd() (r time.Time, exists bool) {
	v := m.current_usage_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentUsagePeriodEnd returns the old "current_usage_period_end" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCurrentUsagePeriodEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentUsagePeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentUsagePeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentUsagePeriodEnd: %w", err)
	}
	return oldValue.CurrentUsagePeriodEnd, nil
}

// ClearCurrentUsagePeriodEnd clears the value of the "current_usage_period_end" field.
func (m *EntitlementMutation) ClearCurrentUsagePeriodEnd() {
	m.current_usage_period_end = nil
	m.clearedFields[entitlement.FieldCurrentUsagePeriodEnd] = struct{}{}
}

// CurrentUsagePeriodEndCleared returns if the "current_usage_period_end" field was cleared in this mutation.
func (m *EntitlementMutation) CurrentUsagePeriodEndCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldCurrentUsagePeriodEnd]
	return ok
}

// ResetCurrentUsagePeriodEnd resets all changes to the "current_usage_period_end" field.
func (m *EntitlementMutation) ResetCurrentUsagePeriodEnd() {
	m.current_usage_period_end = nil
	delete(m.clearedFields, entitlement.FieldCurrentUsagePeriodEnd)
}

// AddUsageResetIDs adds the "usage_reset" edge to the UsageReset entity by ids.
func (m *EntitlementMutation) AddUsageResetIDs(ids ...string) {
	if m.usage_reset == nil {
		m.usage_reset = make(map[string]struct{})
	}
	for i := range ids {
		m.usage_reset[ids[i]] = struct{}{}
	}
}

// ClearUsageReset clears the "usage_reset" edge to the UsageReset entity.
func (m *EntitlementMutation) ClearUsageReset() {
	m.clearedusage_reset = true
}

// UsageResetCleared reports if the "usage_reset" edge to the UsageReset entity was cleared.
func (m *EntitlementMutation) UsageResetCleared() bool {
	return m.clearedusage_reset
}

// RemoveUsageResetIDs removes the "usage_reset" edge to the UsageReset entity by IDs.
func (m *EntitlementMutation) RemoveUsageResetIDs(ids ...string) {
	if m.removedusage_reset == nil {
		m.removedusage_reset = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.usage_reset, ids[i])
		m.removedusage_reset[ids[i]] = struct{}{}
	}
}

// RemovedUsageReset returns the removed IDs of the "usage_reset" edge to the UsageReset entity.
func (m *EntitlementMutation) RemovedUsageResetIDs() (ids []string) {
	for id := range m.removedusage_reset {
		ids = append(ids, id)
	}
	return
}

// UsageResetIDs returns the "usage_reset" edge IDs in the mutation.
func (m *EntitlementMutation) UsageResetIDs() (ids []string) {
	for id := range m.usage_reset {
		ids = append(ids, id)
	}
	return
}

// ResetUsageReset resets all changes to the "usage_reset" edge.
func (m *EntitlementMutation) ResetUsageReset() {
	m.usage_reset = nil
	m.clearedusage_reset = false
	m.removedusage_reset = nil
}

// AddGrantIDs adds the "grant" edge to the Grant entity by ids.
func (m *EntitlementMutation) AddGrantIDs(ids ...string) {
	if m.grant == nil {
		m.grant = make(map[string]struct{})
	}
	for i := range ids {
		m.grant[ids[i]] = struct{}{}
	}
}

// ClearGrant clears the "grant" edge to the Grant entity.
func (m *EntitlementMutation) ClearGrant() {
	m.clearedgrant = true
}

// GrantCleared reports if the "grant" edge to the Grant entity was cleared.
func (m *EntitlementMutation) GrantCleared() bool {
	return m.clearedgrant
}

// RemoveGrantIDs removes the "grant" edge to the Grant entity by IDs.
func (m *EntitlementMutation) RemoveGrantIDs(ids ...string) {
	if m.removedgrant == nil {
		m.removedgrant = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.grant, ids[i])
		m.removedgrant[ids[i]] = struct{}{}
	}
}

// RemovedGrant returns the removed IDs of the "grant" edge to the Grant entity.
func (m *EntitlementMutation) RemovedGrantIDs() (ids []string) {
	for id := range m.removedgrant {
		ids = append(ids, id)
	}
	return
}

// GrantIDs returns the "grant" edge IDs in the mutation.
func (m *EntitlementMutation) GrantIDs() (ids []string) {
	for id := range m.grant {
		ids = append(ids, id)
	}
	return
}

// ResetGrant resets all changes to the "grant" edge.
func (m *EntitlementMutation) ResetGrant() {
	m.grant = nil
	m.clearedgrant = false
	m.removedgrant = nil
}

// AddBalanceSnapshotIDs adds the "balance_snapshot" edge to the BalanceSnapshot entity by ids.
func (m *EntitlementMutation) AddBalanceSnapshotIDs(ids ...int) {
	if m.balance_snapshot == nil {
		m.balance_snapshot = make(map[int]struct{})
	}
	for i := range ids {
		m.balance_snapshot[ids[i]] = struct{}{}
	}
}

// ClearBalanceSnapshot clears the "balance_snapshot" edge to the BalanceSnapshot entity.
func (m *EntitlementMutation) ClearBalanceSnapshot() {
	m.clearedbalance_snapshot = true
}

// BalanceSnapshotCleared reports if the "balance_snapshot" edge to the BalanceSnapshot entity was cleared.
func (m *EntitlementMutation) BalanceSnapshotCleared() bool {
	return m.clearedbalance_snapshot
}

// RemoveBalanceSnapshotIDs removes the "balance_snapshot" edge to the BalanceSnapshot entity by IDs.
func (m *EntitlementMutation) RemoveBalanceSnapshotIDs(ids ...int) {
	if m.removedbalance_snapshot == nil {
		m.removedbalance_snapshot = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.balance_snapshot, ids[i])
		m.removedbalance_snapshot[ids[i]] = struct{}{}
	}
}

// RemovedBalanceSnapshot returns the removed IDs of the "balance_snapshot" edge to the BalanceSnapshot entity.
func (m *EntitlementMutation) RemovedBalanceSnapshotIDs() (ids []int) {
	for id := range m.removedbalance_snapshot {
		ids = append(ids, id)
	}
	return
}

// BalanceSnapshotIDs returns the "balance_snapshot" edge IDs in the mutation.
func (m *EntitlementMutation) BalanceSnapshotIDs() (ids []int) {
	for id := range m.balance_snapshot {
		ids = append(ids, id)
	}
	return
}

// ResetBalanceSnapshot resets all changes to the "balance_snapshot" edge.
func (m *EntitlementMutation) ResetBalanceSnapshot() {
	m.balance_snapshot = nil
	m.clearedbalance_snapshot = false
	m.removedbalance_snapshot = nil
}

// ClearFeature clears the "feature" edge to the Feature entity.
func (m *EntitlementMutation) ClearFeature() {
	m.clearedfeature = true
	m.clearedFields[entitlement.FieldFeatureID] = struct{}{}
}

// FeatureCleared reports if the "feature" edge to the Feature entity was cleared.
func (m *EntitlementMutation) FeatureCleared() bool {
	return m.clearedfeature
}

// FeatureIDs returns the "feature" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureID instead. It exists only for internal usage by the builders.
func (m *EntitlementMutation) FeatureIDs() (ids []string) {
	if id := m.feature; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeature resets all changes to the "feature" edge.
func (m *EntitlementMutation) ResetFeature() {
	m.feature = nil
	m.clearedfeature = false
}

// Where appends a list predicates to the EntitlementMutation builder.
func (m *EntitlementMutation) Where(ps ...predicate.Entitlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entitlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entitlement).
func (m *EntitlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.namespace != nil {
		fields = append(fields, entitlement.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, entitlement.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, entitlement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitlement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitlement.FieldDeletedAt)
	}
	if m.entitlement_type != nil {
		fields = append(fields, entitlement.FieldEntitlementType)
	}
	if m.feature != nil {
		fields = append(fields, entitlement.FieldFeatureID)
	}
	if m.feature_key != nil {
		fields = append(fields, entitlement.FieldFeatureKey)
	}
	if m.subject_key != nil {
		fields = append(fields, entitlement.FieldSubjectKey)
	}
	if m.measure_usage_from != nil {
		fields = append(fields, entitlement.FieldMeasureUsageFrom)
	}
	if m.issue_after_reset != nil {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.issue_after_reset_priority != nil {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	if m.is_soft_limit != nil {
		fields = append(fields, entitlement.FieldIsSoftLimit)
	}
	if m.preserve_overage_at_reset != nil {
		fields = append(fields, entitlement.FieldPreserveOverageAtReset)
	}
	if m._config != nil {
		fields = append(fields, entitlement.FieldConfig)
	}
	if m.usage_period_interval != nil {
		fields = append(fields, entitlement.FieldUsagePeriodInterval)
	}
	if m.usage_period_anchor != nil {
		fields = append(fields, entitlement.FieldUsagePeriodAnchor)
	}
	if m.current_usage_period_start != nil {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodStart)
	}
	if m.current_usage_period_end != nil {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodEnd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlement.FieldNamespace:
		return m.Namespace()
	case entitlement.FieldMetadata:
		return m.Metadata()
	case entitlement.FieldCreatedAt:
		return m.CreatedAt()
	case entitlement.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitlement.FieldDeletedAt:
		return m.DeletedAt()
	case entitlement.FieldEntitlementType:
		return m.EntitlementType()
	case entitlement.FieldFeatureID:
		return m.FeatureID()
	case entitlement.FieldFeatureKey:
		return m.FeatureKey()
	case entitlement.FieldSubjectKey:
		return m.SubjectKey()
	case entitlement.FieldMeasureUsageFrom:
		return m.MeasureUsageFrom()
	case entitlement.FieldIssueAfterReset:
		return m.IssueAfterReset()
	case entitlement.FieldIssueAfterResetPriority:
		return m.IssueAfterResetPriority()
	case entitlement.FieldIsSoftLimit:
		return m.IsSoftLimit()
	case entitlement.FieldPreserveOverageAtReset:
		return m.PreserveOverageAtReset()
	case entitlement.FieldConfig:
		return m.Config()
	case entitlement.FieldUsagePeriodInterval:
		return m.UsagePeriodInterval()
	case entitlement.FieldUsagePeriodAnchor:
		return m.UsagePeriodAnchor()
	case entitlement.FieldCurrentUsagePeriodStart:
		return m.CurrentUsagePeriodStart()
	case entitlement.FieldCurrentUsagePeriodEnd:
		return m.CurrentUsagePeriodEnd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlement.FieldNamespace:
		return m.OldNamespace(ctx)
	case entitlement.FieldMetadata:
		return m.OldMetadata(ctx)
	case entitlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitlement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitlement.FieldEntitlementType:
		return m.OldEntitlementType(ctx)
	case entitlement.FieldFeatureID:
		return m.OldFeatureID(ctx)
	case entitlement.FieldFeatureKey:
		return m.OldFeatureKey(ctx)
	case entitlement.FieldSubjectKey:
		return m.OldSubjectKey(ctx)
	case entitlement.FieldMeasureUsageFrom:
		return m.OldMeasureUsageFrom(ctx)
	case entitlement.FieldIssueAfterReset:
		return m.OldIssueAfterReset(ctx)
	case entitlement.FieldIssueAfterResetPriority:
		return m.OldIssueAfterResetPriority(ctx)
	case entitlement.FieldIsSoftLimit:
		return m.OldIsSoftLimit(ctx)
	case entitlement.FieldPreserveOverageAtReset:
		return m.OldPreserveOverageAtReset(ctx)
	case entitlement.FieldConfig:
		return m.OldConfig(ctx)
	case entitlement.FieldUsagePeriodInterval:
		return m.OldUsagePeriodInterval(ctx)
	case entitlement.FieldUsagePeriodAnchor:
		return m.OldUsagePeriodAnchor(ctx)
	case entitlement.FieldCurrentUsagePeriodStart:
		return m.OldCurrentUsagePeriodStart(ctx)
	case entitlement.FieldCurrentUsagePeriodEnd:
		return m.OldCurrentUsagePeriodEnd(ctx)
	}
	return nil, fmt.Errorf("unknown Entitlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlement.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case entitlement.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case entitlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitlement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitlement.FieldEntitlementType:
		v, ok := value.(entitlement.EntitlementType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementType(v)
		return nil
	case entitlement.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	case entitlement.FieldFeatureKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureKey(v)
		return nil
	case entitlement.FieldSubjectKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectKey(v)
		return nil
	case entitlement.FieldMeasureUsageFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasureUsageFrom(v)
		return nil
	case entitlement.FieldIssueAfterReset:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueAfterReset(v)
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueAfterResetPriority(v)
		return nil
	case entitlement.FieldIsSoftLimit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSoftLimit(v)
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreserveOverageAtReset(v)
		return nil
	case entitlement.FieldConfig:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case entitlement.FieldUsagePeriodInterval:
		v, ok := value.(entitlement.UsagePeriodInterval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsagePeriodInterval(v)
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsagePeriodAnchor(v)
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentUsagePeriodStart(v)
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentUsagePeriodEnd(v)
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementMutation) AddedFields() []string {
	var fields []string
	if m.addissue_after_reset != nil {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.addissue_after_reset_priority != nil {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entitlement.FieldIssueAfterReset:
		return m.AddedIssueAfterReset()
	case entitlement.FieldIssueAfterResetPriority:
		return m.AddedIssueAfterResetPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entitlement.FieldIssueAfterReset:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIssueAfterReset(v)
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIssueAfterResetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Entitlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlement.FieldMetadata) {
		fields = append(fields, entitlement.FieldMetadata)
	}
	if m.FieldCleared(entitlement.FieldDeletedAt) {
		fields = append(fields, entitlement.FieldDeletedAt)
	}
	if m.FieldCleared(entitlement.FieldMeasureUsageFrom) {
		fields = append(fields, entitlement.FieldMeasureUsageFrom)
	}
	if m.FieldCleared(entitlement.FieldIssueAfterReset) {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.FieldCleared(entitlement.FieldIssueAfterResetPriority) {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	if m.FieldCleared(entitlement.FieldIsSoftLimit) {
		fields = append(fields, entitlement.FieldIsSoftLimit)
	}
	if m.FieldCleared(entitlement.FieldPreserveOverageAtReset) {
		fields = append(fields, entitlement.FieldPreserveOverageAtReset)
	}
	if m.FieldCleared(entitlement.FieldConfig) {
		fields = append(fields, entitlement.FieldConfig)
	}
	if m.FieldCleared(entitlement.FieldUsagePeriodInterval) {
		fields = append(fields, entitlement.FieldUsagePeriodInterval)
	}
	if m.FieldCleared(entitlement.FieldUsagePeriodAnchor) {
		fields = append(fields, entitlement.FieldUsagePeriodAnchor)
	}
	if m.FieldCleared(entitlement.FieldCurrentUsagePeriodStart) {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodStart)
	}
	if m.FieldCleared(entitlement.FieldCurrentUsagePeriodEnd) {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodEnd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementMutation) ClearField(name string) error {
	switch name {
	case entitlement.FieldMetadata:
		m.ClearMetadata()
		return nil
	case entitlement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitlement.FieldMeasureUsageFrom:
		m.ClearMeasureUsageFrom()
		return nil
	case entitlement.FieldIssueAfterReset:
		m.ClearIssueAfterReset()
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		m.ClearIssueAfterResetPriority()
		return nil
	case entitlement.FieldIsSoftLimit:
		m.ClearIsSoftLimit()
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		m.ClearPreserveOverageAtReset()
		return nil
	case entitlement.FieldConfig:
		m.ClearConfig()
		return nil
	case entitlement.FieldUsagePeriodInterval:
		m.ClearUsagePeriodInterval()
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		m.ClearUsagePeriodAnchor()
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		m.ClearCurrentUsagePeriodStart()
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		m.ClearCurrentUsagePeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown Entitlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementMutation) ResetField(name string) error {
	switch name {
	case entitlement.FieldNamespace:
		m.ResetNamespace()
		return nil
	case entitlement.FieldMetadata:
		m.ResetMetadata()
		return nil
	case entitlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitlement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitlement.FieldEntitlementType:
		m.ResetEntitlementType()
		return nil
	case entitlement.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	case entitlement.FieldFeatureKey:
		m.ResetFeatureKey()
		return nil
	case entitlement.FieldSubjectKey:
		m.ResetSubjectKey()
		return nil
	case entitlement.FieldMeasureUsageFrom:
		m.ResetMeasureUsageFrom()
		return nil
	case entitlement.FieldIssueAfterReset:
		m.ResetIssueAfterReset()
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		m.ResetIssueAfterResetPriority()
		return nil
	case entitlement.FieldIsSoftLimit:
		m.ResetIsSoftLimit()
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		m.ResetPreserveOverageAtReset()
		return nil
	case entitlement.FieldConfig:
		m.ResetConfig()
		return nil
	case entitlement.FieldUsagePeriodInterval:
		m.ResetUsagePeriodInterval()
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		m.ResetUsagePeriodAnchor()
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		m.ResetCurrentUsagePeriodStart()
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		m.ResetCurrentUsagePeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.usage_reset != nil {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.grant != nil {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.balance_snapshot != nil {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	if m.feature != nil {
		edges = append(edges, entitlement.EdgeFeature)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgeUsageReset:
		ids := make([]ent.Value, 0, len(m.usage_reset))
		for id := range m.usage_reset {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeGrant:
		ids := make([]ent.Value, 0, len(m.grant))
		for id := range m.grant {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeBalanceSnapshot:
		ids := make([]ent.Value, 0, len(m.balance_snapshot))
		for id := range m.balance_snapshot {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeFeature:
		if id := m.feature; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedusage_reset != nil {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.removedgrant != nil {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.removedbalance_snapshot != nil {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgeUsageReset:
		ids := make([]ent.Value, 0, len(m.removedusage_reset))
		for id := range m.removedusage_reset {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeGrant:
		ids := make([]ent.Value, 0, len(m.removedgrant))
		for id := range m.removedgrant {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeBalanceSnapshot:
		ids := make([]ent.Value, 0, len(m.removedbalance_snapshot))
		for id := range m.removedbalance_snapshot {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedusage_reset {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.clearedgrant {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.clearedbalance_snapshot {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	if m.clearedfeature {
		edges = append(edges, entitlement.EdgeFeature)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementMutation) EdgeCleared(name string) bool {
	switch name {
	case entitlement.EdgeUsageReset:
		return m.clearedusage_reset
	case entitlement.EdgeGrant:
		return m.clearedgrant
	case entitlement.EdgeBalanceSnapshot:
		return m.clearedbalance_snapshot
	case entitlement.EdgeFeature:
		return m.clearedfeature
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementMutation) ClearEdge(name string) error {
	switch name {
	case entitlement.EdgeFeature:
		m.ClearFeature()
		return nil
	}
	return fmt.Errorf("unknown Entitlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementMutation) ResetEdge(name string) error {
	switch name {
	case entitlement.EdgeUsageReset:
		m.ResetUsageReset()
		return nil
	case entitlement.EdgeGrant:
		m.ResetGrant()
		return nil
	case entitlement.EdgeBalanceSnapshot:
		m.ResetBalanceSnapshot()
		return nil
	case entitlement.EdgeFeature:
		m.ResetFeature()
		return nil
	}
	return fmt.Errorf("unknown Entitlement edge %s", name)
}

// FeatureMutation represents an operation that mutates the Feature nodes in the graph.
type FeatureMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	metadata               *map[string]string
	namespace              *string
	name                   *string
	key                    *string
	meter_slug             *string
	meter_group_by_filters *map[string]string
	archived_at            *time.Time
	clearedFields          map[string]struct{}
	entitlement            map[string]struct{}
	removedentitlement     map[string]struct{}
	clearedentitlement     bool
	done                   bool
	oldValue               func(context.Context) (*Feature, error)
	predicates             []predicate.Feature
}

var _ ent.Mutation = (*FeatureMutation)(nil)

// featureOption allows management of the mutation configuration using functional options.
type featureOption func(*FeatureMutation)

// newFeatureMutation creates new mutation for the Feature entity.
func newFeatureMutation(c config, op Op, opts ...featureOption) *FeatureMutation {
	m := &FeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureID sets the ID field of the mutation.
func withFeatureID(id string) featureOption {
	return func(m *FeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *Feature
		)
		m.oldValue = func(ctx context.Context) (*Feature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeature sets the old Feature of the mutation.
func withFeature(node *Feature) featureOption {
	return func(m *FeatureMutation) {
		m.oldValue = func(context.Context) (*Feature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feature entities.
func (m *FeatureMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeatureMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeatureMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeatureMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[feature.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeatureMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeatureMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, feature.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *FeatureMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *FeatureMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *FeatureMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[feature.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *FeatureMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[feature.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *FeatureMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, feature.FieldMetadata)
}

// SetNamespace sets the "namespace" field.
func (m *FeatureMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *FeatureMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *FeatureMutation) ResetNamespace() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *FeatureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *FeatureMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *FeatureMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *FeatureMutation) ResetKey() {
	m.key = nil
}

// SetMeterSlug sets the "meter_slug" field.
func (m *FeatureMutation) SetMeterSlug(s string) {
	m.meter_slug = &s
}

// MeterSlug returns the value of the "meter_slug" field in the mutation.
func (m *FeatureMutation) MeterSlug() (r string, exists bool) {
	v := m.meter_slug
	if v == nil {
		return
	}
	return *v, true
}

// OldMeterSlug returns the old "meter_slug" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMeterSlug(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeterSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeterSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeterSlug: %w", err)
	}
	return oldValue.MeterSlug, nil
}

// ClearMeterSlug clears the value of the "meter_slug" field.
func (m *FeatureMutation) ClearMeterSlug() {
	m.meter_slug = nil
	m.clearedFields[feature.FieldMeterSlug] = struct{}{}
}

// MeterSlugCleared returns if the "meter_slug" field was cleared in this mutation.
func (m *FeatureMutation) MeterSlugCleared() bool {
	_, ok := m.clearedFields[feature.FieldMeterSlug]
	return ok
}

// ResetMeterSlug resets all changes to the "meter_slug" field.
func (m *FeatureMutation) ResetMeterSlug() {
	m.meter_slug = nil
	delete(m.clearedFields, feature.FieldMeterSlug)
}

// SetMeterGroupByFilters sets the "meter_group_by_filters" field.
func (m *FeatureMutation) SetMeterGroupByFilters(value map[string]string) {
	m.meter_group_by_filters = &value
}

// MeterGroupByFilters returns the value of the "meter_group_by_filters" field in the mutation.
func (m *FeatureMutation) MeterGroupByFilters() (r map[string]string, exists bool) {
	v := m.meter_group_by_filters
	if v == nil {
		return
	}
	return *v, true
}

// OldMeterGroupByFilters returns the old "meter_group_by_filters" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMeterGroupByFilters(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeterGroupByFilters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeterGroupByFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeterGroupByFilters: %w", err)
	}
	return oldValue.MeterGroupByFilters, nil
}

// ClearMeterGroupByFilters clears the value of the "meter_group_by_filters" field.
func (m *FeatureMutation) ClearMeterGroupByFilters() {
	m.meter_group_by_filters = nil
	m.clearedFields[feature.FieldMeterGroupByFilters] = struct{}{}
}

// MeterGroupByFiltersCleared returns if the "meter_group_by_filters" field was cleared in this mutation.
func (m *FeatureMutation) MeterGroupByFiltersCleared() bool {
	_, ok := m.clearedFields[feature.FieldMeterGroupByFilters]
	return ok
}

// ResetMeterGroupByFilters resets all changes to the "meter_group_by_filters" field.
func (m *FeatureMutation) ResetMeterGroupByFilters() {
	m.meter_group_by_filters = nil
	delete(m.clearedFields, feature.FieldMeterGroupByFilters)
}

// SetArchivedAt sets the "archived_at" field.
func (m *FeatureMutation) SetArchivedAt(t time.Time) {
	m.archived_at = &t
}

// ArchivedAt returns the value of the "archived_at" field in the mutation.
func (m *FeatureMutation) ArchivedAt() (r time.Time, exists bool) {
	v := m.archived_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedAt returns the old "archived_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldArchivedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedAt: %w", err)
	}
	return oldValue.ArchivedAt, nil
}

// ClearArchivedAt clears the value of the "archived_at" field.
func (m *FeatureMutation) ClearArchivedAt() {
	m.archived_at = nil
	m.clearedFields[feature.FieldArchivedAt] = struct{}{}
}

// ArchivedAtCleared returns if the "archived_at" field was cleared in this mutation.
func (m *FeatureMutation) ArchivedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldArchivedAt]
	return ok
}

// ResetArchivedAt resets all changes to the "archived_at" field.
func (m *FeatureMutation) ResetArchivedAt() {
	m.archived_at = nil
	delete(m.clearedFields, feature.FieldArchivedAt)
}

// AddEntitlementIDs adds the "entitlement" edge to the Entitlement entity by ids.
func (m *FeatureMutation) AddEntitlementIDs(ids ...string) {
	if m.entitlement == nil {
		m.entitlement = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlement[ids[i]] = struct{}{}
	}
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *FeatureMutation) ClearEntitlement() {
	m.clearedentitlement = true
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *FeatureMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// RemoveEntitlementIDs removes the "entitlement" edge to the Entitlement entity by IDs.
func (m *FeatureMutation) RemoveEntitlementIDs(ids ...string) {
	if m.removedentitlement == nil {
		m.removedentitlement = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlement, ids[i])
		m.removedentitlement[ids[i]] = struct{}{}
	}
}

// RemovedEntitlement returns the removed IDs of the "entitlement" edge to the Entitlement entity.
func (m *FeatureMutation) RemovedEntitlementIDs() (ids []string) {
	for id := range m.removedentitlement {
		ids = append(ids, id)
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
func (m *FeatureMutation) EntitlementIDs() (ids []string) {
	for id := range m.entitlement {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *FeatureMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
	m.removedentitlement = nil
}

// Where appends a list predicates to the FeatureMutation builder.
func (m *FeatureMutation) Where(ps ...predicate.Feature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feature).
func (m *FeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, feature.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feature.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, feature.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, feature.FieldMetadata)
	}
	if m.namespace != nil {
		fields = append(fields, feature.FieldNamespace)
	}
	if m.name != nil {
		fields = append(fields, feature.FieldName)
	}
	if m.key != nil {
		fields = append(fields, feature.FieldKey)
	}
	if m.meter_slug != nil {
		fields = append(fields, feature.FieldMeterSlug)
	}
	if m.meter_group_by_filters != nil {
		fields = append(fields, feature.FieldMeterGroupByFilters)
	}
	if m.archived_at != nil {
		fields = append(fields, feature.FieldArchivedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feature.FieldCreatedAt:
		return m.CreatedAt()
	case feature.FieldUpdatedAt:
		return m.UpdatedAt()
	case feature.FieldDeletedAt:
		return m.DeletedAt()
	case feature.FieldMetadata:
		return m.Metadata()
	case feature.FieldNamespace:
		return m.Namespace()
	case feature.FieldName:
		return m.Name()
	case feature.FieldKey:
		return m.Key()
	case feature.FieldMeterSlug:
		return m.MeterSlug()
	case feature.FieldMeterGroupByFilters:
		return m.MeterGroupByFilters()
	case feature.FieldArchivedAt:
		return m.ArchivedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feature.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feature.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case feature.FieldMetadata:
		return m.OldMetadata(ctx)
	case feature.FieldNamespace:
		return m.OldNamespace(ctx)
	case feature.FieldName:
		return m.OldName(ctx)
	case feature.FieldKey:
		return m.OldKey(ctx)
	case feature.FieldMeterSlug:
		return m.OldMeterSlug(ctx)
	case feature.FieldMeterGroupByFilters:
		return m.OldMeterGroupByFilters(ctx)
	case feature.FieldArchivedAt:
		return m.OldArchivedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Feature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feature.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feature.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case feature.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case feature.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case feature.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feature.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case feature.FieldMeterSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeterSlug(v)
		return nil
	case feature.FieldMeterGroupByFilters:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeterGroupByFilters(v)
		return nil
	case feature.FieldArchivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feature.FieldDeletedAt) {
		fields = append(fields, feature.FieldDeletedAt)
	}
	if m.FieldCleared(feature.FieldMetadata) {
		fields = append(fields, feature.FieldMetadata)
	}
	if m.FieldCleared(feature.FieldMeterSlug) {
		fields = append(fields, feature.FieldMeterSlug)
	}
	if m.FieldCleared(feature.FieldMeterGroupByFilters) {
		fields = append(fields, feature.FieldMeterGroupByFilters)
	}
	if m.FieldCleared(feature.FieldArchivedAt) {
		fields = append(fields, feature.FieldArchivedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureMutation) ClearField(name string) error {
	switch name {
	case feature.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case feature.FieldMetadata:
		m.ClearMetadata()
		return nil
	case feature.FieldMeterSlug:
		m.ClearMeterSlug()
		return nil
	case feature.FieldMeterGroupByFilters:
		m.ClearMeterGroupByFilters()
		return nil
	case feature.FieldArchivedAt:
		m.ClearArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Feature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureMutation) ResetField(name string) error {
	switch name {
	case feature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feature.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feature.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case feature.FieldMetadata:
		m.ResetMetadata()
		return nil
	case feature.FieldNamespace:
		m.ResetNamespace()
		return nil
	case feature.FieldName:
		m.ResetName()
		return nil
	case feature.FieldKey:
		m.ResetKey()
		return nil
	case feature.FieldMeterSlug:
		m.ResetMeterSlug()
		return nil
	case feature.FieldMeterGroupByFilters:
		m.ResetMeterGroupByFilters()
		return nil
	case feature.FieldArchivedAt:
		m.ResetArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, feature.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeEntitlement:
		ids := make([]ent.Value, 0, len(m.entitlement))
		for id := range m.entitlement {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedentitlement != nil {
		edges = append(edges, feature.EdgeEntitlement)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeEntitlement:
		ids := make([]ent.Value, 0, len(m.removedentitlement))
		for id := range m.removedentitlement {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, feature.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case feature.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureMutation) ResetEdge(name string) error {
	switch name {
	case feature.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown Feature edge %s", name)
}

// GrantMutation represents an operation that mutates the Grant nodes in the graph.
type GrantMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	namespace             *string
	metadata              *map[string]string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	amount                *float64
	addamount             *float64
	priority              *uint8
	addpriority           *int8
	effective_at          *time.Time
	expiration            *grant.ExpirationPeriod
	expires_at            *time.Time
	voided_at             *time.Time
	reset_max_rollover    *float64
	addreset_max_rollover *float64
	reset_min_rollover    *float64
	addreset_min_rollover *float64
	recurrence_period     *recurrence.RecurrenceInterval
	recurrence_anchor     *time.Time
	clearedFields         map[string]struct{}
	entitlement           *string
	clearedentitlement    bool
	done                  bool
	oldValue              func(context.Context) (*Grant, error)
	predicates            []predicate.Grant
}

var _ ent.Mutation = (*GrantMutation)(nil)

// grantOption allows management of the mutation configuration using functional options.
type grantOption func(*GrantMutation)

// newGrantMutation creates new mutation for the Grant entity.
func newGrantMutation(c config, op Op, opts ...grantOption) *GrantMutation {
	m := &GrantMutation{
		config:        c,
		op:            op,
		typ:           TypeGrant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrantID sets the ID field of the mutation.
func withGrantID(id string) grantOption {
	return func(m *GrantMutation) {
		var (
			err   error
			once  sync.Once
			value *Grant
		)
		m.oldValue = func(ctx context.Context) (*Grant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrant sets the old Grant of the mutation.
func withGrant(node *Grant) grantOption {
	return func(m *GrantMutation) {
		m.oldValue = func(context.Context) (*Grant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Grant entities.
func (m *GrantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GrantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GrantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Grant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *GrantMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *GrantMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *GrantMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *GrantMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *GrantMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *GrantMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[dbgrant.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *GrantMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *GrantMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, dbgrant.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *GrantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GrantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GrantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GrantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GrantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GrantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GrantMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GrantMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GrantMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dbgrant.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GrantMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GrantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dbgrant.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *GrantMutation) SetOwnerID(s string) {
	m.entitlement = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *GrantMutation) OwnerID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *GrantMutation) ResetOwnerID() {
	m.entitlement = nil
}

// SetAmount sets the "amount" field.
func (m *GrantMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GrantMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *GrantMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *GrantMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *GrantMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPriority sets the "priority" field.
func (m *GrantMutation) SetPriority(u uint8) {
	m.priority = &u
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *GrantMutation) Priority() (r uint8, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldPriority(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds u to the "priority" field.
func (m *GrantMutation) AddPriority(u int8) {
	if m.addpriority != nil {
		*m.addpriority += u
	} else {
		m.addpriority = &u
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *GrantMutation) AddedPriority() (r int8, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *GrantMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetEffectiveAt sets the "effective_at" field.
func (m *GrantMutation) SetEffectiveAt(t time.Time) {
	m.effective_at = &t
}

// EffectiveAt returns the value of the "effective_at" field in the mutation.
func (m *GrantMutation) EffectiveAt() (r time.Time, exists bool) {
	v := m.effective_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveAt returns the old "effective_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldEffectiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveAt: %w", err)
	}
	return oldValue.EffectiveAt, nil
}

// ResetEffectiveAt resets all changes to the "effective_at" field.
func (m *GrantMutation) ResetEffectiveAt() {
	m.effective_at = nil
}

// SetExpiration sets the "expiration" field.
func (m *GrantMutation) SetExpiration(gp grant.ExpirationPeriod) {
	m.expiration = &gp
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *GrantMutation) Expiration() (r grant.ExpirationPeriod, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldExpiration(ctx context.Context) (v grant.ExpirationPeriod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *GrantMutation) ResetExpiration() {
	m.expiration = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *GrantMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *GrantMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *GrantMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetVoidedAt sets the "voided_at" field.
func (m *GrantMutation) SetVoidedAt(t time.Time) {
	m.voided_at = &t
}

// VoidedAt returns the value of the "voided_at" field in the mutation.
func (m *GrantMutation) VoidedAt() (r time.Time, exists bool) {
	v := m.voided_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidedAt returns the old "voided_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldVoidedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidedAt: %w", err)
	}
	return oldValue.VoidedAt, nil
}

// ClearVoidedAt clears the value of the "voided_at" field.
func (m *GrantMutation) ClearVoidedAt() {
	m.voided_at = nil
	m.clearedFields[dbgrant.FieldVoidedAt] = struct{}{}
}

// VoidedAtCleared returns if the "voided_at" field was cleared in this mutation.
func (m *GrantMutation) VoidedAtCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldVoidedAt]
	return ok
}

// ResetVoidedAt resets all changes to the "voided_at" field.
func (m *GrantMutation) ResetVoidedAt() {
	m.voided_at = nil
	delete(m.clearedFields, dbgrant.FieldVoidedAt)
}

// SetResetMaxRollover sets the "reset_max_rollover" field.
func (m *GrantMutation) SetResetMaxRollover(f float64) {
	m.reset_max_rollover = &f
	m.addreset_max_rollover = nil
}

// ResetMaxRollover returns the value of the "reset_max_rollover" field in the mutation.
func (m *GrantMutation) ResetMaxRollover() (r float64, exists bool) {
	v := m.reset_max_rollover
	if v == nil {
		return
	}
	return *v, true
}

// OldResetMaxRollover returns the old "reset_max_rollover" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldResetMaxRollover(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetMaxRollover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetMaxRollover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetMaxRollover: %w", err)
	}
	return oldValue.ResetMaxRollover, nil
}

// AddResetMaxRollover adds f to the "reset_max_rollover" field.
func (m *GrantMutation) AddResetMaxRollover(f float64) {
	if m.addreset_max_rollover != nil {
		*m.addreset_max_rollover += f
	} else {
		m.addreset_max_rollover = &f
	}
}

// AddedResetMaxRollover returns the value that was added to the "reset_max_rollover" field in this mutation.
func (m *GrantMutation) AddedResetMaxRollover() (r float64, exists bool) {
	v := m.addreset_max_rollover
	if v == nil {
		return
	}
	return *v, true
}

// ResetResetMaxRollover resets all changes to the "reset_max_rollover" field.
func (m *GrantMutation) ResetResetMaxRollover() {
	m.reset_max_rollover = nil
	m.addreset_max_rollover = nil
}

// SetResetMinRollover sets the "reset_min_rollover" field.
func (m *GrantMutation) SetResetMinRollover(f float64) {
	m.reset_min_rollover = &f
	m.addreset_min_rollover = nil
}

// ResetMinRollover returns the value of the "reset_min_rollover" field in the mutation.
func (m *GrantMutation) ResetMinRollover() (r float64, exists bool) {
	v := m.reset_min_rollover
	if v == nil {
		return
	}
	return *v, true
}

// OldResetMinRollover returns the old "reset_min_rollover" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldResetMinRollover(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetMinRollover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetMinRollover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetMinRollover: %w", err)
	}
	return oldValue.ResetMinRollover, nil
}

// AddResetMinRollover adds f to the "reset_min_rollover" field.
func (m *GrantMutation) AddResetMinRollover(f float64) {
	if m.addreset_min_rollover != nil {
		*m.addreset_min_rollover += f
	} else {
		m.addreset_min_rollover = &f
	}
}

// AddedResetMinRollover returns the value that was added to the "reset_min_rollover" field in this mutation.
func (m *GrantMutation) AddedResetMinRollover() (r float64, exists bool) {
	v := m.addreset_min_rollover
	if v == nil {
		return
	}
	return *v, true
}

// ResetResetMinRollover resets all changes to the "reset_min_rollover" field.
func (m *GrantMutation) ResetResetMinRollover() {
	m.reset_min_rollover = nil
	m.addreset_min_rollover = nil
}

// SetRecurrencePeriod sets the "recurrence_period" field.
func (m *GrantMutation) SetRecurrencePeriod(ri recurrence.RecurrenceInterval) {
	m.recurrence_period = &ri
}

// RecurrencePeriod returns the value of the "recurrence_period" field in the mutation.
func (m *GrantMutation) RecurrencePeriod() (r recurrence.RecurrenceInterval, exists bool) {
	v := m.recurrence_period
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrencePeriod returns the old "recurrence_period" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRecurrencePeriod(ctx context.Context) (v *recurrence.RecurrenceInterval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrencePeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrencePeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrencePeriod: %w", err)
	}
	return oldValue.RecurrencePeriod, nil
}

// ClearRecurrencePeriod clears the value of the "recurrence_period" field.
func (m *GrantMutation) ClearRecurrencePeriod() {
	m.recurrence_period = nil
	m.clearedFields[dbgrant.FieldRecurrencePeriod] = struct{}{}
}

// RecurrencePeriodCleared returns if the "recurrence_period" field was cleared in this mutation.
func (m *GrantMutation) RecurrencePeriodCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldRecurrencePeriod]
	return ok
}

// ResetRecurrencePeriod resets all changes to the "recurrence_period" field.
func (m *GrantMutation) ResetRecurrencePeriod() {
	m.recurrence_period = nil
	delete(m.clearedFields, dbgrant.FieldRecurrencePeriod)
}

// SetRecurrenceAnchor sets the "recurrence_anchor" field.
func (m *GrantMutation) SetRecurrenceAnchor(t time.Time) {
	m.recurrence_anchor = &t
}

// RecurrenceAnchor returns the value of the "recurrence_anchor" field in the mutation.
func (m *GrantMutation) RecurrenceAnchor() (r time.Time, exists bool) {
	v := m.recurrence_anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrenceAnchor returns the old "recurrence_anchor" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRecurrenceAnchor(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrenceAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrenceAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrenceAnchor: %w", err)
	}
	return oldValue.RecurrenceAnchor, nil
}

// ClearRecurrenceAnchor clears the value of the "recurrence_anchor" field.
func (m *GrantMutation) ClearRecurrenceAnchor() {
	m.recurrence_anchor = nil
	m.clearedFields[dbgrant.FieldRecurrenceAnchor] = struct{}{}
}

// RecurrenceAnchorCleared returns if the "recurrence_anchor" field was cleared in this mutation.
func (m *GrantMutation) RecurrenceAnchorCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldRecurrenceAnchor]
	return ok
}

// ResetRecurrenceAnchor resets all changes to the "recurrence_anchor" field.
func (m *GrantMutation) ResetRecurrenceAnchor() {
	m.recurrence_anchor = nil
	delete(m.clearedFields, dbgrant.FieldRecurrenceAnchor)
}

// SetEntitlementID sets the "entitlement" edge to the Entitlement entity by id.
func (m *GrantMutation) SetEntitlementID(id string) {
	m.entitlement = &id
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *GrantMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[dbgrant.FieldOwnerID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *GrantMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementID returns the "entitlement" edge ID in the mutation.
func (m *GrantMutation) EntitlementID() (id string, exists bool) {
	if m.entitlement != nil {
		return *m.entitlement, true
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *GrantMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *GrantMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the GrantMutation builder.
func (m *GrantMutation) Where(ps ...predicate.Grant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GrantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GrantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Grant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GrantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GrantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Grant).
func (m *GrantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GrantMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.namespace != nil {
		fields = append(fields, dbgrant.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, dbgrant.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, dbgrant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dbgrant.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dbgrant.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, dbgrant.FieldOwnerID)
	}
	if m.amount != nil {
		fields = append(fields, dbgrant.FieldAmount)
	}
	if m.priority != nil {
		fields = append(fields, dbgrant.FieldPriority)
	}
	if m.effective_at != nil {
		fields = append(fields, dbgrant.FieldEffectiveAt)
	}
	if m.expiration != nil {
		fields = append(fields, dbgrant.FieldExpiration)
	}
	if m.expires_at != nil {
		fields = append(fields, dbgrant.FieldExpiresAt)
	}
	if m.voided_at != nil {
		fields = append(fields, dbgrant.FieldVoidedAt)
	}
	if m.reset_max_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMaxRollover)
	}
	if m.reset_min_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMinRollover)
	}
	if m.recurrence_period != nil {
		fields = append(fields, dbgrant.FieldRecurrencePeriod)
	}
	if m.recurrence_anchor != nil {
		fields = append(fields, dbgrant.FieldRecurrenceAnchor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GrantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbgrant.FieldNamespace:
		return m.Namespace()
	case dbgrant.FieldMetadata:
		return m.Metadata()
	case dbgrant.FieldCreatedAt:
		return m.CreatedAt()
	case dbgrant.FieldUpdatedAt:
		return m.UpdatedAt()
	case dbgrant.FieldDeletedAt:
		return m.DeletedAt()
	case dbgrant.FieldOwnerID:
		return m.OwnerID()
	case dbgrant.FieldAmount:
		return m.Amount()
	case dbgrant.FieldPriority:
		return m.Priority()
	case dbgrant.FieldEffectiveAt:
		return m.EffectiveAt()
	case dbgrant.FieldExpiration:
		return m.Expiration()
	case dbgrant.FieldExpiresAt:
		return m.ExpiresAt()
	case dbgrant.FieldVoidedAt:
		return m.VoidedAt()
	case dbgrant.FieldResetMaxRollover:
		return m.ResetMaxRollover()
	case dbgrant.FieldResetMinRollover:
		return m.ResetMinRollover()
	case dbgrant.FieldRecurrencePeriod:
		return m.RecurrencePeriod()
	case dbgrant.FieldRecurrenceAnchor:
		return m.RecurrenceAnchor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GrantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbgrant.FieldNamespace:
		return m.OldNamespace(ctx)
	case dbgrant.FieldMetadata:
		return m.OldMetadata(ctx)
	case dbgrant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dbgrant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dbgrant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dbgrant.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case dbgrant.FieldAmount:
		return m.OldAmount(ctx)
	case dbgrant.FieldPriority:
		return m.OldPriority(ctx)
	case dbgrant.FieldEffectiveAt:
		return m.OldEffectiveAt(ctx)
	case dbgrant.FieldExpiration:
		return m.OldExpiration(ctx)
	case dbgrant.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case dbgrant.FieldVoidedAt:
		return m.OldVoidedAt(ctx)
	case dbgrant.FieldResetMaxRollover:
		return m.OldResetMaxRollover(ctx)
	case dbgrant.FieldResetMinRollover:
		return m.OldResetMinRollover(ctx)
	case dbgrant.FieldRecurrencePeriod:
		return m.OldRecurrencePeriod(ctx)
	case dbgrant.FieldRecurrenceAnchor:
		return m.OldRecurrenceAnchor(ctx)
	}
	return nil, fmt.Errorf("unknown Grant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbgrant.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case dbgrant.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case dbgrant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dbgrant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dbgrant.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dbgrant.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case dbgrant.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case dbgrant.FieldPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case dbgrant.FieldEffectiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveAt(v)
		return nil
	case dbgrant.FieldExpiration:
		v, ok := value.(grant.ExpirationPeriod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case dbgrant.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case dbgrant.FieldVoidedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidedAt(v)
		return nil
	case dbgrant.FieldResetMaxRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetMaxRollover(v)
		return nil
	case dbgrant.FieldResetMinRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetMinRollover(v)
		return nil
	case dbgrant.FieldRecurrencePeriod:
		v, ok := value.(recurrence.RecurrenceInterval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrencePeriod(v)
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrenceAnchor(v)
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GrantMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, dbgrant.FieldAmount)
	}
	if m.addpriority != nil {
		fields = append(fields, dbgrant.FieldPriority)
	}
	if m.addreset_max_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMaxRollover)
	}
	if m.addreset_min_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMinRollover)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GrantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dbgrant.FieldAmount:
		return m.AddedAmount()
	case dbgrant.FieldPriority:
		return m.AddedPriority()
	case dbgrant.FieldResetMaxRollover:
		return m.AddedResetMaxRollover()
	case dbgrant.FieldResetMinRollover:
		return m.AddedResetMinRollover()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dbgrant.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case dbgrant.FieldPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case dbgrant.FieldResetMaxRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResetMaxRollover(v)
		return nil
	case dbgrant.FieldResetMinRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResetMinRollover(v)
		return nil
	}
	return fmt.Errorf("unknown Grant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GrantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbgrant.FieldMetadata) {
		fields = append(fields, dbgrant.FieldMetadata)
	}
	if m.FieldCleared(dbgrant.FieldDeletedAt) {
		fields = append(fields, dbgrant.FieldDeletedAt)
	}
	if m.FieldCleared(dbgrant.FieldVoidedAt) {
		fields = append(fields, dbgrant.FieldVoidedAt)
	}
	if m.FieldCleared(dbgrant.FieldRecurrencePeriod) {
		fields = append(fields, dbgrant.FieldRecurrencePeriod)
	}
	if m.FieldCleared(dbgrant.FieldRecurrenceAnchor) {
		fields = append(fields, dbgrant.FieldRecurrenceAnchor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GrantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrantMutation) ClearField(name string) error {
	switch name {
	case dbgrant.FieldMetadata:
		m.ClearMetadata()
		return nil
	case dbgrant.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dbgrant.FieldVoidedAt:
		m.ClearVoidedAt()
		return nil
	case dbgrant.FieldRecurrencePeriod:
		m.ClearRecurrencePeriod()
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		m.ClearRecurrenceAnchor()
		return nil
	}
	return fmt.Errorf("unknown Grant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GrantMutation) ResetField(name string) error {
	switch name {
	case dbgrant.FieldNamespace:
		m.ResetNamespace()
		return nil
	case dbgrant.FieldMetadata:
		m.ResetMetadata()
		return nil
	case dbgrant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dbgrant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dbgrant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dbgrant.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case dbgrant.FieldAmount:
		m.ResetAmount()
		return nil
	case dbgrant.FieldPriority:
		m.ResetPriority()
		return nil
	case dbgrant.FieldEffectiveAt:
		m.ResetEffectiveAt()
		return nil
	case dbgrant.FieldExpiration:
		m.ResetExpiration()
		return nil
	case dbgrant.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case dbgrant.FieldVoidedAt:
		m.ResetVoidedAt()
		return nil
	case dbgrant.FieldResetMaxRollover:
		m.ResetResetMaxRollover()
		return nil
	case dbgrant.FieldResetMinRollover:
		m.ResetResetMinRollover()
		return nil
	case dbgrant.FieldRecurrencePeriod:
		m.ResetRecurrencePeriod()
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		m.ResetRecurrenceAnchor()
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GrantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, dbgrant.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GrantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbgrant.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GrantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GrantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GrantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, dbgrant.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GrantMutation) EdgeCleared(name string) bool {
	switch name {
	case dbgrant.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GrantMutation) ClearEdge(name string) error {
	switch name {
	case dbgrant.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown Grant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GrantMutation) ResetEdge(name string) error {
	switch name {
	case dbgrant.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown Grant edge %s", name)
}

// NotificationChannelMutation represents an operation that mutates the NotificationChannel nodes in the graph.
type NotificationChannelMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	_type         *notification.ChannelType
	name          *string
	disabled      *bool
	_config       *notification.ChannelConfig
	clearedFields map[string]struct{}
	rules         map[string]struct{}
	removedrules  map[string]struct{}
	clearedrules  bool
	done          bool
	oldValue      func(context.Context) (*NotificationChannel, error)
	predicates    []predicate.NotificationChannel
}

var _ ent.Mutation = (*NotificationChannelMutation)(nil)

// notificationchannelOption allows management of the mutation configuration using functional options.
type notificationchannelOption func(*NotificationChannelMutation)

// newNotificationChannelMutation creates new mutation for the NotificationChannel entity.
func newNotificationChannelMutation(c config, op Op, opts ...notificationchannelOption) *NotificationChannelMutation {
	m := &NotificationChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationChannelID sets the ID field of the mutation.
func withNotificationChannelID(id string) notificationchannelOption {
	return func(m *NotificationChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationChannel
		)
		m.oldValue = func(ctx context.Context) (*NotificationChannel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationChannel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationChannel sets the old NotificationChannel of the mutation.
func withNotificationChannel(node *NotificationChannel) notificationchannelOption {
	return func(m *NotificationChannelMutation) {
		m.oldValue = func(context.Context) (*NotificationChannel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationChannel entities.
func (m *NotificationChannelMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationChannelMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationChannelMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationChannel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationChannelMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationChannelMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationChannelMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationChannelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationChannelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationChannelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationchannel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationChannelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationchannel.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *NotificationChannelMutation) SetType(nt notification.ChannelType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationChannelMutation) GetType() (r notification.ChannelType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldType(ctx context.Context) (v notification.ChannelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationChannelMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *NotificationChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationChannelMutation) ResetName() {
	m.name = nil
}

// SetDisabled sets the "disabled" field.
func (m *NotificationChannelMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *NotificationChannelMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *NotificationChannelMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[notificationchannel.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *NotificationChannelMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *NotificationChannelMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, notificationchannel.FieldDisabled)
}

// SetConfig sets the "config" field.
func (m *NotificationChannelMutation) SetConfig(nc notification.ChannelConfig) {
	m._config = &nc
}

// Config returns the value of the "config" field in the mutation.
func (m *NotificationChannelMutation) Config() (r notification.ChannelConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldConfig(ctx context.Context) (v notification.ChannelConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NotificationChannelMutation) ResetConfig() {
	m._config = nil
}

// AddRuleIDs adds the "rules" edge to the NotificationRule entity by ids.
func (m *NotificationChannelMutation) AddRuleIDs(ids ...string) {
	if m.rules == nil {
		m.rules = make(map[string]struct{})
	}
	for i := range ids {
		m.rules[ids[i]] = struct{}{}
	}
}

// ClearRules clears the "rules" edge to the NotificationRule entity.
func (m *NotificationChannelMutation) ClearRules() {
	m.clearedrules = true
}

// RulesCleared reports if the "rules" edge to the NotificationRule entity was cleared.
func (m *NotificationChannelMutation) RulesCleared() bool {
	return m.clearedrules
}

// RemoveRuleIDs removes the "rules" edge to the NotificationRule entity by IDs.
func (m *NotificationChannelMutation) RemoveRuleIDs(ids ...string) {
	if m.removedrules == nil {
		m.removedrules = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rules, ids[i])
		m.removedrules[ids[i]] = struct{}{}
	}
}

// RemovedRules returns the removed IDs of the "rules" edge to the NotificationRule entity.
func (m *NotificationChannelMutation) RemovedRulesIDs() (ids []string) {
	for id := range m.removedrules {
		ids = append(ids, id)
	}
	return
}

// RulesIDs returns the "rules" edge IDs in the mutation.
func (m *NotificationChannelMutation) RulesIDs() (ids []string) {
	for id := range m.rules {
		ids = append(ids, id)
	}
	return
}

// ResetRules resets all changes to the "rules" edge.
func (m *NotificationChannelMutation) ResetRules() {
	m.rules = nil
	m.clearedrules = false
	m.removedrules = nil
}

// Where appends a list predicates to the NotificationChannelMutation builder.
func (m *NotificationChannelMutation) Where(ps ...predicate.NotificationChannel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationChannel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationChannel).
func (m *NotificationChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationChannelMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, notificationchannel.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationchannel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationchannel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notificationchannel.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationchannel.FieldType)
	}
	if m.name != nil {
		fields = append(fields, notificationchannel.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, notificationchannel.FieldDisabled)
	}
	if m._config != nil {
		fields = append(fields, notificationchannel.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationchannel.FieldNamespace:
		return m.Namespace()
	case notificationchannel.FieldCreatedAt:
		return m.CreatedAt()
	case notificationchannel.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationchannel.FieldDeletedAt:
		return m.DeletedAt()
	case notificationchannel.FieldType:
		return m.GetType()
	case notificationchannel.FieldName:
		return m.Name()
	case notificationchannel.FieldDisabled:
		return m.Disabled()
	case notificationchannel.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationchannel.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationchannel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationchannel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationchannel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notificationchannel.FieldType:
		return m.OldType(ctx)
	case notificationchannel.FieldName:
		return m.OldName(ctx)
	case notificationchannel.FieldDisabled:
		return m.OldDisabled(ctx)
	case notificationchannel.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationChannel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationchannel.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationchannel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationchannel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationchannel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notificationchannel.FieldType:
		v, ok := value.(notification.ChannelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationchannel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationchannel.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case notificationchannel.FieldConfig:
		v, ok := value.(notification.ChannelConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationChannelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationChannelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationChannel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationchannel.FieldDeletedAt) {
		fields = append(fields, notificationchannel.FieldDeletedAt)
	}
	if m.FieldCleared(notificationchannel.FieldDisabled) {
		fields = append(fields, notificationchannel.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationChannelMutation) ClearField(name string) error {
	switch name {
	case notificationchannel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notificationchannel.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationChannelMutation) ResetField(name string) error {
	switch name {
	case notificationchannel.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationchannel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationchannel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationchannel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notificationchannel.FieldType:
		m.ResetType()
		return nil
	case notificationchannel.FieldName:
		m.ResetName()
		return nil
	case notificationchannel.FieldDisabled:
		m.ResetDisabled()
		return nil
	case notificationchannel.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rules != nil {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationchannel.EdgeRules:
		ids := make([]ent.Value, 0, len(m.rules))
		for id := range m.rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrules != nil {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationchannel.EdgeRules:
		ids := make([]ent.Value, 0, len(m.removedrules))
		for id := range m.removedrules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrules {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationchannel.EdgeRules:
		return m.clearedrules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationChannel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationChannelMutation) ResetEdge(name string) error {
	switch name {
	case notificationchannel.EdgeRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel edge %s", name)
}

// NotificationEventMutation represents an operation that mutates the NotificationEvent nodes in the graph.
type NotificationEventMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	namespace                *string
	created_at               *time.Time
	_type                    *notification.EventType
	payload                  *string
	annotations              *map[string]interface{}
	clearedFields            map[string]struct{}
	delivery_statuses        map[string]struct{}
	removeddelivery_statuses map[string]struct{}
	cleareddelivery_statuses bool
	rules                    *string
	clearedrules             bool
	done                     bool
	oldValue                 func(context.Context) (*NotificationEvent, error)
	predicates               []predicate.NotificationEvent
}

var _ ent.Mutation = (*NotificationEventMutation)(nil)

// notificationeventOption allows management of the mutation configuration using functional options.
type notificationeventOption func(*NotificationEventMutation)

// newNotificationEventMutation creates new mutation for the NotificationEvent entity.
func newNotificationEventMutation(c config, op Op, opts ...notificationeventOption) *NotificationEventMutation {
	m := &NotificationEventMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationEventID sets the ID field of the mutation.
func withNotificationEventID(id string) notificationeventOption {
	return func(m *NotificationEventMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationEvent
		)
		m.oldValue = func(ctx context.Context) (*NotificationEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationEvent sets the old NotificationEvent of the mutation.
func withNotificationEvent(node *NotificationEvent) notificationeventOption {
	return func(m *NotificationEventMutation) {
		m.oldValue = func(context.Context) (*NotificationEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationEvent entities.
func (m *NotificationEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationEventMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationEventMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationEventMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetType sets the "type" field.
func (m *NotificationEventMutation) SetType(nt notification.EventType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationEventMutation) GetType() (r notification.EventType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldType(ctx context.Context) (v notification.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationEventMutation) ResetType() {
	m._type = nil
}

// SetRuleID sets the "rule_id" field.
func (m *NotificationEventMutation) SetRuleID(s string) {
	m.rules = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *NotificationEventMutation) RuleID() (r string, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *NotificationEventMutation) ResetRuleID() {
	m.rules = nil
}

// SetPayload sets the "payload" field.
func (m *NotificationEventMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *NotificationEventMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *NotificationEventMutation) ResetPayload() {
	m.payload = nil
}

// SetAnnotations sets the "annotations" field.
func (m *NotificationEventMutation) SetAnnotations(value map[string]interface{}) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *NotificationEventMutation) Annotations() (r map[string]interface{}, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldAnnotations(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *NotificationEventMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[notificationevent.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *NotificationEventMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[notificationevent.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *NotificationEventMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, notificationevent.FieldAnnotations)
}

// AddDeliveryStatusIDs adds the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity by ids.
func (m *NotificationEventMutation) AddDeliveryStatusIDs(ids ...string) {
	if m.delivery_statuses == nil {
		m.delivery_statuses = make(map[string]struct{})
	}
	for i := range ids {
		m.delivery_statuses[ids[i]] = struct{}{}
	}
}

// ClearDeliveryStatuses clears the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity.
func (m *NotificationEventMutation) ClearDeliveryStatuses() {
	m.cleareddelivery_statuses = true
}

// DeliveryStatusesCleared reports if the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity was cleared.
func (m *NotificationEventMutation) DeliveryStatusesCleared() bool {
	return m.cleareddelivery_statuses
}

// RemoveDeliveryStatusIDs removes the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity by IDs.
func (m *NotificationEventMutation) RemoveDeliveryStatusIDs(ids ...string) {
	if m.removeddelivery_statuses == nil {
		m.removeddelivery_statuses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.delivery_statuses, ids[i])
		m.removeddelivery_statuses[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryStatuses returns the removed IDs of the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity.
func (m *NotificationEventMutation) RemovedDeliveryStatusesIDs() (ids []string) {
	for id := range m.removeddelivery_statuses {
		ids = append(ids, id)
	}
	return
}

// DeliveryStatusesIDs returns the "delivery_statuses" edge IDs in the mutation.
func (m *NotificationEventMutation) DeliveryStatusesIDs() (ids []string) {
	for id := range m.delivery_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryStatuses resets all changes to the "delivery_statuses" edge.
func (m *NotificationEventMutation) ResetDeliveryStatuses() {
	m.delivery_statuses = nil
	m.cleareddelivery_statuses = false
	m.removeddelivery_statuses = nil
}

// SetRulesID sets the "rules" edge to the NotificationRule entity by id.
func (m *NotificationEventMutation) SetRulesID(id string) {
	m.rules = &id
}

// ClearRules clears the "rules" edge to the NotificationRule entity.
func (m *NotificationEventMutation) ClearRules() {
	m.clearedrules = true
	m.clearedFields[notificationevent.FieldRuleID] = struct{}{}
}

// RulesCleared reports if the "rules" edge to the NotificationRule entity was cleared.
func (m *NotificationEventMutation) RulesCleared() bool {
	return m.clearedrules
}

// RulesID returns the "rules" edge ID in the mutation.
func (m *NotificationEventMutation) RulesID() (id string, exists bool) {
	if m.rules != nil {
		return *m.rules, true
	}
	return
}

// RulesIDs returns the "rules" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RulesID instead. It exists only for internal usage by the builders.
func (m *NotificationEventMutation) RulesIDs() (ids []string) {
	if id := m.rules; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRules resets all changes to the "rules" edge.
func (m *NotificationEventMutation) ResetRules() {
	m.rules = nil
	m.clearedrules = false
}

// Where appends a list predicates to the NotificationEventMutation builder.
func (m *NotificationEventMutation) Where(ps ...predicate.NotificationEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationEvent).
func (m *NotificationEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationEventMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.namespace != nil {
		fields = append(fields, notificationevent.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationevent.FieldCreatedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationevent.FieldType)
	}
	if m.rules != nil {
		fields = append(fields, notificationevent.FieldRuleID)
	}
	if m.payload != nil {
		fields = append(fields, notificationevent.FieldPayload)
	}
	if m.annotations != nil {
		fields = append(fields, notificationevent.FieldAnnotations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationevent.FieldNamespace:
		return m.Namespace()
	case notificationevent.FieldCreatedAt:
		return m.CreatedAt()
	case notificationevent.FieldType:
		return m.GetType()
	case notificationevent.FieldRuleID:
		return m.RuleID()
	case notificationevent.FieldPayload:
		return m.Payload()
	case notificationevent.FieldAnnotations:
		return m.Annotations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationevent.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationevent.FieldType:
		return m.OldType(ctx)
	case notificationevent.FieldRuleID:
		return m.OldRuleID(ctx)
	case notificationevent.FieldPayload:
		return m.OldPayload(ctx)
	case notificationevent.FieldAnnotations:
		return m.OldAnnotations(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationevent.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationevent.FieldType:
		v, ok := value.(notification.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationevent.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case notificationevent.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case notificationevent.FieldAnnotations:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationevent.FieldAnnotations) {
		fields = append(fields, notificationevent.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationEventMutation) ClearField(name string) error {
	switch name {
	case notificationevent.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationEventMutation) ResetField(name string) error {
	switch name {
	case notificationevent.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationevent.FieldType:
		m.ResetType()
		return nil
	case notificationevent.FieldRuleID:
		m.ResetRuleID()
		return nil
	case notificationevent.FieldPayload:
		m.ResetPayload()
		return nil
	case notificationevent.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.delivery_statuses != nil {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	if m.rules != nil {
		edges = append(edges, notificationevent.EdgeRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		ids := make([]ent.Value, 0, len(m.delivery_statuses))
		for id := range m.delivery_statuses {
			ids = append(ids, id)
		}
		return ids
	case notificationevent.EdgeRules:
		if id := m.rules; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddelivery_statuses != nil {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		ids := make([]ent.Value, 0, len(m.removeddelivery_statuses))
		for id := range m.removeddelivery_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddelivery_statuses {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	if m.clearedrules {
		edges = append(edges, notificationevent.EdgeRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationEventMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		return m.cleareddelivery_statuses
	case notificationevent.EdgeRules:
		return m.clearedrules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationEventMutation) ClearEdge(name string) error {
	switch name {
	case notificationevent.EdgeRules:
		m.ClearRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationEventMutation) ResetEdge(name string) error {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		m.ResetDeliveryStatuses()
		return nil
	case notificationevent.EdgeRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent edge %s", name)
}

// NotificationEventDeliveryStatusMutation represents an operation that mutates the NotificationEventDeliveryStatus nodes in the graph.
type NotificationEventDeliveryStatusMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	created_at    *time.Time
	updated_at    *time.Time
	event_id      *string
	channel_id    *string
	state         *notification.EventDeliveryStatusState
	reason        *string
	clearedFields map[string]struct{}
	events        map[string]struct{}
	removedevents map[string]struct{}
	clearedevents bool
	done          bool
	oldValue      func(context.Context) (*NotificationEventDeliveryStatus, error)
	predicates    []predicate.NotificationEventDeliveryStatus
}

var _ ent.Mutation = (*NotificationEventDeliveryStatusMutation)(nil)

// notificationeventdeliverystatusOption allows management of the mutation configuration using functional options.
type notificationeventdeliverystatusOption func(*NotificationEventDeliveryStatusMutation)

// newNotificationEventDeliveryStatusMutation creates new mutation for the NotificationEventDeliveryStatus entity.
func newNotificationEventDeliveryStatusMutation(c config, op Op, opts ...notificationeventdeliverystatusOption) *NotificationEventDeliveryStatusMutation {
	m := &NotificationEventDeliveryStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationEventDeliveryStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationEventDeliveryStatusID sets the ID field of the mutation.
func withNotificationEventDeliveryStatusID(id string) notificationeventdeliverystatusOption {
	return func(m *NotificationEventDeliveryStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationEventDeliveryStatus
		)
		m.oldValue = func(ctx context.Context) (*NotificationEventDeliveryStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationEventDeliveryStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationEventDeliveryStatus sets the old NotificationEventDeliveryStatus of the mutation.
func withNotificationEventDeliveryStatus(node *NotificationEventDeliveryStatus) notificationeventdeliverystatusOption {
	return func(m *NotificationEventDeliveryStatusMutation) {
		m.oldValue = func(context.Context) (*NotificationEventDeliveryStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationEventDeliveryStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationEventDeliveryStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationEventDeliveryStatus entities.
func (m *NotificationEventDeliveryStatusMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationEventDeliveryStatusMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationEventDeliveryStatusMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationEventDeliveryStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationEventDeliveryStatusMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationEventDeliveryStatusMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationEventDeliveryStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationEventDeliveryStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationEventDeliveryStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationEventDeliveryStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventID sets the "event_id" field.
func (m *NotificationEventDeliveryStatusMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *NotificationEventDeliveryStatusMutation) ResetEventID() {
	m.event_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *NotificationEventDeliveryStatusMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *NotificationEventDeliveryStatusMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetState sets the "state" field.
func (m *NotificationEventDeliveryStatusMutation) SetState(ndss notification.EventDeliveryStatusState) {
	m.state = &ndss
}

// State returns the value of the "state" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) State() (r notification.EventDeliveryStatusState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldState(ctx context.Context) (v notification.EventDeliveryStatusState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *NotificationEventDeliveryStatusMutation) ResetState() {
	m.state = nil
}

// SetReason sets the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[notificationeventdeliverystatus.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[notificationeventdeliverystatus.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, notificationeventdeliverystatus.FieldReason)
}

// AddEventIDs adds the "events" edge to the NotificationEvent entity by ids.
func (m *NotificationEventDeliveryStatusMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the NotificationEvent entity.
func (m *NotificationEventDeliveryStatusMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the NotificationEvent entity was cleared.
func (m *NotificationEventDeliveryStatusMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the NotificationEvent entity by IDs.
func (m *NotificationEventDeliveryStatusMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the NotificationEvent entity.
func (m *NotificationEventDeliveryStatusMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *NotificationEventDeliveryStatusMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *NotificationEventDeliveryStatusMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the NotificationEventDeliveryStatusMutation builder.
func (m *NotificationEventDeliveryStatusMutation) Where(ps ...predicate.NotificationEventDeliveryStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationEventDeliveryStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationEventDeliveryStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationEventDeliveryStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationEventDeliveryStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationEventDeliveryStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationEventDeliveryStatus).
func (m *NotificationEventDeliveryStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationEventDeliveryStatusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.namespace != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldUpdatedAt)
	}
	if m.event_id != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldEventID)
	}
	if m.channel_id != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldChannelID)
	}
	if m.state != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldState)
	}
	if m.reason != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationEventDeliveryStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		return m.Namespace()
	case notificationeventdeliverystatus.FieldCreatedAt:
		return m.CreatedAt()
	case notificationeventdeliverystatus.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationeventdeliverystatus.FieldEventID:
		return m.EventID()
	case notificationeventdeliverystatus.FieldChannelID:
		return m.ChannelID()
	case notificationeventdeliverystatus.FieldState:
		return m.State()
	case notificationeventdeliverystatus.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationEventDeliveryStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationeventdeliverystatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationeventdeliverystatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationeventdeliverystatus.FieldEventID:
		return m.OldEventID(ctx)
	case notificationeventdeliverystatus.FieldChannelID:
		return m.OldChannelID(ctx)
	case notificationeventdeliverystatus.FieldState:
		return m.OldState(ctx)
	case notificationeventdeliverystatus.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventDeliveryStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationeventdeliverystatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationeventdeliverystatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationeventdeliverystatus.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case notificationeventdeliverystatus.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case notificationeventdeliverystatus.FieldState:
		v, ok := value.(notification.EventDeliveryStatusState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case notificationeventdeliverystatus.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventDeliveryStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationEventDeliveryStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationeventdeliverystatus.FieldReason) {
		fields = append(fields, notificationeventdeliverystatus.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ClearField(name string) error {
	switch name {
	case notificationeventdeliverystatus.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ResetField(name string) error {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationeventdeliverystatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationeventdeliverystatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationeventdeliverystatus.FieldEventID:
		m.ResetEventID()
		return nil
	case notificationeventdeliverystatus.FieldChannelID:
		m.ResetChannelID()
		return nil
	case notificationeventdeliverystatus.FieldState:
		m.ResetState()
		return nil
	case notificationeventdeliverystatus.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationEventDeliveryStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationEventDeliveryStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ResetEdge(name string) error {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus edge %s", name)
}

// NotificationRuleMutation represents an operation that mutates the NotificationRule nodes in the graph.
type NotificationRuleMutation struct {
	config
	op              Op
	typ             string
	id              *string
	namespace       *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	_type           *notification.RuleType
	name            *string
	disabled        *bool
	_config         *notification.RuleConfig
	clearedFields   map[string]struct{}
	channels        map[string]struct{}
	removedchannels map[string]struct{}
	clearedchannels bool
	events          map[string]struct{}
	removedevents   map[string]struct{}
	clearedevents   bool
	done            bool
	oldValue        func(context.Context) (*NotificationRule, error)
	predicates      []predicate.NotificationRule
}

var _ ent.Mutation = (*NotificationRuleMutation)(nil)

// notificationruleOption allows management of the mutation configuration using functional options.
type notificationruleOption func(*NotificationRuleMutation)

// newNotificationRuleMutation creates new mutation for the NotificationRule entity.
func newNotificationRuleMutation(c config, op Op, opts ...notificationruleOption) *NotificationRuleMutation {
	m := &NotificationRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationRuleID sets the ID field of the mutation.
func withNotificationRuleID(id string) notificationruleOption {
	return func(m *NotificationRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationRule
		)
		m.oldValue = func(ctx context.Context) (*NotificationRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationRule sets the old NotificationRule of the mutation.
func withNotificationRule(node *NotificationRule) notificationruleOption {
	return func(m *NotificationRuleMutation) {
		m.oldValue = func(context.Context) (*NotificationRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationRule entities.
func (m *NotificationRuleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationRuleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationRuleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationRuleMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationRuleMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationRuleMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationRuleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationRuleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationRuleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationrule.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationRuleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationrule.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationRuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationrule.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *NotificationRuleMutation) SetType(nt notification.RuleType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationRuleMutation) GetType() (r notification.RuleType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldType(ctx context.Context) (v notification.RuleType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationRuleMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *NotificationRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationRuleMutation) ResetName() {
	m.name = nil
}

// SetDisabled sets the "disabled" field.
func (m *NotificationRuleMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *NotificationRuleMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *NotificationRuleMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[notificationrule.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *NotificationRuleMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[notificationrule.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *NotificationRuleMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, notificationrule.FieldDisabled)
}

// SetConfig sets the "config" field.
func (m *NotificationRuleMutation) SetConfig(nc notification.RuleConfig) {
	m._config = &nc
}

// Config returns the value of the "config" field in the mutation.
func (m *NotificationRuleMutation) Config() (r notification.RuleConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldConfig(ctx context.Context) (v notification.RuleConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NotificationRuleMutation) ResetConfig() {
	m._config = nil
}

// AddChannelIDs adds the "channels" edge to the NotificationChannel entity by ids.
func (m *NotificationRuleMutation) AddChannelIDs(ids ...string) {
	if m.channels == nil {
		m.channels = make(map[string]struct{})
	}
	for i := range ids {
		m.channels[ids[i]] = struct{}{}
	}
}

// ClearChannels clears the "channels" edge to the NotificationChannel entity.
func (m *NotificationRuleMutation) ClearChannels() {
	m.clearedchannels = true
}

// ChannelsCleared reports if the "channels" edge to the NotificationChannel entity was cleared.
func (m *NotificationRuleMutation) ChannelsCleared() bool {
	return m.clearedchannels
}

// RemoveChannelIDs removes the "channels" edge to the NotificationChannel entity by IDs.
func (m *NotificationRuleMutation) RemoveChannelIDs(ids ...string) {
	if m.removedchannels == nil {
		m.removedchannels = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.channels, ids[i])
		m.removedchannels[ids[i]] = struct{}{}
	}
}

// RemovedChannels returns the removed IDs of the "channels" edge to the NotificationChannel entity.
func (m *NotificationRuleMutation) RemovedChannelsIDs() (ids []string) {
	for id := range m.removedchannels {
		ids = append(ids, id)
	}
	return
}

// ChannelsIDs returns the "channels" edge IDs in the mutation.
func (m *NotificationRuleMutation) ChannelsIDs() (ids []string) {
	for id := range m.channels {
		ids = append(ids, id)
	}
	return
}

// ResetChannels resets all changes to the "channels" edge.
func (m *NotificationRuleMutation) ResetChannels() {
	m.channels = nil
	m.clearedchannels = false
	m.removedchannels = nil
}

// AddEventIDs adds the "events" edge to the NotificationEvent entity by ids.
func (m *NotificationRuleMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the NotificationEvent entity.
func (m *NotificationRuleMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the NotificationEvent entity was cleared.
func (m *NotificationRuleMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the NotificationEvent entity by IDs.
func (m *NotificationRuleMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the NotificationEvent entity.
func (m *NotificationRuleMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *NotificationRuleMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *NotificationRuleMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the NotificationRuleMutation builder.
func (m *NotificationRuleMutation) Where(ps ...predicate.NotificationRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationRule).
func (m *NotificationRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationRuleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, notificationrule.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationrule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notificationrule.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationrule.FieldType)
	}
	if m.name != nil {
		fields = append(fields, notificationrule.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, notificationrule.FieldDisabled)
	}
	if m._config != nil {
		fields = append(fields, notificationrule.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationrule.FieldNamespace:
		return m.Namespace()
	case notificationrule.FieldCreatedAt:
		return m.CreatedAt()
	case notificationrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationrule.FieldDeletedAt:
		return m.DeletedAt()
	case notificationrule.FieldType:
		return m.GetType()
	case notificationrule.FieldName:
		return m.Name()
	case notificationrule.FieldDisabled:
		return m.Disabled()
	case notificationrule.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationrule.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationrule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notificationrule.FieldType:
		return m.OldType(ctx)
	case notificationrule.FieldName:
		return m.OldName(ctx)
	case notificationrule.FieldDisabled:
		return m.OldDisabled(ctx)
	case notificationrule.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationrule.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationrule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notificationrule.FieldType:
		v, ok := value.(notification.RuleType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationrule.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case notificationrule.FieldConfig:
		v, ok := value.(notification.RuleConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationRuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationRuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationrule.FieldDeletedAt) {
		fields = append(fields, notificationrule.FieldDeletedAt)
	}
	if m.FieldCleared(notificationrule.FieldDisabled) {
		fields = append(fields, notificationrule.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationRuleMutation) ClearField(name string) error {
	switch name {
	case notificationrule.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notificationrule.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationRuleMutation) ResetField(name string) error {
	switch name {
	case notificationrule.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationrule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notificationrule.FieldType:
		m.ResetType()
		return nil
	case notificationrule.FieldName:
		m.ResetName()
		return nil
	case notificationrule.FieldDisabled:
		m.ResetDisabled()
		return nil
	case notificationrule.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.channels != nil {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.events != nil {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationrule.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.channels))
		for id := range m.channels {
			ids = append(ids, id)
		}
		return ids
	case notificationrule.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchannels != nil {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.removedevents != nil {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationrule.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.removedchannels))
		for id := range m.removedchannels {
			ids = append(ids, id)
		}
		return ids
	case notificationrule.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchannels {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.clearedevents {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationrule.EdgeChannels:
		return m.clearedchannels
	case notificationrule.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationRuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationRuleMutation) ResetEdge(name string) error {
	switch name {
	case notificationrule.EdgeChannels:
		m.ResetChannels()
		return nil
	case notificationrule.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule edge %s", name)
}

// UsageResetMutation represents an operation that mutates the UsageReset nodes in the graph.
type UsageResetMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	namespace          *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	reset_time         *time.Time
	clearedFields      map[string]struct{}
	entitlement        *string
	clearedentitlement bool
	done               bool
	oldValue           func(context.Context) (*UsageReset, error)
	predicates         []predicate.UsageReset
}

var _ ent.Mutation = (*UsageResetMutation)(nil)

// usageresetOption allows management of the mutation configuration using functional options.
type usageresetOption func(*UsageResetMutation)

// newUsageResetMutation creates new mutation for the UsageReset entity.
func newUsageResetMutation(c config, op Op, opts ...usageresetOption) *UsageResetMutation {
	m := &UsageResetMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageReset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageResetID sets the ID field of the mutation.
func withUsageResetID(id string) usageresetOption {
	return func(m *UsageResetMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageReset
		)
		m.oldValue = func(ctx context.Context) (*UsageReset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageReset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageReset sets the old UsageReset of the mutation.
func withUsageReset(node *UsageReset) usageresetOption {
	return func(m *UsageResetMutation) {
		m.oldValue = func(context.Context) (*UsageReset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageResetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageResetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UsageReset entities.
func (m *UsageResetMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageResetMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageResetMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageReset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *UsageResetMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *UsageResetMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *UsageResetMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageResetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageResetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageResetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageResetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageResetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageResetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UsageResetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UsageResetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UsageResetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usagereset.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UsageResetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usagereset.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UsageResetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usagereset.FieldDeletedAt)
}

// SetEntitlementID sets the "entitlement_id" field.
func (m *UsageResetMutation) SetEntitlementID(s string) {
	m.entitlement = &s
}

// EntitlementID returns the value of the "entitlement_id" field in the mutation.
func (m *UsageResetMutation) EntitlementID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementID returns the old "entitlement_id" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldEntitlementID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementID: %w", err)
	}
	return oldValue.EntitlementID, nil
}

// ResetEntitlementID resets all changes to the "entitlement_id" field.
func (m *UsageResetMutation) ResetEntitlementID() {
	m.entitlement = nil
}

// SetResetTime sets the "reset_time" field.
func (m *UsageResetMutation) SetResetTime(t time.Time) {
	m.reset_time = &t
}

// ResetTime returns the value of the "reset_time" field in the mutation.
func (m *UsageResetMutation) ResetTime() (r time.Time, exists bool) {
	v := m.reset_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResetTime returns the old "reset_time" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldResetTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetTime: %w", err)
	}
	return oldValue.ResetTime, nil
}

// ResetResetTime resets all changes to the "reset_time" field.
func (m *UsageResetMutation) ResetResetTime() {
	m.reset_time = nil
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *UsageResetMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[usagereset.FieldEntitlementID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *UsageResetMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *UsageResetMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *UsageResetMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the UsageResetMutation builder.
func (m *UsageResetMutation) Where(ps ...predicate.UsageReset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageResetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageResetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageReset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageResetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageResetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageReset).
func (m *UsageResetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageResetMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.namespace != nil {
		fields = append(fields, usagereset.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, usagereset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usagereset.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usagereset.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, usagereset.FieldEntitlementID)
	}
	if m.reset_time != nil {
		fields = append(fields, usagereset.FieldResetTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageResetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagereset.FieldNamespace:
		return m.Namespace()
	case usagereset.FieldCreatedAt:
		return m.CreatedAt()
	case usagereset.FieldUpdatedAt:
		return m.UpdatedAt()
	case usagereset.FieldDeletedAt:
		return m.DeletedAt()
	case usagereset.FieldEntitlementID:
		return m.EntitlementID()
	case usagereset.FieldResetTime:
		return m.ResetTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageResetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagereset.FieldNamespace:
		return m.OldNamespace(ctx)
	case usagereset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagereset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usagereset.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usagereset.FieldEntitlementID:
		return m.OldEntitlementID(ctx)
	case usagereset.FieldResetTime:
		return m.OldResetTime(ctx)
	}
	return nil, fmt.Errorf("unknown UsageReset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageResetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagereset.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case usagereset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagereset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usagereset.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usagereset.FieldEntitlementID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementID(v)
		return nil
	case usagereset.FieldResetTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetTime(v)
		return nil
	}
	return fmt.Errorf("unknown UsageReset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageResetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageResetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageResetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UsageReset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageResetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagereset.FieldDeletedAt) {
		fields = append(fields, usagereset.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageResetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageResetMutation) ClearField(name string) error {
	switch name {
	case usagereset.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageReset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageResetMutation) ResetField(name string) error {
	switch name {
	case usagereset.FieldNamespace:
		m.ResetNamespace()
		return nil
	case usagereset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagereset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usagereset.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usagereset.FieldEntitlementID:
		m.ResetEntitlementID()
		return nil
	case usagereset.FieldResetTime:
		m.ResetResetTime()
		return nil
	}
	return fmt.Errorf("unknown UsageReset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageResetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, usagereset.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageResetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagereset.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageResetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageResetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageResetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, usagereset.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageResetMutation) EdgeCleared(name string) bool {
	switch name {
	case usagereset.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageResetMutation) ClearEdge(name string) error {
	switch name {
	case usagereset.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown UsageReset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageResetMutation) ResetEdge(name string) error {
	switch name {
	case usagereset.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown UsageReset edge %s", name)
}
