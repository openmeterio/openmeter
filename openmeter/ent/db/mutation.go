// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/alpacahq/alpacadecimal"
	"github.com/openmeterio/openmeter/openmeter/app"
	"github.com/openmeterio/openmeter/openmeter/billing"
	"github.com/openmeterio/openmeter/openmeter/credit/balance"
	"github.com/openmeterio/openmeter/openmeter/credit/grant"
	"github.com/openmeterio/openmeter/openmeter/ent/db/addon"
	"github.com/openmeterio/openmeter/openmeter/ent/db/addonratecard"
	dbapp "github.com/openmeterio/openmeter/openmeter/ent/db/app"
	"github.com/openmeterio/openmeter/openmeter/ent/db/appcustomer"
	"github.com/openmeterio/openmeter/openmeter/ent/db/appcustominvoicing"
	"github.com/openmeterio/openmeter/openmeter/ent/db/appcustominvoicingcustomer"
	"github.com/openmeterio/openmeter/openmeter/ent/db/appstripe"
	"github.com/openmeterio/openmeter/openmeter/ent/db/appstripecustomer"
	"github.com/openmeterio/openmeter/openmeter/ent/db/balancesnapshot"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingcustomerlock"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingcustomeroverride"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoice"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoiceflatfeelineconfig"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoiceline"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoicelinediscount"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoicelineusagediscount"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoiceusagebasedlineconfig"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billinginvoicevalidationissue"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingprofile"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingsequencenumbers"
	"github.com/openmeterio/openmeter/openmeter/ent/db/billingworkflowconfig"
	"github.com/openmeterio/openmeter/openmeter/ent/db/customer"
	"github.com/openmeterio/openmeter/openmeter/ent/db/customersubjects"
	"github.com/openmeterio/openmeter/openmeter/ent/db/entitlement"
	"github.com/openmeterio/openmeter/openmeter/ent/db/feature"
	dbgrant "github.com/openmeterio/openmeter/openmeter/ent/db/grant"
	dbmeter "github.com/openmeterio/openmeter/openmeter/ent/db/meter"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationchannel"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationevent"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationeventdeliverystatus"
	"github.com/openmeterio/openmeter/openmeter/ent/db/notificationrule"
	"github.com/openmeterio/openmeter/openmeter/ent/db/plan"
	"github.com/openmeterio/openmeter/openmeter/ent/db/planaddon"
	"github.com/openmeterio/openmeter/openmeter/ent/db/planphase"
	"github.com/openmeterio/openmeter/openmeter/ent/db/planratecard"
	"github.com/openmeterio/openmeter/openmeter/ent/db/predicate"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscription"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscriptionaddon"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscriptionaddonquantity"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscriptionitem"
	"github.com/openmeterio/openmeter/openmeter/ent/db/subscriptionphase"
	"github.com/openmeterio/openmeter/openmeter/ent/db/usagereset"
	"github.com/openmeterio/openmeter/openmeter/meter"
	"github.com/openmeterio/openmeter/openmeter/notification"
	"github.com/openmeterio/openmeter/openmeter/productcatalog"
	"github.com/openmeterio/openmeter/pkg/currencyx"
	"github.com/openmeterio/openmeter/pkg/isodate"
	"github.com/openmeterio/openmeter/pkg/models"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddon                              = "Addon"
	TypeAddonRateCard                      = "AddonRateCard"
	TypeApp                                = "App"
	TypeAppCustomInvoicing                 = "AppCustomInvoicing"
	TypeAppCustomInvoicingCustomer         = "AppCustomInvoicingCustomer"
	TypeAppCustomer                        = "AppCustomer"
	TypeAppStripe                          = "AppStripe"
	TypeAppStripeCustomer                  = "AppStripeCustomer"
	TypeBalanceSnapshot                    = "BalanceSnapshot"
	TypeBillingCustomerLock                = "BillingCustomerLock"
	TypeBillingCustomerOverride            = "BillingCustomerOverride"
	TypeBillingInvoice                     = "BillingInvoice"
	TypeBillingInvoiceFlatFeeLineConfig    = "BillingInvoiceFlatFeeLineConfig"
	TypeBillingInvoiceLine                 = "BillingInvoiceLine"
	TypeBillingInvoiceLineDiscount         = "BillingInvoiceLineDiscount"
	TypeBillingInvoiceLineUsageDiscount    = "BillingInvoiceLineUsageDiscount"
	TypeBillingInvoiceUsageBasedLineConfig = "BillingInvoiceUsageBasedLineConfig"
	TypeBillingInvoiceValidationIssue      = "BillingInvoiceValidationIssue"
	TypeBillingProfile                     = "BillingProfile"
	TypeBillingSequenceNumbers             = "BillingSequenceNumbers"
	TypeBillingWorkflowConfig              = "BillingWorkflowConfig"
	TypeCustomer                           = "Customer"
	TypeCustomerSubjects                   = "CustomerSubjects"
	TypeEntitlement                        = "Entitlement"
	TypeFeature                            = "Feature"
	TypeGrant                              = "Grant"
	TypeMeter                              = "Meter"
	TypeNotificationChannel                = "NotificationChannel"
	TypeNotificationEvent                  = "NotificationEvent"
	TypeNotificationEventDeliveryStatus    = "NotificationEventDeliveryStatus"
	TypeNotificationRule                   = "NotificationRule"
	TypePlan                               = "Plan"
	TypePlanAddon                          = "PlanAddon"
	TypePlanPhase                          = "PlanPhase"
	TypePlanRateCard                       = "PlanRateCard"
	TypeSubscription                       = "Subscription"
	TypeSubscriptionAddon                  = "SubscriptionAddon"
	TypeSubscriptionAddonQuantity          = "SubscriptionAddonQuantity"
	TypeSubscriptionItem                   = "SubscriptionItem"
	TypeSubscriptionPhase                  = "SubscriptionPhase"
	TypeUsageReset                         = "UsageReset"
)

// AddonMutation represents an operation that mutates the Addon nodes in the graph.
type AddonMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	namespace                  *string
	metadata                   *map[string]string
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	name                       *string
	description                *string
	key                        *string
	version                    *int
	addversion                 *int
	currency                   *string
	instance_type              *productcatalog.AddonInstanceType
	effective_from             *time.Time
	effective_to               *time.Time
	annotations                *map[string]interface{}
	clearedFields              map[string]struct{}
	ratecards                  map[string]struct{}
	removedratecards           map[string]struct{}
	clearedratecards           bool
	plans                      map[string]struct{}
	removedplans               map[string]struct{}
	clearedplans               bool
	subscription_addons        map[string]struct{}
	removedsubscription_addons map[string]struct{}
	clearedsubscription_addons bool
	done                       bool
	oldValue                   func(context.Context) (*Addon, error)
	predicates                 []predicate.Addon
}

var _ ent.Mutation = (*AddonMutation)(nil)

// addonOption allows management of the mutation configuration using functional options.
type addonOption func(*AddonMutation)

// newAddonMutation creates new mutation for the Addon entity.
func newAddonMutation(c config, op Op, opts ...addonOption) *AddonMutation {
	m := &AddonMutation{
		config:        c,
		op:            op,
		typ:           TypeAddon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddonID sets the ID field of the mutation.
func withAddonID(id string) addonOption {
	return func(m *AddonMutation) {
		var (
			err   error
			once  sync.Once
			value *Addon
		)
		m.oldValue = func(ctx context.Context) (*Addon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Addon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddon sets the old Addon of the mutation.
func withAddon(node *Addon) addonOption {
	return func(m *AddonMutation) {
		m.oldValue = func(context.Context) (*Addon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Addon entities.
func (m *AddonMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddonMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddonMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Addon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AddonMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AddonMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AddonMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *AddonMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AddonMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AddonMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[addon.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AddonMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[addon.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AddonMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, addon.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *AddonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AddonMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AddonMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AddonMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[addon.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AddonMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[addon.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AddonMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, addon.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AddonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AddonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AddonMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AddonMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AddonMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AddonMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[addon.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AddonMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[addon.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AddonMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, addon.FieldDescription)
}

// SetKey sets the "key" field.
func (m *AddonMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *AddonMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *AddonMutation) ResetKey() {
	m.key = nil
}

// SetVersion sets the "version" field.
func (m *AddonMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *AddonMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *AddonMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *AddonMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *AddonMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCurrency sets the "currency" field.
func (m *AddonMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *AddonMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *AddonMutation) ResetCurrency() {
	m.currency = nil
}

// SetInstanceType sets the "instance_type" field.
func (m *AddonMutation) SetInstanceType(pit productcatalog.AddonInstanceType) {
	m.instance_type = &pit
}

// InstanceType returns the value of the "instance_type" field in the mutation.
func (m *AddonMutation) InstanceType() (r productcatalog.AddonInstanceType, exists bool) {
	v := m.instance_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceType returns the old "instance_type" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldInstanceType(ctx context.Context) (v productcatalog.AddonInstanceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceType: %w", err)
	}
	return oldValue.InstanceType, nil
}

// ResetInstanceType resets all changes to the "instance_type" field.
func (m *AddonMutation) ResetInstanceType() {
	m.instance_type = nil
}

// SetEffectiveFrom sets the "effective_from" field.
func (m *AddonMutation) SetEffectiveFrom(t time.Time) {
	m.effective_from = &t
}

// EffectiveFrom returns the value of the "effective_from" field in the mutation.
func (m *AddonMutation) EffectiveFrom() (r time.Time, exists bool) {
	v := m.effective_from
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveFrom returns the old "effective_from" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldEffectiveFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveFrom: %w", err)
	}
	return oldValue.EffectiveFrom, nil
}

// ClearEffectiveFrom clears the value of the "effective_from" field.
func (m *AddonMutation) ClearEffectiveFrom() {
	m.effective_from = nil
	m.clearedFields[addon.FieldEffectiveFrom] = struct{}{}
}

// EffectiveFromCleared returns if the "effective_from" field was cleared in this mutation.
func (m *AddonMutation) EffectiveFromCleared() bool {
	_, ok := m.clearedFields[addon.FieldEffectiveFrom]
	return ok
}

// ResetEffectiveFrom resets all changes to the "effective_from" field.
func (m *AddonMutation) ResetEffectiveFrom() {
	m.effective_from = nil
	delete(m.clearedFields, addon.FieldEffectiveFrom)
}

// SetEffectiveTo sets the "effective_to" field.
func (m *AddonMutation) SetEffectiveTo(t time.Time) {
	m.effective_to = &t
}

// EffectiveTo returns the value of the "effective_to" field in the mutation.
func (m *AddonMutation) EffectiveTo() (r time.Time, exists bool) {
	v := m.effective_to
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveTo returns the old "effective_to" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldEffectiveTo(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveTo: %w", err)
	}
	return oldValue.EffectiveTo, nil
}

// ClearEffectiveTo clears the value of the "effective_to" field.
func (m *AddonMutation) ClearEffectiveTo() {
	m.effective_to = nil
	m.clearedFields[addon.FieldEffectiveTo] = struct{}{}
}

// EffectiveToCleared returns if the "effective_to" field was cleared in this mutation.
func (m *AddonMutation) EffectiveToCleared() bool {
	_, ok := m.clearedFields[addon.FieldEffectiveTo]
	return ok
}

// ResetEffectiveTo resets all changes to the "effective_to" field.
func (m *AddonMutation) ResetEffectiveTo() {
	m.effective_to = nil
	delete(m.clearedFields, addon.FieldEffectiveTo)
}

// SetAnnotations sets the "annotations" field.
func (m *AddonMutation) SetAnnotations(value map[string]interface{}) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *AddonMutation) Annotations() (r map[string]interface{}, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Addon entity.
// If the Addon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonMutation) OldAnnotations(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *AddonMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[addon.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *AddonMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[addon.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *AddonMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, addon.FieldAnnotations)
}

// AddRatecardIDs adds the "ratecards" edge to the AddonRateCard entity by ids.
func (m *AddonMutation) AddRatecardIDs(ids ...string) {
	if m.ratecards == nil {
		m.ratecards = make(map[string]struct{})
	}
	for i := range ids {
		m.ratecards[ids[i]] = struct{}{}
	}
}

// ClearRatecards clears the "ratecards" edge to the AddonRateCard entity.
func (m *AddonMutation) ClearRatecards() {
	m.clearedratecards = true
}

// RatecardsCleared reports if the "ratecards" edge to the AddonRateCard entity was cleared.
func (m *AddonMutation) RatecardsCleared() bool {
	return m.clearedratecards
}

// RemoveRatecardIDs removes the "ratecards" edge to the AddonRateCard entity by IDs.
func (m *AddonMutation) RemoveRatecardIDs(ids ...string) {
	if m.removedratecards == nil {
		m.removedratecards = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ratecards, ids[i])
		m.removedratecards[ids[i]] = struct{}{}
	}
}

// RemovedRatecards returns the removed IDs of the "ratecards" edge to the AddonRateCard entity.
func (m *AddonMutation) RemovedRatecardsIDs() (ids []string) {
	for id := range m.removedratecards {
		ids = append(ids, id)
	}
	return
}

// RatecardsIDs returns the "ratecards" edge IDs in the mutation.
func (m *AddonMutation) RatecardsIDs() (ids []string) {
	for id := range m.ratecards {
		ids = append(ids, id)
	}
	return
}

// ResetRatecards resets all changes to the "ratecards" edge.
func (m *AddonMutation) ResetRatecards() {
	m.ratecards = nil
	m.clearedratecards = false
	m.removedratecards = nil
}

// AddPlanIDs adds the "plans" edge to the PlanAddon entity by ids.
func (m *AddonMutation) AddPlanIDs(ids ...string) {
	if m.plans == nil {
		m.plans = make(map[string]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the PlanAddon entity.
func (m *AddonMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the PlanAddon entity was cleared.
func (m *AddonMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the PlanAddon entity by IDs.
func (m *AddonMutation) RemovePlanIDs(ids ...string) {
	if m.removedplans == nil {
		m.removedplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the PlanAddon entity.
func (m *AddonMutation) RemovedPlansIDs() (ids []string) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *AddonMutation) PlansIDs() (ids []string) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *AddonMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// AddSubscriptionAddonIDs adds the "subscription_addons" edge to the SubscriptionAddon entity by ids.
func (m *AddonMutation) AddSubscriptionAddonIDs(ids ...string) {
	if m.subscription_addons == nil {
		m.subscription_addons = make(map[string]struct{})
	}
	for i := range ids {
		m.subscription_addons[ids[i]] = struct{}{}
	}
}

// ClearSubscriptionAddons clears the "subscription_addons" edge to the SubscriptionAddon entity.
func (m *AddonMutation) ClearSubscriptionAddons() {
	m.clearedsubscription_addons = true
}

// SubscriptionAddonsCleared reports if the "subscription_addons" edge to the SubscriptionAddon entity was cleared.
func (m *AddonMutation) SubscriptionAddonsCleared() bool {
	return m.clearedsubscription_addons
}

// RemoveSubscriptionAddonIDs removes the "subscription_addons" edge to the SubscriptionAddon entity by IDs.
func (m *AddonMutation) RemoveSubscriptionAddonIDs(ids ...string) {
	if m.removedsubscription_addons == nil {
		m.removedsubscription_addons = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscription_addons, ids[i])
		m.removedsubscription_addons[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptionAddons returns the removed IDs of the "subscription_addons" edge to the SubscriptionAddon entity.
func (m *AddonMutation) RemovedSubscriptionAddonsIDs() (ids []string) {
	for id := range m.removedsubscription_addons {
		ids = append(ids, id)
	}
	return
}

// SubscriptionAddonsIDs returns the "subscription_addons" edge IDs in the mutation.
func (m *AddonMutation) SubscriptionAddonsIDs() (ids []string) {
	for id := range m.subscription_addons {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptionAddons resets all changes to the "subscription_addons" edge.
func (m *AddonMutation) ResetSubscriptionAddons() {
	m.subscription_addons = nil
	m.clearedsubscription_addons = false
	m.removedsubscription_addons = nil
}

// Where appends a list predicates to the AddonMutation builder.
func (m *AddonMutation) Where(ps ...predicate.Addon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Addon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Addon).
func (m *AddonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddonMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.namespace != nil {
		fields = append(fields, addon.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, addon.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, addon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, addon.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, addon.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, addon.FieldName)
	}
	if m.description != nil {
		fields = append(fields, addon.FieldDescription)
	}
	if m.key != nil {
		fields = append(fields, addon.FieldKey)
	}
	if m.version != nil {
		fields = append(fields, addon.FieldVersion)
	}
	if m.currency != nil {
		fields = append(fields, addon.FieldCurrency)
	}
	if m.instance_type != nil {
		fields = append(fields, addon.FieldInstanceType)
	}
	if m.effective_from != nil {
		fields = append(fields, addon.FieldEffectiveFrom)
	}
	if m.effective_to != nil {
		fields = append(fields, addon.FieldEffectiveTo)
	}
	if m.annotations != nil {
		fields = append(fields, addon.FieldAnnotations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case addon.FieldNamespace:
		return m.Namespace()
	case addon.FieldMetadata:
		return m.Metadata()
	case addon.FieldCreatedAt:
		return m.CreatedAt()
	case addon.FieldUpdatedAt:
		return m.UpdatedAt()
	case addon.FieldDeletedAt:
		return m.DeletedAt()
	case addon.FieldName:
		return m.Name()
	case addon.FieldDescription:
		return m.Description()
	case addon.FieldKey:
		return m.Key()
	case addon.FieldVersion:
		return m.Version()
	case addon.FieldCurrency:
		return m.Currency()
	case addon.FieldInstanceType:
		return m.InstanceType()
	case addon.FieldEffectiveFrom:
		return m.EffectiveFrom()
	case addon.FieldEffectiveTo:
		return m.EffectiveTo()
	case addon.FieldAnnotations:
		return m.Annotations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case addon.FieldNamespace:
		return m.OldNamespace(ctx)
	case addon.FieldMetadata:
		return m.OldMetadata(ctx)
	case addon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case addon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case addon.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case addon.FieldName:
		return m.OldName(ctx)
	case addon.FieldDescription:
		return m.OldDescription(ctx)
	case addon.FieldKey:
		return m.OldKey(ctx)
	case addon.FieldVersion:
		return m.OldVersion(ctx)
	case addon.FieldCurrency:
		return m.OldCurrency(ctx)
	case addon.FieldInstanceType:
		return m.OldInstanceType(ctx)
	case addon.FieldEffectiveFrom:
		return m.OldEffectiveFrom(ctx)
	case addon.FieldEffectiveTo:
		return m.OldEffectiveTo(ctx)
	case addon.FieldAnnotations:
		return m.OldAnnotations(ctx)
	}
	return nil, fmt.Errorf("unknown Addon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case addon.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case addon.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case addon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case addon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case addon.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case addon.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case addon.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case addon.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case addon.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case addon.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case addon.FieldInstanceType:
		v, ok := value.(productcatalog.AddonInstanceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceType(v)
		return nil
	case addon.FieldEffectiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveFrom(v)
		return nil
	case addon.FieldEffectiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveTo(v)
		return nil
	case addon.FieldAnnotations:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	}
	return fmt.Errorf("unknown Addon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddonMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, addon.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case addon.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case addon.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Addon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(addon.FieldMetadata) {
		fields = append(fields, addon.FieldMetadata)
	}
	if m.FieldCleared(addon.FieldDeletedAt) {
		fields = append(fields, addon.FieldDeletedAt)
	}
	if m.FieldCleared(addon.FieldDescription) {
		fields = append(fields, addon.FieldDescription)
	}
	if m.FieldCleared(addon.FieldEffectiveFrom) {
		fields = append(fields, addon.FieldEffectiveFrom)
	}
	if m.FieldCleared(addon.FieldEffectiveTo) {
		fields = append(fields, addon.FieldEffectiveTo)
	}
	if m.FieldCleared(addon.FieldAnnotations) {
		fields = append(fields, addon.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddonMutation) ClearField(name string) error {
	switch name {
	case addon.FieldMetadata:
		m.ClearMetadata()
		return nil
	case addon.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case addon.FieldDescription:
		m.ClearDescription()
		return nil
	case addon.FieldEffectiveFrom:
		m.ClearEffectiveFrom()
		return nil
	case addon.FieldEffectiveTo:
		m.ClearEffectiveTo()
		return nil
	case addon.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Addon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddonMutation) ResetField(name string) error {
	switch name {
	case addon.FieldNamespace:
		m.ResetNamespace()
		return nil
	case addon.FieldMetadata:
		m.ResetMetadata()
		return nil
	case addon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case addon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case addon.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case addon.FieldName:
		m.ResetName()
		return nil
	case addon.FieldDescription:
		m.ResetDescription()
		return nil
	case addon.FieldKey:
		m.ResetKey()
		return nil
	case addon.FieldVersion:
		m.ResetVersion()
		return nil
	case addon.FieldCurrency:
		m.ResetCurrency()
		return nil
	case addon.FieldInstanceType:
		m.ResetInstanceType()
		return nil
	case addon.FieldEffectiveFrom:
		m.ResetEffectiveFrom()
		return nil
	case addon.FieldEffectiveTo:
		m.ResetEffectiveTo()
		return nil
	case addon.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Addon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddonMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.ratecards != nil {
		edges = append(edges, addon.EdgeRatecards)
	}
	if m.plans != nil {
		edges = append(edges, addon.EdgePlans)
	}
	if m.subscription_addons != nil {
		edges = append(edges, addon.EdgeSubscriptionAddons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case addon.EdgeRatecards:
		ids := make([]ent.Value, 0, len(m.ratecards))
		for id := range m.ratecards {
			ids = append(ids, id)
		}
		return ids
	case addon.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	case addon.EdgeSubscriptionAddons:
		ids := make([]ent.Value, 0, len(m.subscription_addons))
		for id := range m.subscription_addons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedratecards != nil {
		edges = append(edges, addon.EdgeRatecards)
	}
	if m.removedplans != nil {
		edges = append(edges, addon.EdgePlans)
	}
	if m.removedsubscription_addons != nil {
		edges = append(edges, addon.EdgeSubscriptionAddons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case addon.EdgeRatecards:
		ids := make([]ent.Value, 0, len(m.removedratecards))
		for id := range m.removedratecards {
			ids = append(ids, id)
		}
		return ids
	case addon.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	case addon.EdgeSubscriptionAddons:
		ids := make([]ent.Value, 0, len(m.removedsubscription_addons))
		for id := range m.removedsubscription_addons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedratecards {
		edges = append(edges, addon.EdgeRatecards)
	}
	if m.clearedplans {
		edges = append(edges, addon.EdgePlans)
	}
	if m.clearedsubscription_addons {
		edges = append(edges, addon.EdgeSubscriptionAddons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddonMutation) EdgeCleared(name string) bool {
	switch name {
	case addon.EdgeRatecards:
		return m.clearedratecards
	case addon.EdgePlans:
		return m.clearedplans
	case addon.EdgeSubscriptionAddons:
		return m.clearedsubscription_addons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddonMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Addon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddonMutation) ResetEdge(name string) error {
	switch name {
	case addon.EdgeRatecards:
		m.ResetRatecards()
		return nil
	case addon.EdgePlans:
		m.ResetPlans()
		return nil
	case addon.EdgeSubscriptionAddons:
		m.ResetSubscriptionAddons()
		return nil
	}
	return fmt.Errorf("unknown Addon edge %s", name)
}

// AddonRateCardMutation represents an operation that mutates the AddonRateCard nodes in the graph.
type AddonRateCardMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	namespace            *string
	metadata             *map[string]string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	description          *string
	key                  *string
	_type                *productcatalog.RateCardType
	feature_key          *string
	entitlement_template **productcatalog.EntitlementTemplate
	tax_config           **productcatalog.TaxConfig
	billing_cadence      *isodate.String
	price                **productcatalog.Price
	discounts            **productcatalog.Discounts
	clearedFields        map[string]struct{}
	addon                *string
	clearedaddon         bool
	features             *string
	clearedfeatures      bool
	done                 bool
	oldValue             func(context.Context) (*AddonRateCard, error)
	predicates           []predicate.AddonRateCard
}

var _ ent.Mutation = (*AddonRateCardMutation)(nil)

// addonratecardOption allows management of the mutation configuration using functional options.
type addonratecardOption func(*AddonRateCardMutation)

// newAddonRateCardMutation creates new mutation for the AddonRateCard entity.
func newAddonRateCardMutation(c config, op Op, opts ...addonratecardOption) *AddonRateCardMutation {
	m := &AddonRateCardMutation{
		config:        c,
		op:            op,
		typ:           TypeAddonRateCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddonRateCardID sets the ID field of the mutation.
func withAddonRateCardID(id string) addonratecardOption {
	return func(m *AddonRateCardMutation) {
		var (
			err   error
			once  sync.Once
			value *AddonRateCard
		)
		m.oldValue = func(ctx context.Context) (*AddonRateCard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AddonRateCard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddonRateCard sets the old AddonRateCard of the mutation.
func withAddonRateCard(node *AddonRateCard) addonratecardOption {
	return func(m *AddonRateCardMutation) {
		m.oldValue = func(context.Context) (*AddonRateCard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddonRateCardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddonRateCardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AddonRateCard entities.
func (m *AddonRateCardMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddonRateCardMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddonRateCardMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AddonRateCard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AddonRateCardMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AddonRateCardMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AddonRateCardMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *AddonRateCardMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AddonRateCardMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AddonRateCardMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[addonratecard.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AddonRateCardMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[addonratecard.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AddonRateCardMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, addonratecard.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *AddonRateCardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddonRateCardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddonRateCardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddonRateCardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddonRateCardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddonRateCardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AddonRateCardMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AddonRateCardMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AddonRateCardMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[addonratecard.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AddonRateCardMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[addonratecard.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AddonRateCardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, addonratecard.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AddonRateCardMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AddonRateCardMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AddonRateCardMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AddonRateCardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AddonRateCardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AddonRateCardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[addonratecard.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AddonRateCardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[addonratecard.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AddonRateCardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, addonratecard.FieldDescription)
}

// SetKey sets the "key" field.
func (m *AddonRateCardMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *AddonRateCardMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *AddonRateCardMutation) ResetKey() {
	m.key = nil
}

// SetType sets the "type" field.
func (m *AddonRateCardMutation) SetType(pct productcatalog.RateCardType) {
	m._type = &pct
}

// GetType returns the value of the "type" field in the mutation.
func (m *AddonRateCardMutation) GetType() (r productcatalog.RateCardType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldType(ctx context.Context) (v productcatalog.RateCardType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AddonRateCardMutation) ResetType() {
	m._type = nil
}

// SetFeatureKey sets the "feature_key" field.
func (m *AddonRateCardMutation) SetFeatureKey(s string) {
	m.feature_key = &s
}

// FeatureKey returns the value of the "feature_key" field in the mutation.
func (m *AddonRateCardMutation) FeatureKey() (r string, exists bool) {
	v := m.feature_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureKey returns the old "feature_key" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldFeatureKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureKey: %w", err)
	}
	return oldValue.FeatureKey, nil
}

// ClearFeatureKey clears the value of the "feature_key" field.
func (m *AddonRateCardMutation) ClearFeatureKey() {
	m.feature_key = nil
	m.clearedFields[addonratecard.FieldFeatureKey] = struct{}{}
}

// FeatureKeyCleared returns if the "feature_key" field was cleared in this mutation.
func (m *AddonRateCardMutation) FeatureKeyCleared() bool {
	_, ok := m.clearedFields[addonratecard.FieldFeatureKey]
	return ok
}

// ResetFeatureKey resets all changes to the "feature_key" field.
func (m *AddonRateCardMutation) ResetFeatureKey() {
	m.feature_key = nil
	delete(m.clearedFields, addonratecard.FieldFeatureKey)
}

// SetEntitlementTemplate sets the "entitlement_template" field.
func (m *AddonRateCardMutation) SetEntitlementTemplate(pt *productcatalog.EntitlementTemplate) {
	m.entitlement_template = &pt
}

// EntitlementTemplate returns the value of the "entitlement_template" field in the mutation.
func (m *AddonRateCardMutation) EntitlementTemplate() (r *productcatalog.EntitlementTemplate, exists bool) {
	v := m.entitlement_template
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementTemplate returns the old "entitlement_template" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldEntitlementTemplate(ctx context.Context) (v *productcatalog.EntitlementTemplate, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementTemplate: %w", err)
	}
	return oldValue.EntitlementTemplate, nil
}

// ClearEntitlementTemplate clears the value of the "entitlement_template" field.
func (m *AddonRateCardMutation) ClearEntitlementTemplate() {
	m.entitlement_template = nil
	m.clearedFields[addonratecard.FieldEntitlementTemplate] = struct{}{}
}

// EntitlementTemplateCleared returns if the "entitlement_template" field was cleared in this mutation.
func (m *AddonRateCardMutation) EntitlementTemplateCleared() bool {
	_, ok := m.clearedFields[addonratecard.FieldEntitlementTemplate]
	return ok
}

// ResetEntitlementTemplate resets all changes to the "entitlement_template" field.
func (m *AddonRateCardMutation) ResetEntitlementTemplate() {
	m.entitlement_template = nil
	delete(m.clearedFields, addonratecard.FieldEntitlementTemplate)
}

// SetTaxConfig sets the "tax_config" field.
func (m *AddonRateCardMutation) SetTaxConfig(pc *productcatalog.TaxConfig) {
	m.tax_config = &pc
}

// TaxConfig returns the value of the "tax_config" field in the mutation.
func (m *AddonRateCardMutation) TaxConfig() (r *productcatalog.TaxConfig, exists bool) {
	v := m.tax_config
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxConfig returns the old "tax_config" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldTaxConfig(ctx context.Context) (v *productcatalog.TaxConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxConfig: %w", err)
	}
	return oldValue.TaxConfig, nil
}

// ClearTaxConfig clears the value of the "tax_config" field.
func (m *AddonRateCardMutation) ClearTaxConfig() {
	m.tax_config = nil
	m.clearedFields[addonratecard.FieldTaxConfig] = struct{}{}
}

// TaxConfigCleared returns if the "tax_config" field was cleared in this mutation.
func (m *AddonRateCardMutation) TaxConfigCleared() bool {
	_, ok := m.clearedFields[addonratecard.FieldTaxConfig]
	return ok
}

// ResetTaxConfig resets all changes to the "tax_config" field.
func (m *AddonRateCardMutation) ResetTaxConfig() {
	m.tax_config = nil
	delete(m.clearedFields, addonratecard.FieldTaxConfig)
}

// SetBillingCadence sets the "billing_cadence" field.
func (m *AddonRateCardMutation) SetBillingCadence(i isodate.String) {
	m.billing_cadence = &i
}

// BillingCadence returns the value of the "billing_cadence" field in the mutation.
func (m *AddonRateCardMutation) BillingCadence() (r isodate.String, exists bool) {
	v := m.billing_cadence
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingCadence returns the old "billing_cadence" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldBillingCadence(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingCadence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingCadence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingCadence: %w", err)
	}
	return oldValue.BillingCadence, nil
}

// ClearBillingCadence clears the value of the "billing_cadence" field.
func (m *AddonRateCardMutation) ClearBillingCadence() {
	m.billing_cadence = nil
	m.clearedFields[addonratecard.FieldBillingCadence] = struct{}{}
}

// BillingCadenceCleared returns if the "billing_cadence" field was cleared in this mutation.
func (m *AddonRateCardMutation) BillingCadenceCleared() bool {
	_, ok := m.clearedFields[addonratecard.FieldBillingCadence]
	return ok
}

// ResetBillingCadence resets all changes to the "billing_cadence" field.
func (m *AddonRateCardMutation) ResetBillingCadence() {
	m.billing_cadence = nil
	delete(m.clearedFields, addonratecard.FieldBillingCadence)
}

// SetPrice sets the "price" field.
func (m *AddonRateCardMutation) SetPrice(pr *productcatalog.Price) {
	m.price = &pr
}

// Price returns the value of the "price" field in the mutation.
func (m *AddonRateCardMutation) Price() (r *productcatalog.Price, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldPrice(ctx context.Context) (v *productcatalog.Price, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *AddonRateCardMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[addonratecard.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *AddonRateCardMutation) PriceCleared() bool {
	_, ok := m.clearedFields[addonratecard.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *AddonRateCardMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, addonratecard.FieldPrice)
}

// SetDiscounts sets the "discounts" field.
func (m *AddonRateCardMutation) SetDiscounts(pr *productcatalog.Discounts) {
	m.discounts = &pr
}

// Discounts returns the value of the "discounts" field in the mutation.
func (m *AddonRateCardMutation) Discounts() (r *productcatalog.Discounts, exists bool) {
	v := m.discounts
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscounts returns the old "discounts" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldDiscounts(ctx context.Context) (v *productcatalog.Discounts, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscounts: %w", err)
	}
	return oldValue.Discounts, nil
}

// ClearDiscounts clears the value of the "discounts" field.
func (m *AddonRateCardMutation) ClearDiscounts() {
	m.discounts = nil
	m.clearedFields[addonratecard.FieldDiscounts] = struct{}{}
}

// DiscountsCleared returns if the "discounts" field was cleared in this mutation.
func (m *AddonRateCardMutation) DiscountsCleared() bool {
	_, ok := m.clearedFields[addonratecard.FieldDiscounts]
	return ok
}

// ResetDiscounts resets all changes to the "discounts" field.
func (m *AddonRateCardMutation) ResetDiscounts() {
	m.discounts = nil
	delete(m.clearedFields, addonratecard.FieldDiscounts)
}

// SetAddonID sets the "addon_id" field.
func (m *AddonRateCardMutation) SetAddonID(s string) {
	m.addon = &s
}

// AddonID returns the value of the "addon_id" field in the mutation.
func (m *AddonRateCardMutation) AddonID() (r string, exists bool) {
	v := m.addon
	if v == nil {
		return
	}
	return *v, true
}

// OldAddonID returns the old "addon_id" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldAddonID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddonID: %w", err)
	}
	return oldValue.AddonID, nil
}

// ResetAddonID resets all changes to the "addon_id" field.
func (m *AddonRateCardMutation) ResetAddonID() {
	m.addon = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *AddonRateCardMutation) SetFeatureID(s string) {
	m.features = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *AddonRateCardMutation) FeatureID() (r string, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the AddonRateCard entity.
// If the AddonRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddonRateCardMutation) OldFeatureID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ClearFeatureID clears the value of the "feature_id" field.
func (m *AddonRateCardMutation) ClearFeatureID() {
	m.features = nil
	m.clearedFields[addonratecard.FieldFeatureID] = struct{}{}
}

// FeatureIDCleared returns if the "feature_id" field was cleared in this mutation.
func (m *AddonRateCardMutation) FeatureIDCleared() bool {
	_, ok := m.clearedFields[addonratecard.FieldFeatureID]
	return ok
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *AddonRateCardMutation) ResetFeatureID() {
	m.features = nil
	delete(m.clearedFields, addonratecard.FieldFeatureID)
}

// ClearAddon clears the "addon" edge to the Addon entity.
func (m *AddonRateCardMutation) ClearAddon() {
	m.clearedaddon = true
	m.clearedFields[addonratecard.FieldAddonID] = struct{}{}
}

// AddonCleared reports if the "addon" edge to the Addon entity was cleared.
func (m *AddonRateCardMutation) AddonCleared() bool {
	return m.clearedaddon
}

// AddonIDs returns the "addon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddonID instead. It exists only for internal usage by the builders.
func (m *AddonRateCardMutation) AddonIDs() (ids []string) {
	if id := m.addon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddon resets all changes to the "addon" edge.
func (m *AddonRateCardMutation) ResetAddon() {
	m.addon = nil
	m.clearedaddon = false
}

// SetFeaturesID sets the "features" edge to the Feature entity by id.
func (m *AddonRateCardMutation) SetFeaturesID(id string) {
	m.features = &id
}

// ClearFeatures clears the "features" edge to the Feature entity.
func (m *AddonRateCardMutation) ClearFeatures() {
	m.clearedfeatures = true
	m.clearedFields[addonratecard.FieldFeatureID] = struct{}{}
}

// FeaturesCleared reports if the "features" edge to the Feature entity was cleared.
func (m *AddonRateCardMutation) FeaturesCleared() bool {
	return m.FeatureIDCleared() || m.clearedfeatures
}

// FeaturesID returns the "features" edge ID in the mutation.
func (m *AddonRateCardMutation) FeaturesID() (id string, exists bool) {
	if m.features != nil {
		return *m.features, true
	}
	return
}

// FeaturesIDs returns the "features" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeaturesID instead. It exists only for internal usage by the builders.
func (m *AddonRateCardMutation) FeaturesIDs() (ids []string) {
	if id := m.features; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatures resets all changes to the "features" edge.
func (m *AddonRateCardMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
}

// Where appends a list predicates to the AddonRateCardMutation builder.
func (m *AddonRateCardMutation) Where(ps ...predicate.AddonRateCard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddonRateCardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddonRateCardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AddonRateCard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddonRateCardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddonRateCardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AddonRateCard).
func (m *AddonRateCardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddonRateCardMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.namespace != nil {
		fields = append(fields, addonratecard.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, addonratecard.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, addonratecard.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, addonratecard.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, addonratecard.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, addonratecard.FieldName)
	}
	if m.description != nil {
		fields = append(fields, addonratecard.FieldDescription)
	}
	if m.key != nil {
		fields = append(fields, addonratecard.FieldKey)
	}
	if m._type != nil {
		fields = append(fields, addonratecard.FieldType)
	}
	if m.feature_key != nil {
		fields = append(fields, addonratecard.FieldFeatureKey)
	}
	if m.entitlement_template != nil {
		fields = append(fields, addonratecard.FieldEntitlementTemplate)
	}
	if m.tax_config != nil {
		fields = append(fields, addonratecard.FieldTaxConfig)
	}
	if m.billing_cadence != nil {
		fields = append(fields, addonratecard.FieldBillingCadence)
	}
	if m.price != nil {
		fields = append(fields, addonratecard.FieldPrice)
	}
	if m.discounts != nil {
		fields = append(fields, addonratecard.FieldDiscounts)
	}
	if m.addon != nil {
		fields = append(fields, addonratecard.FieldAddonID)
	}
	if m.features != nil {
		fields = append(fields, addonratecard.FieldFeatureID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddonRateCardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case addonratecard.FieldNamespace:
		return m.Namespace()
	case addonratecard.FieldMetadata:
		return m.Metadata()
	case addonratecard.FieldCreatedAt:
		return m.CreatedAt()
	case addonratecard.FieldUpdatedAt:
		return m.UpdatedAt()
	case addonratecard.FieldDeletedAt:
		return m.DeletedAt()
	case addonratecard.FieldName:
		return m.Name()
	case addonratecard.FieldDescription:
		return m.Description()
	case addonratecard.FieldKey:
		return m.Key()
	case addonratecard.FieldType:
		return m.GetType()
	case addonratecard.FieldFeatureKey:
		return m.FeatureKey()
	case addonratecard.FieldEntitlementTemplate:
		return m.EntitlementTemplate()
	case addonratecard.FieldTaxConfig:
		return m.TaxConfig()
	case addonratecard.FieldBillingCadence:
		return m.BillingCadence()
	case addonratecard.FieldPrice:
		return m.Price()
	case addonratecard.FieldDiscounts:
		return m.Discounts()
	case addonratecard.FieldAddonID:
		return m.AddonID()
	case addonratecard.FieldFeatureID:
		return m.FeatureID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddonRateCardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case addonratecard.FieldNamespace:
		return m.OldNamespace(ctx)
	case addonratecard.FieldMetadata:
		return m.OldMetadata(ctx)
	case addonratecard.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case addonratecard.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case addonratecard.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case addonratecard.FieldName:
		return m.OldName(ctx)
	case addonratecard.FieldDescription:
		return m.OldDescription(ctx)
	case addonratecard.FieldKey:
		return m.OldKey(ctx)
	case addonratecard.FieldType:
		return m.OldType(ctx)
	case addonratecard.FieldFeatureKey:
		return m.OldFeatureKey(ctx)
	case addonratecard.FieldEntitlementTemplate:
		return m.OldEntitlementTemplate(ctx)
	case addonratecard.FieldTaxConfig:
		return m.OldTaxConfig(ctx)
	case addonratecard.FieldBillingCadence:
		return m.OldBillingCadence(ctx)
	case addonratecard.FieldPrice:
		return m.OldPrice(ctx)
	case addonratecard.FieldDiscounts:
		return m.OldDiscounts(ctx)
	case addonratecard.FieldAddonID:
		return m.OldAddonID(ctx)
	case addonratecard.FieldFeatureID:
		return m.OldFeatureID(ctx)
	}
	return nil, fmt.Errorf("unknown AddonRateCard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddonRateCardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case addonratecard.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case addonratecard.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case addonratecard.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case addonratecard.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case addonratecard.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case addonratecard.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case addonratecard.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case addonratecard.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case addonratecard.FieldType:
		v, ok := value.(productcatalog.RateCardType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case addonratecard.FieldFeatureKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureKey(v)
		return nil
	case addonratecard.FieldEntitlementTemplate:
		v, ok := value.(*productcatalog.EntitlementTemplate)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementTemplate(v)
		return nil
	case addonratecard.FieldTaxConfig:
		v, ok := value.(*productcatalog.TaxConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxConfig(v)
		return nil
	case addonratecard.FieldBillingCadence:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingCadence(v)
		return nil
	case addonratecard.FieldPrice:
		v, ok := value.(*productcatalog.Price)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case addonratecard.FieldDiscounts:
		v, ok := value.(*productcatalog.Discounts)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscounts(v)
		return nil
	case addonratecard.FieldAddonID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddonID(v)
		return nil
	case addonratecard.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	}
	return fmt.Errorf("unknown AddonRateCard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddonRateCardMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddonRateCardMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddonRateCardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AddonRateCard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddonRateCardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(addonratecard.FieldMetadata) {
		fields = append(fields, addonratecard.FieldMetadata)
	}
	if m.FieldCleared(addonratecard.FieldDeletedAt) {
		fields = append(fields, addonratecard.FieldDeletedAt)
	}
	if m.FieldCleared(addonratecard.FieldDescription) {
		fields = append(fields, addonratecard.FieldDescription)
	}
	if m.FieldCleared(addonratecard.FieldFeatureKey) {
		fields = append(fields, addonratecard.FieldFeatureKey)
	}
	if m.FieldCleared(addonratecard.FieldEntitlementTemplate) {
		fields = append(fields, addonratecard.FieldEntitlementTemplate)
	}
	if m.FieldCleared(addonratecard.FieldTaxConfig) {
		fields = append(fields, addonratecard.FieldTaxConfig)
	}
	if m.FieldCleared(addonratecard.FieldBillingCadence) {
		fields = append(fields, addonratecard.FieldBillingCadence)
	}
	if m.FieldCleared(addonratecard.FieldPrice) {
		fields = append(fields, addonratecard.FieldPrice)
	}
	if m.FieldCleared(addonratecard.FieldDiscounts) {
		fields = append(fields, addonratecard.FieldDiscounts)
	}
	if m.FieldCleared(addonratecard.FieldFeatureID) {
		fields = append(fields, addonratecard.FieldFeatureID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddonRateCardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddonRateCardMutation) ClearField(name string) error {
	switch name {
	case addonratecard.FieldMetadata:
		m.ClearMetadata()
		return nil
	case addonratecard.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case addonratecard.FieldDescription:
		m.ClearDescription()
		return nil
	case addonratecard.FieldFeatureKey:
		m.ClearFeatureKey()
		return nil
	case addonratecard.FieldEntitlementTemplate:
		m.ClearEntitlementTemplate()
		return nil
	case addonratecard.FieldTaxConfig:
		m.ClearTaxConfig()
		return nil
	case addonratecard.FieldBillingCadence:
		m.ClearBillingCadence()
		return nil
	case addonratecard.FieldPrice:
		m.ClearPrice()
		return nil
	case addonratecard.FieldDiscounts:
		m.ClearDiscounts()
		return nil
	case addonratecard.FieldFeatureID:
		m.ClearFeatureID()
		return nil
	}
	return fmt.Errorf("unknown AddonRateCard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddonRateCardMutation) ResetField(name string) error {
	switch name {
	case addonratecard.FieldNamespace:
		m.ResetNamespace()
		return nil
	case addonratecard.FieldMetadata:
		m.ResetMetadata()
		return nil
	case addonratecard.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case addonratecard.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case addonratecard.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case addonratecard.FieldName:
		m.ResetName()
		return nil
	case addonratecard.FieldDescription:
		m.ResetDescription()
		return nil
	case addonratecard.FieldKey:
		m.ResetKey()
		return nil
	case addonratecard.FieldType:
		m.ResetType()
		return nil
	case addonratecard.FieldFeatureKey:
		m.ResetFeatureKey()
		return nil
	case addonratecard.FieldEntitlementTemplate:
		m.ResetEntitlementTemplate()
		return nil
	case addonratecard.FieldTaxConfig:
		m.ResetTaxConfig()
		return nil
	case addonratecard.FieldBillingCadence:
		m.ResetBillingCadence()
		return nil
	case addonratecard.FieldPrice:
		m.ResetPrice()
		return nil
	case addonratecard.FieldDiscounts:
		m.ResetDiscounts()
		return nil
	case addonratecard.FieldAddonID:
		m.ResetAddonID()
		return nil
	case addonratecard.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	}
	return fmt.Errorf("unknown AddonRateCard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddonRateCardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.addon != nil {
		edges = append(edges, addonratecard.EdgeAddon)
	}
	if m.features != nil {
		edges = append(edges, addonratecard.EdgeFeatures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddonRateCardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case addonratecard.EdgeAddon:
		if id := m.addon; id != nil {
			return []ent.Value{*id}
		}
	case addonratecard.EdgeFeatures:
		if id := m.features; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddonRateCardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddonRateCardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddonRateCardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaddon {
		edges = append(edges, addonratecard.EdgeAddon)
	}
	if m.clearedfeatures {
		edges = append(edges, addonratecard.EdgeFeatures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddonRateCardMutation) EdgeCleared(name string) bool {
	switch name {
	case addonratecard.EdgeAddon:
		return m.clearedaddon
	case addonratecard.EdgeFeatures:
		return m.clearedfeatures
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddonRateCardMutation) ClearEdge(name string) error {
	switch name {
	case addonratecard.EdgeAddon:
		m.ClearAddon()
		return nil
	case addonratecard.EdgeFeatures:
		m.ClearFeatures()
		return nil
	}
	return fmt.Errorf("unknown AddonRateCard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddonRateCardMutation) ResetEdge(name string) error {
	switch name {
	case addonratecard.EdgeAddon:
		m.ResetAddon()
		return nil
	case addonratecard.EdgeFeatures:
		m.ResetFeatures()
		return nil
	}
	return fmt.Errorf("unknown AddonRateCard edge %s", name)
}

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *string
	namespace                            *string
	metadata                             *map[string]string
	created_at                           *time.Time
	updated_at                           *time.Time
	deleted_at                           *time.Time
	name                                 *string
	description                          *string
	_type                                *app.AppType
	status                               *app.AppStatus
	is_default                           *bool
	clearedFields                        map[string]struct{}
	customer_apps                        map[int]struct{}
	removedcustomer_apps                 map[int]struct{}
	clearedcustomer_apps                 bool
	billing_profile_tax_app              map[string]struct{}
	removedbilling_profile_tax_app       map[string]struct{}
	clearedbilling_profile_tax_app       bool
	billing_profile_invoicing_app        map[string]struct{}
	removedbilling_profile_invoicing_app map[string]struct{}
	clearedbilling_profile_invoicing_app bool
	billing_profile_payment_app          map[string]struct{}
	removedbilling_profile_payment_app   map[string]struct{}
	clearedbilling_profile_payment_app   bool
	billing_invoice_tax_app              map[string]struct{}
	removedbilling_invoice_tax_app       map[string]struct{}
	clearedbilling_invoice_tax_app       bool
	billing_invoice_invoicing_app        map[string]struct{}
	removedbilling_invoice_invoicing_app map[string]struct{}
	clearedbilling_invoice_invoicing_app bool
	billing_invoice_payment_app          map[string]struct{}
	removedbilling_invoice_payment_app   map[string]struct{}
	clearedbilling_invoice_payment_app   bool
	done                                 bool
	oldValue                             func(context.Context) (*App, error)
	predicates                           []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id string) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *AppMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AppMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AppMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[dbapp.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AppMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[dbapp.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AppMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, dbapp.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dbapp.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dbapp.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dbapp.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[dbapp.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dbapp.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, dbapp.FieldDescription)
}

// SetType sets the "type" field.
func (m *AppMutation) SetType(at app.AppType) {
	m._type = &at
}

// GetType returns the value of the "type" field in the mutation.
func (m *AppMutation) GetType() (r app.AppType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldType(ctx context.Context) (v app.AppType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AppMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *AppMutation) SetStatus(as app.AppStatus) {
	m.status = &as
}

// Status returns the value of the "status" field in the mutation.
func (m *AppMutation) Status() (r app.AppStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStatus(ctx context.Context) (v app.AppStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AppMutation) ResetStatus() {
	m.status = nil
}

// SetIsDefault sets the "is_default" field.
func (m *AppMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *AppMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *AppMutation) ResetIsDefault() {
	m.is_default = nil
}

// AddCustomerAppIDs adds the "customer_apps" edge to the AppCustomer entity by ids.
func (m *AppMutation) AddCustomerAppIDs(ids ...int) {
	if m.customer_apps == nil {
		m.customer_apps = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_apps[ids[i]] = struct{}{}
	}
}

// ClearCustomerApps clears the "customer_apps" edge to the AppCustomer entity.
func (m *AppMutation) ClearCustomerApps() {
	m.clearedcustomer_apps = true
}

// CustomerAppsCleared reports if the "customer_apps" edge to the AppCustomer entity was cleared.
func (m *AppMutation) CustomerAppsCleared() bool {
	return m.clearedcustomer_apps
}

// RemoveCustomerAppIDs removes the "customer_apps" edge to the AppCustomer entity by IDs.
func (m *AppMutation) RemoveCustomerAppIDs(ids ...int) {
	if m.removedcustomer_apps == nil {
		m.removedcustomer_apps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_apps, ids[i])
		m.removedcustomer_apps[ids[i]] = struct{}{}
	}
}

// RemovedCustomerApps returns the removed IDs of the "customer_apps" edge to the AppCustomer entity.
func (m *AppMutation) RemovedCustomerAppsIDs() (ids []int) {
	for id := range m.removedcustomer_apps {
		ids = append(ids, id)
	}
	return
}

// CustomerAppsIDs returns the "customer_apps" edge IDs in the mutation.
func (m *AppMutation) CustomerAppsIDs() (ids []int) {
	for id := range m.customer_apps {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerApps resets all changes to the "customer_apps" edge.
func (m *AppMutation) ResetCustomerApps() {
	m.customer_apps = nil
	m.clearedcustomer_apps = false
	m.removedcustomer_apps = nil
}

// AddBillingProfileTaxAppIDs adds the "billing_profile_tax_app" edge to the BillingProfile entity by ids.
func (m *AppMutation) AddBillingProfileTaxAppIDs(ids ...string) {
	if m.billing_profile_tax_app == nil {
		m.billing_profile_tax_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_profile_tax_app[ids[i]] = struct{}{}
	}
}

// ClearBillingProfileTaxApp clears the "billing_profile_tax_app" edge to the BillingProfile entity.
func (m *AppMutation) ClearBillingProfileTaxApp() {
	m.clearedbilling_profile_tax_app = true
}

// BillingProfileTaxAppCleared reports if the "billing_profile_tax_app" edge to the BillingProfile entity was cleared.
func (m *AppMutation) BillingProfileTaxAppCleared() bool {
	return m.clearedbilling_profile_tax_app
}

// RemoveBillingProfileTaxAppIDs removes the "billing_profile_tax_app" edge to the BillingProfile entity by IDs.
func (m *AppMutation) RemoveBillingProfileTaxAppIDs(ids ...string) {
	if m.removedbilling_profile_tax_app == nil {
		m.removedbilling_profile_tax_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_profile_tax_app, ids[i])
		m.removedbilling_profile_tax_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingProfileTaxApp returns the removed IDs of the "billing_profile_tax_app" edge to the BillingProfile entity.
func (m *AppMutation) RemovedBillingProfileTaxAppIDs() (ids []string) {
	for id := range m.removedbilling_profile_tax_app {
		ids = append(ids, id)
	}
	return
}

// BillingProfileTaxAppIDs returns the "billing_profile_tax_app" edge IDs in the mutation.
func (m *AppMutation) BillingProfileTaxAppIDs() (ids []string) {
	for id := range m.billing_profile_tax_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingProfileTaxApp resets all changes to the "billing_profile_tax_app" edge.
func (m *AppMutation) ResetBillingProfileTaxApp() {
	m.billing_profile_tax_app = nil
	m.clearedbilling_profile_tax_app = false
	m.removedbilling_profile_tax_app = nil
}

// AddBillingProfileInvoicingAppIDs adds the "billing_profile_invoicing_app" edge to the BillingProfile entity by ids.
func (m *AppMutation) AddBillingProfileInvoicingAppIDs(ids ...string) {
	if m.billing_profile_invoicing_app == nil {
		m.billing_profile_invoicing_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_profile_invoicing_app[ids[i]] = struct{}{}
	}
}

// ClearBillingProfileInvoicingApp clears the "billing_profile_invoicing_app" edge to the BillingProfile entity.
func (m *AppMutation) ClearBillingProfileInvoicingApp() {
	m.clearedbilling_profile_invoicing_app = true
}

// BillingProfileInvoicingAppCleared reports if the "billing_profile_invoicing_app" edge to the BillingProfile entity was cleared.
func (m *AppMutation) BillingProfileInvoicingAppCleared() bool {
	return m.clearedbilling_profile_invoicing_app
}

// RemoveBillingProfileInvoicingAppIDs removes the "billing_profile_invoicing_app" edge to the BillingProfile entity by IDs.
func (m *AppMutation) RemoveBillingProfileInvoicingAppIDs(ids ...string) {
	if m.removedbilling_profile_invoicing_app == nil {
		m.removedbilling_profile_invoicing_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_profile_invoicing_app, ids[i])
		m.removedbilling_profile_invoicing_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingProfileInvoicingApp returns the removed IDs of the "billing_profile_invoicing_app" edge to the BillingProfile entity.
func (m *AppMutation) RemovedBillingProfileInvoicingAppIDs() (ids []string) {
	for id := range m.removedbilling_profile_invoicing_app {
		ids = append(ids, id)
	}
	return
}

// BillingProfileInvoicingAppIDs returns the "billing_profile_invoicing_app" edge IDs in the mutation.
func (m *AppMutation) BillingProfileInvoicingAppIDs() (ids []string) {
	for id := range m.billing_profile_invoicing_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingProfileInvoicingApp resets all changes to the "billing_profile_invoicing_app" edge.
func (m *AppMutation) ResetBillingProfileInvoicingApp() {
	m.billing_profile_invoicing_app = nil
	m.clearedbilling_profile_invoicing_app = false
	m.removedbilling_profile_invoicing_app = nil
}

// AddBillingProfilePaymentAppIDs adds the "billing_profile_payment_app" edge to the BillingProfile entity by ids.
func (m *AppMutation) AddBillingProfilePaymentAppIDs(ids ...string) {
	if m.billing_profile_payment_app == nil {
		m.billing_profile_payment_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_profile_payment_app[ids[i]] = struct{}{}
	}
}

// ClearBillingProfilePaymentApp clears the "billing_profile_payment_app" edge to the BillingProfile entity.
func (m *AppMutation) ClearBillingProfilePaymentApp() {
	m.clearedbilling_profile_payment_app = true
}

// BillingProfilePaymentAppCleared reports if the "billing_profile_payment_app" edge to the BillingProfile entity was cleared.
func (m *AppMutation) BillingProfilePaymentAppCleared() bool {
	return m.clearedbilling_profile_payment_app
}

// RemoveBillingProfilePaymentAppIDs removes the "billing_profile_payment_app" edge to the BillingProfile entity by IDs.
func (m *AppMutation) RemoveBillingProfilePaymentAppIDs(ids ...string) {
	if m.removedbilling_profile_payment_app == nil {
		m.removedbilling_profile_payment_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_profile_payment_app, ids[i])
		m.removedbilling_profile_payment_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingProfilePaymentApp returns the removed IDs of the "billing_profile_payment_app" edge to the BillingProfile entity.
func (m *AppMutation) RemovedBillingProfilePaymentAppIDs() (ids []string) {
	for id := range m.removedbilling_profile_payment_app {
		ids = append(ids, id)
	}
	return
}

// BillingProfilePaymentAppIDs returns the "billing_profile_payment_app" edge IDs in the mutation.
func (m *AppMutation) BillingProfilePaymentAppIDs() (ids []string) {
	for id := range m.billing_profile_payment_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingProfilePaymentApp resets all changes to the "billing_profile_payment_app" edge.
func (m *AppMutation) ResetBillingProfilePaymentApp() {
	m.billing_profile_payment_app = nil
	m.clearedbilling_profile_payment_app = false
	m.removedbilling_profile_payment_app = nil
}

// AddBillingInvoiceTaxAppIDs adds the "billing_invoice_tax_app" edge to the BillingInvoice entity by ids.
func (m *AppMutation) AddBillingInvoiceTaxAppIDs(ids ...string) {
	if m.billing_invoice_tax_app == nil {
		m.billing_invoice_tax_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_tax_app[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoiceTaxApp clears the "billing_invoice_tax_app" edge to the BillingInvoice entity.
func (m *AppMutation) ClearBillingInvoiceTaxApp() {
	m.clearedbilling_invoice_tax_app = true
}

// BillingInvoiceTaxAppCleared reports if the "billing_invoice_tax_app" edge to the BillingInvoice entity was cleared.
func (m *AppMutation) BillingInvoiceTaxAppCleared() bool {
	return m.clearedbilling_invoice_tax_app
}

// RemoveBillingInvoiceTaxAppIDs removes the "billing_invoice_tax_app" edge to the BillingInvoice entity by IDs.
func (m *AppMutation) RemoveBillingInvoiceTaxAppIDs(ids ...string) {
	if m.removedbilling_invoice_tax_app == nil {
		m.removedbilling_invoice_tax_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_tax_app, ids[i])
		m.removedbilling_invoice_tax_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoiceTaxApp returns the removed IDs of the "billing_invoice_tax_app" edge to the BillingInvoice entity.
func (m *AppMutation) RemovedBillingInvoiceTaxAppIDs() (ids []string) {
	for id := range m.removedbilling_invoice_tax_app {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceTaxAppIDs returns the "billing_invoice_tax_app" edge IDs in the mutation.
func (m *AppMutation) BillingInvoiceTaxAppIDs() (ids []string) {
	for id := range m.billing_invoice_tax_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoiceTaxApp resets all changes to the "billing_invoice_tax_app" edge.
func (m *AppMutation) ResetBillingInvoiceTaxApp() {
	m.billing_invoice_tax_app = nil
	m.clearedbilling_invoice_tax_app = false
	m.removedbilling_invoice_tax_app = nil
}

// AddBillingInvoiceInvoicingAppIDs adds the "billing_invoice_invoicing_app" edge to the BillingInvoice entity by ids.
func (m *AppMutation) AddBillingInvoiceInvoicingAppIDs(ids ...string) {
	if m.billing_invoice_invoicing_app == nil {
		m.billing_invoice_invoicing_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_invoicing_app[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoiceInvoicingApp clears the "billing_invoice_invoicing_app" edge to the BillingInvoice entity.
func (m *AppMutation) ClearBillingInvoiceInvoicingApp() {
	m.clearedbilling_invoice_invoicing_app = true
}

// BillingInvoiceInvoicingAppCleared reports if the "billing_invoice_invoicing_app" edge to the BillingInvoice entity was cleared.
func (m *AppMutation) BillingInvoiceInvoicingAppCleared() bool {
	return m.clearedbilling_invoice_invoicing_app
}

// RemoveBillingInvoiceInvoicingAppIDs removes the "billing_invoice_invoicing_app" edge to the BillingInvoice entity by IDs.
func (m *AppMutation) RemoveBillingInvoiceInvoicingAppIDs(ids ...string) {
	if m.removedbilling_invoice_invoicing_app == nil {
		m.removedbilling_invoice_invoicing_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_invoicing_app, ids[i])
		m.removedbilling_invoice_invoicing_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoiceInvoicingApp returns the removed IDs of the "billing_invoice_invoicing_app" edge to the BillingInvoice entity.
func (m *AppMutation) RemovedBillingInvoiceInvoicingAppIDs() (ids []string) {
	for id := range m.removedbilling_invoice_invoicing_app {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceInvoicingAppIDs returns the "billing_invoice_invoicing_app" edge IDs in the mutation.
func (m *AppMutation) BillingInvoiceInvoicingAppIDs() (ids []string) {
	for id := range m.billing_invoice_invoicing_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoiceInvoicingApp resets all changes to the "billing_invoice_invoicing_app" edge.
func (m *AppMutation) ResetBillingInvoiceInvoicingApp() {
	m.billing_invoice_invoicing_app = nil
	m.clearedbilling_invoice_invoicing_app = false
	m.removedbilling_invoice_invoicing_app = nil
}

// AddBillingInvoicePaymentAppIDs adds the "billing_invoice_payment_app" edge to the BillingInvoice entity by ids.
func (m *AppMutation) AddBillingInvoicePaymentAppIDs(ids ...string) {
	if m.billing_invoice_payment_app == nil {
		m.billing_invoice_payment_app = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_payment_app[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoicePaymentApp clears the "billing_invoice_payment_app" edge to the BillingInvoice entity.
func (m *AppMutation) ClearBillingInvoicePaymentApp() {
	m.clearedbilling_invoice_payment_app = true
}

// BillingInvoicePaymentAppCleared reports if the "billing_invoice_payment_app" edge to the BillingInvoice entity was cleared.
func (m *AppMutation) BillingInvoicePaymentAppCleared() bool {
	return m.clearedbilling_invoice_payment_app
}

// RemoveBillingInvoicePaymentAppIDs removes the "billing_invoice_payment_app" edge to the BillingInvoice entity by IDs.
func (m *AppMutation) RemoveBillingInvoicePaymentAppIDs(ids ...string) {
	if m.removedbilling_invoice_payment_app == nil {
		m.removedbilling_invoice_payment_app = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_payment_app, ids[i])
		m.removedbilling_invoice_payment_app[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoicePaymentApp returns the removed IDs of the "billing_invoice_payment_app" edge to the BillingInvoice entity.
func (m *AppMutation) RemovedBillingInvoicePaymentAppIDs() (ids []string) {
	for id := range m.removedbilling_invoice_payment_app {
		ids = append(ids, id)
	}
	return
}

// BillingInvoicePaymentAppIDs returns the "billing_invoice_payment_app" edge IDs in the mutation.
func (m *AppMutation) BillingInvoicePaymentAppIDs() (ids []string) {
	for id := range m.billing_invoice_payment_app {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoicePaymentApp resets all changes to the "billing_invoice_payment_app" edge.
func (m *AppMutation) ResetBillingInvoicePaymentApp() {
	m.billing_invoice_payment_app = nil
	m.clearedbilling_invoice_payment_app = false
	m.removedbilling_invoice_payment_app = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, dbapp.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, dbapp.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, dbapp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dbapp.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dbapp.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, dbapp.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dbapp.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, dbapp.FieldType)
	}
	if m.status != nil {
		fields = append(fields, dbapp.FieldStatus)
	}
	if m.is_default != nil {
		fields = append(fields, dbapp.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbapp.FieldNamespace:
		return m.Namespace()
	case dbapp.FieldMetadata:
		return m.Metadata()
	case dbapp.FieldCreatedAt:
		return m.CreatedAt()
	case dbapp.FieldUpdatedAt:
		return m.UpdatedAt()
	case dbapp.FieldDeletedAt:
		return m.DeletedAt()
	case dbapp.FieldName:
		return m.Name()
	case dbapp.FieldDescription:
		return m.Description()
	case dbapp.FieldType:
		return m.GetType()
	case dbapp.FieldStatus:
		return m.Status()
	case dbapp.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbapp.FieldNamespace:
		return m.OldNamespace(ctx)
	case dbapp.FieldMetadata:
		return m.OldMetadata(ctx)
	case dbapp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dbapp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dbapp.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dbapp.FieldName:
		return m.OldName(ctx)
	case dbapp.FieldDescription:
		return m.OldDescription(ctx)
	case dbapp.FieldType:
		return m.OldType(ctx)
	case dbapp.FieldStatus:
		return m.OldStatus(ctx)
	case dbapp.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbapp.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case dbapp.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case dbapp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dbapp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dbapp.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dbapp.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbapp.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dbapp.FieldType:
		v, ok := value.(app.AppType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dbapp.FieldStatus:
		v, ok := value.(app.AppStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dbapp.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbapp.FieldMetadata) {
		fields = append(fields, dbapp.FieldMetadata)
	}
	if m.FieldCleared(dbapp.FieldDeletedAt) {
		fields = append(fields, dbapp.FieldDeletedAt)
	}
	if m.FieldCleared(dbapp.FieldDescription) {
		fields = append(fields, dbapp.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case dbapp.FieldMetadata:
		m.ClearMetadata()
		return nil
	case dbapp.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dbapp.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case dbapp.FieldNamespace:
		m.ResetNamespace()
		return nil
	case dbapp.FieldMetadata:
		m.ResetMetadata()
		return nil
	case dbapp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dbapp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dbapp.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dbapp.FieldName:
		m.ResetName()
		return nil
	case dbapp.FieldDescription:
		m.ResetDescription()
		return nil
	case dbapp.FieldType:
		m.ResetType()
		return nil
	case dbapp.FieldStatus:
		m.ResetStatus()
		return nil
	case dbapp.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.customer_apps != nil {
		edges = append(edges, dbapp.EdgeCustomerApps)
	}
	if m.billing_profile_tax_app != nil {
		edges = append(edges, dbapp.EdgeBillingProfileTaxApp)
	}
	if m.billing_profile_invoicing_app != nil {
		edges = append(edges, dbapp.EdgeBillingProfileInvoicingApp)
	}
	if m.billing_profile_payment_app != nil {
		edges = append(edges, dbapp.EdgeBillingProfilePaymentApp)
	}
	if m.billing_invoice_tax_app != nil {
		edges = append(edges, dbapp.EdgeBillingInvoiceTaxApp)
	}
	if m.billing_invoice_invoicing_app != nil {
		edges = append(edges, dbapp.EdgeBillingInvoiceInvoicingApp)
	}
	if m.billing_invoice_payment_app != nil {
		edges = append(edges, dbapp.EdgeBillingInvoicePaymentApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbapp.EdgeCustomerApps:
		ids := make([]ent.Value, 0, len(m.customer_apps))
		for id := range m.customer_apps {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingProfileTaxApp:
		ids := make([]ent.Value, 0, len(m.billing_profile_tax_app))
		for id := range m.billing_profile_tax_app {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingProfileInvoicingApp:
		ids := make([]ent.Value, 0, len(m.billing_profile_invoicing_app))
		for id := range m.billing_profile_invoicing_app {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingProfilePaymentApp:
		ids := make([]ent.Value, 0, len(m.billing_profile_payment_app))
		for id := range m.billing_profile_payment_app {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingInvoiceTaxApp:
		ids := make([]ent.Value, 0, len(m.billing_invoice_tax_app))
		for id := range m.billing_invoice_tax_app {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingInvoiceInvoicingApp:
		ids := make([]ent.Value, 0, len(m.billing_invoice_invoicing_app))
		for id := range m.billing_invoice_invoicing_app {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingInvoicePaymentApp:
		ids := make([]ent.Value, 0, len(m.billing_invoice_payment_app))
		for id := range m.billing_invoice_payment_app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedcustomer_apps != nil {
		edges = append(edges, dbapp.EdgeCustomerApps)
	}
	if m.removedbilling_profile_tax_app != nil {
		edges = append(edges, dbapp.EdgeBillingProfileTaxApp)
	}
	if m.removedbilling_profile_invoicing_app != nil {
		edges = append(edges, dbapp.EdgeBillingProfileInvoicingApp)
	}
	if m.removedbilling_profile_payment_app != nil {
		edges = append(edges, dbapp.EdgeBillingProfilePaymentApp)
	}
	if m.removedbilling_invoice_tax_app != nil {
		edges = append(edges, dbapp.EdgeBillingInvoiceTaxApp)
	}
	if m.removedbilling_invoice_invoicing_app != nil {
		edges = append(edges, dbapp.EdgeBillingInvoiceInvoicingApp)
	}
	if m.removedbilling_invoice_payment_app != nil {
		edges = append(edges, dbapp.EdgeBillingInvoicePaymentApp)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dbapp.EdgeCustomerApps:
		ids := make([]ent.Value, 0, len(m.removedcustomer_apps))
		for id := range m.removedcustomer_apps {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingProfileTaxApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_profile_tax_app))
		for id := range m.removedbilling_profile_tax_app {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingProfileInvoicingApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_profile_invoicing_app))
		for id := range m.removedbilling_profile_invoicing_app {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingProfilePaymentApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_profile_payment_app))
		for id := range m.removedbilling_profile_payment_app {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingInvoiceTaxApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_tax_app))
		for id := range m.removedbilling_invoice_tax_app {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingInvoiceInvoicingApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_invoicing_app))
		for id := range m.removedbilling_invoice_invoicing_app {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeBillingInvoicePaymentApp:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_payment_app))
		for id := range m.removedbilling_invoice_payment_app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcustomer_apps {
		edges = append(edges, dbapp.EdgeCustomerApps)
	}
	if m.clearedbilling_profile_tax_app {
		edges = append(edges, dbapp.EdgeBillingProfileTaxApp)
	}
	if m.clearedbilling_profile_invoicing_app {
		edges = append(edges, dbapp.EdgeBillingProfileInvoicingApp)
	}
	if m.clearedbilling_profile_payment_app {
		edges = append(edges, dbapp.EdgeBillingProfilePaymentApp)
	}
	if m.clearedbilling_invoice_tax_app {
		edges = append(edges, dbapp.EdgeBillingInvoiceTaxApp)
	}
	if m.clearedbilling_invoice_invoicing_app {
		edges = append(edges, dbapp.EdgeBillingInvoiceInvoicingApp)
	}
	if m.clearedbilling_invoice_payment_app {
		edges = append(edges, dbapp.EdgeBillingInvoicePaymentApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case dbapp.EdgeCustomerApps:
		return m.clearedcustomer_apps
	case dbapp.EdgeBillingProfileTaxApp:
		return m.clearedbilling_profile_tax_app
	case dbapp.EdgeBillingProfileInvoicingApp:
		return m.clearedbilling_profile_invoicing_app
	case dbapp.EdgeBillingProfilePaymentApp:
		return m.clearedbilling_profile_payment_app
	case dbapp.EdgeBillingInvoiceTaxApp:
		return m.clearedbilling_invoice_tax_app
	case dbapp.EdgeBillingInvoiceInvoicingApp:
		return m.clearedbilling_invoice_invoicing_app
	case dbapp.EdgeBillingInvoicePaymentApp:
		return m.clearedbilling_invoice_payment_app
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case dbapp.EdgeCustomerApps:
		m.ResetCustomerApps()
		return nil
	case dbapp.EdgeBillingProfileTaxApp:
		m.ResetBillingProfileTaxApp()
		return nil
	case dbapp.EdgeBillingProfileInvoicingApp:
		m.ResetBillingProfileInvoicingApp()
		return nil
	case dbapp.EdgeBillingProfilePaymentApp:
		m.ResetBillingProfilePaymentApp()
		return nil
	case dbapp.EdgeBillingInvoiceTaxApp:
		m.ResetBillingInvoiceTaxApp()
		return nil
	case dbapp.EdgeBillingInvoiceInvoicingApp:
		m.ResetBillingInvoiceInvoicingApp()
		return nil
	case dbapp.EdgeBillingInvoicePaymentApp:
		m.ResetBillingInvoicePaymentApp()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppCustomInvoicingMutation represents an operation that mutates the AppCustomInvoicing nodes in the graph.
type AppCustomInvoicingMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	namespace                *string
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	enable_draft_sync_hook   *bool
	enable_issuing_sync_hook *bool
	clearedFields            map[string]struct{}
	customer_apps            map[int]struct{}
	removedcustomer_apps     map[int]struct{}
	clearedcustomer_apps     bool
	app                      *string
	clearedapp               bool
	done                     bool
	oldValue                 func(context.Context) (*AppCustomInvoicing, error)
	predicates               []predicate.AppCustomInvoicing
}

var _ ent.Mutation = (*AppCustomInvoicingMutation)(nil)

// appcustominvoicingOption allows management of the mutation configuration using functional options.
type appcustominvoicingOption func(*AppCustomInvoicingMutation)

// newAppCustomInvoicingMutation creates new mutation for the AppCustomInvoicing entity.
func newAppCustomInvoicingMutation(c config, op Op, opts ...appcustominvoicingOption) *AppCustomInvoicingMutation {
	m := &AppCustomInvoicingMutation{
		config:        c,
		op:            op,
		typ:           TypeAppCustomInvoicing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppCustomInvoicingID sets the ID field of the mutation.
func withAppCustomInvoicingID(id string) appcustominvoicingOption {
	return func(m *AppCustomInvoicingMutation) {
		var (
			err   error
			once  sync.Once
			value *AppCustomInvoicing
		)
		m.oldValue = func(ctx context.Context) (*AppCustomInvoicing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppCustomInvoicing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppCustomInvoicing sets the old AppCustomInvoicing of the mutation.
func withAppCustomInvoicing(node *AppCustomInvoicing) appcustominvoicingOption {
	return func(m *AppCustomInvoicingMutation) {
		m.oldValue = func(context.Context) (*AppCustomInvoicing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppCustomInvoicingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppCustomInvoicingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppCustomInvoicing entities.
func (m *AppCustomInvoicingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppCustomInvoicingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppCustomInvoicingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppCustomInvoicing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppCustomInvoicingMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppCustomInvoicingMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the AppCustomInvoicing entity.
// If the AppCustomInvoicing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppCustomInvoicingMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppCustomInvoicingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppCustomInvoicingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppCustomInvoicing entity.
// If the AppCustomInvoicing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppCustomInvoicingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppCustomInvoicingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppCustomInvoicingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppCustomInvoicing entity.
// If the AppCustomInvoicing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppCustomInvoicingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppCustomInvoicingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppCustomInvoicingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppCustomInvoicing entity.
// If the AppCustomInvoicing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppCustomInvoicingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appcustominvoicing.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppCustomInvoicingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appcustominvoicing.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppCustomInvoicingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appcustominvoicing.FieldDeletedAt)
}

// SetEnableDraftSyncHook sets the "enable_draft_sync_hook" field.
func (m *AppCustomInvoicingMutation) SetEnableDraftSyncHook(b bool) {
	m.enable_draft_sync_hook = &b
}

// EnableDraftSyncHook returns the value of the "enable_draft_sync_hook" field in the mutation.
func (m *AppCustomInvoicingMutation) EnableDraftSyncHook() (r bool, exists bool) {
	v := m.enable_draft_sync_hook
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableDraftSyncHook returns the old "enable_draft_sync_hook" field's value of the AppCustomInvoicing entity.
// If the AppCustomInvoicing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingMutation) OldEnableDraftSyncHook(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableDraftSyncHook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableDraftSyncHook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableDraftSyncHook: %w", err)
	}
	return oldValue.EnableDraftSyncHook, nil
}

// ResetEnableDraftSyncHook resets all changes to the "enable_draft_sync_hook" field.
func (m *AppCustomInvoicingMutation) ResetEnableDraftSyncHook() {
	m.enable_draft_sync_hook = nil
}

// SetEnableIssuingSyncHook sets the "enable_issuing_sync_hook" field.
func (m *AppCustomInvoicingMutation) SetEnableIssuingSyncHook(b bool) {
	m.enable_issuing_sync_hook = &b
}

// EnableIssuingSyncHook returns the value of the "enable_issuing_sync_hook" field in the mutation.
func (m *AppCustomInvoicingMutation) EnableIssuingSyncHook() (r bool, exists bool) {
	v := m.enable_issuing_sync_hook
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableIssuingSyncHook returns the old "enable_issuing_sync_hook" field's value of the AppCustomInvoicing entity.
// If the AppCustomInvoicing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingMutation) OldEnableIssuingSyncHook(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableIssuingSyncHook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableIssuingSyncHook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableIssuingSyncHook: %w", err)
	}
	return oldValue.EnableIssuingSyncHook, nil
}

// ResetEnableIssuingSyncHook resets all changes to the "enable_issuing_sync_hook" field.
func (m *AppCustomInvoicingMutation) ResetEnableIssuingSyncHook() {
	m.enable_issuing_sync_hook = nil
}

// AddCustomerAppIDs adds the "customer_apps" edge to the AppCustomInvoicingCustomer entity by ids.
func (m *AppCustomInvoicingMutation) AddCustomerAppIDs(ids ...int) {
	if m.customer_apps == nil {
		m.customer_apps = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_apps[ids[i]] = struct{}{}
	}
}

// ClearCustomerApps clears the "customer_apps" edge to the AppCustomInvoicingCustomer entity.
func (m *AppCustomInvoicingMutation) ClearCustomerApps() {
	m.clearedcustomer_apps = true
}

// CustomerAppsCleared reports if the "customer_apps" edge to the AppCustomInvoicingCustomer entity was cleared.
func (m *AppCustomInvoicingMutation) CustomerAppsCleared() bool {
	return m.clearedcustomer_apps
}

// RemoveCustomerAppIDs removes the "customer_apps" edge to the AppCustomInvoicingCustomer entity by IDs.
func (m *AppCustomInvoicingMutation) RemoveCustomerAppIDs(ids ...int) {
	if m.removedcustomer_apps == nil {
		m.removedcustomer_apps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_apps, ids[i])
		m.removedcustomer_apps[ids[i]] = struct{}{}
	}
}

// RemovedCustomerApps returns the removed IDs of the "customer_apps" edge to the AppCustomInvoicingCustomer entity.
func (m *AppCustomInvoicingMutation) RemovedCustomerAppsIDs() (ids []int) {
	for id := range m.removedcustomer_apps {
		ids = append(ids, id)
	}
	return
}

// CustomerAppsIDs returns the "customer_apps" edge IDs in the mutation.
func (m *AppCustomInvoicingMutation) CustomerAppsIDs() (ids []int) {
	for id := range m.customer_apps {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerApps resets all changes to the "customer_apps" edge.
func (m *AppCustomInvoicingMutation) ResetCustomerApps() {
	m.customer_apps = nil
	m.clearedcustomer_apps = false
	m.removedcustomer_apps = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *AppCustomInvoicingMutation) SetAppID(id string) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppCustomInvoicingMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppCustomInvoicingMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *AppCustomInvoicingMutation) AppID() (id string, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppCustomInvoicingMutation) AppIDs() (ids []string) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppCustomInvoicingMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the AppCustomInvoicingMutation builder.
func (m *AppCustomInvoicingMutation) Where(ps ...predicate.AppCustomInvoicing) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppCustomInvoicingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppCustomInvoicingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppCustomInvoicing, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppCustomInvoicingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppCustomInvoicingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppCustomInvoicing).
func (m *AppCustomInvoicingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppCustomInvoicingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.namespace != nil {
		fields = append(fields, appcustominvoicing.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, appcustominvoicing.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appcustominvoicing.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appcustominvoicing.FieldDeletedAt)
	}
	if m.enable_draft_sync_hook != nil {
		fields = append(fields, appcustominvoicing.FieldEnableDraftSyncHook)
	}
	if m.enable_issuing_sync_hook != nil {
		fields = append(fields, appcustominvoicing.FieldEnableIssuingSyncHook)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppCustomInvoicingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appcustominvoicing.FieldNamespace:
		return m.Namespace()
	case appcustominvoicing.FieldCreatedAt:
		return m.CreatedAt()
	case appcustominvoicing.FieldUpdatedAt:
		return m.UpdatedAt()
	case appcustominvoicing.FieldDeletedAt:
		return m.DeletedAt()
	case appcustominvoicing.FieldEnableDraftSyncHook:
		return m.EnableDraftSyncHook()
	case appcustominvoicing.FieldEnableIssuingSyncHook:
		return m.EnableIssuingSyncHook()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppCustomInvoicingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appcustominvoicing.FieldNamespace:
		return m.OldNamespace(ctx)
	case appcustominvoicing.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appcustominvoicing.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appcustominvoicing.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appcustominvoicing.FieldEnableDraftSyncHook:
		return m.OldEnableDraftSyncHook(ctx)
	case appcustominvoicing.FieldEnableIssuingSyncHook:
		return m.OldEnableIssuingSyncHook(ctx)
	}
	return nil, fmt.Errorf("unknown AppCustomInvoicing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCustomInvoicingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appcustominvoicing.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case appcustominvoicing.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appcustominvoicing.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appcustominvoicing.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appcustominvoicing.FieldEnableDraftSyncHook:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableDraftSyncHook(v)
		return nil
	case appcustominvoicing.FieldEnableIssuingSyncHook:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableIssuingSyncHook(v)
		return nil
	}
	return fmt.Errorf("unknown AppCustomInvoicing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppCustomInvoicingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppCustomInvoicingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCustomInvoicingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppCustomInvoicing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppCustomInvoicingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appcustominvoicing.FieldDeletedAt) {
		fields = append(fields, appcustominvoicing.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppCustomInvoicingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppCustomInvoicingMutation) ClearField(name string) error {
	switch name {
	case appcustominvoicing.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AppCustomInvoicing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppCustomInvoicingMutation) ResetField(name string) error {
	switch name {
	case appcustominvoicing.FieldNamespace:
		m.ResetNamespace()
		return nil
	case appcustominvoicing.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appcustominvoicing.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appcustominvoicing.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appcustominvoicing.FieldEnableDraftSyncHook:
		m.ResetEnableDraftSyncHook()
		return nil
	case appcustominvoicing.FieldEnableIssuingSyncHook:
		m.ResetEnableIssuingSyncHook()
		return nil
	}
	return fmt.Errorf("unknown AppCustomInvoicing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppCustomInvoicingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.customer_apps != nil {
		edges = append(edges, appcustominvoicing.EdgeCustomerApps)
	}
	if m.app != nil {
		edges = append(edges, appcustominvoicing.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppCustomInvoicingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appcustominvoicing.EdgeCustomerApps:
		ids := make([]ent.Value, 0, len(m.customer_apps))
		for id := range m.customer_apps {
			ids = append(ids, id)
		}
		return ids
	case appcustominvoicing.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppCustomInvoicingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcustomer_apps != nil {
		edges = append(edges, appcustominvoicing.EdgeCustomerApps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppCustomInvoicingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case appcustominvoicing.EdgeCustomerApps:
		ids := make([]ent.Value, 0, len(m.removedcustomer_apps))
		for id := range m.removedcustomer_apps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppCustomInvoicingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcustomer_apps {
		edges = append(edges, appcustominvoicing.EdgeCustomerApps)
	}
	if m.clearedapp {
		edges = append(edges, appcustominvoicing.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppCustomInvoicingMutation) EdgeCleared(name string) bool {
	switch name {
	case appcustominvoicing.EdgeCustomerApps:
		return m.clearedcustomer_apps
	case appcustominvoicing.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppCustomInvoicingMutation) ClearEdge(name string) error {
	switch name {
	case appcustominvoicing.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppCustomInvoicing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppCustomInvoicingMutation) ResetEdge(name string) error {
	switch name {
	case appcustominvoicing.EdgeCustomerApps:
		m.ResetCustomerApps()
		return nil
	case appcustominvoicing.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AppCustomInvoicing edge %s", name)
}

// AppCustomInvoicingCustomerMutation represents an operation that mutates the AppCustomInvoicingCustomer nodes in the graph.
type AppCustomInvoicingCustomerMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	namespace                   *string
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	metadata                    *map[string]string
	clearedFields               map[string]struct{}
	custom_invoicing_app        *string
	clearedcustom_invoicing_app bool
	customer                    *string
	clearedcustomer             bool
	done                        bool
	oldValue                    func(context.Context) (*AppCustomInvoicingCustomer, error)
	predicates                  []predicate.AppCustomInvoicingCustomer
}

var _ ent.Mutation = (*AppCustomInvoicingCustomerMutation)(nil)

// appcustominvoicingcustomerOption allows management of the mutation configuration using functional options.
type appcustominvoicingcustomerOption func(*AppCustomInvoicingCustomerMutation)

// newAppCustomInvoicingCustomerMutation creates new mutation for the AppCustomInvoicingCustomer entity.
func newAppCustomInvoicingCustomerMutation(c config, op Op, opts ...appcustominvoicingcustomerOption) *AppCustomInvoicingCustomerMutation {
	m := &AppCustomInvoicingCustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeAppCustomInvoicingCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppCustomInvoicingCustomerID sets the ID field of the mutation.
func withAppCustomInvoicingCustomerID(id int) appcustominvoicingcustomerOption {
	return func(m *AppCustomInvoicingCustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *AppCustomInvoicingCustomer
		)
		m.oldValue = func(ctx context.Context) (*AppCustomInvoicingCustomer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppCustomInvoicingCustomer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppCustomInvoicingCustomer sets the old AppCustomInvoicingCustomer of the mutation.
func withAppCustomInvoicingCustomer(node *AppCustomInvoicingCustomer) appcustominvoicingcustomerOption {
	return func(m *AppCustomInvoicingCustomerMutation) {
		m.oldValue = func(context.Context) (*AppCustomInvoicingCustomer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppCustomInvoicingCustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppCustomInvoicingCustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppCustomInvoicingCustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppCustomInvoicingCustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppCustomInvoicingCustomer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppCustomInvoicingCustomerMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppCustomInvoicingCustomerMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the AppCustomInvoicingCustomer entity.
// If the AppCustomInvoicingCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingCustomerMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppCustomInvoicingCustomerMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppCustomInvoicingCustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppCustomInvoicingCustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppCustomInvoicingCustomer entity.
// If the AppCustomInvoicingCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingCustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppCustomInvoicingCustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppCustomInvoicingCustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppCustomInvoicingCustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppCustomInvoicingCustomer entity.
// If the AppCustomInvoicingCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingCustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppCustomInvoicingCustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppCustomInvoicingCustomerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppCustomInvoicingCustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppCustomInvoicingCustomer entity.
// If the AppCustomInvoicingCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingCustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppCustomInvoicingCustomerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appcustominvoicingcustomer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppCustomInvoicingCustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appcustominvoicingcustomer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppCustomInvoicingCustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appcustominvoicingcustomer.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *AppCustomInvoicingCustomerMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AppCustomInvoicingCustomerMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AppCustomInvoicingCustomer entity.
// If the AppCustomInvoicingCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingCustomerMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AppCustomInvoicingCustomerMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[appcustominvoicingcustomer.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AppCustomInvoicingCustomerMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[appcustominvoicingcustomer.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AppCustomInvoicingCustomerMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, appcustominvoicingcustomer.FieldMetadata)
}

// SetAppID sets the "app_id" field.
func (m *AppCustomInvoicingCustomerMutation) SetAppID(s string) {
	m.custom_invoicing_app = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppCustomInvoicingCustomerMutation) AppID() (r string, exists bool) {
	v := m.custom_invoicing_app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppCustomInvoicingCustomer entity.
// If the AppCustomInvoicingCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingCustomerMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppCustomInvoicingCustomerMutation) ResetAppID() {
	m.custom_invoicing_app = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *AppCustomInvoicingCustomerMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *AppCustomInvoicingCustomerMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the AppCustomInvoicingCustomer entity.
// If the AppCustomInvoicingCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomInvoicingCustomerMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *AppCustomInvoicingCustomerMutation) ResetCustomerID() {
	m.customer = nil
}

// SetCustomInvoicingAppID sets the "custom_invoicing_app" edge to the AppCustomInvoicing entity by id.
func (m *AppCustomInvoicingCustomerMutation) SetCustomInvoicingAppID(id string) {
	m.custom_invoicing_app = &id
}

// ClearCustomInvoicingApp clears the "custom_invoicing_app" edge to the AppCustomInvoicing entity.
func (m *AppCustomInvoicingCustomerMutation) ClearCustomInvoicingApp() {
	m.clearedcustom_invoicing_app = true
	m.clearedFields[appcustominvoicingcustomer.FieldAppID] = struct{}{}
}

// CustomInvoicingAppCleared reports if the "custom_invoicing_app" edge to the AppCustomInvoicing entity was cleared.
func (m *AppCustomInvoicingCustomerMutation) CustomInvoicingAppCleared() bool {
	return m.clearedcustom_invoicing_app
}

// CustomInvoicingAppID returns the "custom_invoicing_app" edge ID in the mutation.
func (m *AppCustomInvoicingCustomerMutation) CustomInvoicingAppID() (id string, exists bool) {
	if m.custom_invoicing_app != nil {
		return *m.custom_invoicing_app, true
	}
	return
}

// CustomInvoicingAppIDs returns the "custom_invoicing_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomInvoicingAppID instead. It exists only for internal usage by the builders.
func (m *AppCustomInvoicingCustomerMutation) CustomInvoicingAppIDs() (ids []string) {
	if id := m.custom_invoicing_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomInvoicingApp resets all changes to the "custom_invoicing_app" edge.
func (m *AppCustomInvoicingCustomerMutation) ResetCustomInvoicingApp() {
	m.custom_invoicing_app = nil
	m.clearedcustom_invoicing_app = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *AppCustomInvoicingCustomerMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[appcustominvoicingcustomer.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *AppCustomInvoicingCustomerMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *AppCustomInvoicingCustomerMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *AppCustomInvoicingCustomerMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the AppCustomInvoicingCustomerMutation builder.
func (m *AppCustomInvoicingCustomerMutation) Where(ps ...predicate.AppCustomInvoicingCustomer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppCustomInvoicingCustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppCustomInvoicingCustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppCustomInvoicingCustomer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppCustomInvoicingCustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppCustomInvoicingCustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppCustomInvoicingCustomer).
func (m *AppCustomInvoicingCustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppCustomInvoicingCustomerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.namespace != nil {
		fields = append(fields, appcustominvoicingcustomer.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, appcustominvoicingcustomer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appcustominvoicingcustomer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appcustominvoicingcustomer.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, appcustominvoicingcustomer.FieldMetadata)
	}
	if m.custom_invoicing_app != nil {
		fields = append(fields, appcustominvoicingcustomer.FieldAppID)
	}
	if m.customer != nil {
		fields = append(fields, appcustominvoicingcustomer.FieldCustomerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppCustomInvoicingCustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appcustominvoicingcustomer.FieldNamespace:
		return m.Namespace()
	case appcustominvoicingcustomer.FieldCreatedAt:
		return m.CreatedAt()
	case appcustominvoicingcustomer.FieldUpdatedAt:
		return m.UpdatedAt()
	case appcustominvoicingcustomer.FieldDeletedAt:
		return m.DeletedAt()
	case appcustominvoicingcustomer.FieldMetadata:
		return m.Metadata()
	case appcustominvoicingcustomer.FieldAppID:
		return m.AppID()
	case appcustominvoicingcustomer.FieldCustomerID:
		return m.CustomerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppCustomInvoicingCustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appcustominvoicingcustomer.FieldNamespace:
		return m.OldNamespace(ctx)
	case appcustominvoicingcustomer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appcustominvoicingcustomer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appcustominvoicingcustomer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appcustominvoicingcustomer.FieldMetadata:
		return m.OldMetadata(ctx)
	case appcustominvoicingcustomer.FieldAppID:
		return m.OldAppID(ctx)
	case appcustominvoicingcustomer.FieldCustomerID:
		return m.OldCustomerID(ctx)
	}
	return nil, fmt.Errorf("unknown AppCustomInvoicingCustomer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCustomInvoicingCustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appcustominvoicingcustomer.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case appcustominvoicingcustomer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appcustominvoicingcustomer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appcustominvoicingcustomer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appcustominvoicingcustomer.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case appcustominvoicingcustomer.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appcustominvoicingcustomer.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	}
	return fmt.Errorf("unknown AppCustomInvoicingCustomer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppCustomInvoicingCustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppCustomInvoicingCustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCustomInvoicingCustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppCustomInvoicingCustomer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppCustomInvoicingCustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appcustominvoicingcustomer.FieldDeletedAt) {
		fields = append(fields, appcustominvoicingcustomer.FieldDeletedAt)
	}
	if m.FieldCleared(appcustominvoicingcustomer.FieldMetadata) {
		fields = append(fields, appcustominvoicingcustomer.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppCustomInvoicingCustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppCustomInvoicingCustomerMutation) ClearField(name string) error {
	switch name {
	case appcustominvoicingcustomer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case appcustominvoicingcustomer.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AppCustomInvoicingCustomer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppCustomInvoicingCustomerMutation) ResetField(name string) error {
	switch name {
	case appcustominvoicingcustomer.FieldNamespace:
		m.ResetNamespace()
		return nil
	case appcustominvoicingcustomer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appcustominvoicingcustomer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appcustominvoicingcustomer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appcustominvoicingcustomer.FieldMetadata:
		m.ResetMetadata()
		return nil
	case appcustominvoicingcustomer.FieldAppID:
		m.ResetAppID()
		return nil
	case appcustominvoicingcustomer.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	}
	return fmt.Errorf("unknown AppCustomInvoicingCustomer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppCustomInvoicingCustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.custom_invoicing_app != nil {
		edges = append(edges, appcustominvoicingcustomer.EdgeCustomInvoicingApp)
	}
	if m.customer != nil {
		edges = append(edges, appcustominvoicingcustomer.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppCustomInvoicingCustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appcustominvoicingcustomer.EdgeCustomInvoicingApp:
		if id := m.custom_invoicing_app; id != nil {
			return []ent.Value{*id}
		}
	case appcustominvoicingcustomer.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppCustomInvoicingCustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppCustomInvoicingCustomerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppCustomInvoicingCustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcustom_invoicing_app {
		edges = append(edges, appcustominvoicingcustomer.EdgeCustomInvoicingApp)
	}
	if m.clearedcustomer {
		edges = append(edges, appcustominvoicingcustomer.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppCustomInvoicingCustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case appcustominvoicingcustomer.EdgeCustomInvoicingApp:
		return m.clearedcustom_invoicing_app
	case appcustominvoicingcustomer.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppCustomInvoicingCustomerMutation) ClearEdge(name string) error {
	switch name {
	case appcustominvoicingcustomer.EdgeCustomInvoicingApp:
		m.ClearCustomInvoicingApp()
		return nil
	case appcustominvoicingcustomer.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown AppCustomInvoicingCustomer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppCustomInvoicingCustomerMutation) ResetEdge(name string) error {
	switch name {
	case appcustominvoicingcustomer.EdgeCustomInvoicingApp:
		m.ResetCustomInvoicingApp()
		return nil
	case appcustominvoicingcustomer.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown AppCustomInvoicingCustomer edge %s", name)
}

// AppCustomerMutation represents an operation that mutates the AppCustomer nodes in the graph.
type AppCustomerMutation struct {
	config
	op              Op
	typ             string
	id              *int
	namespace       *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	clearedFields   map[string]struct{}
	app             *string
	clearedapp      bool
	customer        *string
	clearedcustomer bool
	done            bool
	oldValue        func(context.Context) (*AppCustomer, error)
	predicates      []predicate.AppCustomer
}

var _ ent.Mutation = (*AppCustomerMutation)(nil)

// appcustomerOption allows management of the mutation configuration using functional options.
type appcustomerOption func(*AppCustomerMutation)

// newAppCustomerMutation creates new mutation for the AppCustomer entity.
func newAppCustomerMutation(c config, op Op, opts ...appcustomerOption) *AppCustomerMutation {
	m := &AppCustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeAppCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppCustomerID sets the ID field of the mutation.
func withAppCustomerID(id int) appcustomerOption {
	return func(m *AppCustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *AppCustomer
		)
		m.oldValue = func(ctx context.Context) (*AppCustomer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppCustomer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppCustomer sets the old AppCustomer of the mutation.
func withAppCustomer(node *AppCustomer) appcustomerOption {
	return func(m *AppCustomerMutation) {
		m.oldValue = func(context.Context) (*AppCustomer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppCustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppCustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppCustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppCustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppCustomer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppCustomerMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppCustomerMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppCustomerMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppCustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppCustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppCustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppCustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppCustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppCustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppCustomerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppCustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppCustomerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appcustomer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppCustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appcustomer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppCustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appcustomer.FieldDeletedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppCustomerMutation) SetAppID(s string) {
	m.app = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppCustomerMutation) AppID() (r string, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppCustomerMutation) ResetAppID() {
	m.app = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *AppCustomerMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *AppCustomerMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the AppCustomer entity.
// If the AppCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCustomerMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *AppCustomerMutation) ResetCustomerID() {
	m.customer = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppCustomerMutation) ClearApp() {
	m.clearedapp = true
	m.clearedFields[appcustomer.FieldAppID] = struct{}{}
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppCustomerMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppCustomerMutation) AppIDs() (ids []string) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppCustomerMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *AppCustomerMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[appcustomer.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *AppCustomerMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *AppCustomerMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *AppCustomerMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the AppCustomerMutation builder.
func (m *AppCustomerMutation) Where(ps ...predicate.AppCustomer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppCustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppCustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppCustomer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppCustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppCustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppCustomer).
func (m *AppCustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppCustomerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.namespace != nil {
		fields = append(fields, appcustomer.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, appcustomer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appcustomer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appcustomer.FieldDeletedAt)
	}
	if m.app != nil {
		fields = append(fields, appcustomer.FieldAppID)
	}
	if m.customer != nil {
		fields = append(fields, appcustomer.FieldCustomerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppCustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appcustomer.FieldNamespace:
		return m.Namespace()
	case appcustomer.FieldCreatedAt:
		return m.CreatedAt()
	case appcustomer.FieldUpdatedAt:
		return m.UpdatedAt()
	case appcustomer.FieldDeletedAt:
		return m.DeletedAt()
	case appcustomer.FieldAppID:
		return m.AppID()
	case appcustomer.FieldCustomerID:
		return m.CustomerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppCustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appcustomer.FieldNamespace:
		return m.OldNamespace(ctx)
	case appcustomer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appcustomer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appcustomer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appcustomer.FieldAppID:
		return m.OldAppID(ctx)
	case appcustomer.FieldCustomerID:
		return m.OldCustomerID(ctx)
	}
	return nil, fmt.Errorf("unknown AppCustomer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appcustomer.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case appcustomer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appcustomer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appcustomer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appcustomer.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appcustomer.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	}
	return fmt.Errorf("unknown AppCustomer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppCustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppCustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppCustomer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppCustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appcustomer.FieldDeletedAt) {
		fields = append(fields, appcustomer.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppCustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppCustomerMutation) ClearField(name string) error {
	switch name {
	case appcustomer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AppCustomer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppCustomerMutation) ResetField(name string) error {
	switch name {
	case appcustomer.FieldNamespace:
		m.ResetNamespace()
		return nil
	case appcustomer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appcustomer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appcustomer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appcustomer.FieldAppID:
		m.ResetAppID()
		return nil
	case appcustomer.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	}
	return fmt.Errorf("unknown AppCustomer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppCustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, appcustomer.EdgeApp)
	}
	if m.customer != nil {
		edges = append(edges, appcustomer.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppCustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appcustomer.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appcustomer.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppCustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppCustomerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppCustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, appcustomer.EdgeApp)
	}
	if m.clearedcustomer {
		edges = append(edges, appcustomer.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppCustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case appcustomer.EdgeApp:
		return m.clearedapp
	case appcustomer.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppCustomerMutation) ClearEdge(name string) error {
	switch name {
	case appcustomer.EdgeApp:
		m.ClearApp()
		return nil
	case appcustomer.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown AppCustomer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppCustomerMutation) ResetEdge(name string) error {
	switch name {
	case appcustomer.EdgeApp:
		m.ResetApp()
		return nil
	case appcustomer.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown AppCustomer edge %s", name)
}

// AppStripeMutation represents an operation that mutates the AppStripe nodes in the graph.
type AppStripeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	namespace            *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	stripe_account_id    *string
	stripe_livemode      *bool
	api_key              *string
	masked_api_key       *string
	stripe_webhook_id    *string
	webhook_secret       *string
	clearedFields        map[string]struct{}
	customer_apps        map[int]struct{}
	removedcustomer_apps map[int]struct{}
	clearedcustomer_apps bool
	app                  *string
	clearedapp           bool
	done                 bool
	oldValue             func(context.Context) (*AppStripe, error)
	predicates           []predicate.AppStripe
}

var _ ent.Mutation = (*AppStripeMutation)(nil)

// appstripeOption allows management of the mutation configuration using functional options.
type appstripeOption func(*AppStripeMutation)

// newAppStripeMutation creates new mutation for the AppStripe entity.
func newAppStripeMutation(c config, op Op, opts ...appstripeOption) *AppStripeMutation {
	m := &AppStripeMutation{
		config:        c,
		op:            op,
		typ:           TypeAppStripe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppStripeID sets the ID field of the mutation.
func withAppStripeID(id string) appstripeOption {
	return func(m *AppStripeMutation) {
		var (
			err   error
			once  sync.Once
			value *AppStripe
		)
		m.oldValue = func(ctx context.Context) (*AppStripe, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppStripe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppStripe sets the old AppStripe of the mutation.
func withAppStripe(node *AppStripe) appstripeOption {
	return func(m *AppStripeMutation) {
		m.oldValue = func(context.Context) (*AppStripe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppStripeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppStripeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppStripe entities.
func (m *AppStripeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppStripeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppStripeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppStripe.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppStripeMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppStripeMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppStripeMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppStripeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppStripeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppStripeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppStripeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppStripeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppStripeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppStripeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppStripeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppStripeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appstripe.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppStripeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appstripe.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppStripeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appstripe.FieldDeletedAt)
}

// SetStripeAccountID sets the "stripe_account_id" field.
func (m *AppStripeMutation) SetStripeAccountID(s string) {
	m.stripe_account_id = &s
}

// StripeAccountID returns the value of the "stripe_account_id" field in the mutation.
func (m *AppStripeMutation) StripeAccountID() (r string, exists bool) {
	v := m.stripe_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeAccountID returns the old "stripe_account_id" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldStripeAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeAccountID: %w", err)
	}
	return oldValue.StripeAccountID, nil
}

// ResetStripeAccountID resets all changes to the "stripe_account_id" field.
func (m *AppStripeMutation) ResetStripeAccountID() {
	m.stripe_account_id = nil
}

// SetStripeLivemode sets the "stripe_livemode" field.
func (m *AppStripeMutation) SetStripeLivemode(b bool) {
	m.stripe_livemode = &b
}

// StripeLivemode returns the value of the "stripe_livemode" field in the mutation.
func (m *AppStripeMutation) StripeLivemode() (r bool, exists bool) {
	v := m.stripe_livemode
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeLivemode returns the old "stripe_livemode" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldStripeLivemode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeLivemode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeLivemode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeLivemode: %w", err)
	}
	return oldValue.StripeLivemode, nil
}

// ResetStripeLivemode resets all changes to the "stripe_livemode" field.
func (m *AppStripeMutation) ResetStripeLivemode() {
	m.stripe_livemode = nil
}

// SetAPIKey sets the "api_key" field.
func (m *AppStripeMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *AppStripeMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *AppStripeMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetMaskedAPIKey sets the "masked_api_key" field.
func (m *AppStripeMutation) SetMaskedAPIKey(s string) {
	m.masked_api_key = &s
}

// MaskedAPIKey returns the value of the "masked_api_key" field in the mutation.
func (m *AppStripeMutation) MaskedAPIKey() (r string, exists bool) {
	v := m.masked_api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldMaskedAPIKey returns the old "masked_api_key" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldMaskedAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaskedAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaskedAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaskedAPIKey: %w", err)
	}
	return oldValue.MaskedAPIKey, nil
}

// ResetMaskedAPIKey resets all changes to the "masked_api_key" field.
func (m *AppStripeMutation) ResetMaskedAPIKey() {
	m.masked_api_key = nil
}

// SetStripeWebhookID sets the "stripe_webhook_id" field.
func (m *AppStripeMutation) SetStripeWebhookID(s string) {
	m.stripe_webhook_id = &s
}

// StripeWebhookID returns the value of the "stripe_webhook_id" field in the mutation.
func (m *AppStripeMutation) StripeWebhookID() (r string, exists bool) {
	v := m.stripe_webhook_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeWebhookID returns the old "stripe_webhook_id" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldStripeWebhookID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeWebhookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeWebhookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeWebhookID: %w", err)
	}
	return oldValue.StripeWebhookID, nil
}

// ResetStripeWebhookID resets all changes to the "stripe_webhook_id" field.
func (m *AppStripeMutation) ResetStripeWebhookID() {
	m.stripe_webhook_id = nil
}

// SetWebhookSecret sets the "webhook_secret" field.
func (m *AppStripeMutation) SetWebhookSecret(s string) {
	m.webhook_secret = &s
}

// WebhookSecret returns the value of the "webhook_secret" field in the mutation.
func (m *AppStripeMutation) WebhookSecret() (r string, exists bool) {
	v := m.webhook_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldWebhookSecret returns the old "webhook_secret" field's value of the AppStripe entity.
// If the AppStripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeMutation) OldWebhookSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebhookSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebhookSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebhookSecret: %w", err)
	}
	return oldValue.WebhookSecret, nil
}

// ResetWebhookSecret resets all changes to the "webhook_secret" field.
func (m *AppStripeMutation) ResetWebhookSecret() {
	m.webhook_secret = nil
}

// AddCustomerAppIDs adds the "customer_apps" edge to the AppStripeCustomer entity by ids.
func (m *AppStripeMutation) AddCustomerAppIDs(ids ...int) {
	if m.customer_apps == nil {
		m.customer_apps = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_apps[ids[i]] = struct{}{}
	}
}

// ClearCustomerApps clears the "customer_apps" edge to the AppStripeCustomer entity.
func (m *AppStripeMutation) ClearCustomerApps() {
	m.clearedcustomer_apps = true
}

// CustomerAppsCleared reports if the "customer_apps" edge to the AppStripeCustomer entity was cleared.
func (m *AppStripeMutation) CustomerAppsCleared() bool {
	return m.clearedcustomer_apps
}

// RemoveCustomerAppIDs removes the "customer_apps" edge to the AppStripeCustomer entity by IDs.
func (m *AppStripeMutation) RemoveCustomerAppIDs(ids ...int) {
	if m.removedcustomer_apps == nil {
		m.removedcustomer_apps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_apps, ids[i])
		m.removedcustomer_apps[ids[i]] = struct{}{}
	}
}

// RemovedCustomerApps returns the removed IDs of the "customer_apps" edge to the AppStripeCustomer entity.
func (m *AppStripeMutation) RemovedCustomerAppsIDs() (ids []int) {
	for id := range m.removedcustomer_apps {
		ids = append(ids, id)
	}
	return
}

// CustomerAppsIDs returns the "customer_apps" edge IDs in the mutation.
func (m *AppStripeMutation) CustomerAppsIDs() (ids []int) {
	for id := range m.customer_apps {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerApps resets all changes to the "customer_apps" edge.
func (m *AppStripeMutation) ResetCustomerApps() {
	m.customer_apps = nil
	m.clearedcustomer_apps = false
	m.removedcustomer_apps = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *AppStripeMutation) SetAppID(id string) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppStripeMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppStripeMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *AppStripeMutation) AppID() (id string, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppStripeMutation) AppIDs() (ids []string) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppStripeMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the AppStripeMutation builder.
func (m *AppStripeMutation) Where(ps ...predicate.AppStripe) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppStripeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppStripeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppStripe, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppStripeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppStripeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppStripe).
func (m *AppStripeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppStripeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, appstripe.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, appstripe.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appstripe.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appstripe.FieldDeletedAt)
	}
	if m.stripe_account_id != nil {
		fields = append(fields, appstripe.FieldStripeAccountID)
	}
	if m.stripe_livemode != nil {
		fields = append(fields, appstripe.FieldStripeLivemode)
	}
	if m.api_key != nil {
		fields = append(fields, appstripe.FieldAPIKey)
	}
	if m.masked_api_key != nil {
		fields = append(fields, appstripe.FieldMaskedAPIKey)
	}
	if m.stripe_webhook_id != nil {
		fields = append(fields, appstripe.FieldStripeWebhookID)
	}
	if m.webhook_secret != nil {
		fields = append(fields, appstripe.FieldWebhookSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppStripeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appstripe.FieldNamespace:
		return m.Namespace()
	case appstripe.FieldCreatedAt:
		return m.CreatedAt()
	case appstripe.FieldUpdatedAt:
		return m.UpdatedAt()
	case appstripe.FieldDeletedAt:
		return m.DeletedAt()
	case appstripe.FieldStripeAccountID:
		return m.StripeAccountID()
	case appstripe.FieldStripeLivemode:
		return m.StripeLivemode()
	case appstripe.FieldAPIKey:
		return m.APIKey()
	case appstripe.FieldMaskedAPIKey:
		return m.MaskedAPIKey()
	case appstripe.FieldStripeWebhookID:
		return m.StripeWebhookID()
	case appstripe.FieldWebhookSecret:
		return m.WebhookSecret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppStripeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appstripe.FieldNamespace:
		return m.OldNamespace(ctx)
	case appstripe.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appstripe.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appstripe.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appstripe.FieldStripeAccountID:
		return m.OldStripeAccountID(ctx)
	case appstripe.FieldStripeLivemode:
		return m.OldStripeLivemode(ctx)
	case appstripe.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case appstripe.FieldMaskedAPIKey:
		return m.OldMaskedAPIKey(ctx)
	case appstripe.FieldStripeWebhookID:
		return m.OldStripeWebhookID(ctx)
	case appstripe.FieldWebhookSecret:
		return m.OldWebhookSecret(ctx)
	}
	return nil, fmt.Errorf("unknown AppStripe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStripeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appstripe.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case appstripe.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appstripe.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appstripe.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appstripe.FieldStripeAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeAccountID(v)
		return nil
	case appstripe.FieldStripeLivemode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeLivemode(v)
		return nil
	case appstripe.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case appstripe.FieldMaskedAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaskedAPIKey(v)
		return nil
	case appstripe.FieldStripeWebhookID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeWebhookID(v)
		return nil
	case appstripe.FieldWebhookSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebhookSecret(v)
		return nil
	}
	return fmt.Errorf("unknown AppStripe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppStripeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppStripeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStripeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppStripe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppStripeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appstripe.FieldDeletedAt) {
		fields = append(fields, appstripe.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppStripeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppStripeMutation) ClearField(name string) error {
	switch name {
	case appstripe.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AppStripe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppStripeMutation) ResetField(name string) error {
	switch name {
	case appstripe.FieldNamespace:
		m.ResetNamespace()
		return nil
	case appstripe.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appstripe.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appstripe.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appstripe.FieldStripeAccountID:
		m.ResetStripeAccountID()
		return nil
	case appstripe.FieldStripeLivemode:
		m.ResetStripeLivemode()
		return nil
	case appstripe.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case appstripe.FieldMaskedAPIKey:
		m.ResetMaskedAPIKey()
		return nil
	case appstripe.FieldStripeWebhookID:
		m.ResetStripeWebhookID()
		return nil
	case appstripe.FieldWebhookSecret:
		m.ResetWebhookSecret()
		return nil
	}
	return fmt.Errorf("unknown AppStripe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppStripeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.customer_apps != nil {
		edges = append(edges, appstripe.EdgeCustomerApps)
	}
	if m.app != nil {
		edges = append(edges, appstripe.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppStripeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appstripe.EdgeCustomerApps:
		ids := make([]ent.Value, 0, len(m.customer_apps))
		for id := range m.customer_apps {
			ids = append(ids, id)
		}
		return ids
	case appstripe.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppStripeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcustomer_apps != nil {
		edges = append(edges, appstripe.EdgeCustomerApps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppStripeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case appstripe.EdgeCustomerApps:
		ids := make([]ent.Value, 0, len(m.removedcustomer_apps))
		for id := range m.removedcustomer_apps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppStripeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcustomer_apps {
		edges = append(edges, appstripe.EdgeCustomerApps)
	}
	if m.clearedapp {
		edges = append(edges, appstripe.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppStripeMutation) EdgeCleared(name string) bool {
	switch name {
	case appstripe.EdgeCustomerApps:
		return m.clearedcustomer_apps
	case appstripe.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppStripeMutation) ClearEdge(name string) error {
	switch name {
	case appstripe.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppStripe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppStripeMutation) ResetEdge(name string) error {
	switch name {
	case appstripe.EdgeCustomerApps:
		m.ResetCustomerApps()
		return nil
	case appstripe.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AppStripe edge %s", name)
}

// AppStripeCustomerMutation represents an operation that mutates the AppStripeCustomer nodes in the graph.
type AppStripeCustomerMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	namespace                        *string
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	stripe_customer_id               *string
	stripe_default_payment_method_id *string
	clearedFields                    map[string]struct{}
	stripe_app                       *string
	clearedstripe_app                bool
	customer                         *string
	clearedcustomer                  bool
	done                             bool
	oldValue                         func(context.Context) (*AppStripeCustomer, error)
	predicates                       []predicate.AppStripeCustomer
}

var _ ent.Mutation = (*AppStripeCustomerMutation)(nil)

// appstripecustomerOption allows management of the mutation configuration using functional options.
type appstripecustomerOption func(*AppStripeCustomerMutation)

// newAppStripeCustomerMutation creates new mutation for the AppStripeCustomer entity.
func newAppStripeCustomerMutation(c config, op Op, opts ...appstripecustomerOption) *AppStripeCustomerMutation {
	m := &AppStripeCustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeAppStripeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppStripeCustomerID sets the ID field of the mutation.
func withAppStripeCustomerID(id int) appstripecustomerOption {
	return func(m *AppStripeCustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *AppStripeCustomer
		)
		m.oldValue = func(ctx context.Context) (*AppStripeCustomer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppStripeCustomer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppStripeCustomer sets the old AppStripeCustomer of the mutation.
func withAppStripeCustomer(node *AppStripeCustomer) appstripecustomerOption {
	return func(m *AppStripeCustomerMutation) {
		m.oldValue = func(context.Context) (*AppStripeCustomer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppStripeCustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppStripeCustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppStripeCustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppStripeCustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppStripeCustomer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *AppStripeCustomerMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AppStripeCustomerMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AppStripeCustomerMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppStripeCustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppStripeCustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppStripeCustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppStripeCustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppStripeCustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppStripeCustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppStripeCustomerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppStripeCustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppStripeCustomerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appstripecustomer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppStripeCustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appstripecustomer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppStripeCustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appstripecustomer.FieldDeletedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppStripeCustomerMutation) SetAppID(s string) {
	m.stripe_app = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppStripeCustomerMutation) AppID() (r string, exists bool) {
	v := m.stripe_app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppStripeCustomerMutation) ResetAppID() {
	m.stripe_app = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *AppStripeCustomerMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *AppStripeCustomerMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *AppStripeCustomerMutation) ResetCustomerID() {
	m.customer = nil
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *AppStripeCustomerMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *AppStripeCustomerMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldStripeCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *AppStripeCustomerMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
}

// SetStripeDefaultPaymentMethodID sets the "stripe_default_payment_method_id" field.
func (m *AppStripeCustomerMutation) SetStripeDefaultPaymentMethodID(s string) {
	m.stripe_default_payment_method_id = &s
}

// StripeDefaultPaymentMethodID returns the value of the "stripe_default_payment_method_id" field in the mutation.
func (m *AppStripeCustomerMutation) StripeDefaultPaymentMethodID() (r string, exists bool) {
	v := m.stripe_default_payment_method_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeDefaultPaymentMethodID returns the old "stripe_default_payment_method_id" field's value of the AppStripeCustomer entity.
// If the AppStripeCustomer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStripeCustomerMutation) OldStripeDefaultPaymentMethodID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeDefaultPaymentMethodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeDefaultPaymentMethodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeDefaultPaymentMethodID: %w", err)
	}
	return oldValue.StripeDefaultPaymentMethodID, nil
}

// ClearStripeDefaultPaymentMethodID clears the value of the "stripe_default_payment_method_id" field.
func (m *AppStripeCustomerMutation) ClearStripeDefaultPaymentMethodID() {
	m.stripe_default_payment_method_id = nil
	m.clearedFields[appstripecustomer.FieldStripeDefaultPaymentMethodID] = struct{}{}
}

// StripeDefaultPaymentMethodIDCleared returns if the "stripe_default_payment_method_id" field was cleared in this mutation.
func (m *AppStripeCustomerMutation) StripeDefaultPaymentMethodIDCleared() bool {
	_, ok := m.clearedFields[appstripecustomer.FieldStripeDefaultPaymentMethodID]
	return ok
}

// ResetStripeDefaultPaymentMethodID resets all changes to the "stripe_default_payment_method_id" field.
func (m *AppStripeCustomerMutation) ResetStripeDefaultPaymentMethodID() {
	m.stripe_default_payment_method_id = nil
	delete(m.clearedFields, appstripecustomer.FieldStripeDefaultPaymentMethodID)
}

// SetStripeAppID sets the "stripe_app" edge to the AppStripe entity by id.
func (m *AppStripeCustomerMutation) SetStripeAppID(id string) {
	m.stripe_app = &id
}

// ClearStripeApp clears the "stripe_app" edge to the AppStripe entity.
func (m *AppStripeCustomerMutation) ClearStripeApp() {
	m.clearedstripe_app = true
	m.clearedFields[appstripecustomer.FieldAppID] = struct{}{}
}

// StripeAppCleared reports if the "stripe_app" edge to the AppStripe entity was cleared.
func (m *AppStripeCustomerMutation) StripeAppCleared() bool {
	return m.clearedstripe_app
}

// StripeAppID returns the "stripe_app" edge ID in the mutation.
func (m *AppStripeCustomerMutation) StripeAppID() (id string, exists bool) {
	if m.stripe_app != nil {
		return *m.stripe_app, true
	}
	return
}

// StripeAppIDs returns the "stripe_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StripeAppID instead. It exists only for internal usage by the builders.
func (m *AppStripeCustomerMutation) StripeAppIDs() (ids []string) {
	if id := m.stripe_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStripeApp resets all changes to the "stripe_app" edge.
func (m *AppStripeCustomerMutation) ResetStripeApp() {
	m.stripe_app = nil
	m.clearedstripe_app = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *AppStripeCustomerMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[appstripecustomer.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *AppStripeCustomerMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *AppStripeCustomerMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *AppStripeCustomerMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the AppStripeCustomerMutation builder.
func (m *AppStripeCustomerMutation) Where(ps ...predicate.AppStripeCustomer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppStripeCustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppStripeCustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppStripeCustomer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppStripeCustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppStripeCustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppStripeCustomer).
func (m *AppStripeCustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppStripeCustomerMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, appstripecustomer.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, appstripecustomer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appstripecustomer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appstripecustomer.FieldDeletedAt)
	}
	if m.stripe_app != nil {
		fields = append(fields, appstripecustomer.FieldAppID)
	}
	if m.customer != nil {
		fields = append(fields, appstripecustomer.FieldCustomerID)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, appstripecustomer.FieldStripeCustomerID)
	}
	if m.stripe_default_payment_method_id != nil {
		fields = append(fields, appstripecustomer.FieldStripeDefaultPaymentMethodID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppStripeCustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appstripecustomer.FieldNamespace:
		return m.Namespace()
	case appstripecustomer.FieldCreatedAt:
		return m.CreatedAt()
	case appstripecustomer.FieldUpdatedAt:
		return m.UpdatedAt()
	case appstripecustomer.FieldDeletedAt:
		return m.DeletedAt()
	case appstripecustomer.FieldAppID:
		return m.AppID()
	case appstripecustomer.FieldCustomerID:
		return m.CustomerID()
	case appstripecustomer.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case appstripecustomer.FieldStripeDefaultPaymentMethodID:
		return m.StripeDefaultPaymentMethodID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppStripeCustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appstripecustomer.FieldNamespace:
		return m.OldNamespace(ctx)
	case appstripecustomer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appstripecustomer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appstripecustomer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appstripecustomer.FieldAppID:
		return m.OldAppID(ctx)
	case appstripecustomer.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case appstripecustomer.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case appstripecustomer.FieldStripeDefaultPaymentMethodID:
		return m.OldStripeDefaultPaymentMethodID(ctx)
	}
	return nil, fmt.Errorf("unknown AppStripeCustomer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStripeCustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appstripecustomer.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case appstripecustomer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appstripecustomer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appstripecustomer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appstripecustomer.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appstripecustomer.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case appstripecustomer.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case appstripecustomer.FieldStripeDefaultPaymentMethodID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeDefaultPaymentMethodID(v)
		return nil
	}
	return fmt.Errorf("unknown AppStripeCustomer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppStripeCustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppStripeCustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStripeCustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppStripeCustomer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppStripeCustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appstripecustomer.FieldDeletedAt) {
		fields = append(fields, appstripecustomer.FieldDeletedAt)
	}
	if m.FieldCleared(appstripecustomer.FieldStripeDefaultPaymentMethodID) {
		fields = append(fields, appstripecustomer.FieldStripeDefaultPaymentMethodID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppStripeCustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppStripeCustomerMutation) ClearField(name string) error {
	switch name {
	case appstripecustomer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case appstripecustomer.FieldStripeDefaultPaymentMethodID:
		m.ClearStripeDefaultPaymentMethodID()
		return nil
	}
	return fmt.Errorf("unknown AppStripeCustomer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppStripeCustomerMutation) ResetField(name string) error {
	switch name {
	case appstripecustomer.FieldNamespace:
		m.ResetNamespace()
		return nil
	case appstripecustomer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appstripecustomer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appstripecustomer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appstripecustomer.FieldAppID:
		m.ResetAppID()
		return nil
	case appstripecustomer.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case appstripecustomer.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case appstripecustomer.FieldStripeDefaultPaymentMethodID:
		m.ResetStripeDefaultPaymentMethodID()
		return nil
	}
	return fmt.Errorf("unknown AppStripeCustomer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppStripeCustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.stripe_app != nil {
		edges = append(edges, appstripecustomer.EdgeStripeApp)
	}
	if m.customer != nil {
		edges = append(edges, appstripecustomer.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppStripeCustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appstripecustomer.EdgeStripeApp:
		if id := m.stripe_app; id != nil {
			return []ent.Value{*id}
		}
	case appstripecustomer.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppStripeCustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppStripeCustomerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppStripeCustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstripe_app {
		edges = append(edges, appstripecustomer.EdgeStripeApp)
	}
	if m.clearedcustomer {
		edges = append(edges, appstripecustomer.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppStripeCustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case appstripecustomer.EdgeStripeApp:
		return m.clearedstripe_app
	case appstripecustomer.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppStripeCustomerMutation) ClearEdge(name string) error {
	switch name {
	case appstripecustomer.EdgeStripeApp:
		m.ClearStripeApp()
		return nil
	case appstripecustomer.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown AppStripeCustomer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppStripeCustomerMutation) ResetEdge(name string) error {
	switch name {
	case appstripecustomer.EdgeStripeApp:
		m.ResetStripeApp()
		return nil
	case appstripecustomer.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown AppStripeCustomer edge %s", name)
}

// BalanceSnapshotMutation represents an operation that mutates the BalanceSnapshot nodes in the graph.
type BalanceSnapshotMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	namespace          *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	grant_balances     *balance.Map
	usage              **balance.SnapshottedUsage
	balance            *float64
	addbalance         *float64
	overage            *float64
	addoverage         *float64
	at                 *time.Time
	clearedFields      map[string]struct{}
	entitlement        *string
	clearedentitlement bool
	done               bool
	oldValue           func(context.Context) (*BalanceSnapshot, error)
	predicates         []predicate.BalanceSnapshot
}

var _ ent.Mutation = (*BalanceSnapshotMutation)(nil)

// balancesnapshotOption allows management of the mutation configuration using functional options.
type balancesnapshotOption func(*BalanceSnapshotMutation)

// newBalanceSnapshotMutation creates new mutation for the BalanceSnapshot entity.
func newBalanceSnapshotMutation(c config, op Op, opts ...balancesnapshotOption) *BalanceSnapshotMutation {
	m := &BalanceSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeBalanceSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBalanceSnapshotID sets the ID field of the mutation.
func withBalanceSnapshotID(id int) balancesnapshotOption {
	return func(m *BalanceSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *BalanceSnapshot
		)
		m.oldValue = func(ctx context.Context) (*BalanceSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BalanceSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBalanceSnapshot sets the old BalanceSnapshot of the mutation.
func withBalanceSnapshot(node *BalanceSnapshot) balancesnapshotOption {
	return func(m *BalanceSnapshotMutation) {
		m.oldValue = func(context.Context) (*BalanceSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BalanceSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BalanceSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BalanceSnapshotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BalanceSnapshotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BalanceSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BalanceSnapshotMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BalanceSnapshotMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BalanceSnapshotMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BalanceSnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BalanceSnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BalanceSnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BalanceSnapshotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BalanceSnapshotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BalanceSnapshotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BalanceSnapshotMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BalanceSnapshotMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BalanceSnapshotMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[balancesnapshot.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BalanceSnapshotMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[balancesnapshot.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BalanceSnapshotMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, balancesnapshot.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *BalanceSnapshotMutation) SetOwnerID(s string) {
	m.entitlement = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *BalanceSnapshotMutation) OwnerID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *BalanceSnapshotMutation) ResetOwnerID() {
	m.entitlement = nil
}

// SetGrantBalances sets the "grant_balances" field.
func (m *BalanceSnapshotMutation) SetGrantBalances(b balance.Map) {
	m.grant_balances = &b
}

// GrantBalances returns the value of the "grant_balances" field in the mutation.
func (m *BalanceSnapshotMutation) GrantBalances() (r balance.Map, exists bool) {
	v := m.grant_balances
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantBalances returns the old "grant_balances" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldGrantBalances(ctx context.Context) (v balance.Map, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantBalances is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantBalances requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantBalances: %w", err)
	}
	return oldValue.GrantBalances, nil
}

// ResetGrantBalances resets all changes to the "grant_balances" field.
func (m *BalanceSnapshotMutation) ResetGrantBalances() {
	m.grant_balances = nil
}

// SetUsage sets the "usage" field.
func (m *BalanceSnapshotMutation) SetUsage(bu *balance.SnapshottedUsage) {
	m.usage = &bu
}

// Usage returns the value of the "usage" field in the mutation.
func (m *BalanceSnapshotMutation) Usage() (r *balance.SnapshottedUsage, exists bool) {
	v := m.usage
	if v == nil {
		return
	}
	return *v, true
}

// OldUsage returns the old "usage" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldUsage(ctx context.Context) (v *balance.SnapshottedUsage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsage: %w", err)
	}
	return oldValue.Usage, nil
}

// ClearUsage clears the value of the "usage" field.
func (m *BalanceSnapshotMutation) ClearUsage() {
	m.usage = nil
	m.clearedFields[balancesnapshot.FieldUsage] = struct{}{}
}

// UsageCleared returns if the "usage" field was cleared in this mutation.
func (m *BalanceSnapshotMutation) UsageCleared() bool {
	_, ok := m.clearedFields[balancesnapshot.FieldUsage]
	return ok
}

// ResetUsage resets all changes to the "usage" field.
func (m *BalanceSnapshotMutation) ResetUsage() {
	m.usage = nil
	delete(m.clearedFields, balancesnapshot.FieldUsage)
}

// SetBalance sets the "balance" field.
func (m *BalanceSnapshotMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *BalanceSnapshotMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *BalanceSnapshotMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *BalanceSnapshotMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *BalanceSnapshotMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetOverage sets the "overage" field.
func (m *BalanceSnapshotMutation) SetOverage(f float64) {
	m.overage = &f
	m.addoverage = nil
}

// Overage returns the value of the "overage" field in the mutation.
func (m *BalanceSnapshotMutation) Overage() (r float64, exists bool) {
	v := m.overage
	if v == nil {
		return
	}
	return *v, true
}

// OldOverage returns the old "overage" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldOverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverage: %w", err)
	}
	return oldValue.Overage, nil
}

// AddOverage adds f to the "overage" field.
func (m *BalanceSnapshotMutation) AddOverage(f float64) {
	if m.addoverage != nil {
		*m.addoverage += f
	} else {
		m.addoverage = &f
	}
}

// AddedOverage returns the value that was added to the "overage" field in this mutation.
func (m *BalanceSnapshotMutation) AddedOverage() (r float64, exists bool) {
	v := m.addoverage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverage resets all changes to the "overage" field.
func (m *BalanceSnapshotMutation) ResetOverage() {
	m.overage = nil
	m.addoverage = nil
}

// SetAt sets the "at" field.
func (m *BalanceSnapshotMutation) SetAt(t time.Time) {
	m.at = &t
}

// At returns the value of the "at" field in the mutation.
func (m *BalanceSnapshotMutation) At() (r time.Time, exists bool) {
	v := m.at
	if v == nil {
		return
	}
	return *v, true
}

// OldAt returns the old "at" field's value of the BalanceSnapshot entity.
// If the BalanceSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceSnapshotMutation) OldAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAt: %w", err)
	}
	return oldValue.At, nil
}

// ResetAt resets all changes to the "at" field.
func (m *BalanceSnapshotMutation) ResetAt() {
	m.at = nil
}

// SetEntitlementID sets the "entitlement" edge to the Entitlement entity by id.
func (m *BalanceSnapshotMutation) SetEntitlementID(id string) {
	m.entitlement = &id
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *BalanceSnapshotMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[balancesnapshot.FieldOwnerID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *BalanceSnapshotMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementID returns the "entitlement" edge ID in the mutation.
func (m *BalanceSnapshotMutation) EntitlementID() (id string, exists bool) {
	if m.entitlement != nil {
		return *m.entitlement, true
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *BalanceSnapshotMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *BalanceSnapshotMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the BalanceSnapshotMutation builder.
func (m *BalanceSnapshotMutation) Where(ps ...predicate.BalanceSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BalanceSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BalanceSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BalanceSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BalanceSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BalanceSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BalanceSnapshot).
func (m *BalanceSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BalanceSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, balancesnapshot.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, balancesnapshot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, balancesnapshot.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, balancesnapshot.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, balancesnapshot.FieldOwnerID)
	}
	if m.grant_balances != nil {
		fields = append(fields, balancesnapshot.FieldGrantBalances)
	}
	if m.usage != nil {
		fields = append(fields, balancesnapshot.FieldUsage)
	}
	if m.balance != nil {
		fields = append(fields, balancesnapshot.FieldBalance)
	}
	if m.overage != nil {
		fields = append(fields, balancesnapshot.FieldOverage)
	}
	if m.at != nil {
		fields = append(fields, balancesnapshot.FieldAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BalanceSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case balancesnapshot.FieldNamespace:
		return m.Namespace()
	case balancesnapshot.FieldCreatedAt:
		return m.CreatedAt()
	case balancesnapshot.FieldUpdatedAt:
		return m.UpdatedAt()
	case balancesnapshot.FieldDeletedAt:
		return m.DeletedAt()
	case balancesnapshot.FieldOwnerID:
		return m.OwnerID()
	case balancesnapshot.FieldGrantBalances:
		return m.GrantBalances()
	case balancesnapshot.FieldUsage:
		return m.Usage()
	case balancesnapshot.FieldBalance:
		return m.Balance()
	case balancesnapshot.FieldOverage:
		return m.Overage()
	case balancesnapshot.FieldAt:
		return m.At()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BalanceSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case balancesnapshot.FieldNamespace:
		return m.OldNamespace(ctx)
	case balancesnapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case balancesnapshot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case balancesnapshot.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case balancesnapshot.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case balancesnapshot.FieldGrantBalances:
		return m.OldGrantBalances(ctx)
	case balancesnapshot.FieldUsage:
		return m.OldUsage(ctx)
	case balancesnapshot.FieldBalance:
		return m.OldBalance(ctx)
	case balancesnapshot.FieldOverage:
		return m.OldOverage(ctx)
	case balancesnapshot.FieldAt:
		return m.OldAt(ctx)
	}
	return nil, fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case balancesnapshot.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case balancesnapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case balancesnapshot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case balancesnapshot.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case balancesnapshot.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case balancesnapshot.FieldGrantBalances:
		v, ok := value.(balance.Map)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantBalances(v)
		return nil
	case balancesnapshot.FieldUsage:
		v, ok := value.(*balance.SnapshottedUsage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsage(v)
		return nil
	case balancesnapshot.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case balancesnapshot.FieldOverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverage(v)
		return nil
	case balancesnapshot.FieldAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAt(v)
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BalanceSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, balancesnapshot.FieldBalance)
	}
	if m.addoverage != nil {
		fields = append(fields, balancesnapshot.FieldOverage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BalanceSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case balancesnapshot.FieldBalance:
		return m.AddedBalance()
	case balancesnapshot.FieldOverage:
		return m.AddedOverage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case balancesnapshot.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case balancesnapshot.FieldOverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverage(v)
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BalanceSnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(balancesnapshot.FieldDeletedAt) {
		fields = append(fields, balancesnapshot.FieldDeletedAt)
	}
	if m.FieldCleared(balancesnapshot.FieldUsage) {
		fields = append(fields, balancesnapshot.FieldUsage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BalanceSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BalanceSnapshotMutation) ClearField(name string) error {
	switch name {
	case balancesnapshot.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case balancesnapshot.FieldUsage:
		m.ClearUsage()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BalanceSnapshotMutation) ResetField(name string) error {
	switch name {
	case balancesnapshot.FieldNamespace:
		m.ResetNamespace()
		return nil
	case balancesnapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case balancesnapshot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case balancesnapshot.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case balancesnapshot.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case balancesnapshot.FieldGrantBalances:
		m.ResetGrantBalances()
		return nil
	case balancesnapshot.FieldUsage:
		m.ResetUsage()
		return nil
	case balancesnapshot.FieldBalance:
		m.ResetBalance()
		return nil
	case balancesnapshot.FieldOverage:
		m.ResetOverage()
		return nil
	case balancesnapshot.FieldAt:
		m.ResetAt()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BalanceSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, balancesnapshot.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BalanceSnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BalanceSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BalanceSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BalanceSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, balancesnapshot.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BalanceSnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BalanceSnapshotMutation) ClearEdge(name string) error {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BalanceSnapshotMutation) ResetEdge(name string) error {
	switch name {
	case balancesnapshot.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown BalanceSnapshot edge %s", name)
}

// BillingCustomerLockMutation represents an operation that mutates the BillingCustomerLock nodes in the graph.
type BillingCustomerLockMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	customer_id   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BillingCustomerLock, error)
	predicates    []predicate.BillingCustomerLock
}

var _ ent.Mutation = (*BillingCustomerLockMutation)(nil)

// billingcustomerlockOption allows management of the mutation configuration using functional options.
type billingcustomerlockOption func(*BillingCustomerLockMutation)

// newBillingCustomerLockMutation creates new mutation for the BillingCustomerLock entity.
func newBillingCustomerLockMutation(c config, op Op, opts ...billingcustomerlockOption) *BillingCustomerLockMutation {
	m := &BillingCustomerLockMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingCustomerLock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingCustomerLockID sets the ID field of the mutation.
func withBillingCustomerLockID(id string) billingcustomerlockOption {
	return func(m *BillingCustomerLockMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingCustomerLock
		)
		m.oldValue = func(ctx context.Context) (*BillingCustomerLock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingCustomerLock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingCustomerLock sets the old BillingCustomerLock of the mutation.
func withBillingCustomerLock(node *BillingCustomerLock) billingcustomerlockOption {
	return func(m *BillingCustomerLockMutation) {
		m.oldValue = func(context.Context) (*BillingCustomerLock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingCustomerLockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingCustomerLockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingCustomerLock entities.
func (m *BillingCustomerLockMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingCustomerLockMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingCustomerLockMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingCustomerLock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingCustomerLockMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingCustomerLockMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingCustomerLock entity.
// If the BillingCustomerLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerLockMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingCustomerLockMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *BillingCustomerLockMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *BillingCustomerLockMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the BillingCustomerLock entity.
// If the BillingCustomerLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerLockMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *BillingCustomerLockMutation) ResetCustomerID() {
	m.customer_id = nil
}

// Where appends a list predicates to the BillingCustomerLockMutation builder.
func (m *BillingCustomerLockMutation) Where(ps ...predicate.BillingCustomerLock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingCustomerLockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingCustomerLockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingCustomerLock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingCustomerLockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingCustomerLockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingCustomerLock).
func (m *BillingCustomerLockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingCustomerLockMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.namespace != nil {
		fields = append(fields, billingcustomerlock.FieldNamespace)
	}
	if m.customer_id != nil {
		fields = append(fields, billingcustomerlock.FieldCustomerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingCustomerLockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingcustomerlock.FieldNamespace:
		return m.Namespace()
	case billingcustomerlock.FieldCustomerID:
		return m.CustomerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingCustomerLockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingcustomerlock.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingcustomerlock.FieldCustomerID:
		return m.OldCustomerID(ctx)
	}
	return nil, fmt.Errorf("unknown BillingCustomerLock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingCustomerLockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingcustomerlock.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingcustomerlock.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerLock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingCustomerLockMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingCustomerLockMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingCustomerLockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingCustomerLock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingCustomerLockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingCustomerLockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingCustomerLockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BillingCustomerLock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingCustomerLockMutation) ResetField(name string) error {
	switch name {
	case billingcustomerlock.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingcustomerlock.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerLock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingCustomerLockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingCustomerLockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingCustomerLockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingCustomerLockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingCustomerLockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingCustomerLockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingCustomerLockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BillingCustomerLock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingCustomerLockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BillingCustomerLock edge %s", name)
}

// BillingCustomerOverrideMutation represents an operation that mutates the BillingCustomerOverride nodes in the graph.
type BillingCustomerOverrideMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	namespace                   *string
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	collection_alignment        *billing.AlignmentKind
	line_collection_period      *isodate.String
	invoice_auto_advance        *bool
	invoice_draft_period        *isodate.String
	invoice_due_after           *isodate.String
	invoice_collection_method   *billing.CollectionMethod
	invoice_progressive_billing *bool
	invoice_default_tax_config  *productcatalog.TaxConfig
	clearedFields               map[string]struct{}
	customer                    *string
	clearedcustomer             bool
	billing_profile             *string
	clearedbilling_profile      bool
	done                        bool
	oldValue                    func(context.Context) (*BillingCustomerOverride, error)
	predicates                  []predicate.BillingCustomerOverride
}

var _ ent.Mutation = (*BillingCustomerOverrideMutation)(nil)

// billingcustomeroverrideOption allows management of the mutation configuration using functional options.
type billingcustomeroverrideOption func(*BillingCustomerOverrideMutation)

// newBillingCustomerOverrideMutation creates new mutation for the BillingCustomerOverride entity.
func newBillingCustomerOverrideMutation(c config, op Op, opts ...billingcustomeroverrideOption) *BillingCustomerOverrideMutation {
	m := &BillingCustomerOverrideMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingCustomerOverride,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingCustomerOverrideID sets the ID field of the mutation.
func withBillingCustomerOverrideID(id string) billingcustomeroverrideOption {
	return func(m *BillingCustomerOverrideMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingCustomerOverride
		)
		m.oldValue = func(ctx context.Context) (*BillingCustomerOverride, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingCustomerOverride.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingCustomerOverride sets the old BillingCustomerOverride of the mutation.
func withBillingCustomerOverride(node *BillingCustomerOverride) billingcustomeroverrideOption {
	return func(m *BillingCustomerOverrideMutation) {
		m.oldValue = func(context.Context) (*BillingCustomerOverride, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingCustomerOverrideMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingCustomerOverrideMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingCustomerOverride entities.
func (m *BillingCustomerOverrideMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingCustomerOverrideMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingCustomerOverrideMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingCustomerOverride.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingCustomerOverrideMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingCustomerOverrideMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingCustomerOverrideMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingCustomerOverrideMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingCustomerOverrideMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingCustomerOverrideMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingCustomerOverrideMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingCustomerOverrideMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingCustomerOverrideMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingCustomerOverrideMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingCustomerOverrideMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingCustomerOverrideMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billingcustomeroverride.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingCustomerOverrideMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billingcustomeroverride.FieldDeletedAt)
}

// SetCustomerID sets the "customer_id" field.
func (m *BillingCustomerOverrideMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *BillingCustomerOverrideMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *BillingCustomerOverrideMutation) ResetCustomerID() {
	m.customer = nil
}

// SetBillingProfileID sets the "billing_profile_id" field.
func (m *BillingCustomerOverrideMutation) SetBillingProfileID(s string) {
	m.billing_profile = &s
}

// BillingProfileID returns the value of the "billing_profile_id" field in the mutation.
func (m *BillingCustomerOverrideMutation) BillingProfileID() (r string, exists bool) {
	v := m.billing_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingProfileID returns the old "billing_profile_id" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldBillingProfileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingProfileID: %w", err)
	}
	return oldValue.BillingProfileID, nil
}

// ClearBillingProfileID clears the value of the "billing_profile_id" field.
func (m *BillingCustomerOverrideMutation) ClearBillingProfileID() {
	m.billing_profile = nil
	m.clearedFields[billingcustomeroverride.FieldBillingProfileID] = struct{}{}
}

// BillingProfileIDCleared returns if the "billing_profile_id" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) BillingProfileIDCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldBillingProfileID]
	return ok
}

// ResetBillingProfileID resets all changes to the "billing_profile_id" field.
func (m *BillingCustomerOverrideMutation) ResetBillingProfileID() {
	m.billing_profile = nil
	delete(m.clearedFields, billingcustomeroverride.FieldBillingProfileID)
}

// SetCollectionAlignment sets the "collection_alignment" field.
func (m *BillingCustomerOverrideMutation) SetCollectionAlignment(bk billing.AlignmentKind) {
	m.collection_alignment = &bk
}

// CollectionAlignment returns the value of the "collection_alignment" field in the mutation.
func (m *BillingCustomerOverrideMutation) CollectionAlignment() (r billing.AlignmentKind, exists bool) {
	v := m.collection_alignment
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionAlignment returns the old "collection_alignment" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldCollectionAlignment(ctx context.Context) (v *billing.AlignmentKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionAlignment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionAlignment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionAlignment: %w", err)
	}
	return oldValue.CollectionAlignment, nil
}

// ClearCollectionAlignment clears the value of the "collection_alignment" field.
func (m *BillingCustomerOverrideMutation) ClearCollectionAlignment() {
	m.collection_alignment = nil
	m.clearedFields[billingcustomeroverride.FieldCollectionAlignment] = struct{}{}
}

// CollectionAlignmentCleared returns if the "collection_alignment" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) CollectionAlignmentCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldCollectionAlignment]
	return ok
}

// ResetCollectionAlignment resets all changes to the "collection_alignment" field.
func (m *BillingCustomerOverrideMutation) ResetCollectionAlignment() {
	m.collection_alignment = nil
	delete(m.clearedFields, billingcustomeroverride.FieldCollectionAlignment)
}

// SetLineCollectionPeriod sets the "line_collection_period" field.
func (m *BillingCustomerOverrideMutation) SetLineCollectionPeriod(i isodate.String) {
	m.line_collection_period = &i
}

// LineCollectionPeriod returns the value of the "line_collection_period" field in the mutation.
func (m *BillingCustomerOverrideMutation) LineCollectionPeriod() (r isodate.String, exists bool) {
	v := m.line_collection_period
	if v == nil {
		return
	}
	return *v, true
}

// OldLineCollectionPeriod returns the old "line_collection_period" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldLineCollectionPeriod(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineCollectionPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineCollectionPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineCollectionPeriod: %w", err)
	}
	return oldValue.LineCollectionPeriod, nil
}

// ClearLineCollectionPeriod clears the value of the "line_collection_period" field.
func (m *BillingCustomerOverrideMutation) ClearLineCollectionPeriod() {
	m.line_collection_period = nil
	m.clearedFields[billingcustomeroverride.FieldLineCollectionPeriod] = struct{}{}
}

// LineCollectionPeriodCleared returns if the "line_collection_period" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) LineCollectionPeriodCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldLineCollectionPeriod]
	return ok
}

// ResetLineCollectionPeriod resets all changes to the "line_collection_period" field.
func (m *BillingCustomerOverrideMutation) ResetLineCollectionPeriod() {
	m.line_collection_period = nil
	delete(m.clearedFields, billingcustomeroverride.FieldLineCollectionPeriod)
}

// SetInvoiceAutoAdvance sets the "invoice_auto_advance" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceAutoAdvance(b bool) {
	m.invoice_auto_advance = &b
}

// InvoiceAutoAdvance returns the value of the "invoice_auto_advance" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceAutoAdvance() (r bool, exists bool) {
	v := m.invoice_auto_advance
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceAutoAdvance returns the old "invoice_auto_advance" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceAutoAdvance(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceAutoAdvance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceAutoAdvance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceAutoAdvance: %w", err)
	}
	return oldValue.InvoiceAutoAdvance, nil
}

// ClearInvoiceAutoAdvance clears the value of the "invoice_auto_advance" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceAutoAdvance() {
	m.invoice_auto_advance = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceAutoAdvance] = struct{}{}
}

// InvoiceAutoAdvanceCleared returns if the "invoice_auto_advance" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceAutoAdvanceCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceAutoAdvance]
	return ok
}

// ResetInvoiceAutoAdvance resets all changes to the "invoice_auto_advance" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceAutoAdvance() {
	m.invoice_auto_advance = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceAutoAdvance)
}

// SetInvoiceDraftPeriod sets the "invoice_draft_period" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceDraftPeriod(i isodate.String) {
	m.invoice_draft_period = &i
}

// InvoiceDraftPeriod returns the value of the "invoice_draft_period" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDraftPeriod() (r isodate.String, exists bool) {
	v := m.invoice_draft_period
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDraftPeriod returns the old "invoice_draft_period" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceDraftPeriod(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDraftPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDraftPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDraftPeriod: %w", err)
	}
	return oldValue.InvoiceDraftPeriod, nil
}

// ClearInvoiceDraftPeriod clears the value of the "invoice_draft_period" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceDraftPeriod() {
	m.invoice_draft_period = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceDraftPeriod] = struct{}{}
}

// InvoiceDraftPeriodCleared returns if the "invoice_draft_period" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDraftPeriodCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceDraftPeriod]
	return ok
}

// ResetInvoiceDraftPeriod resets all changes to the "invoice_draft_period" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceDraftPeriod() {
	m.invoice_draft_period = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceDraftPeriod)
}

// SetInvoiceDueAfter sets the "invoice_due_after" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceDueAfter(i isodate.String) {
	m.invoice_due_after = &i
}

// InvoiceDueAfter returns the value of the "invoice_due_after" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDueAfter() (r isodate.String, exists bool) {
	v := m.invoice_due_after
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDueAfter returns the old "invoice_due_after" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceDueAfter(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDueAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDueAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDueAfter: %w", err)
	}
	return oldValue.InvoiceDueAfter, nil
}

// ClearInvoiceDueAfter clears the value of the "invoice_due_after" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceDueAfter() {
	m.invoice_due_after = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceDueAfter] = struct{}{}
}

// InvoiceDueAfterCleared returns if the "invoice_due_after" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDueAfterCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceDueAfter]
	return ok
}

// ResetInvoiceDueAfter resets all changes to the "invoice_due_after" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceDueAfter() {
	m.invoice_due_after = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceDueAfter)
}

// SetInvoiceCollectionMethod sets the "invoice_collection_method" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceCollectionMethod(bm billing.CollectionMethod) {
	m.invoice_collection_method = &bm
}

// InvoiceCollectionMethod returns the value of the "invoice_collection_method" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceCollectionMethod() (r billing.CollectionMethod, exists bool) {
	v := m.invoice_collection_method
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceCollectionMethod returns the old "invoice_collection_method" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceCollectionMethod(ctx context.Context) (v *billing.CollectionMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceCollectionMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceCollectionMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceCollectionMethod: %w", err)
	}
	return oldValue.InvoiceCollectionMethod, nil
}

// ClearInvoiceCollectionMethod clears the value of the "invoice_collection_method" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceCollectionMethod() {
	m.invoice_collection_method = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceCollectionMethod] = struct{}{}
}

// InvoiceCollectionMethodCleared returns if the "invoice_collection_method" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceCollectionMethodCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceCollectionMethod]
	return ok
}

// ResetInvoiceCollectionMethod resets all changes to the "invoice_collection_method" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceCollectionMethod() {
	m.invoice_collection_method = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceCollectionMethod)
}

// SetInvoiceProgressiveBilling sets the "invoice_progressive_billing" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceProgressiveBilling(b bool) {
	m.invoice_progressive_billing = &b
}

// InvoiceProgressiveBilling returns the value of the "invoice_progressive_billing" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceProgressiveBilling() (r bool, exists bool) {
	v := m.invoice_progressive_billing
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceProgressiveBilling returns the old "invoice_progressive_billing" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceProgressiveBilling(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceProgressiveBilling is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceProgressiveBilling requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceProgressiveBilling: %w", err)
	}
	return oldValue.InvoiceProgressiveBilling, nil
}

// ClearInvoiceProgressiveBilling clears the value of the "invoice_progressive_billing" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceProgressiveBilling() {
	m.invoice_progressive_billing = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceProgressiveBilling] = struct{}{}
}

// InvoiceProgressiveBillingCleared returns if the "invoice_progressive_billing" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceProgressiveBillingCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceProgressiveBilling]
	return ok
}

// ResetInvoiceProgressiveBilling resets all changes to the "invoice_progressive_billing" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceProgressiveBilling() {
	m.invoice_progressive_billing = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceProgressiveBilling)
}

// SetInvoiceDefaultTaxConfig sets the "invoice_default_tax_config" field.
func (m *BillingCustomerOverrideMutation) SetInvoiceDefaultTaxConfig(pc productcatalog.TaxConfig) {
	m.invoice_default_tax_config = &pc
}

// InvoiceDefaultTaxConfig returns the value of the "invoice_default_tax_config" field in the mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDefaultTaxConfig() (r productcatalog.TaxConfig, exists bool) {
	v := m.invoice_default_tax_config
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDefaultTaxConfig returns the old "invoice_default_tax_config" field's value of the BillingCustomerOverride entity.
// If the BillingCustomerOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingCustomerOverrideMutation) OldInvoiceDefaultTaxConfig(ctx context.Context) (v productcatalog.TaxConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDefaultTaxConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDefaultTaxConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDefaultTaxConfig: %w", err)
	}
	return oldValue.InvoiceDefaultTaxConfig, nil
}

// ClearInvoiceDefaultTaxConfig clears the value of the "invoice_default_tax_config" field.
func (m *BillingCustomerOverrideMutation) ClearInvoiceDefaultTaxConfig() {
	m.invoice_default_tax_config = nil
	m.clearedFields[billingcustomeroverride.FieldInvoiceDefaultTaxConfig] = struct{}{}
}

// InvoiceDefaultTaxConfigCleared returns if the "invoice_default_tax_config" field was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) InvoiceDefaultTaxConfigCleared() bool {
	_, ok := m.clearedFields[billingcustomeroverride.FieldInvoiceDefaultTaxConfig]
	return ok
}

// ResetInvoiceDefaultTaxConfig resets all changes to the "invoice_default_tax_config" field.
func (m *BillingCustomerOverrideMutation) ResetInvoiceDefaultTaxConfig() {
	m.invoice_default_tax_config = nil
	delete(m.clearedFields, billingcustomeroverride.FieldInvoiceDefaultTaxConfig)
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *BillingCustomerOverrideMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[billingcustomeroverride.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *BillingCustomerOverrideMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *BillingCustomerOverrideMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *BillingCustomerOverrideMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearBillingProfile clears the "billing_profile" edge to the BillingProfile entity.
func (m *BillingCustomerOverrideMutation) ClearBillingProfile() {
	m.clearedbilling_profile = true
	m.clearedFields[billingcustomeroverride.FieldBillingProfileID] = struct{}{}
}

// BillingProfileCleared reports if the "billing_profile" edge to the BillingProfile entity was cleared.
func (m *BillingCustomerOverrideMutation) BillingProfileCleared() bool {
	return m.BillingProfileIDCleared() || m.clearedbilling_profile
}

// BillingProfileIDs returns the "billing_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingProfileID instead. It exists only for internal usage by the builders.
func (m *BillingCustomerOverrideMutation) BillingProfileIDs() (ids []string) {
	if id := m.billing_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingProfile resets all changes to the "billing_profile" edge.
func (m *BillingCustomerOverrideMutation) ResetBillingProfile() {
	m.billing_profile = nil
	m.clearedbilling_profile = false
}

// Where appends a list predicates to the BillingCustomerOverrideMutation builder.
func (m *BillingCustomerOverrideMutation) Where(ps ...predicate.BillingCustomerOverride) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingCustomerOverrideMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingCustomerOverrideMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingCustomerOverride, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingCustomerOverrideMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingCustomerOverrideMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingCustomerOverride).
func (m *BillingCustomerOverrideMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingCustomerOverrideMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.namespace != nil {
		fields = append(fields, billingcustomeroverride.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billingcustomeroverride.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingcustomeroverride.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billingcustomeroverride.FieldDeletedAt)
	}
	if m.customer != nil {
		fields = append(fields, billingcustomeroverride.FieldCustomerID)
	}
	if m.billing_profile != nil {
		fields = append(fields, billingcustomeroverride.FieldBillingProfileID)
	}
	if m.collection_alignment != nil {
		fields = append(fields, billingcustomeroverride.FieldCollectionAlignment)
	}
	if m.line_collection_period != nil {
		fields = append(fields, billingcustomeroverride.FieldLineCollectionPeriod)
	}
	if m.invoice_auto_advance != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceAutoAdvance)
	}
	if m.invoice_draft_period != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDraftPeriod)
	}
	if m.invoice_due_after != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDueAfter)
	}
	if m.invoice_collection_method != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceCollectionMethod)
	}
	if m.invoice_progressive_billing != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceProgressiveBilling)
	}
	if m.invoice_default_tax_config != nil {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDefaultTaxConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingCustomerOverrideMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		return m.Namespace()
	case billingcustomeroverride.FieldCreatedAt:
		return m.CreatedAt()
	case billingcustomeroverride.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingcustomeroverride.FieldDeletedAt:
		return m.DeletedAt()
	case billingcustomeroverride.FieldCustomerID:
		return m.CustomerID()
	case billingcustomeroverride.FieldBillingProfileID:
		return m.BillingProfileID()
	case billingcustomeroverride.FieldCollectionAlignment:
		return m.CollectionAlignment()
	case billingcustomeroverride.FieldLineCollectionPeriod:
		return m.LineCollectionPeriod()
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		return m.InvoiceAutoAdvance()
	case billingcustomeroverride.FieldInvoiceDraftPeriod:
		return m.InvoiceDraftPeriod()
	case billingcustomeroverride.FieldInvoiceDueAfter:
		return m.InvoiceDueAfter()
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		return m.InvoiceCollectionMethod()
	case billingcustomeroverride.FieldInvoiceProgressiveBilling:
		return m.InvoiceProgressiveBilling()
	case billingcustomeroverride.FieldInvoiceDefaultTaxConfig:
		return m.InvoiceDefaultTaxConfig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingCustomerOverrideMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingcustomeroverride.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingcustomeroverride.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingcustomeroverride.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billingcustomeroverride.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case billingcustomeroverride.FieldBillingProfileID:
		return m.OldBillingProfileID(ctx)
	case billingcustomeroverride.FieldCollectionAlignment:
		return m.OldCollectionAlignment(ctx)
	case billingcustomeroverride.FieldLineCollectionPeriod:
		return m.OldLineCollectionPeriod(ctx)
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		return m.OldInvoiceAutoAdvance(ctx)
	case billingcustomeroverride.FieldInvoiceDraftPeriod:
		return m.OldInvoiceDraftPeriod(ctx)
	case billingcustomeroverride.FieldInvoiceDueAfter:
		return m.OldInvoiceDueAfter(ctx)
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		return m.OldInvoiceCollectionMethod(ctx)
	case billingcustomeroverride.FieldInvoiceProgressiveBilling:
		return m.OldInvoiceProgressiveBilling(ctx)
	case billingcustomeroverride.FieldInvoiceDefaultTaxConfig:
		return m.OldInvoiceDefaultTaxConfig(ctx)
	}
	return nil, fmt.Errorf("unknown BillingCustomerOverride field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingCustomerOverrideMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingcustomeroverride.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingcustomeroverride.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingcustomeroverride.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billingcustomeroverride.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case billingcustomeroverride.FieldBillingProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingProfileID(v)
		return nil
	case billingcustomeroverride.FieldCollectionAlignment:
		v, ok := value.(billing.AlignmentKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionAlignment(v)
		return nil
	case billingcustomeroverride.FieldLineCollectionPeriod:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineCollectionPeriod(v)
		return nil
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceAutoAdvance(v)
		return nil
	case billingcustomeroverride.FieldInvoiceDraftPeriod:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDraftPeriod(v)
		return nil
	case billingcustomeroverride.FieldInvoiceDueAfter:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDueAfter(v)
		return nil
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		v, ok := value.(billing.CollectionMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceCollectionMethod(v)
		return nil
	case billingcustomeroverride.FieldInvoiceProgressiveBilling:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceProgressiveBilling(v)
		return nil
	case billingcustomeroverride.FieldInvoiceDefaultTaxConfig:
		v, ok := value.(productcatalog.TaxConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDefaultTaxConfig(v)
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingCustomerOverrideMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingCustomerOverrideMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingCustomerOverrideMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingCustomerOverride numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingCustomerOverrideMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billingcustomeroverride.FieldDeletedAt) {
		fields = append(fields, billingcustomeroverride.FieldDeletedAt)
	}
	if m.FieldCleared(billingcustomeroverride.FieldBillingProfileID) {
		fields = append(fields, billingcustomeroverride.FieldBillingProfileID)
	}
	if m.FieldCleared(billingcustomeroverride.FieldCollectionAlignment) {
		fields = append(fields, billingcustomeroverride.FieldCollectionAlignment)
	}
	if m.FieldCleared(billingcustomeroverride.FieldLineCollectionPeriod) {
		fields = append(fields, billingcustomeroverride.FieldLineCollectionPeriod)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceAutoAdvance) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceAutoAdvance)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceDraftPeriod) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDraftPeriod)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceDueAfter) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDueAfter)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceCollectionMethod) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceCollectionMethod)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceProgressiveBilling) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceProgressiveBilling)
	}
	if m.FieldCleared(billingcustomeroverride.FieldInvoiceDefaultTaxConfig) {
		fields = append(fields, billingcustomeroverride.FieldInvoiceDefaultTaxConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingCustomerOverrideMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ClearField(name string) error {
	switch name {
	case billingcustomeroverride.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billingcustomeroverride.FieldBillingProfileID:
		m.ClearBillingProfileID()
		return nil
	case billingcustomeroverride.FieldCollectionAlignment:
		m.ClearCollectionAlignment()
		return nil
	case billingcustomeroverride.FieldLineCollectionPeriod:
		m.ClearLineCollectionPeriod()
		return nil
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		m.ClearInvoiceAutoAdvance()
		return nil
	case billingcustomeroverride.FieldInvoiceDraftPeriod:
		m.ClearInvoiceDraftPeriod()
		return nil
	case billingcustomeroverride.FieldInvoiceDueAfter:
		m.ClearInvoiceDueAfter()
		return nil
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		m.ClearInvoiceCollectionMethod()
		return nil
	case billingcustomeroverride.FieldInvoiceProgressiveBilling:
		m.ClearInvoiceProgressiveBilling()
		return nil
	case billingcustomeroverride.FieldInvoiceDefaultTaxConfig:
		m.ClearInvoiceDefaultTaxConfig()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ResetField(name string) error {
	switch name {
	case billingcustomeroverride.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingcustomeroverride.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingcustomeroverride.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingcustomeroverride.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billingcustomeroverride.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case billingcustomeroverride.FieldBillingProfileID:
		m.ResetBillingProfileID()
		return nil
	case billingcustomeroverride.FieldCollectionAlignment:
		m.ResetCollectionAlignment()
		return nil
	case billingcustomeroverride.FieldLineCollectionPeriod:
		m.ResetLineCollectionPeriod()
		return nil
	case billingcustomeroverride.FieldInvoiceAutoAdvance:
		m.ResetInvoiceAutoAdvance()
		return nil
	case billingcustomeroverride.FieldInvoiceDraftPeriod:
		m.ResetInvoiceDraftPeriod()
		return nil
	case billingcustomeroverride.FieldInvoiceDueAfter:
		m.ResetInvoiceDueAfter()
		return nil
	case billingcustomeroverride.FieldInvoiceCollectionMethod:
		m.ResetInvoiceCollectionMethod()
		return nil
	case billingcustomeroverride.FieldInvoiceProgressiveBilling:
		m.ResetInvoiceProgressiveBilling()
		return nil
	case billingcustomeroverride.FieldInvoiceDefaultTaxConfig:
		m.ResetInvoiceDefaultTaxConfig()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingCustomerOverrideMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.customer != nil {
		edges = append(edges, billingcustomeroverride.EdgeCustomer)
	}
	if m.billing_profile != nil {
		edges = append(edges, billingcustomeroverride.EdgeBillingProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingCustomerOverrideMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case billingcustomeroverride.EdgeBillingProfile:
		if id := m.billing_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingCustomerOverrideMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingCustomerOverrideMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingCustomerOverrideMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcustomer {
		edges = append(edges, billingcustomeroverride.EdgeCustomer)
	}
	if m.clearedbilling_profile {
		edges = append(edges, billingcustomeroverride.EdgeBillingProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingCustomerOverrideMutation) EdgeCleared(name string) bool {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		return m.clearedcustomer
	case billingcustomeroverride.EdgeBillingProfile:
		return m.clearedbilling_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ClearEdge(name string) error {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case billingcustomeroverride.EdgeBillingProfile:
		m.ClearBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingCustomerOverrideMutation) ResetEdge(name string) error {
	switch name {
	case billingcustomeroverride.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case billingcustomeroverride.EdgeBillingProfile:
		m.ResetBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingCustomerOverride edge %s", name)
}

// BillingInvoiceMutation represents an operation that mutates the BillingInvoice nodes in the graph.
type BillingInvoiceMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *string
	namespace                                *string
	metadata                                 *map[string]string
	created_at                               *time.Time
	updated_at                               *time.Time
	deleted_at                               *time.Time
	supplier_address_country                 *models.CountryCode
	supplier_address_postal_code             *string
	supplier_address_state                   *string
	supplier_address_city                    *string
	supplier_address_line1                   *string
	supplier_address_line2                   *string
	supplier_address_phone_number            *string
	customer_address_country                 *models.CountryCode
	customer_address_postal_code             *string
	customer_address_state                   *string
	customer_address_city                    *string
	customer_address_line1                   *string
	customer_address_line2                   *string
	customer_address_phone_number            *string
	amount                                   *alpacadecimal.Decimal
	taxes_total                              *alpacadecimal.Decimal
	taxes_inclusive_total                    *alpacadecimal.Decimal
	taxes_exclusive_total                    *alpacadecimal.Decimal
	charges_total                            *alpacadecimal.Decimal
	discounts_total                          *alpacadecimal.Decimal
	total                                    *alpacadecimal.Decimal
	supplier_name                            *string
	supplier_tax_code                        *string
	customer_name                            *string
	customer_usage_attribution               **billing.VersionedCustomerUsageAttribution
	number                                   *string
	_type                                    *billing.InvoiceType
	description                              *string
	voided_at                                *time.Time
	issued_at                                *time.Time
	sent_to_customer_at                      *time.Time
	draft_until                              *time.Time
	quantity_snapshoted_at                   *time.Time
	currency                                 *currencyx.Code
	due_at                                   *time.Time
	status                                   *billing.InvoiceStatus
	status_details_cache                     *billing.InvoiceStatusDetails
	invoicing_app_external_id                *string
	payment_app_external_id                  *string
	tax_app_external_id                      *string
	period_start                             *time.Time
	period_end                               *time.Time
	collection_at                            *time.Time
	clearedFields                            map[string]struct{}
	source_billing_profile                   *string
	clearedsource_billing_profile            bool
	billing_workflow_config                  *string
	clearedbilling_workflow_config           bool
	billing_invoice_lines                    map[string]struct{}
	removedbilling_invoice_lines             map[string]struct{}
	clearedbilling_invoice_lines             bool
	billing_invoice_validation_issues        map[string]struct{}
	removedbilling_invoice_validation_issues map[string]struct{}
	clearedbilling_invoice_validation_issues bool
	billing_invoice_customer                 *string
	clearedbilling_invoice_customer          bool
	tax_app                                  *string
	clearedtax_app                           bool
	invoicing_app                            *string
	clearedinvoicing_app                     bool
	payment_app                              *string
	clearedpayment_app                       bool
	done                                     bool
	oldValue                                 func(context.Context) (*BillingInvoice, error)
	predicates                               []predicate.BillingInvoice
}

var _ ent.Mutation = (*BillingInvoiceMutation)(nil)

// billinginvoiceOption allows management of the mutation configuration using functional options.
type billinginvoiceOption func(*BillingInvoiceMutation)

// newBillingInvoiceMutation creates new mutation for the BillingInvoice entity.
func newBillingInvoiceMutation(c config, op Op, opts ...billinginvoiceOption) *BillingInvoiceMutation {
	m := &BillingInvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceID sets the ID field of the mutation.
func withBillingInvoiceID(id string) billinginvoiceOption {
	return func(m *BillingInvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoice
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoice sets the old BillingInvoice of the mutation.
func withBillingInvoice(node *BillingInvoice) billinginvoiceOption {
	return func(m *BillingInvoiceMutation) {
		m.oldValue = func(context.Context) (*BillingInvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoice entities.
func (m *BillingInvoiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *BillingInvoiceMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *BillingInvoiceMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *BillingInvoiceMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[billinginvoice.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *BillingInvoiceMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *BillingInvoiceMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, billinginvoice.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingInvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingInvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingInvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingInvoiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingInvoiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingInvoiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingInvoiceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingInvoiceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingInvoiceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billinginvoice.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingInvoiceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billinginvoice.FieldDeletedAt)
}

// SetSupplierAddressCountry sets the "supplier_address_country" field.
func (m *BillingInvoiceMutation) SetSupplierAddressCountry(mc models.CountryCode) {
	m.supplier_address_country = &mc
}

// SupplierAddressCountry returns the value of the "supplier_address_country" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressCountry() (r models.CountryCode, exists bool) {
	v := m.supplier_address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressCountry returns the old "supplier_address_country" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressCountry(ctx context.Context) (v *models.CountryCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressCountry: %w", err)
	}
	return oldValue.SupplierAddressCountry, nil
}

// ClearSupplierAddressCountry clears the value of the "supplier_address_country" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressCountry() {
	m.supplier_address_country = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressCountry] = struct{}{}
}

// SupplierAddressCountryCleared returns if the "supplier_address_country" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressCountryCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressCountry]
	return ok
}

// ResetSupplierAddressCountry resets all changes to the "supplier_address_country" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressCountry() {
	m.supplier_address_country = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressCountry)
}

// SetSupplierAddressPostalCode sets the "supplier_address_postal_code" field.
func (m *BillingInvoiceMutation) SetSupplierAddressPostalCode(s string) {
	m.supplier_address_postal_code = &s
}

// SupplierAddressPostalCode returns the value of the "supplier_address_postal_code" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressPostalCode() (r string, exists bool) {
	v := m.supplier_address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressPostalCode returns the old "supplier_address_postal_code" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressPostalCode: %w", err)
	}
	return oldValue.SupplierAddressPostalCode, nil
}

// ClearSupplierAddressPostalCode clears the value of the "supplier_address_postal_code" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressPostalCode() {
	m.supplier_address_postal_code = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressPostalCode] = struct{}{}
}

// SupplierAddressPostalCodeCleared returns if the "supplier_address_postal_code" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressPostalCode]
	return ok
}

// ResetSupplierAddressPostalCode resets all changes to the "supplier_address_postal_code" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressPostalCode() {
	m.supplier_address_postal_code = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressPostalCode)
}

// SetSupplierAddressState sets the "supplier_address_state" field.
func (m *BillingInvoiceMutation) SetSupplierAddressState(s string) {
	m.supplier_address_state = &s
}

// SupplierAddressState returns the value of the "supplier_address_state" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressState() (r string, exists bool) {
	v := m.supplier_address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressState returns the old "supplier_address_state" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressState: %w", err)
	}
	return oldValue.SupplierAddressState, nil
}

// ClearSupplierAddressState clears the value of the "supplier_address_state" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressState() {
	m.supplier_address_state = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressState] = struct{}{}
}

// SupplierAddressStateCleared returns if the "supplier_address_state" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressStateCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressState]
	return ok
}

// ResetSupplierAddressState resets all changes to the "supplier_address_state" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressState() {
	m.supplier_address_state = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressState)
}

// SetSupplierAddressCity sets the "supplier_address_city" field.
func (m *BillingInvoiceMutation) SetSupplierAddressCity(s string) {
	m.supplier_address_city = &s
}

// SupplierAddressCity returns the value of the "supplier_address_city" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressCity() (r string, exists bool) {
	v := m.supplier_address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressCity returns the old "supplier_address_city" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressCity: %w", err)
	}
	return oldValue.SupplierAddressCity, nil
}

// ClearSupplierAddressCity clears the value of the "supplier_address_city" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressCity() {
	m.supplier_address_city = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressCity] = struct{}{}
}

// SupplierAddressCityCleared returns if the "supplier_address_city" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressCityCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressCity]
	return ok
}

// ResetSupplierAddressCity resets all changes to the "supplier_address_city" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressCity() {
	m.supplier_address_city = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressCity)
}

// SetSupplierAddressLine1 sets the "supplier_address_line1" field.
func (m *BillingInvoiceMutation) SetSupplierAddressLine1(s string) {
	m.supplier_address_line1 = &s
}

// SupplierAddressLine1 returns the value of the "supplier_address_line1" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressLine1() (r string, exists bool) {
	v := m.supplier_address_line1
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressLine1 returns the old "supplier_address_line1" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressLine1: %w", err)
	}
	return oldValue.SupplierAddressLine1, nil
}

// ClearSupplierAddressLine1 clears the value of the "supplier_address_line1" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressLine1() {
	m.supplier_address_line1 = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressLine1] = struct{}{}
}

// SupplierAddressLine1Cleared returns if the "supplier_address_line1" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressLine1Cleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressLine1]
	return ok
}

// ResetSupplierAddressLine1 resets all changes to the "supplier_address_line1" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressLine1() {
	m.supplier_address_line1 = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressLine1)
}

// SetSupplierAddressLine2 sets the "supplier_address_line2" field.
func (m *BillingInvoiceMutation) SetSupplierAddressLine2(s string) {
	m.supplier_address_line2 = &s
}

// SupplierAddressLine2 returns the value of the "supplier_address_line2" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressLine2() (r string, exists bool) {
	v := m.supplier_address_line2
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressLine2 returns the old "supplier_address_line2" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressLine2: %w", err)
	}
	return oldValue.SupplierAddressLine2, nil
}

// ClearSupplierAddressLine2 clears the value of the "supplier_address_line2" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressLine2() {
	m.supplier_address_line2 = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressLine2] = struct{}{}
}

// SupplierAddressLine2Cleared returns if the "supplier_address_line2" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressLine2Cleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressLine2]
	return ok
}

// ResetSupplierAddressLine2 resets all changes to the "supplier_address_line2" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressLine2() {
	m.supplier_address_line2 = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressLine2)
}

// SetSupplierAddressPhoneNumber sets the "supplier_address_phone_number" field.
func (m *BillingInvoiceMutation) SetSupplierAddressPhoneNumber(s string) {
	m.supplier_address_phone_number = &s
}

// SupplierAddressPhoneNumber returns the value of the "supplier_address_phone_number" field in the mutation.
func (m *BillingInvoiceMutation) SupplierAddressPhoneNumber() (r string, exists bool) {
	v := m.supplier_address_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressPhoneNumber returns the old "supplier_address_phone_number" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierAddressPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressPhoneNumber: %w", err)
	}
	return oldValue.SupplierAddressPhoneNumber, nil
}

// ClearSupplierAddressPhoneNumber clears the value of the "supplier_address_phone_number" field.
func (m *BillingInvoiceMutation) ClearSupplierAddressPhoneNumber() {
	m.supplier_address_phone_number = nil
	m.clearedFields[billinginvoice.FieldSupplierAddressPhoneNumber] = struct{}{}
}

// SupplierAddressPhoneNumberCleared returns if the "supplier_address_phone_number" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierAddressPhoneNumberCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierAddressPhoneNumber]
	return ok
}

// ResetSupplierAddressPhoneNumber resets all changes to the "supplier_address_phone_number" field.
func (m *BillingInvoiceMutation) ResetSupplierAddressPhoneNumber() {
	m.supplier_address_phone_number = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierAddressPhoneNumber)
}

// SetCustomerAddressCountry sets the "customer_address_country" field.
func (m *BillingInvoiceMutation) SetCustomerAddressCountry(mc models.CountryCode) {
	m.customer_address_country = &mc
}

// CustomerAddressCountry returns the value of the "customer_address_country" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressCountry() (r models.CountryCode, exists bool) {
	v := m.customer_address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressCountry returns the old "customer_address_country" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressCountry(ctx context.Context) (v *models.CountryCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressCountry: %w", err)
	}
	return oldValue.CustomerAddressCountry, nil
}

// ClearCustomerAddressCountry clears the value of the "customer_address_country" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressCountry() {
	m.customer_address_country = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressCountry] = struct{}{}
}

// CustomerAddressCountryCleared returns if the "customer_address_country" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressCountryCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressCountry]
	return ok
}

// ResetCustomerAddressCountry resets all changes to the "customer_address_country" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressCountry() {
	m.customer_address_country = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressCountry)
}

// SetCustomerAddressPostalCode sets the "customer_address_postal_code" field.
func (m *BillingInvoiceMutation) SetCustomerAddressPostalCode(s string) {
	m.customer_address_postal_code = &s
}

// CustomerAddressPostalCode returns the value of the "customer_address_postal_code" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressPostalCode() (r string, exists bool) {
	v := m.customer_address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressPostalCode returns the old "customer_address_postal_code" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressPostalCode: %w", err)
	}
	return oldValue.CustomerAddressPostalCode, nil
}

// ClearCustomerAddressPostalCode clears the value of the "customer_address_postal_code" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressPostalCode() {
	m.customer_address_postal_code = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressPostalCode] = struct{}{}
}

// CustomerAddressPostalCodeCleared returns if the "customer_address_postal_code" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressPostalCode]
	return ok
}

// ResetCustomerAddressPostalCode resets all changes to the "customer_address_postal_code" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressPostalCode() {
	m.customer_address_postal_code = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressPostalCode)
}

// SetCustomerAddressState sets the "customer_address_state" field.
func (m *BillingInvoiceMutation) SetCustomerAddressState(s string) {
	m.customer_address_state = &s
}

// CustomerAddressState returns the value of the "customer_address_state" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressState() (r string, exists bool) {
	v := m.customer_address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressState returns the old "customer_address_state" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressState: %w", err)
	}
	return oldValue.CustomerAddressState, nil
}

// ClearCustomerAddressState clears the value of the "customer_address_state" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressState() {
	m.customer_address_state = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressState] = struct{}{}
}

// CustomerAddressStateCleared returns if the "customer_address_state" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressStateCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressState]
	return ok
}

// ResetCustomerAddressState resets all changes to the "customer_address_state" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressState() {
	m.customer_address_state = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressState)
}

// SetCustomerAddressCity sets the "customer_address_city" field.
func (m *BillingInvoiceMutation) SetCustomerAddressCity(s string) {
	m.customer_address_city = &s
}

// CustomerAddressCity returns the value of the "customer_address_city" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressCity() (r string, exists bool) {
	v := m.customer_address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressCity returns the old "customer_address_city" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressCity: %w", err)
	}
	return oldValue.CustomerAddressCity, nil
}

// ClearCustomerAddressCity clears the value of the "customer_address_city" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressCity() {
	m.customer_address_city = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressCity] = struct{}{}
}

// CustomerAddressCityCleared returns if the "customer_address_city" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressCityCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressCity]
	return ok
}

// ResetCustomerAddressCity resets all changes to the "customer_address_city" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressCity() {
	m.customer_address_city = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressCity)
}

// SetCustomerAddressLine1 sets the "customer_address_line1" field.
func (m *BillingInvoiceMutation) SetCustomerAddressLine1(s string) {
	m.customer_address_line1 = &s
}

// CustomerAddressLine1 returns the value of the "customer_address_line1" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressLine1() (r string, exists bool) {
	v := m.customer_address_line1
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressLine1 returns the old "customer_address_line1" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressLine1: %w", err)
	}
	return oldValue.CustomerAddressLine1, nil
}

// ClearCustomerAddressLine1 clears the value of the "customer_address_line1" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressLine1() {
	m.customer_address_line1 = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressLine1] = struct{}{}
}

// CustomerAddressLine1Cleared returns if the "customer_address_line1" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressLine1Cleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressLine1]
	return ok
}

// ResetCustomerAddressLine1 resets all changes to the "customer_address_line1" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressLine1() {
	m.customer_address_line1 = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressLine1)
}

// SetCustomerAddressLine2 sets the "customer_address_line2" field.
func (m *BillingInvoiceMutation) SetCustomerAddressLine2(s string) {
	m.customer_address_line2 = &s
}

// CustomerAddressLine2 returns the value of the "customer_address_line2" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressLine2() (r string, exists bool) {
	v := m.customer_address_line2
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressLine2 returns the old "customer_address_line2" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressLine2: %w", err)
	}
	return oldValue.CustomerAddressLine2, nil
}

// ClearCustomerAddressLine2 clears the value of the "customer_address_line2" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressLine2() {
	m.customer_address_line2 = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressLine2] = struct{}{}
}

// CustomerAddressLine2Cleared returns if the "customer_address_line2" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressLine2Cleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressLine2]
	return ok
}

// ResetCustomerAddressLine2 resets all changes to the "customer_address_line2" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressLine2() {
	m.customer_address_line2 = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressLine2)
}

// SetCustomerAddressPhoneNumber sets the "customer_address_phone_number" field.
func (m *BillingInvoiceMutation) SetCustomerAddressPhoneNumber(s string) {
	m.customer_address_phone_number = &s
}

// CustomerAddressPhoneNumber returns the value of the "customer_address_phone_number" field in the mutation.
func (m *BillingInvoiceMutation) CustomerAddressPhoneNumber() (r string, exists bool) {
	v := m.customer_address_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerAddressPhoneNumber returns the old "customer_address_phone_number" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerAddressPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerAddressPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerAddressPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerAddressPhoneNumber: %w", err)
	}
	return oldValue.CustomerAddressPhoneNumber, nil
}

// ClearCustomerAddressPhoneNumber clears the value of the "customer_address_phone_number" field.
func (m *BillingInvoiceMutation) ClearCustomerAddressPhoneNumber() {
	m.customer_address_phone_number = nil
	m.clearedFields[billinginvoice.FieldCustomerAddressPhoneNumber] = struct{}{}
}

// CustomerAddressPhoneNumberCleared returns if the "customer_address_phone_number" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CustomerAddressPhoneNumberCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCustomerAddressPhoneNumber]
	return ok
}

// ResetCustomerAddressPhoneNumber resets all changes to the "customer_address_phone_number" field.
func (m *BillingInvoiceMutation) ResetCustomerAddressPhoneNumber() {
	m.customer_address_phone_number = nil
	delete(m.clearedFields, billinginvoice.FieldCustomerAddressPhoneNumber)
}

// SetAmount sets the "amount" field.
func (m *BillingInvoiceMutation) SetAmount(a alpacadecimal.Decimal) {
	m.amount = &a
}

// Amount returns the value of the "amount" field in the mutation.
func (m *BillingInvoiceMutation) Amount() (r alpacadecimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldAmount(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *BillingInvoiceMutation) ResetAmount() {
	m.amount = nil
}

// SetTaxesTotal sets the "taxes_total" field.
func (m *BillingInvoiceMutation) SetTaxesTotal(a alpacadecimal.Decimal) {
	m.taxes_total = &a
}

// TaxesTotal returns the value of the "taxes_total" field in the mutation.
func (m *BillingInvoiceMutation) TaxesTotal() (r alpacadecimal.Decimal, exists bool) {
	v := m.taxes_total
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxesTotal returns the old "taxes_total" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldTaxesTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxesTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxesTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxesTotal: %w", err)
	}
	return oldValue.TaxesTotal, nil
}

// ResetTaxesTotal resets all changes to the "taxes_total" field.
func (m *BillingInvoiceMutation) ResetTaxesTotal() {
	m.taxes_total = nil
}

// SetTaxesInclusiveTotal sets the "taxes_inclusive_total" field.
func (m *BillingInvoiceMutation) SetTaxesInclusiveTotal(a alpacadecimal.Decimal) {
	m.taxes_inclusive_total = &a
}

// TaxesInclusiveTotal returns the value of the "taxes_inclusive_total" field in the mutation.
func (m *BillingInvoiceMutation) TaxesInclusiveTotal() (r alpacadecimal.Decimal, exists bool) {
	v := m.taxes_inclusive_total
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxesInclusiveTotal returns the old "taxes_inclusive_total" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldTaxesInclusiveTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxesInclusiveTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxesInclusiveTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxesInclusiveTotal: %w", err)
	}
	return oldValue.TaxesInclusiveTotal, nil
}

// ResetTaxesInclusiveTotal resets all changes to the "taxes_inclusive_total" field.
func (m *BillingInvoiceMutation) ResetTaxesInclusiveTotal() {
	m.taxes_inclusive_total = nil
}

// SetTaxesExclusiveTotal sets the "taxes_exclusive_total" field.
func (m *BillingInvoiceMutation) SetTaxesExclusiveTotal(a alpacadecimal.Decimal) {
	m.taxes_exclusive_total = &a
}

// TaxesExclusiveTotal returns the value of the "taxes_exclusive_total" field in the mutation.
func (m *BillingInvoiceMutation) TaxesExclusiveTotal() (r alpacadecimal.Decimal, exists bool) {
	v := m.taxes_exclusive_total
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxesExclusiveTotal returns the old "taxes_exclusive_total" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldTaxesExclusiveTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxesExclusiveTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxesExclusiveTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxesExclusiveTotal: %w", err)
	}
	return oldValue.TaxesExclusiveTotal, nil
}

// ResetTaxesExclusiveTotal resets all changes to the "taxes_exclusive_total" field.
func (m *BillingInvoiceMutation) ResetTaxesExclusiveTotal() {
	m.taxes_exclusive_total = nil
}

// SetChargesTotal sets the "charges_total" field.
func (m *BillingInvoiceMutation) SetChargesTotal(a alpacadecimal.Decimal) {
	m.charges_total = &a
}

// ChargesTotal returns the value of the "charges_total" field in the mutation.
func (m *BillingInvoiceMutation) ChargesTotal() (r alpacadecimal.Decimal, exists bool) {
	v := m.charges_total
	if v == nil {
		return
	}
	return *v, true
}

// OldChargesTotal returns the old "charges_total" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldChargesTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargesTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargesTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargesTotal: %w", err)
	}
	return oldValue.ChargesTotal, nil
}

// ResetChargesTotal resets all changes to the "charges_total" field.
func (m *BillingInvoiceMutation) ResetChargesTotal() {
	m.charges_total = nil
}

// SetDiscountsTotal sets the "discounts_total" field.
func (m *BillingInvoiceMutation) SetDiscountsTotal(a alpacadecimal.Decimal) {
	m.discounts_total = &a
}

// DiscountsTotal returns the value of the "discounts_total" field in the mutation.
func (m *BillingInvoiceMutation) DiscountsTotal() (r alpacadecimal.Decimal, exists bool) {
	v := m.discounts_total
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountsTotal returns the old "discounts_total" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDiscountsTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountsTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountsTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountsTotal: %w", err)
	}
	return oldValue.DiscountsTotal, nil
}

// ResetDiscountsTotal resets all changes to the "discounts_total" field.
func (m *BillingInvoiceMutation) ResetDiscountsTotal() {
	m.discounts_total = nil
}

// SetTotal sets the "total" field.
func (m *BillingInvoiceMutation) SetTotal(a alpacadecimal.Decimal) {
	m.total = &a
}

// Total returns the value of the "total" field in the mutation.
func (m *BillingInvoiceMutation) Total() (r alpacadecimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// ResetTotal resets all changes to the "total" field.
func (m *BillingInvoiceMutation) ResetTotal() {
	m.total = nil
}

// SetSupplierName sets the "supplier_name" field.
func (m *BillingInvoiceMutation) SetSupplierName(s string) {
	m.supplier_name = &s
}

// SupplierName returns the value of the "supplier_name" field in the mutation.
func (m *BillingInvoiceMutation) SupplierName() (r string, exists bool) {
	v := m.supplier_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierName returns the old "supplier_name" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierName: %w", err)
	}
	return oldValue.SupplierName, nil
}

// ResetSupplierName resets all changes to the "supplier_name" field.
func (m *BillingInvoiceMutation) ResetSupplierName() {
	m.supplier_name = nil
}

// SetSupplierTaxCode sets the "supplier_tax_code" field.
func (m *BillingInvoiceMutation) SetSupplierTaxCode(s string) {
	m.supplier_tax_code = &s
}

// SupplierTaxCode returns the value of the "supplier_tax_code" field in the mutation.
func (m *BillingInvoiceMutation) SupplierTaxCode() (r string, exists bool) {
	v := m.supplier_tax_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierTaxCode returns the old "supplier_tax_code" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSupplierTaxCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierTaxCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierTaxCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierTaxCode: %w", err)
	}
	return oldValue.SupplierTaxCode, nil
}

// ClearSupplierTaxCode clears the value of the "supplier_tax_code" field.
func (m *BillingInvoiceMutation) ClearSupplierTaxCode() {
	m.supplier_tax_code = nil
	m.clearedFields[billinginvoice.FieldSupplierTaxCode] = struct{}{}
}

// SupplierTaxCodeCleared returns if the "supplier_tax_code" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SupplierTaxCodeCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSupplierTaxCode]
	return ok
}

// ResetSupplierTaxCode resets all changes to the "supplier_tax_code" field.
func (m *BillingInvoiceMutation) ResetSupplierTaxCode() {
	m.supplier_tax_code = nil
	delete(m.clearedFields, billinginvoice.FieldSupplierTaxCode)
}

// SetCustomerName sets the "customer_name" field.
func (m *BillingInvoiceMutation) SetCustomerName(s string) {
	m.customer_name = &s
}

// CustomerName returns the value of the "customer_name" field in the mutation.
func (m *BillingInvoiceMutation) CustomerName() (r string, exists bool) {
	v := m.customer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerName returns the old "customer_name" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerName: %w", err)
	}
	return oldValue.CustomerName, nil
}

// ResetCustomerName resets all changes to the "customer_name" field.
func (m *BillingInvoiceMutation) ResetCustomerName() {
	m.customer_name = nil
}

// SetCustomerUsageAttribution sets the "customer_usage_attribution" field.
func (m *BillingInvoiceMutation) SetCustomerUsageAttribution(bcua *billing.VersionedCustomerUsageAttribution) {
	m.customer_usage_attribution = &bcua
}

// CustomerUsageAttribution returns the value of the "customer_usage_attribution" field in the mutation.
func (m *BillingInvoiceMutation) CustomerUsageAttribution() (r *billing.VersionedCustomerUsageAttribution, exists bool) {
	v := m.customer_usage_attribution
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerUsageAttribution returns the old "customer_usage_attribution" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerUsageAttribution(ctx context.Context) (v *billing.VersionedCustomerUsageAttribution, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerUsageAttribution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerUsageAttribution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerUsageAttribution: %w", err)
	}
	return oldValue.CustomerUsageAttribution, nil
}

// ResetCustomerUsageAttribution resets all changes to the "customer_usage_attribution" field.
func (m *BillingInvoiceMutation) ResetCustomerUsageAttribution() {
	m.customer_usage_attribution = nil
}

// SetNumber sets the "number" field.
func (m *BillingInvoiceMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *BillingInvoiceMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *BillingInvoiceMutation) ResetNumber() {
	m.number = nil
}

// SetType sets the "type" field.
func (m *BillingInvoiceMutation) SetType(bt billing.InvoiceType) {
	m._type = &bt
}

// GetType returns the value of the "type" field in the mutation.
func (m *BillingInvoiceMutation) GetType() (r billing.InvoiceType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldType(ctx context.Context) (v billing.InvoiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BillingInvoiceMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *BillingInvoiceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BillingInvoiceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BillingInvoiceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[billinginvoice.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BillingInvoiceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BillingInvoiceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, billinginvoice.FieldDescription)
}

// SetCustomerID sets the "customer_id" field.
func (m *BillingInvoiceMutation) SetCustomerID(s string) {
	m.billing_invoice_customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *BillingInvoiceMutation) CustomerID() (r string, exists bool) {
	v := m.billing_invoice_customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *BillingInvoiceMutation) ResetCustomerID() {
	m.billing_invoice_customer = nil
}

// SetSourceBillingProfileID sets the "source_billing_profile_id" field.
func (m *BillingInvoiceMutation) SetSourceBillingProfileID(s string) {
	m.source_billing_profile = &s
}

// SourceBillingProfileID returns the value of the "source_billing_profile_id" field in the mutation.
func (m *BillingInvoiceMutation) SourceBillingProfileID() (r string, exists bool) {
	v := m.source_billing_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceBillingProfileID returns the old "source_billing_profile_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSourceBillingProfileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceBillingProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceBillingProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceBillingProfileID: %w", err)
	}
	return oldValue.SourceBillingProfileID, nil
}

// ResetSourceBillingProfileID resets all changes to the "source_billing_profile_id" field.
func (m *BillingInvoiceMutation) ResetSourceBillingProfileID() {
	m.source_billing_profile = nil
}

// SetVoidedAt sets the "voided_at" field.
func (m *BillingInvoiceMutation) SetVoidedAt(t time.Time) {
	m.voided_at = &t
}

// VoidedAt returns the value of the "voided_at" field in the mutation.
func (m *BillingInvoiceMutation) VoidedAt() (r time.Time, exists bool) {
	v := m.voided_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidedAt returns the old "voided_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldVoidedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidedAt: %w", err)
	}
	return oldValue.VoidedAt, nil
}

// ClearVoidedAt clears the value of the "voided_at" field.
func (m *BillingInvoiceMutation) ClearVoidedAt() {
	m.voided_at = nil
	m.clearedFields[billinginvoice.FieldVoidedAt] = struct{}{}
}

// VoidedAtCleared returns if the "voided_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) VoidedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldVoidedAt]
	return ok
}

// ResetVoidedAt resets all changes to the "voided_at" field.
func (m *BillingInvoiceMutation) ResetVoidedAt() {
	m.voided_at = nil
	delete(m.clearedFields, billinginvoice.FieldVoidedAt)
}

// SetIssuedAt sets the "issued_at" field.
func (m *BillingInvoiceMutation) SetIssuedAt(t time.Time) {
	m.issued_at = &t
}

// IssuedAt returns the value of the "issued_at" field in the mutation.
func (m *BillingInvoiceMutation) IssuedAt() (r time.Time, exists bool) {
	v := m.issued_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedAt returns the old "issued_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldIssuedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedAt: %w", err)
	}
	return oldValue.IssuedAt, nil
}

// ClearIssuedAt clears the value of the "issued_at" field.
func (m *BillingInvoiceMutation) ClearIssuedAt() {
	m.issued_at = nil
	m.clearedFields[billinginvoice.FieldIssuedAt] = struct{}{}
}

// IssuedAtCleared returns if the "issued_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) IssuedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldIssuedAt]
	return ok
}

// ResetIssuedAt resets all changes to the "issued_at" field.
func (m *BillingInvoiceMutation) ResetIssuedAt() {
	m.issued_at = nil
	delete(m.clearedFields, billinginvoice.FieldIssuedAt)
}

// SetSentToCustomerAt sets the "sent_to_customer_at" field.
func (m *BillingInvoiceMutation) SetSentToCustomerAt(t time.Time) {
	m.sent_to_customer_at = &t
}

// SentToCustomerAt returns the value of the "sent_to_customer_at" field in the mutation.
func (m *BillingInvoiceMutation) SentToCustomerAt() (r time.Time, exists bool) {
	v := m.sent_to_customer_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSentToCustomerAt returns the old "sent_to_customer_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldSentToCustomerAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentToCustomerAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentToCustomerAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentToCustomerAt: %w", err)
	}
	return oldValue.SentToCustomerAt, nil
}

// ClearSentToCustomerAt clears the value of the "sent_to_customer_at" field.
func (m *BillingInvoiceMutation) ClearSentToCustomerAt() {
	m.sent_to_customer_at = nil
	m.clearedFields[billinginvoice.FieldSentToCustomerAt] = struct{}{}
}

// SentToCustomerAtCleared returns if the "sent_to_customer_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) SentToCustomerAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldSentToCustomerAt]
	return ok
}

// ResetSentToCustomerAt resets all changes to the "sent_to_customer_at" field.
func (m *BillingInvoiceMutation) ResetSentToCustomerAt() {
	m.sent_to_customer_at = nil
	delete(m.clearedFields, billinginvoice.FieldSentToCustomerAt)
}

// SetDraftUntil sets the "draft_until" field.
func (m *BillingInvoiceMutation) SetDraftUntil(t time.Time) {
	m.draft_until = &t
}

// DraftUntil returns the value of the "draft_until" field in the mutation.
func (m *BillingInvoiceMutation) DraftUntil() (r time.Time, exists bool) {
	v := m.draft_until
	if v == nil {
		return
	}
	return *v, true
}

// OldDraftUntil returns the old "draft_until" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDraftUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDraftUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDraftUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDraftUntil: %w", err)
	}
	return oldValue.DraftUntil, nil
}

// ClearDraftUntil clears the value of the "draft_until" field.
func (m *BillingInvoiceMutation) ClearDraftUntil() {
	m.draft_until = nil
	m.clearedFields[billinginvoice.FieldDraftUntil] = struct{}{}
}

// DraftUntilCleared returns if the "draft_until" field was cleared in this mutation.
func (m *BillingInvoiceMutation) DraftUntilCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldDraftUntil]
	return ok
}

// ResetDraftUntil resets all changes to the "draft_until" field.
func (m *BillingInvoiceMutation) ResetDraftUntil() {
	m.draft_until = nil
	delete(m.clearedFields, billinginvoice.FieldDraftUntil)
}

// SetQuantitySnapshotedAt sets the "quantity_snapshoted_at" field.
func (m *BillingInvoiceMutation) SetQuantitySnapshotedAt(t time.Time) {
	m.quantity_snapshoted_at = &t
}

// QuantitySnapshotedAt returns the value of the "quantity_snapshoted_at" field in the mutation.
func (m *BillingInvoiceMutation) QuantitySnapshotedAt() (r time.Time, exists bool) {
	v := m.quantity_snapshoted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantitySnapshotedAt returns the old "quantity_snapshoted_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldQuantitySnapshotedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantitySnapshotedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantitySnapshotedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantitySnapshotedAt: %w", err)
	}
	return oldValue.QuantitySnapshotedAt, nil
}

// ClearQuantitySnapshotedAt clears the value of the "quantity_snapshoted_at" field.
func (m *BillingInvoiceMutation) ClearQuantitySnapshotedAt() {
	m.quantity_snapshoted_at = nil
	m.clearedFields[billinginvoice.FieldQuantitySnapshotedAt] = struct{}{}
}

// QuantitySnapshotedAtCleared returns if the "quantity_snapshoted_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) QuantitySnapshotedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldQuantitySnapshotedAt]
	return ok
}

// ResetQuantitySnapshotedAt resets all changes to the "quantity_snapshoted_at" field.
func (m *BillingInvoiceMutation) ResetQuantitySnapshotedAt() {
	m.quantity_snapshoted_at = nil
	delete(m.clearedFields, billinginvoice.FieldQuantitySnapshotedAt)
}

// SetCurrency sets the "currency" field.
func (m *BillingInvoiceMutation) SetCurrency(c currencyx.Code) {
	m.currency = &c
}

// Currency returns the value of the "currency" field in the mutation.
func (m *BillingInvoiceMutation) Currency() (r currencyx.Code, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCurrency(ctx context.Context) (v currencyx.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *BillingInvoiceMutation) ResetCurrency() {
	m.currency = nil
}

// SetDueAt sets the "due_at" field.
func (m *BillingInvoiceMutation) SetDueAt(t time.Time) {
	m.due_at = &t
}

// DueAt returns the value of the "due_at" field in the mutation.
func (m *BillingInvoiceMutation) DueAt() (r time.Time, exists bool) {
	v := m.due_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDueAt returns the old "due_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldDueAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueAt: %w", err)
	}
	return oldValue.DueAt, nil
}

// ClearDueAt clears the value of the "due_at" field.
func (m *BillingInvoiceMutation) ClearDueAt() {
	m.due_at = nil
	m.clearedFields[billinginvoice.FieldDueAt] = struct{}{}
}

// DueAtCleared returns if the "due_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) DueAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldDueAt]
	return ok
}

// ResetDueAt resets all changes to the "due_at" field.
func (m *BillingInvoiceMutation) ResetDueAt() {
	m.due_at = nil
	delete(m.clearedFields, billinginvoice.FieldDueAt)
}

// SetStatus sets the "status" field.
func (m *BillingInvoiceMutation) SetStatus(bs billing.InvoiceStatus) {
	m.status = &bs
}

// Status returns the value of the "status" field in the mutation.
func (m *BillingInvoiceMutation) Status() (r billing.InvoiceStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldStatus(ctx context.Context) (v billing.InvoiceStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BillingInvoiceMutation) ResetStatus() {
	m.status = nil
}

// SetStatusDetailsCache sets the "status_details_cache" field.
func (m *BillingInvoiceMutation) SetStatusDetailsCache(bsd billing.InvoiceStatusDetails) {
	m.status_details_cache = &bsd
}

// StatusDetailsCache returns the value of the "status_details_cache" field in the mutation.
func (m *BillingInvoiceMutation) StatusDetailsCache() (r billing.InvoiceStatusDetails, exists bool) {
	v := m.status_details_cache
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusDetailsCache returns the old "status_details_cache" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldStatusDetailsCache(ctx context.Context) (v billing.InvoiceStatusDetails, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusDetailsCache is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusDetailsCache requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusDetailsCache: %w", err)
	}
	return oldValue.StatusDetailsCache, nil
}

// ClearStatusDetailsCache clears the value of the "status_details_cache" field.
func (m *BillingInvoiceMutation) ClearStatusDetailsCache() {
	m.status_details_cache = nil
	m.clearedFields[billinginvoice.FieldStatusDetailsCache] = struct{}{}
}

// StatusDetailsCacheCleared returns if the "status_details_cache" field was cleared in this mutation.
func (m *BillingInvoiceMutation) StatusDetailsCacheCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldStatusDetailsCache]
	return ok
}

// ResetStatusDetailsCache resets all changes to the "status_details_cache" field.
func (m *BillingInvoiceMutation) ResetStatusDetailsCache() {
	m.status_details_cache = nil
	delete(m.clearedFields, billinginvoice.FieldStatusDetailsCache)
}

// SetWorkflowConfigID sets the "workflow_config_id" field.
func (m *BillingInvoiceMutation) SetWorkflowConfigID(s string) {
	m.billing_workflow_config = &s
}

// WorkflowConfigID returns the value of the "workflow_config_id" field in the mutation.
func (m *BillingInvoiceMutation) WorkflowConfigID() (r string, exists bool) {
	v := m.billing_workflow_config
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowConfigID returns the old "workflow_config_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldWorkflowConfigID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowConfigID: %w", err)
	}
	return oldValue.WorkflowConfigID, nil
}

// ResetWorkflowConfigID resets all changes to the "workflow_config_id" field.
func (m *BillingInvoiceMutation) ResetWorkflowConfigID() {
	m.billing_workflow_config = nil
}

// SetTaxAppID sets the "tax_app_id" field.
func (m *BillingInvoiceMutation) SetTaxAppID(s string) {
	m.tax_app = &s
}

// TaxAppID returns the value of the "tax_app_id" field in the mutation.
func (m *BillingInvoiceMutation) TaxAppID() (r string, exists bool) {
	v := m.tax_app
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAppID returns the old "tax_app_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldTaxAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAppID: %w", err)
	}
	return oldValue.TaxAppID, nil
}

// ResetTaxAppID resets all changes to the "tax_app_id" field.
func (m *BillingInvoiceMutation) ResetTaxAppID() {
	m.tax_app = nil
}

// SetInvoicingAppID sets the "invoicing_app_id" field.
func (m *BillingInvoiceMutation) SetInvoicingAppID(s string) {
	m.invoicing_app = &s
}

// InvoicingAppID returns the value of the "invoicing_app_id" field in the mutation.
func (m *BillingInvoiceMutation) InvoicingAppID() (r string, exists bool) {
	v := m.invoicing_app
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingAppID returns the old "invoicing_app_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldInvoicingAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingAppID: %w", err)
	}
	return oldValue.InvoicingAppID, nil
}

// ResetInvoicingAppID resets all changes to the "invoicing_app_id" field.
func (m *BillingInvoiceMutation) ResetInvoicingAppID() {
	m.invoicing_app = nil
}

// SetPaymentAppID sets the "payment_app_id" field.
func (m *BillingInvoiceMutation) SetPaymentAppID(s string) {
	m.payment_app = &s
}

// PaymentAppID returns the value of the "payment_app_id" field in the mutation.
func (m *BillingInvoiceMutation) PaymentAppID() (r string, exists bool) {
	v := m.payment_app
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentAppID returns the old "payment_app_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldPaymentAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentAppID: %w", err)
	}
	return oldValue.PaymentAppID, nil
}

// ResetPaymentAppID resets all changes to the "payment_app_id" field.
func (m *BillingInvoiceMutation) ResetPaymentAppID() {
	m.payment_app = nil
}

// SetInvoicingAppExternalID sets the "invoicing_app_external_id" field.
func (m *BillingInvoiceMutation) SetInvoicingAppExternalID(s string) {
	m.invoicing_app_external_id = &s
}

// InvoicingAppExternalID returns the value of the "invoicing_app_external_id" field in the mutation.
func (m *BillingInvoiceMutation) InvoicingAppExternalID() (r string, exists bool) {
	v := m.invoicing_app_external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingAppExternalID returns the old "invoicing_app_external_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldInvoicingAppExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingAppExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingAppExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingAppExternalID: %w", err)
	}
	return oldValue.InvoicingAppExternalID, nil
}

// ClearInvoicingAppExternalID clears the value of the "invoicing_app_external_id" field.
func (m *BillingInvoiceMutation) ClearInvoicingAppExternalID() {
	m.invoicing_app_external_id = nil
	m.clearedFields[billinginvoice.FieldInvoicingAppExternalID] = struct{}{}
}

// InvoicingAppExternalIDCleared returns if the "invoicing_app_external_id" field was cleared in this mutation.
func (m *BillingInvoiceMutation) InvoicingAppExternalIDCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldInvoicingAppExternalID]
	return ok
}

// ResetInvoicingAppExternalID resets all changes to the "invoicing_app_external_id" field.
func (m *BillingInvoiceMutation) ResetInvoicingAppExternalID() {
	m.invoicing_app_external_id = nil
	delete(m.clearedFields, billinginvoice.FieldInvoicingAppExternalID)
}

// SetPaymentAppExternalID sets the "payment_app_external_id" field.
func (m *BillingInvoiceMutation) SetPaymentAppExternalID(s string) {
	m.payment_app_external_id = &s
}

// PaymentAppExternalID returns the value of the "payment_app_external_id" field in the mutation.
func (m *BillingInvoiceMutation) PaymentAppExternalID() (r string, exists bool) {
	v := m.payment_app_external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentAppExternalID returns the old "payment_app_external_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldPaymentAppExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentAppExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentAppExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentAppExternalID: %w", err)
	}
	return oldValue.PaymentAppExternalID, nil
}

// ClearPaymentAppExternalID clears the value of the "payment_app_external_id" field.
func (m *BillingInvoiceMutation) ClearPaymentAppExternalID() {
	m.payment_app_external_id = nil
	m.clearedFields[billinginvoice.FieldPaymentAppExternalID] = struct{}{}
}

// PaymentAppExternalIDCleared returns if the "payment_app_external_id" field was cleared in this mutation.
func (m *BillingInvoiceMutation) PaymentAppExternalIDCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldPaymentAppExternalID]
	return ok
}

// ResetPaymentAppExternalID resets all changes to the "payment_app_external_id" field.
func (m *BillingInvoiceMutation) ResetPaymentAppExternalID() {
	m.payment_app_external_id = nil
	delete(m.clearedFields, billinginvoice.FieldPaymentAppExternalID)
}

// SetTaxAppExternalID sets the "tax_app_external_id" field.
func (m *BillingInvoiceMutation) SetTaxAppExternalID(s string) {
	m.tax_app_external_id = &s
}

// TaxAppExternalID returns the value of the "tax_app_external_id" field in the mutation.
func (m *BillingInvoiceMutation) TaxAppExternalID() (r string, exists bool) {
	v := m.tax_app_external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAppExternalID returns the old "tax_app_external_id" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldTaxAppExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAppExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAppExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAppExternalID: %w", err)
	}
	return oldValue.TaxAppExternalID, nil
}

// ClearTaxAppExternalID clears the value of the "tax_app_external_id" field.
func (m *BillingInvoiceMutation) ClearTaxAppExternalID() {
	m.tax_app_external_id = nil
	m.clearedFields[billinginvoice.FieldTaxAppExternalID] = struct{}{}
}

// TaxAppExternalIDCleared returns if the "tax_app_external_id" field was cleared in this mutation.
func (m *BillingInvoiceMutation) TaxAppExternalIDCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldTaxAppExternalID]
	return ok
}

// ResetTaxAppExternalID resets all changes to the "tax_app_external_id" field.
func (m *BillingInvoiceMutation) ResetTaxAppExternalID() {
	m.tax_app_external_id = nil
	delete(m.clearedFields, billinginvoice.FieldTaxAppExternalID)
}

// SetPeriodStart sets the "period_start" field.
func (m *BillingInvoiceMutation) SetPeriodStart(t time.Time) {
	m.period_start = &t
}

// PeriodStart returns the value of the "period_start" field in the mutation.
func (m *BillingInvoiceMutation) PeriodStart() (r time.Time, exists bool) {
	v := m.period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodStart returns the old "period_start" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldPeriodStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodStart: %w", err)
	}
	return oldValue.PeriodStart, nil
}

// ClearPeriodStart clears the value of the "period_start" field.
func (m *BillingInvoiceMutation) ClearPeriodStart() {
	m.period_start = nil
	m.clearedFields[billinginvoice.FieldPeriodStart] = struct{}{}
}

// PeriodStartCleared returns if the "period_start" field was cleared in this mutation.
func (m *BillingInvoiceMutation) PeriodStartCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldPeriodStart]
	return ok
}

// ResetPeriodStart resets all changes to the "period_start" field.
func (m *BillingInvoiceMutation) ResetPeriodStart() {
	m.period_start = nil
	delete(m.clearedFields, billinginvoice.FieldPeriodStart)
}

// SetPeriodEnd sets the "period_end" field.
func (m *BillingInvoiceMutation) SetPeriodEnd(t time.Time) {
	m.period_end = &t
}

// PeriodEnd returns the value of the "period_end" field in the mutation.
func (m *BillingInvoiceMutation) PeriodEnd() (r time.Time, exists bool) {
	v := m.period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodEnd returns the old "period_end" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldPeriodEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodEnd: %w", err)
	}
	return oldValue.PeriodEnd, nil
}

// ClearPeriodEnd clears the value of the "period_end" field.
func (m *BillingInvoiceMutation) ClearPeriodEnd() {
	m.period_end = nil
	m.clearedFields[billinginvoice.FieldPeriodEnd] = struct{}{}
}

// PeriodEndCleared returns if the "period_end" field was cleared in this mutation.
func (m *BillingInvoiceMutation) PeriodEndCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldPeriodEnd]
	return ok
}

// ResetPeriodEnd resets all changes to the "period_end" field.
func (m *BillingInvoiceMutation) ResetPeriodEnd() {
	m.period_end = nil
	delete(m.clearedFields, billinginvoice.FieldPeriodEnd)
}

// SetCollectionAt sets the "collection_at" field.
func (m *BillingInvoiceMutation) SetCollectionAt(t time.Time) {
	m.collection_at = &t
}

// CollectionAt returns the value of the "collection_at" field in the mutation.
func (m *BillingInvoiceMutation) CollectionAt() (r time.Time, exists bool) {
	v := m.collection_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionAt returns the old "collection_at" field's value of the BillingInvoice entity.
// If the BillingInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceMutation) OldCollectionAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionAt: %w", err)
	}
	return oldValue.CollectionAt, nil
}

// ClearCollectionAt clears the value of the "collection_at" field.
func (m *BillingInvoiceMutation) ClearCollectionAt() {
	m.collection_at = nil
	m.clearedFields[billinginvoice.FieldCollectionAt] = struct{}{}
}

// CollectionAtCleared returns if the "collection_at" field was cleared in this mutation.
func (m *BillingInvoiceMutation) CollectionAtCleared() bool {
	_, ok := m.clearedFields[billinginvoice.FieldCollectionAt]
	return ok
}

// ResetCollectionAt resets all changes to the "collection_at" field.
func (m *BillingInvoiceMutation) ResetCollectionAt() {
	m.collection_at = nil
	delete(m.clearedFields, billinginvoice.FieldCollectionAt)
}

// ClearSourceBillingProfile clears the "source_billing_profile" edge to the BillingProfile entity.
func (m *BillingInvoiceMutation) ClearSourceBillingProfile() {
	m.clearedsource_billing_profile = true
	m.clearedFields[billinginvoice.FieldSourceBillingProfileID] = struct{}{}
}

// SourceBillingProfileCleared reports if the "source_billing_profile" edge to the BillingProfile entity was cleared.
func (m *BillingInvoiceMutation) SourceBillingProfileCleared() bool {
	return m.clearedsource_billing_profile
}

// SourceBillingProfileIDs returns the "source_billing_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceBillingProfileID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) SourceBillingProfileIDs() (ids []string) {
	if id := m.source_billing_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceBillingProfile resets all changes to the "source_billing_profile" edge.
func (m *BillingInvoiceMutation) ResetSourceBillingProfile() {
	m.source_billing_profile = nil
	m.clearedsource_billing_profile = false
}

// SetBillingWorkflowConfigID sets the "billing_workflow_config" edge to the BillingWorkflowConfig entity by id.
func (m *BillingInvoiceMutation) SetBillingWorkflowConfigID(id string) {
	m.billing_workflow_config = &id
}

// ClearBillingWorkflowConfig clears the "billing_workflow_config" edge to the BillingWorkflowConfig entity.
func (m *BillingInvoiceMutation) ClearBillingWorkflowConfig() {
	m.clearedbilling_workflow_config = true
	m.clearedFields[billinginvoice.FieldWorkflowConfigID] = struct{}{}
}

// BillingWorkflowConfigCleared reports if the "billing_workflow_config" edge to the BillingWorkflowConfig entity was cleared.
func (m *BillingInvoiceMutation) BillingWorkflowConfigCleared() bool {
	return m.clearedbilling_workflow_config
}

// BillingWorkflowConfigID returns the "billing_workflow_config" edge ID in the mutation.
func (m *BillingInvoiceMutation) BillingWorkflowConfigID() (id string, exists bool) {
	if m.billing_workflow_config != nil {
		return *m.billing_workflow_config, true
	}
	return
}

// BillingWorkflowConfigIDs returns the "billing_workflow_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingWorkflowConfigID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) BillingWorkflowConfigIDs() (ids []string) {
	if id := m.billing_workflow_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingWorkflowConfig resets all changes to the "billing_workflow_config" edge.
func (m *BillingInvoiceMutation) ResetBillingWorkflowConfig() {
	m.billing_workflow_config = nil
	m.clearedbilling_workflow_config = false
}

// AddBillingInvoiceLineIDs adds the "billing_invoice_lines" edge to the BillingInvoiceLine entity by ids.
func (m *BillingInvoiceMutation) AddBillingInvoiceLineIDs(ids ...string) {
	if m.billing_invoice_lines == nil {
		m.billing_invoice_lines = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_lines[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoiceLines clears the "billing_invoice_lines" edge to the BillingInvoiceLine entity.
func (m *BillingInvoiceMutation) ClearBillingInvoiceLines() {
	m.clearedbilling_invoice_lines = true
}

// BillingInvoiceLinesCleared reports if the "billing_invoice_lines" edge to the BillingInvoiceLine entity was cleared.
func (m *BillingInvoiceMutation) BillingInvoiceLinesCleared() bool {
	return m.clearedbilling_invoice_lines
}

// RemoveBillingInvoiceLineIDs removes the "billing_invoice_lines" edge to the BillingInvoiceLine entity by IDs.
func (m *BillingInvoiceMutation) RemoveBillingInvoiceLineIDs(ids ...string) {
	if m.removedbilling_invoice_lines == nil {
		m.removedbilling_invoice_lines = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_lines, ids[i])
		m.removedbilling_invoice_lines[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoiceLines returns the removed IDs of the "billing_invoice_lines" edge to the BillingInvoiceLine entity.
func (m *BillingInvoiceMutation) RemovedBillingInvoiceLinesIDs() (ids []string) {
	for id := range m.removedbilling_invoice_lines {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceLinesIDs returns the "billing_invoice_lines" edge IDs in the mutation.
func (m *BillingInvoiceMutation) BillingInvoiceLinesIDs() (ids []string) {
	for id := range m.billing_invoice_lines {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoiceLines resets all changes to the "billing_invoice_lines" edge.
func (m *BillingInvoiceMutation) ResetBillingInvoiceLines() {
	m.billing_invoice_lines = nil
	m.clearedbilling_invoice_lines = false
	m.removedbilling_invoice_lines = nil
}

// AddBillingInvoiceValidationIssueIDs adds the "billing_invoice_validation_issues" edge to the BillingInvoiceValidationIssue entity by ids.
func (m *BillingInvoiceMutation) AddBillingInvoiceValidationIssueIDs(ids ...string) {
	if m.billing_invoice_validation_issues == nil {
		m.billing_invoice_validation_issues = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice_validation_issues[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoiceValidationIssues clears the "billing_invoice_validation_issues" edge to the BillingInvoiceValidationIssue entity.
func (m *BillingInvoiceMutation) ClearBillingInvoiceValidationIssues() {
	m.clearedbilling_invoice_validation_issues = true
}

// BillingInvoiceValidationIssuesCleared reports if the "billing_invoice_validation_issues" edge to the BillingInvoiceValidationIssue entity was cleared.
func (m *BillingInvoiceMutation) BillingInvoiceValidationIssuesCleared() bool {
	return m.clearedbilling_invoice_validation_issues
}

// RemoveBillingInvoiceValidationIssueIDs removes the "billing_invoice_validation_issues" edge to the BillingInvoiceValidationIssue entity by IDs.
func (m *BillingInvoiceMutation) RemoveBillingInvoiceValidationIssueIDs(ids ...string) {
	if m.removedbilling_invoice_validation_issues == nil {
		m.removedbilling_invoice_validation_issues = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice_validation_issues, ids[i])
		m.removedbilling_invoice_validation_issues[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoiceValidationIssues returns the removed IDs of the "billing_invoice_validation_issues" edge to the BillingInvoiceValidationIssue entity.
func (m *BillingInvoiceMutation) RemovedBillingInvoiceValidationIssuesIDs() (ids []string) {
	for id := range m.removedbilling_invoice_validation_issues {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceValidationIssuesIDs returns the "billing_invoice_validation_issues" edge IDs in the mutation.
func (m *BillingInvoiceMutation) BillingInvoiceValidationIssuesIDs() (ids []string) {
	for id := range m.billing_invoice_validation_issues {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoiceValidationIssues resets all changes to the "billing_invoice_validation_issues" edge.
func (m *BillingInvoiceMutation) ResetBillingInvoiceValidationIssues() {
	m.billing_invoice_validation_issues = nil
	m.clearedbilling_invoice_validation_issues = false
	m.removedbilling_invoice_validation_issues = nil
}

// SetBillingInvoiceCustomerID sets the "billing_invoice_customer" edge to the Customer entity by id.
func (m *BillingInvoiceMutation) SetBillingInvoiceCustomerID(id string) {
	m.billing_invoice_customer = &id
}

// ClearBillingInvoiceCustomer clears the "billing_invoice_customer" edge to the Customer entity.
func (m *BillingInvoiceMutation) ClearBillingInvoiceCustomer() {
	m.clearedbilling_invoice_customer = true
	m.clearedFields[billinginvoice.FieldCustomerID] = struct{}{}
}

// BillingInvoiceCustomerCleared reports if the "billing_invoice_customer" edge to the Customer entity was cleared.
func (m *BillingInvoiceMutation) BillingInvoiceCustomerCleared() bool {
	return m.clearedbilling_invoice_customer
}

// BillingInvoiceCustomerID returns the "billing_invoice_customer" edge ID in the mutation.
func (m *BillingInvoiceMutation) BillingInvoiceCustomerID() (id string, exists bool) {
	if m.billing_invoice_customer != nil {
		return *m.billing_invoice_customer, true
	}
	return
}

// BillingInvoiceCustomerIDs returns the "billing_invoice_customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoiceCustomerID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) BillingInvoiceCustomerIDs() (ids []string) {
	if id := m.billing_invoice_customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoiceCustomer resets all changes to the "billing_invoice_customer" edge.
func (m *BillingInvoiceMutation) ResetBillingInvoiceCustomer() {
	m.billing_invoice_customer = nil
	m.clearedbilling_invoice_customer = false
}

// ClearTaxApp clears the "tax_app" edge to the App entity.
func (m *BillingInvoiceMutation) ClearTaxApp() {
	m.clearedtax_app = true
	m.clearedFields[billinginvoice.FieldTaxAppID] = struct{}{}
}

// TaxAppCleared reports if the "tax_app" edge to the App entity was cleared.
func (m *BillingInvoiceMutation) TaxAppCleared() bool {
	return m.clearedtax_app
}

// TaxAppIDs returns the "tax_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaxAppID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) TaxAppIDs() (ids []string) {
	if id := m.tax_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaxApp resets all changes to the "tax_app" edge.
func (m *BillingInvoiceMutation) ResetTaxApp() {
	m.tax_app = nil
	m.clearedtax_app = false
}

// ClearInvoicingApp clears the "invoicing_app" edge to the App entity.
func (m *BillingInvoiceMutation) ClearInvoicingApp() {
	m.clearedinvoicing_app = true
	m.clearedFields[billinginvoice.FieldInvoicingAppID] = struct{}{}
}

// InvoicingAppCleared reports if the "invoicing_app" edge to the App entity was cleared.
func (m *BillingInvoiceMutation) InvoicingAppCleared() bool {
	return m.clearedinvoicing_app
}

// InvoicingAppIDs returns the "invoicing_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoicingAppID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) InvoicingAppIDs() (ids []string) {
	if id := m.invoicing_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoicingApp resets all changes to the "invoicing_app" edge.
func (m *BillingInvoiceMutation) ResetInvoicingApp() {
	m.invoicing_app = nil
	m.clearedinvoicing_app = false
}

// ClearPaymentApp clears the "payment_app" edge to the App entity.
func (m *BillingInvoiceMutation) ClearPaymentApp() {
	m.clearedpayment_app = true
	m.clearedFields[billinginvoice.FieldPaymentAppID] = struct{}{}
}

// PaymentAppCleared reports if the "payment_app" edge to the App entity was cleared.
func (m *BillingInvoiceMutation) PaymentAppCleared() bool {
	return m.clearedpayment_app
}

// PaymentAppIDs returns the "payment_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentAppID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceMutation) PaymentAppIDs() (ids []string) {
	if id := m.payment_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentApp resets all changes to the "payment_app" edge.
func (m *BillingInvoiceMutation) ResetPaymentApp() {
	m.payment_app = nil
	m.clearedpayment_app = false
}

// Where appends a list predicates to the BillingInvoiceMutation builder.
func (m *BillingInvoiceMutation) Where(ps ...predicate.BillingInvoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoice).
func (m *BillingInvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceMutation) Fields() []string {
	fields := make([]string, 0, 54)
	if m.namespace != nil {
		fields = append(fields, billinginvoice.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, billinginvoice.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, billinginvoice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billinginvoice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billinginvoice.FieldDeletedAt)
	}
	if m.supplier_address_country != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressCountry)
	}
	if m.supplier_address_postal_code != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressPostalCode)
	}
	if m.supplier_address_state != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressState)
	}
	if m.supplier_address_city != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressCity)
	}
	if m.supplier_address_line1 != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressLine1)
	}
	if m.supplier_address_line2 != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressLine2)
	}
	if m.supplier_address_phone_number != nil {
		fields = append(fields, billinginvoice.FieldSupplierAddressPhoneNumber)
	}
	if m.customer_address_country != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressCountry)
	}
	if m.customer_address_postal_code != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressPostalCode)
	}
	if m.customer_address_state != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressState)
	}
	if m.customer_address_city != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressCity)
	}
	if m.customer_address_line1 != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressLine1)
	}
	if m.customer_address_line2 != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressLine2)
	}
	if m.customer_address_phone_number != nil {
		fields = append(fields, billinginvoice.FieldCustomerAddressPhoneNumber)
	}
	if m.amount != nil {
		fields = append(fields, billinginvoice.FieldAmount)
	}
	if m.taxes_total != nil {
		fields = append(fields, billinginvoice.FieldTaxesTotal)
	}
	if m.taxes_inclusive_total != nil {
		fields = append(fields, billinginvoice.FieldTaxesInclusiveTotal)
	}
	if m.taxes_exclusive_total != nil {
		fields = append(fields, billinginvoice.FieldTaxesExclusiveTotal)
	}
	if m.charges_total != nil {
		fields = append(fields, billinginvoice.FieldChargesTotal)
	}
	if m.discounts_total != nil {
		fields = append(fields, billinginvoice.FieldDiscountsTotal)
	}
	if m.total != nil {
		fields = append(fields, billinginvoice.FieldTotal)
	}
	if m.supplier_name != nil {
		fields = append(fields, billinginvoice.FieldSupplierName)
	}
	if m.supplier_tax_code != nil {
		fields = append(fields, billinginvoice.FieldSupplierTaxCode)
	}
	if m.customer_name != nil {
		fields = append(fields, billinginvoice.FieldCustomerName)
	}
	if m.customer_usage_attribution != nil {
		fields = append(fields, billinginvoice.FieldCustomerUsageAttribution)
	}
	if m.number != nil {
		fields = append(fields, billinginvoice.FieldNumber)
	}
	if m._type != nil {
		fields = append(fields, billinginvoice.FieldType)
	}
	if m.description != nil {
		fields = append(fields, billinginvoice.FieldDescription)
	}
	if m.billing_invoice_customer != nil {
		fields = append(fields, billinginvoice.FieldCustomerID)
	}
	if m.source_billing_profile != nil {
		fields = append(fields, billinginvoice.FieldSourceBillingProfileID)
	}
	if m.voided_at != nil {
		fields = append(fields, billinginvoice.FieldVoidedAt)
	}
	if m.issued_at != nil {
		fields = append(fields, billinginvoice.FieldIssuedAt)
	}
	if m.sent_to_customer_at != nil {
		fields = append(fields, billinginvoice.FieldSentToCustomerAt)
	}
	if m.draft_until != nil {
		fields = append(fields, billinginvoice.FieldDraftUntil)
	}
	if m.quantity_snapshoted_at != nil {
		fields = append(fields, billinginvoice.FieldQuantitySnapshotedAt)
	}
	if m.currency != nil {
		fields = append(fields, billinginvoice.FieldCurrency)
	}
	if m.due_at != nil {
		fields = append(fields, billinginvoice.FieldDueAt)
	}
	if m.status != nil {
		fields = append(fields, billinginvoice.FieldStatus)
	}
	if m.status_details_cache != nil {
		fields = append(fields, billinginvoice.FieldStatusDetailsCache)
	}
	if m.billing_workflow_config != nil {
		fields = append(fields, billinginvoice.FieldWorkflowConfigID)
	}
	if m.tax_app != nil {
		fields = append(fields, billinginvoice.FieldTaxAppID)
	}
	if m.invoicing_app != nil {
		fields = append(fields, billinginvoice.FieldInvoicingAppID)
	}
	if m.payment_app != nil {
		fields = append(fields, billinginvoice.FieldPaymentAppID)
	}
	if m.invoicing_app_external_id != nil {
		fields = append(fields, billinginvoice.FieldInvoicingAppExternalID)
	}
	if m.payment_app_external_id != nil {
		fields = append(fields, billinginvoice.FieldPaymentAppExternalID)
	}
	if m.tax_app_external_id != nil {
		fields = append(fields, billinginvoice.FieldTaxAppExternalID)
	}
	if m.period_start != nil {
		fields = append(fields, billinginvoice.FieldPeriodStart)
	}
	if m.period_end != nil {
		fields = append(fields, billinginvoice.FieldPeriodEnd)
	}
	if m.collection_at != nil {
		fields = append(fields, billinginvoice.FieldCollectionAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoice.FieldNamespace:
		return m.Namespace()
	case billinginvoice.FieldMetadata:
		return m.Metadata()
	case billinginvoice.FieldCreatedAt:
		return m.CreatedAt()
	case billinginvoice.FieldUpdatedAt:
		return m.UpdatedAt()
	case billinginvoice.FieldDeletedAt:
		return m.DeletedAt()
	case billinginvoice.FieldSupplierAddressCountry:
		return m.SupplierAddressCountry()
	case billinginvoice.FieldSupplierAddressPostalCode:
		return m.SupplierAddressPostalCode()
	case billinginvoice.FieldSupplierAddressState:
		return m.SupplierAddressState()
	case billinginvoice.FieldSupplierAddressCity:
		return m.SupplierAddressCity()
	case billinginvoice.FieldSupplierAddressLine1:
		return m.SupplierAddressLine1()
	case billinginvoice.FieldSupplierAddressLine2:
		return m.SupplierAddressLine2()
	case billinginvoice.FieldSupplierAddressPhoneNumber:
		return m.SupplierAddressPhoneNumber()
	case billinginvoice.FieldCustomerAddressCountry:
		return m.CustomerAddressCountry()
	case billinginvoice.FieldCustomerAddressPostalCode:
		return m.CustomerAddressPostalCode()
	case billinginvoice.FieldCustomerAddressState:
		return m.CustomerAddressState()
	case billinginvoice.FieldCustomerAddressCity:
		return m.CustomerAddressCity()
	case billinginvoice.FieldCustomerAddressLine1:
		return m.CustomerAddressLine1()
	case billinginvoice.FieldCustomerAddressLine2:
		return m.CustomerAddressLine2()
	case billinginvoice.FieldCustomerAddressPhoneNumber:
		return m.CustomerAddressPhoneNumber()
	case billinginvoice.FieldAmount:
		return m.Amount()
	case billinginvoice.FieldTaxesTotal:
		return m.TaxesTotal()
	case billinginvoice.FieldTaxesInclusiveTotal:
		return m.TaxesInclusiveTotal()
	case billinginvoice.FieldTaxesExclusiveTotal:
		return m.TaxesExclusiveTotal()
	case billinginvoice.FieldChargesTotal:
		return m.ChargesTotal()
	case billinginvoice.FieldDiscountsTotal:
		return m.DiscountsTotal()
	case billinginvoice.FieldTotal:
		return m.Total()
	case billinginvoice.FieldSupplierName:
		return m.SupplierName()
	case billinginvoice.FieldSupplierTaxCode:
		return m.SupplierTaxCode()
	case billinginvoice.FieldCustomerName:
		return m.CustomerName()
	case billinginvoice.FieldCustomerUsageAttribution:
		return m.CustomerUsageAttribution()
	case billinginvoice.FieldNumber:
		return m.Number()
	case billinginvoice.FieldType:
		return m.GetType()
	case billinginvoice.FieldDescription:
		return m.Description()
	case billinginvoice.FieldCustomerID:
		return m.CustomerID()
	case billinginvoice.FieldSourceBillingProfileID:
		return m.SourceBillingProfileID()
	case billinginvoice.FieldVoidedAt:
		return m.VoidedAt()
	case billinginvoice.FieldIssuedAt:
		return m.IssuedAt()
	case billinginvoice.FieldSentToCustomerAt:
		return m.SentToCustomerAt()
	case billinginvoice.FieldDraftUntil:
		return m.DraftUntil()
	case billinginvoice.FieldQuantitySnapshotedAt:
		return m.QuantitySnapshotedAt()
	case billinginvoice.FieldCurrency:
		return m.Currency()
	case billinginvoice.FieldDueAt:
		return m.DueAt()
	case billinginvoice.FieldStatus:
		return m.Status()
	case billinginvoice.FieldStatusDetailsCache:
		return m.StatusDetailsCache()
	case billinginvoice.FieldWorkflowConfigID:
		return m.WorkflowConfigID()
	case billinginvoice.FieldTaxAppID:
		return m.TaxAppID()
	case billinginvoice.FieldInvoicingAppID:
		return m.InvoicingAppID()
	case billinginvoice.FieldPaymentAppID:
		return m.PaymentAppID()
	case billinginvoice.FieldInvoicingAppExternalID:
		return m.InvoicingAppExternalID()
	case billinginvoice.FieldPaymentAppExternalID:
		return m.PaymentAppExternalID()
	case billinginvoice.FieldTaxAppExternalID:
		return m.TaxAppExternalID()
	case billinginvoice.FieldPeriodStart:
		return m.PeriodStart()
	case billinginvoice.FieldPeriodEnd:
		return m.PeriodEnd()
	case billinginvoice.FieldCollectionAt:
		return m.CollectionAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoice.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoice.FieldMetadata:
		return m.OldMetadata(ctx)
	case billinginvoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billinginvoice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billinginvoice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billinginvoice.FieldSupplierAddressCountry:
		return m.OldSupplierAddressCountry(ctx)
	case billinginvoice.FieldSupplierAddressPostalCode:
		return m.OldSupplierAddressPostalCode(ctx)
	case billinginvoice.FieldSupplierAddressState:
		return m.OldSupplierAddressState(ctx)
	case billinginvoice.FieldSupplierAddressCity:
		return m.OldSupplierAddressCity(ctx)
	case billinginvoice.FieldSupplierAddressLine1:
		return m.OldSupplierAddressLine1(ctx)
	case billinginvoice.FieldSupplierAddressLine2:
		return m.OldSupplierAddressLine2(ctx)
	case billinginvoice.FieldSupplierAddressPhoneNumber:
		return m.OldSupplierAddressPhoneNumber(ctx)
	case billinginvoice.FieldCustomerAddressCountry:
		return m.OldCustomerAddressCountry(ctx)
	case billinginvoice.FieldCustomerAddressPostalCode:
		return m.OldCustomerAddressPostalCode(ctx)
	case billinginvoice.FieldCustomerAddressState:
		return m.OldCustomerAddressState(ctx)
	case billinginvoice.FieldCustomerAddressCity:
		return m.OldCustomerAddressCity(ctx)
	case billinginvoice.FieldCustomerAddressLine1:
		return m.OldCustomerAddressLine1(ctx)
	case billinginvoice.FieldCustomerAddressLine2:
		return m.OldCustomerAddressLine2(ctx)
	case billinginvoice.FieldCustomerAddressPhoneNumber:
		return m.OldCustomerAddressPhoneNumber(ctx)
	case billinginvoice.FieldAmount:
		return m.OldAmount(ctx)
	case billinginvoice.FieldTaxesTotal:
		return m.OldTaxesTotal(ctx)
	case billinginvoice.FieldTaxesInclusiveTotal:
		return m.OldTaxesInclusiveTotal(ctx)
	case billinginvoice.FieldTaxesExclusiveTotal:
		return m.OldTaxesExclusiveTotal(ctx)
	case billinginvoice.FieldChargesTotal:
		return m.OldChargesTotal(ctx)
	case billinginvoice.FieldDiscountsTotal:
		return m.OldDiscountsTotal(ctx)
	case billinginvoice.FieldTotal:
		return m.OldTotal(ctx)
	case billinginvoice.FieldSupplierName:
		return m.OldSupplierName(ctx)
	case billinginvoice.FieldSupplierTaxCode:
		return m.OldSupplierTaxCode(ctx)
	case billinginvoice.FieldCustomerName:
		return m.OldCustomerName(ctx)
	case billinginvoice.FieldCustomerUsageAttribution:
		return m.OldCustomerUsageAttribution(ctx)
	case billinginvoice.FieldNumber:
		return m.OldNumber(ctx)
	case billinginvoice.FieldType:
		return m.OldType(ctx)
	case billinginvoice.FieldDescription:
		return m.OldDescription(ctx)
	case billinginvoice.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case billinginvoice.FieldSourceBillingProfileID:
		return m.OldSourceBillingProfileID(ctx)
	case billinginvoice.FieldVoidedAt:
		return m.OldVoidedAt(ctx)
	case billinginvoice.FieldIssuedAt:
		return m.OldIssuedAt(ctx)
	case billinginvoice.FieldSentToCustomerAt:
		return m.OldSentToCustomerAt(ctx)
	case billinginvoice.FieldDraftUntil:
		return m.OldDraftUntil(ctx)
	case billinginvoice.FieldQuantitySnapshotedAt:
		return m.OldQuantitySnapshotedAt(ctx)
	case billinginvoice.FieldCurrency:
		return m.OldCurrency(ctx)
	case billinginvoice.FieldDueAt:
		return m.OldDueAt(ctx)
	case billinginvoice.FieldStatus:
		return m.OldStatus(ctx)
	case billinginvoice.FieldStatusDetailsCache:
		return m.OldStatusDetailsCache(ctx)
	case billinginvoice.FieldWorkflowConfigID:
		return m.OldWorkflowConfigID(ctx)
	case billinginvoice.FieldTaxAppID:
		return m.OldTaxAppID(ctx)
	case billinginvoice.FieldInvoicingAppID:
		return m.OldInvoicingAppID(ctx)
	case billinginvoice.FieldPaymentAppID:
		return m.OldPaymentAppID(ctx)
	case billinginvoice.FieldInvoicingAppExternalID:
		return m.OldInvoicingAppExternalID(ctx)
	case billinginvoice.FieldPaymentAppExternalID:
		return m.OldPaymentAppExternalID(ctx)
	case billinginvoice.FieldTaxAppExternalID:
		return m.OldTaxAppExternalID(ctx)
	case billinginvoice.FieldPeriodStart:
		return m.OldPeriodStart(ctx)
	case billinginvoice.FieldPeriodEnd:
		return m.OldPeriodEnd(ctx)
	case billinginvoice.FieldCollectionAt:
		return m.OldCollectionAt(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoice.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoice.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case billinginvoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billinginvoice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billinginvoice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billinginvoice.FieldSupplierAddressCountry:
		v, ok := value.(models.CountryCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressCountry(v)
		return nil
	case billinginvoice.FieldSupplierAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressPostalCode(v)
		return nil
	case billinginvoice.FieldSupplierAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressState(v)
		return nil
	case billinginvoice.FieldSupplierAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressCity(v)
		return nil
	case billinginvoice.FieldSupplierAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressLine1(v)
		return nil
	case billinginvoice.FieldSupplierAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressLine2(v)
		return nil
	case billinginvoice.FieldSupplierAddressPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressPhoneNumber(v)
		return nil
	case billinginvoice.FieldCustomerAddressCountry:
		v, ok := value.(models.CountryCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressCountry(v)
		return nil
	case billinginvoice.FieldCustomerAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressPostalCode(v)
		return nil
	case billinginvoice.FieldCustomerAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressState(v)
		return nil
	case billinginvoice.FieldCustomerAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressCity(v)
		return nil
	case billinginvoice.FieldCustomerAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressLine1(v)
		return nil
	case billinginvoice.FieldCustomerAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressLine2(v)
		return nil
	case billinginvoice.FieldCustomerAddressPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerAddressPhoneNumber(v)
		return nil
	case billinginvoice.FieldAmount:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case billinginvoice.FieldTaxesTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxesTotal(v)
		return nil
	case billinginvoice.FieldTaxesInclusiveTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxesInclusiveTotal(v)
		return nil
	case billinginvoice.FieldTaxesExclusiveTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxesExclusiveTotal(v)
		return nil
	case billinginvoice.FieldChargesTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargesTotal(v)
		return nil
	case billinginvoice.FieldDiscountsTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountsTotal(v)
		return nil
	case billinginvoice.FieldTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case billinginvoice.FieldSupplierName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierName(v)
		return nil
	case billinginvoice.FieldSupplierTaxCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierTaxCode(v)
		return nil
	case billinginvoice.FieldCustomerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerName(v)
		return nil
	case billinginvoice.FieldCustomerUsageAttribution:
		v, ok := value.(*billing.VersionedCustomerUsageAttribution)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerUsageAttribution(v)
		return nil
	case billinginvoice.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case billinginvoice.FieldType:
		v, ok := value.(billing.InvoiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case billinginvoice.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case billinginvoice.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case billinginvoice.FieldSourceBillingProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceBillingProfileID(v)
		return nil
	case billinginvoice.FieldVoidedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidedAt(v)
		return nil
	case billinginvoice.FieldIssuedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedAt(v)
		return nil
	case billinginvoice.FieldSentToCustomerAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentToCustomerAt(v)
		return nil
	case billinginvoice.FieldDraftUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDraftUntil(v)
		return nil
	case billinginvoice.FieldQuantitySnapshotedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantitySnapshotedAt(v)
		return nil
	case billinginvoice.FieldCurrency:
		v, ok := value.(currencyx.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case billinginvoice.FieldDueAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueAt(v)
		return nil
	case billinginvoice.FieldStatus:
		v, ok := value.(billing.InvoiceStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case billinginvoice.FieldStatusDetailsCache:
		v, ok := value.(billing.InvoiceStatusDetails)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusDetailsCache(v)
		return nil
	case billinginvoice.FieldWorkflowConfigID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowConfigID(v)
		return nil
	case billinginvoice.FieldTaxAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAppID(v)
		return nil
	case billinginvoice.FieldInvoicingAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingAppID(v)
		return nil
	case billinginvoice.FieldPaymentAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentAppID(v)
		return nil
	case billinginvoice.FieldInvoicingAppExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingAppExternalID(v)
		return nil
	case billinginvoice.FieldPaymentAppExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentAppExternalID(v)
		return nil
	case billinginvoice.FieldTaxAppExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAppExternalID(v)
		return nil
	case billinginvoice.FieldPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodStart(v)
		return nil
	case billinginvoice.FieldPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodEnd(v)
		return nil
	case billinginvoice.FieldCollectionAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionAt(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoice.FieldMetadata) {
		fields = append(fields, billinginvoice.FieldMetadata)
	}
	if m.FieldCleared(billinginvoice.FieldDeletedAt) {
		fields = append(fields, billinginvoice.FieldDeletedAt)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressCountry) {
		fields = append(fields, billinginvoice.FieldSupplierAddressCountry)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressPostalCode) {
		fields = append(fields, billinginvoice.FieldSupplierAddressPostalCode)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressState) {
		fields = append(fields, billinginvoice.FieldSupplierAddressState)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressCity) {
		fields = append(fields, billinginvoice.FieldSupplierAddressCity)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressLine1) {
		fields = append(fields, billinginvoice.FieldSupplierAddressLine1)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressLine2) {
		fields = append(fields, billinginvoice.FieldSupplierAddressLine2)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierAddressPhoneNumber) {
		fields = append(fields, billinginvoice.FieldSupplierAddressPhoneNumber)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressCountry) {
		fields = append(fields, billinginvoice.FieldCustomerAddressCountry)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressPostalCode) {
		fields = append(fields, billinginvoice.FieldCustomerAddressPostalCode)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressState) {
		fields = append(fields, billinginvoice.FieldCustomerAddressState)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressCity) {
		fields = append(fields, billinginvoice.FieldCustomerAddressCity)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressLine1) {
		fields = append(fields, billinginvoice.FieldCustomerAddressLine1)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressLine2) {
		fields = append(fields, billinginvoice.FieldCustomerAddressLine2)
	}
	if m.FieldCleared(billinginvoice.FieldCustomerAddressPhoneNumber) {
		fields = append(fields, billinginvoice.FieldCustomerAddressPhoneNumber)
	}
	if m.FieldCleared(billinginvoice.FieldSupplierTaxCode) {
		fields = append(fields, billinginvoice.FieldSupplierTaxCode)
	}
	if m.FieldCleared(billinginvoice.FieldDescription) {
		fields = append(fields, billinginvoice.FieldDescription)
	}
	if m.FieldCleared(billinginvoice.FieldVoidedAt) {
		fields = append(fields, billinginvoice.FieldVoidedAt)
	}
	if m.FieldCleared(billinginvoice.FieldIssuedAt) {
		fields = append(fields, billinginvoice.FieldIssuedAt)
	}
	if m.FieldCleared(billinginvoice.FieldSentToCustomerAt) {
		fields = append(fields, billinginvoice.FieldSentToCustomerAt)
	}
	if m.FieldCleared(billinginvoice.FieldDraftUntil) {
		fields = append(fields, billinginvoice.FieldDraftUntil)
	}
	if m.FieldCleared(billinginvoice.FieldQuantitySnapshotedAt) {
		fields = append(fields, billinginvoice.FieldQuantitySnapshotedAt)
	}
	if m.FieldCleared(billinginvoice.FieldDueAt) {
		fields = append(fields, billinginvoice.FieldDueAt)
	}
	if m.FieldCleared(billinginvoice.FieldStatusDetailsCache) {
		fields = append(fields, billinginvoice.FieldStatusDetailsCache)
	}
	if m.FieldCleared(billinginvoice.FieldInvoicingAppExternalID) {
		fields = append(fields, billinginvoice.FieldInvoicingAppExternalID)
	}
	if m.FieldCleared(billinginvoice.FieldPaymentAppExternalID) {
		fields = append(fields, billinginvoice.FieldPaymentAppExternalID)
	}
	if m.FieldCleared(billinginvoice.FieldTaxAppExternalID) {
		fields = append(fields, billinginvoice.FieldTaxAppExternalID)
	}
	if m.FieldCleared(billinginvoice.FieldPeriodStart) {
		fields = append(fields, billinginvoice.FieldPeriodStart)
	}
	if m.FieldCleared(billinginvoice.FieldPeriodEnd) {
		fields = append(fields, billinginvoice.FieldPeriodEnd)
	}
	if m.FieldCleared(billinginvoice.FieldCollectionAt) {
		fields = append(fields, billinginvoice.FieldCollectionAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceMutation) ClearField(name string) error {
	switch name {
	case billinginvoice.FieldMetadata:
		m.ClearMetadata()
		return nil
	case billinginvoice.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billinginvoice.FieldSupplierAddressCountry:
		m.ClearSupplierAddressCountry()
		return nil
	case billinginvoice.FieldSupplierAddressPostalCode:
		m.ClearSupplierAddressPostalCode()
		return nil
	case billinginvoice.FieldSupplierAddressState:
		m.ClearSupplierAddressState()
		return nil
	case billinginvoice.FieldSupplierAddressCity:
		m.ClearSupplierAddressCity()
		return nil
	case billinginvoice.FieldSupplierAddressLine1:
		m.ClearSupplierAddressLine1()
		return nil
	case billinginvoice.FieldSupplierAddressLine2:
		m.ClearSupplierAddressLine2()
		return nil
	case billinginvoice.FieldSupplierAddressPhoneNumber:
		m.ClearSupplierAddressPhoneNumber()
		return nil
	case billinginvoice.FieldCustomerAddressCountry:
		m.ClearCustomerAddressCountry()
		return nil
	case billinginvoice.FieldCustomerAddressPostalCode:
		m.ClearCustomerAddressPostalCode()
		return nil
	case billinginvoice.FieldCustomerAddressState:
		m.ClearCustomerAddressState()
		return nil
	case billinginvoice.FieldCustomerAddressCity:
		m.ClearCustomerAddressCity()
		return nil
	case billinginvoice.FieldCustomerAddressLine1:
		m.ClearCustomerAddressLine1()
		return nil
	case billinginvoice.FieldCustomerAddressLine2:
		m.ClearCustomerAddressLine2()
		return nil
	case billinginvoice.FieldCustomerAddressPhoneNumber:
		m.ClearCustomerAddressPhoneNumber()
		return nil
	case billinginvoice.FieldSupplierTaxCode:
		m.ClearSupplierTaxCode()
		return nil
	case billinginvoice.FieldDescription:
		m.ClearDescription()
		return nil
	case billinginvoice.FieldVoidedAt:
		m.ClearVoidedAt()
		return nil
	case billinginvoice.FieldIssuedAt:
		m.ClearIssuedAt()
		return nil
	case billinginvoice.FieldSentToCustomerAt:
		m.ClearSentToCustomerAt()
		return nil
	case billinginvoice.FieldDraftUntil:
		m.ClearDraftUntil()
		return nil
	case billinginvoice.FieldQuantitySnapshotedAt:
		m.ClearQuantitySnapshotedAt()
		return nil
	case billinginvoice.FieldDueAt:
		m.ClearDueAt()
		return nil
	case billinginvoice.FieldStatusDetailsCache:
		m.ClearStatusDetailsCache()
		return nil
	case billinginvoice.FieldInvoicingAppExternalID:
		m.ClearInvoicingAppExternalID()
		return nil
	case billinginvoice.FieldPaymentAppExternalID:
		m.ClearPaymentAppExternalID()
		return nil
	case billinginvoice.FieldTaxAppExternalID:
		m.ClearTaxAppExternalID()
		return nil
	case billinginvoice.FieldPeriodStart:
		m.ClearPeriodStart()
		return nil
	case billinginvoice.FieldPeriodEnd:
		m.ClearPeriodEnd()
		return nil
	case billinginvoice.FieldCollectionAt:
		m.ClearCollectionAt()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceMutation) ResetField(name string) error {
	switch name {
	case billinginvoice.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoice.FieldMetadata:
		m.ResetMetadata()
		return nil
	case billinginvoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billinginvoice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billinginvoice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billinginvoice.FieldSupplierAddressCountry:
		m.ResetSupplierAddressCountry()
		return nil
	case billinginvoice.FieldSupplierAddressPostalCode:
		m.ResetSupplierAddressPostalCode()
		return nil
	case billinginvoice.FieldSupplierAddressState:
		m.ResetSupplierAddressState()
		return nil
	case billinginvoice.FieldSupplierAddressCity:
		m.ResetSupplierAddressCity()
		return nil
	case billinginvoice.FieldSupplierAddressLine1:
		m.ResetSupplierAddressLine1()
		return nil
	case billinginvoice.FieldSupplierAddressLine2:
		m.ResetSupplierAddressLine2()
		return nil
	case billinginvoice.FieldSupplierAddressPhoneNumber:
		m.ResetSupplierAddressPhoneNumber()
		return nil
	case billinginvoice.FieldCustomerAddressCountry:
		m.ResetCustomerAddressCountry()
		return nil
	case billinginvoice.FieldCustomerAddressPostalCode:
		m.ResetCustomerAddressPostalCode()
		return nil
	case billinginvoice.FieldCustomerAddressState:
		m.ResetCustomerAddressState()
		return nil
	case billinginvoice.FieldCustomerAddressCity:
		m.ResetCustomerAddressCity()
		return nil
	case billinginvoice.FieldCustomerAddressLine1:
		m.ResetCustomerAddressLine1()
		return nil
	case billinginvoice.FieldCustomerAddressLine2:
		m.ResetCustomerAddressLine2()
		return nil
	case billinginvoice.FieldCustomerAddressPhoneNumber:
		m.ResetCustomerAddressPhoneNumber()
		return nil
	case billinginvoice.FieldAmount:
		m.ResetAmount()
		return nil
	case billinginvoice.FieldTaxesTotal:
		m.ResetTaxesTotal()
		return nil
	case billinginvoice.FieldTaxesInclusiveTotal:
		m.ResetTaxesInclusiveTotal()
		return nil
	case billinginvoice.FieldTaxesExclusiveTotal:
		m.ResetTaxesExclusiveTotal()
		return nil
	case billinginvoice.FieldChargesTotal:
		m.ResetChargesTotal()
		return nil
	case billinginvoice.FieldDiscountsTotal:
		m.ResetDiscountsTotal()
		return nil
	case billinginvoice.FieldTotal:
		m.ResetTotal()
		return nil
	case billinginvoice.FieldSupplierName:
		m.ResetSupplierName()
		return nil
	case billinginvoice.FieldSupplierTaxCode:
		m.ResetSupplierTaxCode()
		return nil
	case billinginvoice.FieldCustomerName:
		m.ResetCustomerName()
		return nil
	case billinginvoice.FieldCustomerUsageAttribution:
		m.ResetCustomerUsageAttribution()
		return nil
	case billinginvoice.FieldNumber:
		m.ResetNumber()
		return nil
	case billinginvoice.FieldType:
		m.ResetType()
		return nil
	case billinginvoice.FieldDescription:
		m.ResetDescription()
		return nil
	case billinginvoice.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case billinginvoice.FieldSourceBillingProfileID:
		m.ResetSourceBillingProfileID()
		return nil
	case billinginvoice.FieldVoidedAt:
		m.ResetVoidedAt()
		return nil
	case billinginvoice.FieldIssuedAt:
		m.ResetIssuedAt()
		return nil
	case billinginvoice.FieldSentToCustomerAt:
		m.ResetSentToCustomerAt()
		return nil
	case billinginvoice.FieldDraftUntil:
		m.ResetDraftUntil()
		return nil
	case billinginvoice.FieldQuantitySnapshotedAt:
		m.ResetQuantitySnapshotedAt()
		return nil
	case billinginvoice.FieldCurrency:
		m.ResetCurrency()
		return nil
	case billinginvoice.FieldDueAt:
		m.ResetDueAt()
		return nil
	case billinginvoice.FieldStatus:
		m.ResetStatus()
		return nil
	case billinginvoice.FieldStatusDetailsCache:
		m.ResetStatusDetailsCache()
		return nil
	case billinginvoice.FieldWorkflowConfigID:
		m.ResetWorkflowConfigID()
		return nil
	case billinginvoice.FieldTaxAppID:
		m.ResetTaxAppID()
		return nil
	case billinginvoice.FieldInvoicingAppID:
		m.ResetInvoicingAppID()
		return nil
	case billinginvoice.FieldPaymentAppID:
		m.ResetPaymentAppID()
		return nil
	case billinginvoice.FieldInvoicingAppExternalID:
		m.ResetInvoicingAppExternalID()
		return nil
	case billinginvoice.FieldPaymentAppExternalID:
		m.ResetPaymentAppExternalID()
		return nil
	case billinginvoice.FieldTaxAppExternalID:
		m.ResetTaxAppExternalID()
		return nil
	case billinginvoice.FieldPeriodStart:
		m.ResetPeriodStart()
		return nil
	case billinginvoice.FieldPeriodEnd:
		m.ResetPeriodEnd()
		return nil
	case billinginvoice.FieldCollectionAt:
		m.ResetCollectionAt()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.source_billing_profile != nil {
		edges = append(edges, billinginvoice.EdgeSourceBillingProfile)
	}
	if m.billing_workflow_config != nil {
		edges = append(edges, billinginvoice.EdgeBillingWorkflowConfig)
	}
	if m.billing_invoice_lines != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceLines)
	}
	if m.billing_invoice_validation_issues != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceValidationIssues)
	}
	if m.billing_invoice_customer != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceCustomer)
	}
	if m.tax_app != nil {
		edges = append(edges, billinginvoice.EdgeTaxApp)
	}
	if m.invoicing_app != nil {
		edges = append(edges, billinginvoice.EdgeInvoicingApp)
	}
	if m.payment_app != nil {
		edges = append(edges, billinginvoice.EdgePaymentApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billinginvoice.EdgeSourceBillingProfile:
		if id := m.source_billing_profile; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgeBillingWorkflowConfig:
		if id := m.billing_workflow_config; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgeBillingInvoiceLines:
		ids := make([]ent.Value, 0, len(m.billing_invoice_lines))
		for id := range m.billing_invoice_lines {
			ids = append(ids, id)
		}
		return ids
	case billinginvoice.EdgeBillingInvoiceValidationIssues:
		ids := make([]ent.Value, 0, len(m.billing_invoice_validation_issues))
		for id := range m.billing_invoice_validation_issues {
			ids = append(ids, id)
		}
		return ids
	case billinginvoice.EdgeBillingInvoiceCustomer:
		if id := m.billing_invoice_customer; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgeTaxApp:
		if id := m.tax_app; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgeInvoicingApp:
		if id := m.invoicing_app; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoice.EdgePaymentApp:
		if id := m.payment_app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedbilling_invoice_lines != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceLines)
	}
	if m.removedbilling_invoice_validation_issues != nil {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceValidationIssues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billinginvoice.EdgeBillingInvoiceLines:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_lines))
		for id := range m.removedbilling_invoice_lines {
			ids = append(ids, id)
		}
		return ids
	case billinginvoice.EdgeBillingInvoiceValidationIssues:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice_validation_issues))
		for id := range m.removedbilling_invoice_validation_issues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedsource_billing_profile {
		edges = append(edges, billinginvoice.EdgeSourceBillingProfile)
	}
	if m.clearedbilling_workflow_config {
		edges = append(edges, billinginvoice.EdgeBillingWorkflowConfig)
	}
	if m.clearedbilling_invoice_lines {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceLines)
	}
	if m.clearedbilling_invoice_validation_issues {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceValidationIssues)
	}
	if m.clearedbilling_invoice_customer {
		edges = append(edges, billinginvoice.EdgeBillingInvoiceCustomer)
	}
	if m.clearedtax_app {
		edges = append(edges, billinginvoice.EdgeTaxApp)
	}
	if m.clearedinvoicing_app {
		edges = append(edges, billinginvoice.EdgeInvoicingApp)
	}
	if m.clearedpayment_app {
		edges = append(edges, billinginvoice.EdgePaymentApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case billinginvoice.EdgeSourceBillingProfile:
		return m.clearedsource_billing_profile
	case billinginvoice.EdgeBillingWorkflowConfig:
		return m.clearedbilling_workflow_config
	case billinginvoice.EdgeBillingInvoiceLines:
		return m.clearedbilling_invoice_lines
	case billinginvoice.EdgeBillingInvoiceValidationIssues:
		return m.clearedbilling_invoice_validation_issues
	case billinginvoice.EdgeBillingInvoiceCustomer:
		return m.clearedbilling_invoice_customer
	case billinginvoice.EdgeTaxApp:
		return m.clearedtax_app
	case billinginvoice.EdgeInvoicingApp:
		return m.clearedinvoicing_app
	case billinginvoice.EdgePaymentApp:
		return m.clearedpayment_app
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceMutation) ClearEdge(name string) error {
	switch name {
	case billinginvoice.EdgeSourceBillingProfile:
		m.ClearSourceBillingProfile()
		return nil
	case billinginvoice.EdgeBillingWorkflowConfig:
		m.ClearBillingWorkflowConfig()
		return nil
	case billinginvoice.EdgeBillingInvoiceCustomer:
		m.ClearBillingInvoiceCustomer()
		return nil
	case billinginvoice.EdgeTaxApp:
		m.ClearTaxApp()
		return nil
	case billinginvoice.EdgeInvoicingApp:
		m.ClearInvoicingApp()
		return nil
	case billinginvoice.EdgePaymentApp:
		m.ClearPaymentApp()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceMutation) ResetEdge(name string) error {
	switch name {
	case billinginvoice.EdgeSourceBillingProfile:
		m.ResetSourceBillingProfile()
		return nil
	case billinginvoice.EdgeBillingWorkflowConfig:
		m.ResetBillingWorkflowConfig()
		return nil
	case billinginvoice.EdgeBillingInvoiceLines:
		m.ResetBillingInvoiceLines()
		return nil
	case billinginvoice.EdgeBillingInvoiceValidationIssues:
		m.ResetBillingInvoiceValidationIssues()
		return nil
	case billinginvoice.EdgeBillingInvoiceCustomer:
		m.ResetBillingInvoiceCustomer()
		return nil
	case billinginvoice.EdgeTaxApp:
		m.ResetTaxApp()
		return nil
	case billinginvoice.EdgeInvoicingApp:
		m.ResetInvoicingApp()
		return nil
	case billinginvoice.EdgePaymentApp:
		m.ResetPaymentApp()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoice edge %s", name)
}

// BillingInvoiceFlatFeeLineConfigMutation represents an operation that mutates the BillingInvoiceFlatFeeLineConfig nodes in the graph.
type BillingInvoiceFlatFeeLineConfigMutation struct {
	config
	op              Op
	typ             string
	id              *string
	namespace       *string
	per_unit_amount *alpacadecimal.Decimal
	category        *billing.FlatFeeCategory
	payment_term    *productcatalog.PaymentTermType
	index           *int
	addindex        *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*BillingInvoiceFlatFeeLineConfig, error)
	predicates      []predicate.BillingInvoiceFlatFeeLineConfig
}

var _ ent.Mutation = (*BillingInvoiceFlatFeeLineConfigMutation)(nil)

// billinginvoiceflatfeelineconfigOption allows management of the mutation configuration using functional options.
type billinginvoiceflatfeelineconfigOption func(*BillingInvoiceFlatFeeLineConfigMutation)

// newBillingInvoiceFlatFeeLineConfigMutation creates new mutation for the BillingInvoiceFlatFeeLineConfig entity.
func newBillingInvoiceFlatFeeLineConfigMutation(c config, op Op, opts ...billinginvoiceflatfeelineconfigOption) *BillingInvoiceFlatFeeLineConfigMutation {
	m := &BillingInvoiceFlatFeeLineConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoiceFlatFeeLineConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceFlatFeeLineConfigID sets the ID field of the mutation.
func withBillingInvoiceFlatFeeLineConfigID(id string) billinginvoiceflatfeelineconfigOption {
	return func(m *BillingInvoiceFlatFeeLineConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoiceFlatFeeLineConfig
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoiceFlatFeeLineConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoiceFlatFeeLineConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoiceFlatFeeLineConfig sets the old BillingInvoiceFlatFeeLineConfig of the mutation.
func withBillingInvoiceFlatFeeLineConfig(node *BillingInvoiceFlatFeeLineConfig) billinginvoiceflatfeelineconfigOption {
	return func(m *BillingInvoiceFlatFeeLineConfigMutation) {
		m.oldValue = func(context.Context) (*BillingInvoiceFlatFeeLineConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceFlatFeeLineConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceFlatFeeLineConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoiceFlatFeeLineConfig entities.
func (m *BillingInvoiceFlatFeeLineConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoiceFlatFeeLineConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoiceFlatFeeLineConfig entity.
// If the BillingInvoiceFlatFeeLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceFlatFeeLineConfigMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ResetNamespace() {
	m.namespace = nil
}

// SetPerUnitAmount sets the "per_unit_amount" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) SetPerUnitAmount(a alpacadecimal.Decimal) {
	m.per_unit_amount = &a
}

// PerUnitAmount returns the value of the "per_unit_amount" field in the mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) PerUnitAmount() (r alpacadecimal.Decimal, exists bool) {
	v := m.per_unit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPerUnitAmount returns the old "per_unit_amount" field's value of the BillingInvoiceFlatFeeLineConfig entity.
// If the BillingInvoiceFlatFeeLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceFlatFeeLineConfigMutation) OldPerUnitAmount(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerUnitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerUnitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerUnitAmount: %w", err)
	}
	return oldValue.PerUnitAmount, nil
}

// ResetPerUnitAmount resets all changes to the "per_unit_amount" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ResetPerUnitAmount() {
	m.per_unit_amount = nil
}

// SetCategory sets the "category" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) SetCategory(bfc billing.FlatFeeCategory) {
	m.category = &bfc
}

// Category returns the value of the "category" field in the mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) Category() (r billing.FlatFeeCategory, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the BillingInvoiceFlatFeeLineConfig entity.
// If the BillingInvoiceFlatFeeLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceFlatFeeLineConfigMutation) OldCategory(ctx context.Context) (v billing.FlatFeeCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ResetCategory() {
	m.category = nil
}

// SetPaymentTerm sets the "payment_term" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) SetPaymentTerm(ptt productcatalog.PaymentTermType) {
	m.payment_term = &ptt
}

// PaymentTerm returns the value of the "payment_term" field in the mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) PaymentTerm() (r productcatalog.PaymentTermType, exists bool) {
	v := m.payment_term
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentTerm returns the old "payment_term" field's value of the BillingInvoiceFlatFeeLineConfig entity.
// If the BillingInvoiceFlatFeeLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceFlatFeeLineConfigMutation) OldPaymentTerm(ctx context.Context) (v productcatalog.PaymentTermType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentTerm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentTerm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentTerm: %w", err)
	}
	return oldValue.PaymentTerm, nil
}

// ResetPaymentTerm resets all changes to the "payment_term" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ResetPaymentTerm() {
	m.payment_term = nil
}

// SetIndex sets the "index" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the BillingInvoiceFlatFeeLineConfig entity.
// If the BillingInvoiceFlatFeeLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceFlatFeeLineConfigMutation) OldIndex(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of the "index" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[billinginvoiceflatfeelineconfig.FieldIndex] = struct{}{}
}

// IndexCleared returns if the "index" field was cleared in this mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) IndexCleared() bool {
	_, ok := m.clearedFields[billinginvoiceflatfeelineconfig.FieldIndex]
	return ok
}

// ResetIndex resets all changes to the "index" field.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, billinginvoiceflatfeelineconfig.FieldIndex)
}

// Where appends a list predicates to the BillingInvoiceFlatFeeLineConfigMutation builder.
func (m *BillingInvoiceFlatFeeLineConfigMutation) Where(ps ...predicate.BillingInvoiceFlatFeeLineConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceFlatFeeLineConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceFlatFeeLineConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoiceFlatFeeLineConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceFlatFeeLineConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoiceFlatFeeLineConfig).
func (m *BillingInvoiceFlatFeeLineConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceFlatFeeLineConfigMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.namespace != nil {
		fields = append(fields, billinginvoiceflatfeelineconfig.FieldNamespace)
	}
	if m.per_unit_amount != nil {
		fields = append(fields, billinginvoiceflatfeelineconfig.FieldPerUnitAmount)
	}
	if m.category != nil {
		fields = append(fields, billinginvoiceflatfeelineconfig.FieldCategory)
	}
	if m.payment_term != nil {
		fields = append(fields, billinginvoiceflatfeelineconfig.FieldPaymentTerm)
	}
	if m.index != nil {
		fields = append(fields, billinginvoiceflatfeelineconfig.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceFlatFeeLineConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoiceflatfeelineconfig.FieldNamespace:
		return m.Namespace()
	case billinginvoiceflatfeelineconfig.FieldPerUnitAmount:
		return m.PerUnitAmount()
	case billinginvoiceflatfeelineconfig.FieldCategory:
		return m.Category()
	case billinginvoiceflatfeelineconfig.FieldPaymentTerm:
		return m.PaymentTerm()
	case billinginvoiceflatfeelineconfig.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceFlatFeeLineConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoiceflatfeelineconfig.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoiceflatfeelineconfig.FieldPerUnitAmount:
		return m.OldPerUnitAmount(ctx)
	case billinginvoiceflatfeelineconfig.FieldCategory:
		return m.OldCategory(ctx)
	case billinginvoiceflatfeelineconfig.FieldPaymentTerm:
		return m.OldPaymentTerm(ctx)
	case billinginvoiceflatfeelineconfig.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoiceFlatFeeLineConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceFlatFeeLineConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoiceflatfeelineconfig.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoiceflatfeelineconfig.FieldPerUnitAmount:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerUnitAmount(v)
		return nil
	case billinginvoiceflatfeelineconfig.FieldCategory:
		v, ok := value.(billing.FlatFeeCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case billinginvoiceflatfeelineconfig.FieldPaymentTerm:
		v, ok := value.(productcatalog.PaymentTermType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentTerm(v)
		return nil
	case billinginvoiceflatfeelineconfig.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceFlatFeeLineConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, billinginvoiceflatfeelineconfig.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceFlatFeeLineConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case billinginvoiceflatfeelineconfig.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceFlatFeeLineConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case billinginvoiceflatfeelineconfig.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceFlatFeeLineConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoiceflatfeelineconfig.FieldIndex) {
		fields = append(fields, billinginvoiceflatfeelineconfig.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ClearField(name string) error {
	switch name {
	case billinginvoiceflatfeelineconfig.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceFlatFeeLineConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ResetField(name string) error {
	switch name {
	case billinginvoiceflatfeelineconfig.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoiceflatfeelineconfig.FieldPerUnitAmount:
		m.ResetPerUnitAmount()
		return nil
	case billinginvoiceflatfeelineconfig.FieldCategory:
		m.ResetCategory()
		return nil
	case billinginvoiceflatfeelineconfig.FieldPaymentTerm:
		m.ResetPaymentTerm()
		return nil
	case billinginvoiceflatfeelineconfig.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceFlatFeeLineConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceFlatFeeLineConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BillingInvoiceFlatFeeLineConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceFlatFeeLineConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BillingInvoiceFlatFeeLineConfig edge %s", name)
}

// BillingInvoiceLineMutation represents an operation that mutates the BillingInvoiceLine nodes in the graph.
type BillingInvoiceLineMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	namespace                    *string
	metadata                     *map[string]string
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	name                         *string
	description                  *string
	amount                       *alpacadecimal.Decimal
	taxes_total                  *alpacadecimal.Decimal
	taxes_inclusive_total        *alpacadecimal.Decimal
	taxes_exclusive_total        *alpacadecimal.Decimal
	charges_total                *alpacadecimal.Decimal
	discounts_total              *alpacadecimal.Decimal
	total                        *alpacadecimal.Decimal
	managed_by                   *billing.InvoiceLineManagedBy
	period_start                 *time.Time
	period_end                   *time.Time
	invoice_at                   *time.Time
	_type                        *billing.InvoiceLineType
	status                       *billing.InvoiceLineStatus
	currency                     *currencyx.Code
	quantity                     *alpacadecimal.Decimal
	tax_config                   *productcatalog.TaxConfig
	ratecard_discounts           **billing.Discounts
	invoicing_app_external_id    *string
	child_unique_reference_id    *string
	line_ids                     *string
	clearedFields                map[string]struct{}
	billing_invoice              *string
	clearedbilling_invoice       bool
	flat_fee_line                *string
	clearedflat_fee_line         bool
	usage_based_line             *string
	clearedusage_based_line      bool
	parent_line                  *string
	clearedparent_line           bool
	detailed_lines               map[string]struct{}
	removeddetailed_lines        map[string]struct{}
	cleareddetailed_lines        bool
	line_usage_discounts         map[string]struct{}
	removedline_usage_discounts  map[string]struct{}
	clearedline_usage_discounts  bool
	line_amount_discounts        map[string]struct{}
	removedline_amount_discounts map[string]struct{}
	clearedline_amount_discounts bool
	subscription                 *string
	clearedsubscription          bool
	subscription_phase           *string
	clearedsubscription_phase    bool
	subscription_item            *string
	clearedsubscription_item     bool
	done                         bool
	oldValue                     func(context.Context) (*BillingInvoiceLine, error)
	predicates                   []predicate.BillingInvoiceLine
}

var _ ent.Mutation = (*BillingInvoiceLineMutation)(nil)

// billinginvoicelineOption allows management of the mutation configuration using functional options.
type billinginvoicelineOption func(*BillingInvoiceLineMutation)

// newBillingInvoiceLineMutation creates new mutation for the BillingInvoiceLine entity.
func newBillingInvoiceLineMutation(c config, op Op, opts ...billinginvoicelineOption) *BillingInvoiceLineMutation {
	m := &BillingInvoiceLineMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoiceLine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceLineID sets the ID field of the mutation.
func withBillingInvoiceLineID(id string) billinginvoicelineOption {
	return func(m *BillingInvoiceLineMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoiceLine
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoiceLine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoiceLine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoiceLine sets the old BillingInvoiceLine of the mutation.
func withBillingInvoiceLine(node *BillingInvoiceLine) billinginvoicelineOption {
	return func(m *BillingInvoiceLineMutation) {
		m.oldValue = func(context.Context) (*BillingInvoiceLine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceLineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceLineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoiceLine entities.
func (m *BillingInvoiceLineMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceLineMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceLineMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoiceLine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceLineMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceLineMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceLineMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *BillingInvoiceLineMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *BillingInvoiceLineMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *BillingInvoiceLineMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[billinginvoiceline.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *BillingInvoiceLineMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, billinginvoiceline.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingInvoiceLineMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingInvoiceLineMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingInvoiceLineMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingInvoiceLineMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingInvoiceLineMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingInvoiceLineMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingInvoiceLineMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingInvoiceLineMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingInvoiceLineMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billinginvoiceline.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingInvoiceLineMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billinginvoiceline.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BillingInvoiceLineMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BillingInvoiceLineMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BillingInvoiceLineMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BillingInvoiceLineMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BillingInvoiceLineMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BillingInvoiceLineMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[billinginvoiceline.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BillingInvoiceLineMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, billinginvoiceline.FieldDescription)
}

// SetAmount sets the "amount" field.
func (m *BillingInvoiceLineMutation) SetAmount(a alpacadecimal.Decimal) {
	m.amount = &a
}

// Amount returns the value of the "amount" field in the mutation.
func (m *BillingInvoiceLineMutation) Amount() (r alpacadecimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldAmount(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *BillingInvoiceLineMutation) ResetAmount() {
	m.amount = nil
}

// SetTaxesTotal sets the "taxes_total" field.
func (m *BillingInvoiceLineMutation) SetTaxesTotal(a alpacadecimal.Decimal) {
	m.taxes_total = &a
}

// TaxesTotal returns the value of the "taxes_total" field in the mutation.
func (m *BillingInvoiceLineMutation) TaxesTotal() (r alpacadecimal.Decimal, exists bool) {
	v := m.taxes_total
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxesTotal returns the old "taxes_total" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldTaxesTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxesTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxesTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxesTotal: %w", err)
	}
	return oldValue.TaxesTotal, nil
}

// ResetTaxesTotal resets all changes to the "taxes_total" field.
func (m *BillingInvoiceLineMutation) ResetTaxesTotal() {
	m.taxes_total = nil
}

// SetTaxesInclusiveTotal sets the "taxes_inclusive_total" field.
func (m *BillingInvoiceLineMutation) SetTaxesInclusiveTotal(a alpacadecimal.Decimal) {
	m.taxes_inclusive_total = &a
}

// TaxesInclusiveTotal returns the value of the "taxes_inclusive_total" field in the mutation.
func (m *BillingInvoiceLineMutation) TaxesInclusiveTotal() (r alpacadecimal.Decimal, exists bool) {
	v := m.taxes_inclusive_total
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxesInclusiveTotal returns the old "taxes_inclusive_total" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldTaxesInclusiveTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxesInclusiveTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxesInclusiveTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxesInclusiveTotal: %w", err)
	}
	return oldValue.TaxesInclusiveTotal, nil
}

// ResetTaxesInclusiveTotal resets all changes to the "taxes_inclusive_total" field.
func (m *BillingInvoiceLineMutation) ResetTaxesInclusiveTotal() {
	m.taxes_inclusive_total = nil
}

// SetTaxesExclusiveTotal sets the "taxes_exclusive_total" field.
func (m *BillingInvoiceLineMutation) SetTaxesExclusiveTotal(a alpacadecimal.Decimal) {
	m.taxes_exclusive_total = &a
}

// TaxesExclusiveTotal returns the value of the "taxes_exclusive_total" field in the mutation.
func (m *BillingInvoiceLineMutation) TaxesExclusiveTotal() (r alpacadecimal.Decimal, exists bool) {
	v := m.taxes_exclusive_total
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxesExclusiveTotal returns the old "taxes_exclusive_total" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldTaxesExclusiveTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxesExclusiveTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxesExclusiveTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxesExclusiveTotal: %w", err)
	}
	return oldValue.TaxesExclusiveTotal, nil
}

// ResetTaxesExclusiveTotal resets all changes to the "taxes_exclusive_total" field.
func (m *BillingInvoiceLineMutation) ResetTaxesExclusiveTotal() {
	m.taxes_exclusive_total = nil
}

// SetChargesTotal sets the "charges_total" field.
func (m *BillingInvoiceLineMutation) SetChargesTotal(a alpacadecimal.Decimal) {
	m.charges_total = &a
}

// ChargesTotal returns the value of the "charges_total" field in the mutation.
func (m *BillingInvoiceLineMutation) ChargesTotal() (r alpacadecimal.Decimal, exists bool) {
	v := m.charges_total
	if v == nil {
		return
	}
	return *v, true
}

// OldChargesTotal returns the old "charges_total" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldChargesTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargesTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargesTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargesTotal: %w", err)
	}
	return oldValue.ChargesTotal, nil
}

// ResetChargesTotal resets all changes to the "charges_total" field.
func (m *BillingInvoiceLineMutation) ResetChargesTotal() {
	m.charges_total = nil
}

// SetDiscountsTotal sets the "discounts_total" field.
func (m *BillingInvoiceLineMutation) SetDiscountsTotal(a alpacadecimal.Decimal) {
	m.discounts_total = &a
}

// DiscountsTotal returns the value of the "discounts_total" field in the mutation.
func (m *BillingInvoiceLineMutation) DiscountsTotal() (r alpacadecimal.Decimal, exists bool) {
	v := m.discounts_total
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountsTotal returns the old "discounts_total" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldDiscountsTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountsTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountsTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountsTotal: %w", err)
	}
	return oldValue.DiscountsTotal, nil
}

// ResetDiscountsTotal resets all changes to the "discounts_total" field.
func (m *BillingInvoiceLineMutation) ResetDiscountsTotal() {
	m.discounts_total = nil
}

// SetTotal sets the "total" field.
func (m *BillingInvoiceLineMutation) SetTotal(a alpacadecimal.Decimal) {
	m.total = &a
}

// Total returns the value of the "total" field in the mutation.
func (m *BillingInvoiceLineMutation) Total() (r alpacadecimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldTotal(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// ResetTotal resets all changes to the "total" field.
func (m *BillingInvoiceLineMutation) ResetTotal() {
	m.total = nil
}

// SetInvoiceID sets the "invoice_id" field.
func (m *BillingInvoiceLineMutation) SetInvoiceID(s string) {
	m.billing_invoice = &s
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *BillingInvoiceLineMutation) InvoiceID() (r string, exists bool) {
	v := m.billing_invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldInvoiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *BillingInvoiceLineMutation) ResetInvoiceID() {
	m.billing_invoice = nil
}

// SetManagedBy sets the "managed_by" field.
func (m *BillingInvoiceLineMutation) SetManagedBy(blmb billing.InvoiceLineManagedBy) {
	m.managed_by = &blmb
}

// ManagedBy returns the value of the "managed_by" field in the mutation.
func (m *BillingInvoiceLineMutation) ManagedBy() (r billing.InvoiceLineManagedBy, exists bool) {
	v := m.managed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldManagedBy returns the old "managed_by" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldManagedBy(ctx context.Context) (v billing.InvoiceLineManagedBy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagedBy: %w", err)
	}
	return oldValue.ManagedBy, nil
}

// ResetManagedBy resets all changes to the "managed_by" field.
func (m *BillingInvoiceLineMutation) ResetManagedBy() {
	m.managed_by = nil
}

// SetParentLineID sets the "parent_line_id" field.
func (m *BillingInvoiceLineMutation) SetParentLineID(s string) {
	m.parent_line = &s
}

// ParentLineID returns the value of the "parent_line_id" field in the mutation.
func (m *BillingInvoiceLineMutation) ParentLineID() (r string, exists bool) {
	v := m.parent_line
	if v == nil {
		return
	}
	return *v, true
}

// OldParentLineID returns the old "parent_line_id" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldParentLineID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentLineID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentLineID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentLineID: %w", err)
	}
	return oldValue.ParentLineID, nil
}

// ClearParentLineID clears the value of the "parent_line_id" field.
func (m *BillingInvoiceLineMutation) ClearParentLineID() {
	m.parent_line = nil
	m.clearedFields[billinginvoiceline.FieldParentLineID] = struct{}{}
}

// ParentLineIDCleared returns if the "parent_line_id" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) ParentLineIDCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldParentLineID]
	return ok
}

// ResetParentLineID resets all changes to the "parent_line_id" field.
func (m *BillingInvoiceLineMutation) ResetParentLineID() {
	m.parent_line = nil
	delete(m.clearedFields, billinginvoiceline.FieldParentLineID)
}

// SetPeriodStart sets the "period_start" field.
func (m *BillingInvoiceLineMutation) SetPeriodStart(t time.Time) {
	m.period_start = &t
}

// PeriodStart returns the value of the "period_start" field in the mutation.
func (m *BillingInvoiceLineMutation) PeriodStart() (r time.Time, exists bool) {
	v := m.period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodStart returns the old "period_start" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldPeriodStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodStart: %w", err)
	}
	return oldValue.PeriodStart, nil
}

// ResetPeriodStart resets all changes to the "period_start" field.
func (m *BillingInvoiceLineMutation) ResetPeriodStart() {
	m.period_start = nil
}

// SetPeriodEnd sets the "period_end" field.
func (m *BillingInvoiceLineMutation) SetPeriodEnd(t time.Time) {
	m.period_end = &t
}

// PeriodEnd returns the value of the "period_end" field in the mutation.
func (m *BillingInvoiceLineMutation) PeriodEnd() (r time.Time, exists bool) {
	v := m.period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodEnd returns the old "period_end" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldPeriodEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodEnd: %w", err)
	}
	return oldValue.PeriodEnd, nil
}

// ResetPeriodEnd resets all changes to the "period_end" field.
func (m *BillingInvoiceLineMutation) ResetPeriodEnd() {
	m.period_end = nil
}

// SetInvoiceAt sets the "invoice_at" field.
func (m *BillingInvoiceLineMutation) SetInvoiceAt(t time.Time) {
	m.invoice_at = &t
}

// InvoiceAt returns the value of the "invoice_at" field in the mutation.
func (m *BillingInvoiceLineMutation) InvoiceAt() (r time.Time, exists bool) {
	v := m.invoice_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceAt returns the old "invoice_at" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldInvoiceAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceAt: %w", err)
	}
	return oldValue.InvoiceAt, nil
}

// ResetInvoiceAt resets all changes to the "invoice_at" field.
func (m *BillingInvoiceLineMutation) ResetInvoiceAt() {
	m.invoice_at = nil
}

// SetType sets the "type" field.
func (m *BillingInvoiceLineMutation) SetType(blt billing.InvoiceLineType) {
	m._type = &blt
}

// GetType returns the value of the "type" field in the mutation.
func (m *BillingInvoiceLineMutation) GetType() (r billing.InvoiceLineType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldType(ctx context.Context) (v billing.InvoiceLineType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BillingInvoiceLineMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *BillingInvoiceLineMutation) SetStatus(bls billing.InvoiceLineStatus) {
	m.status = &bls
}

// Status returns the value of the "status" field in the mutation.
func (m *BillingInvoiceLineMutation) Status() (r billing.InvoiceLineStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldStatus(ctx context.Context) (v billing.InvoiceLineStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BillingInvoiceLineMutation) ResetStatus() {
	m.status = nil
}

// SetCurrency sets the "currency" field.
func (m *BillingInvoiceLineMutation) SetCurrency(c currencyx.Code) {
	m.currency = &c
}

// Currency returns the value of the "currency" field in the mutation.
func (m *BillingInvoiceLineMutation) Currency() (r currencyx.Code, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldCurrency(ctx context.Context) (v currencyx.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *BillingInvoiceLineMutation) ResetCurrency() {
	m.currency = nil
}

// SetQuantity sets the "quantity" field.
func (m *BillingInvoiceLineMutation) SetQuantity(a alpacadecimal.Decimal) {
	m.quantity = &a
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *BillingInvoiceLineMutation) Quantity() (r alpacadecimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldQuantity(ctx context.Context) (v *alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ClearQuantity clears the value of the "quantity" field.
func (m *BillingInvoiceLineMutation) ClearQuantity() {
	m.quantity = nil
	m.clearedFields[billinginvoiceline.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *BillingInvoiceLineMutation) ResetQuantity() {
	m.quantity = nil
	delete(m.clearedFields, billinginvoiceline.FieldQuantity)
}

// SetTaxConfig sets the "tax_config" field.
func (m *BillingInvoiceLineMutation) SetTaxConfig(pc productcatalog.TaxConfig) {
	m.tax_config = &pc
}

// TaxConfig returns the value of the "tax_config" field in the mutation.
func (m *BillingInvoiceLineMutation) TaxConfig() (r productcatalog.TaxConfig, exists bool) {
	v := m.tax_config
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxConfig returns the old "tax_config" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldTaxConfig(ctx context.Context) (v productcatalog.TaxConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxConfig: %w", err)
	}
	return oldValue.TaxConfig, nil
}

// ClearTaxConfig clears the value of the "tax_config" field.
func (m *BillingInvoiceLineMutation) ClearTaxConfig() {
	m.tax_config = nil
	m.clearedFields[billinginvoiceline.FieldTaxConfig] = struct{}{}
}

// TaxConfigCleared returns if the "tax_config" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) TaxConfigCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldTaxConfig]
	return ok
}

// ResetTaxConfig resets all changes to the "tax_config" field.
func (m *BillingInvoiceLineMutation) ResetTaxConfig() {
	m.tax_config = nil
	delete(m.clearedFields, billinginvoiceline.FieldTaxConfig)
}

// SetRatecardDiscounts sets the "ratecard_discounts" field.
func (m *BillingInvoiceLineMutation) SetRatecardDiscounts(b *billing.Discounts) {
	m.ratecard_discounts = &b
}

// RatecardDiscounts returns the value of the "ratecard_discounts" field in the mutation.
func (m *BillingInvoiceLineMutation) RatecardDiscounts() (r *billing.Discounts, exists bool) {
	v := m.ratecard_discounts
	if v == nil {
		return
	}
	return *v, true
}

// OldRatecardDiscounts returns the old "ratecard_discounts" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldRatecardDiscounts(ctx context.Context) (v *billing.Discounts, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatecardDiscounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatecardDiscounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatecardDiscounts: %w", err)
	}
	return oldValue.RatecardDiscounts, nil
}

// ClearRatecardDiscounts clears the value of the "ratecard_discounts" field.
func (m *BillingInvoiceLineMutation) ClearRatecardDiscounts() {
	m.ratecard_discounts = nil
	m.clearedFields[billinginvoiceline.FieldRatecardDiscounts] = struct{}{}
}

// RatecardDiscountsCleared returns if the "ratecard_discounts" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) RatecardDiscountsCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldRatecardDiscounts]
	return ok
}

// ResetRatecardDiscounts resets all changes to the "ratecard_discounts" field.
func (m *BillingInvoiceLineMutation) ResetRatecardDiscounts() {
	m.ratecard_discounts = nil
	delete(m.clearedFields, billinginvoiceline.FieldRatecardDiscounts)
}

// SetInvoicingAppExternalID sets the "invoicing_app_external_id" field.
func (m *BillingInvoiceLineMutation) SetInvoicingAppExternalID(s string) {
	m.invoicing_app_external_id = &s
}

// InvoicingAppExternalID returns the value of the "invoicing_app_external_id" field in the mutation.
func (m *BillingInvoiceLineMutation) InvoicingAppExternalID() (r string, exists bool) {
	v := m.invoicing_app_external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingAppExternalID returns the old "invoicing_app_external_id" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldInvoicingAppExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingAppExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingAppExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingAppExternalID: %w", err)
	}
	return oldValue.InvoicingAppExternalID, nil
}

// ClearInvoicingAppExternalID clears the value of the "invoicing_app_external_id" field.
func (m *BillingInvoiceLineMutation) ClearInvoicingAppExternalID() {
	m.invoicing_app_external_id = nil
	m.clearedFields[billinginvoiceline.FieldInvoicingAppExternalID] = struct{}{}
}

// InvoicingAppExternalIDCleared returns if the "invoicing_app_external_id" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) InvoicingAppExternalIDCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldInvoicingAppExternalID]
	return ok
}

// ResetInvoicingAppExternalID resets all changes to the "invoicing_app_external_id" field.
func (m *BillingInvoiceLineMutation) ResetInvoicingAppExternalID() {
	m.invoicing_app_external_id = nil
	delete(m.clearedFields, billinginvoiceline.FieldInvoicingAppExternalID)
}

// SetChildUniqueReferenceID sets the "child_unique_reference_id" field.
func (m *BillingInvoiceLineMutation) SetChildUniqueReferenceID(s string) {
	m.child_unique_reference_id = &s
}

// ChildUniqueReferenceID returns the value of the "child_unique_reference_id" field in the mutation.
func (m *BillingInvoiceLineMutation) ChildUniqueReferenceID() (r string, exists bool) {
	v := m.child_unique_reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildUniqueReferenceID returns the old "child_unique_reference_id" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldChildUniqueReferenceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildUniqueReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildUniqueReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildUniqueReferenceID: %w", err)
	}
	return oldValue.ChildUniqueReferenceID, nil
}

// ClearChildUniqueReferenceID clears the value of the "child_unique_reference_id" field.
func (m *BillingInvoiceLineMutation) ClearChildUniqueReferenceID() {
	m.child_unique_reference_id = nil
	m.clearedFields[billinginvoiceline.FieldChildUniqueReferenceID] = struct{}{}
}

// ChildUniqueReferenceIDCleared returns if the "child_unique_reference_id" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) ChildUniqueReferenceIDCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldChildUniqueReferenceID]
	return ok
}

// ResetChildUniqueReferenceID resets all changes to the "child_unique_reference_id" field.
func (m *BillingInvoiceLineMutation) ResetChildUniqueReferenceID() {
	m.child_unique_reference_id = nil
	delete(m.clearedFields, billinginvoiceline.FieldChildUniqueReferenceID)
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *BillingInvoiceLineMutation) SetSubscriptionID(s string) {
	m.subscription = &s
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *BillingInvoiceLineMutation) SubscriptionID() (r string, exists bool) {
	v := m.subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldSubscriptionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ClearSubscriptionID clears the value of the "subscription_id" field.
func (m *BillingInvoiceLineMutation) ClearSubscriptionID() {
	m.subscription = nil
	m.clearedFields[billinginvoiceline.FieldSubscriptionID] = struct{}{}
}

// SubscriptionIDCleared returns if the "subscription_id" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) SubscriptionIDCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldSubscriptionID]
	return ok
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *BillingInvoiceLineMutation) ResetSubscriptionID() {
	m.subscription = nil
	delete(m.clearedFields, billinginvoiceline.FieldSubscriptionID)
}

// SetSubscriptionPhaseID sets the "subscription_phase_id" field.
func (m *BillingInvoiceLineMutation) SetSubscriptionPhaseID(s string) {
	m.subscription_phase = &s
}

// SubscriptionPhaseID returns the value of the "subscription_phase_id" field in the mutation.
func (m *BillingInvoiceLineMutation) SubscriptionPhaseID() (r string, exists bool) {
	v := m.subscription_phase
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionPhaseID returns the old "subscription_phase_id" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldSubscriptionPhaseID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionPhaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionPhaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionPhaseID: %w", err)
	}
	return oldValue.SubscriptionPhaseID, nil
}

// ClearSubscriptionPhaseID clears the value of the "subscription_phase_id" field.
func (m *BillingInvoiceLineMutation) ClearSubscriptionPhaseID() {
	m.subscription_phase = nil
	m.clearedFields[billinginvoiceline.FieldSubscriptionPhaseID] = struct{}{}
}

// SubscriptionPhaseIDCleared returns if the "subscription_phase_id" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) SubscriptionPhaseIDCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldSubscriptionPhaseID]
	return ok
}

// ResetSubscriptionPhaseID resets all changes to the "subscription_phase_id" field.
func (m *BillingInvoiceLineMutation) ResetSubscriptionPhaseID() {
	m.subscription_phase = nil
	delete(m.clearedFields, billinginvoiceline.FieldSubscriptionPhaseID)
}

// SetSubscriptionItemID sets the "subscription_item_id" field.
func (m *BillingInvoiceLineMutation) SetSubscriptionItemID(s string) {
	m.subscription_item = &s
}

// SubscriptionItemID returns the value of the "subscription_item_id" field in the mutation.
func (m *BillingInvoiceLineMutation) SubscriptionItemID() (r string, exists bool) {
	v := m.subscription_item
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionItemID returns the old "subscription_item_id" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldSubscriptionItemID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionItemID: %w", err)
	}
	return oldValue.SubscriptionItemID, nil
}

// ClearSubscriptionItemID clears the value of the "subscription_item_id" field.
func (m *BillingInvoiceLineMutation) ClearSubscriptionItemID() {
	m.subscription_item = nil
	m.clearedFields[billinginvoiceline.FieldSubscriptionItemID] = struct{}{}
}

// SubscriptionItemIDCleared returns if the "subscription_item_id" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) SubscriptionItemIDCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldSubscriptionItemID]
	return ok
}

// ResetSubscriptionItemID resets all changes to the "subscription_item_id" field.
func (m *BillingInvoiceLineMutation) ResetSubscriptionItemID() {
	m.subscription_item = nil
	delete(m.clearedFields, billinginvoiceline.FieldSubscriptionItemID)
}

// SetLineIds sets the "line_ids" field.
func (m *BillingInvoiceLineMutation) SetLineIds(s string) {
	m.line_ids = &s
}

// LineIds returns the value of the "line_ids" field in the mutation.
func (m *BillingInvoiceLineMutation) LineIds() (r string, exists bool) {
	v := m.line_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldLineIds returns the old "line_ids" field's value of the BillingInvoiceLine entity.
// If the BillingInvoiceLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineMutation) OldLineIds(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineIds: %w", err)
	}
	return oldValue.LineIds, nil
}

// ClearLineIds clears the value of the "line_ids" field.
func (m *BillingInvoiceLineMutation) ClearLineIds() {
	m.line_ids = nil
	m.clearedFields[billinginvoiceline.FieldLineIds] = struct{}{}
}

// LineIdsCleared returns if the "line_ids" field was cleared in this mutation.
func (m *BillingInvoiceLineMutation) LineIdsCleared() bool {
	_, ok := m.clearedFields[billinginvoiceline.FieldLineIds]
	return ok
}

// ResetLineIds resets all changes to the "line_ids" field.
func (m *BillingInvoiceLineMutation) ResetLineIds() {
	m.line_ids = nil
	delete(m.clearedFields, billinginvoiceline.FieldLineIds)
}

// SetBillingInvoiceID sets the "billing_invoice" edge to the BillingInvoice entity by id.
func (m *BillingInvoiceLineMutation) SetBillingInvoiceID(id string) {
	m.billing_invoice = &id
}

// ClearBillingInvoice clears the "billing_invoice" edge to the BillingInvoice entity.
func (m *BillingInvoiceLineMutation) ClearBillingInvoice() {
	m.clearedbilling_invoice = true
	m.clearedFields[billinginvoiceline.FieldInvoiceID] = struct{}{}
}

// BillingInvoiceCleared reports if the "billing_invoice" edge to the BillingInvoice entity was cleared.
func (m *BillingInvoiceLineMutation) BillingInvoiceCleared() bool {
	return m.clearedbilling_invoice
}

// BillingInvoiceID returns the "billing_invoice" edge ID in the mutation.
func (m *BillingInvoiceLineMutation) BillingInvoiceID() (id string, exists bool) {
	if m.billing_invoice != nil {
		return *m.billing_invoice, true
	}
	return
}

// BillingInvoiceIDs returns the "billing_invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoiceID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineMutation) BillingInvoiceIDs() (ids []string) {
	if id := m.billing_invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoice resets all changes to the "billing_invoice" edge.
func (m *BillingInvoiceLineMutation) ResetBillingInvoice() {
	m.billing_invoice = nil
	m.clearedbilling_invoice = false
}

// SetFlatFeeLineID sets the "flat_fee_line" edge to the BillingInvoiceFlatFeeLineConfig entity by id.
func (m *BillingInvoiceLineMutation) SetFlatFeeLineID(id string) {
	m.flat_fee_line = &id
}

// ClearFlatFeeLine clears the "flat_fee_line" edge to the BillingInvoiceFlatFeeLineConfig entity.
func (m *BillingInvoiceLineMutation) ClearFlatFeeLine() {
	m.clearedflat_fee_line = true
}

// FlatFeeLineCleared reports if the "flat_fee_line" edge to the BillingInvoiceFlatFeeLineConfig entity was cleared.
func (m *BillingInvoiceLineMutation) FlatFeeLineCleared() bool {
	return m.clearedflat_fee_line
}

// FlatFeeLineID returns the "flat_fee_line" edge ID in the mutation.
func (m *BillingInvoiceLineMutation) FlatFeeLineID() (id string, exists bool) {
	if m.flat_fee_line != nil {
		return *m.flat_fee_line, true
	}
	return
}

// FlatFeeLineIDs returns the "flat_fee_line" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlatFeeLineID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineMutation) FlatFeeLineIDs() (ids []string) {
	if id := m.flat_fee_line; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlatFeeLine resets all changes to the "flat_fee_line" edge.
func (m *BillingInvoiceLineMutation) ResetFlatFeeLine() {
	m.flat_fee_line = nil
	m.clearedflat_fee_line = false
}

// SetUsageBasedLineID sets the "usage_based_line" edge to the BillingInvoiceUsageBasedLineConfig entity by id.
func (m *BillingInvoiceLineMutation) SetUsageBasedLineID(id string) {
	m.usage_based_line = &id
}

// ClearUsageBasedLine clears the "usage_based_line" edge to the BillingInvoiceUsageBasedLineConfig entity.
func (m *BillingInvoiceLineMutation) ClearUsageBasedLine() {
	m.clearedusage_based_line = true
}

// UsageBasedLineCleared reports if the "usage_based_line" edge to the BillingInvoiceUsageBasedLineConfig entity was cleared.
func (m *BillingInvoiceLineMutation) UsageBasedLineCleared() bool {
	return m.clearedusage_based_line
}

// UsageBasedLineID returns the "usage_based_line" edge ID in the mutation.
func (m *BillingInvoiceLineMutation) UsageBasedLineID() (id string, exists bool) {
	if m.usage_based_line != nil {
		return *m.usage_based_line, true
	}
	return
}

// UsageBasedLineIDs returns the "usage_based_line" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsageBasedLineID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineMutation) UsageBasedLineIDs() (ids []string) {
	if id := m.usage_based_line; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsageBasedLine resets all changes to the "usage_based_line" edge.
func (m *BillingInvoiceLineMutation) ResetUsageBasedLine() {
	m.usage_based_line = nil
	m.clearedusage_based_line = false
}

// ClearParentLine clears the "parent_line" edge to the BillingInvoiceLine entity.
func (m *BillingInvoiceLineMutation) ClearParentLine() {
	m.clearedparent_line = true
	m.clearedFields[billinginvoiceline.FieldParentLineID] = struct{}{}
}

// ParentLineCleared reports if the "parent_line" edge to the BillingInvoiceLine entity was cleared.
func (m *BillingInvoiceLineMutation) ParentLineCleared() bool {
	return m.ParentLineIDCleared() || m.clearedparent_line
}

// ParentLineIDs returns the "parent_line" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentLineID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineMutation) ParentLineIDs() (ids []string) {
	if id := m.parent_line; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentLine resets all changes to the "parent_line" edge.
func (m *BillingInvoiceLineMutation) ResetParentLine() {
	m.parent_line = nil
	m.clearedparent_line = false
}

// AddDetailedLineIDs adds the "detailed_lines" edge to the BillingInvoiceLine entity by ids.
func (m *BillingInvoiceLineMutation) AddDetailedLineIDs(ids ...string) {
	if m.detailed_lines == nil {
		m.detailed_lines = make(map[string]struct{})
	}
	for i := range ids {
		m.detailed_lines[ids[i]] = struct{}{}
	}
}

// ClearDetailedLines clears the "detailed_lines" edge to the BillingInvoiceLine entity.
func (m *BillingInvoiceLineMutation) ClearDetailedLines() {
	m.cleareddetailed_lines = true
}

// DetailedLinesCleared reports if the "detailed_lines" edge to the BillingInvoiceLine entity was cleared.
func (m *BillingInvoiceLineMutation) DetailedLinesCleared() bool {
	return m.cleareddetailed_lines
}

// RemoveDetailedLineIDs removes the "detailed_lines" edge to the BillingInvoiceLine entity by IDs.
func (m *BillingInvoiceLineMutation) RemoveDetailedLineIDs(ids ...string) {
	if m.removeddetailed_lines == nil {
		m.removeddetailed_lines = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.detailed_lines, ids[i])
		m.removeddetailed_lines[ids[i]] = struct{}{}
	}
}

// RemovedDetailedLines returns the removed IDs of the "detailed_lines" edge to the BillingInvoiceLine entity.
func (m *BillingInvoiceLineMutation) RemovedDetailedLinesIDs() (ids []string) {
	for id := range m.removeddetailed_lines {
		ids = append(ids, id)
	}
	return
}

// DetailedLinesIDs returns the "detailed_lines" edge IDs in the mutation.
func (m *BillingInvoiceLineMutation) DetailedLinesIDs() (ids []string) {
	for id := range m.detailed_lines {
		ids = append(ids, id)
	}
	return
}

// ResetDetailedLines resets all changes to the "detailed_lines" edge.
func (m *BillingInvoiceLineMutation) ResetDetailedLines() {
	m.detailed_lines = nil
	m.cleareddetailed_lines = false
	m.removeddetailed_lines = nil
}

// AddLineUsageDiscountIDs adds the "line_usage_discounts" edge to the BillingInvoiceLineUsageDiscount entity by ids.
func (m *BillingInvoiceLineMutation) AddLineUsageDiscountIDs(ids ...string) {
	if m.line_usage_discounts == nil {
		m.line_usage_discounts = make(map[string]struct{})
	}
	for i := range ids {
		m.line_usage_discounts[ids[i]] = struct{}{}
	}
}

// ClearLineUsageDiscounts clears the "line_usage_discounts" edge to the BillingInvoiceLineUsageDiscount entity.
func (m *BillingInvoiceLineMutation) ClearLineUsageDiscounts() {
	m.clearedline_usage_discounts = true
}

// LineUsageDiscountsCleared reports if the "line_usage_discounts" edge to the BillingInvoiceLineUsageDiscount entity was cleared.
func (m *BillingInvoiceLineMutation) LineUsageDiscountsCleared() bool {
	return m.clearedline_usage_discounts
}

// RemoveLineUsageDiscountIDs removes the "line_usage_discounts" edge to the BillingInvoiceLineUsageDiscount entity by IDs.
func (m *BillingInvoiceLineMutation) RemoveLineUsageDiscountIDs(ids ...string) {
	if m.removedline_usage_discounts == nil {
		m.removedline_usage_discounts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.line_usage_discounts, ids[i])
		m.removedline_usage_discounts[ids[i]] = struct{}{}
	}
}

// RemovedLineUsageDiscounts returns the removed IDs of the "line_usage_discounts" edge to the BillingInvoiceLineUsageDiscount entity.
func (m *BillingInvoiceLineMutation) RemovedLineUsageDiscountsIDs() (ids []string) {
	for id := range m.removedline_usage_discounts {
		ids = append(ids, id)
	}
	return
}

// LineUsageDiscountsIDs returns the "line_usage_discounts" edge IDs in the mutation.
func (m *BillingInvoiceLineMutation) LineUsageDiscountsIDs() (ids []string) {
	for id := range m.line_usage_discounts {
		ids = append(ids, id)
	}
	return
}

// ResetLineUsageDiscounts resets all changes to the "line_usage_discounts" edge.
func (m *BillingInvoiceLineMutation) ResetLineUsageDiscounts() {
	m.line_usage_discounts = nil
	m.clearedline_usage_discounts = false
	m.removedline_usage_discounts = nil
}

// AddLineAmountDiscountIDs adds the "line_amount_discounts" edge to the BillingInvoiceLineDiscount entity by ids.
func (m *BillingInvoiceLineMutation) AddLineAmountDiscountIDs(ids ...string) {
	if m.line_amount_discounts == nil {
		m.line_amount_discounts = make(map[string]struct{})
	}
	for i := range ids {
		m.line_amount_discounts[ids[i]] = struct{}{}
	}
}

// ClearLineAmountDiscounts clears the "line_amount_discounts" edge to the BillingInvoiceLineDiscount entity.
func (m *BillingInvoiceLineMutation) ClearLineAmountDiscounts() {
	m.clearedline_amount_discounts = true
}

// LineAmountDiscountsCleared reports if the "line_amount_discounts" edge to the BillingInvoiceLineDiscount entity was cleared.
func (m *BillingInvoiceLineMutation) LineAmountDiscountsCleared() bool {
	return m.clearedline_amount_discounts
}

// RemoveLineAmountDiscountIDs removes the "line_amount_discounts" edge to the BillingInvoiceLineDiscount entity by IDs.
func (m *BillingInvoiceLineMutation) RemoveLineAmountDiscountIDs(ids ...string) {
	if m.removedline_amount_discounts == nil {
		m.removedline_amount_discounts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.line_amount_discounts, ids[i])
		m.removedline_amount_discounts[ids[i]] = struct{}{}
	}
}

// RemovedLineAmountDiscounts returns the removed IDs of the "line_amount_discounts" edge to the BillingInvoiceLineDiscount entity.
func (m *BillingInvoiceLineMutation) RemovedLineAmountDiscountsIDs() (ids []string) {
	for id := range m.removedline_amount_discounts {
		ids = append(ids, id)
	}
	return
}

// LineAmountDiscountsIDs returns the "line_amount_discounts" edge IDs in the mutation.
func (m *BillingInvoiceLineMutation) LineAmountDiscountsIDs() (ids []string) {
	for id := range m.line_amount_discounts {
		ids = append(ids, id)
	}
	return
}

// ResetLineAmountDiscounts resets all changes to the "line_amount_discounts" edge.
func (m *BillingInvoiceLineMutation) ResetLineAmountDiscounts() {
	m.line_amount_discounts = nil
	m.clearedline_amount_discounts = false
	m.removedline_amount_discounts = nil
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *BillingInvoiceLineMutation) ClearSubscription() {
	m.clearedsubscription = true
	m.clearedFields[billinginvoiceline.FieldSubscriptionID] = struct{}{}
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *BillingInvoiceLineMutation) SubscriptionCleared() bool {
	return m.SubscriptionIDCleared() || m.clearedsubscription
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineMutation) SubscriptionIDs() (ids []string) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *BillingInvoiceLineMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// ClearSubscriptionPhase clears the "subscription_phase" edge to the SubscriptionPhase entity.
func (m *BillingInvoiceLineMutation) ClearSubscriptionPhase() {
	m.clearedsubscription_phase = true
	m.clearedFields[billinginvoiceline.FieldSubscriptionPhaseID] = struct{}{}
}

// SubscriptionPhaseCleared reports if the "subscription_phase" edge to the SubscriptionPhase entity was cleared.
func (m *BillingInvoiceLineMutation) SubscriptionPhaseCleared() bool {
	return m.SubscriptionPhaseIDCleared() || m.clearedsubscription_phase
}

// SubscriptionPhaseIDs returns the "subscription_phase" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionPhaseID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineMutation) SubscriptionPhaseIDs() (ids []string) {
	if id := m.subscription_phase; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscriptionPhase resets all changes to the "subscription_phase" edge.
func (m *BillingInvoiceLineMutation) ResetSubscriptionPhase() {
	m.subscription_phase = nil
	m.clearedsubscription_phase = false
}

// ClearSubscriptionItem clears the "subscription_item" edge to the SubscriptionItem entity.
func (m *BillingInvoiceLineMutation) ClearSubscriptionItem() {
	m.clearedsubscription_item = true
	m.clearedFields[billinginvoiceline.FieldSubscriptionItemID] = struct{}{}
}

// SubscriptionItemCleared reports if the "subscription_item" edge to the SubscriptionItem entity was cleared.
func (m *BillingInvoiceLineMutation) SubscriptionItemCleared() bool {
	return m.SubscriptionItemIDCleared() || m.clearedsubscription_item
}

// SubscriptionItemIDs returns the "subscription_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionItemID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineMutation) SubscriptionItemIDs() (ids []string) {
	if id := m.subscription_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscriptionItem resets all changes to the "subscription_item" edge.
func (m *BillingInvoiceLineMutation) ResetSubscriptionItem() {
	m.subscription_item = nil
	m.clearedsubscription_item = false
}

// Where appends a list predicates to the BillingInvoiceLineMutation builder.
func (m *BillingInvoiceLineMutation) Where(ps ...predicate.BillingInvoiceLine) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceLineMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceLineMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoiceLine, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceLineMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceLineMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoiceLine).
func (m *BillingInvoiceLineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceLineMutation) Fields() []string {
	fields := make([]string, 0, 32)
	if m.namespace != nil {
		fields = append(fields, billinginvoiceline.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, billinginvoiceline.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, billinginvoiceline.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billinginvoiceline.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billinginvoiceline.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, billinginvoiceline.FieldName)
	}
	if m.description != nil {
		fields = append(fields, billinginvoiceline.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, billinginvoiceline.FieldAmount)
	}
	if m.taxes_total != nil {
		fields = append(fields, billinginvoiceline.FieldTaxesTotal)
	}
	if m.taxes_inclusive_total != nil {
		fields = append(fields, billinginvoiceline.FieldTaxesInclusiveTotal)
	}
	if m.taxes_exclusive_total != nil {
		fields = append(fields, billinginvoiceline.FieldTaxesExclusiveTotal)
	}
	if m.charges_total != nil {
		fields = append(fields, billinginvoiceline.FieldChargesTotal)
	}
	if m.discounts_total != nil {
		fields = append(fields, billinginvoiceline.FieldDiscountsTotal)
	}
	if m.total != nil {
		fields = append(fields, billinginvoiceline.FieldTotal)
	}
	if m.billing_invoice != nil {
		fields = append(fields, billinginvoiceline.FieldInvoiceID)
	}
	if m.managed_by != nil {
		fields = append(fields, billinginvoiceline.FieldManagedBy)
	}
	if m.parent_line != nil {
		fields = append(fields, billinginvoiceline.FieldParentLineID)
	}
	if m.period_start != nil {
		fields = append(fields, billinginvoiceline.FieldPeriodStart)
	}
	if m.period_end != nil {
		fields = append(fields, billinginvoiceline.FieldPeriodEnd)
	}
	if m.invoice_at != nil {
		fields = append(fields, billinginvoiceline.FieldInvoiceAt)
	}
	if m._type != nil {
		fields = append(fields, billinginvoiceline.FieldType)
	}
	if m.status != nil {
		fields = append(fields, billinginvoiceline.FieldStatus)
	}
	if m.currency != nil {
		fields = append(fields, billinginvoiceline.FieldCurrency)
	}
	if m.quantity != nil {
		fields = append(fields, billinginvoiceline.FieldQuantity)
	}
	if m.tax_config != nil {
		fields = append(fields, billinginvoiceline.FieldTaxConfig)
	}
	if m.ratecard_discounts != nil {
		fields = append(fields, billinginvoiceline.FieldRatecardDiscounts)
	}
	if m.invoicing_app_external_id != nil {
		fields = append(fields, billinginvoiceline.FieldInvoicingAppExternalID)
	}
	if m.child_unique_reference_id != nil {
		fields = append(fields, billinginvoiceline.FieldChildUniqueReferenceID)
	}
	if m.subscription != nil {
		fields = append(fields, billinginvoiceline.FieldSubscriptionID)
	}
	if m.subscription_phase != nil {
		fields = append(fields, billinginvoiceline.FieldSubscriptionPhaseID)
	}
	if m.subscription_item != nil {
		fields = append(fields, billinginvoiceline.FieldSubscriptionItemID)
	}
	if m.line_ids != nil {
		fields = append(fields, billinginvoiceline.FieldLineIds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceLineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoiceline.FieldNamespace:
		return m.Namespace()
	case billinginvoiceline.FieldMetadata:
		return m.Metadata()
	case billinginvoiceline.FieldCreatedAt:
		return m.CreatedAt()
	case billinginvoiceline.FieldUpdatedAt:
		return m.UpdatedAt()
	case billinginvoiceline.FieldDeletedAt:
		return m.DeletedAt()
	case billinginvoiceline.FieldName:
		return m.Name()
	case billinginvoiceline.FieldDescription:
		return m.Description()
	case billinginvoiceline.FieldAmount:
		return m.Amount()
	case billinginvoiceline.FieldTaxesTotal:
		return m.TaxesTotal()
	case billinginvoiceline.FieldTaxesInclusiveTotal:
		return m.TaxesInclusiveTotal()
	case billinginvoiceline.FieldTaxesExclusiveTotal:
		return m.TaxesExclusiveTotal()
	case billinginvoiceline.FieldChargesTotal:
		return m.ChargesTotal()
	case billinginvoiceline.FieldDiscountsTotal:
		return m.DiscountsTotal()
	case billinginvoiceline.FieldTotal:
		return m.Total()
	case billinginvoiceline.FieldInvoiceID:
		return m.InvoiceID()
	case billinginvoiceline.FieldManagedBy:
		return m.ManagedBy()
	case billinginvoiceline.FieldParentLineID:
		return m.ParentLineID()
	case billinginvoiceline.FieldPeriodStart:
		return m.PeriodStart()
	case billinginvoiceline.FieldPeriodEnd:
		return m.PeriodEnd()
	case billinginvoiceline.FieldInvoiceAt:
		return m.InvoiceAt()
	case billinginvoiceline.FieldType:
		return m.GetType()
	case billinginvoiceline.FieldStatus:
		return m.Status()
	case billinginvoiceline.FieldCurrency:
		return m.Currency()
	case billinginvoiceline.FieldQuantity:
		return m.Quantity()
	case billinginvoiceline.FieldTaxConfig:
		return m.TaxConfig()
	case billinginvoiceline.FieldRatecardDiscounts:
		return m.RatecardDiscounts()
	case billinginvoiceline.FieldInvoicingAppExternalID:
		return m.InvoicingAppExternalID()
	case billinginvoiceline.FieldChildUniqueReferenceID:
		return m.ChildUniqueReferenceID()
	case billinginvoiceline.FieldSubscriptionID:
		return m.SubscriptionID()
	case billinginvoiceline.FieldSubscriptionPhaseID:
		return m.SubscriptionPhaseID()
	case billinginvoiceline.FieldSubscriptionItemID:
		return m.SubscriptionItemID()
	case billinginvoiceline.FieldLineIds:
		return m.LineIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceLineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoiceline.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoiceline.FieldMetadata:
		return m.OldMetadata(ctx)
	case billinginvoiceline.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billinginvoiceline.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billinginvoiceline.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billinginvoiceline.FieldName:
		return m.OldName(ctx)
	case billinginvoiceline.FieldDescription:
		return m.OldDescription(ctx)
	case billinginvoiceline.FieldAmount:
		return m.OldAmount(ctx)
	case billinginvoiceline.FieldTaxesTotal:
		return m.OldTaxesTotal(ctx)
	case billinginvoiceline.FieldTaxesInclusiveTotal:
		return m.OldTaxesInclusiveTotal(ctx)
	case billinginvoiceline.FieldTaxesExclusiveTotal:
		return m.OldTaxesExclusiveTotal(ctx)
	case billinginvoiceline.FieldChargesTotal:
		return m.OldChargesTotal(ctx)
	case billinginvoiceline.FieldDiscountsTotal:
		return m.OldDiscountsTotal(ctx)
	case billinginvoiceline.FieldTotal:
		return m.OldTotal(ctx)
	case billinginvoiceline.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	case billinginvoiceline.FieldManagedBy:
		return m.OldManagedBy(ctx)
	case billinginvoiceline.FieldParentLineID:
		return m.OldParentLineID(ctx)
	case billinginvoiceline.FieldPeriodStart:
		return m.OldPeriodStart(ctx)
	case billinginvoiceline.FieldPeriodEnd:
		return m.OldPeriodEnd(ctx)
	case billinginvoiceline.FieldInvoiceAt:
		return m.OldInvoiceAt(ctx)
	case billinginvoiceline.FieldType:
		return m.OldType(ctx)
	case billinginvoiceline.FieldStatus:
		return m.OldStatus(ctx)
	case billinginvoiceline.FieldCurrency:
		return m.OldCurrency(ctx)
	case billinginvoiceline.FieldQuantity:
		return m.OldQuantity(ctx)
	case billinginvoiceline.FieldTaxConfig:
		return m.OldTaxConfig(ctx)
	case billinginvoiceline.FieldRatecardDiscounts:
		return m.OldRatecardDiscounts(ctx)
	case billinginvoiceline.FieldInvoicingAppExternalID:
		return m.OldInvoicingAppExternalID(ctx)
	case billinginvoiceline.FieldChildUniqueReferenceID:
		return m.OldChildUniqueReferenceID(ctx)
	case billinginvoiceline.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case billinginvoiceline.FieldSubscriptionPhaseID:
		return m.OldSubscriptionPhaseID(ctx)
	case billinginvoiceline.FieldSubscriptionItemID:
		return m.OldSubscriptionItemID(ctx)
	case billinginvoiceline.FieldLineIds:
		return m.OldLineIds(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoiceLine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceLineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoiceline.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoiceline.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case billinginvoiceline.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billinginvoiceline.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billinginvoiceline.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billinginvoiceline.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case billinginvoiceline.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case billinginvoiceline.FieldAmount:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case billinginvoiceline.FieldTaxesTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxesTotal(v)
		return nil
	case billinginvoiceline.FieldTaxesInclusiveTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxesInclusiveTotal(v)
		return nil
	case billinginvoiceline.FieldTaxesExclusiveTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxesExclusiveTotal(v)
		return nil
	case billinginvoiceline.FieldChargesTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargesTotal(v)
		return nil
	case billinginvoiceline.FieldDiscountsTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountsTotal(v)
		return nil
	case billinginvoiceline.FieldTotal:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case billinginvoiceline.FieldInvoiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	case billinginvoiceline.FieldManagedBy:
		v, ok := value.(billing.InvoiceLineManagedBy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagedBy(v)
		return nil
	case billinginvoiceline.FieldParentLineID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentLineID(v)
		return nil
	case billinginvoiceline.FieldPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodStart(v)
		return nil
	case billinginvoiceline.FieldPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodEnd(v)
		return nil
	case billinginvoiceline.FieldInvoiceAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceAt(v)
		return nil
	case billinginvoiceline.FieldType:
		v, ok := value.(billing.InvoiceLineType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case billinginvoiceline.FieldStatus:
		v, ok := value.(billing.InvoiceLineStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case billinginvoiceline.FieldCurrency:
		v, ok := value.(currencyx.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case billinginvoiceline.FieldQuantity:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case billinginvoiceline.FieldTaxConfig:
		v, ok := value.(productcatalog.TaxConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxConfig(v)
		return nil
	case billinginvoiceline.FieldRatecardDiscounts:
		v, ok := value.(*billing.Discounts)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatecardDiscounts(v)
		return nil
	case billinginvoiceline.FieldInvoicingAppExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingAppExternalID(v)
		return nil
	case billinginvoiceline.FieldChildUniqueReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildUniqueReferenceID(v)
		return nil
	case billinginvoiceline.FieldSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case billinginvoiceline.FieldSubscriptionPhaseID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionPhaseID(v)
		return nil
	case billinginvoiceline.FieldSubscriptionItemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionItemID(v)
		return nil
	case billinginvoiceline.FieldLineIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineIds(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceLineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceLineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceLineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoiceLine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceLineMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoiceline.FieldMetadata) {
		fields = append(fields, billinginvoiceline.FieldMetadata)
	}
	if m.FieldCleared(billinginvoiceline.FieldDeletedAt) {
		fields = append(fields, billinginvoiceline.FieldDeletedAt)
	}
	if m.FieldCleared(billinginvoiceline.FieldDescription) {
		fields = append(fields, billinginvoiceline.FieldDescription)
	}
	if m.FieldCleared(billinginvoiceline.FieldParentLineID) {
		fields = append(fields, billinginvoiceline.FieldParentLineID)
	}
	if m.FieldCleared(billinginvoiceline.FieldQuantity) {
		fields = append(fields, billinginvoiceline.FieldQuantity)
	}
	if m.FieldCleared(billinginvoiceline.FieldTaxConfig) {
		fields = append(fields, billinginvoiceline.FieldTaxConfig)
	}
	if m.FieldCleared(billinginvoiceline.FieldRatecardDiscounts) {
		fields = append(fields, billinginvoiceline.FieldRatecardDiscounts)
	}
	if m.FieldCleared(billinginvoiceline.FieldInvoicingAppExternalID) {
		fields = append(fields, billinginvoiceline.FieldInvoicingAppExternalID)
	}
	if m.FieldCleared(billinginvoiceline.FieldChildUniqueReferenceID) {
		fields = append(fields, billinginvoiceline.FieldChildUniqueReferenceID)
	}
	if m.FieldCleared(billinginvoiceline.FieldSubscriptionID) {
		fields = append(fields, billinginvoiceline.FieldSubscriptionID)
	}
	if m.FieldCleared(billinginvoiceline.FieldSubscriptionPhaseID) {
		fields = append(fields, billinginvoiceline.FieldSubscriptionPhaseID)
	}
	if m.FieldCleared(billinginvoiceline.FieldSubscriptionItemID) {
		fields = append(fields, billinginvoiceline.FieldSubscriptionItemID)
	}
	if m.FieldCleared(billinginvoiceline.FieldLineIds) {
		fields = append(fields, billinginvoiceline.FieldLineIds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceLineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceLineMutation) ClearField(name string) error {
	switch name {
	case billinginvoiceline.FieldMetadata:
		m.ClearMetadata()
		return nil
	case billinginvoiceline.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billinginvoiceline.FieldDescription:
		m.ClearDescription()
		return nil
	case billinginvoiceline.FieldParentLineID:
		m.ClearParentLineID()
		return nil
	case billinginvoiceline.FieldQuantity:
		m.ClearQuantity()
		return nil
	case billinginvoiceline.FieldTaxConfig:
		m.ClearTaxConfig()
		return nil
	case billinginvoiceline.FieldRatecardDiscounts:
		m.ClearRatecardDiscounts()
		return nil
	case billinginvoiceline.FieldInvoicingAppExternalID:
		m.ClearInvoicingAppExternalID()
		return nil
	case billinginvoiceline.FieldChildUniqueReferenceID:
		m.ClearChildUniqueReferenceID()
		return nil
	case billinginvoiceline.FieldSubscriptionID:
		m.ClearSubscriptionID()
		return nil
	case billinginvoiceline.FieldSubscriptionPhaseID:
		m.ClearSubscriptionPhaseID()
		return nil
	case billinginvoiceline.FieldSubscriptionItemID:
		m.ClearSubscriptionItemID()
		return nil
	case billinginvoiceline.FieldLineIds:
		m.ClearLineIds()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceLineMutation) ResetField(name string) error {
	switch name {
	case billinginvoiceline.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoiceline.FieldMetadata:
		m.ResetMetadata()
		return nil
	case billinginvoiceline.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billinginvoiceline.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billinginvoiceline.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billinginvoiceline.FieldName:
		m.ResetName()
		return nil
	case billinginvoiceline.FieldDescription:
		m.ResetDescription()
		return nil
	case billinginvoiceline.FieldAmount:
		m.ResetAmount()
		return nil
	case billinginvoiceline.FieldTaxesTotal:
		m.ResetTaxesTotal()
		return nil
	case billinginvoiceline.FieldTaxesInclusiveTotal:
		m.ResetTaxesInclusiveTotal()
		return nil
	case billinginvoiceline.FieldTaxesExclusiveTotal:
		m.ResetTaxesExclusiveTotal()
		return nil
	case billinginvoiceline.FieldChargesTotal:
		m.ResetChargesTotal()
		return nil
	case billinginvoiceline.FieldDiscountsTotal:
		m.ResetDiscountsTotal()
		return nil
	case billinginvoiceline.FieldTotal:
		m.ResetTotal()
		return nil
	case billinginvoiceline.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	case billinginvoiceline.FieldManagedBy:
		m.ResetManagedBy()
		return nil
	case billinginvoiceline.FieldParentLineID:
		m.ResetParentLineID()
		return nil
	case billinginvoiceline.FieldPeriodStart:
		m.ResetPeriodStart()
		return nil
	case billinginvoiceline.FieldPeriodEnd:
		m.ResetPeriodEnd()
		return nil
	case billinginvoiceline.FieldInvoiceAt:
		m.ResetInvoiceAt()
		return nil
	case billinginvoiceline.FieldType:
		m.ResetType()
		return nil
	case billinginvoiceline.FieldStatus:
		m.ResetStatus()
		return nil
	case billinginvoiceline.FieldCurrency:
		m.ResetCurrency()
		return nil
	case billinginvoiceline.FieldQuantity:
		m.ResetQuantity()
		return nil
	case billinginvoiceline.FieldTaxConfig:
		m.ResetTaxConfig()
		return nil
	case billinginvoiceline.FieldRatecardDiscounts:
		m.ResetRatecardDiscounts()
		return nil
	case billinginvoiceline.FieldInvoicingAppExternalID:
		m.ResetInvoicingAppExternalID()
		return nil
	case billinginvoiceline.FieldChildUniqueReferenceID:
		m.ResetChildUniqueReferenceID()
		return nil
	case billinginvoiceline.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case billinginvoiceline.FieldSubscriptionPhaseID:
		m.ResetSubscriptionPhaseID()
		return nil
	case billinginvoiceline.FieldSubscriptionItemID:
		m.ResetSubscriptionItemID()
		return nil
	case billinginvoiceline.FieldLineIds:
		m.ResetLineIds()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceLineMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.billing_invoice != nil {
		edges = append(edges, billinginvoiceline.EdgeBillingInvoice)
	}
	if m.flat_fee_line != nil {
		edges = append(edges, billinginvoiceline.EdgeFlatFeeLine)
	}
	if m.usage_based_line != nil {
		edges = append(edges, billinginvoiceline.EdgeUsageBasedLine)
	}
	if m.parent_line != nil {
		edges = append(edges, billinginvoiceline.EdgeParentLine)
	}
	if m.detailed_lines != nil {
		edges = append(edges, billinginvoiceline.EdgeDetailedLines)
	}
	if m.line_usage_discounts != nil {
		edges = append(edges, billinginvoiceline.EdgeLineUsageDiscounts)
	}
	if m.line_amount_discounts != nil {
		edges = append(edges, billinginvoiceline.EdgeLineAmountDiscounts)
	}
	if m.subscription != nil {
		edges = append(edges, billinginvoiceline.EdgeSubscription)
	}
	if m.subscription_phase != nil {
		edges = append(edges, billinginvoiceline.EdgeSubscriptionPhase)
	}
	if m.subscription_item != nil {
		edges = append(edges, billinginvoiceline.EdgeSubscriptionItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceLineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billinginvoiceline.EdgeBillingInvoice:
		if id := m.billing_invoice; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoiceline.EdgeFlatFeeLine:
		if id := m.flat_fee_line; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoiceline.EdgeUsageBasedLine:
		if id := m.usage_based_line; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoiceline.EdgeParentLine:
		if id := m.parent_line; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoiceline.EdgeDetailedLines:
		ids := make([]ent.Value, 0, len(m.detailed_lines))
		for id := range m.detailed_lines {
			ids = append(ids, id)
		}
		return ids
	case billinginvoiceline.EdgeLineUsageDiscounts:
		ids := make([]ent.Value, 0, len(m.line_usage_discounts))
		for id := range m.line_usage_discounts {
			ids = append(ids, id)
		}
		return ids
	case billinginvoiceline.EdgeLineAmountDiscounts:
		ids := make([]ent.Value, 0, len(m.line_amount_discounts))
		for id := range m.line_amount_discounts {
			ids = append(ids, id)
		}
		return ids
	case billinginvoiceline.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoiceline.EdgeSubscriptionPhase:
		if id := m.subscription_phase; id != nil {
			return []ent.Value{*id}
		}
	case billinginvoiceline.EdgeSubscriptionItem:
		if id := m.subscription_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceLineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removeddetailed_lines != nil {
		edges = append(edges, billinginvoiceline.EdgeDetailedLines)
	}
	if m.removedline_usage_discounts != nil {
		edges = append(edges, billinginvoiceline.EdgeLineUsageDiscounts)
	}
	if m.removedline_amount_discounts != nil {
		edges = append(edges, billinginvoiceline.EdgeLineAmountDiscounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceLineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billinginvoiceline.EdgeDetailedLines:
		ids := make([]ent.Value, 0, len(m.removeddetailed_lines))
		for id := range m.removeddetailed_lines {
			ids = append(ids, id)
		}
		return ids
	case billinginvoiceline.EdgeLineUsageDiscounts:
		ids := make([]ent.Value, 0, len(m.removedline_usage_discounts))
		for id := range m.removedline_usage_discounts {
			ids = append(ids, id)
		}
		return ids
	case billinginvoiceline.EdgeLineAmountDiscounts:
		ids := make([]ent.Value, 0, len(m.removedline_amount_discounts))
		for id := range m.removedline_amount_discounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceLineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedbilling_invoice {
		edges = append(edges, billinginvoiceline.EdgeBillingInvoice)
	}
	if m.clearedflat_fee_line {
		edges = append(edges, billinginvoiceline.EdgeFlatFeeLine)
	}
	if m.clearedusage_based_line {
		edges = append(edges, billinginvoiceline.EdgeUsageBasedLine)
	}
	if m.clearedparent_line {
		edges = append(edges, billinginvoiceline.EdgeParentLine)
	}
	if m.cleareddetailed_lines {
		edges = append(edges, billinginvoiceline.EdgeDetailedLines)
	}
	if m.clearedline_usage_discounts {
		edges = append(edges, billinginvoiceline.EdgeLineUsageDiscounts)
	}
	if m.clearedline_amount_discounts {
		edges = append(edges, billinginvoiceline.EdgeLineAmountDiscounts)
	}
	if m.clearedsubscription {
		edges = append(edges, billinginvoiceline.EdgeSubscription)
	}
	if m.clearedsubscription_phase {
		edges = append(edges, billinginvoiceline.EdgeSubscriptionPhase)
	}
	if m.clearedsubscription_item {
		edges = append(edges, billinginvoiceline.EdgeSubscriptionItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceLineMutation) EdgeCleared(name string) bool {
	switch name {
	case billinginvoiceline.EdgeBillingInvoice:
		return m.clearedbilling_invoice
	case billinginvoiceline.EdgeFlatFeeLine:
		return m.clearedflat_fee_line
	case billinginvoiceline.EdgeUsageBasedLine:
		return m.clearedusage_based_line
	case billinginvoiceline.EdgeParentLine:
		return m.clearedparent_line
	case billinginvoiceline.EdgeDetailedLines:
		return m.cleareddetailed_lines
	case billinginvoiceline.EdgeLineUsageDiscounts:
		return m.clearedline_usage_discounts
	case billinginvoiceline.EdgeLineAmountDiscounts:
		return m.clearedline_amount_discounts
	case billinginvoiceline.EdgeSubscription:
		return m.clearedsubscription
	case billinginvoiceline.EdgeSubscriptionPhase:
		return m.clearedsubscription_phase
	case billinginvoiceline.EdgeSubscriptionItem:
		return m.clearedsubscription_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceLineMutation) ClearEdge(name string) error {
	switch name {
	case billinginvoiceline.EdgeBillingInvoice:
		m.ClearBillingInvoice()
		return nil
	case billinginvoiceline.EdgeFlatFeeLine:
		m.ClearFlatFeeLine()
		return nil
	case billinginvoiceline.EdgeUsageBasedLine:
		m.ClearUsageBasedLine()
		return nil
	case billinginvoiceline.EdgeParentLine:
		m.ClearParentLine()
		return nil
	case billinginvoiceline.EdgeSubscription:
		m.ClearSubscription()
		return nil
	case billinginvoiceline.EdgeSubscriptionPhase:
		m.ClearSubscriptionPhase()
		return nil
	case billinginvoiceline.EdgeSubscriptionItem:
		m.ClearSubscriptionItem()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceLineMutation) ResetEdge(name string) error {
	switch name {
	case billinginvoiceline.EdgeBillingInvoice:
		m.ResetBillingInvoice()
		return nil
	case billinginvoiceline.EdgeFlatFeeLine:
		m.ResetFlatFeeLine()
		return nil
	case billinginvoiceline.EdgeUsageBasedLine:
		m.ResetUsageBasedLine()
		return nil
	case billinginvoiceline.EdgeParentLine:
		m.ResetParentLine()
		return nil
	case billinginvoiceline.EdgeDetailedLines:
		m.ResetDetailedLines()
		return nil
	case billinginvoiceline.EdgeLineUsageDiscounts:
		m.ResetLineUsageDiscounts()
		return nil
	case billinginvoiceline.EdgeLineAmountDiscounts:
		m.ResetLineAmountDiscounts()
		return nil
	case billinginvoiceline.EdgeSubscription:
		m.ResetSubscription()
		return nil
	case billinginvoiceline.EdgeSubscriptionPhase:
		m.ResetSubscriptionPhase()
		return nil
	case billinginvoiceline.EdgeSubscriptionItem:
		m.ResetSubscriptionItem()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLine edge %s", name)
}

// BillingInvoiceLineDiscountMutation represents an operation that mutates the BillingInvoiceLineDiscount nodes in the graph.
type BillingInvoiceLineDiscountMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	namespace                   *string
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	child_unique_reference_id   *string
	description                 *string
	reason                      *billing.DiscountReasonType
	invoicing_app_external_id   *string
	amount                      *alpacadecimal.Decimal
	rounding_amount             *alpacadecimal.Decimal
	source_discount             **billing.DiscountReason
	_type                       *string
	quantity                    *alpacadecimal.Decimal
	pre_line_period_quantity    *alpacadecimal.Decimal
	clearedFields               map[string]struct{}
	billing_invoice_line        *string
	clearedbilling_invoice_line bool
	done                        bool
	oldValue                    func(context.Context) (*BillingInvoiceLineDiscount, error)
	predicates                  []predicate.BillingInvoiceLineDiscount
}

var _ ent.Mutation = (*BillingInvoiceLineDiscountMutation)(nil)

// billinginvoicelinediscountOption allows management of the mutation configuration using functional options.
type billinginvoicelinediscountOption func(*BillingInvoiceLineDiscountMutation)

// newBillingInvoiceLineDiscountMutation creates new mutation for the BillingInvoiceLineDiscount entity.
func newBillingInvoiceLineDiscountMutation(c config, op Op, opts ...billinginvoicelinediscountOption) *BillingInvoiceLineDiscountMutation {
	m := &BillingInvoiceLineDiscountMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoiceLineDiscount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceLineDiscountID sets the ID field of the mutation.
func withBillingInvoiceLineDiscountID(id string) billinginvoicelinediscountOption {
	return func(m *BillingInvoiceLineDiscountMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoiceLineDiscount
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoiceLineDiscount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoiceLineDiscount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoiceLineDiscount sets the old BillingInvoiceLineDiscount of the mutation.
func withBillingInvoiceLineDiscount(node *BillingInvoiceLineDiscount) billinginvoicelinediscountOption {
	return func(m *BillingInvoiceLineDiscountMutation) {
		m.oldValue = func(context.Context) (*BillingInvoiceLineDiscount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceLineDiscountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceLineDiscountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoiceLineDiscount entities.
func (m *BillingInvoiceLineDiscountMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceLineDiscountMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceLineDiscountMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoiceLineDiscount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceLineDiscountMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceLineDiscountMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingInvoiceLineDiscountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingInvoiceLineDiscountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingInvoiceLineDiscountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingInvoiceLineDiscountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingInvoiceLineDiscountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingInvoiceLineDiscountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billinginvoicelinediscount.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoicelinediscount.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingInvoiceLineDiscountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billinginvoicelinediscount.FieldDeletedAt)
}

// SetLineID sets the "line_id" field.
func (m *BillingInvoiceLineDiscountMutation) SetLineID(s string) {
	m.billing_invoice_line = &s
}

// LineID returns the value of the "line_id" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) LineID() (r string, exists bool) {
	v := m.billing_invoice_line
	if v == nil {
		return
	}
	return *v, true
}

// OldLineID returns the old "line_id" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldLineID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineID: %w", err)
	}
	return oldValue.LineID, nil
}

// ResetLineID resets all changes to the "line_id" field.
func (m *BillingInvoiceLineDiscountMutation) ResetLineID() {
	m.billing_invoice_line = nil
}

// SetChildUniqueReferenceID sets the "child_unique_reference_id" field.
func (m *BillingInvoiceLineDiscountMutation) SetChildUniqueReferenceID(s string) {
	m.child_unique_reference_id = &s
}

// ChildUniqueReferenceID returns the value of the "child_unique_reference_id" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) ChildUniqueReferenceID() (r string, exists bool) {
	v := m.child_unique_reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildUniqueReferenceID returns the old "child_unique_reference_id" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldChildUniqueReferenceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildUniqueReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildUniqueReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildUniqueReferenceID: %w", err)
	}
	return oldValue.ChildUniqueReferenceID, nil
}

// ClearChildUniqueReferenceID clears the value of the "child_unique_reference_id" field.
func (m *BillingInvoiceLineDiscountMutation) ClearChildUniqueReferenceID() {
	m.child_unique_reference_id = nil
	m.clearedFields[billinginvoicelinediscount.FieldChildUniqueReferenceID] = struct{}{}
}

// ChildUniqueReferenceIDCleared returns if the "child_unique_reference_id" field was cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) ChildUniqueReferenceIDCleared() bool {
	_, ok := m.clearedFields[billinginvoicelinediscount.FieldChildUniqueReferenceID]
	return ok
}

// ResetChildUniqueReferenceID resets all changes to the "child_unique_reference_id" field.
func (m *BillingInvoiceLineDiscountMutation) ResetChildUniqueReferenceID() {
	m.child_unique_reference_id = nil
	delete(m.clearedFields, billinginvoicelinediscount.FieldChildUniqueReferenceID)
}

// SetDescription sets the "description" field.
func (m *BillingInvoiceLineDiscountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BillingInvoiceLineDiscountMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[billinginvoicelinediscount.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[billinginvoicelinediscount.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BillingInvoiceLineDiscountMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, billinginvoicelinediscount.FieldDescription)
}

// SetReason sets the "reason" field.
func (m *BillingInvoiceLineDiscountMutation) SetReason(brt billing.DiscountReasonType) {
	m.reason = &brt
}

// Reason returns the value of the "reason" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) Reason() (r billing.DiscountReasonType, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldReason(ctx context.Context) (v billing.DiscountReasonType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *BillingInvoiceLineDiscountMutation) ResetReason() {
	m.reason = nil
}

// SetInvoicingAppExternalID sets the "invoicing_app_external_id" field.
func (m *BillingInvoiceLineDiscountMutation) SetInvoicingAppExternalID(s string) {
	m.invoicing_app_external_id = &s
}

// InvoicingAppExternalID returns the value of the "invoicing_app_external_id" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) InvoicingAppExternalID() (r string, exists bool) {
	v := m.invoicing_app_external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingAppExternalID returns the old "invoicing_app_external_id" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldInvoicingAppExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingAppExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingAppExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingAppExternalID: %w", err)
	}
	return oldValue.InvoicingAppExternalID, nil
}

// ClearInvoicingAppExternalID clears the value of the "invoicing_app_external_id" field.
func (m *BillingInvoiceLineDiscountMutation) ClearInvoicingAppExternalID() {
	m.invoicing_app_external_id = nil
	m.clearedFields[billinginvoicelinediscount.FieldInvoicingAppExternalID] = struct{}{}
}

// InvoicingAppExternalIDCleared returns if the "invoicing_app_external_id" field was cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) InvoicingAppExternalIDCleared() bool {
	_, ok := m.clearedFields[billinginvoicelinediscount.FieldInvoicingAppExternalID]
	return ok
}

// ResetInvoicingAppExternalID resets all changes to the "invoicing_app_external_id" field.
func (m *BillingInvoiceLineDiscountMutation) ResetInvoicingAppExternalID() {
	m.invoicing_app_external_id = nil
	delete(m.clearedFields, billinginvoicelinediscount.FieldInvoicingAppExternalID)
}

// SetAmount sets the "amount" field.
func (m *BillingInvoiceLineDiscountMutation) SetAmount(a alpacadecimal.Decimal) {
	m.amount = &a
}

// Amount returns the value of the "amount" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) Amount() (r alpacadecimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldAmount(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *BillingInvoiceLineDiscountMutation) ResetAmount() {
	m.amount = nil
}

// SetRoundingAmount sets the "rounding_amount" field.
func (m *BillingInvoiceLineDiscountMutation) SetRoundingAmount(a alpacadecimal.Decimal) {
	m.rounding_amount = &a
}

// RoundingAmount returns the value of the "rounding_amount" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) RoundingAmount() (r alpacadecimal.Decimal, exists bool) {
	v := m.rounding_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundingAmount returns the old "rounding_amount" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldRoundingAmount(ctx context.Context) (v *alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundingAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundingAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundingAmount: %w", err)
	}
	return oldValue.RoundingAmount, nil
}

// ClearRoundingAmount clears the value of the "rounding_amount" field.
func (m *BillingInvoiceLineDiscountMutation) ClearRoundingAmount() {
	m.rounding_amount = nil
	m.clearedFields[billinginvoicelinediscount.FieldRoundingAmount] = struct{}{}
}

// RoundingAmountCleared returns if the "rounding_amount" field was cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) RoundingAmountCleared() bool {
	_, ok := m.clearedFields[billinginvoicelinediscount.FieldRoundingAmount]
	return ok
}

// ResetRoundingAmount resets all changes to the "rounding_amount" field.
func (m *BillingInvoiceLineDiscountMutation) ResetRoundingAmount() {
	m.rounding_amount = nil
	delete(m.clearedFields, billinginvoicelinediscount.FieldRoundingAmount)
}

// SetSourceDiscount sets the "source_discount" field.
func (m *BillingInvoiceLineDiscountMutation) SetSourceDiscount(br *billing.DiscountReason) {
	m.source_discount = &br
}

// SourceDiscount returns the value of the "source_discount" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) SourceDiscount() (r *billing.DiscountReason, exists bool) {
	v := m.source_discount
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceDiscount returns the old "source_discount" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldSourceDiscount(ctx context.Context) (v *billing.DiscountReason, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceDiscount: %w", err)
	}
	return oldValue.SourceDiscount, nil
}

// ClearSourceDiscount clears the value of the "source_discount" field.
func (m *BillingInvoiceLineDiscountMutation) ClearSourceDiscount() {
	m.source_discount = nil
	m.clearedFields[billinginvoicelinediscount.FieldSourceDiscount] = struct{}{}
}

// SourceDiscountCleared returns if the "source_discount" field was cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) SourceDiscountCleared() bool {
	_, ok := m.clearedFields[billinginvoicelinediscount.FieldSourceDiscount]
	return ok
}

// ResetSourceDiscount resets all changes to the "source_discount" field.
func (m *BillingInvoiceLineDiscountMutation) ResetSourceDiscount() {
	m.source_discount = nil
	delete(m.clearedFields, billinginvoicelinediscount.FieldSourceDiscount)
}

// SetType sets the "type" field.
func (m *BillingInvoiceLineDiscountMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *BillingInvoiceLineDiscountMutation) ClearType() {
	m._type = nil
	m.clearedFields[billinginvoicelinediscount.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) TypeCleared() bool {
	_, ok := m.clearedFields[billinginvoicelinediscount.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *BillingInvoiceLineDiscountMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, billinginvoicelinediscount.FieldType)
}

// SetQuantity sets the "quantity" field.
func (m *BillingInvoiceLineDiscountMutation) SetQuantity(a alpacadecimal.Decimal) {
	m.quantity = &a
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) Quantity() (r alpacadecimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldQuantity(ctx context.Context) (v *alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ClearQuantity clears the value of the "quantity" field.
func (m *BillingInvoiceLineDiscountMutation) ClearQuantity() {
	m.quantity = nil
	m.clearedFields[billinginvoicelinediscount.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[billinginvoicelinediscount.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *BillingInvoiceLineDiscountMutation) ResetQuantity() {
	m.quantity = nil
	delete(m.clearedFields, billinginvoicelinediscount.FieldQuantity)
}

// SetPreLinePeriodQuantity sets the "pre_line_period_quantity" field.
func (m *BillingInvoiceLineDiscountMutation) SetPreLinePeriodQuantity(a alpacadecimal.Decimal) {
	m.pre_line_period_quantity = &a
}

// PreLinePeriodQuantity returns the value of the "pre_line_period_quantity" field in the mutation.
func (m *BillingInvoiceLineDiscountMutation) PreLinePeriodQuantity() (r alpacadecimal.Decimal, exists bool) {
	v := m.pre_line_period_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldPreLinePeriodQuantity returns the old "pre_line_period_quantity" field's value of the BillingInvoiceLineDiscount entity.
// If the BillingInvoiceLineDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineDiscountMutation) OldPreLinePeriodQuantity(ctx context.Context) (v *alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreLinePeriodQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreLinePeriodQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreLinePeriodQuantity: %w", err)
	}
	return oldValue.PreLinePeriodQuantity, nil
}

// ClearPreLinePeriodQuantity clears the value of the "pre_line_period_quantity" field.
func (m *BillingInvoiceLineDiscountMutation) ClearPreLinePeriodQuantity() {
	m.pre_line_period_quantity = nil
	m.clearedFields[billinginvoicelinediscount.FieldPreLinePeriodQuantity] = struct{}{}
}

// PreLinePeriodQuantityCleared returns if the "pre_line_period_quantity" field was cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) PreLinePeriodQuantityCleared() bool {
	_, ok := m.clearedFields[billinginvoicelinediscount.FieldPreLinePeriodQuantity]
	return ok
}

// ResetPreLinePeriodQuantity resets all changes to the "pre_line_period_quantity" field.
func (m *BillingInvoiceLineDiscountMutation) ResetPreLinePeriodQuantity() {
	m.pre_line_period_quantity = nil
	delete(m.clearedFields, billinginvoicelinediscount.FieldPreLinePeriodQuantity)
}

// SetBillingInvoiceLineID sets the "billing_invoice_line" edge to the BillingInvoiceLine entity by id.
func (m *BillingInvoiceLineDiscountMutation) SetBillingInvoiceLineID(id string) {
	m.billing_invoice_line = &id
}

// ClearBillingInvoiceLine clears the "billing_invoice_line" edge to the BillingInvoiceLine entity.
func (m *BillingInvoiceLineDiscountMutation) ClearBillingInvoiceLine() {
	m.clearedbilling_invoice_line = true
	m.clearedFields[billinginvoicelinediscount.FieldLineID] = struct{}{}
}

// BillingInvoiceLineCleared reports if the "billing_invoice_line" edge to the BillingInvoiceLine entity was cleared.
func (m *BillingInvoiceLineDiscountMutation) BillingInvoiceLineCleared() bool {
	return m.clearedbilling_invoice_line
}

// BillingInvoiceLineID returns the "billing_invoice_line" edge ID in the mutation.
func (m *BillingInvoiceLineDiscountMutation) BillingInvoiceLineID() (id string, exists bool) {
	if m.billing_invoice_line != nil {
		return *m.billing_invoice_line, true
	}
	return
}

// BillingInvoiceLineIDs returns the "billing_invoice_line" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoiceLineID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineDiscountMutation) BillingInvoiceLineIDs() (ids []string) {
	if id := m.billing_invoice_line; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoiceLine resets all changes to the "billing_invoice_line" edge.
func (m *BillingInvoiceLineDiscountMutation) ResetBillingInvoiceLine() {
	m.billing_invoice_line = nil
	m.clearedbilling_invoice_line = false
}

// Where appends a list predicates to the BillingInvoiceLineDiscountMutation builder.
func (m *BillingInvoiceLineDiscountMutation) Where(ps ...predicate.BillingInvoiceLineDiscount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceLineDiscountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceLineDiscountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoiceLineDiscount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceLineDiscountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceLineDiscountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoiceLineDiscount).
func (m *BillingInvoiceLineDiscountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceLineDiscountMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.namespace != nil {
		fields = append(fields, billinginvoicelinediscount.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billinginvoicelinediscount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billinginvoicelinediscount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billinginvoicelinediscount.FieldDeletedAt)
	}
	if m.billing_invoice_line != nil {
		fields = append(fields, billinginvoicelinediscount.FieldLineID)
	}
	if m.child_unique_reference_id != nil {
		fields = append(fields, billinginvoicelinediscount.FieldChildUniqueReferenceID)
	}
	if m.description != nil {
		fields = append(fields, billinginvoicelinediscount.FieldDescription)
	}
	if m.reason != nil {
		fields = append(fields, billinginvoicelinediscount.FieldReason)
	}
	if m.invoicing_app_external_id != nil {
		fields = append(fields, billinginvoicelinediscount.FieldInvoicingAppExternalID)
	}
	if m.amount != nil {
		fields = append(fields, billinginvoicelinediscount.FieldAmount)
	}
	if m.rounding_amount != nil {
		fields = append(fields, billinginvoicelinediscount.FieldRoundingAmount)
	}
	if m.source_discount != nil {
		fields = append(fields, billinginvoicelinediscount.FieldSourceDiscount)
	}
	if m._type != nil {
		fields = append(fields, billinginvoicelinediscount.FieldType)
	}
	if m.quantity != nil {
		fields = append(fields, billinginvoicelinediscount.FieldQuantity)
	}
	if m.pre_line_period_quantity != nil {
		fields = append(fields, billinginvoicelinediscount.FieldPreLinePeriodQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceLineDiscountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoicelinediscount.FieldNamespace:
		return m.Namespace()
	case billinginvoicelinediscount.FieldCreatedAt:
		return m.CreatedAt()
	case billinginvoicelinediscount.FieldUpdatedAt:
		return m.UpdatedAt()
	case billinginvoicelinediscount.FieldDeletedAt:
		return m.DeletedAt()
	case billinginvoicelinediscount.FieldLineID:
		return m.LineID()
	case billinginvoicelinediscount.FieldChildUniqueReferenceID:
		return m.ChildUniqueReferenceID()
	case billinginvoicelinediscount.FieldDescription:
		return m.Description()
	case billinginvoicelinediscount.FieldReason:
		return m.Reason()
	case billinginvoicelinediscount.FieldInvoicingAppExternalID:
		return m.InvoicingAppExternalID()
	case billinginvoicelinediscount.FieldAmount:
		return m.Amount()
	case billinginvoicelinediscount.FieldRoundingAmount:
		return m.RoundingAmount()
	case billinginvoicelinediscount.FieldSourceDiscount:
		return m.SourceDiscount()
	case billinginvoicelinediscount.FieldType:
		return m.GetType()
	case billinginvoicelinediscount.FieldQuantity:
		return m.Quantity()
	case billinginvoicelinediscount.FieldPreLinePeriodQuantity:
		return m.PreLinePeriodQuantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceLineDiscountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoicelinediscount.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoicelinediscount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billinginvoicelinediscount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billinginvoicelinediscount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billinginvoicelinediscount.FieldLineID:
		return m.OldLineID(ctx)
	case billinginvoicelinediscount.FieldChildUniqueReferenceID:
		return m.OldChildUniqueReferenceID(ctx)
	case billinginvoicelinediscount.FieldDescription:
		return m.OldDescription(ctx)
	case billinginvoicelinediscount.FieldReason:
		return m.OldReason(ctx)
	case billinginvoicelinediscount.FieldInvoicingAppExternalID:
		return m.OldInvoicingAppExternalID(ctx)
	case billinginvoicelinediscount.FieldAmount:
		return m.OldAmount(ctx)
	case billinginvoicelinediscount.FieldRoundingAmount:
		return m.OldRoundingAmount(ctx)
	case billinginvoicelinediscount.FieldSourceDiscount:
		return m.OldSourceDiscount(ctx)
	case billinginvoicelinediscount.FieldType:
		return m.OldType(ctx)
	case billinginvoicelinediscount.FieldQuantity:
		return m.OldQuantity(ctx)
	case billinginvoicelinediscount.FieldPreLinePeriodQuantity:
		return m.OldPreLinePeriodQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoiceLineDiscount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceLineDiscountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoicelinediscount.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoicelinediscount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billinginvoicelinediscount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billinginvoicelinediscount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billinginvoicelinediscount.FieldLineID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineID(v)
		return nil
	case billinginvoicelinediscount.FieldChildUniqueReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildUniqueReferenceID(v)
		return nil
	case billinginvoicelinediscount.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case billinginvoicelinediscount.FieldReason:
		v, ok := value.(billing.DiscountReasonType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case billinginvoicelinediscount.FieldInvoicingAppExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingAppExternalID(v)
		return nil
	case billinginvoicelinediscount.FieldAmount:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case billinginvoicelinediscount.FieldRoundingAmount:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundingAmount(v)
		return nil
	case billinginvoicelinediscount.FieldSourceDiscount:
		v, ok := value.(*billing.DiscountReason)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceDiscount(v)
		return nil
	case billinginvoicelinediscount.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case billinginvoicelinediscount.FieldQuantity:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case billinginvoicelinediscount.FieldPreLinePeriodQuantity:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreLinePeriodQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLineDiscount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceLineDiscountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceLineDiscountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceLineDiscountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoiceLineDiscount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceLineDiscountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoicelinediscount.FieldDeletedAt) {
		fields = append(fields, billinginvoicelinediscount.FieldDeletedAt)
	}
	if m.FieldCleared(billinginvoicelinediscount.FieldChildUniqueReferenceID) {
		fields = append(fields, billinginvoicelinediscount.FieldChildUniqueReferenceID)
	}
	if m.FieldCleared(billinginvoicelinediscount.FieldDescription) {
		fields = append(fields, billinginvoicelinediscount.FieldDescription)
	}
	if m.FieldCleared(billinginvoicelinediscount.FieldInvoicingAppExternalID) {
		fields = append(fields, billinginvoicelinediscount.FieldInvoicingAppExternalID)
	}
	if m.FieldCleared(billinginvoicelinediscount.FieldRoundingAmount) {
		fields = append(fields, billinginvoicelinediscount.FieldRoundingAmount)
	}
	if m.FieldCleared(billinginvoicelinediscount.FieldSourceDiscount) {
		fields = append(fields, billinginvoicelinediscount.FieldSourceDiscount)
	}
	if m.FieldCleared(billinginvoicelinediscount.FieldType) {
		fields = append(fields, billinginvoicelinediscount.FieldType)
	}
	if m.FieldCleared(billinginvoicelinediscount.FieldQuantity) {
		fields = append(fields, billinginvoicelinediscount.FieldQuantity)
	}
	if m.FieldCleared(billinginvoicelinediscount.FieldPreLinePeriodQuantity) {
		fields = append(fields, billinginvoicelinediscount.FieldPreLinePeriodQuantity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceLineDiscountMutation) ClearField(name string) error {
	switch name {
	case billinginvoicelinediscount.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billinginvoicelinediscount.FieldChildUniqueReferenceID:
		m.ClearChildUniqueReferenceID()
		return nil
	case billinginvoicelinediscount.FieldDescription:
		m.ClearDescription()
		return nil
	case billinginvoicelinediscount.FieldInvoicingAppExternalID:
		m.ClearInvoicingAppExternalID()
		return nil
	case billinginvoicelinediscount.FieldRoundingAmount:
		m.ClearRoundingAmount()
		return nil
	case billinginvoicelinediscount.FieldSourceDiscount:
		m.ClearSourceDiscount()
		return nil
	case billinginvoicelinediscount.FieldType:
		m.ClearType()
		return nil
	case billinginvoicelinediscount.FieldQuantity:
		m.ClearQuantity()
		return nil
	case billinginvoicelinediscount.FieldPreLinePeriodQuantity:
		m.ClearPreLinePeriodQuantity()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLineDiscount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceLineDiscountMutation) ResetField(name string) error {
	switch name {
	case billinginvoicelinediscount.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoicelinediscount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billinginvoicelinediscount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billinginvoicelinediscount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billinginvoicelinediscount.FieldLineID:
		m.ResetLineID()
		return nil
	case billinginvoicelinediscount.FieldChildUniqueReferenceID:
		m.ResetChildUniqueReferenceID()
		return nil
	case billinginvoicelinediscount.FieldDescription:
		m.ResetDescription()
		return nil
	case billinginvoicelinediscount.FieldReason:
		m.ResetReason()
		return nil
	case billinginvoicelinediscount.FieldInvoicingAppExternalID:
		m.ResetInvoicingAppExternalID()
		return nil
	case billinginvoicelinediscount.FieldAmount:
		m.ResetAmount()
		return nil
	case billinginvoicelinediscount.FieldRoundingAmount:
		m.ResetRoundingAmount()
		return nil
	case billinginvoicelinediscount.FieldSourceDiscount:
		m.ResetSourceDiscount()
		return nil
	case billinginvoicelinediscount.FieldType:
		m.ResetType()
		return nil
	case billinginvoicelinediscount.FieldQuantity:
		m.ResetQuantity()
		return nil
	case billinginvoicelinediscount.FieldPreLinePeriodQuantity:
		m.ResetPreLinePeriodQuantity()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLineDiscount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceLineDiscountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.billing_invoice_line != nil {
		edges = append(edges, billinginvoicelinediscount.EdgeBillingInvoiceLine)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceLineDiscountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billinginvoicelinediscount.EdgeBillingInvoiceLine:
		if id := m.billing_invoice_line; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceLineDiscountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceLineDiscountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbilling_invoice_line {
		edges = append(edges, billinginvoicelinediscount.EdgeBillingInvoiceLine)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceLineDiscountMutation) EdgeCleared(name string) bool {
	switch name {
	case billinginvoicelinediscount.EdgeBillingInvoiceLine:
		return m.clearedbilling_invoice_line
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceLineDiscountMutation) ClearEdge(name string) error {
	switch name {
	case billinginvoicelinediscount.EdgeBillingInvoiceLine:
		m.ClearBillingInvoiceLine()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLineDiscount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceLineDiscountMutation) ResetEdge(name string) error {
	switch name {
	case billinginvoicelinediscount.EdgeBillingInvoiceLine:
		m.ResetBillingInvoiceLine()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLineDiscount edge %s", name)
}

// BillingInvoiceLineUsageDiscountMutation represents an operation that mutates the BillingInvoiceLineUsageDiscount nodes in the graph.
type BillingInvoiceLineUsageDiscountMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	namespace                   *string
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	child_unique_reference_id   *string
	description                 *string
	reason                      *billing.DiscountReasonType
	invoicing_app_external_id   *string
	quantity                    *alpacadecimal.Decimal
	pre_line_period_quantity    *alpacadecimal.Decimal
	reason_details              **billing.DiscountReason
	clearedFields               map[string]struct{}
	billing_invoice_line        *string
	clearedbilling_invoice_line bool
	done                        bool
	oldValue                    func(context.Context) (*BillingInvoiceLineUsageDiscount, error)
	predicates                  []predicate.BillingInvoiceLineUsageDiscount
}

var _ ent.Mutation = (*BillingInvoiceLineUsageDiscountMutation)(nil)

// billinginvoicelineusagediscountOption allows management of the mutation configuration using functional options.
type billinginvoicelineusagediscountOption func(*BillingInvoiceLineUsageDiscountMutation)

// newBillingInvoiceLineUsageDiscountMutation creates new mutation for the BillingInvoiceLineUsageDiscount entity.
func newBillingInvoiceLineUsageDiscountMutation(c config, op Op, opts ...billinginvoicelineusagediscountOption) *BillingInvoiceLineUsageDiscountMutation {
	m := &BillingInvoiceLineUsageDiscountMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoiceLineUsageDiscount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceLineUsageDiscountID sets the ID field of the mutation.
func withBillingInvoiceLineUsageDiscountID(id string) billinginvoicelineusagediscountOption {
	return func(m *BillingInvoiceLineUsageDiscountMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoiceLineUsageDiscount
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoiceLineUsageDiscount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoiceLineUsageDiscount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoiceLineUsageDiscount sets the old BillingInvoiceLineUsageDiscount of the mutation.
func withBillingInvoiceLineUsageDiscount(node *BillingInvoiceLineUsageDiscount) billinginvoicelineusagediscountOption {
	return func(m *BillingInvoiceLineUsageDiscountMutation) {
		m.oldValue = func(context.Context) (*BillingInvoiceLineUsageDiscount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceLineUsageDiscountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceLineUsageDiscountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoiceLineUsageDiscount entities.
func (m *BillingInvoiceLineUsageDiscountMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceLineUsageDiscountMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoiceLineUsageDiscount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billinginvoicelineusagediscount.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoicelineusagediscount.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billinginvoicelineusagediscount.FieldDeletedAt)
}

// SetLineID sets the "line_id" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetLineID(s string) {
	m.billing_invoice_line = &s
}

// LineID returns the value of the "line_id" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) LineID() (r string, exists bool) {
	v := m.billing_invoice_line
	if v == nil {
		return
	}
	return *v, true
}

// OldLineID returns the old "line_id" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldLineID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineID: %w", err)
	}
	return oldValue.LineID, nil
}

// ResetLineID resets all changes to the "line_id" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetLineID() {
	m.billing_invoice_line = nil
}

// SetChildUniqueReferenceID sets the "child_unique_reference_id" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetChildUniqueReferenceID(s string) {
	m.child_unique_reference_id = &s
}

// ChildUniqueReferenceID returns the value of the "child_unique_reference_id" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) ChildUniqueReferenceID() (r string, exists bool) {
	v := m.child_unique_reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChildUniqueReferenceID returns the old "child_unique_reference_id" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldChildUniqueReferenceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildUniqueReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildUniqueReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildUniqueReferenceID: %w", err)
	}
	return oldValue.ChildUniqueReferenceID, nil
}

// ClearChildUniqueReferenceID clears the value of the "child_unique_reference_id" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearChildUniqueReferenceID() {
	m.child_unique_reference_id = nil
	m.clearedFields[billinginvoicelineusagediscount.FieldChildUniqueReferenceID] = struct{}{}
}

// ChildUniqueReferenceIDCleared returns if the "child_unique_reference_id" field was cleared in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) ChildUniqueReferenceIDCleared() bool {
	_, ok := m.clearedFields[billinginvoicelineusagediscount.FieldChildUniqueReferenceID]
	return ok
}

// ResetChildUniqueReferenceID resets all changes to the "child_unique_reference_id" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetChildUniqueReferenceID() {
	m.child_unique_reference_id = nil
	delete(m.clearedFields, billinginvoicelineusagediscount.FieldChildUniqueReferenceID)
}

// SetDescription sets the "description" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[billinginvoicelineusagediscount.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[billinginvoicelineusagediscount.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, billinginvoicelineusagediscount.FieldDescription)
}

// SetReason sets the "reason" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetReason(brt billing.DiscountReasonType) {
	m.reason = &brt
}

// Reason returns the value of the "reason" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) Reason() (r billing.DiscountReasonType, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldReason(ctx context.Context) (v billing.DiscountReasonType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetReason() {
	m.reason = nil
}

// SetInvoicingAppExternalID sets the "invoicing_app_external_id" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetInvoicingAppExternalID(s string) {
	m.invoicing_app_external_id = &s
}

// InvoicingAppExternalID returns the value of the "invoicing_app_external_id" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) InvoicingAppExternalID() (r string, exists bool) {
	v := m.invoicing_app_external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingAppExternalID returns the old "invoicing_app_external_id" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldInvoicingAppExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingAppExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingAppExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingAppExternalID: %w", err)
	}
	return oldValue.InvoicingAppExternalID, nil
}

// ClearInvoicingAppExternalID clears the value of the "invoicing_app_external_id" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearInvoicingAppExternalID() {
	m.invoicing_app_external_id = nil
	m.clearedFields[billinginvoicelineusagediscount.FieldInvoicingAppExternalID] = struct{}{}
}

// InvoicingAppExternalIDCleared returns if the "invoicing_app_external_id" field was cleared in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) InvoicingAppExternalIDCleared() bool {
	_, ok := m.clearedFields[billinginvoicelineusagediscount.FieldInvoicingAppExternalID]
	return ok
}

// ResetInvoicingAppExternalID resets all changes to the "invoicing_app_external_id" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetInvoicingAppExternalID() {
	m.invoicing_app_external_id = nil
	delete(m.clearedFields, billinginvoicelineusagediscount.FieldInvoicingAppExternalID)
}

// SetQuantity sets the "quantity" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetQuantity(a alpacadecimal.Decimal) {
	m.quantity = &a
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) Quantity() (r alpacadecimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldQuantity(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetQuantity() {
	m.quantity = nil
}

// SetPreLinePeriodQuantity sets the "pre_line_period_quantity" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetPreLinePeriodQuantity(a alpacadecimal.Decimal) {
	m.pre_line_period_quantity = &a
}

// PreLinePeriodQuantity returns the value of the "pre_line_period_quantity" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) PreLinePeriodQuantity() (r alpacadecimal.Decimal, exists bool) {
	v := m.pre_line_period_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldPreLinePeriodQuantity returns the old "pre_line_period_quantity" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldPreLinePeriodQuantity(ctx context.Context) (v *alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreLinePeriodQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreLinePeriodQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreLinePeriodQuantity: %w", err)
	}
	return oldValue.PreLinePeriodQuantity, nil
}

// ClearPreLinePeriodQuantity clears the value of the "pre_line_period_quantity" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearPreLinePeriodQuantity() {
	m.pre_line_period_quantity = nil
	m.clearedFields[billinginvoicelineusagediscount.FieldPreLinePeriodQuantity] = struct{}{}
}

// PreLinePeriodQuantityCleared returns if the "pre_line_period_quantity" field was cleared in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) PreLinePeriodQuantityCleared() bool {
	_, ok := m.clearedFields[billinginvoicelineusagediscount.FieldPreLinePeriodQuantity]
	return ok
}

// ResetPreLinePeriodQuantity resets all changes to the "pre_line_period_quantity" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetPreLinePeriodQuantity() {
	m.pre_line_period_quantity = nil
	delete(m.clearedFields, billinginvoicelineusagediscount.FieldPreLinePeriodQuantity)
}

// SetReasonDetails sets the "reason_details" field.
func (m *BillingInvoiceLineUsageDiscountMutation) SetReasonDetails(br *billing.DiscountReason) {
	m.reason_details = &br
}

// ReasonDetails returns the value of the "reason_details" field in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) ReasonDetails() (r *billing.DiscountReason, exists bool) {
	v := m.reason_details
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonDetails returns the old "reason_details" field's value of the BillingInvoiceLineUsageDiscount entity.
// If the BillingInvoiceLineUsageDiscount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceLineUsageDiscountMutation) OldReasonDetails(ctx context.Context) (v *billing.DiscountReason, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasonDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasonDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonDetails: %w", err)
	}
	return oldValue.ReasonDetails, nil
}

// ClearReasonDetails clears the value of the "reason_details" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearReasonDetails() {
	m.reason_details = nil
	m.clearedFields[billinginvoicelineusagediscount.FieldReasonDetails] = struct{}{}
}

// ReasonDetailsCleared returns if the "reason_details" field was cleared in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) ReasonDetailsCleared() bool {
	_, ok := m.clearedFields[billinginvoicelineusagediscount.FieldReasonDetails]
	return ok
}

// ResetReasonDetails resets all changes to the "reason_details" field.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetReasonDetails() {
	m.reason_details = nil
	delete(m.clearedFields, billinginvoicelineusagediscount.FieldReasonDetails)
}

// SetBillingInvoiceLineID sets the "billing_invoice_line" edge to the BillingInvoiceLine entity by id.
func (m *BillingInvoiceLineUsageDiscountMutation) SetBillingInvoiceLineID(id string) {
	m.billing_invoice_line = &id
}

// ClearBillingInvoiceLine clears the "billing_invoice_line" edge to the BillingInvoiceLine entity.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearBillingInvoiceLine() {
	m.clearedbilling_invoice_line = true
	m.clearedFields[billinginvoicelineusagediscount.FieldLineID] = struct{}{}
}

// BillingInvoiceLineCleared reports if the "billing_invoice_line" edge to the BillingInvoiceLine entity was cleared.
func (m *BillingInvoiceLineUsageDiscountMutation) BillingInvoiceLineCleared() bool {
	return m.clearedbilling_invoice_line
}

// BillingInvoiceLineID returns the "billing_invoice_line" edge ID in the mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) BillingInvoiceLineID() (id string, exists bool) {
	if m.billing_invoice_line != nil {
		return *m.billing_invoice_line, true
	}
	return
}

// BillingInvoiceLineIDs returns the "billing_invoice_line" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoiceLineID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceLineUsageDiscountMutation) BillingInvoiceLineIDs() (ids []string) {
	if id := m.billing_invoice_line; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoiceLine resets all changes to the "billing_invoice_line" edge.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetBillingInvoiceLine() {
	m.billing_invoice_line = nil
	m.clearedbilling_invoice_line = false
}

// Where appends a list predicates to the BillingInvoiceLineUsageDiscountMutation builder.
func (m *BillingInvoiceLineUsageDiscountMutation) Where(ps ...predicate.BillingInvoiceLineUsageDiscount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceLineUsageDiscountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceLineUsageDiscountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoiceLineUsageDiscount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceLineUsageDiscountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceLineUsageDiscountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoiceLineUsageDiscount).
func (m *BillingInvoiceLineUsageDiscountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceLineUsageDiscountMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.namespace != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldDeletedAt)
	}
	if m.billing_invoice_line != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldLineID)
	}
	if m.child_unique_reference_id != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldChildUniqueReferenceID)
	}
	if m.description != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldDescription)
	}
	if m.reason != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldReason)
	}
	if m.invoicing_app_external_id != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldInvoicingAppExternalID)
	}
	if m.quantity != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldQuantity)
	}
	if m.pre_line_period_quantity != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldPreLinePeriodQuantity)
	}
	if m.reason_details != nil {
		fields = append(fields, billinginvoicelineusagediscount.FieldReasonDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceLineUsageDiscountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoicelineusagediscount.FieldNamespace:
		return m.Namespace()
	case billinginvoicelineusagediscount.FieldCreatedAt:
		return m.CreatedAt()
	case billinginvoicelineusagediscount.FieldUpdatedAt:
		return m.UpdatedAt()
	case billinginvoicelineusagediscount.FieldDeletedAt:
		return m.DeletedAt()
	case billinginvoicelineusagediscount.FieldLineID:
		return m.LineID()
	case billinginvoicelineusagediscount.FieldChildUniqueReferenceID:
		return m.ChildUniqueReferenceID()
	case billinginvoicelineusagediscount.FieldDescription:
		return m.Description()
	case billinginvoicelineusagediscount.FieldReason:
		return m.Reason()
	case billinginvoicelineusagediscount.FieldInvoicingAppExternalID:
		return m.InvoicingAppExternalID()
	case billinginvoicelineusagediscount.FieldQuantity:
		return m.Quantity()
	case billinginvoicelineusagediscount.FieldPreLinePeriodQuantity:
		return m.PreLinePeriodQuantity()
	case billinginvoicelineusagediscount.FieldReasonDetails:
		return m.ReasonDetails()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceLineUsageDiscountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoicelineusagediscount.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoicelineusagediscount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billinginvoicelineusagediscount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billinginvoicelineusagediscount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billinginvoicelineusagediscount.FieldLineID:
		return m.OldLineID(ctx)
	case billinginvoicelineusagediscount.FieldChildUniqueReferenceID:
		return m.OldChildUniqueReferenceID(ctx)
	case billinginvoicelineusagediscount.FieldDescription:
		return m.OldDescription(ctx)
	case billinginvoicelineusagediscount.FieldReason:
		return m.OldReason(ctx)
	case billinginvoicelineusagediscount.FieldInvoicingAppExternalID:
		return m.OldInvoicingAppExternalID(ctx)
	case billinginvoicelineusagediscount.FieldQuantity:
		return m.OldQuantity(ctx)
	case billinginvoicelineusagediscount.FieldPreLinePeriodQuantity:
		return m.OldPreLinePeriodQuantity(ctx)
	case billinginvoicelineusagediscount.FieldReasonDetails:
		return m.OldReasonDetails(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoiceLineUsageDiscount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceLineUsageDiscountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoicelineusagediscount.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoicelineusagediscount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billinginvoicelineusagediscount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billinginvoicelineusagediscount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billinginvoicelineusagediscount.FieldLineID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineID(v)
		return nil
	case billinginvoicelineusagediscount.FieldChildUniqueReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildUniqueReferenceID(v)
		return nil
	case billinginvoicelineusagediscount.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case billinginvoicelineusagediscount.FieldReason:
		v, ok := value.(billing.DiscountReasonType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case billinginvoicelineusagediscount.FieldInvoicingAppExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingAppExternalID(v)
		return nil
	case billinginvoicelineusagediscount.FieldQuantity:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case billinginvoicelineusagediscount.FieldPreLinePeriodQuantity:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreLinePeriodQuantity(v)
		return nil
	case billinginvoicelineusagediscount.FieldReasonDetails:
		v, ok := value.(*billing.DiscountReason)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonDetails(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLineUsageDiscount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceLineUsageDiscountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceLineUsageDiscountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoiceLineUsageDiscount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoicelineusagediscount.FieldDeletedAt) {
		fields = append(fields, billinginvoicelineusagediscount.FieldDeletedAt)
	}
	if m.FieldCleared(billinginvoicelineusagediscount.FieldChildUniqueReferenceID) {
		fields = append(fields, billinginvoicelineusagediscount.FieldChildUniqueReferenceID)
	}
	if m.FieldCleared(billinginvoicelineusagediscount.FieldDescription) {
		fields = append(fields, billinginvoicelineusagediscount.FieldDescription)
	}
	if m.FieldCleared(billinginvoicelineusagediscount.FieldInvoicingAppExternalID) {
		fields = append(fields, billinginvoicelineusagediscount.FieldInvoicingAppExternalID)
	}
	if m.FieldCleared(billinginvoicelineusagediscount.FieldPreLinePeriodQuantity) {
		fields = append(fields, billinginvoicelineusagediscount.FieldPreLinePeriodQuantity)
	}
	if m.FieldCleared(billinginvoicelineusagediscount.FieldReasonDetails) {
		fields = append(fields, billinginvoicelineusagediscount.FieldReasonDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearField(name string) error {
	switch name {
	case billinginvoicelineusagediscount.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billinginvoicelineusagediscount.FieldChildUniqueReferenceID:
		m.ClearChildUniqueReferenceID()
		return nil
	case billinginvoicelineusagediscount.FieldDescription:
		m.ClearDescription()
		return nil
	case billinginvoicelineusagediscount.FieldInvoicingAppExternalID:
		m.ClearInvoicingAppExternalID()
		return nil
	case billinginvoicelineusagediscount.FieldPreLinePeriodQuantity:
		m.ClearPreLinePeriodQuantity()
		return nil
	case billinginvoicelineusagediscount.FieldReasonDetails:
		m.ClearReasonDetails()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLineUsageDiscount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetField(name string) error {
	switch name {
	case billinginvoicelineusagediscount.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoicelineusagediscount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billinginvoicelineusagediscount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billinginvoicelineusagediscount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billinginvoicelineusagediscount.FieldLineID:
		m.ResetLineID()
		return nil
	case billinginvoicelineusagediscount.FieldChildUniqueReferenceID:
		m.ResetChildUniqueReferenceID()
		return nil
	case billinginvoicelineusagediscount.FieldDescription:
		m.ResetDescription()
		return nil
	case billinginvoicelineusagediscount.FieldReason:
		m.ResetReason()
		return nil
	case billinginvoicelineusagediscount.FieldInvoicingAppExternalID:
		m.ResetInvoicingAppExternalID()
		return nil
	case billinginvoicelineusagediscount.FieldQuantity:
		m.ResetQuantity()
		return nil
	case billinginvoicelineusagediscount.FieldPreLinePeriodQuantity:
		m.ResetPreLinePeriodQuantity()
		return nil
	case billinginvoicelineusagediscount.FieldReasonDetails:
		m.ResetReasonDetails()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLineUsageDiscount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.billing_invoice_line != nil {
		edges = append(edges, billinginvoicelineusagediscount.EdgeBillingInvoiceLine)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billinginvoicelineusagediscount.EdgeBillingInvoiceLine:
		if id := m.billing_invoice_line; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbilling_invoice_line {
		edges = append(edges, billinginvoicelineusagediscount.EdgeBillingInvoiceLine)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceLineUsageDiscountMutation) EdgeCleared(name string) bool {
	switch name {
	case billinginvoicelineusagediscount.EdgeBillingInvoiceLine:
		return m.clearedbilling_invoice_line
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceLineUsageDiscountMutation) ClearEdge(name string) error {
	switch name {
	case billinginvoicelineusagediscount.EdgeBillingInvoiceLine:
		m.ClearBillingInvoiceLine()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLineUsageDiscount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceLineUsageDiscountMutation) ResetEdge(name string) error {
	switch name {
	case billinginvoicelineusagediscount.EdgeBillingInvoiceLine:
		m.ResetBillingInvoiceLine()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceLineUsageDiscount edge %s", name)
}

// BillingInvoiceUsageBasedLineConfigMutation represents an operation that mutates the BillingInvoiceUsageBasedLineConfig nodes in the graph.
type BillingInvoiceUsageBasedLineConfigMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	namespace                        *string
	price_type                       *productcatalog.PriceType
	feature_key                      *string
	price                            **productcatalog.Price
	pre_line_period_quantity         *alpacadecimal.Decimal
	metered_pre_line_period_quantity *alpacadecimal.Decimal
	metered_quantity                 *alpacadecimal.Decimal
	clearedFields                    map[string]struct{}
	done                             bool
	oldValue                         func(context.Context) (*BillingInvoiceUsageBasedLineConfig, error)
	predicates                       []predicate.BillingInvoiceUsageBasedLineConfig
}

var _ ent.Mutation = (*BillingInvoiceUsageBasedLineConfigMutation)(nil)

// billinginvoiceusagebasedlineconfigOption allows management of the mutation configuration using functional options.
type billinginvoiceusagebasedlineconfigOption func(*BillingInvoiceUsageBasedLineConfigMutation)

// newBillingInvoiceUsageBasedLineConfigMutation creates new mutation for the BillingInvoiceUsageBasedLineConfig entity.
func newBillingInvoiceUsageBasedLineConfigMutation(c config, op Op, opts ...billinginvoiceusagebasedlineconfigOption) *BillingInvoiceUsageBasedLineConfigMutation {
	m := &BillingInvoiceUsageBasedLineConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoiceUsageBasedLineConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceUsageBasedLineConfigID sets the ID field of the mutation.
func withBillingInvoiceUsageBasedLineConfigID(id string) billinginvoiceusagebasedlineconfigOption {
	return func(m *BillingInvoiceUsageBasedLineConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoiceUsageBasedLineConfig
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoiceUsageBasedLineConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoiceUsageBasedLineConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoiceUsageBasedLineConfig sets the old BillingInvoiceUsageBasedLineConfig of the mutation.
func withBillingInvoiceUsageBasedLineConfig(node *BillingInvoiceUsageBasedLineConfig) billinginvoiceusagebasedlineconfigOption {
	return func(m *BillingInvoiceUsageBasedLineConfigMutation) {
		m.oldValue = func(context.Context) (*BillingInvoiceUsageBasedLineConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceUsageBasedLineConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceUsageBasedLineConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoiceUsageBasedLineConfig entities.
func (m *BillingInvoiceUsageBasedLineConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoiceUsageBasedLineConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoiceUsageBasedLineConfig entity.
// If the BillingInvoiceUsageBasedLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceUsageBasedLineConfigMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ResetNamespace() {
	m.namespace = nil
}

// SetPriceType sets the "price_type" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) SetPriceType(pt productcatalog.PriceType) {
	m.price_type = &pt
}

// PriceType returns the value of the "price_type" field in the mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) PriceType() (r productcatalog.PriceType, exists bool) {
	v := m.price_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceType returns the old "price_type" field's value of the BillingInvoiceUsageBasedLineConfig entity.
// If the BillingInvoiceUsageBasedLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceUsageBasedLineConfigMutation) OldPriceType(ctx context.Context) (v productcatalog.PriceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceType: %w", err)
	}
	return oldValue.PriceType, nil
}

// ResetPriceType resets all changes to the "price_type" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ResetPriceType() {
	m.price_type = nil
}

// SetFeatureKey sets the "feature_key" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) SetFeatureKey(s string) {
	m.feature_key = &s
}

// FeatureKey returns the value of the "feature_key" field in the mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) FeatureKey() (r string, exists bool) {
	v := m.feature_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureKey returns the old "feature_key" field's value of the BillingInvoiceUsageBasedLineConfig entity.
// If the BillingInvoiceUsageBasedLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceUsageBasedLineConfigMutation) OldFeatureKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureKey: %w", err)
	}
	return oldValue.FeatureKey, nil
}

// ResetFeatureKey resets all changes to the "feature_key" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ResetFeatureKey() {
	m.feature_key = nil
}

// SetPrice sets the "price" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) SetPrice(pr *productcatalog.Price) {
	m.price = &pr
}

// Price returns the value of the "price" field in the mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) Price() (r *productcatalog.Price, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the BillingInvoiceUsageBasedLineConfig entity.
// If the BillingInvoiceUsageBasedLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceUsageBasedLineConfigMutation) OldPrice(ctx context.Context) (v *productcatalog.Price, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ResetPrice() {
	m.price = nil
}

// SetPreLinePeriodQuantity sets the "pre_line_period_quantity" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) SetPreLinePeriodQuantity(a alpacadecimal.Decimal) {
	m.pre_line_period_quantity = &a
}

// PreLinePeriodQuantity returns the value of the "pre_line_period_quantity" field in the mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) PreLinePeriodQuantity() (r alpacadecimal.Decimal, exists bool) {
	v := m.pre_line_period_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldPreLinePeriodQuantity returns the old "pre_line_period_quantity" field's value of the BillingInvoiceUsageBasedLineConfig entity.
// If the BillingInvoiceUsageBasedLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceUsageBasedLineConfigMutation) OldPreLinePeriodQuantity(ctx context.Context) (v *alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreLinePeriodQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreLinePeriodQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreLinePeriodQuantity: %w", err)
	}
	return oldValue.PreLinePeriodQuantity, nil
}

// ClearPreLinePeriodQuantity clears the value of the "pre_line_period_quantity" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ClearPreLinePeriodQuantity() {
	m.pre_line_period_quantity = nil
	m.clearedFields[billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity] = struct{}{}
}

// PreLinePeriodQuantityCleared returns if the "pre_line_period_quantity" field was cleared in this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) PreLinePeriodQuantityCleared() bool {
	_, ok := m.clearedFields[billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity]
	return ok
}

// ResetPreLinePeriodQuantity resets all changes to the "pre_line_period_quantity" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ResetPreLinePeriodQuantity() {
	m.pre_line_period_quantity = nil
	delete(m.clearedFields, billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity)
}

// SetMeteredPreLinePeriodQuantity sets the "metered_pre_line_period_quantity" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) SetMeteredPreLinePeriodQuantity(a alpacadecimal.Decimal) {
	m.metered_pre_line_period_quantity = &a
}

// MeteredPreLinePeriodQuantity returns the value of the "metered_pre_line_period_quantity" field in the mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) MeteredPreLinePeriodQuantity() (r alpacadecimal.Decimal, exists bool) {
	v := m.metered_pre_line_period_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldMeteredPreLinePeriodQuantity returns the old "metered_pre_line_period_quantity" field's value of the BillingInvoiceUsageBasedLineConfig entity.
// If the BillingInvoiceUsageBasedLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceUsageBasedLineConfigMutation) OldMeteredPreLinePeriodQuantity(ctx context.Context) (v *alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeteredPreLinePeriodQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeteredPreLinePeriodQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeteredPreLinePeriodQuantity: %w", err)
	}
	return oldValue.MeteredPreLinePeriodQuantity, nil
}

// ClearMeteredPreLinePeriodQuantity clears the value of the "metered_pre_line_period_quantity" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ClearMeteredPreLinePeriodQuantity() {
	m.metered_pre_line_period_quantity = nil
	m.clearedFields[billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity] = struct{}{}
}

// MeteredPreLinePeriodQuantityCleared returns if the "metered_pre_line_period_quantity" field was cleared in this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) MeteredPreLinePeriodQuantityCleared() bool {
	_, ok := m.clearedFields[billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity]
	return ok
}

// ResetMeteredPreLinePeriodQuantity resets all changes to the "metered_pre_line_period_quantity" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ResetMeteredPreLinePeriodQuantity() {
	m.metered_pre_line_period_quantity = nil
	delete(m.clearedFields, billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity)
}

// SetMeteredQuantity sets the "metered_quantity" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) SetMeteredQuantity(a alpacadecimal.Decimal) {
	m.metered_quantity = &a
}

// MeteredQuantity returns the value of the "metered_quantity" field in the mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) MeteredQuantity() (r alpacadecimal.Decimal, exists bool) {
	v := m.metered_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldMeteredQuantity returns the old "metered_quantity" field's value of the BillingInvoiceUsageBasedLineConfig entity.
// If the BillingInvoiceUsageBasedLineConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceUsageBasedLineConfigMutation) OldMeteredQuantity(ctx context.Context) (v *alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeteredQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeteredQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeteredQuantity: %w", err)
	}
	return oldValue.MeteredQuantity, nil
}

// ClearMeteredQuantity clears the value of the "metered_quantity" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ClearMeteredQuantity() {
	m.metered_quantity = nil
	m.clearedFields[billinginvoiceusagebasedlineconfig.FieldMeteredQuantity] = struct{}{}
}

// MeteredQuantityCleared returns if the "metered_quantity" field was cleared in this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) MeteredQuantityCleared() bool {
	_, ok := m.clearedFields[billinginvoiceusagebasedlineconfig.FieldMeteredQuantity]
	return ok
}

// ResetMeteredQuantity resets all changes to the "metered_quantity" field.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ResetMeteredQuantity() {
	m.metered_quantity = nil
	delete(m.clearedFields, billinginvoiceusagebasedlineconfig.FieldMeteredQuantity)
}

// Where appends a list predicates to the BillingInvoiceUsageBasedLineConfigMutation builder.
func (m *BillingInvoiceUsageBasedLineConfigMutation) Where(ps ...predicate.BillingInvoiceUsageBasedLineConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceUsageBasedLineConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceUsageBasedLineConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoiceUsageBasedLineConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceUsageBasedLineConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoiceUsageBasedLineConfig).
func (m *BillingInvoiceUsageBasedLineConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceUsageBasedLineConfigMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.namespace != nil {
		fields = append(fields, billinginvoiceusagebasedlineconfig.FieldNamespace)
	}
	if m.price_type != nil {
		fields = append(fields, billinginvoiceusagebasedlineconfig.FieldPriceType)
	}
	if m.feature_key != nil {
		fields = append(fields, billinginvoiceusagebasedlineconfig.FieldFeatureKey)
	}
	if m.price != nil {
		fields = append(fields, billinginvoiceusagebasedlineconfig.FieldPrice)
	}
	if m.pre_line_period_quantity != nil {
		fields = append(fields, billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity)
	}
	if m.metered_pre_line_period_quantity != nil {
		fields = append(fields, billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity)
	}
	if m.metered_quantity != nil {
		fields = append(fields, billinginvoiceusagebasedlineconfig.FieldMeteredQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceUsageBasedLineConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoiceusagebasedlineconfig.FieldNamespace:
		return m.Namespace()
	case billinginvoiceusagebasedlineconfig.FieldPriceType:
		return m.PriceType()
	case billinginvoiceusagebasedlineconfig.FieldFeatureKey:
		return m.FeatureKey()
	case billinginvoiceusagebasedlineconfig.FieldPrice:
		return m.Price()
	case billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity:
		return m.PreLinePeriodQuantity()
	case billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity:
		return m.MeteredPreLinePeriodQuantity()
	case billinginvoiceusagebasedlineconfig.FieldMeteredQuantity:
		return m.MeteredQuantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceUsageBasedLineConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoiceusagebasedlineconfig.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoiceusagebasedlineconfig.FieldPriceType:
		return m.OldPriceType(ctx)
	case billinginvoiceusagebasedlineconfig.FieldFeatureKey:
		return m.OldFeatureKey(ctx)
	case billinginvoiceusagebasedlineconfig.FieldPrice:
		return m.OldPrice(ctx)
	case billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity:
		return m.OldPreLinePeriodQuantity(ctx)
	case billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity:
		return m.OldMeteredPreLinePeriodQuantity(ctx)
	case billinginvoiceusagebasedlineconfig.FieldMeteredQuantity:
		return m.OldMeteredQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoiceUsageBasedLineConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceUsageBasedLineConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoiceusagebasedlineconfig.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoiceusagebasedlineconfig.FieldPriceType:
		v, ok := value.(productcatalog.PriceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceType(v)
		return nil
	case billinginvoiceusagebasedlineconfig.FieldFeatureKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureKey(v)
		return nil
	case billinginvoiceusagebasedlineconfig.FieldPrice:
		v, ok := value.(*productcatalog.Price)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreLinePeriodQuantity(v)
		return nil
	case billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeteredPreLinePeriodQuantity(v)
		return nil
	case billinginvoiceusagebasedlineconfig.FieldMeteredQuantity:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeteredQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceUsageBasedLineConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceUsageBasedLineConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceUsageBasedLineConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoiceUsageBasedLineConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity) {
		fields = append(fields, billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity)
	}
	if m.FieldCleared(billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity) {
		fields = append(fields, billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity)
	}
	if m.FieldCleared(billinginvoiceusagebasedlineconfig.FieldMeteredQuantity) {
		fields = append(fields, billinginvoiceusagebasedlineconfig.FieldMeteredQuantity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ClearField(name string) error {
	switch name {
	case billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity:
		m.ClearPreLinePeriodQuantity()
		return nil
	case billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity:
		m.ClearMeteredPreLinePeriodQuantity()
		return nil
	case billinginvoiceusagebasedlineconfig.FieldMeteredQuantity:
		m.ClearMeteredQuantity()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceUsageBasedLineConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ResetField(name string) error {
	switch name {
	case billinginvoiceusagebasedlineconfig.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoiceusagebasedlineconfig.FieldPriceType:
		m.ResetPriceType()
		return nil
	case billinginvoiceusagebasedlineconfig.FieldFeatureKey:
		m.ResetFeatureKey()
		return nil
	case billinginvoiceusagebasedlineconfig.FieldPrice:
		m.ResetPrice()
		return nil
	case billinginvoiceusagebasedlineconfig.FieldPreLinePeriodQuantity:
		m.ResetPreLinePeriodQuantity()
		return nil
	case billinginvoiceusagebasedlineconfig.FieldMeteredPreLinePeriodQuantity:
		m.ResetMeteredPreLinePeriodQuantity()
		return nil
	case billinginvoiceusagebasedlineconfig.FieldMeteredQuantity:
		m.ResetMeteredQuantity()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceUsageBasedLineConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceUsageBasedLineConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BillingInvoiceUsageBasedLineConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceUsageBasedLineConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BillingInvoiceUsageBasedLineConfig edge %s", name)
}

// BillingInvoiceValidationIssueMutation represents an operation that mutates the BillingInvoiceValidationIssue nodes in the graph.
type BillingInvoiceValidationIssueMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	namespace              *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	severity               *billing.ValidationIssueSeverity
	code                   *string
	message                *string
	_path                  *string
	component              *string
	dedupe_hash            *[]byte
	clearedFields          map[string]struct{}
	billing_invoice        *string
	clearedbilling_invoice bool
	done                   bool
	oldValue               func(context.Context) (*BillingInvoiceValidationIssue, error)
	predicates             []predicate.BillingInvoiceValidationIssue
}

var _ ent.Mutation = (*BillingInvoiceValidationIssueMutation)(nil)

// billinginvoicevalidationissueOption allows management of the mutation configuration using functional options.
type billinginvoicevalidationissueOption func(*BillingInvoiceValidationIssueMutation)

// newBillingInvoiceValidationIssueMutation creates new mutation for the BillingInvoiceValidationIssue entity.
func newBillingInvoiceValidationIssueMutation(c config, op Op, opts ...billinginvoicevalidationissueOption) *BillingInvoiceValidationIssueMutation {
	m := &BillingInvoiceValidationIssueMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingInvoiceValidationIssue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingInvoiceValidationIssueID sets the ID field of the mutation.
func withBillingInvoiceValidationIssueID(id string) billinginvoicevalidationissueOption {
	return func(m *BillingInvoiceValidationIssueMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingInvoiceValidationIssue
		)
		m.oldValue = func(ctx context.Context) (*BillingInvoiceValidationIssue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingInvoiceValidationIssue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingInvoiceValidationIssue sets the old BillingInvoiceValidationIssue of the mutation.
func withBillingInvoiceValidationIssue(node *BillingInvoiceValidationIssue) billinginvoicevalidationissueOption {
	return func(m *BillingInvoiceValidationIssueMutation) {
		m.oldValue = func(context.Context) (*BillingInvoiceValidationIssue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingInvoiceValidationIssueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingInvoiceValidationIssueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingInvoiceValidationIssue entities.
func (m *BillingInvoiceValidationIssueMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingInvoiceValidationIssueMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingInvoiceValidationIssueMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingInvoiceValidationIssue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingInvoiceValidationIssueMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingInvoiceValidationIssueMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingInvoiceValidationIssueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingInvoiceValidationIssueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingInvoiceValidationIssueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingInvoiceValidationIssueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingInvoiceValidationIssueMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingInvoiceValidationIssueMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billinginvoicevalidationissue.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billinginvoicevalidationissue.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingInvoiceValidationIssueMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billinginvoicevalidationissue.FieldDeletedAt)
}

// SetInvoiceID sets the "invoice_id" field.
func (m *BillingInvoiceValidationIssueMutation) SetInvoiceID(s string) {
	m.billing_invoice = &s
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) InvoiceID() (r string, exists bool) {
	v := m.billing_invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldInvoiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *BillingInvoiceValidationIssueMutation) ResetInvoiceID() {
	m.billing_invoice = nil
}

// SetSeverity sets the "severity" field.
func (m *BillingInvoiceValidationIssueMutation) SetSeverity(bis billing.ValidationIssueSeverity) {
	m.severity = &bis
}

// Severity returns the value of the "severity" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Severity() (r billing.ValidationIssueSeverity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldSeverity(ctx context.Context) (v billing.ValidationIssueSeverity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *BillingInvoiceValidationIssueMutation) ResetSeverity() {
	m.severity = nil
}

// SetCode sets the "code" field.
func (m *BillingInvoiceValidationIssueMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *BillingInvoiceValidationIssueMutation) ClearCode() {
	m.code = nil
	m.clearedFields[billinginvoicevalidationissue.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) CodeCleared() bool {
	_, ok := m.clearedFields[billinginvoicevalidationissue.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *BillingInvoiceValidationIssueMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, billinginvoicevalidationissue.FieldCode)
}

// SetMessage sets the "message" field.
func (m *BillingInvoiceValidationIssueMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *BillingInvoiceValidationIssueMutation) ResetMessage() {
	m.message = nil
}

// SetPath sets the "path" field.
func (m *BillingInvoiceValidationIssueMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *BillingInvoiceValidationIssueMutation) ClearPath() {
	m._path = nil
	m.clearedFields[billinginvoicevalidationissue.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) PathCleared() bool {
	_, ok := m.clearedFields[billinginvoicevalidationissue.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *BillingInvoiceValidationIssueMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, billinginvoicevalidationissue.FieldPath)
}

// SetComponent sets the "component" field.
func (m *BillingInvoiceValidationIssueMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldComponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ResetComponent resets all changes to the "component" field.
func (m *BillingInvoiceValidationIssueMutation) ResetComponent() {
	m.component = nil
}

// SetDedupeHash sets the "dedupe_hash" field.
func (m *BillingInvoiceValidationIssueMutation) SetDedupeHash(b []byte) {
	m.dedupe_hash = &b
}

// DedupeHash returns the value of the "dedupe_hash" field in the mutation.
func (m *BillingInvoiceValidationIssueMutation) DedupeHash() (r []byte, exists bool) {
	v := m.dedupe_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldDedupeHash returns the old "dedupe_hash" field's value of the BillingInvoiceValidationIssue entity.
// If the BillingInvoiceValidationIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingInvoiceValidationIssueMutation) OldDedupeHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDedupeHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDedupeHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDedupeHash: %w", err)
	}
	return oldValue.DedupeHash, nil
}

// ResetDedupeHash resets all changes to the "dedupe_hash" field.
func (m *BillingInvoiceValidationIssueMutation) ResetDedupeHash() {
	m.dedupe_hash = nil
}

// SetBillingInvoiceID sets the "billing_invoice" edge to the BillingInvoice entity by id.
func (m *BillingInvoiceValidationIssueMutation) SetBillingInvoiceID(id string) {
	m.billing_invoice = &id
}

// ClearBillingInvoice clears the "billing_invoice" edge to the BillingInvoice entity.
func (m *BillingInvoiceValidationIssueMutation) ClearBillingInvoice() {
	m.clearedbilling_invoice = true
	m.clearedFields[billinginvoicevalidationissue.FieldInvoiceID] = struct{}{}
}

// BillingInvoiceCleared reports if the "billing_invoice" edge to the BillingInvoice entity was cleared.
func (m *BillingInvoiceValidationIssueMutation) BillingInvoiceCleared() bool {
	return m.clearedbilling_invoice
}

// BillingInvoiceID returns the "billing_invoice" edge ID in the mutation.
func (m *BillingInvoiceValidationIssueMutation) BillingInvoiceID() (id string, exists bool) {
	if m.billing_invoice != nil {
		return *m.billing_invoice, true
	}
	return
}

// BillingInvoiceIDs returns the "billing_invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoiceID instead. It exists only for internal usage by the builders.
func (m *BillingInvoiceValidationIssueMutation) BillingInvoiceIDs() (ids []string) {
	if id := m.billing_invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoice resets all changes to the "billing_invoice" edge.
func (m *BillingInvoiceValidationIssueMutation) ResetBillingInvoice() {
	m.billing_invoice = nil
	m.clearedbilling_invoice = false
}

// Where appends a list predicates to the BillingInvoiceValidationIssueMutation builder.
func (m *BillingInvoiceValidationIssueMutation) Where(ps ...predicate.BillingInvoiceValidationIssue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingInvoiceValidationIssueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingInvoiceValidationIssueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingInvoiceValidationIssue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingInvoiceValidationIssueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingInvoiceValidationIssueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingInvoiceValidationIssue).
func (m *BillingInvoiceValidationIssueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingInvoiceValidationIssueMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.namespace != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldDeletedAt)
	}
	if m.billing_invoice != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldInvoiceID)
	}
	if m.severity != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldSeverity)
	}
	if m.code != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldCode)
	}
	if m.message != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldMessage)
	}
	if m._path != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldPath)
	}
	if m.component != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldComponent)
	}
	if m.dedupe_hash != nil {
		fields = append(fields, billinginvoicevalidationissue.FieldDedupeHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingInvoiceValidationIssueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billinginvoicevalidationissue.FieldNamespace:
		return m.Namespace()
	case billinginvoicevalidationissue.FieldCreatedAt:
		return m.CreatedAt()
	case billinginvoicevalidationissue.FieldUpdatedAt:
		return m.UpdatedAt()
	case billinginvoicevalidationissue.FieldDeletedAt:
		return m.DeletedAt()
	case billinginvoicevalidationissue.FieldInvoiceID:
		return m.InvoiceID()
	case billinginvoicevalidationissue.FieldSeverity:
		return m.Severity()
	case billinginvoicevalidationissue.FieldCode:
		return m.Code()
	case billinginvoicevalidationissue.FieldMessage:
		return m.Message()
	case billinginvoicevalidationissue.FieldPath:
		return m.Path()
	case billinginvoicevalidationissue.FieldComponent:
		return m.Component()
	case billinginvoicevalidationissue.FieldDedupeHash:
		return m.DedupeHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingInvoiceValidationIssueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billinginvoicevalidationissue.FieldNamespace:
		return m.OldNamespace(ctx)
	case billinginvoicevalidationissue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billinginvoicevalidationissue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billinginvoicevalidationissue.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billinginvoicevalidationissue.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	case billinginvoicevalidationissue.FieldSeverity:
		return m.OldSeverity(ctx)
	case billinginvoicevalidationissue.FieldCode:
		return m.OldCode(ctx)
	case billinginvoicevalidationissue.FieldMessage:
		return m.OldMessage(ctx)
	case billinginvoicevalidationissue.FieldPath:
		return m.OldPath(ctx)
	case billinginvoicevalidationissue.FieldComponent:
		return m.OldComponent(ctx)
	case billinginvoicevalidationissue.FieldDedupeHash:
		return m.OldDedupeHash(ctx)
	}
	return nil, fmt.Errorf("unknown BillingInvoiceValidationIssue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceValidationIssueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billinginvoicevalidationissue.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billinginvoicevalidationissue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billinginvoicevalidationissue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billinginvoicevalidationissue.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billinginvoicevalidationissue.FieldInvoiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	case billinginvoicevalidationissue.FieldSeverity:
		v, ok := value.(billing.ValidationIssueSeverity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case billinginvoicevalidationissue.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case billinginvoicevalidationissue.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case billinginvoicevalidationissue.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case billinginvoicevalidationissue.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case billinginvoicevalidationissue.FieldDedupeHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDedupeHash(v)
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingInvoiceValidationIssueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingInvoiceValidationIssueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingInvoiceValidationIssueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingInvoiceValidationIssueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billinginvoicevalidationissue.FieldDeletedAt) {
		fields = append(fields, billinginvoicevalidationissue.FieldDeletedAt)
	}
	if m.FieldCleared(billinginvoicevalidationissue.FieldCode) {
		fields = append(fields, billinginvoicevalidationissue.FieldCode)
	}
	if m.FieldCleared(billinginvoicevalidationissue.FieldPath) {
		fields = append(fields, billinginvoicevalidationissue.FieldPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingInvoiceValidationIssueMutation) ClearField(name string) error {
	switch name {
	case billinginvoicevalidationissue.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billinginvoicevalidationissue.FieldCode:
		m.ClearCode()
		return nil
	case billinginvoicevalidationissue.FieldPath:
		m.ClearPath()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingInvoiceValidationIssueMutation) ResetField(name string) error {
	switch name {
	case billinginvoicevalidationissue.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billinginvoicevalidationissue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billinginvoicevalidationissue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billinginvoicevalidationissue.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billinginvoicevalidationissue.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	case billinginvoicevalidationissue.FieldSeverity:
		m.ResetSeverity()
		return nil
	case billinginvoicevalidationissue.FieldCode:
		m.ResetCode()
		return nil
	case billinginvoicevalidationissue.FieldMessage:
		m.ResetMessage()
		return nil
	case billinginvoicevalidationissue.FieldPath:
		m.ResetPath()
		return nil
	case billinginvoicevalidationissue.FieldComponent:
		m.ResetComponent()
		return nil
	case billinginvoicevalidationissue.FieldDedupeHash:
		m.ResetDedupeHash()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingInvoiceValidationIssueMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.billing_invoice != nil {
		edges = append(edges, billinginvoicevalidationissue.EdgeBillingInvoice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingInvoiceValidationIssueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billinginvoicevalidationissue.EdgeBillingInvoice:
		if id := m.billing_invoice; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingInvoiceValidationIssueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingInvoiceValidationIssueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbilling_invoice {
		edges = append(edges, billinginvoicevalidationissue.EdgeBillingInvoice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingInvoiceValidationIssueMutation) EdgeCleared(name string) bool {
	switch name {
	case billinginvoicevalidationissue.EdgeBillingInvoice:
		return m.clearedbilling_invoice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingInvoiceValidationIssueMutation) ClearEdge(name string) error {
	switch name {
	case billinginvoicevalidationissue.EdgeBillingInvoice:
		m.ClearBillingInvoice()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingInvoiceValidationIssueMutation) ResetEdge(name string) error {
	switch name {
	case billinginvoicevalidationissue.EdgeBillingInvoice:
		m.ResetBillingInvoice()
		return nil
	}
	return fmt.Errorf("unknown BillingInvoiceValidationIssue edge %s", name)
}

// BillingProfileMutation represents an operation that mutates the BillingProfile nodes in the graph.
type BillingProfileMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	namespace                        *string
	metadata                         *map[string]string
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	name                             *string
	description                      *string
	supplier_address_country         *models.CountryCode
	supplier_address_postal_code     *string
	supplier_address_state           *string
	supplier_address_city            *string
	supplier_address_line1           *string
	supplier_address_line2           *string
	supplier_address_phone_number    *string
	_default                         *bool
	supplier_name                    *string
	supplier_tax_code                *string
	clearedFields                    map[string]struct{}
	billing_invoices                 map[string]struct{}
	removedbilling_invoices          map[string]struct{}
	clearedbilling_invoices          bool
	billing_customer_override        map[string]struct{}
	removedbilling_customer_override map[string]struct{}
	clearedbilling_customer_override bool
	workflow_config                  *string
	clearedworkflow_config           bool
	tax_app                          *string
	clearedtax_app                   bool
	invoicing_app                    *string
	clearedinvoicing_app             bool
	payment_app                      *string
	clearedpayment_app               bool
	done                             bool
	oldValue                         func(context.Context) (*BillingProfile, error)
	predicates                       []predicate.BillingProfile
}

var _ ent.Mutation = (*BillingProfileMutation)(nil)

// billingprofileOption allows management of the mutation configuration using functional options.
type billingprofileOption func(*BillingProfileMutation)

// newBillingProfileMutation creates new mutation for the BillingProfile entity.
func newBillingProfileMutation(c config, op Op, opts ...billingprofileOption) *BillingProfileMutation {
	m := &BillingProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingProfileID sets the ID field of the mutation.
func withBillingProfileID(id string) billingprofileOption {
	return func(m *BillingProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingProfile
		)
		m.oldValue = func(ctx context.Context) (*BillingProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingProfile sets the old BillingProfile of the mutation.
func withBillingProfile(node *BillingProfile) billingprofileOption {
	return func(m *BillingProfileMutation) {
		m.oldValue = func(context.Context) (*BillingProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingProfile entities.
func (m *BillingProfileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingProfileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingProfileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingProfileMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingProfileMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingProfileMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *BillingProfileMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *BillingProfileMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *BillingProfileMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[billingprofile.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *BillingProfileMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *BillingProfileMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, billingprofile.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingProfileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingProfileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingProfileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billingprofile.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingProfileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingProfileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billingprofile.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BillingProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BillingProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BillingProfileMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BillingProfileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BillingProfileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BillingProfileMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[billingprofile.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BillingProfileMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BillingProfileMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, billingprofile.FieldDescription)
}

// SetSupplierAddressCountry sets the "supplier_address_country" field.
func (m *BillingProfileMutation) SetSupplierAddressCountry(mc models.CountryCode) {
	m.supplier_address_country = &mc
}

// SupplierAddressCountry returns the value of the "supplier_address_country" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressCountry() (r models.CountryCode, exists bool) {
	v := m.supplier_address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressCountry returns the old "supplier_address_country" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressCountry(ctx context.Context) (v *models.CountryCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressCountry: %w", err)
	}
	return oldValue.SupplierAddressCountry, nil
}

// ClearSupplierAddressCountry clears the value of the "supplier_address_country" field.
func (m *BillingProfileMutation) ClearSupplierAddressCountry() {
	m.supplier_address_country = nil
	m.clearedFields[billingprofile.FieldSupplierAddressCountry] = struct{}{}
}

// SupplierAddressCountryCleared returns if the "supplier_address_country" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressCountryCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressCountry]
	return ok
}

// ResetSupplierAddressCountry resets all changes to the "supplier_address_country" field.
func (m *BillingProfileMutation) ResetSupplierAddressCountry() {
	m.supplier_address_country = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressCountry)
}

// SetSupplierAddressPostalCode sets the "supplier_address_postal_code" field.
func (m *BillingProfileMutation) SetSupplierAddressPostalCode(s string) {
	m.supplier_address_postal_code = &s
}

// SupplierAddressPostalCode returns the value of the "supplier_address_postal_code" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressPostalCode() (r string, exists bool) {
	v := m.supplier_address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressPostalCode returns the old "supplier_address_postal_code" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressPostalCode: %w", err)
	}
	return oldValue.SupplierAddressPostalCode, nil
}

// ClearSupplierAddressPostalCode clears the value of the "supplier_address_postal_code" field.
func (m *BillingProfileMutation) ClearSupplierAddressPostalCode() {
	m.supplier_address_postal_code = nil
	m.clearedFields[billingprofile.FieldSupplierAddressPostalCode] = struct{}{}
}

// SupplierAddressPostalCodeCleared returns if the "supplier_address_postal_code" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressPostalCode]
	return ok
}

// ResetSupplierAddressPostalCode resets all changes to the "supplier_address_postal_code" field.
func (m *BillingProfileMutation) ResetSupplierAddressPostalCode() {
	m.supplier_address_postal_code = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressPostalCode)
}

// SetSupplierAddressState sets the "supplier_address_state" field.
func (m *BillingProfileMutation) SetSupplierAddressState(s string) {
	m.supplier_address_state = &s
}

// SupplierAddressState returns the value of the "supplier_address_state" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressState() (r string, exists bool) {
	v := m.supplier_address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressState returns the old "supplier_address_state" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressState: %w", err)
	}
	return oldValue.SupplierAddressState, nil
}

// ClearSupplierAddressState clears the value of the "supplier_address_state" field.
func (m *BillingProfileMutation) ClearSupplierAddressState() {
	m.supplier_address_state = nil
	m.clearedFields[billingprofile.FieldSupplierAddressState] = struct{}{}
}

// SupplierAddressStateCleared returns if the "supplier_address_state" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressStateCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressState]
	return ok
}

// ResetSupplierAddressState resets all changes to the "supplier_address_state" field.
func (m *BillingProfileMutation) ResetSupplierAddressState() {
	m.supplier_address_state = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressState)
}

// SetSupplierAddressCity sets the "supplier_address_city" field.
func (m *BillingProfileMutation) SetSupplierAddressCity(s string) {
	m.supplier_address_city = &s
}

// SupplierAddressCity returns the value of the "supplier_address_city" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressCity() (r string, exists bool) {
	v := m.supplier_address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressCity returns the old "supplier_address_city" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressCity: %w", err)
	}
	return oldValue.SupplierAddressCity, nil
}

// ClearSupplierAddressCity clears the value of the "supplier_address_city" field.
func (m *BillingProfileMutation) ClearSupplierAddressCity() {
	m.supplier_address_city = nil
	m.clearedFields[billingprofile.FieldSupplierAddressCity] = struct{}{}
}

// SupplierAddressCityCleared returns if the "supplier_address_city" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressCityCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressCity]
	return ok
}

// ResetSupplierAddressCity resets all changes to the "supplier_address_city" field.
func (m *BillingProfileMutation) ResetSupplierAddressCity() {
	m.supplier_address_city = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressCity)
}

// SetSupplierAddressLine1 sets the "supplier_address_line1" field.
func (m *BillingProfileMutation) SetSupplierAddressLine1(s string) {
	m.supplier_address_line1 = &s
}

// SupplierAddressLine1 returns the value of the "supplier_address_line1" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressLine1() (r string, exists bool) {
	v := m.supplier_address_line1
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressLine1 returns the old "supplier_address_line1" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressLine1: %w", err)
	}
	return oldValue.SupplierAddressLine1, nil
}

// ClearSupplierAddressLine1 clears the value of the "supplier_address_line1" field.
func (m *BillingProfileMutation) ClearSupplierAddressLine1() {
	m.supplier_address_line1 = nil
	m.clearedFields[billingprofile.FieldSupplierAddressLine1] = struct{}{}
}

// SupplierAddressLine1Cleared returns if the "supplier_address_line1" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressLine1Cleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressLine1]
	return ok
}

// ResetSupplierAddressLine1 resets all changes to the "supplier_address_line1" field.
func (m *BillingProfileMutation) ResetSupplierAddressLine1() {
	m.supplier_address_line1 = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressLine1)
}

// SetSupplierAddressLine2 sets the "supplier_address_line2" field.
func (m *BillingProfileMutation) SetSupplierAddressLine2(s string) {
	m.supplier_address_line2 = &s
}

// SupplierAddressLine2 returns the value of the "supplier_address_line2" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressLine2() (r string, exists bool) {
	v := m.supplier_address_line2
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressLine2 returns the old "supplier_address_line2" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressLine2: %w", err)
	}
	return oldValue.SupplierAddressLine2, nil
}

// ClearSupplierAddressLine2 clears the value of the "supplier_address_line2" field.
func (m *BillingProfileMutation) ClearSupplierAddressLine2() {
	m.supplier_address_line2 = nil
	m.clearedFields[billingprofile.FieldSupplierAddressLine2] = struct{}{}
}

// SupplierAddressLine2Cleared returns if the "supplier_address_line2" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressLine2Cleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressLine2]
	return ok
}

// ResetSupplierAddressLine2 resets all changes to the "supplier_address_line2" field.
func (m *BillingProfileMutation) ResetSupplierAddressLine2() {
	m.supplier_address_line2 = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressLine2)
}

// SetSupplierAddressPhoneNumber sets the "supplier_address_phone_number" field.
func (m *BillingProfileMutation) SetSupplierAddressPhoneNumber(s string) {
	m.supplier_address_phone_number = &s
}

// SupplierAddressPhoneNumber returns the value of the "supplier_address_phone_number" field in the mutation.
func (m *BillingProfileMutation) SupplierAddressPhoneNumber() (r string, exists bool) {
	v := m.supplier_address_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAddressPhoneNumber returns the old "supplier_address_phone_number" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierAddressPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierAddressPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierAddressPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAddressPhoneNumber: %w", err)
	}
	return oldValue.SupplierAddressPhoneNumber, nil
}

// ClearSupplierAddressPhoneNumber clears the value of the "supplier_address_phone_number" field.
func (m *BillingProfileMutation) ClearSupplierAddressPhoneNumber() {
	m.supplier_address_phone_number = nil
	m.clearedFields[billingprofile.FieldSupplierAddressPhoneNumber] = struct{}{}
}

// SupplierAddressPhoneNumberCleared returns if the "supplier_address_phone_number" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierAddressPhoneNumberCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierAddressPhoneNumber]
	return ok
}

// ResetSupplierAddressPhoneNumber resets all changes to the "supplier_address_phone_number" field.
func (m *BillingProfileMutation) ResetSupplierAddressPhoneNumber() {
	m.supplier_address_phone_number = nil
	delete(m.clearedFields, billingprofile.FieldSupplierAddressPhoneNumber)
}

// SetTaxAppID sets the "tax_app_id" field.
func (m *BillingProfileMutation) SetTaxAppID(s string) {
	m.tax_app = &s
}

// TaxAppID returns the value of the "tax_app_id" field in the mutation.
func (m *BillingProfileMutation) TaxAppID() (r string, exists bool) {
	v := m.tax_app
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAppID returns the old "tax_app_id" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldTaxAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAppID: %w", err)
	}
	return oldValue.TaxAppID, nil
}

// ResetTaxAppID resets all changes to the "tax_app_id" field.
func (m *BillingProfileMutation) ResetTaxAppID() {
	m.tax_app = nil
}

// SetInvoicingAppID sets the "invoicing_app_id" field.
func (m *BillingProfileMutation) SetInvoicingAppID(s string) {
	m.invoicing_app = &s
}

// InvoicingAppID returns the value of the "invoicing_app_id" field in the mutation.
func (m *BillingProfileMutation) InvoicingAppID() (r string, exists bool) {
	v := m.invoicing_app
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingAppID returns the old "invoicing_app_id" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldInvoicingAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingAppID: %w", err)
	}
	return oldValue.InvoicingAppID, nil
}

// ResetInvoicingAppID resets all changes to the "invoicing_app_id" field.
func (m *BillingProfileMutation) ResetInvoicingAppID() {
	m.invoicing_app = nil
}

// SetPaymentAppID sets the "payment_app_id" field.
func (m *BillingProfileMutation) SetPaymentAppID(s string) {
	m.payment_app = &s
}

// PaymentAppID returns the value of the "payment_app_id" field in the mutation.
func (m *BillingProfileMutation) PaymentAppID() (r string, exists bool) {
	v := m.payment_app
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentAppID returns the old "payment_app_id" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldPaymentAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentAppID: %w", err)
	}
	return oldValue.PaymentAppID, nil
}

// ResetPaymentAppID resets all changes to the "payment_app_id" field.
func (m *BillingProfileMutation) ResetPaymentAppID() {
	m.payment_app = nil
}

// SetWorkflowConfigID sets the "workflow_config_id" field.
func (m *BillingProfileMutation) SetWorkflowConfigID(s string) {
	m.workflow_config = &s
}

// WorkflowConfigID returns the value of the "workflow_config_id" field in the mutation.
func (m *BillingProfileMutation) WorkflowConfigID() (r string, exists bool) {
	v := m.workflow_config
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowConfigID returns the old "workflow_config_id" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldWorkflowConfigID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowConfigID: %w", err)
	}
	return oldValue.WorkflowConfigID, nil
}

// ResetWorkflowConfigID resets all changes to the "workflow_config_id" field.
func (m *BillingProfileMutation) ResetWorkflowConfigID() {
	m.workflow_config = nil
}

// SetDefault sets the "default" field.
func (m *BillingProfileMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *BillingProfileMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *BillingProfileMutation) ResetDefault() {
	m._default = nil
}

// SetSupplierName sets the "supplier_name" field.
func (m *BillingProfileMutation) SetSupplierName(s string) {
	m.supplier_name = &s
}

// SupplierName returns the value of the "supplier_name" field in the mutation.
func (m *BillingProfileMutation) SupplierName() (r string, exists bool) {
	v := m.supplier_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierName returns the old "supplier_name" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierName: %w", err)
	}
	return oldValue.SupplierName, nil
}

// ResetSupplierName resets all changes to the "supplier_name" field.
func (m *BillingProfileMutation) ResetSupplierName() {
	m.supplier_name = nil
}

// SetSupplierTaxCode sets the "supplier_tax_code" field.
func (m *BillingProfileMutation) SetSupplierTaxCode(s string) {
	m.supplier_tax_code = &s
}

// SupplierTaxCode returns the value of the "supplier_tax_code" field in the mutation.
func (m *BillingProfileMutation) SupplierTaxCode() (r string, exists bool) {
	v := m.supplier_tax_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierTaxCode returns the old "supplier_tax_code" field's value of the BillingProfile entity.
// If the BillingProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingProfileMutation) OldSupplierTaxCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierTaxCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierTaxCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierTaxCode: %w", err)
	}
	return oldValue.SupplierTaxCode, nil
}

// ClearSupplierTaxCode clears the value of the "supplier_tax_code" field.
func (m *BillingProfileMutation) ClearSupplierTaxCode() {
	m.supplier_tax_code = nil
	m.clearedFields[billingprofile.FieldSupplierTaxCode] = struct{}{}
}

// SupplierTaxCodeCleared returns if the "supplier_tax_code" field was cleared in this mutation.
func (m *BillingProfileMutation) SupplierTaxCodeCleared() bool {
	_, ok := m.clearedFields[billingprofile.FieldSupplierTaxCode]
	return ok
}

// ResetSupplierTaxCode resets all changes to the "supplier_tax_code" field.
func (m *BillingProfileMutation) ResetSupplierTaxCode() {
	m.supplier_tax_code = nil
	delete(m.clearedFields, billingprofile.FieldSupplierTaxCode)
}

// AddBillingInvoiceIDs adds the "billing_invoices" edge to the BillingInvoice entity by ids.
func (m *BillingProfileMutation) AddBillingInvoiceIDs(ids ...string) {
	if m.billing_invoices == nil {
		m.billing_invoices = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoices[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoices clears the "billing_invoices" edge to the BillingInvoice entity.
func (m *BillingProfileMutation) ClearBillingInvoices() {
	m.clearedbilling_invoices = true
}

// BillingInvoicesCleared reports if the "billing_invoices" edge to the BillingInvoice entity was cleared.
func (m *BillingProfileMutation) BillingInvoicesCleared() bool {
	return m.clearedbilling_invoices
}

// RemoveBillingInvoiceIDs removes the "billing_invoices" edge to the BillingInvoice entity by IDs.
func (m *BillingProfileMutation) RemoveBillingInvoiceIDs(ids ...string) {
	if m.removedbilling_invoices == nil {
		m.removedbilling_invoices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoices, ids[i])
		m.removedbilling_invoices[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoices returns the removed IDs of the "billing_invoices" edge to the BillingInvoice entity.
func (m *BillingProfileMutation) RemovedBillingInvoicesIDs() (ids []string) {
	for id := range m.removedbilling_invoices {
		ids = append(ids, id)
	}
	return
}

// BillingInvoicesIDs returns the "billing_invoices" edge IDs in the mutation.
func (m *BillingProfileMutation) BillingInvoicesIDs() (ids []string) {
	for id := range m.billing_invoices {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoices resets all changes to the "billing_invoices" edge.
func (m *BillingProfileMutation) ResetBillingInvoices() {
	m.billing_invoices = nil
	m.clearedbilling_invoices = false
	m.removedbilling_invoices = nil
}

// AddBillingCustomerOverrideIDs adds the "billing_customer_override" edge to the BillingCustomerOverride entity by ids.
func (m *BillingProfileMutation) AddBillingCustomerOverrideIDs(ids ...string) {
	if m.billing_customer_override == nil {
		m.billing_customer_override = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_customer_override[ids[i]] = struct{}{}
	}
}

// ClearBillingCustomerOverride clears the "billing_customer_override" edge to the BillingCustomerOverride entity.
func (m *BillingProfileMutation) ClearBillingCustomerOverride() {
	m.clearedbilling_customer_override = true
}

// BillingCustomerOverrideCleared reports if the "billing_customer_override" edge to the BillingCustomerOverride entity was cleared.
func (m *BillingProfileMutation) BillingCustomerOverrideCleared() bool {
	return m.clearedbilling_customer_override
}

// RemoveBillingCustomerOverrideIDs removes the "billing_customer_override" edge to the BillingCustomerOverride entity by IDs.
func (m *BillingProfileMutation) RemoveBillingCustomerOverrideIDs(ids ...string) {
	if m.removedbilling_customer_override == nil {
		m.removedbilling_customer_override = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_customer_override, ids[i])
		m.removedbilling_customer_override[ids[i]] = struct{}{}
	}
}

// RemovedBillingCustomerOverride returns the removed IDs of the "billing_customer_override" edge to the BillingCustomerOverride entity.
func (m *BillingProfileMutation) RemovedBillingCustomerOverrideIDs() (ids []string) {
	for id := range m.removedbilling_customer_override {
		ids = append(ids, id)
	}
	return
}

// BillingCustomerOverrideIDs returns the "billing_customer_override" edge IDs in the mutation.
func (m *BillingProfileMutation) BillingCustomerOverrideIDs() (ids []string) {
	for id := range m.billing_customer_override {
		ids = append(ids, id)
	}
	return
}

// ResetBillingCustomerOverride resets all changes to the "billing_customer_override" edge.
func (m *BillingProfileMutation) ResetBillingCustomerOverride() {
	m.billing_customer_override = nil
	m.clearedbilling_customer_override = false
	m.removedbilling_customer_override = nil
}

// ClearWorkflowConfig clears the "workflow_config" edge to the BillingWorkflowConfig entity.
func (m *BillingProfileMutation) ClearWorkflowConfig() {
	m.clearedworkflow_config = true
	m.clearedFields[billingprofile.FieldWorkflowConfigID] = struct{}{}
}

// WorkflowConfigCleared reports if the "workflow_config" edge to the BillingWorkflowConfig entity was cleared.
func (m *BillingProfileMutation) WorkflowConfigCleared() bool {
	return m.clearedworkflow_config
}

// WorkflowConfigIDs returns the "workflow_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowConfigID instead. It exists only for internal usage by the builders.
func (m *BillingProfileMutation) WorkflowConfigIDs() (ids []string) {
	if id := m.workflow_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowConfig resets all changes to the "workflow_config" edge.
func (m *BillingProfileMutation) ResetWorkflowConfig() {
	m.workflow_config = nil
	m.clearedworkflow_config = false
}

// ClearTaxApp clears the "tax_app" edge to the App entity.
func (m *BillingProfileMutation) ClearTaxApp() {
	m.clearedtax_app = true
	m.clearedFields[billingprofile.FieldTaxAppID] = struct{}{}
}

// TaxAppCleared reports if the "tax_app" edge to the App entity was cleared.
func (m *BillingProfileMutation) TaxAppCleared() bool {
	return m.clearedtax_app
}

// TaxAppIDs returns the "tax_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaxAppID instead. It exists only for internal usage by the builders.
func (m *BillingProfileMutation) TaxAppIDs() (ids []string) {
	if id := m.tax_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaxApp resets all changes to the "tax_app" edge.
func (m *BillingProfileMutation) ResetTaxApp() {
	m.tax_app = nil
	m.clearedtax_app = false
}

// ClearInvoicingApp clears the "invoicing_app" edge to the App entity.
func (m *BillingProfileMutation) ClearInvoicingApp() {
	m.clearedinvoicing_app = true
	m.clearedFields[billingprofile.FieldInvoicingAppID] = struct{}{}
}

// InvoicingAppCleared reports if the "invoicing_app" edge to the App entity was cleared.
func (m *BillingProfileMutation) InvoicingAppCleared() bool {
	return m.clearedinvoicing_app
}

// InvoicingAppIDs returns the "invoicing_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoicingAppID instead. It exists only for internal usage by the builders.
func (m *BillingProfileMutation) InvoicingAppIDs() (ids []string) {
	if id := m.invoicing_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoicingApp resets all changes to the "invoicing_app" edge.
func (m *BillingProfileMutation) ResetInvoicingApp() {
	m.invoicing_app = nil
	m.clearedinvoicing_app = false
}

// ClearPaymentApp clears the "payment_app" edge to the App entity.
func (m *BillingProfileMutation) ClearPaymentApp() {
	m.clearedpayment_app = true
	m.clearedFields[billingprofile.FieldPaymentAppID] = struct{}{}
}

// PaymentAppCleared reports if the "payment_app" edge to the App entity was cleared.
func (m *BillingProfileMutation) PaymentAppCleared() bool {
	return m.clearedpayment_app
}

// PaymentAppIDs returns the "payment_app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentAppID instead. It exists only for internal usage by the builders.
func (m *BillingProfileMutation) PaymentAppIDs() (ids []string) {
	if id := m.payment_app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentApp resets all changes to the "payment_app" edge.
func (m *BillingProfileMutation) ResetPaymentApp() {
	m.payment_app = nil
	m.clearedpayment_app = false
}

// Where appends a list predicates to the BillingProfileMutation builder.
func (m *BillingProfileMutation) Where(ps ...predicate.BillingProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingProfile).
func (m *BillingProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingProfileMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.namespace != nil {
		fields = append(fields, billingprofile.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, billingprofile.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, billingprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingprofile.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billingprofile.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, billingprofile.FieldName)
	}
	if m.description != nil {
		fields = append(fields, billingprofile.FieldDescription)
	}
	if m.supplier_address_country != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressCountry)
	}
	if m.supplier_address_postal_code != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressPostalCode)
	}
	if m.supplier_address_state != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressState)
	}
	if m.supplier_address_city != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressCity)
	}
	if m.supplier_address_line1 != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressLine1)
	}
	if m.supplier_address_line2 != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressLine2)
	}
	if m.supplier_address_phone_number != nil {
		fields = append(fields, billingprofile.FieldSupplierAddressPhoneNumber)
	}
	if m.tax_app != nil {
		fields = append(fields, billingprofile.FieldTaxAppID)
	}
	if m.invoicing_app != nil {
		fields = append(fields, billingprofile.FieldInvoicingAppID)
	}
	if m.payment_app != nil {
		fields = append(fields, billingprofile.FieldPaymentAppID)
	}
	if m.workflow_config != nil {
		fields = append(fields, billingprofile.FieldWorkflowConfigID)
	}
	if m._default != nil {
		fields = append(fields, billingprofile.FieldDefault)
	}
	if m.supplier_name != nil {
		fields = append(fields, billingprofile.FieldSupplierName)
	}
	if m.supplier_tax_code != nil {
		fields = append(fields, billingprofile.FieldSupplierTaxCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingprofile.FieldNamespace:
		return m.Namespace()
	case billingprofile.FieldMetadata:
		return m.Metadata()
	case billingprofile.FieldCreatedAt:
		return m.CreatedAt()
	case billingprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingprofile.FieldDeletedAt:
		return m.DeletedAt()
	case billingprofile.FieldName:
		return m.Name()
	case billingprofile.FieldDescription:
		return m.Description()
	case billingprofile.FieldSupplierAddressCountry:
		return m.SupplierAddressCountry()
	case billingprofile.FieldSupplierAddressPostalCode:
		return m.SupplierAddressPostalCode()
	case billingprofile.FieldSupplierAddressState:
		return m.SupplierAddressState()
	case billingprofile.FieldSupplierAddressCity:
		return m.SupplierAddressCity()
	case billingprofile.FieldSupplierAddressLine1:
		return m.SupplierAddressLine1()
	case billingprofile.FieldSupplierAddressLine2:
		return m.SupplierAddressLine2()
	case billingprofile.FieldSupplierAddressPhoneNumber:
		return m.SupplierAddressPhoneNumber()
	case billingprofile.FieldTaxAppID:
		return m.TaxAppID()
	case billingprofile.FieldInvoicingAppID:
		return m.InvoicingAppID()
	case billingprofile.FieldPaymentAppID:
		return m.PaymentAppID()
	case billingprofile.FieldWorkflowConfigID:
		return m.WorkflowConfigID()
	case billingprofile.FieldDefault:
		return m.Default()
	case billingprofile.FieldSupplierName:
		return m.SupplierName()
	case billingprofile.FieldSupplierTaxCode:
		return m.SupplierTaxCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingprofile.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingprofile.FieldMetadata:
		return m.OldMetadata(ctx)
	case billingprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingprofile.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billingprofile.FieldName:
		return m.OldName(ctx)
	case billingprofile.FieldDescription:
		return m.OldDescription(ctx)
	case billingprofile.FieldSupplierAddressCountry:
		return m.OldSupplierAddressCountry(ctx)
	case billingprofile.FieldSupplierAddressPostalCode:
		return m.OldSupplierAddressPostalCode(ctx)
	case billingprofile.FieldSupplierAddressState:
		return m.OldSupplierAddressState(ctx)
	case billingprofile.FieldSupplierAddressCity:
		return m.OldSupplierAddressCity(ctx)
	case billingprofile.FieldSupplierAddressLine1:
		return m.OldSupplierAddressLine1(ctx)
	case billingprofile.FieldSupplierAddressLine2:
		return m.OldSupplierAddressLine2(ctx)
	case billingprofile.FieldSupplierAddressPhoneNumber:
		return m.OldSupplierAddressPhoneNumber(ctx)
	case billingprofile.FieldTaxAppID:
		return m.OldTaxAppID(ctx)
	case billingprofile.FieldInvoicingAppID:
		return m.OldInvoicingAppID(ctx)
	case billingprofile.FieldPaymentAppID:
		return m.OldPaymentAppID(ctx)
	case billingprofile.FieldWorkflowConfigID:
		return m.OldWorkflowConfigID(ctx)
	case billingprofile.FieldDefault:
		return m.OldDefault(ctx)
	case billingprofile.FieldSupplierName:
		return m.OldSupplierName(ctx)
	case billingprofile.FieldSupplierTaxCode:
		return m.OldSupplierTaxCode(ctx)
	}
	return nil, fmt.Errorf("unknown BillingProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingprofile.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingprofile.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case billingprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingprofile.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billingprofile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case billingprofile.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case billingprofile.FieldSupplierAddressCountry:
		v, ok := value.(models.CountryCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressCountry(v)
		return nil
	case billingprofile.FieldSupplierAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressPostalCode(v)
		return nil
	case billingprofile.FieldSupplierAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressState(v)
		return nil
	case billingprofile.FieldSupplierAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressCity(v)
		return nil
	case billingprofile.FieldSupplierAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressLine1(v)
		return nil
	case billingprofile.FieldSupplierAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressLine2(v)
		return nil
	case billingprofile.FieldSupplierAddressPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAddressPhoneNumber(v)
		return nil
	case billingprofile.FieldTaxAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAppID(v)
		return nil
	case billingprofile.FieldInvoicingAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingAppID(v)
		return nil
	case billingprofile.FieldPaymentAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentAppID(v)
		return nil
	case billingprofile.FieldWorkflowConfigID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowConfigID(v)
		return nil
	case billingprofile.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	case billingprofile.FieldSupplierName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierName(v)
		return nil
	case billingprofile.FieldSupplierTaxCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierTaxCode(v)
		return nil
	}
	return fmt.Errorf("unknown BillingProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billingprofile.FieldMetadata) {
		fields = append(fields, billingprofile.FieldMetadata)
	}
	if m.FieldCleared(billingprofile.FieldDeletedAt) {
		fields = append(fields, billingprofile.FieldDeletedAt)
	}
	if m.FieldCleared(billingprofile.FieldDescription) {
		fields = append(fields, billingprofile.FieldDescription)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressCountry) {
		fields = append(fields, billingprofile.FieldSupplierAddressCountry)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressPostalCode) {
		fields = append(fields, billingprofile.FieldSupplierAddressPostalCode)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressState) {
		fields = append(fields, billingprofile.FieldSupplierAddressState)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressCity) {
		fields = append(fields, billingprofile.FieldSupplierAddressCity)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressLine1) {
		fields = append(fields, billingprofile.FieldSupplierAddressLine1)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressLine2) {
		fields = append(fields, billingprofile.FieldSupplierAddressLine2)
	}
	if m.FieldCleared(billingprofile.FieldSupplierAddressPhoneNumber) {
		fields = append(fields, billingprofile.FieldSupplierAddressPhoneNumber)
	}
	if m.FieldCleared(billingprofile.FieldSupplierTaxCode) {
		fields = append(fields, billingprofile.FieldSupplierTaxCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingProfileMutation) ClearField(name string) error {
	switch name {
	case billingprofile.FieldMetadata:
		m.ClearMetadata()
		return nil
	case billingprofile.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billingprofile.FieldDescription:
		m.ClearDescription()
		return nil
	case billingprofile.FieldSupplierAddressCountry:
		m.ClearSupplierAddressCountry()
		return nil
	case billingprofile.FieldSupplierAddressPostalCode:
		m.ClearSupplierAddressPostalCode()
		return nil
	case billingprofile.FieldSupplierAddressState:
		m.ClearSupplierAddressState()
		return nil
	case billingprofile.FieldSupplierAddressCity:
		m.ClearSupplierAddressCity()
		return nil
	case billingprofile.FieldSupplierAddressLine1:
		m.ClearSupplierAddressLine1()
		return nil
	case billingprofile.FieldSupplierAddressLine2:
		m.ClearSupplierAddressLine2()
		return nil
	case billingprofile.FieldSupplierAddressPhoneNumber:
		m.ClearSupplierAddressPhoneNumber()
		return nil
	case billingprofile.FieldSupplierTaxCode:
		m.ClearSupplierTaxCode()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingProfileMutation) ResetField(name string) error {
	switch name {
	case billingprofile.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingprofile.FieldMetadata:
		m.ResetMetadata()
		return nil
	case billingprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingprofile.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billingprofile.FieldName:
		m.ResetName()
		return nil
	case billingprofile.FieldDescription:
		m.ResetDescription()
		return nil
	case billingprofile.FieldSupplierAddressCountry:
		m.ResetSupplierAddressCountry()
		return nil
	case billingprofile.FieldSupplierAddressPostalCode:
		m.ResetSupplierAddressPostalCode()
		return nil
	case billingprofile.FieldSupplierAddressState:
		m.ResetSupplierAddressState()
		return nil
	case billingprofile.FieldSupplierAddressCity:
		m.ResetSupplierAddressCity()
		return nil
	case billingprofile.FieldSupplierAddressLine1:
		m.ResetSupplierAddressLine1()
		return nil
	case billingprofile.FieldSupplierAddressLine2:
		m.ResetSupplierAddressLine2()
		return nil
	case billingprofile.FieldSupplierAddressPhoneNumber:
		m.ResetSupplierAddressPhoneNumber()
		return nil
	case billingprofile.FieldTaxAppID:
		m.ResetTaxAppID()
		return nil
	case billingprofile.FieldInvoicingAppID:
		m.ResetInvoicingAppID()
		return nil
	case billingprofile.FieldPaymentAppID:
		m.ResetPaymentAppID()
		return nil
	case billingprofile.FieldWorkflowConfigID:
		m.ResetWorkflowConfigID()
		return nil
	case billingprofile.FieldDefault:
		m.ResetDefault()
		return nil
	case billingprofile.FieldSupplierName:
		m.ResetSupplierName()
		return nil
	case billingprofile.FieldSupplierTaxCode:
		m.ResetSupplierTaxCode()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.billing_invoices != nil {
		edges = append(edges, billingprofile.EdgeBillingInvoices)
	}
	if m.billing_customer_override != nil {
		edges = append(edges, billingprofile.EdgeBillingCustomerOverride)
	}
	if m.workflow_config != nil {
		edges = append(edges, billingprofile.EdgeWorkflowConfig)
	}
	if m.tax_app != nil {
		edges = append(edges, billingprofile.EdgeTaxApp)
	}
	if m.invoicing_app != nil {
		edges = append(edges, billingprofile.EdgeInvoicingApp)
	}
	if m.payment_app != nil {
		edges = append(edges, billingprofile.EdgePaymentApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		ids := make([]ent.Value, 0, len(m.billing_invoices))
		for id := range m.billing_invoices {
			ids = append(ids, id)
		}
		return ids
	case billingprofile.EdgeBillingCustomerOverride:
		ids := make([]ent.Value, 0, len(m.billing_customer_override))
		for id := range m.billing_customer_override {
			ids = append(ids, id)
		}
		return ids
	case billingprofile.EdgeWorkflowConfig:
		if id := m.workflow_config; id != nil {
			return []ent.Value{*id}
		}
	case billingprofile.EdgeTaxApp:
		if id := m.tax_app; id != nil {
			return []ent.Value{*id}
		}
	case billingprofile.EdgeInvoicingApp:
		if id := m.invoicing_app; id != nil {
			return []ent.Value{*id}
		}
	case billingprofile.EdgePaymentApp:
		if id := m.payment_app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedbilling_invoices != nil {
		edges = append(edges, billingprofile.EdgeBillingInvoices)
	}
	if m.removedbilling_customer_override != nil {
		edges = append(edges, billingprofile.EdgeBillingCustomerOverride)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoices))
		for id := range m.removedbilling_invoices {
			ids = append(ids, id)
		}
		return ids
	case billingprofile.EdgeBillingCustomerOverride:
		ids := make([]ent.Value, 0, len(m.removedbilling_customer_override))
		for id := range m.removedbilling_customer_override {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedbilling_invoices {
		edges = append(edges, billingprofile.EdgeBillingInvoices)
	}
	if m.clearedbilling_customer_override {
		edges = append(edges, billingprofile.EdgeBillingCustomerOverride)
	}
	if m.clearedworkflow_config {
		edges = append(edges, billingprofile.EdgeWorkflowConfig)
	}
	if m.clearedtax_app {
		edges = append(edges, billingprofile.EdgeTaxApp)
	}
	if m.clearedinvoicing_app {
		edges = append(edges, billingprofile.EdgeInvoicingApp)
	}
	if m.clearedpayment_app {
		edges = append(edges, billingprofile.EdgePaymentApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		return m.clearedbilling_invoices
	case billingprofile.EdgeBillingCustomerOverride:
		return m.clearedbilling_customer_override
	case billingprofile.EdgeWorkflowConfig:
		return m.clearedworkflow_config
	case billingprofile.EdgeTaxApp:
		return m.clearedtax_app
	case billingprofile.EdgeInvoicingApp:
		return m.clearedinvoicing_app
	case billingprofile.EdgePaymentApp:
		return m.clearedpayment_app
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingProfileMutation) ClearEdge(name string) error {
	switch name {
	case billingprofile.EdgeWorkflowConfig:
		m.ClearWorkflowConfig()
		return nil
	case billingprofile.EdgeTaxApp:
		m.ClearTaxApp()
		return nil
	case billingprofile.EdgeInvoicingApp:
		m.ClearInvoicingApp()
		return nil
	case billingprofile.EdgePaymentApp:
		m.ClearPaymentApp()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingProfileMutation) ResetEdge(name string) error {
	switch name {
	case billingprofile.EdgeBillingInvoices:
		m.ResetBillingInvoices()
		return nil
	case billingprofile.EdgeBillingCustomerOverride:
		m.ResetBillingCustomerOverride()
		return nil
	case billingprofile.EdgeWorkflowConfig:
		m.ResetWorkflowConfig()
		return nil
	case billingprofile.EdgeTaxApp:
		m.ResetTaxApp()
		return nil
	case billingprofile.EdgeInvoicingApp:
		m.ResetInvoicingApp()
		return nil
	case billingprofile.EdgePaymentApp:
		m.ResetPaymentApp()
		return nil
	}
	return fmt.Errorf("unknown BillingProfile edge %s", name)
}

// BillingSequenceNumbersMutation represents an operation that mutates the BillingSequenceNumbers nodes in the graph.
type BillingSequenceNumbersMutation struct {
	config
	op            Op
	typ           string
	id            *int
	namespace     *string
	scope         *string
	last          *alpacadecimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BillingSequenceNumbers, error)
	predicates    []predicate.BillingSequenceNumbers
}

var _ ent.Mutation = (*BillingSequenceNumbersMutation)(nil)

// billingsequencenumbersOption allows management of the mutation configuration using functional options.
type billingsequencenumbersOption func(*BillingSequenceNumbersMutation)

// newBillingSequenceNumbersMutation creates new mutation for the BillingSequenceNumbers entity.
func newBillingSequenceNumbersMutation(c config, op Op, opts ...billingsequencenumbersOption) *BillingSequenceNumbersMutation {
	m := &BillingSequenceNumbersMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingSequenceNumbers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingSequenceNumbersID sets the ID field of the mutation.
func withBillingSequenceNumbersID(id int) billingsequencenumbersOption {
	return func(m *BillingSequenceNumbersMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingSequenceNumbers
		)
		m.oldValue = func(ctx context.Context) (*BillingSequenceNumbers, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingSequenceNumbers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingSequenceNumbers sets the old BillingSequenceNumbers of the mutation.
func withBillingSequenceNumbers(node *BillingSequenceNumbers) billingsequencenumbersOption {
	return func(m *BillingSequenceNumbersMutation) {
		m.oldValue = func(context.Context) (*BillingSequenceNumbers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingSequenceNumbersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingSequenceNumbersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingSequenceNumbersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingSequenceNumbersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingSequenceNumbers.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingSequenceNumbersMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingSequenceNumbersMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingSequenceNumbers entity.
// If the BillingSequenceNumbers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingSequenceNumbersMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingSequenceNumbersMutation) ResetNamespace() {
	m.namespace = nil
}

// SetScope sets the "scope" field.
func (m *BillingSequenceNumbersMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *BillingSequenceNumbersMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the BillingSequenceNumbers entity.
// If the BillingSequenceNumbers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingSequenceNumbersMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *BillingSequenceNumbersMutation) ResetScope() {
	m.scope = nil
}

// SetLast sets the "last" field.
func (m *BillingSequenceNumbersMutation) SetLast(a alpacadecimal.Decimal) {
	m.last = &a
}

// Last returns the value of the "last" field in the mutation.
func (m *BillingSequenceNumbersMutation) Last() (r alpacadecimal.Decimal, exists bool) {
	v := m.last
	if v == nil {
		return
	}
	return *v, true
}

// OldLast returns the old "last" field's value of the BillingSequenceNumbers entity.
// If the BillingSequenceNumbers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingSequenceNumbersMutation) OldLast(ctx context.Context) (v alpacadecimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast: %w", err)
	}
	return oldValue.Last, nil
}

// ResetLast resets all changes to the "last" field.
func (m *BillingSequenceNumbersMutation) ResetLast() {
	m.last = nil
}

// Where appends a list predicates to the BillingSequenceNumbersMutation builder.
func (m *BillingSequenceNumbersMutation) Where(ps ...predicate.BillingSequenceNumbers) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingSequenceNumbersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingSequenceNumbersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingSequenceNumbers, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingSequenceNumbersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingSequenceNumbersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingSequenceNumbers).
func (m *BillingSequenceNumbersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingSequenceNumbersMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.namespace != nil {
		fields = append(fields, billingsequencenumbers.FieldNamespace)
	}
	if m.scope != nil {
		fields = append(fields, billingsequencenumbers.FieldScope)
	}
	if m.last != nil {
		fields = append(fields, billingsequencenumbers.FieldLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingSequenceNumbersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingsequencenumbers.FieldNamespace:
		return m.Namespace()
	case billingsequencenumbers.FieldScope:
		return m.Scope()
	case billingsequencenumbers.FieldLast:
		return m.Last()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingSequenceNumbersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingsequencenumbers.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingsequencenumbers.FieldScope:
		return m.OldScope(ctx)
	case billingsequencenumbers.FieldLast:
		return m.OldLast(ctx)
	}
	return nil, fmt.Errorf("unknown BillingSequenceNumbers field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingSequenceNumbersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingsequencenumbers.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingsequencenumbers.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case billingsequencenumbers.FieldLast:
		v, ok := value.(alpacadecimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast(v)
		return nil
	}
	return fmt.Errorf("unknown BillingSequenceNumbers field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingSequenceNumbersMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingSequenceNumbersMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingSequenceNumbersMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingSequenceNumbers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingSequenceNumbersMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingSequenceNumbersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingSequenceNumbersMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BillingSequenceNumbers nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingSequenceNumbersMutation) ResetField(name string) error {
	switch name {
	case billingsequencenumbers.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingsequencenumbers.FieldScope:
		m.ResetScope()
		return nil
	case billingsequencenumbers.FieldLast:
		m.ResetLast()
		return nil
	}
	return fmt.Errorf("unknown BillingSequenceNumbers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingSequenceNumbersMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingSequenceNumbersMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingSequenceNumbersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingSequenceNumbersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingSequenceNumbersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingSequenceNumbersMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingSequenceNumbersMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BillingSequenceNumbers unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingSequenceNumbersMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BillingSequenceNumbers edge %s", name)
}

// BillingWorkflowConfigMutation represents an operation that mutates the BillingWorkflowConfig nodes in the graph.
type BillingWorkflowConfigMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	namespace                    *string
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	collection_alignment         *billing.AlignmentKind
	line_collection_period       *isodate.String
	invoice_auto_advance         *bool
	invoice_draft_period         *isodate.String
	invoice_due_after            *isodate.String
	invoice_collection_method    *billing.CollectionMethod
	invoice_progressive_billing  *bool
	invoice_default_tax_settings *productcatalog.TaxConfig
	tax_enabled                  *bool
	tax_enforced                 *bool
	clearedFields                map[string]struct{}
	billing_invoices             *string
	clearedbilling_invoices      bool
	billing_profile              *string
	clearedbilling_profile       bool
	done                         bool
	oldValue                     func(context.Context) (*BillingWorkflowConfig, error)
	predicates                   []predicate.BillingWorkflowConfig
}

var _ ent.Mutation = (*BillingWorkflowConfigMutation)(nil)

// billingworkflowconfigOption allows management of the mutation configuration using functional options.
type billingworkflowconfigOption func(*BillingWorkflowConfigMutation)

// newBillingWorkflowConfigMutation creates new mutation for the BillingWorkflowConfig entity.
func newBillingWorkflowConfigMutation(c config, op Op, opts ...billingworkflowconfigOption) *BillingWorkflowConfigMutation {
	m := &BillingWorkflowConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingWorkflowConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingWorkflowConfigID sets the ID field of the mutation.
func withBillingWorkflowConfigID(id string) billingworkflowconfigOption {
	return func(m *BillingWorkflowConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingWorkflowConfig
		)
		m.oldValue = func(ctx context.Context) (*BillingWorkflowConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingWorkflowConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingWorkflowConfig sets the old BillingWorkflowConfig of the mutation.
func withBillingWorkflowConfig(node *BillingWorkflowConfig) billingworkflowconfigOption {
	return func(m *BillingWorkflowConfigMutation) {
		m.oldValue = func(context.Context) (*BillingWorkflowConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingWorkflowConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingWorkflowConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingWorkflowConfig entities.
func (m *BillingWorkflowConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingWorkflowConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingWorkflowConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingWorkflowConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *BillingWorkflowConfigMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *BillingWorkflowConfigMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *BillingWorkflowConfigMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingWorkflowConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingWorkflowConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingWorkflowConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingWorkflowConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingWorkflowConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingWorkflowConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BillingWorkflowConfigMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BillingWorkflowConfigMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BillingWorkflowConfigMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[billingworkflowconfig.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BillingWorkflowConfigMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[billingworkflowconfig.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BillingWorkflowConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, billingworkflowconfig.FieldDeletedAt)
}

// SetCollectionAlignment sets the "collection_alignment" field.
func (m *BillingWorkflowConfigMutation) SetCollectionAlignment(bk billing.AlignmentKind) {
	m.collection_alignment = &bk
}

// CollectionAlignment returns the value of the "collection_alignment" field in the mutation.
func (m *BillingWorkflowConfigMutation) CollectionAlignment() (r billing.AlignmentKind, exists bool) {
	v := m.collection_alignment
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionAlignment returns the old "collection_alignment" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldCollectionAlignment(ctx context.Context) (v billing.AlignmentKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionAlignment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionAlignment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionAlignment: %w", err)
	}
	return oldValue.CollectionAlignment, nil
}

// ResetCollectionAlignment resets all changes to the "collection_alignment" field.
func (m *BillingWorkflowConfigMutation) ResetCollectionAlignment() {
	m.collection_alignment = nil
}

// SetLineCollectionPeriod sets the "line_collection_period" field.
func (m *BillingWorkflowConfigMutation) SetLineCollectionPeriod(i isodate.String) {
	m.line_collection_period = &i
}

// LineCollectionPeriod returns the value of the "line_collection_period" field in the mutation.
func (m *BillingWorkflowConfigMutation) LineCollectionPeriod() (r isodate.String, exists bool) {
	v := m.line_collection_period
	if v == nil {
		return
	}
	return *v, true
}

// OldLineCollectionPeriod returns the old "line_collection_period" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldLineCollectionPeriod(ctx context.Context) (v isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineCollectionPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineCollectionPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineCollectionPeriod: %w", err)
	}
	return oldValue.LineCollectionPeriod, nil
}

// ResetLineCollectionPeriod resets all changes to the "line_collection_period" field.
func (m *BillingWorkflowConfigMutation) ResetLineCollectionPeriod() {
	m.line_collection_period = nil
}

// SetInvoiceAutoAdvance sets the "invoice_auto_advance" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceAutoAdvance(b bool) {
	m.invoice_auto_advance = &b
}

// InvoiceAutoAdvance returns the value of the "invoice_auto_advance" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceAutoAdvance() (r bool, exists bool) {
	v := m.invoice_auto_advance
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceAutoAdvance returns the old "invoice_auto_advance" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceAutoAdvance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceAutoAdvance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceAutoAdvance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceAutoAdvance: %w", err)
	}
	return oldValue.InvoiceAutoAdvance, nil
}

// ResetInvoiceAutoAdvance resets all changes to the "invoice_auto_advance" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceAutoAdvance() {
	m.invoice_auto_advance = nil
}

// SetInvoiceDraftPeriod sets the "invoice_draft_period" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceDraftPeriod(i isodate.String) {
	m.invoice_draft_period = &i
}

// InvoiceDraftPeriod returns the value of the "invoice_draft_period" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceDraftPeriod() (r isodate.String, exists bool) {
	v := m.invoice_draft_period
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDraftPeriod returns the old "invoice_draft_period" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceDraftPeriod(ctx context.Context) (v isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDraftPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDraftPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDraftPeriod: %w", err)
	}
	return oldValue.InvoiceDraftPeriod, nil
}

// ResetInvoiceDraftPeriod resets all changes to the "invoice_draft_period" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceDraftPeriod() {
	m.invoice_draft_period = nil
}

// SetInvoiceDueAfter sets the "invoice_due_after" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceDueAfter(i isodate.String) {
	m.invoice_due_after = &i
}

// InvoiceDueAfter returns the value of the "invoice_due_after" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceDueAfter() (r isodate.String, exists bool) {
	v := m.invoice_due_after
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDueAfter returns the old "invoice_due_after" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceDueAfter(ctx context.Context) (v isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDueAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDueAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDueAfter: %w", err)
	}
	return oldValue.InvoiceDueAfter, nil
}

// ResetInvoiceDueAfter resets all changes to the "invoice_due_after" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceDueAfter() {
	m.invoice_due_after = nil
}

// SetInvoiceCollectionMethod sets the "invoice_collection_method" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceCollectionMethod(bm billing.CollectionMethod) {
	m.invoice_collection_method = &bm
}

// InvoiceCollectionMethod returns the value of the "invoice_collection_method" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceCollectionMethod() (r billing.CollectionMethod, exists bool) {
	v := m.invoice_collection_method
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceCollectionMethod returns the old "invoice_collection_method" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceCollectionMethod(ctx context.Context) (v billing.CollectionMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceCollectionMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceCollectionMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceCollectionMethod: %w", err)
	}
	return oldValue.InvoiceCollectionMethod, nil
}

// ResetInvoiceCollectionMethod resets all changes to the "invoice_collection_method" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceCollectionMethod() {
	m.invoice_collection_method = nil
}

// SetInvoiceProgressiveBilling sets the "invoice_progressive_billing" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceProgressiveBilling(b bool) {
	m.invoice_progressive_billing = &b
}

// InvoiceProgressiveBilling returns the value of the "invoice_progressive_billing" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceProgressiveBilling() (r bool, exists bool) {
	v := m.invoice_progressive_billing
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceProgressiveBilling returns the old "invoice_progressive_billing" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceProgressiveBilling(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceProgressiveBilling is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceProgressiveBilling requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceProgressiveBilling: %w", err)
	}
	return oldValue.InvoiceProgressiveBilling, nil
}

// ResetInvoiceProgressiveBilling resets all changes to the "invoice_progressive_billing" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceProgressiveBilling() {
	m.invoice_progressive_billing = nil
}

// SetInvoiceDefaultTaxSettings sets the "invoice_default_tax_settings" field.
func (m *BillingWorkflowConfigMutation) SetInvoiceDefaultTaxSettings(pc productcatalog.TaxConfig) {
	m.invoice_default_tax_settings = &pc
}

// InvoiceDefaultTaxSettings returns the value of the "invoice_default_tax_settings" field in the mutation.
func (m *BillingWorkflowConfigMutation) InvoiceDefaultTaxSettings() (r productcatalog.TaxConfig, exists bool) {
	v := m.invoice_default_tax_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDefaultTaxSettings returns the old "invoice_default_tax_settings" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldInvoiceDefaultTaxSettings(ctx context.Context) (v productcatalog.TaxConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDefaultTaxSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDefaultTaxSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDefaultTaxSettings: %w", err)
	}
	return oldValue.InvoiceDefaultTaxSettings, nil
}

// ClearInvoiceDefaultTaxSettings clears the value of the "invoice_default_tax_settings" field.
func (m *BillingWorkflowConfigMutation) ClearInvoiceDefaultTaxSettings() {
	m.invoice_default_tax_settings = nil
	m.clearedFields[billingworkflowconfig.FieldInvoiceDefaultTaxSettings] = struct{}{}
}

// InvoiceDefaultTaxSettingsCleared returns if the "invoice_default_tax_settings" field was cleared in this mutation.
func (m *BillingWorkflowConfigMutation) InvoiceDefaultTaxSettingsCleared() bool {
	_, ok := m.clearedFields[billingworkflowconfig.FieldInvoiceDefaultTaxSettings]
	return ok
}

// ResetInvoiceDefaultTaxSettings resets all changes to the "invoice_default_tax_settings" field.
func (m *BillingWorkflowConfigMutation) ResetInvoiceDefaultTaxSettings() {
	m.invoice_default_tax_settings = nil
	delete(m.clearedFields, billingworkflowconfig.FieldInvoiceDefaultTaxSettings)
}

// SetTaxEnabled sets the "tax_enabled" field.
func (m *BillingWorkflowConfigMutation) SetTaxEnabled(b bool) {
	m.tax_enabled = &b
}

// TaxEnabled returns the value of the "tax_enabled" field in the mutation.
func (m *BillingWorkflowConfigMutation) TaxEnabled() (r bool, exists bool) {
	v := m.tax_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxEnabled returns the old "tax_enabled" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldTaxEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxEnabled: %w", err)
	}
	return oldValue.TaxEnabled, nil
}

// ResetTaxEnabled resets all changes to the "tax_enabled" field.
func (m *BillingWorkflowConfigMutation) ResetTaxEnabled() {
	m.tax_enabled = nil
}

// SetTaxEnforced sets the "tax_enforced" field.
func (m *BillingWorkflowConfigMutation) SetTaxEnforced(b bool) {
	m.tax_enforced = &b
}

// TaxEnforced returns the value of the "tax_enforced" field in the mutation.
func (m *BillingWorkflowConfigMutation) TaxEnforced() (r bool, exists bool) {
	v := m.tax_enforced
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxEnforced returns the old "tax_enforced" field's value of the BillingWorkflowConfig entity.
// If the BillingWorkflowConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingWorkflowConfigMutation) OldTaxEnforced(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxEnforced is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxEnforced requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxEnforced: %w", err)
	}
	return oldValue.TaxEnforced, nil
}

// ResetTaxEnforced resets all changes to the "tax_enforced" field.
func (m *BillingWorkflowConfigMutation) ResetTaxEnforced() {
	m.tax_enforced = nil
}

// SetBillingInvoicesID sets the "billing_invoices" edge to the BillingInvoice entity by id.
func (m *BillingWorkflowConfigMutation) SetBillingInvoicesID(id string) {
	m.billing_invoices = &id
}

// ClearBillingInvoices clears the "billing_invoices" edge to the BillingInvoice entity.
func (m *BillingWorkflowConfigMutation) ClearBillingInvoices() {
	m.clearedbilling_invoices = true
}

// BillingInvoicesCleared reports if the "billing_invoices" edge to the BillingInvoice entity was cleared.
func (m *BillingWorkflowConfigMutation) BillingInvoicesCleared() bool {
	return m.clearedbilling_invoices
}

// BillingInvoicesID returns the "billing_invoices" edge ID in the mutation.
func (m *BillingWorkflowConfigMutation) BillingInvoicesID() (id string, exists bool) {
	if m.billing_invoices != nil {
		return *m.billing_invoices, true
	}
	return
}

// BillingInvoicesIDs returns the "billing_invoices" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingInvoicesID instead. It exists only for internal usage by the builders.
func (m *BillingWorkflowConfigMutation) BillingInvoicesIDs() (ids []string) {
	if id := m.billing_invoices; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingInvoices resets all changes to the "billing_invoices" edge.
func (m *BillingWorkflowConfigMutation) ResetBillingInvoices() {
	m.billing_invoices = nil
	m.clearedbilling_invoices = false
}

// SetBillingProfileID sets the "billing_profile" edge to the BillingProfile entity by id.
func (m *BillingWorkflowConfigMutation) SetBillingProfileID(id string) {
	m.billing_profile = &id
}

// ClearBillingProfile clears the "billing_profile" edge to the BillingProfile entity.
func (m *BillingWorkflowConfigMutation) ClearBillingProfile() {
	m.clearedbilling_profile = true
}

// BillingProfileCleared reports if the "billing_profile" edge to the BillingProfile entity was cleared.
func (m *BillingWorkflowConfigMutation) BillingProfileCleared() bool {
	return m.clearedbilling_profile
}

// BillingProfileID returns the "billing_profile" edge ID in the mutation.
func (m *BillingWorkflowConfigMutation) BillingProfileID() (id string, exists bool) {
	if m.billing_profile != nil {
		return *m.billing_profile, true
	}
	return
}

// BillingProfileIDs returns the "billing_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingProfileID instead. It exists only for internal usage by the builders.
func (m *BillingWorkflowConfigMutation) BillingProfileIDs() (ids []string) {
	if id := m.billing_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingProfile resets all changes to the "billing_profile" edge.
func (m *BillingWorkflowConfigMutation) ResetBillingProfile() {
	m.billing_profile = nil
	m.clearedbilling_profile = false
}

// Where appends a list predicates to the BillingWorkflowConfigMutation builder.
func (m *BillingWorkflowConfigMutation) Where(ps ...predicate.BillingWorkflowConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingWorkflowConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingWorkflowConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingWorkflowConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingWorkflowConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingWorkflowConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingWorkflowConfig).
func (m *BillingWorkflowConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingWorkflowConfigMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.namespace != nil {
		fields = append(fields, billingworkflowconfig.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, billingworkflowconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingworkflowconfig.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, billingworkflowconfig.FieldDeletedAt)
	}
	if m.collection_alignment != nil {
		fields = append(fields, billingworkflowconfig.FieldCollectionAlignment)
	}
	if m.line_collection_period != nil {
		fields = append(fields, billingworkflowconfig.FieldLineCollectionPeriod)
	}
	if m.invoice_auto_advance != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceAutoAdvance)
	}
	if m.invoice_draft_period != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceDraftPeriod)
	}
	if m.invoice_due_after != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceDueAfter)
	}
	if m.invoice_collection_method != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceCollectionMethod)
	}
	if m.invoice_progressive_billing != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceProgressiveBilling)
	}
	if m.invoice_default_tax_settings != nil {
		fields = append(fields, billingworkflowconfig.FieldInvoiceDefaultTaxSettings)
	}
	if m.tax_enabled != nil {
		fields = append(fields, billingworkflowconfig.FieldTaxEnabled)
	}
	if m.tax_enforced != nil {
		fields = append(fields, billingworkflowconfig.FieldTaxEnforced)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingWorkflowConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		return m.Namespace()
	case billingworkflowconfig.FieldCreatedAt:
		return m.CreatedAt()
	case billingworkflowconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingworkflowconfig.FieldDeletedAt:
		return m.DeletedAt()
	case billingworkflowconfig.FieldCollectionAlignment:
		return m.CollectionAlignment()
	case billingworkflowconfig.FieldLineCollectionPeriod:
		return m.LineCollectionPeriod()
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		return m.InvoiceAutoAdvance()
	case billingworkflowconfig.FieldInvoiceDraftPeriod:
		return m.InvoiceDraftPeriod()
	case billingworkflowconfig.FieldInvoiceDueAfter:
		return m.InvoiceDueAfter()
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		return m.InvoiceCollectionMethod()
	case billingworkflowconfig.FieldInvoiceProgressiveBilling:
		return m.InvoiceProgressiveBilling()
	case billingworkflowconfig.FieldInvoiceDefaultTaxSettings:
		return m.InvoiceDefaultTaxSettings()
	case billingworkflowconfig.FieldTaxEnabled:
		return m.TaxEnabled()
	case billingworkflowconfig.FieldTaxEnforced:
		return m.TaxEnforced()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingWorkflowConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		return m.OldNamespace(ctx)
	case billingworkflowconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingworkflowconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingworkflowconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case billingworkflowconfig.FieldCollectionAlignment:
		return m.OldCollectionAlignment(ctx)
	case billingworkflowconfig.FieldLineCollectionPeriod:
		return m.OldLineCollectionPeriod(ctx)
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		return m.OldInvoiceAutoAdvance(ctx)
	case billingworkflowconfig.FieldInvoiceDraftPeriod:
		return m.OldInvoiceDraftPeriod(ctx)
	case billingworkflowconfig.FieldInvoiceDueAfter:
		return m.OldInvoiceDueAfter(ctx)
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		return m.OldInvoiceCollectionMethod(ctx)
	case billingworkflowconfig.FieldInvoiceProgressiveBilling:
		return m.OldInvoiceProgressiveBilling(ctx)
	case billingworkflowconfig.FieldInvoiceDefaultTaxSettings:
		return m.OldInvoiceDefaultTaxSettings(ctx)
	case billingworkflowconfig.FieldTaxEnabled:
		return m.OldTaxEnabled(ctx)
	case billingworkflowconfig.FieldTaxEnforced:
		return m.OldTaxEnforced(ctx)
	}
	return nil, fmt.Errorf("unknown BillingWorkflowConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingWorkflowConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case billingworkflowconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingworkflowconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingworkflowconfig.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case billingworkflowconfig.FieldCollectionAlignment:
		v, ok := value.(billing.AlignmentKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionAlignment(v)
		return nil
	case billingworkflowconfig.FieldLineCollectionPeriod:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineCollectionPeriod(v)
		return nil
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceAutoAdvance(v)
		return nil
	case billingworkflowconfig.FieldInvoiceDraftPeriod:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDraftPeriod(v)
		return nil
	case billingworkflowconfig.FieldInvoiceDueAfter:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDueAfter(v)
		return nil
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		v, ok := value.(billing.CollectionMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceCollectionMethod(v)
		return nil
	case billingworkflowconfig.FieldInvoiceProgressiveBilling:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceProgressiveBilling(v)
		return nil
	case billingworkflowconfig.FieldInvoiceDefaultTaxSettings:
		v, ok := value.(productcatalog.TaxConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDefaultTaxSettings(v)
		return nil
	case billingworkflowconfig.FieldTaxEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxEnabled(v)
		return nil
	case billingworkflowconfig.FieldTaxEnforced:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxEnforced(v)
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingWorkflowConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingWorkflowConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingWorkflowConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingWorkflowConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingWorkflowConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billingworkflowconfig.FieldDeletedAt) {
		fields = append(fields, billingworkflowconfig.FieldDeletedAt)
	}
	if m.FieldCleared(billingworkflowconfig.FieldInvoiceDefaultTaxSettings) {
		fields = append(fields, billingworkflowconfig.FieldInvoiceDefaultTaxSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingWorkflowConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ClearField(name string) error {
	switch name {
	case billingworkflowconfig.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case billingworkflowconfig.FieldInvoiceDefaultTaxSettings:
		m.ClearInvoiceDefaultTaxSettings()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ResetField(name string) error {
	switch name {
	case billingworkflowconfig.FieldNamespace:
		m.ResetNamespace()
		return nil
	case billingworkflowconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingworkflowconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingworkflowconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case billingworkflowconfig.FieldCollectionAlignment:
		m.ResetCollectionAlignment()
		return nil
	case billingworkflowconfig.FieldLineCollectionPeriod:
		m.ResetLineCollectionPeriod()
		return nil
	case billingworkflowconfig.FieldInvoiceAutoAdvance:
		m.ResetInvoiceAutoAdvance()
		return nil
	case billingworkflowconfig.FieldInvoiceDraftPeriod:
		m.ResetInvoiceDraftPeriod()
		return nil
	case billingworkflowconfig.FieldInvoiceDueAfter:
		m.ResetInvoiceDueAfter()
		return nil
	case billingworkflowconfig.FieldInvoiceCollectionMethod:
		m.ResetInvoiceCollectionMethod()
		return nil
	case billingworkflowconfig.FieldInvoiceProgressiveBilling:
		m.ResetInvoiceProgressiveBilling()
		return nil
	case billingworkflowconfig.FieldInvoiceDefaultTaxSettings:
		m.ResetInvoiceDefaultTaxSettings()
		return nil
	case billingworkflowconfig.FieldTaxEnabled:
		m.ResetTaxEnabled()
		return nil
	case billingworkflowconfig.FieldTaxEnforced:
		m.ResetTaxEnforced()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingWorkflowConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.billing_invoices != nil {
		edges = append(edges, billingworkflowconfig.EdgeBillingInvoices)
	}
	if m.billing_profile != nil {
		edges = append(edges, billingworkflowconfig.EdgeBillingProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingWorkflowConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		if id := m.billing_invoices; id != nil {
			return []ent.Value{*id}
		}
	case billingworkflowconfig.EdgeBillingProfile:
		if id := m.billing_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingWorkflowConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingWorkflowConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingWorkflowConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbilling_invoices {
		edges = append(edges, billingworkflowconfig.EdgeBillingInvoices)
	}
	if m.clearedbilling_profile {
		edges = append(edges, billingworkflowconfig.EdgeBillingProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingWorkflowConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		return m.clearedbilling_invoices
	case billingworkflowconfig.EdgeBillingProfile:
		return m.clearedbilling_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ClearEdge(name string) error {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		m.ClearBillingInvoices()
		return nil
	case billingworkflowconfig.EdgeBillingProfile:
		m.ClearBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingWorkflowConfigMutation) ResetEdge(name string) error {
	switch name {
	case billingworkflowconfig.EdgeBillingInvoices:
		m.ResetBillingInvoices()
		return nil
	case billingworkflowconfig.EdgeBillingProfile:
		m.ResetBillingProfile()
		return nil
	}
	return fmt.Errorf("unknown BillingWorkflowConfig edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	namespace                        *string
	metadata                         *map[string]string
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	name                             *string
	description                      *string
	billing_address_country          *models.CountryCode
	billing_address_postal_code      *string
	billing_address_state            *string
	billing_address_city             *string
	billing_address_line1            *string
	billing_address_line2            *string
	billing_address_phone_number     *string
	key                              *string
	primary_email                    *string
	currency                         *currencyx.Code
	clearedFields                    map[string]struct{}
	apps                             map[int]struct{}
	removedapps                      map[int]struct{}
	clearedapps                      bool
	subjects                         map[int]struct{}
	removedsubjects                  map[int]struct{}
	clearedsubjects                  bool
	billing_customer_override        *string
	clearedbilling_customer_override bool
	billing_invoice                  map[string]struct{}
	removedbilling_invoice           map[string]struct{}
	clearedbilling_invoice           bool
	subscription                     map[string]struct{}
	removedsubscription              map[string]struct{}
	clearedsubscription              bool
	done                             bool
	oldValue                         func(context.Context) (*Customer, error)
	predicates                       []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id string) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Customer entities.
func (m *CustomerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *CustomerMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *CustomerMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *CustomerMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *CustomerMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CustomerMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CustomerMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[customer.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CustomerMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[customer.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CustomerMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, customer.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CustomerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CustomerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[customer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, customer.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CustomerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CustomerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CustomerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[customer.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CustomerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[customer.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CustomerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, customer.FieldDescription)
}

// SetBillingAddressCountry sets the "billing_address_country" field.
func (m *CustomerMutation) SetBillingAddressCountry(mc models.CountryCode) {
	m.billing_address_country = &mc
}

// BillingAddressCountry returns the value of the "billing_address_country" field in the mutation.
func (m *CustomerMutation) BillingAddressCountry() (r models.CountryCode, exists bool) {
	v := m.billing_address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressCountry returns the old "billing_address_country" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressCountry(ctx context.Context) (v *models.CountryCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressCountry: %w", err)
	}
	return oldValue.BillingAddressCountry, nil
}

// ClearBillingAddressCountry clears the value of the "billing_address_country" field.
func (m *CustomerMutation) ClearBillingAddressCountry() {
	m.billing_address_country = nil
	m.clearedFields[customer.FieldBillingAddressCountry] = struct{}{}
}

// BillingAddressCountryCleared returns if the "billing_address_country" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressCountryCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressCountry]
	return ok
}

// ResetBillingAddressCountry resets all changes to the "billing_address_country" field.
func (m *CustomerMutation) ResetBillingAddressCountry() {
	m.billing_address_country = nil
	delete(m.clearedFields, customer.FieldBillingAddressCountry)
}

// SetBillingAddressPostalCode sets the "billing_address_postal_code" field.
func (m *CustomerMutation) SetBillingAddressPostalCode(s string) {
	m.billing_address_postal_code = &s
}

// BillingAddressPostalCode returns the value of the "billing_address_postal_code" field in the mutation.
func (m *CustomerMutation) BillingAddressPostalCode() (r string, exists bool) {
	v := m.billing_address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressPostalCode returns the old "billing_address_postal_code" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressPostalCode: %w", err)
	}
	return oldValue.BillingAddressPostalCode, nil
}

// ClearBillingAddressPostalCode clears the value of the "billing_address_postal_code" field.
func (m *CustomerMutation) ClearBillingAddressPostalCode() {
	m.billing_address_postal_code = nil
	m.clearedFields[customer.FieldBillingAddressPostalCode] = struct{}{}
}

// BillingAddressPostalCodeCleared returns if the "billing_address_postal_code" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressPostalCode]
	return ok
}

// ResetBillingAddressPostalCode resets all changes to the "billing_address_postal_code" field.
func (m *CustomerMutation) ResetBillingAddressPostalCode() {
	m.billing_address_postal_code = nil
	delete(m.clearedFields, customer.FieldBillingAddressPostalCode)
}

// SetBillingAddressState sets the "billing_address_state" field.
func (m *CustomerMutation) SetBillingAddressState(s string) {
	m.billing_address_state = &s
}

// BillingAddressState returns the value of the "billing_address_state" field in the mutation.
func (m *CustomerMutation) BillingAddressState() (r string, exists bool) {
	v := m.billing_address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressState returns the old "billing_address_state" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressState: %w", err)
	}
	return oldValue.BillingAddressState, nil
}

// ClearBillingAddressState clears the value of the "billing_address_state" field.
func (m *CustomerMutation) ClearBillingAddressState() {
	m.billing_address_state = nil
	m.clearedFields[customer.FieldBillingAddressState] = struct{}{}
}

// BillingAddressStateCleared returns if the "billing_address_state" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressStateCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressState]
	return ok
}

// ResetBillingAddressState resets all changes to the "billing_address_state" field.
func (m *CustomerMutation) ResetBillingAddressState() {
	m.billing_address_state = nil
	delete(m.clearedFields, customer.FieldBillingAddressState)
}

// SetBillingAddressCity sets the "billing_address_city" field.
func (m *CustomerMutation) SetBillingAddressCity(s string) {
	m.billing_address_city = &s
}

// BillingAddressCity returns the value of the "billing_address_city" field in the mutation.
func (m *CustomerMutation) BillingAddressCity() (r string, exists bool) {
	v := m.billing_address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressCity returns the old "billing_address_city" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressCity: %w", err)
	}
	return oldValue.BillingAddressCity, nil
}

// ClearBillingAddressCity clears the value of the "billing_address_city" field.
func (m *CustomerMutation) ClearBillingAddressCity() {
	m.billing_address_city = nil
	m.clearedFields[customer.FieldBillingAddressCity] = struct{}{}
}

// BillingAddressCityCleared returns if the "billing_address_city" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressCityCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressCity]
	return ok
}

// ResetBillingAddressCity resets all changes to the "billing_address_city" field.
func (m *CustomerMutation) ResetBillingAddressCity() {
	m.billing_address_city = nil
	delete(m.clearedFields, customer.FieldBillingAddressCity)
}

// SetBillingAddressLine1 sets the "billing_address_line1" field.
func (m *CustomerMutation) SetBillingAddressLine1(s string) {
	m.billing_address_line1 = &s
}

// BillingAddressLine1 returns the value of the "billing_address_line1" field in the mutation.
func (m *CustomerMutation) BillingAddressLine1() (r string, exists bool) {
	v := m.billing_address_line1
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressLine1 returns the old "billing_address_line1" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressLine1: %w", err)
	}
	return oldValue.BillingAddressLine1, nil
}

// ClearBillingAddressLine1 clears the value of the "billing_address_line1" field.
func (m *CustomerMutation) ClearBillingAddressLine1() {
	m.billing_address_line1 = nil
	m.clearedFields[customer.FieldBillingAddressLine1] = struct{}{}
}

// BillingAddressLine1Cleared returns if the "billing_address_line1" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressLine1Cleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressLine1]
	return ok
}

// ResetBillingAddressLine1 resets all changes to the "billing_address_line1" field.
func (m *CustomerMutation) ResetBillingAddressLine1() {
	m.billing_address_line1 = nil
	delete(m.clearedFields, customer.FieldBillingAddressLine1)
}

// SetBillingAddressLine2 sets the "billing_address_line2" field.
func (m *CustomerMutation) SetBillingAddressLine2(s string) {
	m.billing_address_line2 = &s
}

// BillingAddressLine2 returns the value of the "billing_address_line2" field in the mutation.
func (m *CustomerMutation) BillingAddressLine2() (r string, exists bool) {
	v := m.billing_address_line2
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressLine2 returns the old "billing_address_line2" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressLine2: %w", err)
	}
	return oldValue.BillingAddressLine2, nil
}

// ClearBillingAddressLine2 clears the value of the "billing_address_line2" field.
func (m *CustomerMutation) ClearBillingAddressLine2() {
	m.billing_address_line2 = nil
	m.clearedFields[customer.FieldBillingAddressLine2] = struct{}{}
}

// BillingAddressLine2Cleared returns if the "billing_address_line2" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressLine2Cleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressLine2]
	return ok
}

// ResetBillingAddressLine2 resets all changes to the "billing_address_line2" field.
func (m *CustomerMutation) ResetBillingAddressLine2() {
	m.billing_address_line2 = nil
	delete(m.clearedFields, customer.FieldBillingAddressLine2)
}

// SetBillingAddressPhoneNumber sets the "billing_address_phone_number" field.
func (m *CustomerMutation) SetBillingAddressPhoneNumber(s string) {
	m.billing_address_phone_number = &s
}

// BillingAddressPhoneNumber returns the value of the "billing_address_phone_number" field in the mutation.
func (m *CustomerMutation) BillingAddressPhoneNumber() (r string, exists bool) {
	v := m.billing_address_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddressPhoneNumber returns the old "billing_address_phone_number" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBillingAddressPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddressPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddressPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddressPhoneNumber: %w", err)
	}
	return oldValue.BillingAddressPhoneNumber, nil
}

// ClearBillingAddressPhoneNumber clears the value of the "billing_address_phone_number" field.
func (m *CustomerMutation) ClearBillingAddressPhoneNumber() {
	m.billing_address_phone_number = nil
	m.clearedFields[customer.FieldBillingAddressPhoneNumber] = struct{}{}
}

// BillingAddressPhoneNumberCleared returns if the "billing_address_phone_number" field was cleared in this mutation.
func (m *CustomerMutation) BillingAddressPhoneNumberCleared() bool {
	_, ok := m.clearedFields[customer.FieldBillingAddressPhoneNumber]
	return ok
}

// ResetBillingAddressPhoneNumber resets all changes to the "billing_address_phone_number" field.
func (m *CustomerMutation) ResetBillingAddressPhoneNumber() {
	m.billing_address_phone_number = nil
	delete(m.clearedFields, customer.FieldBillingAddressPhoneNumber)
}

// SetKey sets the "key" field.
func (m *CustomerMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *CustomerMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ClearKey clears the value of the "key" field.
func (m *CustomerMutation) ClearKey() {
	m.key = nil
	m.clearedFields[customer.FieldKey] = struct{}{}
}

// KeyCleared returns if the "key" field was cleared in this mutation.
func (m *CustomerMutation) KeyCleared() bool {
	_, ok := m.clearedFields[customer.FieldKey]
	return ok
}

// ResetKey resets all changes to the "key" field.
func (m *CustomerMutation) ResetKey() {
	m.key = nil
	delete(m.clearedFields, customer.FieldKey)
}

// SetPrimaryEmail sets the "primary_email" field.
func (m *CustomerMutation) SetPrimaryEmail(s string) {
	m.primary_email = &s
}

// PrimaryEmail returns the value of the "primary_email" field in the mutation.
func (m *CustomerMutation) PrimaryEmail() (r string, exists bool) {
	v := m.primary_email
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryEmail returns the old "primary_email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPrimaryEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryEmail: %w", err)
	}
	return oldValue.PrimaryEmail, nil
}

// ClearPrimaryEmail clears the value of the "primary_email" field.
func (m *CustomerMutation) ClearPrimaryEmail() {
	m.primary_email = nil
	m.clearedFields[customer.FieldPrimaryEmail] = struct{}{}
}

// PrimaryEmailCleared returns if the "primary_email" field was cleared in this mutation.
func (m *CustomerMutation) PrimaryEmailCleared() bool {
	_, ok := m.clearedFields[customer.FieldPrimaryEmail]
	return ok
}

// ResetPrimaryEmail resets all changes to the "primary_email" field.
func (m *CustomerMutation) ResetPrimaryEmail() {
	m.primary_email = nil
	delete(m.clearedFields, customer.FieldPrimaryEmail)
}

// SetCurrency sets the "currency" field.
func (m *CustomerMutation) SetCurrency(c currencyx.Code) {
	m.currency = &c
}

// Currency returns the value of the "currency" field in the mutation.
func (m *CustomerMutation) Currency() (r currencyx.Code, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCurrency(ctx context.Context) (v *currencyx.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *CustomerMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[customer.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *CustomerMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[customer.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *CustomerMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, customer.FieldCurrency)
}

// AddAppIDs adds the "apps" edge to the AppCustomer entity by ids.
func (m *CustomerMutation) AddAppIDs(ids ...int) {
	if m.apps == nil {
		m.apps = make(map[int]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the AppCustomer entity.
func (m *CustomerMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the AppCustomer entity was cleared.
func (m *CustomerMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the AppCustomer entity by IDs.
func (m *CustomerMutation) RemoveAppIDs(ids ...int) {
	if m.removedapps == nil {
		m.removedapps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the AppCustomer entity.
func (m *CustomerMutation) RemovedAppsIDs() (ids []int) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *CustomerMutation) AppsIDs() (ids []int) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *CustomerMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// AddSubjectIDs adds the "subjects" edge to the CustomerSubjects entity by ids.
func (m *CustomerMutation) AddSubjectIDs(ids ...int) {
	if m.subjects == nil {
		m.subjects = make(map[int]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the CustomerSubjects entity.
func (m *CustomerMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the CustomerSubjects entity was cleared.
func (m *CustomerMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the CustomerSubjects entity by IDs.
func (m *CustomerMutation) RemoveSubjectIDs(ids ...int) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the CustomerSubjects entity.
func (m *CustomerMutation) RemovedSubjectsIDs() (ids []int) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *CustomerMutation) SubjectsIDs() (ids []int) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *CustomerMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// SetBillingCustomerOverrideID sets the "billing_customer_override" edge to the BillingCustomerOverride entity by id.
func (m *CustomerMutation) SetBillingCustomerOverrideID(id string) {
	m.billing_customer_override = &id
}

// ClearBillingCustomerOverride clears the "billing_customer_override" edge to the BillingCustomerOverride entity.
func (m *CustomerMutation) ClearBillingCustomerOverride() {
	m.clearedbilling_customer_override = true
}

// BillingCustomerOverrideCleared reports if the "billing_customer_override" edge to the BillingCustomerOverride entity was cleared.
func (m *CustomerMutation) BillingCustomerOverrideCleared() bool {
	return m.clearedbilling_customer_override
}

// BillingCustomerOverrideID returns the "billing_customer_override" edge ID in the mutation.
func (m *CustomerMutation) BillingCustomerOverrideID() (id string, exists bool) {
	if m.billing_customer_override != nil {
		return *m.billing_customer_override, true
	}
	return
}

// BillingCustomerOverrideIDs returns the "billing_customer_override" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingCustomerOverrideID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) BillingCustomerOverrideIDs() (ids []string) {
	if id := m.billing_customer_override; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingCustomerOverride resets all changes to the "billing_customer_override" edge.
func (m *CustomerMutation) ResetBillingCustomerOverride() {
	m.billing_customer_override = nil
	m.clearedbilling_customer_override = false
}

// AddBillingInvoiceIDs adds the "billing_invoice" edge to the BillingInvoice entity by ids.
func (m *CustomerMutation) AddBillingInvoiceIDs(ids ...string) {
	if m.billing_invoice == nil {
		m.billing_invoice = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_invoice[ids[i]] = struct{}{}
	}
}

// ClearBillingInvoice clears the "billing_invoice" edge to the BillingInvoice entity.
func (m *CustomerMutation) ClearBillingInvoice() {
	m.clearedbilling_invoice = true
}

// BillingInvoiceCleared reports if the "billing_invoice" edge to the BillingInvoice entity was cleared.
func (m *CustomerMutation) BillingInvoiceCleared() bool {
	return m.clearedbilling_invoice
}

// RemoveBillingInvoiceIDs removes the "billing_invoice" edge to the BillingInvoice entity by IDs.
func (m *CustomerMutation) RemoveBillingInvoiceIDs(ids ...string) {
	if m.removedbilling_invoice == nil {
		m.removedbilling_invoice = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_invoice, ids[i])
		m.removedbilling_invoice[ids[i]] = struct{}{}
	}
}

// RemovedBillingInvoice returns the removed IDs of the "billing_invoice" edge to the BillingInvoice entity.
func (m *CustomerMutation) RemovedBillingInvoiceIDs() (ids []string) {
	for id := range m.removedbilling_invoice {
		ids = append(ids, id)
	}
	return
}

// BillingInvoiceIDs returns the "billing_invoice" edge IDs in the mutation.
func (m *CustomerMutation) BillingInvoiceIDs() (ids []string) {
	for id := range m.billing_invoice {
		ids = append(ids, id)
	}
	return
}

// ResetBillingInvoice resets all changes to the "billing_invoice" edge.
func (m *CustomerMutation) ResetBillingInvoice() {
	m.billing_invoice = nil
	m.clearedbilling_invoice = false
	m.removedbilling_invoice = nil
}

// AddSubscriptionIDs adds the "subscription" edge to the Subscription entity by ids.
func (m *CustomerMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscription == nil {
		m.subscription = make(map[string]struct{})
	}
	for i := range ids {
		m.subscription[ids[i]] = struct{}{}
	}
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *CustomerMutation) ClearSubscription() {
	m.clearedsubscription = true
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *CustomerMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// RemoveSubscriptionIDs removes the "subscription" edge to the Subscription entity by IDs.
func (m *CustomerMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscription == nil {
		m.removedsubscription = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscription, ids[i])
		m.removedsubscription[ids[i]] = struct{}{}
	}
}

// RemovedSubscription returns the removed IDs of the "subscription" edge to the Subscription entity.
func (m *CustomerMutation) RemovedSubscriptionIDs() (ids []string) {
	for id := range m.removedsubscription {
		ids = append(ids, id)
	}
	return
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
func (m *CustomerMutation) SubscriptionIDs() (ids []string) {
	for id := range m.subscription {
		ids = append(ids, id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *CustomerMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
	m.removedsubscription = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.namespace != nil {
		fields = append(fields, customer.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, customer.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.description != nil {
		fields = append(fields, customer.FieldDescription)
	}
	if m.billing_address_country != nil {
		fields = append(fields, customer.FieldBillingAddressCountry)
	}
	if m.billing_address_postal_code != nil {
		fields = append(fields, customer.FieldBillingAddressPostalCode)
	}
	if m.billing_address_state != nil {
		fields = append(fields, customer.FieldBillingAddressState)
	}
	if m.billing_address_city != nil {
		fields = append(fields, customer.FieldBillingAddressCity)
	}
	if m.billing_address_line1 != nil {
		fields = append(fields, customer.FieldBillingAddressLine1)
	}
	if m.billing_address_line2 != nil {
		fields = append(fields, customer.FieldBillingAddressLine2)
	}
	if m.billing_address_phone_number != nil {
		fields = append(fields, customer.FieldBillingAddressPhoneNumber)
	}
	if m.key != nil {
		fields = append(fields, customer.FieldKey)
	}
	if m.primary_email != nil {
		fields = append(fields, customer.FieldPrimaryEmail)
	}
	if m.currency != nil {
		fields = append(fields, customer.FieldCurrency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldNamespace:
		return m.Namespace()
	case customer.FieldMetadata:
		return m.Metadata()
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldDeletedAt:
		return m.DeletedAt()
	case customer.FieldName:
		return m.Name()
	case customer.FieldDescription:
		return m.Description()
	case customer.FieldBillingAddressCountry:
		return m.BillingAddressCountry()
	case customer.FieldBillingAddressPostalCode:
		return m.BillingAddressPostalCode()
	case customer.FieldBillingAddressState:
		return m.BillingAddressState()
	case customer.FieldBillingAddressCity:
		return m.BillingAddressCity()
	case customer.FieldBillingAddressLine1:
		return m.BillingAddressLine1()
	case customer.FieldBillingAddressLine2:
		return m.BillingAddressLine2()
	case customer.FieldBillingAddressPhoneNumber:
		return m.BillingAddressPhoneNumber()
	case customer.FieldKey:
		return m.Key()
	case customer.FieldPrimaryEmail:
		return m.PrimaryEmail()
	case customer.FieldCurrency:
		return m.Currency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldNamespace:
		return m.OldNamespace(ctx)
	case customer.FieldMetadata:
		return m.OldMetadata(ctx)
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldDescription:
		return m.OldDescription(ctx)
	case customer.FieldBillingAddressCountry:
		return m.OldBillingAddressCountry(ctx)
	case customer.FieldBillingAddressPostalCode:
		return m.OldBillingAddressPostalCode(ctx)
	case customer.FieldBillingAddressState:
		return m.OldBillingAddressState(ctx)
	case customer.FieldBillingAddressCity:
		return m.OldBillingAddressCity(ctx)
	case customer.FieldBillingAddressLine1:
		return m.OldBillingAddressLine1(ctx)
	case customer.FieldBillingAddressLine2:
		return m.OldBillingAddressLine2(ctx)
	case customer.FieldBillingAddressPhoneNumber:
		return m.OldBillingAddressPhoneNumber(ctx)
	case customer.FieldKey:
		return m.OldKey(ctx)
	case customer.FieldPrimaryEmail:
		return m.OldPrimaryEmail(ctx)
	case customer.FieldCurrency:
		return m.OldCurrency(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case customer.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case customer.FieldBillingAddressCountry:
		v, ok := value.(models.CountryCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressCountry(v)
		return nil
	case customer.FieldBillingAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressPostalCode(v)
		return nil
	case customer.FieldBillingAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressState(v)
		return nil
	case customer.FieldBillingAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressCity(v)
		return nil
	case customer.FieldBillingAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressLine1(v)
		return nil
	case customer.FieldBillingAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressLine2(v)
		return nil
	case customer.FieldBillingAddressPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddressPhoneNumber(v)
		return nil
	case customer.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case customer.FieldPrimaryEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryEmail(v)
		return nil
	case customer.FieldCurrency:
		v, ok := value.(currencyx.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldMetadata) {
		fields = append(fields, customer.FieldMetadata)
	}
	if m.FieldCleared(customer.FieldDeletedAt) {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.FieldCleared(customer.FieldDescription) {
		fields = append(fields, customer.FieldDescription)
	}
	if m.FieldCleared(customer.FieldBillingAddressCountry) {
		fields = append(fields, customer.FieldBillingAddressCountry)
	}
	if m.FieldCleared(customer.FieldBillingAddressPostalCode) {
		fields = append(fields, customer.FieldBillingAddressPostalCode)
	}
	if m.FieldCleared(customer.FieldBillingAddressState) {
		fields = append(fields, customer.FieldBillingAddressState)
	}
	if m.FieldCleared(customer.FieldBillingAddressCity) {
		fields = append(fields, customer.FieldBillingAddressCity)
	}
	if m.FieldCleared(customer.FieldBillingAddressLine1) {
		fields = append(fields, customer.FieldBillingAddressLine1)
	}
	if m.FieldCleared(customer.FieldBillingAddressLine2) {
		fields = append(fields, customer.FieldBillingAddressLine2)
	}
	if m.FieldCleared(customer.FieldBillingAddressPhoneNumber) {
		fields = append(fields, customer.FieldBillingAddressPhoneNumber)
	}
	if m.FieldCleared(customer.FieldKey) {
		fields = append(fields, customer.FieldKey)
	}
	if m.FieldCleared(customer.FieldPrimaryEmail) {
		fields = append(fields, customer.FieldPrimaryEmail)
	}
	if m.FieldCleared(customer.FieldCurrency) {
		fields = append(fields, customer.FieldCurrency)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldMetadata:
		m.ClearMetadata()
		return nil
	case customer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case customer.FieldDescription:
		m.ClearDescription()
		return nil
	case customer.FieldBillingAddressCountry:
		m.ClearBillingAddressCountry()
		return nil
	case customer.FieldBillingAddressPostalCode:
		m.ClearBillingAddressPostalCode()
		return nil
	case customer.FieldBillingAddressState:
		m.ClearBillingAddressState()
		return nil
	case customer.FieldBillingAddressCity:
		m.ClearBillingAddressCity()
		return nil
	case customer.FieldBillingAddressLine1:
		m.ClearBillingAddressLine1()
		return nil
	case customer.FieldBillingAddressLine2:
		m.ClearBillingAddressLine2()
		return nil
	case customer.FieldBillingAddressPhoneNumber:
		m.ClearBillingAddressPhoneNumber()
		return nil
	case customer.FieldKey:
		m.ClearKey()
		return nil
	case customer.FieldPrimaryEmail:
		m.ClearPrimaryEmail()
		return nil
	case customer.FieldCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldNamespace:
		m.ResetNamespace()
		return nil
	case customer.FieldMetadata:
		m.ResetMetadata()
		return nil
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldDescription:
		m.ResetDescription()
		return nil
	case customer.FieldBillingAddressCountry:
		m.ResetBillingAddressCountry()
		return nil
	case customer.FieldBillingAddressPostalCode:
		m.ResetBillingAddressPostalCode()
		return nil
	case customer.FieldBillingAddressState:
		m.ResetBillingAddressState()
		return nil
	case customer.FieldBillingAddressCity:
		m.ResetBillingAddressCity()
		return nil
	case customer.FieldBillingAddressLine1:
		m.ResetBillingAddressLine1()
		return nil
	case customer.FieldBillingAddressLine2:
		m.ResetBillingAddressLine2()
		return nil
	case customer.FieldBillingAddressPhoneNumber:
		m.ResetBillingAddressPhoneNumber()
		return nil
	case customer.FieldKey:
		m.ResetKey()
		return nil
	case customer.FieldPrimaryEmail:
		m.ResetPrimaryEmail()
		return nil
	case customer.FieldCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.apps != nil {
		edges = append(edges, customer.EdgeApps)
	}
	if m.subjects != nil {
		edges = append(edges, customer.EdgeSubjects)
	}
	if m.billing_customer_override != nil {
		edges = append(edges, customer.EdgeBillingCustomerOverride)
	}
	if m.billing_invoice != nil {
		edges = append(edges, customer.EdgeBillingInvoice)
	}
	if m.subscription != nil {
		edges = append(edges, customer.EdgeSubscription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeBillingCustomerOverride:
		if id := m.billing_customer_override; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeBillingInvoice:
		ids := make([]ent.Value, 0, len(m.billing_invoice))
		for id := range m.billing_invoice {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSubscription:
		ids := make([]ent.Value, 0, len(m.subscription))
		for id := range m.subscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedapps != nil {
		edges = append(edges, customer.EdgeApps)
	}
	if m.removedsubjects != nil {
		edges = append(edges, customer.EdgeSubjects)
	}
	if m.removedbilling_invoice != nil {
		edges = append(edges, customer.EdgeBillingInvoice)
	}
	if m.removedsubscription != nil {
		edges = append(edges, customer.EdgeSubscription)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeBillingInvoice:
		ids := make([]ent.Value, 0, len(m.removedbilling_invoice))
		for id := range m.removedbilling_invoice {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSubscription:
		ids := make([]ent.Value, 0, len(m.removedsubscription))
		for id := range m.removedsubscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedapps {
		edges = append(edges, customer.EdgeApps)
	}
	if m.clearedsubjects {
		edges = append(edges, customer.EdgeSubjects)
	}
	if m.clearedbilling_customer_override {
		edges = append(edges, customer.EdgeBillingCustomerOverride)
	}
	if m.clearedbilling_invoice {
		edges = append(edges, customer.EdgeBillingInvoice)
	}
	if m.clearedsubscription {
		edges = append(edges, customer.EdgeSubscription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeApps:
		return m.clearedapps
	case customer.EdgeSubjects:
		return m.clearedsubjects
	case customer.EdgeBillingCustomerOverride:
		return m.clearedbilling_customer_override
	case customer.EdgeBillingInvoice:
		return m.clearedbilling_invoice
	case customer.EdgeSubscription:
		return m.clearedsubscription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeBillingCustomerOverride:
		m.ClearBillingCustomerOverride()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeApps:
		m.ResetApps()
		return nil
	case customer.EdgeSubjects:
		m.ResetSubjects()
		return nil
	case customer.EdgeBillingCustomerOverride:
		m.ResetBillingCustomerOverride()
		return nil
	case customer.EdgeBillingInvoice:
		m.ResetBillingInvoice()
		return nil
	case customer.EdgeSubscription:
		m.ResetSubscription()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// CustomerSubjectsMutation represents an operation that mutates the CustomerSubjects nodes in the graph.
type CustomerSubjectsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	namespace       *string
	subject_key     *string
	created_at      *time.Time
	deleted_at      *time.Time
	clearedFields   map[string]struct{}
	customer        *string
	clearedcustomer bool
	done            bool
	oldValue        func(context.Context) (*CustomerSubjects, error)
	predicates      []predicate.CustomerSubjects
}

var _ ent.Mutation = (*CustomerSubjectsMutation)(nil)

// customersubjectsOption allows management of the mutation configuration using functional options.
type customersubjectsOption func(*CustomerSubjectsMutation)

// newCustomerSubjectsMutation creates new mutation for the CustomerSubjects entity.
func newCustomerSubjectsMutation(c config, op Op, opts ...customersubjectsOption) *CustomerSubjectsMutation {
	m := &CustomerSubjectsMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerSubjects,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerSubjectsID sets the ID field of the mutation.
func withCustomerSubjectsID(id int) customersubjectsOption {
	return func(m *CustomerSubjectsMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerSubjects
		)
		m.oldValue = func(ctx context.Context) (*CustomerSubjects, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerSubjects.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerSubjects sets the old CustomerSubjects of the mutation.
func withCustomerSubjects(node *CustomerSubjects) customersubjectsOption {
	return func(m *CustomerSubjectsMutation) {
		m.oldValue = func(context.Context) (*CustomerSubjects, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerSubjectsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerSubjectsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerSubjectsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerSubjectsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerSubjects.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *CustomerSubjectsMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *CustomerSubjectsMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *CustomerSubjectsMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerSubjectsMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerSubjectsMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerSubjectsMutation) ResetCustomerID() {
	m.customer = nil
}

// SetSubjectKey sets the "subject_key" field.
func (m *CustomerSubjectsMutation) SetSubjectKey(s string) {
	m.subject_key = &s
}

// SubjectKey returns the value of the "subject_key" field in the mutation.
func (m *CustomerSubjectsMutation) SubjectKey() (r string, exists bool) {
	v := m.subject_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectKey returns the old "subject_key" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldSubjectKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectKey: %w", err)
	}
	return oldValue.SubjectKey, nil
}

// ResetSubjectKey resets all changes to the "subject_key" field.
func (m *CustomerSubjectsMutation) ResetSubjectKey() {
	m.subject_key = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerSubjectsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerSubjectsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerSubjectsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CustomerSubjectsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CustomerSubjectsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CustomerSubjects entity.
// If the CustomerSubjects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerSubjectsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CustomerSubjectsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[customersubjects.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CustomerSubjectsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customersubjects.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CustomerSubjectsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, customersubjects.FieldDeletedAt)
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerSubjectsMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customersubjects.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerSubjectsMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerSubjectsMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerSubjectsMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the CustomerSubjectsMutation builder.
func (m *CustomerSubjectsMutation) Where(ps ...predicate.CustomerSubjects) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerSubjectsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerSubjectsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerSubjects, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerSubjectsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerSubjectsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerSubjects).
func (m *CustomerSubjectsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerSubjectsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.namespace != nil {
		fields = append(fields, customersubjects.FieldNamespace)
	}
	if m.customer != nil {
		fields = append(fields, customersubjects.FieldCustomerID)
	}
	if m.subject_key != nil {
		fields = append(fields, customersubjects.FieldSubjectKey)
	}
	if m.created_at != nil {
		fields = append(fields, customersubjects.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, customersubjects.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerSubjectsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customersubjects.FieldNamespace:
		return m.Namespace()
	case customersubjects.FieldCustomerID:
		return m.CustomerID()
	case customersubjects.FieldSubjectKey:
		return m.SubjectKey()
	case customersubjects.FieldCreatedAt:
		return m.CreatedAt()
	case customersubjects.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerSubjectsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customersubjects.FieldNamespace:
		return m.OldNamespace(ctx)
	case customersubjects.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customersubjects.FieldSubjectKey:
		return m.OldSubjectKey(ctx)
	case customersubjects.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customersubjects.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerSubjects field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerSubjectsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customersubjects.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case customersubjects.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customersubjects.FieldSubjectKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectKey(v)
		return nil
	case customersubjects.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customersubjects.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerSubjectsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerSubjectsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerSubjectsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomerSubjects numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerSubjectsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customersubjects.FieldDeletedAt) {
		fields = append(fields, customersubjects.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerSubjectsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerSubjectsMutation) ClearField(name string) error {
	switch name {
	case customersubjects.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerSubjectsMutation) ResetField(name string) error {
	switch name {
	case customersubjects.FieldNamespace:
		m.ResetNamespace()
		return nil
	case customersubjects.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customersubjects.FieldSubjectKey:
		m.ResetSubjectKey()
		return nil
	case customersubjects.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customersubjects.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerSubjectsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.customer != nil {
		edges = append(edges, customersubjects.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerSubjectsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customersubjects.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerSubjectsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerSubjectsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerSubjectsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcustomer {
		edges = append(edges, customersubjects.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerSubjectsMutation) EdgeCleared(name string) bool {
	switch name {
	case customersubjects.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerSubjectsMutation) ClearEdge(name string) error {
	switch name {
	case customersubjects.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerSubjectsMutation) ResetEdge(name string) error {
	switch name {
	case customersubjects.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerSubjects edge %s", name)
}

// EntitlementMutation represents an operation that mutates the Entitlement nodes in the graph.
type EntitlementMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	namespace                     *string
	metadata                      *map[string]string
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	entitlement_type              *entitlement.EntitlementType
	active_from                   *time.Time
	active_to                     *time.Time
	feature_key                   *string
	subject_key                   *string
	measure_usage_from            *time.Time
	issue_after_reset             *float64
	addissue_after_reset          *float64
	issue_after_reset_priority    *uint8
	addissue_after_reset_priority *int8
	is_soft_limit                 *bool
	preserve_overage_at_reset     *bool
	_config                       *[]uint8
	append_config                 []uint8
	usage_period_interval         *isodate.String
	usage_period_anchor           *time.Time
	current_usage_period_start    *time.Time
	current_usage_period_end      *time.Time
	annotations                   *map[string]interface{}
	clearedFields                 map[string]struct{}
	usage_reset                   map[string]struct{}
	removedusage_reset            map[string]struct{}
	clearedusage_reset            bool
	grant                         map[string]struct{}
	removedgrant                  map[string]struct{}
	clearedgrant                  bool
	balance_snapshot              map[int]struct{}
	removedbalance_snapshot       map[int]struct{}
	clearedbalance_snapshot       bool
	subscription_item             map[string]struct{}
	removedsubscription_item      map[string]struct{}
	clearedsubscription_item      bool
	feature                       *string
	clearedfeature                bool
	done                          bool
	oldValue                      func(context.Context) (*Entitlement, error)
	predicates                    []predicate.Entitlement
}

var _ ent.Mutation = (*EntitlementMutation)(nil)

// entitlementOption allows management of the mutation configuration using functional options.
type entitlementOption func(*EntitlementMutation)

// newEntitlementMutation creates new mutation for the Entitlement entity.
func newEntitlementMutation(c config, op Op, opts ...entitlementOption) *EntitlementMutation {
	m := &EntitlementMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementID sets the ID field of the mutation.
func withEntitlementID(id string) entitlementOption {
	return func(m *EntitlementMutation) {
		var (
			err   error
			once  sync.Once
			value *Entitlement
		)
		m.oldValue = func(ctx context.Context) (*Entitlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entitlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlement sets the old Entitlement of the mutation.
func withEntitlement(node *Entitlement) entitlementOption {
	return func(m *EntitlementMutation) {
		m.oldValue = func(context.Context) (*Entitlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entitlement entities.
func (m *EntitlementMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entitlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *EntitlementMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *EntitlementMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *EntitlementMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *EntitlementMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EntitlementMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EntitlementMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[entitlement.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EntitlementMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EntitlementMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, entitlement.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitlementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitlementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitlementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitlement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitlementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitlementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitlement.FieldDeletedAt)
}

// SetEntitlementType sets the "entitlement_type" field.
func (m *EntitlementMutation) SetEntitlementType(et entitlement.EntitlementType) {
	m.entitlement_type = &et
}

// EntitlementType returns the value of the "entitlement_type" field in the mutation.
func (m *EntitlementMutation) EntitlementType() (r entitlement.EntitlementType, exists bool) {
	v := m.entitlement_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementType returns the old "entitlement_type" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldEntitlementType(ctx context.Context) (v entitlement.EntitlementType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementType: %w", err)
	}
	return oldValue.EntitlementType, nil
}

// ResetEntitlementType resets all changes to the "entitlement_type" field.
func (m *EntitlementMutation) ResetEntitlementType() {
	m.entitlement_type = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *EntitlementMutation) SetFeatureID(s string) {
	m.feature = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *EntitlementMutation) FeatureID() (r string, exists bool) {
	v := m.feature
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldFeatureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *EntitlementMutation) ResetFeatureID() {
	m.feature = nil
}

// SetActiveFrom sets the "active_from" field.
func (m *EntitlementMutation) SetActiveFrom(t time.Time) {
	m.active_from = &t
}

// ActiveFrom returns the value of the "active_from" field in the mutation.
func (m *EntitlementMutation) ActiveFrom() (r time.Time, exists bool) {
	v := m.active_from
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveFrom returns the old "active_from" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldActiveFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveFrom: %w", err)
	}
	return oldValue.ActiveFrom, nil
}

// ClearActiveFrom clears the value of the "active_from" field.
func (m *EntitlementMutation) ClearActiveFrom() {
	m.active_from = nil
	m.clearedFields[entitlement.FieldActiveFrom] = struct{}{}
}

// ActiveFromCleared returns if the "active_from" field was cleared in this mutation.
func (m *EntitlementMutation) ActiveFromCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldActiveFrom]
	return ok
}

// ResetActiveFrom resets all changes to the "active_from" field.
func (m *EntitlementMutation) ResetActiveFrom() {
	m.active_from = nil
	delete(m.clearedFields, entitlement.FieldActiveFrom)
}

// SetActiveTo sets the "active_to" field.
func (m *EntitlementMutation) SetActiveTo(t time.Time) {
	m.active_to = &t
}

// ActiveTo returns the value of the "active_to" field in the mutation.
func (m *EntitlementMutation) ActiveTo() (r time.Time, exists bool) {
	v := m.active_to
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveTo returns the old "active_to" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldActiveTo(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveTo: %w", err)
	}
	return oldValue.ActiveTo, nil
}

// ClearActiveTo clears the value of the "active_to" field.
func (m *EntitlementMutation) ClearActiveTo() {
	m.active_to = nil
	m.clearedFields[entitlement.FieldActiveTo] = struct{}{}
}

// ActiveToCleared returns if the "active_to" field was cleared in this mutation.
func (m *EntitlementMutation) ActiveToCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldActiveTo]
	return ok
}

// ResetActiveTo resets all changes to the "active_to" field.
func (m *EntitlementMutation) ResetActiveTo() {
	m.active_to = nil
	delete(m.clearedFields, entitlement.FieldActiveTo)
}

// SetFeatureKey sets the "feature_key" field.
func (m *EntitlementMutation) SetFeatureKey(s string) {
	m.feature_key = &s
}

// FeatureKey returns the value of the "feature_key" field in the mutation.
func (m *EntitlementMutation) FeatureKey() (r string, exists bool) {
	v := m.feature_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureKey returns the old "feature_key" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldFeatureKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureKey: %w", err)
	}
	return oldValue.FeatureKey, nil
}

// ResetFeatureKey resets all changes to the "feature_key" field.
func (m *EntitlementMutation) ResetFeatureKey() {
	m.feature_key = nil
}

// SetSubjectKey sets the "subject_key" field.
func (m *EntitlementMutation) SetSubjectKey(s string) {
	m.subject_key = &s
}

// SubjectKey returns the value of the "subject_key" field in the mutation.
func (m *EntitlementMutation) SubjectKey() (r string, exists bool) {
	v := m.subject_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectKey returns the old "subject_key" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldSubjectKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectKey: %w", err)
	}
	return oldValue.SubjectKey, nil
}

// ResetSubjectKey resets all changes to the "subject_key" field.
func (m *EntitlementMutation) ResetSubjectKey() {
	m.subject_key = nil
}

// SetMeasureUsageFrom sets the "measure_usage_from" field.
func (m *EntitlementMutation) SetMeasureUsageFrom(t time.Time) {
	m.measure_usage_from = &t
}

// MeasureUsageFrom returns the value of the "measure_usage_from" field in the mutation.
func (m *EntitlementMutation) MeasureUsageFrom() (r time.Time, exists bool) {
	v := m.measure_usage_from
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasureUsageFrom returns the old "measure_usage_from" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldMeasureUsageFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasureUsageFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasureUsageFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasureUsageFrom: %w", err)
	}
	return oldValue.MeasureUsageFrom, nil
}

// ClearMeasureUsageFrom clears the value of the "measure_usage_from" field.
func (m *EntitlementMutation) ClearMeasureUsageFrom() {
	m.measure_usage_from = nil
	m.clearedFields[entitlement.FieldMeasureUsageFrom] = struct{}{}
}

// MeasureUsageFromCleared returns if the "measure_usage_from" field was cleared in this mutation.
func (m *EntitlementMutation) MeasureUsageFromCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldMeasureUsageFrom]
	return ok
}

// ResetMeasureUsageFrom resets all changes to the "measure_usage_from" field.
func (m *EntitlementMutation) ResetMeasureUsageFrom() {
	m.measure_usage_from = nil
	delete(m.clearedFields, entitlement.FieldMeasureUsageFrom)
}

// SetIssueAfterReset sets the "issue_after_reset" field.
func (m *EntitlementMutation) SetIssueAfterReset(f float64) {
	m.issue_after_reset = &f
	m.addissue_after_reset = nil
}

// IssueAfterReset returns the value of the "issue_after_reset" field in the mutation.
func (m *EntitlementMutation) IssueAfterReset() (r float64, exists bool) {
	v := m.issue_after_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueAfterReset returns the old "issue_after_reset" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIssueAfterReset(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueAfterReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueAfterReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueAfterReset: %w", err)
	}
	return oldValue.IssueAfterReset, nil
}

// AddIssueAfterReset adds f to the "issue_after_reset" field.
func (m *EntitlementMutation) AddIssueAfterReset(f float64) {
	if m.addissue_after_reset != nil {
		*m.addissue_after_reset += f
	} else {
		m.addissue_after_reset = &f
	}
}

// AddedIssueAfterReset returns the value that was added to the "issue_after_reset" field in this mutation.
func (m *EntitlementMutation) AddedIssueAfterReset() (r float64, exists bool) {
	v := m.addissue_after_reset
	if v == nil {
		return
	}
	return *v, true
}

// ClearIssueAfterReset clears the value of the "issue_after_reset" field.
func (m *EntitlementMutation) ClearIssueAfterReset() {
	m.issue_after_reset = nil
	m.addissue_after_reset = nil
	m.clearedFields[entitlement.FieldIssueAfterReset] = struct{}{}
}

// IssueAfterResetCleared returns if the "issue_after_reset" field was cleared in this mutation.
func (m *EntitlementMutation) IssueAfterResetCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIssueAfterReset]
	return ok
}

// ResetIssueAfterReset resets all changes to the "issue_after_reset" field.
func (m *EntitlementMutation) ResetIssueAfterReset() {
	m.issue_after_reset = nil
	m.addissue_after_reset = nil
	delete(m.clearedFields, entitlement.FieldIssueAfterReset)
}

// SetIssueAfterResetPriority sets the "issue_after_reset_priority" field.
func (m *EntitlementMutation) SetIssueAfterResetPriority(u uint8) {
	m.issue_after_reset_priority = &u
	m.addissue_after_reset_priority = nil
}

// IssueAfterResetPriority returns the value of the "issue_after_reset_priority" field in the mutation.
func (m *EntitlementMutation) IssueAfterResetPriority() (r uint8, exists bool) {
	v := m.issue_after_reset_priority
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueAfterResetPriority returns the old "issue_after_reset_priority" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIssueAfterResetPriority(ctx context.Context) (v *uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueAfterResetPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueAfterResetPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueAfterResetPriority: %w", err)
	}
	return oldValue.IssueAfterResetPriority, nil
}

// AddIssueAfterResetPriority adds u to the "issue_after_reset_priority" field.
func (m *EntitlementMutation) AddIssueAfterResetPriority(u int8) {
	if m.addissue_after_reset_priority != nil {
		*m.addissue_after_reset_priority += u
	} else {
		m.addissue_after_reset_priority = &u
	}
}

// AddedIssueAfterResetPriority returns the value that was added to the "issue_after_reset_priority" field in this mutation.
func (m *EntitlementMutation) AddedIssueAfterResetPriority() (r int8, exists bool) {
	v := m.addissue_after_reset_priority
	if v == nil {
		return
	}
	return *v, true
}

// ClearIssueAfterResetPriority clears the value of the "issue_after_reset_priority" field.
func (m *EntitlementMutation) ClearIssueAfterResetPriority() {
	m.issue_after_reset_priority = nil
	m.addissue_after_reset_priority = nil
	m.clearedFields[entitlement.FieldIssueAfterResetPriority] = struct{}{}
}

// IssueAfterResetPriorityCleared returns if the "issue_after_reset_priority" field was cleared in this mutation.
func (m *EntitlementMutation) IssueAfterResetPriorityCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIssueAfterResetPriority]
	return ok
}

// ResetIssueAfterResetPriority resets all changes to the "issue_after_reset_priority" field.
func (m *EntitlementMutation) ResetIssueAfterResetPriority() {
	m.issue_after_reset_priority = nil
	m.addissue_after_reset_priority = nil
	delete(m.clearedFields, entitlement.FieldIssueAfterResetPriority)
}

// SetIsSoftLimit sets the "is_soft_limit" field.
func (m *EntitlementMutation) SetIsSoftLimit(b bool) {
	m.is_soft_limit = &b
}

// IsSoftLimit returns the value of the "is_soft_limit" field in the mutation.
func (m *EntitlementMutation) IsSoftLimit() (r bool, exists bool) {
	v := m.is_soft_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSoftLimit returns the old "is_soft_limit" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldIsSoftLimit(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSoftLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSoftLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSoftLimit: %w", err)
	}
	return oldValue.IsSoftLimit, nil
}

// ClearIsSoftLimit clears the value of the "is_soft_limit" field.
func (m *EntitlementMutation) ClearIsSoftLimit() {
	m.is_soft_limit = nil
	m.clearedFields[entitlement.FieldIsSoftLimit] = struct{}{}
}

// IsSoftLimitCleared returns if the "is_soft_limit" field was cleared in this mutation.
func (m *EntitlementMutation) IsSoftLimitCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldIsSoftLimit]
	return ok
}

// ResetIsSoftLimit resets all changes to the "is_soft_limit" field.
func (m *EntitlementMutation) ResetIsSoftLimit() {
	m.is_soft_limit = nil
	delete(m.clearedFields, entitlement.FieldIsSoftLimit)
}

// SetPreserveOverageAtReset sets the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) SetPreserveOverageAtReset(b bool) {
	m.preserve_overage_at_reset = &b
}

// PreserveOverageAtReset returns the value of the "preserve_overage_at_reset" field in the mutation.
func (m *EntitlementMutation) PreserveOverageAtReset() (r bool, exists bool) {
	v := m.preserve_overage_at_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldPreserveOverageAtReset returns the old "preserve_overage_at_reset" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldPreserveOverageAtReset(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreserveOverageAtReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreserveOverageAtReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreserveOverageAtReset: %w", err)
	}
	return oldValue.PreserveOverageAtReset, nil
}

// ClearPreserveOverageAtReset clears the value of the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) ClearPreserveOverageAtReset() {
	m.preserve_overage_at_reset = nil
	m.clearedFields[entitlement.FieldPreserveOverageAtReset] = struct{}{}
}

// PreserveOverageAtResetCleared returns if the "preserve_overage_at_reset" field was cleared in this mutation.
func (m *EntitlementMutation) PreserveOverageAtResetCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldPreserveOverageAtReset]
	return ok
}

// ResetPreserveOverageAtReset resets all changes to the "preserve_overage_at_reset" field.
func (m *EntitlementMutation) ResetPreserveOverageAtReset() {
	m.preserve_overage_at_reset = nil
	delete(m.clearedFields, entitlement.FieldPreserveOverageAtReset)
}

// SetConfig sets the "config" field.
func (m *EntitlementMutation) SetConfig(u []uint8) {
	m._config = &u
	m.append_config = nil
}

// Config returns the value of the "config" field in the mutation.
func (m *EntitlementMutation) Config() (r []uint8, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldConfig(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// AppendConfig adds u to the "config" field.
func (m *EntitlementMutation) AppendConfig(u []uint8) {
	m.append_config = append(m.append_config, u...)
}

// AppendedConfig returns the list of values that were appended to the "config" field in this mutation.
func (m *EntitlementMutation) AppendedConfig() ([]uint8, bool) {
	if len(m.append_config) == 0 {
		return nil, false
	}
	return m.append_config, true
}

// ClearConfig clears the value of the "config" field.
func (m *EntitlementMutation) ClearConfig() {
	m._config = nil
	m.append_config = nil
	m.clearedFields[entitlement.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *EntitlementMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *EntitlementMutation) ResetConfig() {
	m._config = nil
	m.append_config = nil
	delete(m.clearedFields, entitlement.FieldConfig)
}

// SetUsagePeriodInterval sets the "usage_period_interval" field.
func (m *EntitlementMutation) SetUsagePeriodInterval(i isodate.String) {
	m.usage_period_interval = &i
}

// UsagePeriodInterval returns the value of the "usage_period_interval" field in the mutation.
func (m *EntitlementMutation) UsagePeriodInterval() (r isodate.String, exists bool) {
	v := m.usage_period_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldUsagePeriodInterval returns the old "usage_period_interval" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUsagePeriodInterval(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsagePeriodInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsagePeriodInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsagePeriodInterval: %w", err)
	}
	return oldValue.UsagePeriodInterval, nil
}

// ClearUsagePeriodInterval clears the value of the "usage_period_interval" field.
func (m *EntitlementMutation) ClearUsagePeriodInterval() {
	m.usage_period_interval = nil
	m.clearedFields[entitlement.FieldUsagePeriodInterval] = struct{}{}
}

// UsagePeriodIntervalCleared returns if the "usage_period_interval" field was cleared in this mutation.
func (m *EntitlementMutation) UsagePeriodIntervalCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldUsagePeriodInterval]
	return ok
}

// ResetUsagePeriodInterval resets all changes to the "usage_period_interval" field.
func (m *EntitlementMutation) ResetUsagePeriodInterval() {
	m.usage_period_interval = nil
	delete(m.clearedFields, entitlement.FieldUsagePeriodInterval)
}

// SetUsagePeriodAnchor sets the "usage_period_anchor" field.
func (m *EntitlementMutation) SetUsagePeriodAnchor(t time.Time) {
	m.usage_period_anchor = &t
}

// UsagePeriodAnchor returns the value of the "usage_period_anchor" field in the mutation.
func (m *EntitlementMutation) UsagePeriodAnchor() (r time.Time, exists bool) {
	v := m.usage_period_anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldUsagePeriodAnchor returns the old "usage_period_anchor" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUsagePeriodAnchor(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsagePeriodAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsagePeriodAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsagePeriodAnchor: %w", err)
	}
	return oldValue.UsagePeriodAnchor, nil
}

// ClearUsagePeriodAnchor clears the value of the "usage_period_anchor" field.
func (m *EntitlementMutation) ClearUsagePeriodAnchor() {
	m.usage_period_anchor = nil
	m.clearedFields[entitlement.FieldUsagePeriodAnchor] = struct{}{}
}

// UsagePeriodAnchorCleared returns if the "usage_period_anchor" field was cleared in this mutation.
func (m *EntitlementMutation) UsagePeriodAnchorCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldUsagePeriodAnchor]
	return ok
}

// ResetUsagePeriodAnchor resets all changes to the "usage_period_anchor" field.
func (m *EntitlementMutation) ResetUsagePeriodAnchor() {
	m.usage_period_anchor = nil
	delete(m.clearedFields, entitlement.FieldUsagePeriodAnchor)
}

// SetCurrentUsagePeriodStart sets the "current_usage_period_start" field.
func (m *EntitlementMutation) SetCurrentUsagePeriodStart(t time.Time) {
	m.current_usage_period_start = &t
}

// CurrentUsagePeriodStart returns the value of the "current_usage_period_start" field in the mutation.
func (m *EntitlementMutation) CurrentUsagePeriodStart() (r time.Time, exists bool) {
	v := m.current_usage_period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentUsagePeriodStart returns the old "current_usage_period_start" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCurrentUsagePeriodStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentUsagePeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentUsagePeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentUsagePeriodStart: %w", err)
	}
	return oldValue.CurrentUsagePeriodStart, nil
}

// ClearCurrentUsagePeriodStart clears the value of the "current_usage_period_start" field.
func (m *EntitlementMutation) ClearCurrentUsagePeriodStart() {
	m.current_usage_period_start = nil
	m.clearedFields[entitlement.FieldCurrentUsagePeriodStart] = struct{}{}
}

// CurrentUsagePeriodStartCleared returns if the "current_usage_period_start" field was cleared in this mutation.
func (m *EntitlementMutation) CurrentUsagePeriodStartCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldCurrentUsagePeriodStart]
	return ok
}

// ResetCurrentUsagePeriodStart resets all changes to the "current_usage_period_start" field.
func (m *EntitlementMutation) ResetCurrentUsagePeriodStart() {
	m.current_usage_period_start = nil
	delete(m.clearedFields, entitlement.FieldCurrentUsagePeriodStart)
}

// SetCurrentUsagePeriodEnd sets the "current_usage_period_end" field.
func (m *EntitlementMutation) SetCurrentUsagePeriodEnd(t time.Time) {
	m.current_usage_period_end = &t
}

// CurrentUsagePeriodEnd returns the value of the "current_usage_period_end" field in the mutation.
func (m *EntitlementMutation) CurrentUsagePeriodEnd() (r time.Time, exists bool) {
	v := m.current_usage_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentUsagePeriodEnd returns the old "current_usage_period_end" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCurrentUsagePeriodEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentUsagePeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentUsagePeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentUsagePeriodEnd: %w", err)
	}
	return oldValue.CurrentUsagePeriodEnd, nil
}

// ClearCurrentUsagePeriodEnd clears the value of the "current_usage_period_end" field.
func (m *EntitlementMutation) ClearCurrentUsagePeriodEnd() {
	m.current_usage_period_end = nil
	m.clearedFields[entitlement.FieldCurrentUsagePeriodEnd] = struct{}{}
}

// CurrentUsagePeriodEndCleared returns if the "current_usage_period_end" field was cleared in this mutation.
func (m *EntitlementMutation) CurrentUsagePeriodEndCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldCurrentUsagePeriodEnd]
	return ok
}

// ResetCurrentUsagePeriodEnd resets all changes to the "current_usage_period_end" field.
func (m *EntitlementMutation) ResetCurrentUsagePeriodEnd() {
	m.current_usage_period_end = nil
	delete(m.clearedFields, entitlement.FieldCurrentUsagePeriodEnd)
}

// SetAnnotations sets the "annotations" field.
func (m *EntitlementMutation) SetAnnotations(value map[string]interface{}) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *EntitlementMutation) Annotations() (r map[string]interface{}, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldAnnotations(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *EntitlementMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[entitlement.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *EntitlementMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *EntitlementMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, entitlement.FieldAnnotations)
}

// AddUsageResetIDs adds the "usage_reset" edge to the UsageReset entity by ids.
func (m *EntitlementMutation) AddUsageResetIDs(ids ...string) {
	if m.usage_reset == nil {
		m.usage_reset = make(map[string]struct{})
	}
	for i := range ids {
		m.usage_reset[ids[i]] = struct{}{}
	}
}

// ClearUsageReset clears the "usage_reset" edge to the UsageReset entity.
func (m *EntitlementMutation) ClearUsageReset() {
	m.clearedusage_reset = true
}

// UsageResetCleared reports if the "usage_reset" edge to the UsageReset entity was cleared.
func (m *EntitlementMutation) UsageResetCleared() bool {
	return m.clearedusage_reset
}

// RemoveUsageResetIDs removes the "usage_reset" edge to the UsageReset entity by IDs.
func (m *EntitlementMutation) RemoveUsageResetIDs(ids ...string) {
	if m.removedusage_reset == nil {
		m.removedusage_reset = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.usage_reset, ids[i])
		m.removedusage_reset[ids[i]] = struct{}{}
	}
}

// RemovedUsageReset returns the removed IDs of the "usage_reset" edge to the UsageReset entity.
func (m *EntitlementMutation) RemovedUsageResetIDs() (ids []string) {
	for id := range m.removedusage_reset {
		ids = append(ids, id)
	}
	return
}

// UsageResetIDs returns the "usage_reset" edge IDs in the mutation.
func (m *EntitlementMutation) UsageResetIDs() (ids []string) {
	for id := range m.usage_reset {
		ids = append(ids, id)
	}
	return
}

// ResetUsageReset resets all changes to the "usage_reset" edge.
func (m *EntitlementMutation) ResetUsageReset() {
	m.usage_reset = nil
	m.clearedusage_reset = false
	m.removedusage_reset = nil
}

// AddGrantIDs adds the "grant" edge to the Grant entity by ids.
func (m *EntitlementMutation) AddGrantIDs(ids ...string) {
	if m.grant == nil {
		m.grant = make(map[string]struct{})
	}
	for i := range ids {
		m.grant[ids[i]] = struct{}{}
	}
}

// ClearGrant clears the "grant" edge to the Grant entity.
func (m *EntitlementMutation) ClearGrant() {
	m.clearedgrant = true
}

// GrantCleared reports if the "grant" edge to the Grant entity was cleared.
func (m *EntitlementMutation) GrantCleared() bool {
	return m.clearedgrant
}

// RemoveGrantIDs removes the "grant" edge to the Grant entity by IDs.
func (m *EntitlementMutation) RemoveGrantIDs(ids ...string) {
	if m.removedgrant == nil {
		m.removedgrant = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.grant, ids[i])
		m.removedgrant[ids[i]] = struct{}{}
	}
}

// RemovedGrant returns the removed IDs of the "grant" edge to the Grant entity.
func (m *EntitlementMutation) RemovedGrantIDs() (ids []string) {
	for id := range m.removedgrant {
		ids = append(ids, id)
	}
	return
}

// GrantIDs returns the "grant" edge IDs in the mutation.
func (m *EntitlementMutation) GrantIDs() (ids []string) {
	for id := range m.grant {
		ids = append(ids, id)
	}
	return
}

// ResetGrant resets all changes to the "grant" edge.
func (m *EntitlementMutation) ResetGrant() {
	m.grant = nil
	m.clearedgrant = false
	m.removedgrant = nil
}

// AddBalanceSnapshotIDs adds the "balance_snapshot" edge to the BalanceSnapshot entity by ids.
func (m *EntitlementMutation) AddBalanceSnapshotIDs(ids ...int) {
	if m.balance_snapshot == nil {
		m.balance_snapshot = make(map[int]struct{})
	}
	for i := range ids {
		m.balance_snapshot[ids[i]] = struct{}{}
	}
}

// ClearBalanceSnapshot clears the "balance_snapshot" edge to the BalanceSnapshot entity.
func (m *EntitlementMutation) ClearBalanceSnapshot() {
	m.clearedbalance_snapshot = true
}

// BalanceSnapshotCleared reports if the "balance_snapshot" edge to the BalanceSnapshot entity was cleared.
func (m *EntitlementMutation) BalanceSnapshotCleared() bool {
	return m.clearedbalance_snapshot
}

// RemoveBalanceSnapshotIDs removes the "balance_snapshot" edge to the BalanceSnapshot entity by IDs.
func (m *EntitlementMutation) RemoveBalanceSnapshotIDs(ids ...int) {
	if m.removedbalance_snapshot == nil {
		m.removedbalance_snapshot = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.balance_snapshot, ids[i])
		m.removedbalance_snapshot[ids[i]] = struct{}{}
	}
}

// RemovedBalanceSnapshot returns the removed IDs of the "balance_snapshot" edge to the BalanceSnapshot entity.
func (m *EntitlementMutation) RemovedBalanceSnapshotIDs() (ids []int) {
	for id := range m.removedbalance_snapshot {
		ids = append(ids, id)
	}
	return
}

// BalanceSnapshotIDs returns the "balance_snapshot" edge IDs in the mutation.
func (m *EntitlementMutation) BalanceSnapshotIDs() (ids []int) {
	for id := range m.balance_snapshot {
		ids = append(ids, id)
	}
	return
}

// ResetBalanceSnapshot resets all changes to the "balance_snapshot" edge.
func (m *EntitlementMutation) ResetBalanceSnapshot() {
	m.balance_snapshot = nil
	m.clearedbalance_snapshot = false
	m.removedbalance_snapshot = nil
}

// AddSubscriptionItemIDs adds the "subscription_item" edge to the SubscriptionItem entity by ids.
func (m *EntitlementMutation) AddSubscriptionItemIDs(ids ...string) {
	if m.subscription_item == nil {
		m.subscription_item = make(map[string]struct{})
	}
	for i := range ids {
		m.subscription_item[ids[i]] = struct{}{}
	}
}

// ClearSubscriptionItem clears the "subscription_item" edge to the SubscriptionItem entity.
func (m *EntitlementMutation) ClearSubscriptionItem() {
	m.clearedsubscription_item = true
}

// SubscriptionItemCleared reports if the "subscription_item" edge to the SubscriptionItem entity was cleared.
func (m *EntitlementMutation) SubscriptionItemCleared() bool {
	return m.clearedsubscription_item
}

// RemoveSubscriptionItemIDs removes the "subscription_item" edge to the SubscriptionItem entity by IDs.
func (m *EntitlementMutation) RemoveSubscriptionItemIDs(ids ...string) {
	if m.removedsubscription_item == nil {
		m.removedsubscription_item = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscription_item, ids[i])
		m.removedsubscription_item[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptionItem returns the removed IDs of the "subscription_item" edge to the SubscriptionItem entity.
func (m *EntitlementMutation) RemovedSubscriptionItemIDs() (ids []string) {
	for id := range m.removedsubscription_item {
		ids = append(ids, id)
	}
	return
}

// SubscriptionItemIDs returns the "subscription_item" edge IDs in the mutation.
func (m *EntitlementMutation) SubscriptionItemIDs() (ids []string) {
	for id := range m.subscription_item {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptionItem resets all changes to the "subscription_item" edge.
func (m *EntitlementMutation) ResetSubscriptionItem() {
	m.subscription_item = nil
	m.clearedsubscription_item = false
	m.removedsubscription_item = nil
}

// ClearFeature clears the "feature" edge to the Feature entity.
func (m *EntitlementMutation) ClearFeature() {
	m.clearedfeature = true
	m.clearedFields[entitlement.FieldFeatureID] = struct{}{}
}

// FeatureCleared reports if the "feature" edge to the Feature entity was cleared.
func (m *EntitlementMutation) FeatureCleared() bool {
	return m.clearedfeature
}

// FeatureIDs returns the "feature" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureID instead. It exists only for internal usage by the builders.
func (m *EntitlementMutation) FeatureIDs() (ids []string) {
	if id := m.feature; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeature resets all changes to the "feature" edge.
func (m *EntitlementMutation) ResetFeature() {
	m.feature = nil
	m.clearedfeature = false
}

// Where appends a list predicates to the EntitlementMutation builder.
func (m *EntitlementMutation) Where(ps ...predicate.Entitlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entitlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entitlement).
func (m *EntitlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.namespace != nil {
		fields = append(fields, entitlement.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, entitlement.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, entitlement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitlement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitlement.FieldDeletedAt)
	}
	if m.entitlement_type != nil {
		fields = append(fields, entitlement.FieldEntitlementType)
	}
	if m.feature != nil {
		fields = append(fields, entitlement.FieldFeatureID)
	}
	if m.active_from != nil {
		fields = append(fields, entitlement.FieldActiveFrom)
	}
	if m.active_to != nil {
		fields = append(fields, entitlement.FieldActiveTo)
	}
	if m.feature_key != nil {
		fields = append(fields, entitlement.FieldFeatureKey)
	}
	if m.subject_key != nil {
		fields = append(fields, entitlement.FieldSubjectKey)
	}
	if m.measure_usage_from != nil {
		fields = append(fields, entitlement.FieldMeasureUsageFrom)
	}
	if m.issue_after_reset != nil {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.issue_after_reset_priority != nil {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	if m.is_soft_limit != nil {
		fields = append(fields, entitlement.FieldIsSoftLimit)
	}
	if m.preserve_overage_at_reset != nil {
		fields = append(fields, entitlement.FieldPreserveOverageAtReset)
	}
	if m._config != nil {
		fields = append(fields, entitlement.FieldConfig)
	}
	if m.usage_period_interval != nil {
		fields = append(fields, entitlement.FieldUsagePeriodInterval)
	}
	if m.usage_period_anchor != nil {
		fields = append(fields, entitlement.FieldUsagePeriodAnchor)
	}
	if m.current_usage_period_start != nil {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodStart)
	}
	if m.current_usage_period_end != nil {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodEnd)
	}
	if m.annotations != nil {
		fields = append(fields, entitlement.FieldAnnotations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlement.FieldNamespace:
		return m.Namespace()
	case entitlement.FieldMetadata:
		return m.Metadata()
	case entitlement.FieldCreatedAt:
		return m.CreatedAt()
	case entitlement.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitlement.FieldDeletedAt:
		return m.DeletedAt()
	case entitlement.FieldEntitlementType:
		return m.EntitlementType()
	case entitlement.FieldFeatureID:
		return m.FeatureID()
	case entitlement.FieldActiveFrom:
		return m.ActiveFrom()
	case entitlement.FieldActiveTo:
		return m.ActiveTo()
	case entitlement.FieldFeatureKey:
		return m.FeatureKey()
	case entitlement.FieldSubjectKey:
		return m.SubjectKey()
	case entitlement.FieldMeasureUsageFrom:
		return m.MeasureUsageFrom()
	case entitlement.FieldIssueAfterReset:
		return m.IssueAfterReset()
	case entitlement.FieldIssueAfterResetPriority:
		return m.IssueAfterResetPriority()
	case entitlement.FieldIsSoftLimit:
		return m.IsSoftLimit()
	case entitlement.FieldPreserveOverageAtReset:
		return m.PreserveOverageAtReset()
	case entitlement.FieldConfig:
		return m.Config()
	case entitlement.FieldUsagePeriodInterval:
		return m.UsagePeriodInterval()
	case entitlement.FieldUsagePeriodAnchor:
		return m.UsagePeriodAnchor()
	case entitlement.FieldCurrentUsagePeriodStart:
		return m.CurrentUsagePeriodStart()
	case entitlement.FieldCurrentUsagePeriodEnd:
		return m.CurrentUsagePeriodEnd()
	case entitlement.FieldAnnotations:
		return m.Annotations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlement.FieldNamespace:
		return m.OldNamespace(ctx)
	case entitlement.FieldMetadata:
		return m.OldMetadata(ctx)
	case entitlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitlement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitlement.FieldEntitlementType:
		return m.OldEntitlementType(ctx)
	case entitlement.FieldFeatureID:
		return m.OldFeatureID(ctx)
	case entitlement.FieldActiveFrom:
		return m.OldActiveFrom(ctx)
	case entitlement.FieldActiveTo:
		return m.OldActiveTo(ctx)
	case entitlement.FieldFeatureKey:
		return m.OldFeatureKey(ctx)
	case entitlement.FieldSubjectKey:
		return m.OldSubjectKey(ctx)
	case entitlement.FieldMeasureUsageFrom:
		return m.OldMeasureUsageFrom(ctx)
	case entitlement.FieldIssueAfterReset:
		return m.OldIssueAfterReset(ctx)
	case entitlement.FieldIssueAfterResetPriority:
		return m.OldIssueAfterResetPriority(ctx)
	case entitlement.FieldIsSoftLimit:
		return m.OldIsSoftLimit(ctx)
	case entitlement.FieldPreserveOverageAtReset:
		return m.OldPreserveOverageAtReset(ctx)
	case entitlement.FieldConfig:
		return m.OldConfig(ctx)
	case entitlement.FieldUsagePeriodInterval:
		return m.OldUsagePeriodInterval(ctx)
	case entitlement.FieldUsagePeriodAnchor:
		return m.OldUsagePeriodAnchor(ctx)
	case entitlement.FieldCurrentUsagePeriodStart:
		return m.OldCurrentUsagePeriodStart(ctx)
	case entitlement.FieldCurrentUsagePeriodEnd:
		return m.OldCurrentUsagePeriodEnd(ctx)
	case entitlement.FieldAnnotations:
		return m.OldAnnotations(ctx)
	}
	return nil, fmt.Errorf("unknown Entitlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlement.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case entitlement.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case entitlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitlement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitlement.FieldEntitlementType:
		v, ok := value.(entitlement.EntitlementType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementType(v)
		return nil
	case entitlement.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	case entitlement.FieldActiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveFrom(v)
		return nil
	case entitlement.FieldActiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveTo(v)
		return nil
	case entitlement.FieldFeatureKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureKey(v)
		return nil
	case entitlement.FieldSubjectKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectKey(v)
		return nil
	case entitlement.FieldMeasureUsageFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasureUsageFrom(v)
		return nil
	case entitlement.FieldIssueAfterReset:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueAfterReset(v)
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueAfterResetPriority(v)
		return nil
	case entitlement.FieldIsSoftLimit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSoftLimit(v)
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreserveOverageAtReset(v)
		return nil
	case entitlement.FieldConfig:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case entitlement.FieldUsagePeriodInterval:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsagePeriodInterval(v)
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsagePeriodAnchor(v)
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentUsagePeriodStart(v)
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentUsagePeriodEnd(v)
		return nil
	case entitlement.FieldAnnotations:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementMutation) AddedFields() []string {
	var fields []string
	if m.addissue_after_reset != nil {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.addissue_after_reset_priority != nil {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entitlement.FieldIssueAfterReset:
		return m.AddedIssueAfterReset()
	case entitlement.FieldIssueAfterResetPriority:
		return m.AddedIssueAfterResetPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entitlement.FieldIssueAfterReset:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIssueAfterReset(v)
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIssueAfterResetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Entitlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlement.FieldMetadata) {
		fields = append(fields, entitlement.FieldMetadata)
	}
	if m.FieldCleared(entitlement.FieldDeletedAt) {
		fields = append(fields, entitlement.FieldDeletedAt)
	}
	if m.FieldCleared(entitlement.FieldActiveFrom) {
		fields = append(fields, entitlement.FieldActiveFrom)
	}
	if m.FieldCleared(entitlement.FieldActiveTo) {
		fields = append(fields, entitlement.FieldActiveTo)
	}
	if m.FieldCleared(entitlement.FieldMeasureUsageFrom) {
		fields = append(fields, entitlement.FieldMeasureUsageFrom)
	}
	if m.FieldCleared(entitlement.FieldIssueAfterReset) {
		fields = append(fields, entitlement.FieldIssueAfterReset)
	}
	if m.FieldCleared(entitlement.FieldIssueAfterResetPriority) {
		fields = append(fields, entitlement.FieldIssueAfterResetPriority)
	}
	if m.FieldCleared(entitlement.FieldIsSoftLimit) {
		fields = append(fields, entitlement.FieldIsSoftLimit)
	}
	if m.FieldCleared(entitlement.FieldPreserveOverageAtReset) {
		fields = append(fields, entitlement.FieldPreserveOverageAtReset)
	}
	if m.FieldCleared(entitlement.FieldConfig) {
		fields = append(fields, entitlement.FieldConfig)
	}
	if m.FieldCleared(entitlement.FieldUsagePeriodInterval) {
		fields = append(fields, entitlement.FieldUsagePeriodInterval)
	}
	if m.FieldCleared(entitlement.FieldUsagePeriodAnchor) {
		fields = append(fields, entitlement.FieldUsagePeriodAnchor)
	}
	if m.FieldCleared(entitlement.FieldCurrentUsagePeriodStart) {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodStart)
	}
	if m.FieldCleared(entitlement.FieldCurrentUsagePeriodEnd) {
		fields = append(fields, entitlement.FieldCurrentUsagePeriodEnd)
	}
	if m.FieldCleared(entitlement.FieldAnnotations) {
		fields = append(fields, entitlement.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementMutation) ClearField(name string) error {
	switch name {
	case entitlement.FieldMetadata:
		m.ClearMetadata()
		return nil
	case entitlement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitlement.FieldActiveFrom:
		m.ClearActiveFrom()
		return nil
	case entitlement.FieldActiveTo:
		m.ClearActiveTo()
		return nil
	case entitlement.FieldMeasureUsageFrom:
		m.ClearMeasureUsageFrom()
		return nil
	case entitlement.FieldIssueAfterReset:
		m.ClearIssueAfterReset()
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		m.ClearIssueAfterResetPriority()
		return nil
	case entitlement.FieldIsSoftLimit:
		m.ClearIsSoftLimit()
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		m.ClearPreserveOverageAtReset()
		return nil
	case entitlement.FieldConfig:
		m.ClearConfig()
		return nil
	case entitlement.FieldUsagePeriodInterval:
		m.ClearUsagePeriodInterval()
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		m.ClearUsagePeriodAnchor()
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		m.ClearCurrentUsagePeriodStart()
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		m.ClearCurrentUsagePeriodEnd()
		return nil
	case entitlement.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Entitlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementMutation) ResetField(name string) error {
	switch name {
	case entitlement.FieldNamespace:
		m.ResetNamespace()
		return nil
	case entitlement.FieldMetadata:
		m.ResetMetadata()
		return nil
	case entitlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitlement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitlement.FieldEntitlementType:
		m.ResetEntitlementType()
		return nil
	case entitlement.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	case entitlement.FieldActiveFrom:
		m.ResetActiveFrom()
		return nil
	case entitlement.FieldActiveTo:
		m.ResetActiveTo()
		return nil
	case entitlement.FieldFeatureKey:
		m.ResetFeatureKey()
		return nil
	case entitlement.FieldSubjectKey:
		m.ResetSubjectKey()
		return nil
	case entitlement.FieldMeasureUsageFrom:
		m.ResetMeasureUsageFrom()
		return nil
	case entitlement.FieldIssueAfterReset:
		m.ResetIssueAfterReset()
		return nil
	case entitlement.FieldIssueAfterResetPriority:
		m.ResetIssueAfterResetPriority()
		return nil
	case entitlement.FieldIsSoftLimit:
		m.ResetIsSoftLimit()
		return nil
	case entitlement.FieldPreserveOverageAtReset:
		m.ResetPreserveOverageAtReset()
		return nil
	case entitlement.FieldConfig:
		m.ResetConfig()
		return nil
	case entitlement.FieldUsagePeriodInterval:
		m.ResetUsagePeriodInterval()
		return nil
	case entitlement.FieldUsagePeriodAnchor:
		m.ResetUsagePeriodAnchor()
		return nil
	case entitlement.FieldCurrentUsagePeriodStart:
		m.ResetCurrentUsagePeriodStart()
		return nil
	case entitlement.FieldCurrentUsagePeriodEnd:
		m.ResetCurrentUsagePeriodEnd()
		return nil
	case entitlement.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.usage_reset != nil {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.grant != nil {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.balance_snapshot != nil {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	if m.subscription_item != nil {
		edges = append(edges, entitlement.EdgeSubscriptionItem)
	}
	if m.feature != nil {
		edges = append(edges, entitlement.EdgeFeature)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgeUsageReset:
		ids := make([]ent.Value, 0, len(m.usage_reset))
		for id := range m.usage_reset {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeGrant:
		ids := make([]ent.Value, 0, len(m.grant))
		for id := range m.grant {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeBalanceSnapshot:
		ids := make([]ent.Value, 0, len(m.balance_snapshot))
		for id := range m.balance_snapshot {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeSubscriptionItem:
		ids := make([]ent.Value, 0, len(m.subscription_item))
		for id := range m.subscription_item {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeFeature:
		if id := m.feature; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedusage_reset != nil {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.removedgrant != nil {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.removedbalance_snapshot != nil {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	if m.removedsubscription_item != nil {
		edges = append(edges, entitlement.EdgeSubscriptionItem)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgeUsageReset:
		ids := make([]ent.Value, 0, len(m.removedusage_reset))
		for id := range m.removedusage_reset {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeGrant:
		ids := make([]ent.Value, 0, len(m.removedgrant))
		for id := range m.removedgrant {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeBalanceSnapshot:
		ids := make([]ent.Value, 0, len(m.removedbalance_snapshot))
		for id := range m.removedbalance_snapshot {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeSubscriptionItem:
		ids := make([]ent.Value, 0, len(m.removedsubscription_item))
		for id := range m.removedsubscription_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedusage_reset {
		edges = append(edges, entitlement.EdgeUsageReset)
	}
	if m.clearedgrant {
		edges = append(edges, entitlement.EdgeGrant)
	}
	if m.clearedbalance_snapshot {
		edges = append(edges, entitlement.EdgeBalanceSnapshot)
	}
	if m.clearedsubscription_item {
		edges = append(edges, entitlement.EdgeSubscriptionItem)
	}
	if m.clearedfeature {
		edges = append(edges, entitlement.EdgeFeature)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementMutation) EdgeCleared(name string) bool {
	switch name {
	case entitlement.EdgeUsageReset:
		return m.clearedusage_reset
	case entitlement.EdgeGrant:
		return m.clearedgrant
	case entitlement.EdgeBalanceSnapshot:
		return m.clearedbalance_snapshot
	case entitlement.EdgeSubscriptionItem:
		return m.clearedsubscription_item
	case entitlement.EdgeFeature:
		return m.clearedfeature
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementMutation) ClearEdge(name string) error {
	switch name {
	case entitlement.EdgeFeature:
		m.ClearFeature()
		return nil
	}
	return fmt.Errorf("unknown Entitlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementMutation) ResetEdge(name string) error {
	switch name {
	case entitlement.EdgeUsageReset:
		m.ResetUsageReset()
		return nil
	case entitlement.EdgeGrant:
		m.ResetGrant()
		return nil
	case entitlement.EdgeBalanceSnapshot:
		m.ResetBalanceSnapshot()
		return nil
	case entitlement.EdgeSubscriptionItem:
		m.ResetSubscriptionItem()
		return nil
	case entitlement.EdgeFeature:
		m.ResetFeature()
		return nil
	}
	return fmt.Errorf("unknown Entitlement edge %s", name)
}

// FeatureMutation represents an operation that mutates the Feature nodes in the graph.
type FeatureMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	metadata               *map[string]string
	namespace              *string
	name                   *string
	key                    *string
	meter_slug             *string
	meter_group_by_filters *map[string]string
	archived_at            *time.Time
	clearedFields          map[string]struct{}
	entitlement            map[string]struct{}
	removedentitlement     map[string]struct{}
	clearedentitlement     bool
	ratecard               map[string]struct{}
	removedratecard        map[string]struct{}
	clearedratecard        bool
	addon_ratecard         map[string]struct{}
	removedaddon_ratecard  map[string]struct{}
	clearedaddon_ratecard  bool
	done                   bool
	oldValue               func(context.Context) (*Feature, error)
	predicates             []predicate.Feature
}

var _ ent.Mutation = (*FeatureMutation)(nil)

// featureOption allows management of the mutation configuration using functional options.
type featureOption func(*FeatureMutation)

// newFeatureMutation creates new mutation for the Feature entity.
func newFeatureMutation(c config, op Op, opts ...featureOption) *FeatureMutation {
	m := &FeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureID sets the ID field of the mutation.
func withFeatureID(id string) featureOption {
	return func(m *FeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *Feature
		)
		m.oldValue = func(ctx context.Context) (*Feature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeature sets the old Feature of the mutation.
func withFeature(node *Feature) featureOption {
	return func(m *FeatureMutation) {
		m.oldValue = func(context.Context) (*Feature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feature entities.
func (m *FeatureMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeatureMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeatureMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeatureMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[feature.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeatureMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeatureMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, feature.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *FeatureMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *FeatureMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *FeatureMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[feature.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *FeatureMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[feature.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *FeatureMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, feature.FieldMetadata)
}

// SetNamespace sets the "namespace" field.
func (m *FeatureMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *FeatureMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *FeatureMutation) ResetNamespace() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *FeatureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *FeatureMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *FeatureMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *FeatureMutation) ResetKey() {
	m.key = nil
}

// SetMeterSlug sets the "meter_slug" field.
func (m *FeatureMutation) SetMeterSlug(s string) {
	m.meter_slug = &s
}

// MeterSlug returns the value of the "meter_slug" field in the mutation.
func (m *FeatureMutation) MeterSlug() (r string, exists bool) {
	v := m.meter_slug
	if v == nil {
		return
	}
	return *v, true
}

// OldMeterSlug returns the old "meter_slug" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMeterSlug(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeterSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeterSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeterSlug: %w", err)
	}
	return oldValue.MeterSlug, nil
}

// ClearMeterSlug clears the value of the "meter_slug" field.
func (m *FeatureMutation) ClearMeterSlug() {
	m.meter_slug = nil
	m.clearedFields[feature.FieldMeterSlug] = struct{}{}
}

// MeterSlugCleared returns if the "meter_slug" field was cleared in this mutation.
func (m *FeatureMutation) MeterSlugCleared() bool {
	_, ok := m.clearedFields[feature.FieldMeterSlug]
	return ok
}

// ResetMeterSlug resets all changes to the "meter_slug" field.
func (m *FeatureMutation) ResetMeterSlug() {
	m.meter_slug = nil
	delete(m.clearedFields, feature.FieldMeterSlug)
}

// SetMeterGroupByFilters sets the "meter_group_by_filters" field.
func (m *FeatureMutation) SetMeterGroupByFilters(value map[string]string) {
	m.meter_group_by_filters = &value
}

// MeterGroupByFilters returns the value of the "meter_group_by_filters" field in the mutation.
func (m *FeatureMutation) MeterGroupByFilters() (r map[string]string, exists bool) {
	v := m.meter_group_by_filters
	if v == nil {
		return
	}
	return *v, true
}

// OldMeterGroupByFilters returns the old "meter_group_by_filters" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMeterGroupByFilters(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeterGroupByFilters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeterGroupByFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeterGroupByFilters: %w", err)
	}
	return oldValue.MeterGroupByFilters, nil
}

// ClearMeterGroupByFilters clears the value of the "meter_group_by_filters" field.
func (m *FeatureMutation) ClearMeterGroupByFilters() {
	m.meter_group_by_filters = nil
	m.clearedFields[feature.FieldMeterGroupByFilters] = struct{}{}
}

// MeterGroupByFiltersCleared returns if the "meter_group_by_filters" field was cleared in this mutation.
func (m *FeatureMutation) MeterGroupByFiltersCleared() bool {
	_, ok := m.clearedFields[feature.FieldMeterGroupByFilters]
	return ok
}

// ResetMeterGroupByFilters resets all changes to the "meter_group_by_filters" field.
func (m *FeatureMutation) ResetMeterGroupByFilters() {
	m.meter_group_by_filters = nil
	delete(m.clearedFields, feature.FieldMeterGroupByFilters)
}

// SetArchivedAt sets the "archived_at" field.
func (m *FeatureMutation) SetArchivedAt(t time.Time) {
	m.archived_at = &t
}

// ArchivedAt returns the value of the "archived_at" field in the mutation.
func (m *FeatureMutation) ArchivedAt() (r time.Time, exists bool) {
	v := m.archived_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedAt returns the old "archived_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldArchivedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedAt: %w", err)
	}
	return oldValue.ArchivedAt, nil
}

// ClearArchivedAt clears the value of the "archived_at" field.
func (m *FeatureMutation) ClearArchivedAt() {
	m.archived_at = nil
	m.clearedFields[feature.FieldArchivedAt] = struct{}{}
}

// ArchivedAtCleared returns if the "archived_at" field was cleared in this mutation.
func (m *FeatureMutation) ArchivedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldArchivedAt]
	return ok
}

// ResetArchivedAt resets all changes to the "archived_at" field.
func (m *FeatureMutation) ResetArchivedAt() {
	m.archived_at = nil
	delete(m.clearedFields, feature.FieldArchivedAt)
}

// AddEntitlementIDs adds the "entitlement" edge to the Entitlement entity by ids.
func (m *FeatureMutation) AddEntitlementIDs(ids ...string) {
	if m.entitlement == nil {
		m.entitlement = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlement[ids[i]] = struct{}{}
	}
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *FeatureMutation) ClearEntitlement() {
	m.clearedentitlement = true
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *FeatureMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// RemoveEntitlementIDs removes the "entitlement" edge to the Entitlement entity by IDs.
func (m *FeatureMutation) RemoveEntitlementIDs(ids ...string) {
	if m.removedentitlement == nil {
		m.removedentitlement = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlement, ids[i])
		m.removedentitlement[ids[i]] = struct{}{}
	}
}

// RemovedEntitlement returns the removed IDs of the "entitlement" edge to the Entitlement entity.
func (m *FeatureMutation) RemovedEntitlementIDs() (ids []string) {
	for id := range m.removedentitlement {
		ids = append(ids, id)
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
func (m *FeatureMutation) EntitlementIDs() (ids []string) {
	for id := range m.entitlement {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *FeatureMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
	m.removedentitlement = nil
}

// AddRatecardIDs adds the "ratecard" edge to the PlanRateCard entity by ids.
func (m *FeatureMutation) AddRatecardIDs(ids ...string) {
	if m.ratecard == nil {
		m.ratecard = make(map[string]struct{})
	}
	for i := range ids {
		m.ratecard[ids[i]] = struct{}{}
	}
}

// ClearRatecard clears the "ratecard" edge to the PlanRateCard entity.
func (m *FeatureMutation) ClearRatecard() {
	m.clearedratecard = true
}

// RatecardCleared reports if the "ratecard" edge to the PlanRateCard entity was cleared.
func (m *FeatureMutation) RatecardCleared() bool {
	return m.clearedratecard
}

// RemoveRatecardIDs removes the "ratecard" edge to the PlanRateCard entity by IDs.
func (m *FeatureMutation) RemoveRatecardIDs(ids ...string) {
	if m.removedratecard == nil {
		m.removedratecard = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ratecard, ids[i])
		m.removedratecard[ids[i]] = struct{}{}
	}
}

// RemovedRatecard returns the removed IDs of the "ratecard" edge to the PlanRateCard entity.
func (m *FeatureMutation) RemovedRatecardIDs() (ids []string) {
	for id := range m.removedratecard {
		ids = append(ids, id)
	}
	return
}

// RatecardIDs returns the "ratecard" edge IDs in the mutation.
func (m *FeatureMutation) RatecardIDs() (ids []string) {
	for id := range m.ratecard {
		ids = append(ids, id)
	}
	return
}

// ResetRatecard resets all changes to the "ratecard" edge.
func (m *FeatureMutation) ResetRatecard() {
	m.ratecard = nil
	m.clearedratecard = false
	m.removedratecard = nil
}

// AddAddonRatecardIDs adds the "addon_ratecard" edge to the AddonRateCard entity by ids.
func (m *FeatureMutation) AddAddonRatecardIDs(ids ...string) {
	if m.addon_ratecard == nil {
		m.addon_ratecard = make(map[string]struct{})
	}
	for i := range ids {
		m.addon_ratecard[ids[i]] = struct{}{}
	}
}

// ClearAddonRatecard clears the "addon_ratecard" edge to the AddonRateCard entity.
func (m *FeatureMutation) ClearAddonRatecard() {
	m.clearedaddon_ratecard = true
}

// AddonRatecardCleared reports if the "addon_ratecard" edge to the AddonRateCard entity was cleared.
func (m *FeatureMutation) AddonRatecardCleared() bool {
	return m.clearedaddon_ratecard
}

// RemoveAddonRatecardIDs removes the "addon_ratecard" edge to the AddonRateCard entity by IDs.
func (m *FeatureMutation) RemoveAddonRatecardIDs(ids ...string) {
	if m.removedaddon_ratecard == nil {
		m.removedaddon_ratecard = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.addon_ratecard, ids[i])
		m.removedaddon_ratecard[ids[i]] = struct{}{}
	}
}

// RemovedAddonRatecard returns the removed IDs of the "addon_ratecard" edge to the AddonRateCard entity.
func (m *FeatureMutation) RemovedAddonRatecardIDs() (ids []string) {
	for id := range m.removedaddon_ratecard {
		ids = append(ids, id)
	}
	return
}

// AddonRatecardIDs returns the "addon_ratecard" edge IDs in the mutation.
func (m *FeatureMutation) AddonRatecardIDs() (ids []string) {
	for id := range m.addon_ratecard {
		ids = append(ids, id)
	}
	return
}

// ResetAddonRatecard resets all changes to the "addon_ratecard" edge.
func (m *FeatureMutation) ResetAddonRatecard() {
	m.addon_ratecard = nil
	m.clearedaddon_ratecard = false
	m.removedaddon_ratecard = nil
}

// Where appends a list predicates to the FeatureMutation builder.
func (m *FeatureMutation) Where(ps ...predicate.Feature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feature).
func (m *FeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, feature.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feature.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, feature.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, feature.FieldMetadata)
	}
	if m.namespace != nil {
		fields = append(fields, feature.FieldNamespace)
	}
	if m.name != nil {
		fields = append(fields, feature.FieldName)
	}
	if m.key != nil {
		fields = append(fields, feature.FieldKey)
	}
	if m.meter_slug != nil {
		fields = append(fields, feature.FieldMeterSlug)
	}
	if m.meter_group_by_filters != nil {
		fields = append(fields, feature.FieldMeterGroupByFilters)
	}
	if m.archived_at != nil {
		fields = append(fields, feature.FieldArchivedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feature.FieldCreatedAt:
		return m.CreatedAt()
	case feature.FieldUpdatedAt:
		return m.UpdatedAt()
	case feature.FieldDeletedAt:
		return m.DeletedAt()
	case feature.FieldMetadata:
		return m.Metadata()
	case feature.FieldNamespace:
		return m.Namespace()
	case feature.FieldName:
		return m.Name()
	case feature.FieldKey:
		return m.Key()
	case feature.FieldMeterSlug:
		return m.MeterSlug()
	case feature.FieldMeterGroupByFilters:
		return m.MeterGroupByFilters()
	case feature.FieldArchivedAt:
		return m.ArchivedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feature.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feature.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case feature.FieldMetadata:
		return m.OldMetadata(ctx)
	case feature.FieldNamespace:
		return m.OldNamespace(ctx)
	case feature.FieldName:
		return m.OldName(ctx)
	case feature.FieldKey:
		return m.OldKey(ctx)
	case feature.FieldMeterSlug:
		return m.OldMeterSlug(ctx)
	case feature.FieldMeterGroupByFilters:
		return m.OldMeterGroupByFilters(ctx)
	case feature.FieldArchivedAt:
		return m.OldArchivedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Feature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feature.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feature.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case feature.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case feature.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case feature.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feature.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case feature.FieldMeterSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeterSlug(v)
		return nil
	case feature.FieldMeterGroupByFilters:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeterGroupByFilters(v)
		return nil
	case feature.FieldArchivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feature.FieldDeletedAt) {
		fields = append(fields, feature.FieldDeletedAt)
	}
	if m.FieldCleared(feature.FieldMetadata) {
		fields = append(fields, feature.FieldMetadata)
	}
	if m.FieldCleared(feature.FieldMeterSlug) {
		fields = append(fields, feature.FieldMeterSlug)
	}
	if m.FieldCleared(feature.FieldMeterGroupByFilters) {
		fields = append(fields, feature.FieldMeterGroupByFilters)
	}
	if m.FieldCleared(feature.FieldArchivedAt) {
		fields = append(fields, feature.FieldArchivedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureMutation) ClearField(name string) error {
	switch name {
	case feature.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case feature.FieldMetadata:
		m.ClearMetadata()
		return nil
	case feature.FieldMeterSlug:
		m.ClearMeterSlug()
		return nil
	case feature.FieldMeterGroupByFilters:
		m.ClearMeterGroupByFilters()
		return nil
	case feature.FieldArchivedAt:
		m.ClearArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Feature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureMutation) ResetField(name string) error {
	switch name {
	case feature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feature.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feature.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case feature.FieldMetadata:
		m.ResetMetadata()
		return nil
	case feature.FieldNamespace:
		m.ResetNamespace()
		return nil
	case feature.FieldName:
		m.ResetName()
		return nil
	case feature.FieldKey:
		m.ResetKey()
		return nil
	case feature.FieldMeterSlug:
		m.ResetMeterSlug()
		return nil
	case feature.FieldMeterGroupByFilters:
		m.ResetMeterGroupByFilters()
		return nil
	case feature.FieldArchivedAt:
		m.ResetArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.entitlement != nil {
		edges = append(edges, feature.EdgeEntitlement)
	}
	if m.ratecard != nil {
		edges = append(edges, feature.EdgeRatecard)
	}
	if m.addon_ratecard != nil {
		edges = append(edges, feature.EdgeAddonRatecard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeEntitlement:
		ids := make([]ent.Value, 0, len(m.entitlement))
		for id := range m.entitlement {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeRatecard:
		ids := make([]ent.Value, 0, len(m.ratecard))
		for id := range m.ratecard {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeAddonRatecard:
		ids := make([]ent.Value, 0, len(m.addon_ratecard))
		for id := range m.addon_ratecard {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedentitlement != nil {
		edges = append(edges, feature.EdgeEntitlement)
	}
	if m.removedratecard != nil {
		edges = append(edges, feature.EdgeRatecard)
	}
	if m.removedaddon_ratecard != nil {
		edges = append(edges, feature.EdgeAddonRatecard)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeEntitlement:
		ids := make([]ent.Value, 0, len(m.removedentitlement))
		for id := range m.removedentitlement {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeRatecard:
		ids := make([]ent.Value, 0, len(m.removedratecard))
		for id := range m.removedratecard {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeAddonRatecard:
		ids := make([]ent.Value, 0, len(m.removedaddon_ratecard))
		for id := range m.removedaddon_ratecard {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedentitlement {
		edges = append(edges, feature.EdgeEntitlement)
	}
	if m.clearedratecard {
		edges = append(edges, feature.EdgeRatecard)
	}
	if m.clearedaddon_ratecard {
		edges = append(edges, feature.EdgeAddonRatecard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case feature.EdgeEntitlement:
		return m.clearedentitlement
	case feature.EdgeRatecard:
		return m.clearedratecard
	case feature.EdgeAddonRatecard:
		return m.clearedaddon_ratecard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureMutation) ResetEdge(name string) error {
	switch name {
	case feature.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	case feature.EdgeRatecard:
		m.ResetRatecard()
		return nil
	case feature.EdgeAddonRatecard:
		m.ResetAddonRatecard()
		return nil
	}
	return fmt.Errorf("unknown Feature edge %s", name)
}

// GrantMutation represents an operation that mutates the Grant nodes in the graph.
type GrantMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	namespace             *string
	metadata              *map[string]string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	amount                *float64
	addamount             *float64
	priority              *uint8
	addpriority           *int8
	effective_at          *time.Time
	expiration            *grant.ExpirationPeriod
	expires_at            *time.Time
	voided_at             *time.Time
	reset_max_rollover    *float64
	addreset_max_rollover *float64
	reset_min_rollover    *float64
	addreset_min_rollover *float64
	recurrence_period     *isodate.String
	recurrence_anchor     *time.Time
	clearedFields         map[string]struct{}
	entitlement           *string
	clearedentitlement    bool
	done                  bool
	oldValue              func(context.Context) (*Grant, error)
	predicates            []predicate.Grant
}

var _ ent.Mutation = (*GrantMutation)(nil)

// grantOption allows management of the mutation configuration using functional options.
type grantOption func(*GrantMutation)

// newGrantMutation creates new mutation for the Grant entity.
func newGrantMutation(c config, op Op, opts ...grantOption) *GrantMutation {
	m := &GrantMutation{
		config:        c,
		op:            op,
		typ:           TypeGrant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrantID sets the ID field of the mutation.
func withGrantID(id string) grantOption {
	return func(m *GrantMutation) {
		var (
			err   error
			once  sync.Once
			value *Grant
		)
		m.oldValue = func(ctx context.Context) (*Grant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrant sets the old Grant of the mutation.
func withGrant(node *Grant) grantOption {
	return func(m *GrantMutation) {
		m.oldValue = func(context.Context) (*Grant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Grant entities.
func (m *GrantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GrantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GrantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Grant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *GrantMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *GrantMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *GrantMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *GrantMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *GrantMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *GrantMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[dbgrant.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *GrantMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *GrantMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, dbgrant.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *GrantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GrantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GrantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GrantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GrantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GrantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GrantMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GrantMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GrantMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dbgrant.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GrantMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GrantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dbgrant.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *GrantMutation) SetOwnerID(s string) {
	m.entitlement = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *GrantMutation) OwnerID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *GrantMutation) ResetOwnerID() {
	m.entitlement = nil
}

// SetAmount sets the "amount" field.
func (m *GrantMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GrantMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *GrantMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *GrantMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *GrantMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPriority sets the "priority" field.
func (m *GrantMutation) SetPriority(u uint8) {
	m.priority = &u
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *GrantMutation) Priority() (r uint8, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldPriority(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds u to the "priority" field.
func (m *GrantMutation) AddPriority(u int8) {
	if m.addpriority != nil {
		*m.addpriority += u
	} else {
		m.addpriority = &u
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *GrantMutation) AddedPriority() (r int8, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *GrantMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetEffectiveAt sets the "effective_at" field.
func (m *GrantMutation) SetEffectiveAt(t time.Time) {
	m.effective_at = &t
}

// EffectiveAt returns the value of the "effective_at" field in the mutation.
func (m *GrantMutation) EffectiveAt() (r time.Time, exists bool) {
	v := m.effective_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveAt returns the old "effective_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldEffectiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveAt: %w", err)
	}
	return oldValue.EffectiveAt, nil
}

// ResetEffectiveAt resets all changes to the "effective_at" field.
func (m *GrantMutation) ResetEffectiveAt() {
	m.effective_at = nil
}

// SetExpiration sets the "expiration" field.
func (m *GrantMutation) SetExpiration(gp grant.ExpirationPeriod) {
	m.expiration = &gp
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *GrantMutation) Expiration() (r grant.ExpirationPeriod, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldExpiration(ctx context.Context) (v grant.ExpirationPeriod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *GrantMutation) ResetExpiration() {
	m.expiration = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *GrantMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *GrantMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *GrantMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetVoidedAt sets the "voided_at" field.
func (m *GrantMutation) SetVoidedAt(t time.Time) {
	m.voided_at = &t
}

// VoidedAt returns the value of the "voided_at" field in the mutation.
func (m *GrantMutation) VoidedAt() (r time.Time, exists bool) {
	v := m.voided_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidedAt returns the old "voided_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldVoidedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidedAt: %w", err)
	}
	return oldValue.VoidedAt, nil
}

// ClearVoidedAt clears the value of the "voided_at" field.
func (m *GrantMutation) ClearVoidedAt() {
	m.voided_at = nil
	m.clearedFields[dbgrant.FieldVoidedAt] = struct{}{}
}

// VoidedAtCleared returns if the "voided_at" field was cleared in this mutation.
func (m *GrantMutation) VoidedAtCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldVoidedAt]
	return ok
}

// ResetVoidedAt resets all changes to the "voided_at" field.
func (m *GrantMutation) ResetVoidedAt() {
	m.voided_at = nil
	delete(m.clearedFields, dbgrant.FieldVoidedAt)
}

// SetResetMaxRollover sets the "reset_max_rollover" field.
func (m *GrantMutation) SetResetMaxRollover(f float64) {
	m.reset_max_rollover = &f
	m.addreset_max_rollover = nil
}

// ResetMaxRollover returns the value of the "reset_max_rollover" field in the mutation.
func (m *GrantMutation) ResetMaxRollover() (r float64, exists bool) {
	v := m.reset_max_rollover
	if v == nil {
		return
	}
	return *v, true
}

// OldResetMaxRollover returns the old "reset_max_rollover" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldResetMaxRollover(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetMaxRollover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetMaxRollover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetMaxRollover: %w", err)
	}
	return oldValue.ResetMaxRollover, nil
}

// AddResetMaxRollover adds f to the "reset_max_rollover" field.
func (m *GrantMutation) AddResetMaxRollover(f float64) {
	if m.addreset_max_rollover != nil {
		*m.addreset_max_rollover += f
	} else {
		m.addreset_max_rollover = &f
	}
}

// AddedResetMaxRollover returns the value that was added to the "reset_max_rollover" field in this mutation.
func (m *GrantMutation) AddedResetMaxRollover() (r float64, exists bool) {
	v := m.addreset_max_rollover
	if v == nil {
		return
	}
	return *v, true
}

// ResetResetMaxRollover resets all changes to the "reset_max_rollover" field.
func (m *GrantMutation) ResetResetMaxRollover() {
	m.reset_max_rollover = nil
	m.addreset_max_rollover = nil
}

// SetResetMinRollover sets the "reset_min_rollover" field.
func (m *GrantMutation) SetResetMinRollover(f float64) {
	m.reset_min_rollover = &f
	m.addreset_min_rollover = nil
}

// ResetMinRollover returns the value of the "reset_min_rollover" field in the mutation.
func (m *GrantMutation) ResetMinRollover() (r float64, exists bool) {
	v := m.reset_min_rollover
	if v == nil {
		return
	}
	return *v, true
}

// OldResetMinRollover returns the old "reset_min_rollover" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldResetMinRollover(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetMinRollover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetMinRollover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetMinRollover: %w", err)
	}
	return oldValue.ResetMinRollover, nil
}

// AddResetMinRollover adds f to the "reset_min_rollover" field.
func (m *GrantMutation) AddResetMinRollover(f float64) {
	if m.addreset_min_rollover != nil {
		*m.addreset_min_rollover += f
	} else {
		m.addreset_min_rollover = &f
	}
}

// AddedResetMinRollover returns the value that was added to the "reset_min_rollover" field in this mutation.
func (m *GrantMutation) AddedResetMinRollover() (r float64, exists bool) {
	v := m.addreset_min_rollover
	if v == nil {
		return
	}
	return *v, true
}

// ResetResetMinRollover resets all changes to the "reset_min_rollover" field.
func (m *GrantMutation) ResetResetMinRollover() {
	m.reset_min_rollover = nil
	m.addreset_min_rollover = nil
}

// SetRecurrencePeriod sets the "recurrence_period" field.
func (m *GrantMutation) SetRecurrencePeriod(i isodate.String) {
	m.recurrence_period = &i
}

// RecurrencePeriod returns the value of the "recurrence_period" field in the mutation.
func (m *GrantMutation) RecurrencePeriod() (r isodate.String, exists bool) {
	v := m.recurrence_period
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrencePeriod returns the old "recurrence_period" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRecurrencePeriod(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrencePeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrencePeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrencePeriod: %w", err)
	}
	return oldValue.RecurrencePeriod, nil
}

// ClearRecurrencePeriod clears the value of the "recurrence_period" field.
func (m *GrantMutation) ClearRecurrencePeriod() {
	m.recurrence_period = nil
	m.clearedFields[dbgrant.FieldRecurrencePeriod] = struct{}{}
}

// RecurrencePeriodCleared returns if the "recurrence_period" field was cleared in this mutation.
func (m *GrantMutation) RecurrencePeriodCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldRecurrencePeriod]
	return ok
}

// ResetRecurrencePeriod resets all changes to the "recurrence_period" field.
func (m *GrantMutation) ResetRecurrencePeriod() {
	m.recurrence_period = nil
	delete(m.clearedFields, dbgrant.FieldRecurrencePeriod)
}

// SetRecurrenceAnchor sets the "recurrence_anchor" field.
func (m *GrantMutation) SetRecurrenceAnchor(t time.Time) {
	m.recurrence_anchor = &t
}

// RecurrenceAnchor returns the value of the "recurrence_anchor" field in the mutation.
func (m *GrantMutation) RecurrenceAnchor() (r time.Time, exists bool) {
	v := m.recurrence_anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrenceAnchor returns the old "recurrence_anchor" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRecurrenceAnchor(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrenceAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrenceAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrenceAnchor: %w", err)
	}
	return oldValue.RecurrenceAnchor, nil
}

// ClearRecurrenceAnchor clears the value of the "recurrence_anchor" field.
func (m *GrantMutation) ClearRecurrenceAnchor() {
	m.recurrence_anchor = nil
	m.clearedFields[dbgrant.FieldRecurrenceAnchor] = struct{}{}
}

// RecurrenceAnchorCleared returns if the "recurrence_anchor" field was cleared in this mutation.
func (m *GrantMutation) RecurrenceAnchorCleared() bool {
	_, ok := m.clearedFields[dbgrant.FieldRecurrenceAnchor]
	return ok
}

// ResetRecurrenceAnchor resets all changes to the "recurrence_anchor" field.
func (m *GrantMutation) ResetRecurrenceAnchor() {
	m.recurrence_anchor = nil
	delete(m.clearedFields, dbgrant.FieldRecurrenceAnchor)
}

// SetEntitlementID sets the "entitlement" edge to the Entitlement entity by id.
func (m *GrantMutation) SetEntitlementID(id string) {
	m.entitlement = &id
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *GrantMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[dbgrant.FieldOwnerID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *GrantMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementID returns the "entitlement" edge ID in the mutation.
func (m *GrantMutation) EntitlementID() (id string, exists bool) {
	if m.entitlement != nil {
		return *m.entitlement, true
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *GrantMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *GrantMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the GrantMutation builder.
func (m *GrantMutation) Where(ps ...predicate.Grant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GrantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GrantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Grant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GrantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GrantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Grant).
func (m *GrantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GrantMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.namespace != nil {
		fields = append(fields, dbgrant.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, dbgrant.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, dbgrant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dbgrant.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dbgrant.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, dbgrant.FieldOwnerID)
	}
	if m.amount != nil {
		fields = append(fields, dbgrant.FieldAmount)
	}
	if m.priority != nil {
		fields = append(fields, dbgrant.FieldPriority)
	}
	if m.effective_at != nil {
		fields = append(fields, dbgrant.FieldEffectiveAt)
	}
	if m.expiration != nil {
		fields = append(fields, dbgrant.FieldExpiration)
	}
	if m.expires_at != nil {
		fields = append(fields, dbgrant.FieldExpiresAt)
	}
	if m.voided_at != nil {
		fields = append(fields, dbgrant.FieldVoidedAt)
	}
	if m.reset_max_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMaxRollover)
	}
	if m.reset_min_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMinRollover)
	}
	if m.recurrence_period != nil {
		fields = append(fields, dbgrant.FieldRecurrencePeriod)
	}
	if m.recurrence_anchor != nil {
		fields = append(fields, dbgrant.FieldRecurrenceAnchor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GrantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbgrant.FieldNamespace:
		return m.Namespace()
	case dbgrant.FieldMetadata:
		return m.Metadata()
	case dbgrant.FieldCreatedAt:
		return m.CreatedAt()
	case dbgrant.FieldUpdatedAt:
		return m.UpdatedAt()
	case dbgrant.FieldDeletedAt:
		return m.DeletedAt()
	case dbgrant.FieldOwnerID:
		return m.OwnerID()
	case dbgrant.FieldAmount:
		return m.Amount()
	case dbgrant.FieldPriority:
		return m.Priority()
	case dbgrant.FieldEffectiveAt:
		return m.EffectiveAt()
	case dbgrant.FieldExpiration:
		return m.Expiration()
	case dbgrant.FieldExpiresAt:
		return m.ExpiresAt()
	case dbgrant.FieldVoidedAt:
		return m.VoidedAt()
	case dbgrant.FieldResetMaxRollover:
		return m.ResetMaxRollover()
	case dbgrant.FieldResetMinRollover:
		return m.ResetMinRollover()
	case dbgrant.FieldRecurrencePeriod:
		return m.RecurrencePeriod()
	case dbgrant.FieldRecurrenceAnchor:
		return m.RecurrenceAnchor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GrantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbgrant.FieldNamespace:
		return m.OldNamespace(ctx)
	case dbgrant.FieldMetadata:
		return m.OldMetadata(ctx)
	case dbgrant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dbgrant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dbgrant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dbgrant.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case dbgrant.FieldAmount:
		return m.OldAmount(ctx)
	case dbgrant.FieldPriority:
		return m.OldPriority(ctx)
	case dbgrant.FieldEffectiveAt:
		return m.OldEffectiveAt(ctx)
	case dbgrant.FieldExpiration:
		return m.OldExpiration(ctx)
	case dbgrant.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case dbgrant.FieldVoidedAt:
		return m.OldVoidedAt(ctx)
	case dbgrant.FieldResetMaxRollover:
		return m.OldResetMaxRollover(ctx)
	case dbgrant.FieldResetMinRollover:
		return m.OldResetMinRollover(ctx)
	case dbgrant.FieldRecurrencePeriod:
		return m.OldRecurrencePeriod(ctx)
	case dbgrant.FieldRecurrenceAnchor:
		return m.OldRecurrenceAnchor(ctx)
	}
	return nil, fmt.Errorf("unknown Grant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbgrant.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case dbgrant.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case dbgrant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dbgrant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dbgrant.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dbgrant.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case dbgrant.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case dbgrant.FieldPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case dbgrant.FieldEffectiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveAt(v)
		return nil
	case dbgrant.FieldExpiration:
		v, ok := value.(grant.ExpirationPeriod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case dbgrant.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case dbgrant.FieldVoidedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidedAt(v)
		return nil
	case dbgrant.FieldResetMaxRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetMaxRollover(v)
		return nil
	case dbgrant.FieldResetMinRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetMinRollover(v)
		return nil
	case dbgrant.FieldRecurrencePeriod:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrencePeriod(v)
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrenceAnchor(v)
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GrantMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, dbgrant.FieldAmount)
	}
	if m.addpriority != nil {
		fields = append(fields, dbgrant.FieldPriority)
	}
	if m.addreset_max_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMaxRollover)
	}
	if m.addreset_min_rollover != nil {
		fields = append(fields, dbgrant.FieldResetMinRollover)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GrantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dbgrant.FieldAmount:
		return m.AddedAmount()
	case dbgrant.FieldPriority:
		return m.AddedPriority()
	case dbgrant.FieldResetMaxRollover:
		return m.AddedResetMaxRollover()
	case dbgrant.FieldResetMinRollover:
		return m.AddedResetMinRollover()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dbgrant.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case dbgrant.FieldPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case dbgrant.FieldResetMaxRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResetMaxRollover(v)
		return nil
	case dbgrant.FieldResetMinRollover:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResetMinRollover(v)
		return nil
	}
	return fmt.Errorf("unknown Grant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GrantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbgrant.FieldMetadata) {
		fields = append(fields, dbgrant.FieldMetadata)
	}
	if m.FieldCleared(dbgrant.FieldDeletedAt) {
		fields = append(fields, dbgrant.FieldDeletedAt)
	}
	if m.FieldCleared(dbgrant.FieldVoidedAt) {
		fields = append(fields, dbgrant.FieldVoidedAt)
	}
	if m.FieldCleared(dbgrant.FieldRecurrencePeriod) {
		fields = append(fields, dbgrant.FieldRecurrencePeriod)
	}
	if m.FieldCleared(dbgrant.FieldRecurrenceAnchor) {
		fields = append(fields, dbgrant.FieldRecurrenceAnchor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GrantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrantMutation) ClearField(name string) error {
	switch name {
	case dbgrant.FieldMetadata:
		m.ClearMetadata()
		return nil
	case dbgrant.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dbgrant.FieldVoidedAt:
		m.ClearVoidedAt()
		return nil
	case dbgrant.FieldRecurrencePeriod:
		m.ClearRecurrencePeriod()
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		m.ClearRecurrenceAnchor()
		return nil
	}
	return fmt.Errorf("unknown Grant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GrantMutation) ResetField(name string) error {
	switch name {
	case dbgrant.FieldNamespace:
		m.ResetNamespace()
		return nil
	case dbgrant.FieldMetadata:
		m.ResetMetadata()
		return nil
	case dbgrant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dbgrant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dbgrant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dbgrant.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case dbgrant.FieldAmount:
		m.ResetAmount()
		return nil
	case dbgrant.FieldPriority:
		m.ResetPriority()
		return nil
	case dbgrant.FieldEffectiveAt:
		m.ResetEffectiveAt()
		return nil
	case dbgrant.FieldExpiration:
		m.ResetExpiration()
		return nil
	case dbgrant.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case dbgrant.FieldVoidedAt:
		m.ResetVoidedAt()
		return nil
	case dbgrant.FieldResetMaxRollover:
		m.ResetResetMaxRollover()
		return nil
	case dbgrant.FieldResetMinRollover:
		m.ResetResetMinRollover()
		return nil
	case dbgrant.FieldRecurrencePeriod:
		m.ResetRecurrencePeriod()
		return nil
	case dbgrant.FieldRecurrenceAnchor:
		m.ResetRecurrenceAnchor()
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GrantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, dbgrant.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GrantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbgrant.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GrantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GrantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GrantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, dbgrant.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GrantMutation) EdgeCleared(name string) bool {
	switch name {
	case dbgrant.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GrantMutation) ClearEdge(name string) error {
	switch name {
	case dbgrant.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown Grant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GrantMutation) ResetEdge(name string) error {
	switch name {
	case dbgrant.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown Grant edge %s", name)
}

// MeterMutation represents an operation that mutates the Meter nodes in the graph.
type MeterMutation struct {
	config
	op             Op
	typ            string
	id             *string
	namespace      *string
	metadata       *map[string]string
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	name           *string
	description    *string
	key            *string
	event_type     *string
	value_property *string
	group_by       *map[string]string
	aggregation    *meter.MeterAggregation
	event_from     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Meter, error)
	predicates     []predicate.Meter
}

var _ ent.Mutation = (*MeterMutation)(nil)

// meterOption allows management of the mutation configuration using functional options.
type meterOption func(*MeterMutation)

// newMeterMutation creates new mutation for the Meter entity.
func newMeterMutation(c config, op Op, opts ...meterOption) *MeterMutation {
	m := &MeterMutation{
		config:        c,
		op:            op,
		typ:           TypeMeter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMeterID sets the ID field of the mutation.
func withMeterID(id string) meterOption {
	return func(m *MeterMutation) {
		var (
			err   error
			once  sync.Once
			value *Meter
		)
		m.oldValue = func(ctx context.Context) (*Meter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Meter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMeter sets the old Meter of the mutation.
func withMeter(node *Meter) meterOption {
	return func(m *MeterMutation) {
		m.oldValue = func(context.Context) (*Meter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MeterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MeterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Meter entities.
func (m *MeterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MeterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MeterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Meter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *MeterMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *MeterMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *MeterMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *MeterMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *MeterMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *MeterMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[dbmeter.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *MeterMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[dbmeter.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *MeterMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, dbmeter.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *MeterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MeterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MeterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MeterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MeterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MeterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MeterMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MeterMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MeterMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dbmeter.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MeterMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dbmeter.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MeterMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dbmeter.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *MeterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MeterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MeterMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *MeterMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MeterMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MeterMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[dbmeter.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MeterMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dbmeter.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MeterMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, dbmeter.FieldDescription)
}

// SetKey sets the "key" field.
func (m *MeterMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *MeterMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *MeterMutation) ResetKey() {
	m.key = nil
}

// SetEventType sets the "event_type" field.
func (m *MeterMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *MeterMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *MeterMutation) ResetEventType() {
	m.event_type = nil
}

// SetValueProperty sets the "value_property" field.
func (m *MeterMutation) SetValueProperty(s string) {
	m.value_property = &s
}

// ValueProperty returns the value of the "value_property" field in the mutation.
func (m *MeterMutation) ValueProperty() (r string, exists bool) {
	v := m.value_property
	if v == nil {
		return
	}
	return *v, true
}

// OldValueProperty returns the old "value_property" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldValueProperty(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueProperty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueProperty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueProperty: %w", err)
	}
	return oldValue.ValueProperty, nil
}

// ClearValueProperty clears the value of the "value_property" field.
func (m *MeterMutation) ClearValueProperty() {
	m.value_property = nil
	m.clearedFields[dbmeter.FieldValueProperty] = struct{}{}
}

// ValuePropertyCleared returns if the "value_property" field was cleared in this mutation.
func (m *MeterMutation) ValuePropertyCleared() bool {
	_, ok := m.clearedFields[dbmeter.FieldValueProperty]
	return ok
}

// ResetValueProperty resets all changes to the "value_property" field.
func (m *MeterMutation) ResetValueProperty() {
	m.value_property = nil
	delete(m.clearedFields, dbmeter.FieldValueProperty)
}

// SetGroupBy sets the "group_by" field.
func (m *MeterMutation) SetGroupBy(value map[string]string) {
	m.group_by = &value
}

// GroupBy returns the value of the "group_by" field in the mutation.
func (m *MeterMutation) GroupBy() (r map[string]string, exists bool) {
	v := m.group_by
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupBy returns the old "group_by" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldGroupBy(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupBy: %w", err)
	}
	return oldValue.GroupBy, nil
}

// ClearGroupBy clears the value of the "group_by" field.
func (m *MeterMutation) ClearGroupBy() {
	m.group_by = nil
	m.clearedFields[dbmeter.FieldGroupBy] = struct{}{}
}

// GroupByCleared returns if the "group_by" field was cleared in this mutation.
func (m *MeterMutation) GroupByCleared() bool {
	_, ok := m.clearedFields[dbmeter.FieldGroupBy]
	return ok
}

// ResetGroupBy resets all changes to the "group_by" field.
func (m *MeterMutation) ResetGroupBy() {
	m.group_by = nil
	delete(m.clearedFields, dbmeter.FieldGroupBy)
}

// SetAggregation sets the "aggregation" field.
func (m *MeterMutation) SetAggregation(ma meter.MeterAggregation) {
	m.aggregation = &ma
}

// Aggregation returns the value of the "aggregation" field in the mutation.
func (m *MeterMutation) Aggregation() (r meter.MeterAggregation, exists bool) {
	v := m.aggregation
	if v == nil {
		return
	}
	return *v, true
}

// OldAggregation returns the old "aggregation" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldAggregation(ctx context.Context) (v meter.MeterAggregation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAggregation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAggregation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAggregation: %w", err)
	}
	return oldValue.Aggregation, nil
}

// ResetAggregation resets all changes to the "aggregation" field.
func (m *MeterMutation) ResetAggregation() {
	m.aggregation = nil
}

// SetEventFrom sets the "event_from" field.
func (m *MeterMutation) SetEventFrom(t time.Time) {
	m.event_from = &t
}

// EventFrom returns the value of the "event_from" field in the mutation.
func (m *MeterMutation) EventFrom() (r time.Time, exists bool) {
	v := m.event_from
	if v == nil {
		return
	}
	return *v, true
}

// OldEventFrom returns the old "event_from" field's value of the Meter entity.
// If the Meter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeterMutation) OldEventFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventFrom: %w", err)
	}
	return oldValue.EventFrom, nil
}

// ClearEventFrom clears the value of the "event_from" field.
func (m *MeterMutation) ClearEventFrom() {
	m.event_from = nil
	m.clearedFields[dbmeter.FieldEventFrom] = struct{}{}
}

// EventFromCleared returns if the "event_from" field was cleared in this mutation.
func (m *MeterMutation) EventFromCleared() bool {
	_, ok := m.clearedFields[dbmeter.FieldEventFrom]
	return ok
}

// ResetEventFrom resets all changes to the "event_from" field.
func (m *MeterMutation) ResetEventFrom() {
	m.event_from = nil
	delete(m.clearedFields, dbmeter.FieldEventFrom)
}

// Where appends a list predicates to the MeterMutation builder.
func (m *MeterMutation) Where(ps ...predicate.Meter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MeterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MeterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Meter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MeterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MeterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Meter).
func (m *MeterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MeterMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.namespace != nil {
		fields = append(fields, dbmeter.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, dbmeter.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, dbmeter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dbmeter.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dbmeter.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, dbmeter.FieldName)
	}
	if m.description != nil {
		fields = append(fields, dbmeter.FieldDescription)
	}
	if m.key != nil {
		fields = append(fields, dbmeter.FieldKey)
	}
	if m.event_type != nil {
		fields = append(fields, dbmeter.FieldEventType)
	}
	if m.value_property != nil {
		fields = append(fields, dbmeter.FieldValueProperty)
	}
	if m.group_by != nil {
		fields = append(fields, dbmeter.FieldGroupBy)
	}
	if m.aggregation != nil {
		fields = append(fields, dbmeter.FieldAggregation)
	}
	if m.event_from != nil {
		fields = append(fields, dbmeter.FieldEventFrom)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MeterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbmeter.FieldNamespace:
		return m.Namespace()
	case dbmeter.FieldMetadata:
		return m.Metadata()
	case dbmeter.FieldCreatedAt:
		return m.CreatedAt()
	case dbmeter.FieldUpdatedAt:
		return m.UpdatedAt()
	case dbmeter.FieldDeletedAt:
		return m.DeletedAt()
	case dbmeter.FieldName:
		return m.Name()
	case dbmeter.FieldDescription:
		return m.Description()
	case dbmeter.FieldKey:
		return m.Key()
	case dbmeter.FieldEventType:
		return m.EventType()
	case dbmeter.FieldValueProperty:
		return m.ValueProperty()
	case dbmeter.FieldGroupBy:
		return m.GroupBy()
	case dbmeter.FieldAggregation:
		return m.Aggregation()
	case dbmeter.FieldEventFrom:
		return m.EventFrom()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MeterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbmeter.FieldNamespace:
		return m.OldNamespace(ctx)
	case dbmeter.FieldMetadata:
		return m.OldMetadata(ctx)
	case dbmeter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dbmeter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dbmeter.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dbmeter.FieldName:
		return m.OldName(ctx)
	case dbmeter.FieldDescription:
		return m.OldDescription(ctx)
	case dbmeter.FieldKey:
		return m.OldKey(ctx)
	case dbmeter.FieldEventType:
		return m.OldEventType(ctx)
	case dbmeter.FieldValueProperty:
		return m.OldValueProperty(ctx)
	case dbmeter.FieldGroupBy:
		return m.OldGroupBy(ctx)
	case dbmeter.FieldAggregation:
		return m.OldAggregation(ctx)
	case dbmeter.FieldEventFrom:
		return m.OldEventFrom(ctx)
	}
	return nil, fmt.Errorf("unknown Meter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbmeter.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case dbmeter.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case dbmeter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dbmeter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dbmeter.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dbmeter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbmeter.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dbmeter.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dbmeter.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case dbmeter.FieldValueProperty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueProperty(v)
		return nil
	case dbmeter.FieldGroupBy:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupBy(v)
		return nil
	case dbmeter.FieldAggregation:
		v, ok := value.(meter.MeterAggregation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAggregation(v)
		return nil
	case dbmeter.FieldEventFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventFrom(v)
		return nil
	}
	return fmt.Errorf("unknown Meter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MeterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MeterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Meter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MeterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbmeter.FieldMetadata) {
		fields = append(fields, dbmeter.FieldMetadata)
	}
	if m.FieldCleared(dbmeter.FieldDeletedAt) {
		fields = append(fields, dbmeter.FieldDeletedAt)
	}
	if m.FieldCleared(dbmeter.FieldDescription) {
		fields = append(fields, dbmeter.FieldDescription)
	}
	if m.FieldCleared(dbmeter.FieldValueProperty) {
		fields = append(fields, dbmeter.FieldValueProperty)
	}
	if m.FieldCleared(dbmeter.FieldGroupBy) {
		fields = append(fields, dbmeter.FieldGroupBy)
	}
	if m.FieldCleared(dbmeter.FieldEventFrom) {
		fields = append(fields, dbmeter.FieldEventFrom)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MeterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MeterMutation) ClearField(name string) error {
	switch name {
	case dbmeter.FieldMetadata:
		m.ClearMetadata()
		return nil
	case dbmeter.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dbmeter.FieldDescription:
		m.ClearDescription()
		return nil
	case dbmeter.FieldValueProperty:
		m.ClearValueProperty()
		return nil
	case dbmeter.FieldGroupBy:
		m.ClearGroupBy()
		return nil
	case dbmeter.FieldEventFrom:
		m.ClearEventFrom()
		return nil
	}
	return fmt.Errorf("unknown Meter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MeterMutation) ResetField(name string) error {
	switch name {
	case dbmeter.FieldNamespace:
		m.ResetNamespace()
		return nil
	case dbmeter.FieldMetadata:
		m.ResetMetadata()
		return nil
	case dbmeter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dbmeter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dbmeter.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dbmeter.FieldName:
		m.ResetName()
		return nil
	case dbmeter.FieldDescription:
		m.ResetDescription()
		return nil
	case dbmeter.FieldKey:
		m.ResetKey()
		return nil
	case dbmeter.FieldEventType:
		m.ResetEventType()
		return nil
	case dbmeter.FieldValueProperty:
		m.ResetValueProperty()
		return nil
	case dbmeter.FieldGroupBy:
		m.ResetGroupBy()
		return nil
	case dbmeter.FieldAggregation:
		m.ResetAggregation()
		return nil
	case dbmeter.FieldEventFrom:
		m.ResetEventFrom()
		return nil
	}
	return fmt.Errorf("unknown Meter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MeterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MeterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MeterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MeterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MeterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MeterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MeterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Meter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MeterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Meter edge %s", name)
}

// NotificationChannelMutation represents an operation that mutates the NotificationChannel nodes in the graph.
type NotificationChannelMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	_type         *notification.ChannelType
	name          *string
	disabled      *bool
	_config       *notification.ChannelConfig
	clearedFields map[string]struct{}
	rules         map[string]struct{}
	removedrules  map[string]struct{}
	clearedrules  bool
	done          bool
	oldValue      func(context.Context) (*NotificationChannel, error)
	predicates    []predicate.NotificationChannel
}

var _ ent.Mutation = (*NotificationChannelMutation)(nil)

// notificationchannelOption allows management of the mutation configuration using functional options.
type notificationchannelOption func(*NotificationChannelMutation)

// newNotificationChannelMutation creates new mutation for the NotificationChannel entity.
func newNotificationChannelMutation(c config, op Op, opts ...notificationchannelOption) *NotificationChannelMutation {
	m := &NotificationChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationChannelID sets the ID field of the mutation.
func withNotificationChannelID(id string) notificationchannelOption {
	return func(m *NotificationChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationChannel
		)
		m.oldValue = func(ctx context.Context) (*NotificationChannel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationChannel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationChannel sets the old NotificationChannel of the mutation.
func withNotificationChannel(node *NotificationChannel) notificationchannelOption {
	return func(m *NotificationChannelMutation) {
		m.oldValue = func(context.Context) (*NotificationChannel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationChannel entities.
func (m *NotificationChannelMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationChannelMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationChannelMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationChannel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationChannelMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationChannelMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationChannelMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationChannelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationChannelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationChannelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationchannel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationChannelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationchannel.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *NotificationChannelMutation) SetType(nt notification.ChannelType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationChannelMutation) GetType() (r notification.ChannelType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldType(ctx context.Context) (v notification.ChannelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationChannelMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *NotificationChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationChannelMutation) ResetName() {
	m.name = nil
}

// SetDisabled sets the "disabled" field.
func (m *NotificationChannelMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *NotificationChannelMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *NotificationChannelMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[notificationchannel.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *NotificationChannelMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[notificationchannel.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *NotificationChannelMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, notificationchannel.FieldDisabled)
}

// SetConfig sets the "config" field.
func (m *NotificationChannelMutation) SetConfig(nc notification.ChannelConfig) {
	m._config = &nc
}

// Config returns the value of the "config" field in the mutation.
func (m *NotificationChannelMutation) Config() (r notification.ChannelConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the NotificationChannel entity.
// If the NotificationChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationChannelMutation) OldConfig(ctx context.Context) (v notification.ChannelConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NotificationChannelMutation) ResetConfig() {
	m._config = nil
}

// AddRuleIDs adds the "rules" edge to the NotificationRule entity by ids.
func (m *NotificationChannelMutation) AddRuleIDs(ids ...string) {
	if m.rules == nil {
		m.rules = make(map[string]struct{})
	}
	for i := range ids {
		m.rules[ids[i]] = struct{}{}
	}
}

// ClearRules clears the "rules" edge to the NotificationRule entity.
func (m *NotificationChannelMutation) ClearRules() {
	m.clearedrules = true
}

// RulesCleared reports if the "rules" edge to the NotificationRule entity was cleared.
func (m *NotificationChannelMutation) RulesCleared() bool {
	return m.clearedrules
}

// RemoveRuleIDs removes the "rules" edge to the NotificationRule entity by IDs.
func (m *NotificationChannelMutation) RemoveRuleIDs(ids ...string) {
	if m.removedrules == nil {
		m.removedrules = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rules, ids[i])
		m.removedrules[ids[i]] = struct{}{}
	}
}

// RemovedRules returns the removed IDs of the "rules" edge to the NotificationRule entity.
func (m *NotificationChannelMutation) RemovedRulesIDs() (ids []string) {
	for id := range m.removedrules {
		ids = append(ids, id)
	}
	return
}

// RulesIDs returns the "rules" edge IDs in the mutation.
func (m *NotificationChannelMutation) RulesIDs() (ids []string) {
	for id := range m.rules {
		ids = append(ids, id)
	}
	return
}

// ResetRules resets all changes to the "rules" edge.
func (m *NotificationChannelMutation) ResetRules() {
	m.rules = nil
	m.clearedrules = false
	m.removedrules = nil
}

// Where appends a list predicates to the NotificationChannelMutation builder.
func (m *NotificationChannelMutation) Where(ps ...predicate.NotificationChannel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationChannel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationChannel).
func (m *NotificationChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationChannelMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, notificationchannel.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationchannel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationchannel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notificationchannel.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationchannel.FieldType)
	}
	if m.name != nil {
		fields = append(fields, notificationchannel.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, notificationchannel.FieldDisabled)
	}
	if m._config != nil {
		fields = append(fields, notificationchannel.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationchannel.FieldNamespace:
		return m.Namespace()
	case notificationchannel.FieldCreatedAt:
		return m.CreatedAt()
	case notificationchannel.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationchannel.FieldDeletedAt:
		return m.DeletedAt()
	case notificationchannel.FieldType:
		return m.GetType()
	case notificationchannel.FieldName:
		return m.Name()
	case notificationchannel.FieldDisabled:
		return m.Disabled()
	case notificationchannel.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationchannel.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationchannel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationchannel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationchannel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notificationchannel.FieldType:
		return m.OldType(ctx)
	case notificationchannel.FieldName:
		return m.OldName(ctx)
	case notificationchannel.FieldDisabled:
		return m.OldDisabled(ctx)
	case notificationchannel.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationChannel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationchannel.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationchannel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationchannel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationchannel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notificationchannel.FieldType:
		v, ok := value.(notification.ChannelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationchannel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationchannel.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case notificationchannel.FieldConfig:
		v, ok := value.(notification.ChannelConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationChannelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationChannelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationChannel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationchannel.FieldDeletedAt) {
		fields = append(fields, notificationchannel.FieldDeletedAt)
	}
	if m.FieldCleared(notificationchannel.FieldDisabled) {
		fields = append(fields, notificationchannel.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationChannelMutation) ClearField(name string) error {
	switch name {
	case notificationchannel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notificationchannel.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationChannelMutation) ResetField(name string) error {
	switch name {
	case notificationchannel.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationchannel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationchannel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationchannel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notificationchannel.FieldType:
		m.ResetType()
		return nil
	case notificationchannel.FieldName:
		m.ResetName()
		return nil
	case notificationchannel.FieldDisabled:
		m.ResetDisabled()
		return nil
	case notificationchannel.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rules != nil {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationchannel.EdgeRules:
		ids := make([]ent.Value, 0, len(m.rules))
		for id := range m.rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrules != nil {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationchannel.EdgeRules:
		ids := make([]ent.Value, 0, len(m.removedrules))
		for id := range m.removedrules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrules {
		edges = append(edges, notificationchannel.EdgeRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationchannel.EdgeRules:
		return m.clearedrules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationChannel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationChannelMutation) ResetEdge(name string) error {
	switch name {
	case notificationchannel.EdgeRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationChannel edge %s", name)
}

// NotificationEventMutation represents an operation that mutates the NotificationEvent nodes in the graph.
type NotificationEventMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	namespace                *string
	created_at               *time.Time
	_type                    *notification.EventType
	payload                  *string
	annotations              *map[string]interface{}
	clearedFields            map[string]struct{}
	delivery_statuses        map[string]struct{}
	removeddelivery_statuses map[string]struct{}
	cleareddelivery_statuses bool
	rules                    *string
	clearedrules             bool
	done                     bool
	oldValue                 func(context.Context) (*NotificationEvent, error)
	predicates               []predicate.NotificationEvent
}

var _ ent.Mutation = (*NotificationEventMutation)(nil)

// notificationeventOption allows management of the mutation configuration using functional options.
type notificationeventOption func(*NotificationEventMutation)

// newNotificationEventMutation creates new mutation for the NotificationEvent entity.
func newNotificationEventMutation(c config, op Op, opts ...notificationeventOption) *NotificationEventMutation {
	m := &NotificationEventMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationEventID sets the ID field of the mutation.
func withNotificationEventID(id string) notificationeventOption {
	return func(m *NotificationEventMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationEvent
		)
		m.oldValue = func(ctx context.Context) (*NotificationEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationEvent sets the old NotificationEvent of the mutation.
func withNotificationEvent(node *NotificationEvent) notificationeventOption {
	return func(m *NotificationEventMutation) {
		m.oldValue = func(context.Context) (*NotificationEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationEvent entities.
func (m *NotificationEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationEventMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationEventMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationEventMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetType sets the "type" field.
func (m *NotificationEventMutation) SetType(nt notification.EventType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationEventMutation) GetType() (r notification.EventType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldType(ctx context.Context) (v notification.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationEventMutation) ResetType() {
	m._type = nil
}

// SetRuleID sets the "rule_id" field.
func (m *NotificationEventMutation) SetRuleID(s string) {
	m.rules = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *NotificationEventMutation) RuleID() (r string, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *NotificationEventMutation) ResetRuleID() {
	m.rules = nil
}

// SetPayload sets the "payload" field.
func (m *NotificationEventMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *NotificationEventMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *NotificationEventMutation) ResetPayload() {
	m.payload = nil
}

// SetAnnotations sets the "annotations" field.
func (m *NotificationEventMutation) SetAnnotations(value map[string]interface{}) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *NotificationEventMutation) Annotations() (r map[string]interface{}, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldAnnotations(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *NotificationEventMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[notificationevent.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *NotificationEventMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[notificationevent.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *NotificationEventMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, notificationevent.FieldAnnotations)
}

// AddDeliveryStatusIDs adds the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity by ids.
func (m *NotificationEventMutation) AddDeliveryStatusIDs(ids ...string) {
	if m.delivery_statuses == nil {
		m.delivery_statuses = make(map[string]struct{})
	}
	for i := range ids {
		m.delivery_statuses[ids[i]] = struct{}{}
	}
}

// ClearDeliveryStatuses clears the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity.
func (m *NotificationEventMutation) ClearDeliveryStatuses() {
	m.cleareddelivery_statuses = true
}

// DeliveryStatusesCleared reports if the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity was cleared.
func (m *NotificationEventMutation) DeliveryStatusesCleared() bool {
	return m.cleareddelivery_statuses
}

// RemoveDeliveryStatusIDs removes the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity by IDs.
func (m *NotificationEventMutation) RemoveDeliveryStatusIDs(ids ...string) {
	if m.removeddelivery_statuses == nil {
		m.removeddelivery_statuses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.delivery_statuses, ids[i])
		m.removeddelivery_statuses[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryStatuses returns the removed IDs of the "delivery_statuses" edge to the NotificationEventDeliveryStatus entity.
func (m *NotificationEventMutation) RemovedDeliveryStatusesIDs() (ids []string) {
	for id := range m.removeddelivery_statuses {
		ids = append(ids, id)
	}
	return
}

// DeliveryStatusesIDs returns the "delivery_statuses" edge IDs in the mutation.
func (m *NotificationEventMutation) DeliveryStatusesIDs() (ids []string) {
	for id := range m.delivery_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryStatuses resets all changes to the "delivery_statuses" edge.
func (m *NotificationEventMutation) ResetDeliveryStatuses() {
	m.delivery_statuses = nil
	m.cleareddelivery_statuses = false
	m.removeddelivery_statuses = nil
}

// SetRulesID sets the "rules" edge to the NotificationRule entity by id.
func (m *NotificationEventMutation) SetRulesID(id string) {
	m.rules = &id
}

// ClearRules clears the "rules" edge to the NotificationRule entity.
func (m *NotificationEventMutation) ClearRules() {
	m.clearedrules = true
	m.clearedFields[notificationevent.FieldRuleID] = struct{}{}
}

// RulesCleared reports if the "rules" edge to the NotificationRule entity was cleared.
func (m *NotificationEventMutation) RulesCleared() bool {
	return m.clearedrules
}

// RulesID returns the "rules" edge ID in the mutation.
func (m *NotificationEventMutation) RulesID() (id string, exists bool) {
	if m.rules != nil {
		return *m.rules, true
	}
	return
}

// RulesIDs returns the "rules" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RulesID instead. It exists only for internal usage by the builders.
func (m *NotificationEventMutation) RulesIDs() (ids []string) {
	if id := m.rules; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRules resets all changes to the "rules" edge.
func (m *NotificationEventMutation) ResetRules() {
	m.rules = nil
	m.clearedrules = false
}

// Where appends a list predicates to the NotificationEventMutation builder.
func (m *NotificationEventMutation) Where(ps ...predicate.NotificationEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationEvent).
func (m *NotificationEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationEventMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.namespace != nil {
		fields = append(fields, notificationevent.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationevent.FieldCreatedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationevent.FieldType)
	}
	if m.rules != nil {
		fields = append(fields, notificationevent.FieldRuleID)
	}
	if m.payload != nil {
		fields = append(fields, notificationevent.FieldPayload)
	}
	if m.annotations != nil {
		fields = append(fields, notificationevent.FieldAnnotations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationevent.FieldNamespace:
		return m.Namespace()
	case notificationevent.FieldCreatedAt:
		return m.CreatedAt()
	case notificationevent.FieldType:
		return m.GetType()
	case notificationevent.FieldRuleID:
		return m.RuleID()
	case notificationevent.FieldPayload:
		return m.Payload()
	case notificationevent.FieldAnnotations:
		return m.Annotations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationevent.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationevent.FieldType:
		return m.OldType(ctx)
	case notificationevent.FieldRuleID:
		return m.OldRuleID(ctx)
	case notificationevent.FieldPayload:
		return m.OldPayload(ctx)
	case notificationevent.FieldAnnotations:
		return m.OldAnnotations(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationevent.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationevent.FieldType:
		v, ok := value.(notification.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationevent.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case notificationevent.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case notificationevent.FieldAnnotations:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationevent.FieldAnnotations) {
		fields = append(fields, notificationevent.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationEventMutation) ClearField(name string) error {
	switch name {
	case notificationevent.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationEventMutation) ResetField(name string) error {
	switch name {
	case notificationevent.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationevent.FieldType:
		m.ResetType()
		return nil
	case notificationevent.FieldRuleID:
		m.ResetRuleID()
		return nil
	case notificationevent.FieldPayload:
		m.ResetPayload()
		return nil
	case notificationevent.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.delivery_statuses != nil {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	if m.rules != nil {
		edges = append(edges, notificationevent.EdgeRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		ids := make([]ent.Value, 0, len(m.delivery_statuses))
		for id := range m.delivery_statuses {
			ids = append(ids, id)
		}
		return ids
	case notificationevent.EdgeRules:
		if id := m.rules; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddelivery_statuses != nil {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		ids := make([]ent.Value, 0, len(m.removeddelivery_statuses))
		for id := range m.removeddelivery_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddelivery_statuses {
		edges = append(edges, notificationevent.EdgeDeliveryStatuses)
	}
	if m.clearedrules {
		edges = append(edges, notificationevent.EdgeRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationEventMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		return m.cleareddelivery_statuses
	case notificationevent.EdgeRules:
		return m.clearedrules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationEventMutation) ClearEdge(name string) error {
	switch name {
	case notificationevent.EdgeRules:
		m.ClearRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationEventMutation) ResetEdge(name string) error {
	switch name {
	case notificationevent.EdgeDeliveryStatuses:
		m.ResetDeliveryStatuses()
		return nil
	case notificationevent.EdgeRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent edge %s", name)
}

// NotificationEventDeliveryStatusMutation represents an operation that mutates the NotificationEventDeliveryStatus nodes in the graph.
type NotificationEventDeliveryStatusMutation struct {
	config
	op            Op
	typ           string
	id            *string
	namespace     *string
	created_at    *time.Time
	updated_at    *time.Time
	event_id      *string
	channel_id    *string
	state         *notification.EventDeliveryStatusState
	reason        *string
	clearedFields map[string]struct{}
	events        map[string]struct{}
	removedevents map[string]struct{}
	clearedevents bool
	done          bool
	oldValue      func(context.Context) (*NotificationEventDeliveryStatus, error)
	predicates    []predicate.NotificationEventDeliveryStatus
}

var _ ent.Mutation = (*NotificationEventDeliveryStatusMutation)(nil)

// notificationeventdeliverystatusOption allows management of the mutation configuration using functional options.
type notificationeventdeliverystatusOption func(*NotificationEventDeliveryStatusMutation)

// newNotificationEventDeliveryStatusMutation creates new mutation for the NotificationEventDeliveryStatus entity.
func newNotificationEventDeliveryStatusMutation(c config, op Op, opts ...notificationeventdeliverystatusOption) *NotificationEventDeliveryStatusMutation {
	m := &NotificationEventDeliveryStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationEventDeliveryStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationEventDeliveryStatusID sets the ID field of the mutation.
func withNotificationEventDeliveryStatusID(id string) notificationeventdeliverystatusOption {
	return func(m *NotificationEventDeliveryStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationEventDeliveryStatus
		)
		m.oldValue = func(ctx context.Context) (*NotificationEventDeliveryStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationEventDeliveryStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationEventDeliveryStatus sets the old NotificationEventDeliveryStatus of the mutation.
func withNotificationEventDeliveryStatus(node *NotificationEventDeliveryStatus) notificationeventdeliverystatusOption {
	return func(m *NotificationEventDeliveryStatusMutation) {
		m.oldValue = func(context.Context) (*NotificationEventDeliveryStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationEventDeliveryStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationEventDeliveryStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationEventDeliveryStatus entities.
func (m *NotificationEventDeliveryStatusMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationEventDeliveryStatusMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationEventDeliveryStatusMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationEventDeliveryStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationEventDeliveryStatusMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationEventDeliveryStatusMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationEventDeliveryStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationEventDeliveryStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationEventDeliveryStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationEventDeliveryStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventID sets the "event_id" field.
func (m *NotificationEventDeliveryStatusMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *NotificationEventDeliveryStatusMutation) ResetEventID() {
	m.event_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *NotificationEventDeliveryStatusMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *NotificationEventDeliveryStatusMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetState sets the "state" field.
func (m *NotificationEventDeliveryStatusMutation) SetState(ndss notification.EventDeliveryStatusState) {
	m.state = &ndss
}

// State returns the value of the "state" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) State() (r notification.EventDeliveryStatusState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldState(ctx context.Context) (v notification.EventDeliveryStatusState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *NotificationEventDeliveryStatusMutation) ResetState() {
	m.state = nil
}

// SetReason sets the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *NotificationEventDeliveryStatusMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the NotificationEventDeliveryStatus entity.
// If the NotificationEventDeliveryStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventDeliveryStatusMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[notificationeventdeliverystatus.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[notificationeventdeliverystatus.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *NotificationEventDeliveryStatusMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, notificationeventdeliverystatus.FieldReason)
}

// AddEventIDs adds the "events" edge to the NotificationEvent entity by ids.
func (m *NotificationEventDeliveryStatusMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the NotificationEvent entity.
func (m *NotificationEventDeliveryStatusMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the NotificationEvent entity was cleared.
func (m *NotificationEventDeliveryStatusMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the NotificationEvent entity by IDs.
func (m *NotificationEventDeliveryStatusMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the NotificationEvent entity.
func (m *NotificationEventDeliveryStatusMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *NotificationEventDeliveryStatusMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *NotificationEventDeliveryStatusMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the NotificationEventDeliveryStatusMutation builder.
func (m *NotificationEventDeliveryStatusMutation) Where(ps ...predicate.NotificationEventDeliveryStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationEventDeliveryStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationEventDeliveryStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationEventDeliveryStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationEventDeliveryStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationEventDeliveryStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationEventDeliveryStatus).
func (m *NotificationEventDeliveryStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationEventDeliveryStatusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.namespace != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldUpdatedAt)
	}
	if m.event_id != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldEventID)
	}
	if m.channel_id != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldChannelID)
	}
	if m.state != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldState)
	}
	if m.reason != nil {
		fields = append(fields, notificationeventdeliverystatus.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationEventDeliveryStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		return m.Namespace()
	case notificationeventdeliverystatus.FieldCreatedAt:
		return m.CreatedAt()
	case notificationeventdeliverystatus.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationeventdeliverystatus.FieldEventID:
		return m.EventID()
	case notificationeventdeliverystatus.FieldChannelID:
		return m.ChannelID()
	case notificationeventdeliverystatus.FieldState:
		return m.State()
	case notificationeventdeliverystatus.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationEventDeliveryStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationeventdeliverystatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationeventdeliverystatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationeventdeliverystatus.FieldEventID:
		return m.OldEventID(ctx)
	case notificationeventdeliverystatus.FieldChannelID:
		return m.OldChannelID(ctx)
	case notificationeventdeliverystatus.FieldState:
		return m.OldState(ctx)
	case notificationeventdeliverystatus.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventDeliveryStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationeventdeliverystatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationeventdeliverystatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationeventdeliverystatus.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case notificationeventdeliverystatus.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case notificationeventdeliverystatus.FieldState:
		v, ok := value.(notification.EventDeliveryStatusState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case notificationeventdeliverystatus.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventDeliveryStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationEventDeliveryStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationeventdeliverystatus.FieldReason) {
		fields = append(fields, notificationeventdeliverystatus.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ClearField(name string) error {
	switch name {
	case notificationeventdeliverystatus.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ResetField(name string) error {
	switch name {
	case notificationeventdeliverystatus.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationeventdeliverystatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationeventdeliverystatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationeventdeliverystatus.FieldEventID:
		m.ResetEventID()
		return nil
	case notificationeventdeliverystatus.FieldChannelID:
		m.ResetChannelID()
		return nil
	case notificationeventdeliverystatus.FieldState:
		m.ResetState()
		return nil
	case notificationeventdeliverystatus.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationEventDeliveryStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationEventDeliveryStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationEventDeliveryStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, notificationeventdeliverystatus.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationEventDeliveryStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationEventDeliveryStatusMutation) ResetEdge(name string) error {
	switch name {
	case notificationeventdeliverystatus.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown NotificationEventDeliveryStatus edge %s", name)
}

// NotificationRuleMutation represents an operation that mutates the NotificationRule nodes in the graph.
type NotificationRuleMutation struct {
	config
	op              Op
	typ             string
	id              *string
	namespace       *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	_type           *notification.EventType
	name            *string
	disabled        *bool
	_config         *notification.RuleConfig
	clearedFields   map[string]struct{}
	channels        map[string]struct{}
	removedchannels map[string]struct{}
	clearedchannels bool
	events          map[string]struct{}
	removedevents   map[string]struct{}
	clearedevents   bool
	done            bool
	oldValue        func(context.Context) (*NotificationRule, error)
	predicates      []predicate.NotificationRule
}

var _ ent.Mutation = (*NotificationRuleMutation)(nil)

// notificationruleOption allows management of the mutation configuration using functional options.
type notificationruleOption func(*NotificationRuleMutation)

// newNotificationRuleMutation creates new mutation for the NotificationRule entity.
func newNotificationRuleMutation(c config, op Op, opts ...notificationruleOption) *NotificationRuleMutation {
	m := &NotificationRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationRuleID sets the ID field of the mutation.
func withNotificationRuleID(id string) notificationruleOption {
	return func(m *NotificationRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationRule
		)
		m.oldValue = func(ctx context.Context) (*NotificationRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationRule sets the old NotificationRule of the mutation.
func withNotificationRule(node *NotificationRule) notificationruleOption {
	return func(m *NotificationRuleMutation) {
		m.oldValue = func(context.Context) (*NotificationRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationRule entities.
func (m *NotificationRuleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationRuleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationRuleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *NotificationRuleMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *NotificationRuleMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *NotificationRuleMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationRuleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationRuleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationRuleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationrule.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationRuleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationrule.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationRuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationrule.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *NotificationRuleMutation) SetType(nt notification.EventType) {
	m._type = &nt
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationRuleMutation) GetType() (r notification.EventType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldType(ctx context.Context) (v notification.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationRuleMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *NotificationRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationRuleMutation) ResetName() {
	m.name = nil
}

// SetDisabled sets the "disabled" field.
func (m *NotificationRuleMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *NotificationRuleMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *NotificationRuleMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[notificationrule.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *NotificationRuleMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[notificationrule.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *NotificationRuleMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, notificationrule.FieldDisabled)
}

// SetConfig sets the "config" field.
func (m *NotificationRuleMutation) SetConfig(nc notification.RuleConfig) {
	m._config = &nc
}

// Config returns the value of the "config" field in the mutation.
func (m *NotificationRuleMutation) Config() (r notification.RuleConfig, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the NotificationRule entity.
// If the NotificationRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationRuleMutation) OldConfig(ctx context.Context) (v notification.RuleConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NotificationRuleMutation) ResetConfig() {
	m._config = nil
}

// AddChannelIDs adds the "channels" edge to the NotificationChannel entity by ids.
func (m *NotificationRuleMutation) AddChannelIDs(ids ...string) {
	if m.channels == nil {
		m.channels = make(map[string]struct{})
	}
	for i := range ids {
		m.channels[ids[i]] = struct{}{}
	}
}

// ClearChannels clears the "channels" edge to the NotificationChannel entity.
func (m *NotificationRuleMutation) ClearChannels() {
	m.clearedchannels = true
}

// ChannelsCleared reports if the "channels" edge to the NotificationChannel entity was cleared.
func (m *NotificationRuleMutation) ChannelsCleared() bool {
	return m.clearedchannels
}

// RemoveChannelIDs removes the "channels" edge to the NotificationChannel entity by IDs.
func (m *NotificationRuleMutation) RemoveChannelIDs(ids ...string) {
	if m.removedchannels == nil {
		m.removedchannels = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.channels, ids[i])
		m.removedchannels[ids[i]] = struct{}{}
	}
}

// RemovedChannels returns the removed IDs of the "channels" edge to the NotificationChannel entity.
func (m *NotificationRuleMutation) RemovedChannelsIDs() (ids []string) {
	for id := range m.removedchannels {
		ids = append(ids, id)
	}
	return
}

// ChannelsIDs returns the "channels" edge IDs in the mutation.
func (m *NotificationRuleMutation) ChannelsIDs() (ids []string) {
	for id := range m.channels {
		ids = append(ids, id)
	}
	return
}

// ResetChannels resets all changes to the "channels" edge.
func (m *NotificationRuleMutation) ResetChannels() {
	m.channels = nil
	m.clearedchannels = false
	m.removedchannels = nil
}

// AddEventIDs adds the "events" edge to the NotificationEvent entity by ids.
func (m *NotificationRuleMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the NotificationEvent entity.
func (m *NotificationRuleMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the NotificationEvent entity was cleared.
func (m *NotificationRuleMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the NotificationEvent entity by IDs.
func (m *NotificationRuleMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the NotificationEvent entity.
func (m *NotificationRuleMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *NotificationRuleMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *NotificationRuleMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the NotificationRuleMutation builder.
func (m *NotificationRuleMutation) Where(ps ...predicate.NotificationRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationRule).
func (m *NotificationRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationRuleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.namespace != nil {
		fields = append(fields, notificationrule.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, notificationrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationrule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notificationrule.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, notificationrule.FieldType)
	}
	if m.name != nil {
		fields = append(fields, notificationrule.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, notificationrule.FieldDisabled)
	}
	if m._config != nil {
		fields = append(fields, notificationrule.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationrule.FieldNamespace:
		return m.Namespace()
	case notificationrule.FieldCreatedAt:
		return m.CreatedAt()
	case notificationrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationrule.FieldDeletedAt:
		return m.DeletedAt()
	case notificationrule.FieldType:
		return m.GetType()
	case notificationrule.FieldName:
		return m.Name()
	case notificationrule.FieldDisabled:
		return m.Disabled()
	case notificationrule.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationrule.FieldNamespace:
		return m.OldNamespace(ctx)
	case notificationrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationrule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notificationrule.FieldType:
		return m.OldType(ctx)
	case notificationrule.FieldName:
		return m.OldName(ctx)
	case notificationrule.FieldDisabled:
		return m.OldDisabled(ctx)
	case notificationrule.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationrule.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case notificationrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationrule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notificationrule.FieldType:
		v, ok := value.(notification.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notificationrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationrule.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case notificationrule.FieldConfig:
		v, ok := value.(notification.RuleConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationRuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationRuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationrule.FieldDeletedAt) {
		fields = append(fields, notificationrule.FieldDeletedAt)
	}
	if m.FieldCleared(notificationrule.FieldDisabled) {
		fields = append(fields, notificationrule.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationRuleMutation) ClearField(name string) error {
	switch name {
	case notificationrule.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notificationrule.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationRuleMutation) ResetField(name string) error {
	switch name {
	case notificationrule.FieldNamespace:
		m.ResetNamespace()
		return nil
	case notificationrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationrule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notificationrule.FieldType:
		m.ResetType()
		return nil
	case notificationrule.FieldName:
		m.ResetName()
		return nil
	case notificationrule.FieldDisabled:
		m.ResetDisabled()
		return nil
	case notificationrule.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.channels != nil {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.events != nil {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationrule.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.channels))
		for id := range m.channels {
			ids = append(ids, id)
		}
		return ids
	case notificationrule.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchannels != nil {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.removedevents != nil {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notificationrule.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.removedchannels))
		for id := range m.removedchannels {
			ids = append(ids, id)
		}
		return ids
	case notificationrule.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchannels {
		edges = append(edges, notificationrule.EdgeChannels)
	}
	if m.clearedevents {
		edges = append(edges, notificationrule.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationrule.EdgeChannels:
		return m.clearedchannels
	case notificationrule.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationRuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationRuleMutation) ResetEdge(name string) error {
	switch name {
	case notificationrule.EdgeChannels:
		m.ResetChannels()
		return nil
	case notificationrule.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown NotificationRule edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	namespace            *string
	metadata             *map[string]string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	description          *string
	key                  *string
	billables_must_align *bool
	version              *int
	addversion           *int
	currency             *string
	effective_from       *time.Time
	effective_to         *time.Time
	is_custom            *bool
	clearedFields        map[string]struct{}
	phases               map[string]struct{}
	removedphases        map[string]struct{}
	clearedphases        bool
	addons               map[string]struct{}
	removedaddons        map[string]struct{}
	clearedaddons        bool
	subscriptions        map[string]struct{}
	removedsubscriptions map[string]struct{}
	clearedsubscriptions bool
	done                 bool
	oldValue             func(context.Context) (*Plan, error)
	predicates           []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id string) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plan entities.
func (m *PlanMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *PlanMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PlanMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PlanMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *PlanMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PlanMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PlanMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[plan.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PlanMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[plan.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PlanMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, plan.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlanMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[plan.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlanMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[plan.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, plan.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[plan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[plan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, plan.FieldDescription)
}

// SetKey sets the "key" field.
func (m *PlanMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PlanMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PlanMutation) ResetKey() {
	m.key = nil
}

// SetBillablesMustAlign sets the "billables_must_align" field.
func (m *PlanMutation) SetBillablesMustAlign(b bool) {
	m.billables_must_align = &b
}

// BillablesMustAlign returns the value of the "billables_must_align" field in the mutation.
func (m *PlanMutation) BillablesMustAlign() (r bool, exists bool) {
	v := m.billables_must_align
	if v == nil {
		return
	}
	return *v, true
}

// OldBillablesMustAlign returns the old "billables_must_align" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldBillablesMustAlign(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillablesMustAlign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillablesMustAlign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillablesMustAlign: %w", err)
	}
	return oldValue.BillablesMustAlign, nil
}

// ResetBillablesMustAlign resets all changes to the "billables_must_align" field.
func (m *PlanMutation) ResetBillablesMustAlign() {
	m.billables_must_align = nil
}

// SetVersion sets the "version" field.
func (m *PlanMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *PlanMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *PlanMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *PlanMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *PlanMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCurrency sets the "currency" field.
func (m *PlanMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PlanMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PlanMutation) ResetCurrency() {
	m.currency = nil
}

// SetEffectiveFrom sets the "effective_from" field.
func (m *PlanMutation) SetEffectiveFrom(t time.Time) {
	m.effective_from = &t
}

// EffectiveFrom returns the value of the "effective_from" field in the mutation.
func (m *PlanMutation) EffectiveFrom() (r time.Time, exists bool) {
	v := m.effective_from
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveFrom returns the old "effective_from" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldEffectiveFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveFrom: %w", err)
	}
	return oldValue.EffectiveFrom, nil
}

// ClearEffectiveFrom clears the value of the "effective_from" field.
func (m *PlanMutation) ClearEffectiveFrom() {
	m.effective_from = nil
	m.clearedFields[plan.FieldEffectiveFrom] = struct{}{}
}

// EffectiveFromCleared returns if the "effective_from" field was cleared in this mutation.
func (m *PlanMutation) EffectiveFromCleared() bool {
	_, ok := m.clearedFields[plan.FieldEffectiveFrom]
	return ok
}

// ResetEffectiveFrom resets all changes to the "effective_from" field.
func (m *PlanMutation) ResetEffectiveFrom() {
	m.effective_from = nil
	delete(m.clearedFields, plan.FieldEffectiveFrom)
}

// SetEffectiveTo sets the "effective_to" field.
func (m *PlanMutation) SetEffectiveTo(t time.Time) {
	m.effective_to = &t
}

// EffectiveTo returns the value of the "effective_to" field in the mutation.
func (m *PlanMutation) EffectiveTo() (r time.Time, exists bool) {
	v := m.effective_to
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveTo returns the old "effective_to" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldEffectiveTo(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveTo: %w", err)
	}
	return oldValue.EffectiveTo, nil
}

// ClearEffectiveTo clears the value of the "effective_to" field.
func (m *PlanMutation) ClearEffectiveTo() {
	m.effective_to = nil
	m.clearedFields[plan.FieldEffectiveTo] = struct{}{}
}

// EffectiveToCleared returns if the "effective_to" field was cleared in this mutation.
func (m *PlanMutation) EffectiveToCleared() bool {
	_, ok := m.clearedFields[plan.FieldEffectiveTo]
	return ok
}

// ResetEffectiveTo resets all changes to the "effective_to" field.
func (m *PlanMutation) ResetEffectiveTo() {
	m.effective_to = nil
	delete(m.clearedFields, plan.FieldEffectiveTo)
}

// SetIsCustom sets the "is_custom" field.
func (m *PlanMutation) SetIsCustom(b bool) {
	m.is_custom = &b
}

// IsCustom returns the value of the "is_custom" field in the mutation.
func (m *PlanMutation) IsCustom() (r bool, exists bool) {
	v := m.is_custom
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCustom returns the old "is_custom" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldIsCustom(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCustom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCustom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCustom: %w", err)
	}
	return oldValue.IsCustom, nil
}

// ResetIsCustom resets all changes to the "is_custom" field.
func (m *PlanMutation) ResetIsCustom() {
	m.is_custom = nil
}

// AddPhaseIDs adds the "phases" edge to the PlanPhase entity by ids.
func (m *PlanMutation) AddPhaseIDs(ids ...string) {
	if m.phases == nil {
		m.phases = make(map[string]struct{})
	}
	for i := range ids {
		m.phases[ids[i]] = struct{}{}
	}
}

// ClearPhases clears the "phases" edge to the PlanPhase entity.
func (m *PlanMutation) ClearPhases() {
	m.clearedphases = true
}

// PhasesCleared reports if the "phases" edge to the PlanPhase entity was cleared.
func (m *PlanMutation) PhasesCleared() bool {
	return m.clearedphases
}

// RemovePhaseIDs removes the "phases" edge to the PlanPhase entity by IDs.
func (m *PlanMutation) RemovePhaseIDs(ids ...string) {
	if m.removedphases == nil {
		m.removedphases = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.phases, ids[i])
		m.removedphases[ids[i]] = struct{}{}
	}
}

// RemovedPhases returns the removed IDs of the "phases" edge to the PlanPhase entity.
func (m *PlanMutation) RemovedPhasesIDs() (ids []string) {
	for id := range m.removedphases {
		ids = append(ids, id)
	}
	return
}

// PhasesIDs returns the "phases" edge IDs in the mutation.
func (m *PlanMutation) PhasesIDs() (ids []string) {
	for id := range m.phases {
		ids = append(ids, id)
	}
	return
}

// ResetPhases resets all changes to the "phases" edge.
func (m *PlanMutation) ResetPhases() {
	m.phases = nil
	m.clearedphases = false
	m.removedphases = nil
}

// AddAddonIDs adds the "addons" edge to the PlanAddon entity by ids.
func (m *PlanMutation) AddAddonIDs(ids ...string) {
	if m.addons == nil {
		m.addons = make(map[string]struct{})
	}
	for i := range ids {
		m.addons[ids[i]] = struct{}{}
	}
}

// ClearAddons clears the "addons" edge to the PlanAddon entity.
func (m *PlanMutation) ClearAddons() {
	m.clearedaddons = true
}

// AddonsCleared reports if the "addons" edge to the PlanAddon entity was cleared.
func (m *PlanMutation) AddonsCleared() bool {
	return m.clearedaddons
}

// RemoveAddonIDs removes the "addons" edge to the PlanAddon entity by IDs.
func (m *PlanMutation) RemoveAddonIDs(ids ...string) {
	if m.removedaddons == nil {
		m.removedaddons = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.addons, ids[i])
		m.removedaddons[ids[i]] = struct{}{}
	}
}

// RemovedAddons returns the removed IDs of the "addons" edge to the PlanAddon entity.
func (m *PlanMutation) RemovedAddonsIDs() (ids []string) {
	for id := range m.removedaddons {
		ids = append(ids, id)
	}
	return
}

// AddonsIDs returns the "addons" edge IDs in the mutation.
func (m *PlanMutation) AddonsIDs() (ids []string) {
	for id := range m.addons {
		ids = append(ids, id)
	}
	return
}

// ResetAddons resets all changes to the "addons" edge.
func (m *PlanMutation) ResetAddons() {
	m.addons = nil
	m.clearedaddons = false
	m.removedaddons = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *PlanMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[string]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *PlanMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *PlanMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *PlanMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *PlanMutation) RemovedSubscriptionsIDs() (ids []string) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *PlanMutation) SubscriptionsIDs() (ids []string) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *PlanMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.namespace != nil {
		fields = append(fields, plan.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, plan.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, plan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plan.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, plan.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, plan.FieldName)
	}
	if m.description != nil {
		fields = append(fields, plan.FieldDescription)
	}
	if m.key != nil {
		fields = append(fields, plan.FieldKey)
	}
	if m.billables_must_align != nil {
		fields = append(fields, plan.FieldBillablesMustAlign)
	}
	if m.version != nil {
		fields = append(fields, plan.FieldVersion)
	}
	if m.currency != nil {
		fields = append(fields, plan.FieldCurrency)
	}
	if m.effective_from != nil {
		fields = append(fields, plan.FieldEffectiveFrom)
	}
	if m.effective_to != nil {
		fields = append(fields, plan.FieldEffectiveTo)
	}
	if m.is_custom != nil {
		fields = append(fields, plan.FieldIsCustom)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldNamespace:
		return m.Namespace()
	case plan.FieldMetadata:
		return m.Metadata()
	case plan.FieldCreatedAt:
		return m.CreatedAt()
	case plan.FieldUpdatedAt:
		return m.UpdatedAt()
	case plan.FieldDeletedAt:
		return m.DeletedAt()
	case plan.FieldName:
		return m.Name()
	case plan.FieldDescription:
		return m.Description()
	case plan.FieldKey:
		return m.Key()
	case plan.FieldBillablesMustAlign:
		return m.BillablesMustAlign()
	case plan.FieldVersion:
		return m.Version()
	case plan.FieldCurrency:
		return m.Currency()
	case plan.FieldEffectiveFrom:
		return m.EffectiveFrom()
	case plan.FieldEffectiveTo:
		return m.EffectiveTo()
	case plan.FieldIsCustom:
		return m.IsCustom()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldNamespace:
		return m.OldNamespace(ctx)
	case plan.FieldMetadata:
		return m.OldMetadata(ctx)
	case plan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case plan.FieldName:
		return m.OldName(ctx)
	case plan.FieldDescription:
		return m.OldDescription(ctx)
	case plan.FieldKey:
		return m.OldKey(ctx)
	case plan.FieldBillablesMustAlign:
		return m.OldBillablesMustAlign(ctx)
	case plan.FieldVersion:
		return m.OldVersion(ctx)
	case plan.FieldCurrency:
		return m.OldCurrency(ctx)
	case plan.FieldEffectiveFrom:
		return m.OldEffectiveFrom(ctx)
	case plan.FieldEffectiveTo:
		return m.OldEffectiveTo(ctx)
	case plan.FieldIsCustom:
		return m.OldIsCustom(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case plan.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case plan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plan.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case plan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case plan.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case plan.FieldBillablesMustAlign:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillablesMustAlign(v)
		return nil
	case plan.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case plan.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case plan.FieldEffectiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveFrom(v)
		return nil
	case plan.FieldEffectiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveTo(v)
		return nil
	case plan.FieldIsCustom:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCustom(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, plan.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plan.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plan.FieldMetadata) {
		fields = append(fields, plan.FieldMetadata)
	}
	if m.FieldCleared(plan.FieldDeletedAt) {
		fields = append(fields, plan.FieldDeletedAt)
	}
	if m.FieldCleared(plan.FieldDescription) {
		fields = append(fields, plan.FieldDescription)
	}
	if m.FieldCleared(plan.FieldEffectiveFrom) {
		fields = append(fields, plan.FieldEffectiveFrom)
	}
	if m.FieldCleared(plan.FieldEffectiveTo) {
		fields = append(fields, plan.FieldEffectiveTo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	switch name {
	case plan.FieldMetadata:
		m.ClearMetadata()
		return nil
	case plan.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case plan.FieldDescription:
		m.ClearDescription()
		return nil
	case plan.FieldEffectiveFrom:
		m.ClearEffectiveFrom()
		return nil
	case plan.FieldEffectiveTo:
		m.ClearEffectiveTo()
		return nil
	}
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldNamespace:
		m.ResetNamespace()
		return nil
	case plan.FieldMetadata:
		m.ResetMetadata()
		return nil
	case plan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case plan.FieldName:
		m.ResetName()
		return nil
	case plan.FieldDescription:
		m.ResetDescription()
		return nil
	case plan.FieldKey:
		m.ResetKey()
		return nil
	case plan.FieldBillablesMustAlign:
		m.ResetBillablesMustAlign()
		return nil
	case plan.FieldVersion:
		m.ResetVersion()
		return nil
	case plan.FieldCurrency:
		m.ResetCurrency()
		return nil
	case plan.FieldEffectiveFrom:
		m.ResetEffectiveFrom()
		return nil
	case plan.FieldEffectiveTo:
		m.ResetEffectiveTo()
		return nil
	case plan.FieldIsCustom:
		m.ResetIsCustom()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.phases != nil {
		edges = append(edges, plan.EdgePhases)
	}
	if m.addons != nil {
		edges = append(edges, plan.EdgeAddons)
	}
	if m.subscriptions != nil {
		edges = append(edges, plan.EdgeSubscriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgePhases:
		ids := make([]ent.Value, 0, len(m.phases))
		for id := range m.phases {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeAddons:
		ids := make([]ent.Value, 0, len(m.addons))
		for id := range m.addons {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedphases != nil {
		edges = append(edges, plan.EdgePhases)
	}
	if m.removedaddons != nil {
		edges = append(edges, plan.EdgeAddons)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, plan.EdgeSubscriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgePhases:
		ids := make([]ent.Value, 0, len(m.removedphases))
		for id := range m.removedphases {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeAddons:
		ids := make([]ent.Value, 0, len(m.removedaddons))
		for id := range m.removedaddons {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedphases {
		edges = append(edges, plan.EdgePhases)
	}
	if m.clearedaddons {
		edges = append(edges, plan.EdgeAddons)
	}
	if m.clearedsubscriptions {
		edges = append(edges, plan.EdgeSubscriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	switch name {
	case plan.EdgePhases:
		return m.clearedphases
	case plan.EdgeAddons:
		return m.clearedaddons
	case plan.EdgeSubscriptions:
		return m.clearedsubscriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	switch name {
	case plan.EdgePhases:
		m.ResetPhases()
		return nil
	case plan.EdgeAddons:
		m.ResetAddons()
		return nil
	case plan.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown Plan edge %s", name)
}

// PlanAddonMutation represents an operation that mutates the PlanAddon nodes in the graph.
type PlanAddonMutation struct {
	config
	op              Op
	typ             string
	id              *string
	namespace       *string
	metadata        *map[string]string
	annotations     *map[string]interface{}
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	from_plan_phase *string
	max_quantity    *int
	addmax_quantity *int
	clearedFields   map[string]struct{}
	plan            *string
	clearedplan     bool
	addon           *string
	clearedaddon    bool
	done            bool
	oldValue        func(context.Context) (*PlanAddon, error)
	predicates      []predicate.PlanAddon
}

var _ ent.Mutation = (*PlanAddonMutation)(nil)

// planaddonOption allows management of the mutation configuration using functional options.
type planaddonOption func(*PlanAddonMutation)

// newPlanAddonMutation creates new mutation for the PlanAddon entity.
func newPlanAddonMutation(c config, op Op, opts ...planaddonOption) *PlanAddonMutation {
	m := &PlanAddonMutation{
		config:        c,
		op:            op,
		typ:           TypePlanAddon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanAddonID sets the ID field of the mutation.
func withPlanAddonID(id string) planaddonOption {
	return func(m *PlanAddonMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanAddon
		)
		m.oldValue = func(ctx context.Context) (*PlanAddon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanAddon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanAddon sets the old PlanAddon of the mutation.
func withPlanAddon(node *PlanAddon) planaddonOption {
	return func(m *PlanAddonMutation) {
		m.oldValue = func(context.Context) (*PlanAddon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanAddonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanAddonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlanAddon entities.
func (m *PlanAddonMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanAddonMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanAddonMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanAddon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *PlanAddonMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PlanAddonMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the PlanAddon entity.
// If the PlanAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanAddonMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PlanAddonMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *PlanAddonMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PlanAddonMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PlanAddon entity.
// If the PlanAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanAddonMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PlanAddonMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[planaddon.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PlanAddonMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[planaddon.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PlanAddonMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, planaddon.FieldMetadata)
}

// SetAnnotations sets the "annotations" field.
func (m *PlanAddonMutation) SetAnnotations(value map[string]interface{}) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *PlanAddonMutation) Annotations() (r map[string]interface{}, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the PlanAddon entity.
// If the PlanAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanAddonMutation) OldAnnotations(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *PlanAddonMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[planaddon.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *PlanAddonMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[planaddon.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *PlanAddonMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, planaddon.FieldAnnotations)
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanAddonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanAddonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlanAddon entity.
// If the PlanAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanAddonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanAddonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanAddonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanAddonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlanAddon entity.
// If the PlanAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanAddonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanAddonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanAddonMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanAddonMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlanAddon entity.
// If the PlanAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanAddonMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlanAddonMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[planaddon.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlanAddonMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[planaddon.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanAddonMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, planaddon.FieldDeletedAt)
}

// SetPlanID sets the "plan_id" field.
func (m *PlanAddonMutation) SetPlanID(s string) {
	m.plan = &s
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *PlanAddonMutation) PlanID() (r string, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the PlanAddon entity.
// If the PlanAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanAddonMutation) OldPlanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *PlanAddonMutation) ResetPlanID() {
	m.plan = nil
}

// SetAddonID sets the "addon_id" field.
func (m *PlanAddonMutation) SetAddonID(s string) {
	m.addon = &s
}

// AddonID returns the value of the "addon_id" field in the mutation.
func (m *PlanAddonMutation) AddonID() (r string, exists bool) {
	v := m.addon
	if v == nil {
		return
	}
	return *v, true
}

// OldAddonID returns the old "addon_id" field's value of the PlanAddon entity.
// If the PlanAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanAddonMutation) OldAddonID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddonID: %w", err)
	}
	return oldValue.AddonID, nil
}

// ResetAddonID resets all changes to the "addon_id" field.
func (m *PlanAddonMutation) ResetAddonID() {
	m.addon = nil
}

// SetFromPlanPhase sets the "from_plan_phase" field.
func (m *PlanAddonMutation) SetFromPlanPhase(s string) {
	m.from_plan_phase = &s
}

// FromPlanPhase returns the value of the "from_plan_phase" field in the mutation.
func (m *PlanAddonMutation) FromPlanPhase() (r string, exists bool) {
	v := m.from_plan_phase
	if v == nil {
		return
	}
	return *v, true
}

// OldFromPlanPhase returns the old "from_plan_phase" field's value of the PlanAddon entity.
// If the PlanAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanAddonMutation) OldFromPlanPhase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromPlanPhase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromPlanPhase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromPlanPhase: %w", err)
	}
	return oldValue.FromPlanPhase, nil
}

// ResetFromPlanPhase resets all changes to the "from_plan_phase" field.
func (m *PlanAddonMutation) ResetFromPlanPhase() {
	m.from_plan_phase = nil
}

// SetMaxQuantity sets the "max_quantity" field.
func (m *PlanAddonMutation) SetMaxQuantity(i int) {
	m.max_quantity = &i
	m.addmax_quantity = nil
}

// MaxQuantity returns the value of the "max_quantity" field in the mutation.
func (m *PlanAddonMutation) MaxQuantity() (r int, exists bool) {
	v := m.max_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxQuantity returns the old "max_quantity" field's value of the PlanAddon entity.
// If the PlanAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanAddonMutation) OldMaxQuantity(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxQuantity: %w", err)
	}
	return oldValue.MaxQuantity, nil
}

// AddMaxQuantity adds i to the "max_quantity" field.
func (m *PlanAddonMutation) AddMaxQuantity(i int) {
	if m.addmax_quantity != nil {
		*m.addmax_quantity += i
	} else {
		m.addmax_quantity = &i
	}
}

// AddedMaxQuantity returns the value that was added to the "max_quantity" field in this mutation.
func (m *PlanAddonMutation) AddedMaxQuantity() (r int, exists bool) {
	v := m.addmax_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxQuantity clears the value of the "max_quantity" field.
func (m *PlanAddonMutation) ClearMaxQuantity() {
	m.max_quantity = nil
	m.addmax_quantity = nil
	m.clearedFields[planaddon.FieldMaxQuantity] = struct{}{}
}

// MaxQuantityCleared returns if the "max_quantity" field was cleared in this mutation.
func (m *PlanAddonMutation) MaxQuantityCleared() bool {
	_, ok := m.clearedFields[planaddon.FieldMaxQuantity]
	return ok
}

// ResetMaxQuantity resets all changes to the "max_quantity" field.
func (m *PlanAddonMutation) ResetMaxQuantity() {
	m.max_quantity = nil
	m.addmax_quantity = nil
	delete(m.clearedFields, planaddon.FieldMaxQuantity)
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *PlanAddonMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[planaddon.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *PlanAddonMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *PlanAddonMutation) PlanIDs() (ids []string) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *PlanAddonMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearAddon clears the "addon" edge to the Addon entity.
func (m *PlanAddonMutation) ClearAddon() {
	m.clearedaddon = true
	m.clearedFields[planaddon.FieldAddonID] = struct{}{}
}

// AddonCleared reports if the "addon" edge to the Addon entity was cleared.
func (m *PlanAddonMutation) AddonCleared() bool {
	return m.clearedaddon
}

// AddonIDs returns the "addon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddonID instead. It exists only for internal usage by the builders.
func (m *PlanAddonMutation) AddonIDs() (ids []string) {
	if id := m.addon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddon resets all changes to the "addon" edge.
func (m *PlanAddonMutation) ResetAddon() {
	m.addon = nil
	m.clearedaddon = false
}

// Where appends a list predicates to the PlanAddonMutation builder.
func (m *PlanAddonMutation) Where(ps ...predicate.PlanAddon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanAddonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanAddonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlanAddon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanAddonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanAddonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlanAddon).
func (m *PlanAddonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanAddonMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, planaddon.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, planaddon.FieldMetadata)
	}
	if m.annotations != nil {
		fields = append(fields, planaddon.FieldAnnotations)
	}
	if m.created_at != nil {
		fields = append(fields, planaddon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, planaddon.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, planaddon.FieldDeletedAt)
	}
	if m.plan != nil {
		fields = append(fields, planaddon.FieldPlanID)
	}
	if m.addon != nil {
		fields = append(fields, planaddon.FieldAddonID)
	}
	if m.from_plan_phase != nil {
		fields = append(fields, planaddon.FieldFromPlanPhase)
	}
	if m.max_quantity != nil {
		fields = append(fields, planaddon.FieldMaxQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanAddonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planaddon.FieldNamespace:
		return m.Namespace()
	case planaddon.FieldMetadata:
		return m.Metadata()
	case planaddon.FieldAnnotations:
		return m.Annotations()
	case planaddon.FieldCreatedAt:
		return m.CreatedAt()
	case planaddon.FieldUpdatedAt:
		return m.UpdatedAt()
	case planaddon.FieldDeletedAt:
		return m.DeletedAt()
	case planaddon.FieldPlanID:
		return m.PlanID()
	case planaddon.FieldAddonID:
		return m.AddonID()
	case planaddon.FieldFromPlanPhase:
		return m.FromPlanPhase()
	case planaddon.FieldMaxQuantity:
		return m.MaxQuantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanAddonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case planaddon.FieldNamespace:
		return m.OldNamespace(ctx)
	case planaddon.FieldMetadata:
		return m.OldMetadata(ctx)
	case planaddon.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case planaddon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case planaddon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case planaddon.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case planaddon.FieldPlanID:
		return m.OldPlanID(ctx)
	case planaddon.FieldAddonID:
		return m.OldAddonID(ctx)
	case planaddon.FieldFromPlanPhase:
		return m.OldFromPlanPhase(ctx)
	case planaddon.FieldMaxQuantity:
		return m.OldMaxQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown PlanAddon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanAddonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planaddon.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case planaddon.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case planaddon.FieldAnnotations:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case planaddon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case planaddon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case planaddon.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case planaddon.FieldPlanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case planaddon.FieldAddonID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddonID(v)
		return nil
	case planaddon.FieldFromPlanPhase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromPlanPhase(v)
		return nil
	case planaddon.FieldMaxQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PlanAddon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanAddonMutation) AddedFields() []string {
	var fields []string
	if m.addmax_quantity != nil {
		fields = append(fields, planaddon.FieldMaxQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanAddonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case planaddon.FieldMaxQuantity:
		return m.AddedMaxQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanAddonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case planaddon.FieldMaxQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PlanAddon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanAddonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(planaddon.FieldMetadata) {
		fields = append(fields, planaddon.FieldMetadata)
	}
	if m.FieldCleared(planaddon.FieldAnnotations) {
		fields = append(fields, planaddon.FieldAnnotations)
	}
	if m.FieldCleared(planaddon.FieldDeletedAt) {
		fields = append(fields, planaddon.FieldDeletedAt)
	}
	if m.FieldCleared(planaddon.FieldMaxQuantity) {
		fields = append(fields, planaddon.FieldMaxQuantity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanAddonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanAddonMutation) ClearField(name string) error {
	switch name {
	case planaddon.FieldMetadata:
		m.ClearMetadata()
		return nil
	case planaddon.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case planaddon.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case planaddon.FieldMaxQuantity:
		m.ClearMaxQuantity()
		return nil
	}
	return fmt.Errorf("unknown PlanAddon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanAddonMutation) ResetField(name string) error {
	switch name {
	case planaddon.FieldNamespace:
		m.ResetNamespace()
		return nil
	case planaddon.FieldMetadata:
		m.ResetMetadata()
		return nil
	case planaddon.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case planaddon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case planaddon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case planaddon.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case planaddon.FieldPlanID:
		m.ResetPlanID()
		return nil
	case planaddon.FieldAddonID:
		m.ResetAddonID()
		return nil
	case planaddon.FieldFromPlanPhase:
		m.ResetFromPlanPhase()
		return nil
	case planaddon.FieldMaxQuantity:
		m.ResetMaxQuantity()
		return nil
	}
	return fmt.Errorf("unknown PlanAddon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanAddonMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.plan != nil {
		edges = append(edges, planaddon.EdgePlan)
	}
	if m.addon != nil {
		edges = append(edges, planaddon.EdgeAddon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanAddonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case planaddon.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case planaddon.EdgeAddon:
		if id := m.addon; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanAddonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanAddonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanAddonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplan {
		edges = append(edges, planaddon.EdgePlan)
	}
	if m.clearedaddon {
		edges = append(edges, planaddon.EdgeAddon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanAddonMutation) EdgeCleared(name string) bool {
	switch name {
	case planaddon.EdgePlan:
		return m.clearedplan
	case planaddon.EdgeAddon:
		return m.clearedaddon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanAddonMutation) ClearEdge(name string) error {
	switch name {
	case planaddon.EdgePlan:
		m.ClearPlan()
		return nil
	case planaddon.EdgeAddon:
		m.ClearAddon()
		return nil
	}
	return fmt.Errorf("unknown PlanAddon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanAddonMutation) ResetEdge(name string) error {
	switch name {
	case planaddon.EdgePlan:
		m.ResetPlan()
		return nil
	case planaddon.EdgeAddon:
		m.ResetAddon()
		return nil
	}
	return fmt.Errorf("unknown PlanAddon edge %s", name)
}

// PlanPhaseMutation represents an operation that mutates the PlanPhase nodes in the graph.
type PlanPhaseMutation struct {
	config
	op               Op
	typ              string
	id               *string
	namespace        *string
	metadata         *map[string]string
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	name             *string
	description      *string
	key              *string
	index            *uint8
	addindex         *int8
	duration         *isodate.String
	clearedFields    map[string]struct{}
	plan             *string
	clearedplan      bool
	ratecards        map[string]struct{}
	removedratecards map[string]struct{}
	clearedratecards bool
	done             bool
	oldValue         func(context.Context) (*PlanPhase, error)
	predicates       []predicate.PlanPhase
}

var _ ent.Mutation = (*PlanPhaseMutation)(nil)

// planphaseOption allows management of the mutation configuration using functional options.
type planphaseOption func(*PlanPhaseMutation)

// newPlanPhaseMutation creates new mutation for the PlanPhase entity.
func newPlanPhaseMutation(c config, op Op, opts ...planphaseOption) *PlanPhaseMutation {
	m := &PlanPhaseMutation{
		config:        c,
		op:            op,
		typ:           TypePlanPhase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanPhaseID sets the ID field of the mutation.
func withPlanPhaseID(id string) planphaseOption {
	return func(m *PlanPhaseMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanPhase
		)
		m.oldValue = func(ctx context.Context) (*PlanPhase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanPhase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanPhase sets the old PlanPhase of the mutation.
func withPlanPhase(node *PlanPhase) planphaseOption {
	return func(m *PlanPhaseMutation) {
		m.oldValue = func(context.Context) (*PlanPhase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanPhaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanPhaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlanPhase entities.
func (m *PlanPhaseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanPhaseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanPhaseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanPhase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *PlanPhaseMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PlanPhaseMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PlanPhaseMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *PlanPhaseMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PlanPhaseMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PlanPhaseMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[planphase.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PlanPhaseMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[planphase.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PlanPhaseMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, planphase.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanPhaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanPhaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanPhaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanPhaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanPhaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanPhaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanPhaseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanPhaseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlanPhaseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[planphase.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlanPhaseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[planphase.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanPhaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, planphase.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PlanPhaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanPhaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanPhaseMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PlanPhaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanPhaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanPhaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[planphase.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanPhaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[planphase.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanPhaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, planphase.FieldDescription)
}

// SetKey sets the "key" field.
func (m *PlanPhaseMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PlanPhaseMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PlanPhaseMutation) ResetKey() {
	m.key = nil
}

// SetPlanID sets the "plan_id" field.
func (m *PlanPhaseMutation) SetPlanID(s string) {
	m.plan = &s
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *PlanPhaseMutation) PlanID() (r string, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldPlanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *PlanPhaseMutation) ResetPlanID() {
	m.plan = nil
}

// SetIndex sets the "index" field.
func (m *PlanPhaseMutation) SetIndex(u uint8) {
	m.index = &u
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *PlanPhaseMutation) Index() (r uint8, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldIndex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds u to the "index" field.
func (m *PlanPhaseMutation) AddIndex(u int8) {
	if m.addindex != nil {
		*m.addindex += u
	} else {
		m.addindex = &u
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *PlanPhaseMutation) AddedIndex() (r int8, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *PlanPhaseMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetDuration sets the "duration" field.
func (m *PlanPhaseMutation) SetDuration(i isodate.String) {
	m.duration = &i
}

// Duration returns the value of the "duration" field in the mutation.
func (m *PlanPhaseMutation) Duration() (r isodate.String, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the PlanPhase entity.
// If the PlanPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanPhaseMutation) OldDuration(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ClearDuration clears the value of the "duration" field.
func (m *PlanPhaseMutation) ClearDuration() {
	m.duration = nil
	m.clearedFields[planphase.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *PlanPhaseMutation) DurationCleared() bool {
	_, ok := m.clearedFields[planphase.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *PlanPhaseMutation) ResetDuration() {
	m.duration = nil
	delete(m.clearedFields, planphase.FieldDuration)
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *PlanPhaseMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[planphase.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *PlanPhaseMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *PlanPhaseMutation) PlanIDs() (ids []string) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *PlanPhaseMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// AddRatecardIDs adds the "ratecards" edge to the PlanRateCard entity by ids.
func (m *PlanPhaseMutation) AddRatecardIDs(ids ...string) {
	if m.ratecards == nil {
		m.ratecards = make(map[string]struct{})
	}
	for i := range ids {
		m.ratecards[ids[i]] = struct{}{}
	}
}

// ClearRatecards clears the "ratecards" edge to the PlanRateCard entity.
func (m *PlanPhaseMutation) ClearRatecards() {
	m.clearedratecards = true
}

// RatecardsCleared reports if the "ratecards" edge to the PlanRateCard entity was cleared.
func (m *PlanPhaseMutation) RatecardsCleared() bool {
	return m.clearedratecards
}

// RemoveRatecardIDs removes the "ratecards" edge to the PlanRateCard entity by IDs.
func (m *PlanPhaseMutation) RemoveRatecardIDs(ids ...string) {
	if m.removedratecards == nil {
		m.removedratecards = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ratecards, ids[i])
		m.removedratecards[ids[i]] = struct{}{}
	}
}

// RemovedRatecards returns the removed IDs of the "ratecards" edge to the PlanRateCard entity.
func (m *PlanPhaseMutation) RemovedRatecardsIDs() (ids []string) {
	for id := range m.removedratecards {
		ids = append(ids, id)
	}
	return
}

// RatecardsIDs returns the "ratecards" edge IDs in the mutation.
func (m *PlanPhaseMutation) RatecardsIDs() (ids []string) {
	for id := range m.ratecards {
		ids = append(ids, id)
	}
	return
}

// ResetRatecards resets all changes to the "ratecards" edge.
func (m *PlanPhaseMutation) ResetRatecards() {
	m.ratecards = nil
	m.clearedratecards = false
	m.removedratecards = nil
}

// Where appends a list predicates to the PlanPhaseMutation builder.
func (m *PlanPhaseMutation) Where(ps ...predicate.PlanPhase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanPhaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanPhaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlanPhase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanPhaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanPhaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlanPhase).
func (m *PlanPhaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanPhaseMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.namespace != nil {
		fields = append(fields, planphase.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, planphase.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, planphase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, planphase.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, planphase.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, planphase.FieldName)
	}
	if m.description != nil {
		fields = append(fields, planphase.FieldDescription)
	}
	if m.key != nil {
		fields = append(fields, planphase.FieldKey)
	}
	if m.plan != nil {
		fields = append(fields, planphase.FieldPlanID)
	}
	if m.index != nil {
		fields = append(fields, planphase.FieldIndex)
	}
	if m.duration != nil {
		fields = append(fields, planphase.FieldDuration)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanPhaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planphase.FieldNamespace:
		return m.Namespace()
	case planphase.FieldMetadata:
		return m.Metadata()
	case planphase.FieldCreatedAt:
		return m.CreatedAt()
	case planphase.FieldUpdatedAt:
		return m.UpdatedAt()
	case planphase.FieldDeletedAt:
		return m.DeletedAt()
	case planphase.FieldName:
		return m.Name()
	case planphase.FieldDescription:
		return m.Description()
	case planphase.FieldKey:
		return m.Key()
	case planphase.FieldPlanID:
		return m.PlanID()
	case planphase.FieldIndex:
		return m.Index()
	case planphase.FieldDuration:
		return m.Duration()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanPhaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case planphase.FieldNamespace:
		return m.OldNamespace(ctx)
	case planphase.FieldMetadata:
		return m.OldMetadata(ctx)
	case planphase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case planphase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case planphase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case planphase.FieldName:
		return m.OldName(ctx)
	case planphase.FieldDescription:
		return m.OldDescription(ctx)
	case planphase.FieldKey:
		return m.OldKey(ctx)
	case planphase.FieldPlanID:
		return m.OldPlanID(ctx)
	case planphase.FieldIndex:
		return m.OldIndex(ctx)
	case planphase.FieldDuration:
		return m.OldDuration(ctx)
	}
	return nil, fmt.Errorf("unknown PlanPhase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanPhaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planphase.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case planphase.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case planphase.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case planphase.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case planphase.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case planphase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case planphase.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case planphase.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case planphase.FieldPlanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case planphase.FieldIndex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case planphase.FieldDuration:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	}
	return fmt.Errorf("unknown PlanPhase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanPhaseMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, planphase.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanPhaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case planphase.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanPhaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case planphase.FieldIndex:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown PlanPhase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanPhaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(planphase.FieldMetadata) {
		fields = append(fields, planphase.FieldMetadata)
	}
	if m.FieldCleared(planphase.FieldDeletedAt) {
		fields = append(fields, planphase.FieldDeletedAt)
	}
	if m.FieldCleared(planphase.FieldDescription) {
		fields = append(fields, planphase.FieldDescription)
	}
	if m.FieldCleared(planphase.FieldDuration) {
		fields = append(fields, planphase.FieldDuration)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanPhaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanPhaseMutation) ClearField(name string) error {
	switch name {
	case planphase.FieldMetadata:
		m.ClearMetadata()
		return nil
	case planphase.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case planphase.FieldDescription:
		m.ClearDescription()
		return nil
	case planphase.FieldDuration:
		m.ClearDuration()
		return nil
	}
	return fmt.Errorf("unknown PlanPhase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanPhaseMutation) ResetField(name string) error {
	switch name {
	case planphase.FieldNamespace:
		m.ResetNamespace()
		return nil
	case planphase.FieldMetadata:
		m.ResetMetadata()
		return nil
	case planphase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case planphase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case planphase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case planphase.FieldName:
		m.ResetName()
		return nil
	case planphase.FieldDescription:
		m.ResetDescription()
		return nil
	case planphase.FieldKey:
		m.ResetKey()
		return nil
	case planphase.FieldPlanID:
		m.ResetPlanID()
		return nil
	case planphase.FieldIndex:
		m.ResetIndex()
		return nil
	case planphase.FieldDuration:
		m.ResetDuration()
		return nil
	}
	return fmt.Errorf("unknown PlanPhase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanPhaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.plan != nil {
		edges = append(edges, planphase.EdgePlan)
	}
	if m.ratecards != nil {
		edges = append(edges, planphase.EdgeRatecards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanPhaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case planphase.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case planphase.EdgeRatecards:
		ids := make([]ent.Value, 0, len(m.ratecards))
		for id := range m.ratecards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanPhaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedratecards != nil {
		edges = append(edges, planphase.EdgeRatecards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanPhaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case planphase.EdgeRatecards:
		ids := make([]ent.Value, 0, len(m.removedratecards))
		for id := range m.removedratecards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanPhaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplan {
		edges = append(edges, planphase.EdgePlan)
	}
	if m.clearedratecards {
		edges = append(edges, planphase.EdgeRatecards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanPhaseMutation) EdgeCleared(name string) bool {
	switch name {
	case planphase.EdgePlan:
		return m.clearedplan
	case planphase.EdgeRatecards:
		return m.clearedratecards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanPhaseMutation) ClearEdge(name string) error {
	switch name {
	case planphase.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown PlanPhase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanPhaseMutation) ResetEdge(name string) error {
	switch name {
	case planphase.EdgePlan:
		m.ResetPlan()
		return nil
	case planphase.EdgeRatecards:
		m.ResetRatecards()
		return nil
	}
	return fmt.Errorf("unknown PlanPhase edge %s", name)
}

// PlanRateCardMutation represents an operation that mutates the PlanRateCard nodes in the graph.
type PlanRateCardMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	namespace            *string
	metadata             *map[string]string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	description          *string
	key                  *string
	_type                *productcatalog.RateCardType
	feature_key          *string
	entitlement_template **productcatalog.EntitlementTemplate
	tax_config           **productcatalog.TaxConfig
	billing_cadence      *isodate.String
	price                **productcatalog.Price
	discounts            **productcatalog.Discounts
	clearedFields        map[string]struct{}
	phase                *string
	clearedphase         bool
	features             *string
	clearedfeatures      bool
	done                 bool
	oldValue             func(context.Context) (*PlanRateCard, error)
	predicates           []predicate.PlanRateCard
}

var _ ent.Mutation = (*PlanRateCardMutation)(nil)

// planratecardOption allows management of the mutation configuration using functional options.
type planratecardOption func(*PlanRateCardMutation)

// newPlanRateCardMutation creates new mutation for the PlanRateCard entity.
func newPlanRateCardMutation(c config, op Op, opts ...planratecardOption) *PlanRateCardMutation {
	m := &PlanRateCardMutation{
		config:        c,
		op:            op,
		typ:           TypePlanRateCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanRateCardID sets the ID field of the mutation.
func withPlanRateCardID(id string) planratecardOption {
	return func(m *PlanRateCardMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanRateCard
		)
		m.oldValue = func(ctx context.Context) (*PlanRateCard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanRateCard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanRateCard sets the old PlanRateCard of the mutation.
func withPlanRateCard(node *PlanRateCard) planratecardOption {
	return func(m *PlanRateCardMutation) {
		m.oldValue = func(context.Context) (*PlanRateCard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanRateCardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanRateCardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlanRateCard entities.
func (m *PlanRateCardMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanRateCardMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanRateCardMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanRateCard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *PlanRateCardMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PlanRateCardMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PlanRateCardMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *PlanRateCardMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PlanRateCardMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PlanRateCardMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[planratecard.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PlanRateCardMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PlanRateCardMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, planratecard.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanRateCardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanRateCardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanRateCardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanRateCardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanRateCardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanRateCardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanRateCardMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanRateCardMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlanRateCardMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[planratecard.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlanRateCardMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanRateCardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, planratecard.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PlanRateCardMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanRateCardMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanRateCardMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PlanRateCardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanRateCardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanRateCardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[planratecard.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanRateCardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanRateCardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, planratecard.FieldDescription)
}

// SetKey sets the "key" field.
func (m *PlanRateCardMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PlanRateCardMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PlanRateCardMutation) ResetKey() {
	m.key = nil
}

// SetType sets the "type" field.
func (m *PlanRateCardMutation) SetType(pct productcatalog.RateCardType) {
	m._type = &pct
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlanRateCardMutation) GetType() (r productcatalog.RateCardType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldType(ctx context.Context) (v productcatalog.RateCardType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PlanRateCardMutation) ResetType() {
	m._type = nil
}

// SetFeatureKey sets the "feature_key" field.
func (m *PlanRateCardMutation) SetFeatureKey(s string) {
	m.feature_key = &s
}

// FeatureKey returns the value of the "feature_key" field in the mutation.
func (m *PlanRateCardMutation) FeatureKey() (r string, exists bool) {
	v := m.feature_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureKey returns the old "feature_key" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldFeatureKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureKey: %w", err)
	}
	return oldValue.FeatureKey, nil
}

// ClearFeatureKey clears the value of the "feature_key" field.
func (m *PlanRateCardMutation) ClearFeatureKey() {
	m.feature_key = nil
	m.clearedFields[planratecard.FieldFeatureKey] = struct{}{}
}

// FeatureKeyCleared returns if the "feature_key" field was cleared in this mutation.
func (m *PlanRateCardMutation) FeatureKeyCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldFeatureKey]
	return ok
}

// ResetFeatureKey resets all changes to the "feature_key" field.
func (m *PlanRateCardMutation) ResetFeatureKey() {
	m.feature_key = nil
	delete(m.clearedFields, planratecard.FieldFeatureKey)
}

// SetEntitlementTemplate sets the "entitlement_template" field.
func (m *PlanRateCardMutation) SetEntitlementTemplate(pt *productcatalog.EntitlementTemplate) {
	m.entitlement_template = &pt
}

// EntitlementTemplate returns the value of the "entitlement_template" field in the mutation.
func (m *PlanRateCardMutation) EntitlementTemplate() (r *productcatalog.EntitlementTemplate, exists bool) {
	v := m.entitlement_template
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementTemplate returns the old "entitlement_template" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldEntitlementTemplate(ctx context.Context) (v *productcatalog.EntitlementTemplate, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementTemplate: %w", err)
	}
	return oldValue.EntitlementTemplate, nil
}

// ClearEntitlementTemplate clears the value of the "entitlement_template" field.
func (m *PlanRateCardMutation) ClearEntitlementTemplate() {
	m.entitlement_template = nil
	m.clearedFields[planratecard.FieldEntitlementTemplate] = struct{}{}
}

// EntitlementTemplateCleared returns if the "entitlement_template" field was cleared in this mutation.
func (m *PlanRateCardMutation) EntitlementTemplateCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldEntitlementTemplate]
	return ok
}

// ResetEntitlementTemplate resets all changes to the "entitlement_template" field.
func (m *PlanRateCardMutation) ResetEntitlementTemplate() {
	m.entitlement_template = nil
	delete(m.clearedFields, planratecard.FieldEntitlementTemplate)
}

// SetTaxConfig sets the "tax_config" field.
func (m *PlanRateCardMutation) SetTaxConfig(pc *productcatalog.TaxConfig) {
	m.tax_config = &pc
}

// TaxConfig returns the value of the "tax_config" field in the mutation.
func (m *PlanRateCardMutation) TaxConfig() (r *productcatalog.TaxConfig, exists bool) {
	v := m.tax_config
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxConfig returns the old "tax_config" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldTaxConfig(ctx context.Context) (v *productcatalog.TaxConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxConfig: %w", err)
	}
	return oldValue.TaxConfig, nil
}

// ClearTaxConfig clears the value of the "tax_config" field.
func (m *PlanRateCardMutation) ClearTaxConfig() {
	m.tax_config = nil
	m.clearedFields[planratecard.FieldTaxConfig] = struct{}{}
}

// TaxConfigCleared returns if the "tax_config" field was cleared in this mutation.
func (m *PlanRateCardMutation) TaxConfigCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldTaxConfig]
	return ok
}

// ResetTaxConfig resets all changes to the "tax_config" field.
func (m *PlanRateCardMutation) ResetTaxConfig() {
	m.tax_config = nil
	delete(m.clearedFields, planratecard.FieldTaxConfig)
}

// SetBillingCadence sets the "billing_cadence" field.
func (m *PlanRateCardMutation) SetBillingCadence(i isodate.String) {
	m.billing_cadence = &i
}

// BillingCadence returns the value of the "billing_cadence" field in the mutation.
func (m *PlanRateCardMutation) BillingCadence() (r isodate.String, exists bool) {
	v := m.billing_cadence
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingCadence returns the old "billing_cadence" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldBillingCadence(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingCadence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingCadence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingCadence: %w", err)
	}
	return oldValue.BillingCadence, nil
}

// ClearBillingCadence clears the value of the "billing_cadence" field.
func (m *PlanRateCardMutation) ClearBillingCadence() {
	m.billing_cadence = nil
	m.clearedFields[planratecard.FieldBillingCadence] = struct{}{}
}

// BillingCadenceCleared returns if the "billing_cadence" field was cleared in this mutation.
func (m *PlanRateCardMutation) BillingCadenceCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldBillingCadence]
	return ok
}

// ResetBillingCadence resets all changes to the "billing_cadence" field.
func (m *PlanRateCardMutation) ResetBillingCadence() {
	m.billing_cadence = nil
	delete(m.clearedFields, planratecard.FieldBillingCadence)
}

// SetPrice sets the "price" field.
func (m *PlanRateCardMutation) SetPrice(pr *productcatalog.Price) {
	m.price = &pr
}

// Price returns the value of the "price" field in the mutation.
func (m *PlanRateCardMutation) Price() (r *productcatalog.Price, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldPrice(ctx context.Context) (v *productcatalog.Price, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *PlanRateCardMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[planratecard.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *PlanRateCardMutation) PriceCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *PlanRateCardMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, planratecard.FieldPrice)
}

// SetDiscounts sets the "discounts" field.
func (m *PlanRateCardMutation) SetDiscounts(pr *productcatalog.Discounts) {
	m.discounts = &pr
}

// Discounts returns the value of the "discounts" field in the mutation.
func (m *PlanRateCardMutation) Discounts() (r *productcatalog.Discounts, exists bool) {
	v := m.discounts
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscounts returns the old "discounts" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldDiscounts(ctx context.Context) (v *productcatalog.Discounts, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscounts: %w", err)
	}
	return oldValue.Discounts, nil
}

// ClearDiscounts clears the value of the "discounts" field.
func (m *PlanRateCardMutation) ClearDiscounts() {
	m.discounts = nil
	m.clearedFields[planratecard.FieldDiscounts] = struct{}{}
}

// DiscountsCleared returns if the "discounts" field was cleared in this mutation.
func (m *PlanRateCardMutation) DiscountsCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldDiscounts]
	return ok
}

// ResetDiscounts resets all changes to the "discounts" field.
func (m *PlanRateCardMutation) ResetDiscounts() {
	m.discounts = nil
	delete(m.clearedFields, planratecard.FieldDiscounts)
}

// SetPhaseID sets the "phase_id" field.
func (m *PlanRateCardMutation) SetPhaseID(s string) {
	m.phase = &s
}

// PhaseID returns the value of the "phase_id" field in the mutation.
func (m *PlanRateCardMutation) PhaseID() (r string, exists bool) {
	v := m.phase
	if v == nil {
		return
	}
	return *v, true
}

// OldPhaseID returns the old "phase_id" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldPhaseID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhaseID: %w", err)
	}
	return oldValue.PhaseID, nil
}

// ResetPhaseID resets all changes to the "phase_id" field.
func (m *PlanRateCardMutation) ResetPhaseID() {
	m.phase = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *PlanRateCardMutation) SetFeatureID(s string) {
	m.features = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *PlanRateCardMutation) FeatureID() (r string, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the PlanRateCard entity.
// If the PlanRateCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanRateCardMutation) OldFeatureID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ClearFeatureID clears the value of the "feature_id" field.
func (m *PlanRateCardMutation) ClearFeatureID() {
	m.features = nil
	m.clearedFields[planratecard.FieldFeatureID] = struct{}{}
}

// FeatureIDCleared returns if the "feature_id" field was cleared in this mutation.
func (m *PlanRateCardMutation) FeatureIDCleared() bool {
	_, ok := m.clearedFields[planratecard.FieldFeatureID]
	return ok
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *PlanRateCardMutation) ResetFeatureID() {
	m.features = nil
	delete(m.clearedFields, planratecard.FieldFeatureID)
}

// ClearPhase clears the "phase" edge to the PlanPhase entity.
func (m *PlanRateCardMutation) ClearPhase() {
	m.clearedphase = true
	m.clearedFields[planratecard.FieldPhaseID] = struct{}{}
}

// PhaseCleared reports if the "phase" edge to the PlanPhase entity was cleared.
func (m *PlanRateCardMutation) PhaseCleared() bool {
	return m.clearedphase
}

// PhaseIDs returns the "phase" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PhaseID instead. It exists only for internal usage by the builders.
func (m *PlanRateCardMutation) PhaseIDs() (ids []string) {
	if id := m.phase; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPhase resets all changes to the "phase" edge.
func (m *PlanRateCardMutation) ResetPhase() {
	m.phase = nil
	m.clearedphase = false
}

// SetFeaturesID sets the "features" edge to the Feature entity by id.
func (m *PlanRateCardMutation) SetFeaturesID(id string) {
	m.features = &id
}

// ClearFeatures clears the "features" edge to the Feature entity.
func (m *PlanRateCardMutation) ClearFeatures() {
	m.clearedfeatures = true
	m.clearedFields[planratecard.FieldFeatureID] = struct{}{}
}

// FeaturesCleared reports if the "features" edge to the Feature entity was cleared.
func (m *PlanRateCardMutation) FeaturesCleared() bool {
	return m.FeatureIDCleared() || m.clearedfeatures
}

// FeaturesID returns the "features" edge ID in the mutation.
func (m *PlanRateCardMutation) FeaturesID() (id string, exists bool) {
	if m.features != nil {
		return *m.features, true
	}
	return
}

// FeaturesIDs returns the "features" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeaturesID instead. It exists only for internal usage by the builders.
func (m *PlanRateCardMutation) FeaturesIDs() (ids []string) {
	if id := m.features; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatures resets all changes to the "features" edge.
func (m *PlanRateCardMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
}

// Where appends a list predicates to the PlanRateCardMutation builder.
func (m *PlanRateCardMutation) Where(ps ...predicate.PlanRateCard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanRateCardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanRateCardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlanRateCard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanRateCardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanRateCardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlanRateCard).
func (m *PlanRateCardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanRateCardMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.namespace != nil {
		fields = append(fields, planratecard.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, planratecard.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, planratecard.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, planratecard.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, planratecard.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, planratecard.FieldName)
	}
	if m.description != nil {
		fields = append(fields, planratecard.FieldDescription)
	}
	if m.key != nil {
		fields = append(fields, planratecard.FieldKey)
	}
	if m._type != nil {
		fields = append(fields, planratecard.FieldType)
	}
	if m.feature_key != nil {
		fields = append(fields, planratecard.FieldFeatureKey)
	}
	if m.entitlement_template != nil {
		fields = append(fields, planratecard.FieldEntitlementTemplate)
	}
	if m.tax_config != nil {
		fields = append(fields, planratecard.FieldTaxConfig)
	}
	if m.billing_cadence != nil {
		fields = append(fields, planratecard.FieldBillingCadence)
	}
	if m.price != nil {
		fields = append(fields, planratecard.FieldPrice)
	}
	if m.discounts != nil {
		fields = append(fields, planratecard.FieldDiscounts)
	}
	if m.phase != nil {
		fields = append(fields, planratecard.FieldPhaseID)
	}
	if m.features != nil {
		fields = append(fields, planratecard.FieldFeatureID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanRateCardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planratecard.FieldNamespace:
		return m.Namespace()
	case planratecard.FieldMetadata:
		return m.Metadata()
	case planratecard.FieldCreatedAt:
		return m.CreatedAt()
	case planratecard.FieldUpdatedAt:
		return m.UpdatedAt()
	case planratecard.FieldDeletedAt:
		return m.DeletedAt()
	case planratecard.FieldName:
		return m.Name()
	case planratecard.FieldDescription:
		return m.Description()
	case planratecard.FieldKey:
		return m.Key()
	case planratecard.FieldType:
		return m.GetType()
	case planratecard.FieldFeatureKey:
		return m.FeatureKey()
	case planratecard.FieldEntitlementTemplate:
		return m.EntitlementTemplate()
	case planratecard.FieldTaxConfig:
		return m.TaxConfig()
	case planratecard.FieldBillingCadence:
		return m.BillingCadence()
	case planratecard.FieldPrice:
		return m.Price()
	case planratecard.FieldDiscounts:
		return m.Discounts()
	case planratecard.FieldPhaseID:
		return m.PhaseID()
	case planratecard.FieldFeatureID:
		return m.FeatureID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanRateCardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case planratecard.FieldNamespace:
		return m.OldNamespace(ctx)
	case planratecard.FieldMetadata:
		return m.OldMetadata(ctx)
	case planratecard.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case planratecard.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case planratecard.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case planratecard.FieldName:
		return m.OldName(ctx)
	case planratecard.FieldDescription:
		return m.OldDescription(ctx)
	case planratecard.FieldKey:
		return m.OldKey(ctx)
	case planratecard.FieldType:
		return m.OldType(ctx)
	case planratecard.FieldFeatureKey:
		return m.OldFeatureKey(ctx)
	case planratecard.FieldEntitlementTemplate:
		return m.OldEntitlementTemplate(ctx)
	case planratecard.FieldTaxConfig:
		return m.OldTaxConfig(ctx)
	case planratecard.FieldBillingCadence:
		return m.OldBillingCadence(ctx)
	case planratecard.FieldPrice:
		return m.OldPrice(ctx)
	case planratecard.FieldDiscounts:
		return m.OldDiscounts(ctx)
	case planratecard.FieldPhaseID:
		return m.OldPhaseID(ctx)
	case planratecard.FieldFeatureID:
		return m.OldFeatureID(ctx)
	}
	return nil, fmt.Errorf("unknown PlanRateCard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanRateCardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planratecard.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case planratecard.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case planratecard.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case planratecard.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case planratecard.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case planratecard.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case planratecard.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case planratecard.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case planratecard.FieldType:
		v, ok := value.(productcatalog.RateCardType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case planratecard.FieldFeatureKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureKey(v)
		return nil
	case planratecard.FieldEntitlementTemplate:
		v, ok := value.(*productcatalog.EntitlementTemplate)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementTemplate(v)
		return nil
	case planratecard.FieldTaxConfig:
		v, ok := value.(*productcatalog.TaxConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxConfig(v)
		return nil
	case planratecard.FieldBillingCadence:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingCadence(v)
		return nil
	case planratecard.FieldPrice:
		v, ok := value.(*productcatalog.Price)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case planratecard.FieldDiscounts:
		v, ok := value.(*productcatalog.Discounts)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscounts(v)
		return nil
	case planratecard.FieldPhaseID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhaseID(v)
		return nil
	case planratecard.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	}
	return fmt.Errorf("unknown PlanRateCard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanRateCardMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanRateCardMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanRateCardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlanRateCard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanRateCardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(planratecard.FieldMetadata) {
		fields = append(fields, planratecard.FieldMetadata)
	}
	if m.FieldCleared(planratecard.FieldDeletedAt) {
		fields = append(fields, planratecard.FieldDeletedAt)
	}
	if m.FieldCleared(planratecard.FieldDescription) {
		fields = append(fields, planratecard.FieldDescription)
	}
	if m.FieldCleared(planratecard.FieldFeatureKey) {
		fields = append(fields, planratecard.FieldFeatureKey)
	}
	if m.FieldCleared(planratecard.FieldEntitlementTemplate) {
		fields = append(fields, planratecard.FieldEntitlementTemplate)
	}
	if m.FieldCleared(planratecard.FieldTaxConfig) {
		fields = append(fields, planratecard.FieldTaxConfig)
	}
	if m.FieldCleared(planratecard.FieldBillingCadence) {
		fields = append(fields, planratecard.FieldBillingCadence)
	}
	if m.FieldCleared(planratecard.FieldPrice) {
		fields = append(fields, planratecard.FieldPrice)
	}
	if m.FieldCleared(planratecard.FieldDiscounts) {
		fields = append(fields, planratecard.FieldDiscounts)
	}
	if m.FieldCleared(planratecard.FieldFeatureID) {
		fields = append(fields, planratecard.FieldFeatureID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanRateCardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanRateCardMutation) ClearField(name string) error {
	switch name {
	case planratecard.FieldMetadata:
		m.ClearMetadata()
		return nil
	case planratecard.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case planratecard.FieldDescription:
		m.ClearDescription()
		return nil
	case planratecard.FieldFeatureKey:
		m.ClearFeatureKey()
		return nil
	case planratecard.FieldEntitlementTemplate:
		m.ClearEntitlementTemplate()
		return nil
	case planratecard.FieldTaxConfig:
		m.ClearTaxConfig()
		return nil
	case planratecard.FieldBillingCadence:
		m.ClearBillingCadence()
		return nil
	case planratecard.FieldPrice:
		m.ClearPrice()
		return nil
	case planratecard.FieldDiscounts:
		m.ClearDiscounts()
		return nil
	case planratecard.FieldFeatureID:
		m.ClearFeatureID()
		return nil
	}
	return fmt.Errorf("unknown PlanRateCard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanRateCardMutation) ResetField(name string) error {
	switch name {
	case planratecard.FieldNamespace:
		m.ResetNamespace()
		return nil
	case planratecard.FieldMetadata:
		m.ResetMetadata()
		return nil
	case planratecard.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case planratecard.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case planratecard.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case planratecard.FieldName:
		m.ResetName()
		return nil
	case planratecard.FieldDescription:
		m.ResetDescription()
		return nil
	case planratecard.FieldKey:
		m.ResetKey()
		return nil
	case planratecard.FieldType:
		m.ResetType()
		return nil
	case planratecard.FieldFeatureKey:
		m.ResetFeatureKey()
		return nil
	case planratecard.FieldEntitlementTemplate:
		m.ResetEntitlementTemplate()
		return nil
	case planratecard.FieldTaxConfig:
		m.ResetTaxConfig()
		return nil
	case planratecard.FieldBillingCadence:
		m.ResetBillingCadence()
		return nil
	case planratecard.FieldPrice:
		m.ResetPrice()
		return nil
	case planratecard.FieldDiscounts:
		m.ResetDiscounts()
		return nil
	case planratecard.FieldPhaseID:
		m.ResetPhaseID()
		return nil
	case planratecard.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	}
	return fmt.Errorf("unknown PlanRateCard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanRateCardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.phase != nil {
		edges = append(edges, planratecard.EdgePhase)
	}
	if m.features != nil {
		edges = append(edges, planratecard.EdgeFeatures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanRateCardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case planratecard.EdgePhase:
		if id := m.phase; id != nil {
			return []ent.Value{*id}
		}
	case planratecard.EdgeFeatures:
		if id := m.features; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanRateCardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanRateCardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanRateCardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedphase {
		edges = append(edges, planratecard.EdgePhase)
	}
	if m.clearedfeatures {
		edges = append(edges, planratecard.EdgeFeatures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanRateCardMutation) EdgeCleared(name string) bool {
	switch name {
	case planratecard.EdgePhase:
		return m.clearedphase
	case planratecard.EdgeFeatures:
		return m.clearedfeatures
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanRateCardMutation) ClearEdge(name string) error {
	switch name {
	case planratecard.EdgePhase:
		m.ClearPhase()
		return nil
	case planratecard.EdgeFeatures:
		m.ClearFeatures()
		return nil
	}
	return fmt.Errorf("unknown PlanRateCard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanRateCardMutation) ResetEdge(name string) error {
	switch name {
	case planratecard.EdgePhase:
		m.ResetPhase()
		return nil
	case planratecard.EdgeFeatures:
		m.ResetFeatures()
		return nil
	}
	return fmt.Errorf("unknown PlanRateCard edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	namespace            *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	metadata             *map[string]string
	active_from          *time.Time
	active_to            *time.Time
	billables_must_align *bool
	name                 *string
	description          *string
	currency             *currencyx.Code
	clearedFields        map[string]struct{}
	plan                 *string
	clearedplan          bool
	customer             *string
	clearedcustomer      bool
	phases               map[string]struct{}
	removedphases        map[string]struct{}
	clearedphases        bool
	billing_lines        map[string]struct{}
	removedbilling_lines map[string]struct{}
	clearedbilling_lines bool
	addons               map[string]struct{}
	removedaddons        map[string]struct{}
	clearedaddons        bool
	done                 bool
	oldValue             func(context.Context) (*Subscription, error)
	predicates           []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id string) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscription entities.
func (m *SubscriptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscriptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscription.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscriptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscription.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *SubscriptionMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SubscriptionMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SubscriptionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[subscription.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SubscriptionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[subscription.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SubscriptionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, subscription.FieldMetadata)
}

// SetActiveFrom sets the "active_from" field.
func (m *SubscriptionMutation) SetActiveFrom(t time.Time) {
	m.active_from = &t
}

// ActiveFrom returns the value of the "active_from" field in the mutation.
func (m *SubscriptionMutation) ActiveFrom() (r time.Time, exists bool) {
	v := m.active_from
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveFrom returns the old "active_from" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldActiveFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveFrom: %w", err)
	}
	return oldValue.ActiveFrom, nil
}

// ResetActiveFrom resets all changes to the "active_from" field.
func (m *SubscriptionMutation) ResetActiveFrom() {
	m.active_from = nil
}

// SetActiveTo sets the "active_to" field.
func (m *SubscriptionMutation) SetActiveTo(t time.Time) {
	m.active_to = &t
}

// ActiveTo returns the value of the "active_to" field in the mutation.
func (m *SubscriptionMutation) ActiveTo() (r time.Time, exists bool) {
	v := m.active_to
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveTo returns the old "active_to" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldActiveTo(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveTo: %w", err)
	}
	return oldValue.ActiveTo, nil
}

// ClearActiveTo clears the value of the "active_to" field.
func (m *SubscriptionMutation) ClearActiveTo() {
	m.active_to = nil
	m.clearedFields[subscription.FieldActiveTo] = struct{}{}
}

// ActiveToCleared returns if the "active_to" field was cleared in this mutation.
func (m *SubscriptionMutation) ActiveToCleared() bool {
	_, ok := m.clearedFields[subscription.FieldActiveTo]
	return ok
}

// ResetActiveTo resets all changes to the "active_to" field.
func (m *SubscriptionMutation) ResetActiveTo() {
	m.active_to = nil
	delete(m.clearedFields, subscription.FieldActiveTo)
}

// SetBillablesMustAlign sets the "billables_must_align" field.
func (m *SubscriptionMutation) SetBillablesMustAlign(b bool) {
	m.billables_must_align = &b
}

// BillablesMustAlign returns the value of the "billables_must_align" field in the mutation.
func (m *SubscriptionMutation) BillablesMustAlign() (r bool, exists bool) {
	v := m.billables_must_align
	if v == nil {
		return
	}
	return *v, true
}

// OldBillablesMustAlign returns the old "billables_must_align" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldBillablesMustAlign(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillablesMustAlign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillablesMustAlign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillablesMustAlign: %w", err)
	}
	return oldValue.BillablesMustAlign, nil
}

// ResetBillablesMustAlign resets all changes to the "billables_must_align" field.
func (m *SubscriptionMutation) ResetBillablesMustAlign() {
	m.billables_must_align = nil
}

// SetName sets the "name" field.
func (m *SubscriptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubscriptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubscriptionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SubscriptionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubscriptionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubscriptionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subscription.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubscriptionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubscriptionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subscription.FieldDescription)
}

// SetPlanID sets the "plan_id" field.
func (m *SubscriptionMutation) SetPlanID(s string) {
	m.plan = &s
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *SubscriptionMutation) PlanID() (r string, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldPlanID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *SubscriptionMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[subscription.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *SubscriptionMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *SubscriptionMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, subscription.FieldPlanID)
}

// SetCustomerID sets the "customer_id" field.
func (m *SubscriptionMutation) SetCustomerID(s string) {
	m.customer = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *SubscriptionMutation) CustomerID() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *SubscriptionMutation) ResetCustomerID() {
	m.customer = nil
}

// SetCurrency sets the "currency" field.
func (m *SubscriptionMutation) SetCurrency(c currencyx.Code) {
	m.currency = &c
}

// Currency returns the value of the "currency" field in the mutation.
func (m *SubscriptionMutation) Currency() (r currencyx.Code, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCurrency(ctx context.Context) (v currencyx.Code, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *SubscriptionMutation) ResetCurrency() {
	m.currency = nil
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *SubscriptionMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[subscription.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *SubscriptionMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) PlanIDs() (ids []string) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *SubscriptionMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *SubscriptionMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[subscription.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *SubscriptionMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) CustomerIDs() (ids []string) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *SubscriptionMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// AddPhaseIDs adds the "phases" edge to the SubscriptionPhase entity by ids.
func (m *SubscriptionMutation) AddPhaseIDs(ids ...string) {
	if m.phases == nil {
		m.phases = make(map[string]struct{})
	}
	for i := range ids {
		m.phases[ids[i]] = struct{}{}
	}
}

// ClearPhases clears the "phases" edge to the SubscriptionPhase entity.
func (m *SubscriptionMutation) ClearPhases() {
	m.clearedphases = true
}

// PhasesCleared reports if the "phases" edge to the SubscriptionPhase entity was cleared.
func (m *SubscriptionMutation) PhasesCleared() bool {
	return m.clearedphases
}

// RemovePhaseIDs removes the "phases" edge to the SubscriptionPhase entity by IDs.
func (m *SubscriptionMutation) RemovePhaseIDs(ids ...string) {
	if m.removedphases == nil {
		m.removedphases = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.phases, ids[i])
		m.removedphases[ids[i]] = struct{}{}
	}
}

// RemovedPhases returns the removed IDs of the "phases" edge to the SubscriptionPhase entity.
func (m *SubscriptionMutation) RemovedPhasesIDs() (ids []string) {
	for id := range m.removedphases {
		ids = append(ids, id)
	}
	return
}

// PhasesIDs returns the "phases" edge IDs in the mutation.
func (m *SubscriptionMutation) PhasesIDs() (ids []string) {
	for id := range m.phases {
		ids = append(ids, id)
	}
	return
}

// ResetPhases resets all changes to the "phases" edge.
func (m *SubscriptionMutation) ResetPhases() {
	m.phases = nil
	m.clearedphases = false
	m.removedphases = nil
}

// AddBillingLineIDs adds the "billing_lines" edge to the BillingInvoiceLine entity by ids.
func (m *SubscriptionMutation) AddBillingLineIDs(ids ...string) {
	if m.billing_lines == nil {
		m.billing_lines = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_lines[ids[i]] = struct{}{}
	}
}

// ClearBillingLines clears the "billing_lines" edge to the BillingInvoiceLine entity.
func (m *SubscriptionMutation) ClearBillingLines() {
	m.clearedbilling_lines = true
}

// BillingLinesCleared reports if the "billing_lines" edge to the BillingInvoiceLine entity was cleared.
func (m *SubscriptionMutation) BillingLinesCleared() bool {
	return m.clearedbilling_lines
}

// RemoveBillingLineIDs removes the "billing_lines" edge to the BillingInvoiceLine entity by IDs.
func (m *SubscriptionMutation) RemoveBillingLineIDs(ids ...string) {
	if m.removedbilling_lines == nil {
		m.removedbilling_lines = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_lines, ids[i])
		m.removedbilling_lines[ids[i]] = struct{}{}
	}
}

// RemovedBillingLines returns the removed IDs of the "billing_lines" edge to the BillingInvoiceLine entity.
func (m *SubscriptionMutation) RemovedBillingLinesIDs() (ids []string) {
	for id := range m.removedbilling_lines {
		ids = append(ids, id)
	}
	return
}

// BillingLinesIDs returns the "billing_lines" edge IDs in the mutation.
func (m *SubscriptionMutation) BillingLinesIDs() (ids []string) {
	for id := range m.billing_lines {
		ids = append(ids, id)
	}
	return
}

// ResetBillingLines resets all changes to the "billing_lines" edge.
func (m *SubscriptionMutation) ResetBillingLines() {
	m.billing_lines = nil
	m.clearedbilling_lines = false
	m.removedbilling_lines = nil
}

// AddAddonIDs adds the "addons" edge to the SubscriptionAddon entity by ids.
func (m *SubscriptionMutation) AddAddonIDs(ids ...string) {
	if m.addons == nil {
		m.addons = make(map[string]struct{})
	}
	for i := range ids {
		m.addons[ids[i]] = struct{}{}
	}
}

// ClearAddons clears the "addons" edge to the SubscriptionAddon entity.
func (m *SubscriptionMutation) ClearAddons() {
	m.clearedaddons = true
}

// AddonsCleared reports if the "addons" edge to the SubscriptionAddon entity was cleared.
func (m *SubscriptionMutation) AddonsCleared() bool {
	return m.clearedaddons
}

// RemoveAddonIDs removes the "addons" edge to the SubscriptionAddon entity by IDs.
func (m *SubscriptionMutation) RemoveAddonIDs(ids ...string) {
	if m.removedaddons == nil {
		m.removedaddons = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.addons, ids[i])
		m.removedaddons[ids[i]] = struct{}{}
	}
}

// RemovedAddons returns the removed IDs of the "addons" edge to the SubscriptionAddon entity.
func (m *SubscriptionMutation) RemovedAddonsIDs() (ids []string) {
	for id := range m.removedaddons {
		ids = append(ids, id)
	}
	return
}

// AddonsIDs returns the "addons" edge IDs in the mutation.
func (m *SubscriptionMutation) AddonsIDs() (ids []string) {
	for id := range m.addons {
		ids = append(ids, id)
	}
	return
}

// ResetAddons resets all changes to the "addons" edge.
func (m *SubscriptionMutation) ResetAddons() {
	m.addons = nil
	m.clearedaddons = false
	m.removedaddons = nil
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.namespace != nil {
		fields = append(fields, subscription.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, subscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscription.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscription.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, subscription.FieldMetadata)
	}
	if m.active_from != nil {
		fields = append(fields, subscription.FieldActiveFrom)
	}
	if m.active_to != nil {
		fields = append(fields, subscription.FieldActiveTo)
	}
	if m.billables_must_align != nil {
		fields = append(fields, subscription.FieldBillablesMustAlign)
	}
	if m.name != nil {
		fields = append(fields, subscription.FieldName)
	}
	if m.description != nil {
		fields = append(fields, subscription.FieldDescription)
	}
	if m.plan != nil {
		fields = append(fields, subscription.FieldPlanID)
	}
	if m.customer != nil {
		fields = append(fields, subscription.FieldCustomerID)
	}
	if m.currency != nil {
		fields = append(fields, subscription.FieldCurrency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldNamespace:
		return m.Namespace()
	case subscription.FieldCreatedAt:
		return m.CreatedAt()
	case subscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscription.FieldDeletedAt:
		return m.DeletedAt()
	case subscription.FieldMetadata:
		return m.Metadata()
	case subscription.FieldActiveFrom:
		return m.ActiveFrom()
	case subscription.FieldActiveTo:
		return m.ActiveTo()
	case subscription.FieldBillablesMustAlign:
		return m.BillablesMustAlign()
	case subscription.FieldName:
		return m.Name()
	case subscription.FieldDescription:
		return m.Description()
	case subscription.FieldPlanID:
		return m.PlanID()
	case subscription.FieldCustomerID:
		return m.CustomerID()
	case subscription.FieldCurrency:
		return m.Currency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscription.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscription.FieldMetadata:
		return m.OldMetadata(ctx)
	case subscription.FieldActiveFrom:
		return m.OldActiveFrom(ctx)
	case subscription.FieldActiveTo:
		return m.OldActiveTo(ctx)
	case subscription.FieldBillablesMustAlign:
		return m.OldBillablesMustAlign(ctx)
	case subscription.FieldName:
		return m.OldName(ctx)
	case subscription.FieldDescription:
		return m.OldDescription(ctx)
	case subscription.FieldPlanID:
		return m.OldPlanID(ctx)
	case subscription.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case subscription.FieldCurrency:
		return m.OldCurrency(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscription.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscription.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case subscription.FieldActiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveFrom(v)
		return nil
	case subscription.FieldActiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveTo(v)
		return nil
	case subscription.FieldBillablesMustAlign:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillablesMustAlign(v)
		return nil
	case subscription.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subscription.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subscription.FieldPlanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case subscription.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case subscription.FieldCurrency:
		v, ok := value.(currencyx.Code)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldDeletedAt) {
		fields = append(fields, subscription.FieldDeletedAt)
	}
	if m.FieldCleared(subscription.FieldMetadata) {
		fields = append(fields, subscription.FieldMetadata)
	}
	if m.FieldCleared(subscription.FieldActiveTo) {
		fields = append(fields, subscription.FieldActiveTo)
	}
	if m.FieldCleared(subscription.FieldDescription) {
		fields = append(fields, subscription.FieldDescription)
	}
	if m.FieldCleared(subscription.FieldPlanID) {
		fields = append(fields, subscription.FieldPlanID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscription.FieldMetadata:
		m.ClearMetadata()
		return nil
	case subscription.FieldActiveTo:
		m.ClearActiveTo()
		return nil
	case subscription.FieldDescription:
		m.ClearDescription()
		return nil
	case subscription.FieldPlanID:
		m.ClearPlanID()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscription.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscription.FieldMetadata:
		m.ResetMetadata()
		return nil
	case subscription.FieldActiveFrom:
		m.ResetActiveFrom()
		return nil
	case subscription.FieldActiveTo:
		m.ResetActiveTo()
		return nil
	case subscription.FieldBillablesMustAlign:
		m.ResetBillablesMustAlign()
		return nil
	case subscription.FieldName:
		m.ResetName()
		return nil
	case subscription.FieldDescription:
		m.ResetDescription()
		return nil
	case subscription.FieldPlanID:
		m.ResetPlanID()
		return nil
	case subscription.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case subscription.FieldCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.plan != nil {
		edges = append(edges, subscription.EdgePlan)
	}
	if m.customer != nil {
		edges = append(edges, subscription.EdgeCustomer)
	}
	if m.phases != nil {
		edges = append(edges, subscription.EdgePhases)
	}
	if m.billing_lines != nil {
		edges = append(edges, subscription.EdgeBillingLines)
	}
	if m.addons != nil {
		edges = append(edges, subscription.EdgeAddons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case subscription.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case subscription.EdgePhases:
		ids := make([]ent.Value, 0, len(m.phases))
		for id := range m.phases {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgeBillingLines:
		ids := make([]ent.Value, 0, len(m.billing_lines))
		for id := range m.billing_lines {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgeAddons:
		ids := make([]ent.Value, 0, len(m.addons))
		for id := range m.addons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedphases != nil {
		edges = append(edges, subscription.EdgePhases)
	}
	if m.removedbilling_lines != nil {
		edges = append(edges, subscription.EdgeBillingLines)
	}
	if m.removedaddons != nil {
		edges = append(edges, subscription.EdgeAddons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgePhases:
		ids := make([]ent.Value, 0, len(m.removedphases))
		for id := range m.removedphases {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgeBillingLines:
		ids := make([]ent.Value, 0, len(m.removedbilling_lines))
		for id := range m.removedbilling_lines {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgeAddons:
		ids := make([]ent.Value, 0, len(m.removedaddons))
		for id := range m.removedaddons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedplan {
		edges = append(edges, subscription.EdgePlan)
	}
	if m.clearedcustomer {
		edges = append(edges, subscription.EdgeCustomer)
	}
	if m.clearedphases {
		edges = append(edges, subscription.EdgePhases)
	}
	if m.clearedbilling_lines {
		edges = append(edges, subscription.EdgeBillingLines)
	}
	if m.clearedaddons {
		edges = append(edges, subscription.EdgeAddons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case subscription.EdgePlan:
		return m.clearedplan
	case subscription.EdgeCustomer:
		return m.clearedcustomer
	case subscription.EdgePhases:
		return m.clearedphases
	case subscription.EdgeBillingLines:
		return m.clearedbilling_lines
	case subscription.EdgeAddons:
		return m.clearedaddons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case subscription.EdgePlan:
		m.ClearPlan()
		return nil
	case subscription.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case subscription.EdgePlan:
		m.ResetPlan()
		return nil
	case subscription.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case subscription.EdgePhases:
		m.ResetPhases()
		return nil
	case subscription.EdgeBillingLines:
		m.ResetBillingLines()
		return nil
	case subscription.EdgeAddons:
		m.ResetAddons()
		return nil
	}
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// SubscriptionAddonMutation represents an operation that mutates the SubscriptionAddon nodes in the graph.
type SubscriptionAddonMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	namespace           *string
	metadata            *map[string]string
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	subscription        *string
	clearedsubscription bool
	quantities          map[string]struct{}
	removedquantities   map[string]struct{}
	clearedquantities   bool
	addon               *string
	clearedaddon        bool
	done                bool
	oldValue            func(context.Context) (*SubscriptionAddon, error)
	predicates          []predicate.SubscriptionAddon
}

var _ ent.Mutation = (*SubscriptionAddonMutation)(nil)

// subscriptionaddonOption allows management of the mutation configuration using functional options.
type subscriptionaddonOption func(*SubscriptionAddonMutation)

// newSubscriptionAddonMutation creates new mutation for the SubscriptionAddon entity.
func newSubscriptionAddonMutation(c config, op Op, opts ...subscriptionaddonOption) *SubscriptionAddonMutation {
	m := &SubscriptionAddonMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionAddon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionAddonID sets the ID field of the mutation.
func withSubscriptionAddonID(id string) subscriptionaddonOption {
	return func(m *SubscriptionAddonMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionAddon
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionAddon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionAddon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionAddon sets the old SubscriptionAddon of the mutation.
func withSubscriptionAddon(node *SubscriptionAddon) subscriptionaddonOption {
	return func(m *SubscriptionAddonMutation) {
		m.oldValue = func(context.Context) (*SubscriptionAddon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionAddonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionAddonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionAddon entities.
func (m *SubscriptionAddonMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionAddonMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionAddonMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionAddon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionAddonMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionAddonMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SubscriptionAddon entity.
// If the SubscriptionAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionAddonMutation) ResetNamespace() {
	m.namespace = nil
}

// SetMetadata sets the "metadata" field.
func (m *SubscriptionAddonMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SubscriptionAddonMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SubscriptionAddon entity.
// If the SubscriptionAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SubscriptionAddonMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[subscriptionaddon.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SubscriptionAddonMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[subscriptionaddon.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SubscriptionAddonMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, subscriptionaddon.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionAddonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionAddonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscriptionAddon entity.
// If the SubscriptionAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionAddonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionAddonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionAddonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscriptionAddon entity.
// If the SubscriptionAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionAddonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriptionAddonMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriptionAddonMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubscriptionAddon entity.
// If the SubscriptionAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscriptionAddonMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscriptionaddon.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscriptionAddonMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscriptionaddon.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriptionAddonMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscriptionaddon.FieldDeletedAt)
}

// SetAddonID sets the "addon_id" field.
func (m *SubscriptionAddonMutation) SetAddonID(s string) {
	m.addon = &s
}

// AddonID returns the value of the "addon_id" field in the mutation.
func (m *SubscriptionAddonMutation) AddonID() (r string, exists bool) {
	v := m.addon
	if v == nil {
		return
	}
	return *v, true
}

// OldAddonID returns the old "addon_id" field's value of the SubscriptionAddon entity.
// If the SubscriptionAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonMutation) OldAddonID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddonID: %w", err)
	}
	return oldValue.AddonID, nil
}

// ResetAddonID resets all changes to the "addon_id" field.
func (m *SubscriptionAddonMutation) ResetAddonID() {
	m.addon = nil
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *SubscriptionAddonMutation) SetSubscriptionID(s string) {
	m.subscription = &s
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *SubscriptionAddonMutation) SubscriptionID() (r string, exists bool) {
	v := m.subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the SubscriptionAddon entity.
// If the SubscriptionAddon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonMutation) OldSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *SubscriptionAddonMutation) ResetSubscriptionID() {
	m.subscription = nil
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *SubscriptionAddonMutation) ClearSubscription() {
	m.clearedsubscription = true
	m.clearedFields[subscriptionaddon.FieldSubscriptionID] = struct{}{}
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *SubscriptionAddonMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *SubscriptionAddonMutation) SubscriptionIDs() (ids []string) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *SubscriptionAddonMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// AddQuantityIDs adds the "quantities" edge to the SubscriptionAddonQuantity entity by ids.
func (m *SubscriptionAddonMutation) AddQuantityIDs(ids ...string) {
	if m.quantities == nil {
		m.quantities = make(map[string]struct{})
	}
	for i := range ids {
		m.quantities[ids[i]] = struct{}{}
	}
}

// ClearQuantities clears the "quantities" edge to the SubscriptionAddonQuantity entity.
func (m *SubscriptionAddonMutation) ClearQuantities() {
	m.clearedquantities = true
}

// QuantitiesCleared reports if the "quantities" edge to the SubscriptionAddonQuantity entity was cleared.
func (m *SubscriptionAddonMutation) QuantitiesCleared() bool {
	return m.clearedquantities
}

// RemoveQuantityIDs removes the "quantities" edge to the SubscriptionAddonQuantity entity by IDs.
func (m *SubscriptionAddonMutation) RemoveQuantityIDs(ids ...string) {
	if m.removedquantities == nil {
		m.removedquantities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.quantities, ids[i])
		m.removedquantities[ids[i]] = struct{}{}
	}
}

// RemovedQuantities returns the removed IDs of the "quantities" edge to the SubscriptionAddonQuantity entity.
func (m *SubscriptionAddonMutation) RemovedQuantitiesIDs() (ids []string) {
	for id := range m.removedquantities {
		ids = append(ids, id)
	}
	return
}

// QuantitiesIDs returns the "quantities" edge IDs in the mutation.
func (m *SubscriptionAddonMutation) QuantitiesIDs() (ids []string) {
	for id := range m.quantities {
		ids = append(ids, id)
	}
	return
}

// ResetQuantities resets all changes to the "quantities" edge.
func (m *SubscriptionAddonMutation) ResetQuantities() {
	m.quantities = nil
	m.clearedquantities = false
	m.removedquantities = nil
}

// ClearAddon clears the "addon" edge to the Addon entity.
func (m *SubscriptionAddonMutation) ClearAddon() {
	m.clearedaddon = true
	m.clearedFields[subscriptionaddon.FieldAddonID] = struct{}{}
}

// AddonCleared reports if the "addon" edge to the Addon entity was cleared.
func (m *SubscriptionAddonMutation) AddonCleared() bool {
	return m.clearedaddon
}

// AddonIDs returns the "addon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddonID instead. It exists only for internal usage by the builders.
func (m *SubscriptionAddonMutation) AddonIDs() (ids []string) {
	if id := m.addon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddon resets all changes to the "addon" edge.
func (m *SubscriptionAddonMutation) ResetAddon() {
	m.addon = nil
	m.clearedaddon = false
}

// Where appends a list predicates to the SubscriptionAddonMutation builder.
func (m *SubscriptionAddonMutation) Where(ps ...predicate.SubscriptionAddon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionAddonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionAddonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionAddon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionAddonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionAddonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionAddon).
func (m *SubscriptionAddonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionAddonMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.namespace != nil {
		fields = append(fields, subscriptionaddon.FieldNamespace)
	}
	if m.metadata != nil {
		fields = append(fields, subscriptionaddon.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, subscriptionaddon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriptionaddon.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscriptionaddon.FieldDeletedAt)
	}
	if m.addon != nil {
		fields = append(fields, subscriptionaddon.FieldAddonID)
	}
	if m.subscription != nil {
		fields = append(fields, subscriptionaddon.FieldSubscriptionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionAddonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptionaddon.FieldNamespace:
		return m.Namespace()
	case subscriptionaddon.FieldMetadata:
		return m.Metadata()
	case subscriptionaddon.FieldCreatedAt:
		return m.CreatedAt()
	case subscriptionaddon.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscriptionaddon.FieldDeletedAt:
		return m.DeletedAt()
	case subscriptionaddon.FieldAddonID:
		return m.AddonID()
	case subscriptionaddon.FieldSubscriptionID:
		return m.SubscriptionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionAddonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptionaddon.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscriptionaddon.FieldMetadata:
		return m.OldMetadata(ctx)
	case subscriptionaddon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriptionaddon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscriptionaddon.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscriptionaddon.FieldAddonID:
		return m.OldAddonID(ctx)
	case subscriptionaddon.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionAddon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionAddonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptionaddon.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscriptionaddon.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case subscriptionaddon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriptionaddon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscriptionaddon.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscriptionaddon.FieldAddonID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddonID(v)
		return nil
	case subscriptionaddon.FieldSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionAddonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionAddonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionAddonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubscriptionAddon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionAddonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriptionaddon.FieldMetadata) {
		fields = append(fields, subscriptionaddon.FieldMetadata)
	}
	if m.FieldCleared(subscriptionaddon.FieldDeletedAt) {
		fields = append(fields, subscriptionaddon.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionAddonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionAddonMutation) ClearField(name string) error {
	switch name {
	case subscriptionaddon.FieldMetadata:
		m.ClearMetadata()
		return nil
	case subscriptionaddon.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionAddonMutation) ResetField(name string) error {
	switch name {
	case subscriptionaddon.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscriptionaddon.FieldMetadata:
		m.ResetMetadata()
		return nil
	case subscriptionaddon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriptionaddon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscriptionaddon.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscriptionaddon.FieldAddonID:
		m.ResetAddonID()
		return nil
	case subscriptionaddon.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionAddonMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.subscription != nil {
		edges = append(edges, subscriptionaddon.EdgeSubscription)
	}
	if m.quantities != nil {
		edges = append(edges, subscriptionaddon.EdgeQuantities)
	}
	if m.addon != nil {
		edges = append(edges, subscriptionaddon.EdgeAddon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionAddonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptionaddon.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	case subscriptionaddon.EdgeQuantities:
		ids := make([]ent.Value, 0, len(m.quantities))
		for id := range m.quantities {
			ids = append(ids, id)
		}
		return ids
	case subscriptionaddon.EdgeAddon:
		if id := m.addon; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionAddonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedquantities != nil {
		edges = append(edges, subscriptionaddon.EdgeQuantities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionAddonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscriptionaddon.EdgeQuantities:
		ids := make([]ent.Value, 0, len(m.removedquantities))
		for id := range m.removedquantities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionAddonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsubscription {
		edges = append(edges, subscriptionaddon.EdgeSubscription)
	}
	if m.clearedquantities {
		edges = append(edges, subscriptionaddon.EdgeQuantities)
	}
	if m.clearedaddon {
		edges = append(edges, subscriptionaddon.EdgeAddon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionAddonMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptionaddon.EdgeSubscription:
		return m.clearedsubscription
	case subscriptionaddon.EdgeQuantities:
		return m.clearedquantities
	case subscriptionaddon.EdgeAddon:
		return m.clearedaddon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionAddonMutation) ClearEdge(name string) error {
	switch name {
	case subscriptionaddon.EdgeSubscription:
		m.ClearSubscription()
		return nil
	case subscriptionaddon.EdgeAddon:
		m.ClearAddon()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionAddonMutation) ResetEdge(name string) error {
	switch name {
	case subscriptionaddon.EdgeSubscription:
		m.ResetSubscription()
		return nil
	case subscriptionaddon.EdgeQuantities:
		m.ResetQuantities()
		return nil
	case subscriptionaddon.EdgeAddon:
		m.ResetAddon()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddon edge %s", name)
}

// SubscriptionAddonQuantityMutation represents an operation that mutates the SubscriptionAddonQuantity nodes in the graph.
type SubscriptionAddonQuantityMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	namespace                 *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	active_from               *time.Time
	quantity                  *int
	addquantity               *int
	clearedFields             map[string]struct{}
	subscription_addon        *string
	clearedsubscription_addon bool
	done                      bool
	oldValue                  func(context.Context) (*SubscriptionAddonQuantity, error)
	predicates                []predicate.SubscriptionAddonQuantity
}

var _ ent.Mutation = (*SubscriptionAddonQuantityMutation)(nil)

// subscriptionaddonquantityOption allows management of the mutation configuration using functional options.
type subscriptionaddonquantityOption func(*SubscriptionAddonQuantityMutation)

// newSubscriptionAddonQuantityMutation creates new mutation for the SubscriptionAddonQuantity entity.
func newSubscriptionAddonQuantityMutation(c config, op Op, opts ...subscriptionaddonquantityOption) *SubscriptionAddonQuantityMutation {
	m := &SubscriptionAddonQuantityMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionAddonQuantity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionAddonQuantityID sets the ID field of the mutation.
func withSubscriptionAddonQuantityID(id string) subscriptionaddonquantityOption {
	return func(m *SubscriptionAddonQuantityMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionAddonQuantity
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionAddonQuantity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionAddonQuantity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionAddonQuantity sets the old SubscriptionAddonQuantity of the mutation.
func withSubscriptionAddonQuantity(node *SubscriptionAddonQuantity) subscriptionaddonquantityOption {
	return func(m *SubscriptionAddonQuantityMutation) {
		m.oldValue = func(context.Context) (*SubscriptionAddonQuantity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionAddonQuantityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionAddonQuantityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionAddonQuantity entities.
func (m *SubscriptionAddonQuantityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionAddonQuantityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionAddonQuantityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionAddonQuantity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionAddonQuantityMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionAddonQuantityMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SubscriptionAddonQuantity entity.
// If the SubscriptionAddonQuantity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonQuantityMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionAddonQuantityMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionAddonQuantityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionAddonQuantityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscriptionAddonQuantity entity.
// If the SubscriptionAddonQuantity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonQuantityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionAddonQuantityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionAddonQuantityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionAddonQuantityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscriptionAddonQuantity entity.
// If the SubscriptionAddonQuantity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonQuantityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionAddonQuantityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriptionAddonQuantityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriptionAddonQuantityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubscriptionAddonQuantity entity.
// If the SubscriptionAddonQuantity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonQuantityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscriptionAddonQuantityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscriptionaddonquantity.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscriptionAddonQuantityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscriptionaddonquantity.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriptionAddonQuantityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscriptionaddonquantity.FieldDeletedAt)
}

// SetActiveFrom sets the "active_from" field.
func (m *SubscriptionAddonQuantityMutation) SetActiveFrom(t time.Time) {
	m.active_from = &t
}

// ActiveFrom returns the value of the "active_from" field in the mutation.
func (m *SubscriptionAddonQuantityMutation) ActiveFrom() (r time.Time, exists bool) {
	v := m.active_from
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveFrom returns the old "active_from" field's value of the SubscriptionAddonQuantity entity.
// If the SubscriptionAddonQuantity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonQuantityMutation) OldActiveFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveFrom: %w", err)
	}
	return oldValue.ActiveFrom, nil
}

// ResetActiveFrom resets all changes to the "active_from" field.
func (m *SubscriptionAddonQuantityMutation) ResetActiveFrom() {
	m.active_from = nil
}

// SetQuantity sets the "quantity" field.
func (m *SubscriptionAddonQuantityMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *SubscriptionAddonQuantityMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the SubscriptionAddonQuantity entity.
// If the SubscriptionAddonQuantity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonQuantityMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *SubscriptionAddonQuantityMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *SubscriptionAddonQuantityMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *SubscriptionAddonQuantityMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetSubscriptionAddonID sets the "subscription_addon_id" field.
func (m *SubscriptionAddonQuantityMutation) SetSubscriptionAddonID(s string) {
	m.subscription_addon = &s
}

// SubscriptionAddonID returns the value of the "subscription_addon_id" field in the mutation.
func (m *SubscriptionAddonQuantityMutation) SubscriptionAddonID() (r string, exists bool) {
	v := m.subscription_addon
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionAddonID returns the old "subscription_addon_id" field's value of the SubscriptionAddonQuantity entity.
// If the SubscriptionAddonQuantity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionAddonQuantityMutation) OldSubscriptionAddonID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionAddonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionAddonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionAddonID: %w", err)
	}
	return oldValue.SubscriptionAddonID, nil
}

// ResetSubscriptionAddonID resets all changes to the "subscription_addon_id" field.
func (m *SubscriptionAddonQuantityMutation) ResetSubscriptionAddonID() {
	m.subscription_addon = nil
}

// ClearSubscriptionAddon clears the "subscription_addon" edge to the SubscriptionAddon entity.
func (m *SubscriptionAddonQuantityMutation) ClearSubscriptionAddon() {
	m.clearedsubscription_addon = true
	m.clearedFields[subscriptionaddonquantity.FieldSubscriptionAddonID] = struct{}{}
}

// SubscriptionAddonCleared reports if the "subscription_addon" edge to the SubscriptionAddon entity was cleared.
func (m *SubscriptionAddonQuantityMutation) SubscriptionAddonCleared() bool {
	return m.clearedsubscription_addon
}

// SubscriptionAddonIDs returns the "subscription_addon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionAddonID instead. It exists only for internal usage by the builders.
func (m *SubscriptionAddonQuantityMutation) SubscriptionAddonIDs() (ids []string) {
	if id := m.subscription_addon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscriptionAddon resets all changes to the "subscription_addon" edge.
func (m *SubscriptionAddonQuantityMutation) ResetSubscriptionAddon() {
	m.subscription_addon = nil
	m.clearedsubscription_addon = false
}

// Where appends a list predicates to the SubscriptionAddonQuantityMutation builder.
func (m *SubscriptionAddonQuantityMutation) Where(ps ...predicate.SubscriptionAddonQuantity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionAddonQuantityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionAddonQuantityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionAddonQuantity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionAddonQuantityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionAddonQuantityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionAddonQuantity).
func (m *SubscriptionAddonQuantityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionAddonQuantityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.namespace != nil {
		fields = append(fields, subscriptionaddonquantity.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, subscriptionaddonquantity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriptionaddonquantity.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscriptionaddonquantity.FieldDeletedAt)
	}
	if m.active_from != nil {
		fields = append(fields, subscriptionaddonquantity.FieldActiveFrom)
	}
	if m.quantity != nil {
		fields = append(fields, subscriptionaddonquantity.FieldQuantity)
	}
	if m.subscription_addon != nil {
		fields = append(fields, subscriptionaddonquantity.FieldSubscriptionAddonID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionAddonQuantityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptionaddonquantity.FieldNamespace:
		return m.Namespace()
	case subscriptionaddonquantity.FieldCreatedAt:
		return m.CreatedAt()
	case subscriptionaddonquantity.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscriptionaddonquantity.FieldDeletedAt:
		return m.DeletedAt()
	case subscriptionaddonquantity.FieldActiveFrom:
		return m.ActiveFrom()
	case subscriptionaddonquantity.FieldQuantity:
		return m.Quantity()
	case subscriptionaddonquantity.FieldSubscriptionAddonID:
		return m.SubscriptionAddonID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionAddonQuantityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptionaddonquantity.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscriptionaddonquantity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriptionaddonquantity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscriptionaddonquantity.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscriptionaddonquantity.FieldActiveFrom:
		return m.OldActiveFrom(ctx)
	case subscriptionaddonquantity.FieldQuantity:
		return m.OldQuantity(ctx)
	case subscriptionaddonquantity.FieldSubscriptionAddonID:
		return m.OldSubscriptionAddonID(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionAddonQuantity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionAddonQuantityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptionaddonquantity.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscriptionaddonquantity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriptionaddonquantity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscriptionaddonquantity.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscriptionaddonquantity.FieldActiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveFrom(v)
		return nil
	case subscriptionaddonquantity.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case subscriptionaddonquantity.FieldSubscriptionAddonID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionAddonID(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddonQuantity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionAddonQuantityMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, subscriptionaddonquantity.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionAddonQuantityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscriptionaddonquantity.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionAddonQuantityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscriptionaddonquantity.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddonQuantity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionAddonQuantityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriptionaddonquantity.FieldDeletedAt) {
		fields = append(fields, subscriptionaddonquantity.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionAddonQuantityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionAddonQuantityMutation) ClearField(name string) error {
	switch name {
	case subscriptionaddonquantity.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddonQuantity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionAddonQuantityMutation) ResetField(name string) error {
	switch name {
	case subscriptionaddonquantity.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscriptionaddonquantity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriptionaddonquantity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscriptionaddonquantity.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscriptionaddonquantity.FieldActiveFrom:
		m.ResetActiveFrom()
		return nil
	case subscriptionaddonquantity.FieldQuantity:
		m.ResetQuantity()
		return nil
	case subscriptionaddonquantity.FieldSubscriptionAddonID:
		m.ResetSubscriptionAddonID()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddonQuantity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionAddonQuantityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subscription_addon != nil {
		edges = append(edges, subscriptionaddonquantity.EdgeSubscriptionAddon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionAddonQuantityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptionaddonquantity.EdgeSubscriptionAddon:
		if id := m.subscription_addon; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionAddonQuantityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionAddonQuantityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionAddonQuantityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubscription_addon {
		edges = append(edges, subscriptionaddonquantity.EdgeSubscriptionAddon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionAddonQuantityMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptionaddonquantity.EdgeSubscriptionAddon:
		return m.clearedsubscription_addon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionAddonQuantityMutation) ClearEdge(name string) error {
	switch name {
	case subscriptionaddonquantity.EdgeSubscriptionAddon:
		m.ClearSubscriptionAddon()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddonQuantity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionAddonQuantityMutation) ResetEdge(name string) error {
	switch name {
	case subscriptionaddonquantity.EdgeSubscriptionAddon:
		m.ResetSubscriptionAddon()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionAddonQuantity edge %s", name)
}

// SubscriptionItemMutation represents an operation that mutates the SubscriptionItem nodes in the graph.
type SubscriptionItemMutation struct {
	config
	op                                           Op
	typ                                          string
	id                                           *string
	namespace                                    *string
	created_at                                   *time.Time
	updated_at                                   *time.Time
	deleted_at                                   *time.Time
	metadata                                     *map[string]string
	annotations                                  *map[string]interface{}
	active_from                                  *time.Time
	active_to                                    *time.Time
	key                                          *string
	restarts_billing_period                      *bool
	active_from_override_relative_to_phase_start *isodate.String
	active_to_override_relative_to_phase_start   *isodate.String
	name                                         *string
	description                                  *string
	feature_key                                  *string
	entitlement_template                         **productcatalog.EntitlementTemplate
	tax_config                                   **productcatalog.TaxConfig
	billing_cadence                              *isodate.String
	price                                        **productcatalog.Price
	discounts                                    **productcatalog.Discounts
	clearedFields                                map[string]struct{}
	phase                                        *string
	clearedphase                                 bool
	entitlement                                  *string
	clearedentitlement                           bool
	billing_lines                                map[string]struct{}
	removedbilling_lines                         map[string]struct{}
	clearedbilling_lines                         bool
	done                                         bool
	oldValue                                     func(context.Context) (*SubscriptionItem, error)
	predicates                                   []predicate.SubscriptionItem
}

var _ ent.Mutation = (*SubscriptionItemMutation)(nil)

// subscriptionitemOption allows management of the mutation configuration using functional options.
type subscriptionitemOption func(*SubscriptionItemMutation)

// newSubscriptionItemMutation creates new mutation for the SubscriptionItem entity.
func newSubscriptionItemMutation(c config, op Op, opts ...subscriptionitemOption) *SubscriptionItemMutation {
	m := &SubscriptionItemMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionItemID sets the ID field of the mutation.
func withSubscriptionItemID(id string) subscriptionitemOption {
	return func(m *SubscriptionItemMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionItem
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionItem sets the old SubscriptionItem of the mutation.
func withSubscriptionItem(node *SubscriptionItem) subscriptionitemOption {
	return func(m *SubscriptionItemMutation) {
		m.oldValue = func(context.Context) (*SubscriptionItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionItem entities.
func (m *SubscriptionItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionItemMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionItemMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionItemMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriptionItemMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriptionItemMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscriptionItemMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscriptionitem.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscriptionItemMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriptionItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscriptionitem.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *SubscriptionItemMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SubscriptionItemMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SubscriptionItemMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[subscriptionitem.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SubscriptionItemMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SubscriptionItemMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, subscriptionitem.FieldMetadata)
}

// SetAnnotations sets the "annotations" field.
func (m *SubscriptionItemMutation) SetAnnotations(value map[string]interface{}) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *SubscriptionItemMutation) Annotations() (r map[string]interface{}, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldAnnotations(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *SubscriptionItemMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[subscriptionitem.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *SubscriptionItemMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *SubscriptionItemMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, subscriptionitem.FieldAnnotations)
}

// SetActiveFrom sets the "active_from" field.
func (m *SubscriptionItemMutation) SetActiveFrom(t time.Time) {
	m.active_from = &t
}

// ActiveFrom returns the value of the "active_from" field in the mutation.
func (m *SubscriptionItemMutation) ActiveFrom() (r time.Time, exists bool) {
	v := m.active_from
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveFrom returns the old "active_from" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldActiveFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveFrom: %w", err)
	}
	return oldValue.ActiveFrom, nil
}

// ResetActiveFrom resets all changes to the "active_from" field.
func (m *SubscriptionItemMutation) ResetActiveFrom() {
	m.active_from = nil
}

// SetActiveTo sets the "active_to" field.
func (m *SubscriptionItemMutation) SetActiveTo(t time.Time) {
	m.active_to = &t
}

// ActiveTo returns the value of the "active_to" field in the mutation.
func (m *SubscriptionItemMutation) ActiveTo() (r time.Time, exists bool) {
	v := m.active_to
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveTo returns the old "active_to" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldActiveTo(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveTo: %w", err)
	}
	return oldValue.ActiveTo, nil
}

// ClearActiveTo clears the value of the "active_to" field.
func (m *SubscriptionItemMutation) ClearActiveTo() {
	m.active_to = nil
	m.clearedFields[subscriptionitem.FieldActiveTo] = struct{}{}
}

// ActiveToCleared returns if the "active_to" field was cleared in this mutation.
func (m *SubscriptionItemMutation) ActiveToCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldActiveTo]
	return ok
}

// ResetActiveTo resets all changes to the "active_to" field.
func (m *SubscriptionItemMutation) ResetActiveTo() {
	m.active_to = nil
	delete(m.clearedFields, subscriptionitem.FieldActiveTo)
}

// SetPhaseID sets the "phase_id" field.
func (m *SubscriptionItemMutation) SetPhaseID(s string) {
	m.phase = &s
}

// PhaseID returns the value of the "phase_id" field in the mutation.
func (m *SubscriptionItemMutation) PhaseID() (r string, exists bool) {
	v := m.phase
	if v == nil {
		return
	}
	return *v, true
}

// OldPhaseID returns the old "phase_id" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldPhaseID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhaseID: %w", err)
	}
	return oldValue.PhaseID, nil
}

// ResetPhaseID resets all changes to the "phase_id" field.
func (m *SubscriptionItemMutation) ResetPhaseID() {
	m.phase = nil
}

// SetKey sets the "key" field.
func (m *SubscriptionItemMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SubscriptionItemMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SubscriptionItemMutation) ResetKey() {
	m.key = nil
}

// SetEntitlementID sets the "entitlement_id" field.
func (m *SubscriptionItemMutation) SetEntitlementID(s string) {
	m.entitlement = &s
}

// EntitlementID returns the value of the "entitlement_id" field in the mutation.
func (m *SubscriptionItemMutation) EntitlementID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementID returns the old "entitlement_id" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldEntitlementID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementID: %w", err)
	}
	return oldValue.EntitlementID, nil
}

// ClearEntitlementID clears the value of the "entitlement_id" field.
func (m *SubscriptionItemMutation) ClearEntitlementID() {
	m.entitlement = nil
	m.clearedFields[subscriptionitem.FieldEntitlementID] = struct{}{}
}

// EntitlementIDCleared returns if the "entitlement_id" field was cleared in this mutation.
func (m *SubscriptionItemMutation) EntitlementIDCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldEntitlementID]
	return ok
}

// ResetEntitlementID resets all changes to the "entitlement_id" field.
func (m *SubscriptionItemMutation) ResetEntitlementID() {
	m.entitlement = nil
	delete(m.clearedFields, subscriptionitem.FieldEntitlementID)
}

// SetRestartsBillingPeriod sets the "restarts_billing_period" field.
func (m *SubscriptionItemMutation) SetRestartsBillingPeriod(b bool) {
	m.restarts_billing_period = &b
}

// RestartsBillingPeriod returns the value of the "restarts_billing_period" field in the mutation.
func (m *SubscriptionItemMutation) RestartsBillingPeriod() (r bool, exists bool) {
	v := m.restarts_billing_period
	if v == nil {
		return
	}
	return *v, true
}

// OldRestartsBillingPeriod returns the old "restarts_billing_period" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldRestartsBillingPeriod(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestartsBillingPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestartsBillingPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestartsBillingPeriod: %w", err)
	}
	return oldValue.RestartsBillingPeriod, nil
}

// ClearRestartsBillingPeriod clears the value of the "restarts_billing_period" field.
func (m *SubscriptionItemMutation) ClearRestartsBillingPeriod() {
	m.restarts_billing_period = nil
	m.clearedFields[subscriptionitem.FieldRestartsBillingPeriod] = struct{}{}
}

// RestartsBillingPeriodCleared returns if the "restarts_billing_period" field was cleared in this mutation.
func (m *SubscriptionItemMutation) RestartsBillingPeriodCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldRestartsBillingPeriod]
	return ok
}

// ResetRestartsBillingPeriod resets all changes to the "restarts_billing_period" field.
func (m *SubscriptionItemMutation) ResetRestartsBillingPeriod() {
	m.restarts_billing_period = nil
	delete(m.clearedFields, subscriptionitem.FieldRestartsBillingPeriod)
}

// SetActiveFromOverrideRelativeToPhaseStart sets the "active_from_override_relative_to_phase_start" field.
func (m *SubscriptionItemMutation) SetActiveFromOverrideRelativeToPhaseStart(i isodate.String) {
	m.active_from_override_relative_to_phase_start = &i
}

// ActiveFromOverrideRelativeToPhaseStart returns the value of the "active_from_override_relative_to_phase_start" field in the mutation.
func (m *SubscriptionItemMutation) ActiveFromOverrideRelativeToPhaseStart() (r isodate.String, exists bool) {
	v := m.active_from_override_relative_to_phase_start
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveFromOverrideRelativeToPhaseStart returns the old "active_from_override_relative_to_phase_start" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldActiveFromOverrideRelativeToPhaseStart(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveFromOverrideRelativeToPhaseStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveFromOverrideRelativeToPhaseStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveFromOverrideRelativeToPhaseStart: %w", err)
	}
	return oldValue.ActiveFromOverrideRelativeToPhaseStart, nil
}

// ClearActiveFromOverrideRelativeToPhaseStart clears the value of the "active_from_override_relative_to_phase_start" field.
func (m *SubscriptionItemMutation) ClearActiveFromOverrideRelativeToPhaseStart() {
	m.active_from_override_relative_to_phase_start = nil
	m.clearedFields[subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart] = struct{}{}
}

// ActiveFromOverrideRelativeToPhaseStartCleared returns if the "active_from_override_relative_to_phase_start" field was cleared in this mutation.
func (m *SubscriptionItemMutation) ActiveFromOverrideRelativeToPhaseStartCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart]
	return ok
}

// ResetActiveFromOverrideRelativeToPhaseStart resets all changes to the "active_from_override_relative_to_phase_start" field.
func (m *SubscriptionItemMutation) ResetActiveFromOverrideRelativeToPhaseStart() {
	m.active_from_override_relative_to_phase_start = nil
	delete(m.clearedFields, subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart)
}

// SetActiveToOverrideRelativeToPhaseStart sets the "active_to_override_relative_to_phase_start" field.
func (m *SubscriptionItemMutation) SetActiveToOverrideRelativeToPhaseStart(i isodate.String) {
	m.active_to_override_relative_to_phase_start = &i
}

// ActiveToOverrideRelativeToPhaseStart returns the value of the "active_to_override_relative_to_phase_start" field in the mutation.
func (m *SubscriptionItemMutation) ActiveToOverrideRelativeToPhaseStart() (r isodate.String, exists bool) {
	v := m.active_to_override_relative_to_phase_start
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveToOverrideRelativeToPhaseStart returns the old "active_to_override_relative_to_phase_start" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldActiveToOverrideRelativeToPhaseStart(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveToOverrideRelativeToPhaseStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveToOverrideRelativeToPhaseStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveToOverrideRelativeToPhaseStart: %w", err)
	}
	return oldValue.ActiveToOverrideRelativeToPhaseStart, nil
}

// ClearActiveToOverrideRelativeToPhaseStart clears the value of the "active_to_override_relative_to_phase_start" field.
func (m *SubscriptionItemMutation) ClearActiveToOverrideRelativeToPhaseStart() {
	m.active_to_override_relative_to_phase_start = nil
	m.clearedFields[subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart] = struct{}{}
}

// ActiveToOverrideRelativeToPhaseStartCleared returns if the "active_to_override_relative_to_phase_start" field was cleared in this mutation.
func (m *SubscriptionItemMutation) ActiveToOverrideRelativeToPhaseStartCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart]
	return ok
}

// ResetActiveToOverrideRelativeToPhaseStart resets all changes to the "active_to_override_relative_to_phase_start" field.
func (m *SubscriptionItemMutation) ResetActiveToOverrideRelativeToPhaseStart() {
	m.active_to_override_relative_to_phase_start = nil
	delete(m.clearedFields, subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart)
}

// SetName sets the "name" field.
func (m *SubscriptionItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubscriptionItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubscriptionItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SubscriptionItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubscriptionItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubscriptionItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subscriptionitem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubscriptionItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubscriptionItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subscriptionitem.FieldDescription)
}

// SetFeatureKey sets the "feature_key" field.
func (m *SubscriptionItemMutation) SetFeatureKey(s string) {
	m.feature_key = &s
}

// FeatureKey returns the value of the "feature_key" field in the mutation.
func (m *SubscriptionItemMutation) FeatureKey() (r string, exists bool) {
	v := m.feature_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureKey returns the old "feature_key" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldFeatureKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureKey: %w", err)
	}
	return oldValue.FeatureKey, nil
}

// ClearFeatureKey clears the value of the "feature_key" field.
func (m *SubscriptionItemMutation) ClearFeatureKey() {
	m.feature_key = nil
	m.clearedFields[subscriptionitem.FieldFeatureKey] = struct{}{}
}

// FeatureKeyCleared returns if the "feature_key" field was cleared in this mutation.
func (m *SubscriptionItemMutation) FeatureKeyCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldFeatureKey]
	return ok
}

// ResetFeatureKey resets all changes to the "feature_key" field.
func (m *SubscriptionItemMutation) ResetFeatureKey() {
	m.feature_key = nil
	delete(m.clearedFields, subscriptionitem.FieldFeatureKey)
}

// SetEntitlementTemplate sets the "entitlement_template" field.
func (m *SubscriptionItemMutation) SetEntitlementTemplate(pt *productcatalog.EntitlementTemplate) {
	m.entitlement_template = &pt
}

// EntitlementTemplate returns the value of the "entitlement_template" field in the mutation.
func (m *SubscriptionItemMutation) EntitlementTemplate() (r *productcatalog.EntitlementTemplate, exists bool) {
	v := m.entitlement_template
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementTemplate returns the old "entitlement_template" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldEntitlementTemplate(ctx context.Context) (v *productcatalog.EntitlementTemplate, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementTemplate: %w", err)
	}
	return oldValue.EntitlementTemplate, nil
}

// ClearEntitlementTemplate clears the value of the "entitlement_template" field.
func (m *SubscriptionItemMutation) ClearEntitlementTemplate() {
	m.entitlement_template = nil
	m.clearedFields[subscriptionitem.FieldEntitlementTemplate] = struct{}{}
}

// EntitlementTemplateCleared returns if the "entitlement_template" field was cleared in this mutation.
func (m *SubscriptionItemMutation) EntitlementTemplateCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldEntitlementTemplate]
	return ok
}

// ResetEntitlementTemplate resets all changes to the "entitlement_template" field.
func (m *SubscriptionItemMutation) ResetEntitlementTemplate() {
	m.entitlement_template = nil
	delete(m.clearedFields, subscriptionitem.FieldEntitlementTemplate)
}

// SetTaxConfig sets the "tax_config" field.
func (m *SubscriptionItemMutation) SetTaxConfig(pc *productcatalog.TaxConfig) {
	m.tax_config = &pc
}

// TaxConfig returns the value of the "tax_config" field in the mutation.
func (m *SubscriptionItemMutation) TaxConfig() (r *productcatalog.TaxConfig, exists bool) {
	v := m.tax_config
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxConfig returns the old "tax_config" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldTaxConfig(ctx context.Context) (v *productcatalog.TaxConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxConfig: %w", err)
	}
	return oldValue.TaxConfig, nil
}

// ClearTaxConfig clears the value of the "tax_config" field.
func (m *SubscriptionItemMutation) ClearTaxConfig() {
	m.tax_config = nil
	m.clearedFields[subscriptionitem.FieldTaxConfig] = struct{}{}
}

// TaxConfigCleared returns if the "tax_config" field was cleared in this mutation.
func (m *SubscriptionItemMutation) TaxConfigCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldTaxConfig]
	return ok
}

// ResetTaxConfig resets all changes to the "tax_config" field.
func (m *SubscriptionItemMutation) ResetTaxConfig() {
	m.tax_config = nil
	delete(m.clearedFields, subscriptionitem.FieldTaxConfig)
}

// SetBillingCadence sets the "billing_cadence" field.
func (m *SubscriptionItemMutation) SetBillingCadence(i isodate.String) {
	m.billing_cadence = &i
}

// BillingCadence returns the value of the "billing_cadence" field in the mutation.
func (m *SubscriptionItemMutation) BillingCadence() (r isodate.String, exists bool) {
	v := m.billing_cadence
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingCadence returns the old "billing_cadence" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldBillingCadence(ctx context.Context) (v *isodate.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingCadence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingCadence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingCadence: %w", err)
	}
	return oldValue.BillingCadence, nil
}

// ClearBillingCadence clears the value of the "billing_cadence" field.
func (m *SubscriptionItemMutation) ClearBillingCadence() {
	m.billing_cadence = nil
	m.clearedFields[subscriptionitem.FieldBillingCadence] = struct{}{}
}

// BillingCadenceCleared returns if the "billing_cadence" field was cleared in this mutation.
func (m *SubscriptionItemMutation) BillingCadenceCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldBillingCadence]
	return ok
}

// ResetBillingCadence resets all changes to the "billing_cadence" field.
func (m *SubscriptionItemMutation) ResetBillingCadence() {
	m.billing_cadence = nil
	delete(m.clearedFields, subscriptionitem.FieldBillingCadence)
}

// SetPrice sets the "price" field.
func (m *SubscriptionItemMutation) SetPrice(pr *productcatalog.Price) {
	m.price = &pr
}

// Price returns the value of the "price" field in the mutation.
func (m *SubscriptionItemMutation) Price() (r *productcatalog.Price, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldPrice(ctx context.Context) (v *productcatalog.Price, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *SubscriptionItemMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[subscriptionitem.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *SubscriptionItemMutation) PriceCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *SubscriptionItemMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, subscriptionitem.FieldPrice)
}

// SetDiscounts sets the "discounts" field.
func (m *SubscriptionItemMutation) SetDiscounts(pr *productcatalog.Discounts) {
	m.discounts = &pr
}

// Discounts returns the value of the "discounts" field in the mutation.
func (m *SubscriptionItemMutation) Discounts() (r *productcatalog.Discounts, exists bool) {
	v := m.discounts
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscounts returns the old "discounts" field's value of the SubscriptionItem entity.
// If the SubscriptionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionItemMutation) OldDiscounts(ctx context.Context) (v *productcatalog.Discounts, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscounts: %w", err)
	}
	return oldValue.Discounts, nil
}

// ClearDiscounts clears the value of the "discounts" field.
func (m *SubscriptionItemMutation) ClearDiscounts() {
	m.discounts = nil
	m.clearedFields[subscriptionitem.FieldDiscounts] = struct{}{}
}

// DiscountsCleared returns if the "discounts" field was cleared in this mutation.
func (m *SubscriptionItemMutation) DiscountsCleared() bool {
	_, ok := m.clearedFields[subscriptionitem.FieldDiscounts]
	return ok
}

// ResetDiscounts resets all changes to the "discounts" field.
func (m *SubscriptionItemMutation) ResetDiscounts() {
	m.discounts = nil
	delete(m.clearedFields, subscriptionitem.FieldDiscounts)
}

// ClearPhase clears the "phase" edge to the SubscriptionPhase entity.
func (m *SubscriptionItemMutation) ClearPhase() {
	m.clearedphase = true
	m.clearedFields[subscriptionitem.FieldPhaseID] = struct{}{}
}

// PhaseCleared reports if the "phase" edge to the SubscriptionPhase entity was cleared.
func (m *SubscriptionItemMutation) PhaseCleared() bool {
	return m.clearedphase
}

// PhaseIDs returns the "phase" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PhaseID instead. It exists only for internal usage by the builders.
func (m *SubscriptionItemMutation) PhaseIDs() (ids []string) {
	if id := m.phase; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPhase resets all changes to the "phase" edge.
func (m *SubscriptionItemMutation) ResetPhase() {
	m.phase = nil
	m.clearedphase = false
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *SubscriptionItemMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[subscriptionitem.FieldEntitlementID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *SubscriptionItemMutation) EntitlementCleared() bool {
	return m.EntitlementIDCleared() || m.clearedentitlement
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *SubscriptionItemMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *SubscriptionItemMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// AddBillingLineIDs adds the "billing_lines" edge to the BillingInvoiceLine entity by ids.
func (m *SubscriptionItemMutation) AddBillingLineIDs(ids ...string) {
	if m.billing_lines == nil {
		m.billing_lines = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_lines[ids[i]] = struct{}{}
	}
}

// ClearBillingLines clears the "billing_lines" edge to the BillingInvoiceLine entity.
func (m *SubscriptionItemMutation) ClearBillingLines() {
	m.clearedbilling_lines = true
}

// BillingLinesCleared reports if the "billing_lines" edge to the BillingInvoiceLine entity was cleared.
func (m *SubscriptionItemMutation) BillingLinesCleared() bool {
	return m.clearedbilling_lines
}

// RemoveBillingLineIDs removes the "billing_lines" edge to the BillingInvoiceLine entity by IDs.
func (m *SubscriptionItemMutation) RemoveBillingLineIDs(ids ...string) {
	if m.removedbilling_lines == nil {
		m.removedbilling_lines = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_lines, ids[i])
		m.removedbilling_lines[ids[i]] = struct{}{}
	}
}

// RemovedBillingLines returns the removed IDs of the "billing_lines" edge to the BillingInvoiceLine entity.
func (m *SubscriptionItemMutation) RemovedBillingLinesIDs() (ids []string) {
	for id := range m.removedbilling_lines {
		ids = append(ids, id)
	}
	return
}

// BillingLinesIDs returns the "billing_lines" edge IDs in the mutation.
func (m *SubscriptionItemMutation) BillingLinesIDs() (ids []string) {
	for id := range m.billing_lines {
		ids = append(ids, id)
	}
	return
}

// ResetBillingLines resets all changes to the "billing_lines" edge.
func (m *SubscriptionItemMutation) ResetBillingLines() {
	m.billing_lines = nil
	m.clearedbilling_lines = false
	m.removedbilling_lines = nil
}

// Where appends a list predicates to the SubscriptionItemMutation builder.
func (m *SubscriptionItemMutation) Where(ps ...predicate.SubscriptionItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionItem).
func (m *SubscriptionItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionItemMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.namespace != nil {
		fields = append(fields, subscriptionitem.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, subscriptionitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriptionitem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscriptionitem.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, subscriptionitem.FieldMetadata)
	}
	if m.annotations != nil {
		fields = append(fields, subscriptionitem.FieldAnnotations)
	}
	if m.active_from != nil {
		fields = append(fields, subscriptionitem.FieldActiveFrom)
	}
	if m.active_to != nil {
		fields = append(fields, subscriptionitem.FieldActiveTo)
	}
	if m.phase != nil {
		fields = append(fields, subscriptionitem.FieldPhaseID)
	}
	if m.key != nil {
		fields = append(fields, subscriptionitem.FieldKey)
	}
	if m.entitlement != nil {
		fields = append(fields, subscriptionitem.FieldEntitlementID)
	}
	if m.restarts_billing_period != nil {
		fields = append(fields, subscriptionitem.FieldRestartsBillingPeriod)
	}
	if m.active_from_override_relative_to_phase_start != nil {
		fields = append(fields, subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart)
	}
	if m.active_to_override_relative_to_phase_start != nil {
		fields = append(fields, subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart)
	}
	if m.name != nil {
		fields = append(fields, subscriptionitem.FieldName)
	}
	if m.description != nil {
		fields = append(fields, subscriptionitem.FieldDescription)
	}
	if m.feature_key != nil {
		fields = append(fields, subscriptionitem.FieldFeatureKey)
	}
	if m.entitlement_template != nil {
		fields = append(fields, subscriptionitem.FieldEntitlementTemplate)
	}
	if m.tax_config != nil {
		fields = append(fields, subscriptionitem.FieldTaxConfig)
	}
	if m.billing_cadence != nil {
		fields = append(fields, subscriptionitem.FieldBillingCadence)
	}
	if m.price != nil {
		fields = append(fields, subscriptionitem.FieldPrice)
	}
	if m.discounts != nil {
		fields = append(fields, subscriptionitem.FieldDiscounts)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptionitem.FieldNamespace:
		return m.Namespace()
	case subscriptionitem.FieldCreatedAt:
		return m.CreatedAt()
	case subscriptionitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscriptionitem.FieldDeletedAt:
		return m.DeletedAt()
	case subscriptionitem.FieldMetadata:
		return m.Metadata()
	case subscriptionitem.FieldAnnotations:
		return m.Annotations()
	case subscriptionitem.FieldActiveFrom:
		return m.ActiveFrom()
	case subscriptionitem.FieldActiveTo:
		return m.ActiveTo()
	case subscriptionitem.FieldPhaseID:
		return m.PhaseID()
	case subscriptionitem.FieldKey:
		return m.Key()
	case subscriptionitem.FieldEntitlementID:
		return m.EntitlementID()
	case subscriptionitem.FieldRestartsBillingPeriod:
		return m.RestartsBillingPeriod()
	case subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart:
		return m.ActiveFromOverrideRelativeToPhaseStart()
	case subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart:
		return m.ActiveToOverrideRelativeToPhaseStart()
	case subscriptionitem.FieldName:
		return m.Name()
	case subscriptionitem.FieldDescription:
		return m.Description()
	case subscriptionitem.FieldFeatureKey:
		return m.FeatureKey()
	case subscriptionitem.FieldEntitlementTemplate:
		return m.EntitlementTemplate()
	case subscriptionitem.FieldTaxConfig:
		return m.TaxConfig()
	case subscriptionitem.FieldBillingCadence:
		return m.BillingCadence()
	case subscriptionitem.FieldPrice:
		return m.Price()
	case subscriptionitem.FieldDiscounts:
		return m.Discounts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptionitem.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscriptionitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriptionitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscriptionitem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscriptionitem.FieldMetadata:
		return m.OldMetadata(ctx)
	case subscriptionitem.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case subscriptionitem.FieldActiveFrom:
		return m.OldActiveFrom(ctx)
	case subscriptionitem.FieldActiveTo:
		return m.OldActiveTo(ctx)
	case subscriptionitem.FieldPhaseID:
		return m.OldPhaseID(ctx)
	case subscriptionitem.FieldKey:
		return m.OldKey(ctx)
	case subscriptionitem.FieldEntitlementID:
		return m.OldEntitlementID(ctx)
	case subscriptionitem.FieldRestartsBillingPeriod:
		return m.OldRestartsBillingPeriod(ctx)
	case subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart:
		return m.OldActiveFromOverrideRelativeToPhaseStart(ctx)
	case subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart:
		return m.OldActiveToOverrideRelativeToPhaseStart(ctx)
	case subscriptionitem.FieldName:
		return m.OldName(ctx)
	case subscriptionitem.FieldDescription:
		return m.OldDescription(ctx)
	case subscriptionitem.FieldFeatureKey:
		return m.OldFeatureKey(ctx)
	case subscriptionitem.FieldEntitlementTemplate:
		return m.OldEntitlementTemplate(ctx)
	case subscriptionitem.FieldTaxConfig:
		return m.OldTaxConfig(ctx)
	case subscriptionitem.FieldBillingCadence:
		return m.OldBillingCadence(ctx)
	case subscriptionitem.FieldPrice:
		return m.OldPrice(ctx)
	case subscriptionitem.FieldDiscounts:
		return m.OldDiscounts(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptionitem.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscriptionitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriptionitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscriptionitem.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscriptionitem.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case subscriptionitem.FieldAnnotations:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case subscriptionitem.FieldActiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveFrom(v)
		return nil
	case subscriptionitem.FieldActiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveTo(v)
		return nil
	case subscriptionitem.FieldPhaseID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhaseID(v)
		return nil
	case subscriptionitem.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case subscriptionitem.FieldEntitlementID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementID(v)
		return nil
	case subscriptionitem.FieldRestartsBillingPeriod:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestartsBillingPeriod(v)
		return nil
	case subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveFromOverrideRelativeToPhaseStart(v)
		return nil
	case subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveToOverrideRelativeToPhaseStart(v)
		return nil
	case subscriptionitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subscriptionitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subscriptionitem.FieldFeatureKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureKey(v)
		return nil
	case subscriptionitem.FieldEntitlementTemplate:
		v, ok := value.(*productcatalog.EntitlementTemplate)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementTemplate(v)
		return nil
	case subscriptionitem.FieldTaxConfig:
		v, ok := value.(*productcatalog.TaxConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxConfig(v)
		return nil
	case subscriptionitem.FieldBillingCadence:
		v, ok := value.(isodate.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingCadence(v)
		return nil
	case subscriptionitem.FieldPrice:
		v, ok := value.(*productcatalog.Price)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case subscriptionitem.FieldDiscounts:
		v, ok := value.(*productcatalog.Discounts)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscounts(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubscriptionItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriptionitem.FieldDeletedAt) {
		fields = append(fields, subscriptionitem.FieldDeletedAt)
	}
	if m.FieldCleared(subscriptionitem.FieldMetadata) {
		fields = append(fields, subscriptionitem.FieldMetadata)
	}
	if m.FieldCleared(subscriptionitem.FieldAnnotations) {
		fields = append(fields, subscriptionitem.FieldAnnotations)
	}
	if m.FieldCleared(subscriptionitem.FieldActiveTo) {
		fields = append(fields, subscriptionitem.FieldActiveTo)
	}
	if m.FieldCleared(subscriptionitem.FieldEntitlementID) {
		fields = append(fields, subscriptionitem.FieldEntitlementID)
	}
	if m.FieldCleared(subscriptionitem.FieldRestartsBillingPeriod) {
		fields = append(fields, subscriptionitem.FieldRestartsBillingPeriod)
	}
	if m.FieldCleared(subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart) {
		fields = append(fields, subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart)
	}
	if m.FieldCleared(subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart) {
		fields = append(fields, subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart)
	}
	if m.FieldCleared(subscriptionitem.FieldDescription) {
		fields = append(fields, subscriptionitem.FieldDescription)
	}
	if m.FieldCleared(subscriptionitem.FieldFeatureKey) {
		fields = append(fields, subscriptionitem.FieldFeatureKey)
	}
	if m.FieldCleared(subscriptionitem.FieldEntitlementTemplate) {
		fields = append(fields, subscriptionitem.FieldEntitlementTemplate)
	}
	if m.FieldCleared(subscriptionitem.FieldTaxConfig) {
		fields = append(fields, subscriptionitem.FieldTaxConfig)
	}
	if m.FieldCleared(subscriptionitem.FieldBillingCadence) {
		fields = append(fields, subscriptionitem.FieldBillingCadence)
	}
	if m.FieldCleared(subscriptionitem.FieldPrice) {
		fields = append(fields, subscriptionitem.FieldPrice)
	}
	if m.FieldCleared(subscriptionitem.FieldDiscounts) {
		fields = append(fields, subscriptionitem.FieldDiscounts)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionItemMutation) ClearField(name string) error {
	switch name {
	case subscriptionitem.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscriptionitem.FieldMetadata:
		m.ClearMetadata()
		return nil
	case subscriptionitem.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case subscriptionitem.FieldActiveTo:
		m.ClearActiveTo()
		return nil
	case subscriptionitem.FieldEntitlementID:
		m.ClearEntitlementID()
		return nil
	case subscriptionitem.FieldRestartsBillingPeriod:
		m.ClearRestartsBillingPeriod()
		return nil
	case subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart:
		m.ClearActiveFromOverrideRelativeToPhaseStart()
		return nil
	case subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart:
		m.ClearActiveToOverrideRelativeToPhaseStart()
		return nil
	case subscriptionitem.FieldDescription:
		m.ClearDescription()
		return nil
	case subscriptionitem.FieldFeatureKey:
		m.ClearFeatureKey()
		return nil
	case subscriptionitem.FieldEntitlementTemplate:
		m.ClearEntitlementTemplate()
		return nil
	case subscriptionitem.FieldTaxConfig:
		m.ClearTaxConfig()
		return nil
	case subscriptionitem.FieldBillingCadence:
		m.ClearBillingCadence()
		return nil
	case subscriptionitem.FieldPrice:
		m.ClearPrice()
		return nil
	case subscriptionitem.FieldDiscounts:
		m.ClearDiscounts()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionItemMutation) ResetField(name string) error {
	switch name {
	case subscriptionitem.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscriptionitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriptionitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscriptionitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscriptionitem.FieldMetadata:
		m.ResetMetadata()
		return nil
	case subscriptionitem.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case subscriptionitem.FieldActiveFrom:
		m.ResetActiveFrom()
		return nil
	case subscriptionitem.FieldActiveTo:
		m.ResetActiveTo()
		return nil
	case subscriptionitem.FieldPhaseID:
		m.ResetPhaseID()
		return nil
	case subscriptionitem.FieldKey:
		m.ResetKey()
		return nil
	case subscriptionitem.FieldEntitlementID:
		m.ResetEntitlementID()
		return nil
	case subscriptionitem.FieldRestartsBillingPeriod:
		m.ResetRestartsBillingPeriod()
		return nil
	case subscriptionitem.FieldActiveFromOverrideRelativeToPhaseStart:
		m.ResetActiveFromOverrideRelativeToPhaseStart()
		return nil
	case subscriptionitem.FieldActiveToOverrideRelativeToPhaseStart:
		m.ResetActiveToOverrideRelativeToPhaseStart()
		return nil
	case subscriptionitem.FieldName:
		m.ResetName()
		return nil
	case subscriptionitem.FieldDescription:
		m.ResetDescription()
		return nil
	case subscriptionitem.FieldFeatureKey:
		m.ResetFeatureKey()
		return nil
	case subscriptionitem.FieldEntitlementTemplate:
		m.ResetEntitlementTemplate()
		return nil
	case subscriptionitem.FieldTaxConfig:
		m.ResetTaxConfig()
		return nil
	case subscriptionitem.FieldBillingCadence:
		m.ResetBillingCadence()
		return nil
	case subscriptionitem.FieldPrice:
		m.ResetPrice()
		return nil
	case subscriptionitem.FieldDiscounts:
		m.ResetDiscounts()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.phase != nil {
		edges = append(edges, subscriptionitem.EdgePhase)
	}
	if m.entitlement != nil {
		edges = append(edges, subscriptionitem.EdgeEntitlement)
	}
	if m.billing_lines != nil {
		edges = append(edges, subscriptionitem.EdgeBillingLines)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptionitem.EdgePhase:
		if id := m.phase; id != nil {
			return []ent.Value{*id}
		}
	case subscriptionitem.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	case subscriptionitem.EdgeBillingLines:
		ids := make([]ent.Value, 0, len(m.billing_lines))
		for id := range m.billing_lines {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbilling_lines != nil {
		edges = append(edges, subscriptionitem.EdgeBillingLines)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscriptionitem.EdgeBillingLines:
		ids := make([]ent.Value, 0, len(m.removedbilling_lines))
		for id := range m.removedbilling_lines {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedphase {
		edges = append(edges, subscriptionitem.EdgePhase)
	}
	if m.clearedentitlement {
		edges = append(edges, subscriptionitem.EdgeEntitlement)
	}
	if m.clearedbilling_lines {
		edges = append(edges, subscriptionitem.EdgeBillingLines)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionItemMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptionitem.EdgePhase:
		return m.clearedphase
	case subscriptionitem.EdgeEntitlement:
		return m.clearedentitlement
	case subscriptionitem.EdgeBillingLines:
		return m.clearedbilling_lines
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionItemMutation) ClearEdge(name string) error {
	switch name {
	case subscriptionitem.EdgePhase:
		m.ClearPhase()
		return nil
	case subscriptionitem.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionItemMutation) ResetEdge(name string) error {
	switch name {
	case subscriptionitem.EdgePhase:
		m.ResetPhase()
		return nil
	case subscriptionitem.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	case subscriptionitem.EdgeBillingLines:
		m.ResetBillingLines()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionItem edge %s", name)
}

// SubscriptionPhaseMutation represents an operation that mutates the SubscriptionPhase nodes in the graph.
type SubscriptionPhaseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	namespace            *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	metadata             *map[string]string
	key                  *string
	name                 *string
	description          *string
	active_from          *time.Time
	clearedFields        map[string]struct{}
	subscription         *string
	clearedsubscription  bool
	items                map[string]struct{}
	removeditems         map[string]struct{}
	cleareditems         bool
	billing_lines        map[string]struct{}
	removedbilling_lines map[string]struct{}
	clearedbilling_lines bool
	done                 bool
	oldValue             func(context.Context) (*SubscriptionPhase, error)
	predicates           []predicate.SubscriptionPhase
}

var _ ent.Mutation = (*SubscriptionPhaseMutation)(nil)

// subscriptionphaseOption allows management of the mutation configuration using functional options.
type subscriptionphaseOption func(*SubscriptionPhaseMutation)

// newSubscriptionPhaseMutation creates new mutation for the SubscriptionPhase entity.
func newSubscriptionPhaseMutation(c config, op Op, opts ...subscriptionphaseOption) *SubscriptionPhaseMutation {
	m := &SubscriptionPhaseMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionPhase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionPhaseID sets the ID field of the mutation.
func withSubscriptionPhaseID(id string) subscriptionphaseOption {
	return func(m *SubscriptionPhaseMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionPhase
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionPhase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionPhase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionPhase sets the old SubscriptionPhase of the mutation.
func withSubscriptionPhase(node *SubscriptionPhase) subscriptionphaseOption {
	return func(m *SubscriptionPhaseMutation) {
		m.oldValue = func(context.Context) (*SubscriptionPhase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionPhaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionPhaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionPhase entities.
func (m *SubscriptionPhaseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionPhaseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionPhaseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionPhase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SubscriptionPhaseMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SubscriptionPhaseMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SubscriptionPhase entity.
// If the SubscriptionPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPhaseMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SubscriptionPhaseMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionPhaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionPhaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscriptionPhase entity.
// If the SubscriptionPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPhaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionPhaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionPhaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionPhaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscriptionPhase entity.
// If the SubscriptionPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPhaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionPhaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriptionPhaseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriptionPhaseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubscriptionPhase entity.
// If the SubscriptionPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPhaseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscriptionPhaseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscriptionphase.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscriptionPhaseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscriptionphase.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriptionPhaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscriptionphase.FieldDeletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *SubscriptionPhaseMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SubscriptionPhaseMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SubscriptionPhase entity.
// If the SubscriptionPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPhaseMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SubscriptionPhaseMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[subscriptionphase.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SubscriptionPhaseMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[subscriptionphase.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SubscriptionPhaseMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, subscriptionphase.FieldMetadata)
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *SubscriptionPhaseMutation) SetSubscriptionID(s string) {
	m.subscription = &s
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *SubscriptionPhaseMutation) SubscriptionID() (r string, exists bool) {
	v := m.subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the SubscriptionPhase entity.
// If the SubscriptionPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPhaseMutation) OldSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *SubscriptionPhaseMutation) ResetSubscriptionID() {
	m.subscription = nil
}

// SetKey sets the "key" field.
func (m *SubscriptionPhaseMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SubscriptionPhaseMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the SubscriptionPhase entity.
// If the SubscriptionPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPhaseMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SubscriptionPhaseMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *SubscriptionPhaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubscriptionPhaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SubscriptionPhase entity.
// If the SubscriptionPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPhaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubscriptionPhaseMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SubscriptionPhaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubscriptionPhaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SubscriptionPhase entity.
// If the SubscriptionPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPhaseMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubscriptionPhaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subscriptionphase.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubscriptionPhaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subscriptionphase.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubscriptionPhaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subscriptionphase.FieldDescription)
}

// SetActiveFrom sets the "active_from" field.
func (m *SubscriptionPhaseMutation) SetActiveFrom(t time.Time) {
	m.active_from = &t
}

// ActiveFrom returns the value of the "active_from" field in the mutation.
func (m *SubscriptionPhaseMutation) ActiveFrom() (r time.Time, exists bool) {
	v := m.active_from
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveFrom returns the old "active_from" field's value of the SubscriptionPhase entity.
// If the SubscriptionPhase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionPhaseMutation) OldActiveFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveFrom: %w", err)
	}
	return oldValue.ActiveFrom, nil
}

// ResetActiveFrom resets all changes to the "active_from" field.
func (m *SubscriptionPhaseMutation) ResetActiveFrom() {
	m.active_from = nil
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *SubscriptionPhaseMutation) ClearSubscription() {
	m.clearedsubscription = true
	m.clearedFields[subscriptionphase.FieldSubscriptionID] = struct{}{}
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *SubscriptionPhaseMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *SubscriptionPhaseMutation) SubscriptionIDs() (ids []string) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *SubscriptionPhaseMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// AddItemIDs adds the "items" edge to the SubscriptionItem entity by ids.
func (m *SubscriptionPhaseMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the SubscriptionItem entity.
func (m *SubscriptionPhaseMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the SubscriptionItem entity was cleared.
func (m *SubscriptionPhaseMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the SubscriptionItem entity by IDs.
func (m *SubscriptionPhaseMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the SubscriptionItem entity.
func (m *SubscriptionPhaseMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *SubscriptionPhaseMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *SubscriptionPhaseMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddBillingLineIDs adds the "billing_lines" edge to the BillingInvoiceLine entity by ids.
func (m *SubscriptionPhaseMutation) AddBillingLineIDs(ids ...string) {
	if m.billing_lines == nil {
		m.billing_lines = make(map[string]struct{})
	}
	for i := range ids {
		m.billing_lines[ids[i]] = struct{}{}
	}
}

// ClearBillingLines clears the "billing_lines" edge to the BillingInvoiceLine entity.
func (m *SubscriptionPhaseMutation) ClearBillingLines() {
	m.clearedbilling_lines = true
}

// BillingLinesCleared reports if the "billing_lines" edge to the BillingInvoiceLine entity was cleared.
func (m *SubscriptionPhaseMutation) BillingLinesCleared() bool {
	return m.clearedbilling_lines
}

// RemoveBillingLineIDs removes the "billing_lines" edge to the BillingInvoiceLine entity by IDs.
func (m *SubscriptionPhaseMutation) RemoveBillingLineIDs(ids ...string) {
	if m.removedbilling_lines == nil {
		m.removedbilling_lines = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.billing_lines, ids[i])
		m.removedbilling_lines[ids[i]] = struct{}{}
	}
}

// RemovedBillingLines returns the removed IDs of the "billing_lines" edge to the BillingInvoiceLine entity.
func (m *SubscriptionPhaseMutation) RemovedBillingLinesIDs() (ids []string) {
	for id := range m.removedbilling_lines {
		ids = append(ids, id)
	}
	return
}

// BillingLinesIDs returns the "billing_lines" edge IDs in the mutation.
func (m *SubscriptionPhaseMutation) BillingLinesIDs() (ids []string) {
	for id := range m.billing_lines {
		ids = append(ids, id)
	}
	return
}

// ResetBillingLines resets all changes to the "billing_lines" edge.
func (m *SubscriptionPhaseMutation) ResetBillingLines() {
	m.billing_lines = nil
	m.clearedbilling_lines = false
	m.removedbilling_lines = nil
}

// Where appends a list predicates to the SubscriptionPhaseMutation builder.
func (m *SubscriptionPhaseMutation) Where(ps ...predicate.SubscriptionPhase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionPhaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionPhaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionPhase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionPhaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionPhaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionPhase).
func (m *SubscriptionPhaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionPhaseMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.namespace != nil {
		fields = append(fields, subscriptionphase.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, subscriptionphase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriptionphase.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscriptionphase.FieldDeletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, subscriptionphase.FieldMetadata)
	}
	if m.subscription != nil {
		fields = append(fields, subscriptionphase.FieldSubscriptionID)
	}
	if m.key != nil {
		fields = append(fields, subscriptionphase.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, subscriptionphase.FieldName)
	}
	if m.description != nil {
		fields = append(fields, subscriptionphase.FieldDescription)
	}
	if m.active_from != nil {
		fields = append(fields, subscriptionphase.FieldActiveFrom)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionPhaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptionphase.FieldNamespace:
		return m.Namespace()
	case subscriptionphase.FieldCreatedAt:
		return m.CreatedAt()
	case subscriptionphase.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscriptionphase.FieldDeletedAt:
		return m.DeletedAt()
	case subscriptionphase.FieldMetadata:
		return m.Metadata()
	case subscriptionphase.FieldSubscriptionID:
		return m.SubscriptionID()
	case subscriptionphase.FieldKey:
		return m.Key()
	case subscriptionphase.FieldName:
		return m.Name()
	case subscriptionphase.FieldDescription:
		return m.Description()
	case subscriptionphase.FieldActiveFrom:
		return m.ActiveFrom()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionPhaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptionphase.FieldNamespace:
		return m.OldNamespace(ctx)
	case subscriptionphase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriptionphase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscriptionphase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscriptionphase.FieldMetadata:
		return m.OldMetadata(ctx)
	case subscriptionphase.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case subscriptionphase.FieldKey:
		return m.OldKey(ctx)
	case subscriptionphase.FieldName:
		return m.OldName(ctx)
	case subscriptionphase.FieldDescription:
		return m.OldDescription(ctx)
	case subscriptionphase.FieldActiveFrom:
		return m.OldActiveFrom(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionPhase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionPhaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptionphase.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case subscriptionphase.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriptionphase.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscriptionphase.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscriptionphase.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case subscriptionphase.FieldSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case subscriptionphase.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case subscriptionphase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subscriptionphase.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subscriptionphase.FieldActiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveFrom(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPhase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionPhaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionPhaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionPhaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubscriptionPhase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionPhaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriptionphase.FieldDeletedAt) {
		fields = append(fields, subscriptionphase.FieldDeletedAt)
	}
	if m.FieldCleared(subscriptionphase.FieldMetadata) {
		fields = append(fields, subscriptionphase.FieldMetadata)
	}
	if m.FieldCleared(subscriptionphase.FieldDescription) {
		fields = append(fields, subscriptionphase.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionPhaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionPhaseMutation) ClearField(name string) error {
	switch name {
	case subscriptionphase.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscriptionphase.FieldMetadata:
		m.ClearMetadata()
		return nil
	case subscriptionphase.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPhase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionPhaseMutation) ResetField(name string) error {
	switch name {
	case subscriptionphase.FieldNamespace:
		m.ResetNamespace()
		return nil
	case subscriptionphase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriptionphase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscriptionphase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscriptionphase.FieldMetadata:
		m.ResetMetadata()
		return nil
	case subscriptionphase.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case subscriptionphase.FieldKey:
		m.ResetKey()
		return nil
	case subscriptionphase.FieldName:
		m.ResetName()
		return nil
	case subscriptionphase.FieldDescription:
		m.ResetDescription()
		return nil
	case subscriptionphase.FieldActiveFrom:
		m.ResetActiveFrom()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPhase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionPhaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.subscription != nil {
		edges = append(edges, subscriptionphase.EdgeSubscription)
	}
	if m.items != nil {
		edges = append(edges, subscriptionphase.EdgeItems)
	}
	if m.billing_lines != nil {
		edges = append(edges, subscriptionphase.EdgeBillingLines)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionPhaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptionphase.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	case subscriptionphase.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case subscriptionphase.EdgeBillingLines:
		ids := make([]ent.Value, 0, len(m.billing_lines))
		for id := range m.billing_lines {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionPhaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeditems != nil {
		edges = append(edges, subscriptionphase.EdgeItems)
	}
	if m.removedbilling_lines != nil {
		edges = append(edges, subscriptionphase.EdgeBillingLines)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionPhaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscriptionphase.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case subscriptionphase.EdgeBillingLines:
		ids := make([]ent.Value, 0, len(m.removedbilling_lines))
		for id := range m.removedbilling_lines {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionPhaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsubscription {
		edges = append(edges, subscriptionphase.EdgeSubscription)
	}
	if m.cleareditems {
		edges = append(edges, subscriptionphase.EdgeItems)
	}
	if m.clearedbilling_lines {
		edges = append(edges, subscriptionphase.EdgeBillingLines)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionPhaseMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptionphase.EdgeSubscription:
		return m.clearedsubscription
	case subscriptionphase.EdgeItems:
		return m.cleareditems
	case subscriptionphase.EdgeBillingLines:
		return m.clearedbilling_lines
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionPhaseMutation) ClearEdge(name string) error {
	switch name {
	case subscriptionphase.EdgeSubscription:
		m.ClearSubscription()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPhase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionPhaseMutation) ResetEdge(name string) error {
	switch name {
	case subscriptionphase.EdgeSubscription:
		m.ResetSubscription()
		return nil
	case subscriptionphase.EdgeItems:
		m.ResetItems()
		return nil
	case subscriptionphase.EdgeBillingLines:
		m.ResetBillingLines()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionPhase edge %s", name)
}

// UsageResetMutation represents an operation that mutates the UsageReset nodes in the graph.
type UsageResetMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	namespace          *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	reset_time         *time.Time
	anchor             *time.Time
	clearedFields      map[string]struct{}
	entitlement        *string
	clearedentitlement bool
	done               bool
	oldValue           func(context.Context) (*UsageReset, error)
	predicates         []predicate.UsageReset
}

var _ ent.Mutation = (*UsageResetMutation)(nil)

// usageresetOption allows management of the mutation configuration using functional options.
type usageresetOption func(*UsageResetMutation)

// newUsageResetMutation creates new mutation for the UsageReset entity.
func newUsageResetMutation(c config, op Op, opts ...usageresetOption) *UsageResetMutation {
	m := &UsageResetMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageReset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageResetID sets the ID field of the mutation.
func withUsageResetID(id string) usageresetOption {
	return func(m *UsageResetMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageReset
		)
		m.oldValue = func(ctx context.Context) (*UsageReset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageReset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageReset sets the old UsageReset of the mutation.
func withUsageReset(node *UsageReset) usageresetOption {
	return func(m *UsageResetMutation) {
		m.oldValue = func(context.Context) (*UsageReset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageResetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageResetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UsageReset entities.
func (m *UsageResetMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageResetMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageResetMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageReset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *UsageResetMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *UsageResetMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *UsageResetMutation) ResetNamespace() {
	m.namespace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageResetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageResetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageResetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageResetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageResetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageResetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UsageResetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UsageResetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UsageResetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usagereset.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UsageResetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usagereset.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UsageResetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usagereset.FieldDeletedAt)
}

// SetEntitlementID sets the "entitlement_id" field.
func (m *UsageResetMutation) SetEntitlementID(s string) {
	m.entitlement = &s
}

// EntitlementID returns the value of the "entitlement_id" field in the mutation.
func (m *UsageResetMutation) EntitlementID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementID returns the old "entitlement_id" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldEntitlementID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementID: %w", err)
	}
	return oldValue.EntitlementID, nil
}

// ResetEntitlementID resets all changes to the "entitlement_id" field.
func (m *UsageResetMutation) ResetEntitlementID() {
	m.entitlement = nil
}

// SetResetTime sets the "reset_time" field.
func (m *UsageResetMutation) SetResetTime(t time.Time) {
	m.reset_time = &t
}

// ResetTime returns the value of the "reset_time" field in the mutation.
func (m *UsageResetMutation) ResetTime() (r time.Time, exists bool) {
	v := m.reset_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResetTime returns the old "reset_time" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldResetTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetTime: %w", err)
	}
	return oldValue.ResetTime, nil
}

// ResetResetTime resets all changes to the "reset_time" field.
func (m *UsageResetMutation) ResetResetTime() {
	m.reset_time = nil
}

// SetAnchor sets the "anchor" field.
func (m *UsageResetMutation) SetAnchor(t time.Time) {
	m.anchor = &t
}

// Anchor returns the value of the "anchor" field in the mutation.
func (m *UsageResetMutation) Anchor() (r time.Time, exists bool) {
	v := m.anchor
	if v == nil {
		return
	}
	return *v, true
}

// OldAnchor returns the old "anchor" field's value of the UsageReset entity.
// If the UsageReset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageResetMutation) OldAnchor(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnchor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnchor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnchor: %w", err)
	}
	return oldValue.Anchor, nil
}

// ResetAnchor resets all changes to the "anchor" field.
func (m *UsageResetMutation) ResetAnchor() {
	m.anchor = nil
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *UsageResetMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[usagereset.FieldEntitlementID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *UsageResetMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *UsageResetMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *UsageResetMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// Where appends a list predicates to the UsageResetMutation builder.
func (m *UsageResetMutation) Where(ps ...predicate.UsageReset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageResetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageResetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageReset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageResetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageResetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageReset).
func (m *UsageResetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageResetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.namespace != nil {
		fields = append(fields, usagereset.FieldNamespace)
	}
	if m.created_at != nil {
		fields = append(fields, usagereset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usagereset.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usagereset.FieldDeletedAt)
	}
	if m.entitlement != nil {
		fields = append(fields, usagereset.FieldEntitlementID)
	}
	if m.reset_time != nil {
		fields = append(fields, usagereset.FieldResetTime)
	}
	if m.anchor != nil {
		fields = append(fields, usagereset.FieldAnchor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageResetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagereset.FieldNamespace:
		return m.Namespace()
	case usagereset.FieldCreatedAt:
		return m.CreatedAt()
	case usagereset.FieldUpdatedAt:
		return m.UpdatedAt()
	case usagereset.FieldDeletedAt:
		return m.DeletedAt()
	case usagereset.FieldEntitlementID:
		return m.EntitlementID()
	case usagereset.FieldResetTime:
		return m.ResetTime()
	case usagereset.FieldAnchor:
		return m.Anchor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageResetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagereset.FieldNamespace:
		return m.OldNamespace(ctx)
	case usagereset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagereset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usagereset.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usagereset.FieldEntitlementID:
		return m.OldEntitlementID(ctx)
	case usagereset.FieldResetTime:
		return m.OldResetTime(ctx)
	case usagereset.FieldAnchor:
		return m.OldAnchor(ctx)
	}
	return nil, fmt.Errorf("unknown UsageReset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageResetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagereset.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case usagereset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagereset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usagereset.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usagereset.FieldEntitlementID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementID(v)
		return nil
	case usagereset.FieldResetTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetTime(v)
		return nil
	case usagereset.FieldAnchor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnchor(v)
		return nil
	}
	return fmt.Errorf("unknown UsageReset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageResetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageResetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageResetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UsageReset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageResetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagereset.FieldDeletedAt) {
		fields = append(fields, usagereset.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageResetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageResetMutation) ClearField(name string) error {
	switch name {
	case usagereset.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageReset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageResetMutation) ResetField(name string) error {
	switch name {
	case usagereset.FieldNamespace:
		m.ResetNamespace()
		return nil
	case usagereset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagereset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usagereset.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usagereset.FieldEntitlementID:
		m.ResetEntitlementID()
		return nil
	case usagereset.FieldResetTime:
		m.ResetResetTime()
		return nil
	case usagereset.FieldAnchor:
		m.ResetAnchor()
		return nil
	}
	return fmt.Errorf("unknown UsageReset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageResetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entitlement != nil {
		edges = append(edges, usagereset.EdgeEntitlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageResetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagereset.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageResetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageResetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageResetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentitlement {
		edges = append(edges, usagereset.EdgeEntitlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageResetMutation) EdgeCleared(name string) bool {
	switch name {
	case usagereset.EdgeEntitlement:
		return m.clearedentitlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageResetMutation) ClearEdge(name string) error {
	switch name {
	case usagereset.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown UsageReset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageResetMutation) ResetEdge(name string) error {
	switch name {
	case usagereset.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	}
	return fmt.Errorf("unknown UsageReset edge %s", name)
}
