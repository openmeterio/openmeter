// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"fmt"

	"github.com/openmeterio/openmeter/pkg/pagination"
)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AddonQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*Addon], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*Addon]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Addon] = (*AddonQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AddonRateCardQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*AddonRateCard], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*AddonRateCard]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AddonRateCard] = (*AddonRateCardQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*App], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*App]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*App] = (*AppQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppCustomInvoicingQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*AppCustomInvoicing], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*AppCustomInvoicing]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AppCustomInvoicing] = (*AppCustomInvoicingQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppCustomInvoicingCustomerQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*AppCustomInvoicingCustomer], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*AppCustomInvoicingCustomer]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AppCustomInvoicingCustomer] = (*AppCustomInvoicingCustomerQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppCustomerQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*AppCustomer], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*AppCustomer]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AppCustomer] = (*AppCustomerQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppStripeQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*AppStripe], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*AppStripe]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AppStripe] = (*AppStripeQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppStripeCustomerQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*AppStripeCustomer], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*AppStripeCustomer]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AppStripeCustomer] = (*AppStripeCustomerQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BalanceSnapshotQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BalanceSnapshot], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BalanceSnapshot]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BalanceSnapshot] = (*BalanceSnapshotQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingCustomerLockQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingCustomerLock], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingCustomerLock]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingCustomerLock] = (*BillingCustomerLockQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingCustomerOverrideQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingCustomerOverride], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingCustomerOverride]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingCustomerOverride] = (*BillingCustomerOverrideQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingInvoice], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingInvoice]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoice] = (*BillingInvoiceQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceFlatFeeLineConfigQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingInvoiceFlatFeeLineConfig], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingInvoiceFlatFeeLineConfig]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceFlatFeeLineConfig] = (*BillingInvoiceFlatFeeLineConfigQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceLineQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingInvoiceLine], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingInvoiceLine]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceLine] = (*BillingInvoiceLineQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceLineDiscountQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingInvoiceLineDiscount], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingInvoiceLineDiscount]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceLineDiscount] = (*BillingInvoiceLineDiscountQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceLineUsageDiscountQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingInvoiceLineUsageDiscount], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingInvoiceLineUsageDiscount]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceLineUsageDiscount] = (*BillingInvoiceLineUsageDiscountQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceUsageBasedLineConfigQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingInvoiceUsageBasedLineConfig], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingInvoiceUsageBasedLineConfig]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceUsageBasedLineConfig] = (*BillingInvoiceUsageBasedLineConfigQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceValidationIssueQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingInvoiceValidationIssue], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingInvoiceValidationIssue]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceValidationIssue] = (*BillingInvoiceValidationIssueQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingProfileQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingProfile], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingProfile]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingProfile] = (*BillingProfileQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingSequenceNumbersQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingSequenceNumbers], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingSequenceNumbers]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingSequenceNumbers] = (*BillingSequenceNumbersQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingWorkflowConfigQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*BillingWorkflowConfig], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*BillingWorkflowConfig]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingWorkflowConfig] = (*BillingWorkflowConfigQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *CustomerQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*Customer], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*Customer]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Customer] = (*CustomerQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *CustomerSubjectsQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*CustomerSubjects], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*CustomerSubjects]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*CustomerSubjects] = (*CustomerSubjectsQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *EntitlementQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*Entitlement], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*Entitlement]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Entitlement] = (*EntitlementQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *FeatureQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*Feature], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*Feature]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Feature] = (*FeatureQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *GrantQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*Grant], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*Grant]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Grant] = (*GrantQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *MeterQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*Meter], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*Meter]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Meter] = (*MeterQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *NotificationChannelQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*NotificationChannel], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*NotificationChannel]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*NotificationChannel] = (*NotificationChannelQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *NotificationEventQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*NotificationEvent], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*NotificationEvent]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*NotificationEvent] = (*NotificationEventQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *NotificationEventDeliveryStatusQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*NotificationEventDeliveryStatus], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*NotificationEventDeliveryStatus]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*NotificationEventDeliveryStatus] = (*NotificationEventDeliveryStatusQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *NotificationRuleQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*NotificationRule], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*NotificationRule]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*NotificationRule] = (*NotificationRuleQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *PlanQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*Plan], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*Plan]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Plan] = (*PlanQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *PlanAddonQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*PlanAddon], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*PlanAddon]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*PlanAddon] = (*PlanAddonQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *PlanPhaseQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*PlanPhase], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*PlanPhase]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*PlanPhase] = (*PlanPhaseQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *PlanRateCardQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*PlanRateCard], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*PlanRateCard]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*PlanRateCard] = (*PlanRateCardQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubjectQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*Subject], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*Subject]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Subject] = (*SubjectQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubscriptionQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*Subscription], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*Subscription]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Subscription] = (*SubscriptionQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubscriptionAddonQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*SubscriptionAddon], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*SubscriptionAddon]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*SubscriptionAddon] = (*SubscriptionAddonQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubscriptionAddonQuantityQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*SubscriptionAddonQuantity], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*SubscriptionAddonQuantity]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*SubscriptionAddonQuantity] = (*SubscriptionAddonQuantityQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubscriptionItemQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*SubscriptionItem], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*SubscriptionItem]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*SubscriptionItem] = (*SubscriptionItemQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubscriptionPhaseQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*SubscriptionPhase], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*SubscriptionPhase]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*SubscriptionPhase] = (*SubscriptionPhaseQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *UsageResetQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.PagedResponse[*UsageReset], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.PagedResponse[*UsageReset]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*UsageReset] = (*UsageResetQuery)(nil)
