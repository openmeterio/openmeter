// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"fmt"

	"github.com/openmeterio/openmeter/pkg/pagination"
)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AddonQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*Addon], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*Addon]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*Addon, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Addon] = (*AddonQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AddonRateCardQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*AddonRateCard], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*AddonRateCard]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*AddonRateCard, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AddonRateCard] = (*AddonRateCardQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*App], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*App]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*App, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*App] = (*AppQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppCustomInvoicingQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*AppCustomInvoicing], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*AppCustomInvoicing]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*AppCustomInvoicing, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AppCustomInvoicing] = (*AppCustomInvoicingQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppCustomInvoicingCustomerQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*AppCustomInvoicingCustomer], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*AppCustomInvoicingCustomer]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*AppCustomInvoicingCustomer, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AppCustomInvoicingCustomer] = (*AppCustomInvoicingCustomerQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppCustomerQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*AppCustomer], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*AppCustomer]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*AppCustomer, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AppCustomer] = (*AppCustomerQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppStripeQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*AppStripe], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*AppStripe]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*AppStripe, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AppStripe] = (*AppStripeQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *AppStripeCustomerQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*AppStripeCustomer], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*AppStripeCustomer]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*AppStripeCustomer, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*AppStripeCustomer] = (*AppStripeCustomerQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BalanceSnapshotQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BalanceSnapshot], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BalanceSnapshot]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BalanceSnapshot, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BalanceSnapshot] = (*BalanceSnapshotQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingCustomerLockQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingCustomerLock], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingCustomerLock]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingCustomerLock, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingCustomerLock] = (*BillingCustomerLockQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingCustomerOverrideQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingCustomerOverride], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingCustomerOverride]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingCustomerOverride, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingCustomerOverride] = (*BillingCustomerOverrideQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingInvoice], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingInvoice]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingInvoice, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoice] = (*BillingInvoiceQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceFlatFeeLineConfigQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingInvoiceFlatFeeLineConfig], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingInvoiceFlatFeeLineConfig]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingInvoiceFlatFeeLineConfig, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceFlatFeeLineConfig] = (*BillingInvoiceFlatFeeLineConfigQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceLineQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingInvoiceLine], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingInvoiceLine]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingInvoiceLine, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceLine] = (*BillingInvoiceLineQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceLineDiscountQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingInvoiceLineDiscount], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingInvoiceLineDiscount]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingInvoiceLineDiscount, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceLineDiscount] = (*BillingInvoiceLineDiscountQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceLineUsageDiscountQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingInvoiceLineUsageDiscount], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingInvoiceLineUsageDiscount]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingInvoiceLineUsageDiscount, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceLineUsageDiscount] = (*BillingInvoiceLineUsageDiscountQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceSplitLineGroupQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingInvoiceSplitLineGroup], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingInvoiceSplitLineGroup]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingInvoiceSplitLineGroup, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceSplitLineGroup] = (*BillingInvoiceSplitLineGroupQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceUsageBasedLineConfigQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingInvoiceUsageBasedLineConfig], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingInvoiceUsageBasedLineConfig]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingInvoiceUsageBasedLineConfig, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceUsageBasedLineConfig] = (*BillingInvoiceUsageBasedLineConfigQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingInvoiceValidationIssueQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingInvoiceValidationIssue], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingInvoiceValidationIssue]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingInvoiceValidationIssue, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingInvoiceValidationIssue] = (*BillingInvoiceValidationIssueQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingProfileQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingProfile], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingProfile]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingProfile, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingProfile] = (*BillingProfileQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingSequenceNumbersQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingSequenceNumbers], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingSequenceNumbers]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingSequenceNumbers, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingSequenceNumbers] = (*BillingSequenceNumbersQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *BillingWorkflowConfigQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*BillingWorkflowConfig], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*BillingWorkflowConfig]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*BillingWorkflowConfig, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*BillingWorkflowConfig] = (*BillingWorkflowConfigQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *CustomerQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*Customer], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*Customer]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*Customer, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Customer] = (*CustomerQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *CustomerSubjectsQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*CustomerSubjects], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*CustomerSubjects]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*CustomerSubjects, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*CustomerSubjects] = (*CustomerSubjectsQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *EntitlementQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*Entitlement], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*Entitlement]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*Entitlement, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Entitlement] = (*EntitlementQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *FeatureQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*Feature], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*Feature]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*Feature, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Feature] = (*FeatureQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *GrantQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*Grant], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*Grant]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*Grant, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Grant] = (*GrantQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *MeterQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*Meter], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*Meter]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*Meter, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Meter] = (*MeterQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *NotificationChannelQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*NotificationChannel], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*NotificationChannel]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*NotificationChannel, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*NotificationChannel] = (*NotificationChannelQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *NotificationEventQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*NotificationEvent], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*NotificationEvent]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*NotificationEvent, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*NotificationEvent] = (*NotificationEventQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *NotificationEventDeliveryStatusQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*NotificationEventDeliveryStatus], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*NotificationEventDeliveryStatus]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*NotificationEventDeliveryStatus, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*NotificationEventDeliveryStatus] = (*NotificationEventDeliveryStatusQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *NotificationRuleQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*NotificationRule], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*NotificationRule]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*NotificationRule, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*NotificationRule] = (*NotificationRuleQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *PlanQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*Plan], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*Plan]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*Plan, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Plan] = (*PlanQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *PlanAddonQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*PlanAddon], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*PlanAddon]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*PlanAddon, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*PlanAddon] = (*PlanAddonQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *PlanPhaseQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*PlanPhase], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*PlanPhase]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*PlanPhase, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*PlanPhase] = (*PlanPhaseQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *PlanRateCardQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*PlanRateCard], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*PlanRateCard]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*PlanRateCard, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*PlanRateCard] = (*PlanRateCardQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubjectQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*Subject], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*Subject]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*Subject, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Subject] = (*SubjectQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubscriptionQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*Subscription], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*Subscription]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*Subscription, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*Subscription] = (*SubscriptionQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubscriptionAddonQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*SubscriptionAddon], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*SubscriptionAddon]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*SubscriptionAddon, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*SubscriptionAddon] = (*SubscriptionAddonQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubscriptionAddonQuantityQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*SubscriptionAddonQuantity], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*SubscriptionAddonQuantity]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*SubscriptionAddonQuantity, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*SubscriptionAddonQuantity] = (*SubscriptionAddonQuantityQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubscriptionItemQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*SubscriptionItem], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*SubscriptionItem]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*SubscriptionItem, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*SubscriptionItem] = (*SubscriptionItemQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *SubscriptionPhaseQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*SubscriptionPhase], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*SubscriptionPhase]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*SubscriptionPhase, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*SubscriptionPhase] = (*SubscriptionPhaseQuery)(nil)

// Paginate runs the query and returns a paginated response.
// If page is its 0 value then it will return all the items and populate the response page accordingly.
func (_m *UsageResetQuery) Paginate(ctx context.Context, page pagination.Page) (pagination.Result[*UsageReset], error) {
	// Get the limit and offset
	limit, offset := page.Limit(), page.Offset()

	// Unset previous pagination settings
	zero := 0
	_m.ctx.Offset = &zero
	_m.ctx.Limit = &zero

	// Create duplicate of the query to run for
	countQuery := _m.Clone()
	pagedQuery := _m

	// Unset select for count query
	countQuery.ctx.Fields = []string{}

	// Unset ordering for count query
	countQuery.order = nil

	pagedResponse := pagination.Result[*UsageReset]{
		Page: page,
	}

	// Get the total count
	count, err := countQuery.Count(ctx)
	if err != nil {
		return pagedResponse, fmt.Errorf("failed to get count: %w", err)
	}
	pagedResponse.TotalCount = count

	// If there are no items, return the empty response early
	if count == 0 {
		// Items should be [] not null.
		pagedResponse.Items = make([]*UsageReset, 0)
		return pagedResponse, nil
	}

	// If page is its 0 value then return all the items
	if page.IsZero() {
		offset = 0
		limit = count
	}

	// Set the limit and offset
	pagedQuery.ctx.Limit = &limit
	pagedQuery.ctx.Offset = &offset

	// Get the paged items
	items, err := pagedQuery.All(ctx)
	pagedResponse.Items = items
	return pagedResponse, err
}

// type check
var _ pagination.Paginator[*UsageReset] = (*UsageResetQuery)(nil)
