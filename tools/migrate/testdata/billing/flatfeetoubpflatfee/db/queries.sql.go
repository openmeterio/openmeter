// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const getFlatFeeLinesByParentID = `-- name: GetFlatFeeLinesByParentID :many

SELECT l.id, l.namespace, l.metadata, l.created_at, l.updated_at, l.deleted_at, l.name, l.description, l.period_start, l.period_end, l.invoice_at, l.type, l.status, l.currency, l.quantity, l.tax_config, l.invoice_id, l.fee_line_config_id, l.usage_based_line_config_id, l.parent_line_id, l.child_unique_reference_id, l.amount, l.taxes_total, l.taxes_inclusive_total, l.taxes_exclusive_total, l.charges_total, l.discounts_total, l.total, l.invoicing_app_external_id, l.subscription_id, l.subscription_item_id, l.subscription_phase_id, l.line_ids, l.managed_by, l.ratecard_discounts, c.per_unit_amount, c.category, c.payment_term, c.index
FROM public.billing_invoice_lines l JOIN public.billing_invoice_flat_fee_line_configs c ON (l.fee_line_config_id = c.id)
WHERE type = 'flat_fee' AND status = 'detailed' AND l.parent_line_id = $1::varchar
`

type GetFlatFeeLinesByParentIDRow struct {
	ID                     string
	Namespace              string
	Metadata               pqtype.NullRawMessage
	CreatedAt              time.Time
	UpdatedAt              time.Time
	DeletedAt              sql.NullTime
	Name                   string
	Description            sql.NullString
	PeriodStart            time.Time
	PeriodEnd              time.Time
	InvoiceAt              time.Time
	Type                   string
	Status                 string
	Currency               string
	Quantity               sql.NullString
	TaxConfig              pqtype.NullRawMessage
	InvoiceID              string
	FeeLineConfigID        sql.NullString
	UsageBasedLineConfigID sql.NullString
	ParentLineID           sql.NullString
	ChildUniqueReferenceID sql.NullString
	Amount                 string
	TaxesTotal             string
	TaxesInclusiveTotal    string
	TaxesExclusiveTotal    string
	ChargesTotal           string
	DiscountsTotal         string
	Total                  string
	InvoicingAppExternalID sql.NullString
	SubscriptionID         sql.NullString
	SubscriptionItemID     sql.NullString
	SubscriptionPhaseID    sql.NullString
	LineIds                sql.NullString
	ManagedBy              string
	RatecardDiscounts      pqtype.NullRawMessage
	PerUnitAmount          string
	Category               string
	PaymentTerm            string
	Index                  sql.NullInt64
}

func (q *Queries) GetFlatFeeLinesByParentID(ctx context.Context, parentLineID string) ([]GetFlatFeeLinesByParentIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getFlatFeeLinesByParentID, parentLineID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlatFeeLinesByParentIDRow
	for rows.Next() {
		var i GetFlatFeeLinesByParentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Description,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.InvoiceAt,
			&i.Type,
			&i.Status,
			&i.Currency,
			&i.Quantity,
			&i.TaxConfig,
			&i.InvoiceID,
			&i.FeeLineConfigID,
			&i.UsageBasedLineConfigID,
			&i.ParentLineID,
			&i.ChildUniqueReferenceID,
			&i.Amount,
			&i.TaxesTotal,
			&i.TaxesInclusiveTotal,
			&i.TaxesExclusiveTotal,
			&i.ChargesTotal,
			&i.DiscountsTotal,
			&i.Total,
			&i.InvoicingAppExternalID,
			&i.SubscriptionID,
			&i.SubscriptionItemID,
			&i.SubscriptionPhaseID,
			&i.LineIds,
			&i.ManagedBy,
			&i.RatecardDiscounts,
			&i.PerUnitAmount,
			&i.Category,
			&i.PaymentTerm,
			&i.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParentID = `-- name: GetParentID :one
SELECT l.parent_line_id FROM public.billing_invoice_lines l WHERE l.id = $1::varchar
`

func (q *Queries) GetParentID(ctx context.Context, lineID string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getParentID, lineID)
	var parent_line_id sql.NullString
	err := row.Scan(&parent_line_id)
	return parent_line_id, err
}

const getUsageBasedLineByID = `-- name: GetUsageBasedLineByID :one

SELECT l.id, l.namespace, l.metadata, l.created_at, l.updated_at, l.deleted_at, l.name, l.description, l.period_start, l.period_end, l.invoice_at, l.type, l.status, l.currency, l.quantity, l.tax_config, l.invoice_id, l.fee_line_config_id, l.usage_based_line_config_id, l.parent_line_id, l.child_unique_reference_id, l.amount, l.taxes_total, l.taxes_inclusive_total, l.taxes_exclusive_total, l.charges_total, l.discounts_total, l.total, l.invoicing_app_external_id, l.subscription_id, l.subscription_item_id, l.subscription_phase_id, l.line_ids, l.managed_by, l.ratecard_discounts, c.price_type, c.feature_key, c.price, c.pre_line_period_quantity, c.metered_quantity, c.metered_pre_line_period_quantity
FROM public.billing_invoice_lines l JOIN public.billing_invoice_usage_based_line_configs c ON (l.usage_based_line_config_id = c.id)
WHERE type = 'usage_based' AND status = 'valid' AND l.id = $1::varchar
`

type GetUsageBasedLineByIDRow struct {
	ID                           string
	Namespace                    string
	Metadata                     pqtype.NullRawMessage
	CreatedAt                    time.Time
	UpdatedAt                    time.Time
	DeletedAt                    sql.NullTime
	Name                         string
	Description                  sql.NullString
	PeriodStart                  time.Time
	PeriodEnd                    time.Time
	InvoiceAt                    time.Time
	Type                         string
	Status                       string
	Currency                     string
	Quantity                     sql.NullString
	TaxConfig                    pqtype.NullRawMessage
	InvoiceID                    string
	FeeLineConfigID              sql.NullString
	UsageBasedLineConfigID       sql.NullString
	ParentLineID                 sql.NullString
	ChildUniqueReferenceID       sql.NullString
	Amount                       string
	TaxesTotal                   string
	TaxesInclusiveTotal          string
	TaxesExclusiveTotal          string
	ChargesTotal                 string
	DiscountsTotal               string
	Total                        string
	InvoicingAppExternalID       sql.NullString
	SubscriptionID               sql.NullString
	SubscriptionItemID           sql.NullString
	SubscriptionPhaseID          sql.NullString
	LineIds                      sql.NullString
	ManagedBy                    string
	RatecardDiscounts            pqtype.NullRawMessage
	PriceType                    string
	FeatureKey                   sql.NullString
	Price                        json.RawMessage
	PreLinePeriodQuantity        sql.NullString
	MeteredQuantity              sql.NullString
	MeteredPreLinePeriodQuantity sql.NullString
}

func (q *Queries) GetUsageBasedLineByID(ctx context.Context, lineID string) (GetUsageBasedLineByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUsageBasedLineByID, lineID)
	var i GetUsageBasedLineByIDRow
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Description,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.InvoiceAt,
		&i.Type,
		&i.Status,
		&i.Currency,
		&i.Quantity,
		&i.TaxConfig,
		&i.InvoiceID,
		&i.FeeLineConfigID,
		&i.UsageBasedLineConfigID,
		&i.ParentLineID,
		&i.ChildUniqueReferenceID,
		&i.Amount,
		&i.TaxesTotal,
		&i.TaxesInclusiveTotal,
		&i.TaxesExclusiveTotal,
		&i.ChargesTotal,
		&i.DiscountsTotal,
		&i.Total,
		&i.InvoicingAppExternalID,
		&i.SubscriptionID,
		&i.SubscriptionItemID,
		&i.SubscriptionPhaseID,
		&i.LineIds,
		&i.ManagedBy,
		&i.RatecardDiscounts,
		&i.PriceType,
		&i.FeatureKey,
		&i.Price,
		&i.PreLinePeriodQuantity,
		&i.MeteredQuantity,
		&i.MeteredPreLinePeriodQuantity,
	)
	return i, err
}
