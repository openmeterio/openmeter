// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const countLinesByStatusType = `-- name: CountLinesByStatusType :many
SELECT status, type, count(*)
    FROM public.billing_invoice_lines
    GROUP BY status, type
`

type CountLinesByStatusTypeRow struct {
	Status string
	Type   string
	Count  int64
}

func (q *Queries) CountLinesByStatusType(ctx context.Context) ([]CountLinesByStatusTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, countLinesByStatusType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountLinesByStatusTypeRow
	for rows.Next() {
		var i CountLinesByStatusTypeRow
		if err := rows.Scan(&i.Status, &i.Type, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitLineGroup = `-- name: GetSplitLineGroup :one
SELECT id, namespace, metadata, created_at, updated_at, deleted_at, name, description, service_period_start, service_period_end, currency, tax_config, unique_reference_id, ratecard_discounts, feature_key, price, subscription_id, subscription_item_id, subscription_phase_id
    FROM public.billing_invoice_split_line_groups
    WHERE id = $1
`

func (q *Queries) GetSplitLineGroup(ctx context.Context, id string) (BillingInvoiceSplitLineGroup, error) {
	row := q.db.QueryRowContext(ctx, getSplitLineGroup, id)
	var i BillingInvoiceSplitLineGroup
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Description,
		&i.ServicePeriodStart,
		&i.ServicePeriodEnd,
		&i.Currency,
		&i.TaxConfig,
		&i.UniqueReferenceID,
		&i.RatecardDiscounts,
		&i.FeatureKey,
		&i.Price,
		&i.SubscriptionID,
		&i.SubscriptionItemID,
		&i.SubscriptionPhaseID,
	)
	return i, err
}

const getUsageBasedLinesBySplitLineGroup = `-- name: GetUsageBasedLinesBySplitLineGroup :many
SELECT l.id, l.namespace, l.metadata, l.created_at, l.updated_at, l.deleted_at, l.name, l.description, l.period_start, l.period_end, l.invoice_at, l.type, l.status, l.currency, l.quantity, l.tax_config, l.invoice_id, l.fee_line_config_id, l.usage_based_line_config_id, l.parent_line_id, l.child_unique_reference_id, l.amount, l.taxes_total, l.taxes_inclusive_total, l.taxes_exclusive_total, l.charges_total, l.discounts_total, l.total, l.invoicing_app_external_id, l.subscription_id, l.subscription_item_id, l.subscription_phase_id, l.line_ids, l.managed_by, l.ratecard_discounts, l.split_line_group_id, c.price, c.feature_key
    FROM public.billing_invoice_lines l JOIN public.billing_invoice_usage_based_line_configs c ON (l.usage_based_line_config_id = c.id)
    WHERE type = 'usage_based' AND status = 'valid' AND split_line_group_id = $1
`

type GetUsageBasedLinesBySplitLineGroupRow struct {
	ID                     string
	Namespace              string
	Metadata               pqtype.NullRawMessage
	CreatedAt              time.Time
	UpdatedAt              time.Time
	DeletedAt              sql.NullTime
	Name                   string
	Description            sql.NullString
	PeriodStart            time.Time
	PeriodEnd              time.Time
	InvoiceAt              time.Time
	Type                   string
	Status                 string
	Currency               string
	Quantity               sql.NullString
	TaxConfig              pqtype.NullRawMessage
	InvoiceID              string
	FeeLineConfigID        sql.NullString
	UsageBasedLineConfigID sql.NullString
	ParentLineID           sql.NullString
	ChildUniqueReferenceID sql.NullString
	Amount                 string
	TaxesTotal             string
	TaxesInclusiveTotal    string
	TaxesExclusiveTotal    string
	ChargesTotal           string
	DiscountsTotal         string
	Total                  string
	InvoicingAppExternalID sql.NullString
	SubscriptionID         sql.NullString
	SubscriptionItemID     sql.NullString
	SubscriptionPhaseID    sql.NullString
	LineIds                sql.NullString
	ManagedBy              string
	RatecardDiscounts      pqtype.NullRawMessage
	SplitLineGroupID       sql.NullString
	Price                  json.RawMessage
	FeatureKey             sql.NullString
}

func (q *Queries) GetUsageBasedLinesBySplitLineGroup(ctx context.Context, splitLineGroupID sql.NullString) ([]GetUsageBasedLinesBySplitLineGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsageBasedLinesBySplitLineGroup, splitLineGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsageBasedLinesBySplitLineGroupRow
	for rows.Next() {
		var i GetUsageBasedLinesBySplitLineGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Description,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.InvoiceAt,
			&i.Type,
			&i.Status,
			&i.Currency,
			&i.Quantity,
			&i.TaxConfig,
			&i.InvoiceID,
			&i.FeeLineConfigID,
			&i.UsageBasedLineConfigID,
			&i.ParentLineID,
			&i.ChildUniqueReferenceID,
			&i.Amount,
			&i.TaxesTotal,
			&i.TaxesInclusiveTotal,
			&i.TaxesExclusiveTotal,
			&i.ChargesTotal,
			&i.DiscountsTotal,
			&i.Total,
			&i.InvoicingAppExternalID,
			&i.SubscriptionID,
			&i.SubscriptionItemID,
			&i.SubscriptionPhaseID,
			&i.LineIds,
			&i.ManagedBy,
			&i.RatecardDiscounts,
			&i.SplitLineGroupID,
			&i.Price,
			&i.FeatureKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
