package models

import (
	"errors"
	"fmt"
	"time"

	"github.com/openmeterio/openmeter/pkg/clock"
)

type ManagedUniqueResource struct {
	NamespacedModel
	ManagedModel

	// ID is the unique identifier for Resource.
	ID string `json:"id"`

	// Key is the unique key for Resource.
	Key string `json:"key"`
}

type ManagedResource struct {
	NamespacedModel
	ManagedModel

	// ID is the unique identifier for Resource.
	ID          string  `json:"id"`
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

type ManagedResourceInput struct {
	ID          string
	Namespace   string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   *time.Time
	Name        string
	Description *string
}

func (r ManagedResourceInput) Validate() error {
	if r.ID == "" {
		return errors.New("id is required")
	}

	if r.Namespace == "" {
		return errors.New("namespace is required")
	}

	if r.CreatedAt.IsZero() {
		return errors.New("created at is required")
	}

	if r.UpdatedAt.IsZero() {
		return errors.New("updated at is required")
	}

	return nil
}

func NewManagedResource(input ManagedResourceInput) ManagedResource {
	return ManagedResource{
		ID: input.ID,
		NamespacedModel: NamespacedModel{
			Namespace: input.Namespace,
		},
		ManagedModel: ManagedModel{
			CreatedAt: input.CreatedAt.UTC(),
			UpdatedAt: input.UpdatedAt.UTC(),
			DeletedAt: func() *time.Time {
				if input.DeletedAt == nil {
					return nil
				}

				deletedAt := input.DeletedAt.UTC()

				return &deletedAt
			}(),
		},
		Name:        input.Name,
		Description: input.Description,
	}
}

func (r ManagedResource) Validate() error {
	if err := r.NamespacedModel.Validate(); err != nil {
		return fmt.Errorf("error validating namespaced model: %w", err)
	}

	if err := r.ManagedModel.Validate(); err != nil {
		return fmt.Errorf("error validating managed model: %w", err)
	}

	if r.ID == "" {
		return errors.New("id is required")
	}

	if r.Name == "" {
		return errors.New("name is required")
	}

	return nil
}

type ManagedModel struct {
	CreatedAt time.Time `json:"createdAt"`
	// After creation the entity is considered updated.
	UpdatedAt time.Time `json:"updatedAt"`
	// Time of soft delete. If not null, the entity is considered deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
}

func (m ManagedModel) Validate() error {
	if m.CreatedAt.IsZero() {
		return errors.New("created at is required")
	}

	if m.UpdatedAt.IsZero() {
		return errors.New("updated at is required")
	}

	return nil
}

func (m ManagedModel) IsDeleted() bool {
	return m.IsDeletedAt(clock.Now())
}

func (m ManagedModel) IsDeletedAt(t time.Time) bool {
	if m.DeletedAt == nil {
		return false
	}

	return !m.DeletedAt.After(t)
}

type NamespacedModel struct {
	Namespace string `json:"-" yaml:"-"`
}

func (m NamespacedModel) Validate() error {
	if m.Namespace == "" {
		return errors.New("namespace is required")
	}

	return nil
}

type Address struct {
	Country     *CountryCode `json:"country,omitempty"`
	PostalCode  *string      `json:"postalCode,omitempty"`
	State       *string      `json:"state,omitempty"`
	City        *string      `json:"city,omitempty"`
	Line1       *string      `json:"line1,omitempty"`
	Line2       *string      `json:"line2,omitempty"`
	PhoneNumber *string      `json:"phoneNumber,omitempty"`
}

// [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.
type CountryCode string

// VersionedModel represents a versionable entity. With each new version the sequence is incremented
// while the key remains the same. Key + Version uniquely identifies an entity.
type VersionedModel struct {
	// Key is the unique identifier of the entity across its versions.
	// Might be generated by the system or provided by the user.
	Key string `json:"key,omitempty"`
	// Version is the integer sequential version of the entity, starting from 1.
	Version int `json:"version,omitempty"`
}

type (
	annotatedMarker bool // marker is used so only AnnotatedModel can implement Annotated
	Annotated       interface {
		annotated() annotatedMarker
	}
)

type AnnotatedModel struct {
	Metadata map[string]string `json:"metadata,omitempty"`
}

var _ Annotated = AnnotatedModel{}

func (a AnnotatedModel) annotated() annotatedMarker {
	return true
}

// Cadenced represents a model with active from and to dates.
// The interval described is inclusive on the from side and exclusive on the to side.
type (
	cadencedMarker bool // marker is used so only CadencedModel can implement Cadenced
	Cadenced       interface {
		cadenced() cadencedMarker
	}
)

type CadencedModel struct {
	ActiveFrom time.Time  `json:"activeFrom"`
	ActiveTo   *time.Time `json:"activeTo"`
}

var _ Cadenced = CadencedModel{}

func (c CadencedModel) cadenced() cadencedMarker {
	return true
}

func (c CadencedModel) IsActiveAt(t time.Time) bool {
	if c.ActiveFrom.After(t) {
		return false
	}

	if c.ActiveTo != nil && c.ActiveTo.Before(t) {
		return false
	}

	return true
}
