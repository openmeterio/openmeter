// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"fmt"
	"github.com/AppsFlyer/go-sundheit"
	http2 "github.com/AppsFlyer/go-sundheit/http"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-slog/otelslog"
	"github.com/google/wire"
	"github.com/openmeterio/openmeter/config"
	"github.com/openmeterio/openmeter/pkg/contextx"
	"github.com/openmeterio/openmeter/pkg/framework/operation"
	gosundheit2 "github.com/openmeterio/openmeter/pkg/gosundheit"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/samber/slog-multi"
	metric2 "go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/resource"
	"go.opentelemetry.io/otel/sdk/trace"
	"go.opentelemetry.io/otel/semconv/v1.20.0"
	"log/slog"
	"net/http"
	"os"
)

// Injectors from wire.go:

func InitializeApplication(ctx context.Context, conf config.Configuration) (Application, func(), error) {
	telemetryConfig := conf.Telemetry
	logTelemetryConfiguration := telemetryConfig.Log
	resource := ProvideOtelResource(conf)
	logger := ProvideLogger(logTelemetryConfiguration, resource)
	metricsTelemetryConfig := telemetryConfig.Metrics
	meterProvider, cleanup, err := ProvideOtelMeterProvider(ctx, metricsTelemetryConfig, resource, logger)
	if err != nil {
		return Application{}, nil, err
	}
	meter := ProvideOtelMeter(meterProvider)
	traceTelemetryConfig := telemetryConfig.Trace
	tracerProvider, cleanup2, err := ProvideOtelTracerProvider(ctx, traceTelemetryConfig, resource, logger)
	if err != nil {
		cleanup()
		return Application{}, nil, err
	}
	health := ProvideHealthChecker(logger)
	telemetryHandler := ProvideTelemetryHandler(metricsTelemetryConfig, health)
	application := ProvideApplication(logger, meterProvider, meter, tracerProvider, health, telemetryHandler)
	return application, func() {
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

type Application struct {
	Logger           *slog.Logger
	MeterProvider    *metric.MeterProvider
	Meter            metric2.Meter
	TracerProvider   *trace.TracerProvider
	HealthChecker    gosundheit.Health
	TelemetryHandler TelemetryHandler
}

func ProvideApplication(
	logger *slog.Logger,
	meterProvider *metric.MeterProvider,
	meter metric2.Meter,
	tracerProvider *trace.TracerProvider,
	healthChecker gosundheit.Health,
	telemetryHandler TelemetryHandler,
) Application {
	return Application{
		Logger:           logger,
		MeterProvider:    meterProvider,
		Meter:            meter,
		TracerProvider:   tracerProvider,
		HealthChecker:    healthChecker,
		TelemetryHandler: telemetryHandler,
	}
}

var set = wire.NewSet(config.Set, ProvideLogger,
	ProvideOtelResource,
	ProvideOtelMeterProvider,
	ProvideOtelMeter,
	ProvideOtelTracerProvider,
	ProvideHealthChecker,
	ProvideTelemetryHandler,
)

func ProvideLogger(conf config.LogTelemetryConfiguration, res *resource.Resource) *slog.Logger {
	logger := slog.New(slogmulti.Pipe(otelslog.NewHandler, contextx.NewLogHandler, operation.NewLogHandler).Handler(conf.NewHandler(os.Stdout)))

	logger = otelslog.WithResource(logger, res)

	return logger
}

func ProvideOtelResource(conf config.Configuration) *resource.Resource {
	extraResources, _ := resource.New(context.Background(), resource.WithContainer(), resource.WithAttributes(semconv.ServiceName("openmeter"), semconv.ServiceVersion(version), semconv.DeploymentEnvironment(conf.Environment)),
	)

	res, _ := resource.Merge(resource.Default(), extraResources)

	return res
}

func ProvideOtelMeterProvider(ctx context.Context, conf config.MetricsTelemetryConfig, res *resource.Resource, logger *slog.Logger) (*metric.MeterProvider, func(), error) {
	meterProvider, err := conf.NewMeterProvider(ctx, res)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to initialize OpenTelemetry Metrics provider: %w", err)
	}

	return meterProvider, func() {

		ctx, cancel := context.WithTimeout(context.Background(), defaultShutdownTimeout)
		defer cancel()

		if err := meterProvider.Shutdown(ctx); err != nil {
			logger.Error("shutting down meter provider", slog.String("error", err.Error()))
		}
	}, nil
}

func ProvideOtelMeter(meterProvider *metric.MeterProvider) metric2.Meter {
	return meterProvider.Meter(otelName)
}

func ProvideOtelTracerProvider(ctx context.Context, conf config.TraceTelemetryConfig, res *resource.Resource, logger *slog.Logger) (*trace.TracerProvider, func(), error) {
	tracerProvider, err := conf.NewTracerProvider(ctx, res)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to initialize OpenTelemetry Trace provider: %w", err)
	}

	return tracerProvider, func() {

		ctx, cancel := context.WithTimeout(context.Background(), defaultShutdownTimeout)
		defer cancel()

		if err := tracerProvider.Shutdown(ctx); err != nil {
			logger.Error("shutting down tracer provider", slog.String("error", err.Error()))
		}
	}, nil
}

func ProvideHealthChecker(logger *slog.Logger) gosundheit.Health {
	return gosundheit.New(gosundheit.WithCheckListeners(gosundheit2.NewLogger(logger.With(slog.String("component", "healthcheck")))))
}

type TelemetryHandler http.Handler

func ProvideTelemetryHandler(metricsConf config.MetricsTelemetryConfig, healthChecker gosundheit.Health) TelemetryHandler {
	router := chi.NewRouter()
	router.Mount("/debug", middleware.Profiler())

	if metricsConf.Exporters.Prometheus.Enabled {
		router.Handle("/metrics", promhttp.Handler())
	}

	handler := http2.HandleHealthJSON(healthChecker)
	router.Handle("/healthz", handler)

	router.HandleFunc("/healthz/live", func(w http.ResponseWriter, _ *http.Request) {
		_, _ = w.Write([]byte("ok"))
	})
	router.Handle("/healthz/ready", handler)

	return router
}
