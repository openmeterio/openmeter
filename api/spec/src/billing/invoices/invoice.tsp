import "@typespec/http";
import "@typespec/rest";
import "@typespec/openapi3";

using TypeSpec.Http;
using TypeSpec.Rest;
using TypeSpec.OpenAPI;

using OpenMeter.ProductCatalog;

namespace OpenMeter.Billing.Invoice;

/**
 * InvoiceNumber is a unique identifier for the invoice, generated by the
 * invoicing app.
 *
 * The uniqueness depends on a lot of factors:
 * - app setting (unique per app or unique per customer)
 * - multiple app scenarios (multiple apps generating invoices with the same prefix)
 */
@example("INV-2024-01-01-01")
@minLength(1)
@maxLength(256)
@friendlyName("InvoiceNumber")
scalar InvoiceNumber extends string;

/* Omitted fields (not required yet, from GOBL schema):
 * op_date: Date when the operation defined by the invoice became effective.
 * value_date: When the taxes of this invoice become accountable, if none set, the issue date is used.
 * exchange_rates: Exchange rates to be used when converting the invoices monetary values into other currencies.
 *    -> We are not supporting multi-currency invoices yet, so this is not supported.
 * charges: 	Charges or surcharges applied to the complete invoice.
 *    -> We are not supporting this yet.
 * outlays: 	Expenses paid for by the supplier but invoiced directly to the customer.
 *    -> We are not supporting this yet.
 * ordering: Ordering details including document references and buyer or seller parties.
 *    -> We are not supporting this yet (e.g. order handled by seperate entity, physical goods delivery details, etc.)
 * delivery: Specific details on delivery of the goods referenced in the invoice.
 *    -> We are not supporting physical goods delivery yet.
 * tax: Special tax configuration for billing.
 *    -> The prices include is the meaningful part, but we should make that an array, let's see if we need this as we implement more features.
 */
/**
 * Invoice represents an invoice in the system.
 */
@friendlyName("Invoice")
model Invoice {
  ...OmitProperties<global.Resource, "name">;

  /**
   * Type of the invoice.
   *
   * The type of invoice determines the purpose of the invoice and how it should be handled.
   *
   * Supported types:
   * - standard: A regular commercial invoice document between a supplier and customer.
   * - credit_note: Reflects a refund either partial or complete of the preceding document. A credit note effectively *extends* the previous document.
   */
  @visibility(Lifecycle.Read)
  type: InvoiceType;

  /**
   * The taxable entity supplying the goods or services.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  supplier: BillingParty;

  /**
   * Legal entity receiving the goods or services.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  customer: BillingParty;

  /**
   * Number specifies the human readable key used to reference this Invoice.
   *
   * The invoice number can change in the draft phases, as we are allocating temporary draft
   * invoice numbers, but it's final as soon as the invoice gets finalized (issued state).
   *
   * Please note that the number is (depending on the upstream settings) either unique for the
   * whole organization or unique for the customer, or in multi (stripe) account setups unique for the
   * account.
   */
  @visibility(Lifecycle.Read)
  number: InvoiceNumber;

  /**
   * Currency for all invoice line items.
   *
   * Multi currency invoices are not supported yet.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create)
  currency: CurrencyCode;

  /**
   * Key information regarding previous invoices and potentially details as to why they were corrected.
   */
  @visibility(Lifecycle.Read)
  preceding?: InvoiceDocumentRef[];

  /**
   * Summary of all the invoice totals, including taxes (calculated).
   */
  @visibility(Lifecycle.Read)
  totals: InvoiceTotals;

  /**
   * The status of the invoice.
   *
   * This field only conatins a simplified status, for more detailed information use the statusDetails field.
   */
  @visibility(Lifecycle.Read)
  status: InvoiceStatus;

  /**
   * The details of the current invoice status.
   */
  @visibility(Lifecycle.Read)
  statusDetails: InvoiceStatusDetails;

  /**
   * The time the invoice was issued.
   *
   * Depending on the status of the invoice this can mean multiple things:
   * - draft, gathering: The time the invoice will be issued based on the workflow settings.
   * - issued: The time the invoice was issued.
   */
  @visibility(Lifecycle.Read)
  issuedAt?: DateTime;

  /**
   * The time until the invoice is in draft status.
   *
   * On draft invoice creation it is calculated from the workflow settings.
   *
   * If manual approval is required, the draftUntil time is set.
   */
  @visibility(Lifecycle.Read, Lifecycle.Update)
  draftUntil?: DateTime;

  /**
   * Due time of the fulfillment of the invoice (if available).
   */
  @visibility(Lifecycle.Read)
  dueAt?: DateTime;

  /**
   * The period the invoice covers. If the invoice has no line items, it's not set.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create)
  period?: Period;

  /**
   * The time the invoice was voided.
   *
   * If the invoice was voided, this field will be set to the time the invoice was voided.
   */
  @visibility(Lifecycle.Read)
  voidedAt?: DateTime;

  /**
   * The time the invoice was sent to customer.
   */
  @visibility(Lifecycle.Read)
  sentToCustomerAt?: DateTime;

  /**
   * The workflow associated with the invoice.
   *
   * It is always a snapshot of the workflow settings at the time of invoice creation. The
   * field is optional as it should be explicitly requested with expand options.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  workflow: InvoiceWorkflowSettings;

  /**
   * List of invoice lines representing each of the items sold to the customer.
   */
  @visibility(Lifecycle.Read, Lifecycle.Update)
  lines?: InvoiceLine[];

  /**
   * Information on when, how, and to whom the invoice should be paid.
   */
  @visibility(Lifecycle.Read)
  payment?: InvoicePaymentTerms;

  /**
   * Validation issues reported by the invoice workflow.
   */
  @visibility(Lifecycle.Read)
  validationIssues?: ValidationIssue[];

  /**
   * External IDs of the invoice in other apps such as Stripe.
   */
  @visibility(Lifecycle.Read)
  externalIds?: InvoiceAppExternalIds;
}

/**
 * InvoiceAvailableActions represents the actions that can be performed on the invoice.
 */
@friendlyName("InvoiceAvailableActions")
model InvoiceAvailableActions {
  /**
   * Advance the invoice to the next status.
   */
  @visibility(Lifecycle.Read)
  advance?: InvoiceAvailableActionDetails;

  /**
   * Approve an invoice that requires manual approval.
   */
  @visibility(Lifecycle.Read)
  approve?: InvoiceAvailableActionDetails;

  /**
   * Delete the invoice (only non-issued invoices can be deleted).
   */
  @visibility(Lifecycle.Read)
  delete?: InvoiceAvailableActionDetails;

  /**
   * Retry an invoice issuing step that failed.
   */
  @visibility(Lifecycle.Read)
  retry?: InvoiceAvailableActionDetails;

  /**
   * Void an already issued invoice.
   */
  @visibility(Lifecycle.Read)
  `void`?: InvoiceAvailableActionDetails;

  /**
   * Invoice a gathering invoice
   */
  @visibility(Lifecycle.Read)
  invoice?: InvoiceAvailableActionInvoiceDetails;
}

/**
 * InvoiceAvailableActionInvoiceDetails represents the details of the invoice action for
 * non-gathering invoices.
 */
@friendlyName("InvoiceAvailableActionDetails")
model InvoiceAvailableActionDetails {
  /**
   * The state the invoice will reach if the action is activated and
   * all intermediate steps are successful.
   *
   * For example advancing a draft_created invoice will result in a draft_manual_approval_needed invoice.
   */
  @visibility(Lifecycle.Read)
  resultingState: InvoiceExtendedStatus;
}

/**
 * InvoiceAvailableActionInvoiceDetails represents the details of the invoice action for
 * gathering invoices.
 */
// Note: this is a placeholder for future extensibility
@friendlyName("InvoiceAvailableActionInvoiceDetails")
model InvoiceAvailableActionInvoiceDetails {}

/**
 * InvoiceStatusDetails represents the details of the invoice status.
 *
 * API users are encouraged to rely on the immutable/failed/avaliableActions fields to determine
 * the next steps of the invoice instead of the extendedStatus field.
 */
@friendlyName("InvoiceStatusDetails")
model InvoiceStatusDetails {
  /**
   * Is the invoice editable?
   */
  @visibility(Lifecycle.Read)
  immutable: boolean;

  /**
   * Is the invoice in a failed state?
   */
  @visibility(Lifecycle.Read)
  failed: boolean;

  /**
   * Extended status information for the invoice.
   */
  @visibility(Lifecycle.Read)
  extendedStatus: InvoiceExtendedStatus;

  /**
   * The actions that can be performed on the invoice.
   */
  availableActions: InvoiceAvailableActions;
}

// TODO[later]: we can make this an enum, but only if we have reached a stable state with the statuses.
scalar InvoiceExtendedStatus extends string;

/**
 * InvoiceWorkflowSettings represents the workflow settings used by the invoice.
 *
 * This is a clone of the billing profile's workflow settings at the time of invoice creation
 * with customer overrides considered.
 */
@friendlyName("InvoiceWorkflowSettings")
model InvoiceWorkflowSettings {
  /**
   * The apps that will be used to orchestrate the invoice's workflow.
   */
  @visibility(Lifecycle.Read)
  apps?: OpenMeter.Billing.BillingProfileAppsOrReference;

  /**
   * sourceBillingProfileID is the billing profile on which the workflow was based on.
   *
   * The profile is snapshotted on invoice creation, after which it can be altered independently
   * of the profile itself.
   */
  @visibility(Lifecycle.Read)
  sourceBillingProfileId: ULID;

  /**
   * The workflow details used by this invoice.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  workflow: OpenMeter.Billing.BillingWorkflow;
}

/**
 * InvoiceStatus describes the status of an invoice.
 */
@friendlyName("InvoiceStatus")
enum InvoiceStatus {
  /**
   * The list of line items for the next invoice is being gathered.
   */
  gathering: "gathering",

  /**
   * The invoice is in draft status.
   */
  draft: "draft",

  /**
   * The invoice is in the process of being issued.
   */
  issuing: "issuing",

  /**
   * The invoice has been issued to the customer.
   */
  issued: "issued",

  /**
   * The payment for the invoice is being processed.
   */
  paymentProcessing: "payment_processing",

  /**
   * The invoice's payment is overdue.
   */
  overdue: "overdue",

  /**
   * The invoice has been paid.
   */
  paid: "paid",

  /**
   * The invoice has been marked uncollectible.
   */
  uncollectible: "uncollectible",

  /**
   * The invoice has been voided.
   */
  voided: "voided",
}

/*
 * Omitted types: proforma, corrected, debit-note, other
 */
/**
 * InvoiceType represents the type of invoice.
 *
 * The type of invoice determines the purpose of the invoice and how it should be handled.
 */
@friendlyName("InvoiceType")
enum InvoiceType {
  /**
   * A regular commercial invoice document between a supplier and customer.
   */
  standard: "standard",

  /**
   * Reflects a refund either partial or complete of the preceding document. A credit note effectively *extends* the previous document.
   */
  creditNote: "credit_note",
}

/**
 * BillingInvoiceLine represents a line item that is sold to the customer based on a specific (unit) price.
 */
@friendlyName("InvoiceLine")
@discriminated(#{ envelope: "none", discriminatorPropertyName: "type" })
union InvoiceLine {
  usage_based: InvoiceUsageBasedLine,
  flat_fee: InvoiceFlatFeeLine,
}

/**
 * InvoiceLineReplaceUpdate represents the update model for an invoice line.
 */
@friendlyName("InvoiceLineReplaceUpdate")
@discriminated(#{ envelope: "none", discriminatorPropertyName: "type" })
union InvoiceLineReplaceUpdate {
  usage_based: InvoiceUsageBasedLineReplaceUpdate,
  flat_fee: InvoiceFlatFeeLineReplaceUpdate,
}

/**
 * InvoiceUpdateUsageBasedLineReplaceUpdate represents the update model for an UBP invoice line.
 *
 * This type makes ID optional to allow for creating new lines as part of the update.
 */
@friendlyName("InvoiceUsageBasedLineReplaceUpdate")
model InvoiceUsageBasedLineReplaceUpdate {
  ...Rest.Resource.ResourceReplaceModel<OmitProperties<
    InvoiceUsageBasedLine,
    "id"
  >>;

  /**
   * The ID of the line.
   */
  @visibility(Lifecycle.Update)
  id?: ULID;
}

/**
 * InvoiceFlatFeeLineReplaceUpdate represents the update model for a flat fee invoice line.
 *
 * This type makes ID optional to allow for creating new lines as part of the update.
 */
@friendlyName("InvoiceFlatFeeLineReplaceUpdate")
model InvoiceFlatFeeLineReplaceUpdate {
  ...Rest.Resource.ResourceReplaceModel<OmitProperties<
    InvoiceFlatFeeLine,
    "id"
  >>;

  /**
   * The ID of the line.
   */
  @visibility(Lifecycle.Update)
  id?: ULID;
}

/**
 * InvoiceLineCreate represents the create model for an invoice line.
 */
@friendlyName("InvoicePendingLineCreate")
@discriminated(#{ envelope: "none", discriminatorPropertyName: "type" })
union InvoicePendingLineCreate {
  usage_based: InvoiceUsageBasedPendingLineCreate,
  flat_fee: InvoiceFlatFeePendingLineCreate,
}

/**
 * InvoiceUsageBasedLineCreateWithCustomer represents the create model for an invoice line that is sold to the customer based on usage.
 */
@friendlyName("InvoiceUsageBasedPendingLineCreate")
model InvoiceUsageBasedPendingLineCreate {
  // Note: invoice is omitted as the line is assigned a new or existing gathering invoice
  ...Rest.Resource.ResourceCreateModel<OmitProperties<
    InvoiceUsageBasedLine,
    "invoice"
  >>;

  /**
   * The customer this line item belongs to.
   */
  @visibility(Lifecycle.Create)
  customerId: ULID;
}

/**
 * InvoiceFlatFeePendingLineCreate represents the create model for an invoice line that is sold to the customer as a manually added fee.
 */
@friendlyName("InvoiceFlatFeePendingLineCreate")
model InvoiceFlatFeePendingLineCreate {
  // Note: invoice is omitted as the line is assigned a new or existing gathering invoice
  ...Rest.Resource.ResourceCreateModel<OmitProperties<
    InvoiceFlatFeeLine,
    "invoice"
  >>;

  /**
   * The customer this line item belongs to.
   */
  @visibility(Lifecycle.Create)
  customerId: ULID;
}

/**
 * LineTypes represents the different types of lines that can be used in an invoice.
 */
@friendlyName("InvoiceLineTypes")
enum InvoiceLineTypes {
  flatFee: "flat_fee",
  usageBased: "usage_based",
}

/**
 * Line status specifies the status of the line.
 */
@friendlyName("InvoiceLineStatus")
enum InvoiceLineStatus {
  /**
   * The line is valid and can be used in the invoice.
   */
  valid: "valid",

  /**
   * The line is a detail line which is used to detail the individual
   * charges and discounts of a valid line.
   */
  detail: "detail",

  /**
   * The line has been split into multiple valid lines due to progressive
   * billing.
   */
  split: "split",
}

/**
 * InvoiceLineManagedBy specifies who manages the line.
 */
@friendlyName("InvoiceLineManagedBy")
enum InvoiceLineManagedBy {
  /**
   * The line is managed by the susbcription engine of OpenMeter.
   *
   * If there are any changes to the subscription the line will be updated accordingly.
   */
  subscription: "subscription",

  /**
   * The line is managed by the billing system of the OpenMeter.
   *
   * The line is immutable.
   */
  system: "system",

  /**
   * The line is managed via our API.
   *
   * If the line is coming from a subscription we will not update the line if the subscription changes.
   *
   * The only exception is that the period and invoiceAt fields will be updated in case of progressively billed
   * usage-based lines to maintain the coherence of the line structure. Any other fields edited will be kept as is.
   */
  manual: "manual",
}

/**
 * InvoiceLine represents a single item or service sold to the customer.
 *
 * This is a base class for all line types, and should not be used directly.
 * */
@friendlyName("InvoiceLineBase")
model InvoiceLineBase {
  // Note: ID has updated visibility as we support batch line creations and upserts
  ...OmitProperties<global.Resource, "id">;

  /**
   * ID of the line.
   */
  @visibility(Lifecycle.Read, Lifecycle.Update)
  id: ULID;

  /**
   * Type of the line.
   *
   * A line's type cannot be changed after creation.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create)
  type: InvoiceLineTypes;

  /**
   * managedBy specifies if the line is manually added via the api or managed by OpenMeter.
   */
  @visibility(Lifecycle.Read)
  managedBy: InvoiceLineManagedBy;

  /**
   * Status of the line.
   *
   * External calls always create valid lines, other line types are managed by the
   * billing engine of OpenMeter.
   */
  @visibility(Lifecycle.Read)
  status: InvoiceLineStatus;

  /**
   * Discounts detailes applied to this line.
   *
   * New discounts can be added via the invoice's discounts API, to facilitate
   * discounts that are affecting multiple lines.
   */
  @visibility(Lifecycle.Read)
  discounts?: InvoiceLineDiscounts;

  /**
   * The invoice this item belongs to.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create)
  invoice?: InvoiceReference;

  /**
   * The currency of this line.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create)
  currency: CurrencyCode;

  /**
   * Taxes applied to the invoice totals.
   */
  @visibility(Lifecycle.Read) // Tax is handled by the tax provider, we only need to show the output of that here
  taxes?: InvoiceLineTaxItem[];

  /**
   * Tax config specify the tax configuration for this line.
   */
  #deprecated "Use rateCard.taxConfig instead"
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  taxConfig?: OpenMeter.ProductCatalog.TaxConfig;

  /**
   * The lines detailing the item or service sold.
   */
  @visibility(Lifecycle.Read)
  children?: InvoiceLine[];

  /**
   * Totals for this line.
   */
  @visibility(Lifecycle.Read)
  totals: InvoiceTotals;

  /**
   * Period of the line item applies to for revenue recognition pruposes.
   *
   * Billing always treats periods as start being inclusive and end being exclusive.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  period: Period;

  /**
   * The time this line item should be invoiced.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  invoiceAt: DateTime;

  /**
   * External IDs of the invoice in other apps such as Stripe.
   */
  @visibility(Lifecycle.Read)
  externalIds?: InvoiceLineAppExternalIds;

  /**
   * Subscription are the references to the subscritpions that this line is related to.
   */
  @visibility(Lifecycle.Read)
  subscription?: InvoiceLineSubscriptionReference;
}

/**
 * Reference to an invoice.
 */
@friendlyName("InvoiceReference")
model InvoiceReference {
  /**
   * The ID of the invoice.
   */
  @visibility(Lifecycle.Read)
  id: ULID;

  /**
   * The number of the invoice.
   */
  @visibility(Lifecycle.Read)
  number?: InvoiceNumber;
}

/**
 * InvoiceUsageBasedRateCard represents the rate card (intent) for an usage-based line.
 */
@friendlyName("InvoiceUsageBasedRateCard")
model InvoiceUsageBasedRateCard {
  // TODO: Once the deprecation is done, let's make featureKey and price required
  ...PickProperties<
    OpenMeter.ProductCatalog.RateCardUsageBased,
    "taxConfig" | "featureKey" | "price"
  >;

  /**
   * The discounts that are applied to the line.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  discounts?: BillingDiscounts;
}

/**
 * InvoiceUsageBasedLine represents a line item that is sold to the customer based on usage. */
@friendlyName("InvoiceUsageBasedLine")
model InvoiceUsageBasedLine {
  ...OmitProperties<InvoiceLineBase, "type">;

  /**
   * Type of the line.
   */
  type: InvoiceLineTypes.usageBased;

  /**
   * Price of the usage-based item being sold.
   */
  #deprecated "Use rateCard.price instead"
  price?: OpenMeter.ProductCatalog.RateCardUsageBasedPrice;

  /**
   * The feature that the usage is based on.
   */
  #deprecated "Use rateCard.featureKey instead"
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  featureKey?: Key;

  /**
   * The rate card that is used for this line.
   *
   * The rate card captures the intent of the price and discounts for the usage-based item.
   */
  // TODO: Once the deprecation is done, let's make rateCard required
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  rateCard?: InvoiceUsageBasedRateCard;

  /**
   * The quantity of the item being sold.
   *
   * Any usage discounts applied previously are deducted from this quantity.
   */
  @visibility(Lifecycle.Read)
  quantity?: Numeric;

  /**
   * The quantity of the item that has been metered for the period before any discounts were applied.
   */
  @visibility(Lifecycle.Read)
  meteredQuantity?: Numeric;

  /**
   * The quantity of the item used before this line's period.
   *
   * It is non-zero in case of progressive billing, when this shows how much of the usage was already billed.
   *
   * Any usage discounts applied previously are deducted from this quantity.
   */
  @visibility(Lifecycle.Read)
  preLinePeriodQuantity?: Numeric;

  /**
   * The metered quantity of the item used in before this line's period without any discounts applied.
   *
   * It is non-zero in case of progressive billing, when this shows how much of the usage was already billed.
   */
  @visibility(Lifecycle.Read)
  meteredPreLinePeriodQuantity?: Numeric;
}

/**
 * InvoiceFlatFeeRateCard represents the rate card (intent) for a flat fee line.
 */
@friendlyName("InvoiceFlatFeeRateCard")
model InvoiceFlatFeeRateCard {
  // TODO: Once the deprecation is done, let's make price required
  ...PickProperties<
    OpenMeter.ProductCatalog.RateCardFlatFee,
    "taxConfig" | "price"
  >;

  /**
   * Quantity of the item being sold.
   *
   * Default: 1
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  quantity?: Numeric;

  /**
   * The discounts that are applied to the line.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  discounts?: BillingDiscounts;
}

/**
 * InvoiceFlatFeeLine represents a line item that is sold to the customer as a manually added fee.
 */
@friendlyName("InvoiceFlatFeeLine")
model InvoiceFlatFeeLine {
  ...OmitProperties<InvoiceLineBase, "type">;

  /**
   * Type of the line.
   */
  type: InvoiceLineTypes.flatFee;

  /**
   * Price of the item being sold.
   */
  #deprecated "Use rateCard.perUnitAmount instead"
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  perUnitAmount?: Money;

  /**
   * Payment term of the line.
   */
  #deprecated "Use rateCard.paymentTerm instead"
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  paymentTerm?: OpenMeter.ProductCatalog.PricePaymentTerm = OpenMeter.ProductCatalog.PricePaymentTerm.inAdvance;

  /**
   * Quantity of the item being sold.
   */
  #deprecated "Use rateCard.quantity instead"
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  quantity?: Numeric;

  /**
   * The rate card that is used for this line.
   */
  // TODO: Once the deprecation is done, let's make rateCard required
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  rateCard?: InvoiceFlatFeeRateCard;

  /**
   * Category of the flat fee.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  category?: InvoiceFlatFeeCategory = InvoiceFlatFeeCategory.regular;
}

/**
 * InvoiceFlatFeeCategory determines if the flat fee is a regular fee due to use due to a
 * commitment.
 */
@friendlyName("InvoiceFlatFeeCategory")
union InvoiceFlatFeeCategory {
  /**
   * The fee is a regular fee due to usage.
   */
  regular: "regular",

  /**
   * The fee is a fee due to a commitment (e.g. minimum spend).
   */
  commitment: "commitment",
}

/*
 * Omitted fields:
 * - taxes: Summary of all the taxes included in the invoice.
 *    We don't need that detailed information here, as we only need the total tax amount.
 */
/**
 * Totals contains the summaries of all calculations for the invoice.
 */
@friendlyName("InvoiceTotals")
model InvoiceTotals {
  /**
   * The total value of the line before taxes, discounts and commitments.
   */
  @visibility(Lifecycle.Read)
  amount: Numeric;

  /**
   * The amount of value of the line that are due to additional charges.
   */
  @visibility(Lifecycle.Read)
  chargesTotal: Numeric;

  /**
   * The amount of value of the line that are due to discounts.
   */
  @visibility(Lifecycle.Read)
  discountsTotal: Numeric;

  /**
   * The total amount of taxes that are included in the line.
   */
  @visibility(Lifecycle.Read)
  taxesInclusiveTotal: Numeric;

  /**
   * The total amount of taxes that are added on top of amount from the line.
   */
  @visibility(Lifecycle.Read)
  taxesExclusiveTotal: Numeric;

  /**
   * The total amount of taxes for this line.
   */
  @visibility(Lifecycle.Read)
  taxesTotal: Numeric;

  /**
   * The total amount value of the line after taxes, discounts and commitments.
   */
  @visibility(Lifecycle.Read)
  total: Numeric;
}

/*
 * Omitted fields:
 * - payee: The party responsible for receiving payment of the invoice, if not the supplier.
 *    We don't need this information here, as we only need the payment terms.
 * - advances: Any amounts that have been paid in advance and should be deducted from the amount due.
 *    We are not supporting prepayments yet.
 * - instructions: Details on how payment should be made.
 *    This is deferred to the payment provider for now, if we start supporing more payment providers,
 *    we might need this information.
 */
/**
 * Payment contains details as to how the invoice should be paid.
 */
@friendlyName("InvoicePaymentTerms")
model InvoicePaymentTerms {
  /**
   * The terms of payment for the invoice.
   */
  @visibility(Lifecycle.Read, Lifecycle.Create, Lifecycle.Update)
  terms?: PaymentTerms;
}

/**
 * ValidationIssueSeverity describes the severity of a validation issue.
 *
 * Issues with severity "critical" will prevent the invoice from being issued.
 */
@friendlyName("ValidationIssueSeverity")
enum ValidationIssueSeverity {
  critical: "critical",
  warning: "warning",
}

/**
 * ValidationIssue captures any validation issues related to the invoice.
 *
 * Issues with severity "critical" will prevent the invoice from being issued.
 */
@friendlyName("ValidationIssue")
model ValidationIssue {
  ...ResourceTimestamps;

  /**
   * ID of the charge or discount.
   */
  @visibility(Lifecycle.Read)
  id: ULID;

  /**
   * The severity of the issue.
   */
  @visibility(Lifecycle.Read)
  severity: ValidationIssueSeverity;

  /**
   * The field that the issue is related to, if available in JSON path format.
   */
  @visibility(Lifecycle.Read)
  field?: string;

  /**
   * Machine indentifiable code for the issue, if available.
   */
  @visibility(Lifecycle.Read)
  code?: string;

  /**
   * Component reporting the issue.
   */
  @visibility(Lifecycle.Read)
  component: string;

  /**
   * A human-readable description of the issue.
   */
  @visibility(Lifecycle.Read)
  message: string;

  /**
   * Additional context for the issue.
   */
  @visibility(Lifecycle.Read)
  metadata?: Metadata;
}

/**
 * InvoiceAppExternalIds contains the external IDs of the invoice in other apps such as Stripe.
 */
@friendlyName("InvoiceAppExternalIds")
model InvoiceAppExternalIds {
  /**
   * The external ID of the invoice in the invoicing app if available.
   */
  @visibility(Lifecycle.Read)
  invoicing?: string;

  /**
   * The external ID of the invoice in the tax app if available.
   */
  @visibility(Lifecycle.Read)
  tax?: string;

  /**
   * The external ID of the invoice in the payment app if available.
   */
  @visibility(Lifecycle.Read)
  payment?: string;
}

/**
 * InvoiceLineAppExternalIds contains the external IDs of the invoice in other apps such as Stripe.
 */
@friendlyName("InvoiceLineAppExternalIds")
model InvoiceLineAppExternalIds {
  /**
   * The external ID of the invoice in the invoicing app if available.
   */
  @visibility(Lifecycle.Read)
  invoicing?: string;

  /**
   * The external ID of the invoice in the tax app if available.
   */
  @visibility(Lifecycle.Read)
  tax?: string;
}

/**
 * InvoiceLineSubscriptionReference contains the references to the subscription that this line is related to.
 */
@friendlyName("InvoiceLineSubscriptionReference")
model InvoiceLineSubscriptionReference {
  /**
   * The subscription.
   */
  @visibility(Lifecycle.Read)
  subscription: IDResource;

  /**
   * The phase of the subscription.
   */
  @visibility(Lifecycle.Read)
  phase: IDResource;

  /**
   * The item this line is related to.
   */
  @visibility(Lifecycle.Read)
  item: IDResource;
}
