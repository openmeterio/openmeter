import "@typespec/http";
import "@typespec/rest";
import "@typespec/openapi3";

using TypeSpec.Http;
using TypeSpec.Rest;
using TypeSpec.OpenAPI;

using OpenMeter.ProductCatalog;

namespace Invoices;

/**
 * InvoiceNumber is a unique identifier for the invoice, generated by the
 * invoicing app.
 *
 * The uniqueness depends on a lot of factors:
 * - app setting (unique per app or unique per customer)
 * - multiple app scenarios (multiple apps generating invoices with the same prefix)
 */
@example("INV-2024-01-01-01")
@minLength(1)
@maxLength(256)
@friendlyName("InvoiceNumber")
scalar InvoiceNumber extends string;

/* Omitted fields (not required yet, from GOBL schema):
 * op_date: Date when the operation defined by the invoice became effective.
 * value_date: When the taxes of this invoice become accountable, if none set, the issue date is used.
 * exchange_rates: Exchange rates to be used when converting the invoices monetary values into other currencies.
 *    -> We are not supporting multi-currency invoices yet, so this is not supported.
 * charges: 	Charges or surcharges applied to the complete invoice.
 *    -> We are not supporting this yet.
 * outlays: 	Expenses paid for by the supplier but invoiced directly to the customer.
 *    -> We are not supporting this yet.
 * ordering: Ordering details including document references and buyer or seller parties.
 *    -> We are not supporting this yet (e.g. order handled by seperate entity, physical goods delivery details, etc.)
 * delivery: Specific details on delivery of the goods referenced in the invoice.
 *    -> We are not supporting physical goods delivery yet.
 * tax: Special tax configuration for billing.
 *    -> The prices include is the meaningful part, but we should make that an array, let's see if we need this as we implement more features.
 */
/**
 * Invoice represents an invoice in the system.
 */
@friendlyName("Invoice")
model Invoice {
  ...OmitProperties<global.Resource, "name">;

  /**
   * Type of the invoice.
   *
   * The type of invoice determines the purpose of the invoice and how it should be handled.
   *
   * Supported types:
   * - standard: A regular commercial invoice document between a supplier and customer.
   * - credit_note: Reflects a refund either partial or complete of the preceding document. A credit note effectively *extends* the previous document.
   */
  @visibility("read")
  type: InvoiceType;

  /**
   * The taxable entity supplying the goods or services.
   */
  @visibility("read", "update", "create")
  supplier: BillingParty;

  /**
   * Legal entity receiving the goods or services.
   */
  @visibility("read", "update", "create")
  customer: BillingParty;

  /**
   * Number specifies the human readable key used to reference this Invoice.
   *
   * The number only gets populated after the invoice had been issued.
   *
   * Please note that the number is (depending on the upstream settings) either unique for the
   * whole organization or unique for the customer, or in multi (stripe) account setups unique for the
   * account.
   */
  @visibility("read")
  number?: InvoiceNumber;

  /**
   * Currency for all invoice line items.
   *
   * Multi currency invoices are not supported yet.
   */
  @visibility("read", "create")
  currency: CurrencyCode;

  /**
   * Key information regarding previous invoices and potentially details as to why they were corrected.
   */
  @visibility("read")
  preceding?: InvoiceDocumentRef[];

  /**
   * Summary of all the invoice totals, including taxes (calculated).
   */
  @visibility("read")
  totals: InvoiceTotals;

  /**
   * The status of the invoice.
   *
   * This field only conatins a simplified status, for more detailed information use the statusDetails field.
   */
  @visibility("read")
  status: InvoiceStatus;

  /**
   * The details of the current invoice status.
   */
  @visibility("read")
  statusDetails: InvoiceStatusDetails;

  /**
   * The time the invoice was issued.
   *
   * Depending on the status of the invoice this can mean multiple things:
   * - draft, gathering: The time the invoice will be issued based on the workflow settings.
   * - issued: The time the invoice was issued.
   */
  @visibility("read")
  issuedAt?: DateTime;

  /**
   * The time until the invoice is in draft status.
   *
   * On draft invoice creation it is calculated from the workflow settings.
   *
   * If manual approval is required, the draftUntil time is set.
   */
  @visibility("read", "update")
  draftUntil?: DateTime;

  /**
   * Due time of the fulfillment of the invoice (if available).
   */
  @visibility("read")
  dueAt?: DateTime;

  /**
   * The period the invoice covers. If the invoice has no line items, it's not set.
   */
  @visibility("read", "create", "update")
  period?: Period;

  /**
   * The time the invoice was voided.
   *
   * If the invoice was voided, this field will be set to the time the invoice was voided.
   */
  @visibility("read")
  voidedAt?: DateTime;

  /**
   * The workflow associated with the invoice.
   *
   * It is always a snapshot of the workflow settings at the time of invoice creation. The
   * field is optional as it should be explicitly requested with expand options.
   */
  @visibility("read", "create", "update")
  workflow?: InvoiceWorkflowSettings;

  /**
   * List of invoice lines representing each of the items sold to the customer.
   */
  @visibility("read") // Seperate API endpoint is available for updating
  lines?: InvoiceLine[];

  /**
   * Discounts or allowances applied to the complete invoice.
   */
  @visibility("read", "create") // Updates and later deletions are handled by the restful API
  discounts?: Discount[];

  /**
   * Information on when, how, and to whom the invoice should be paid.
   */
  @visibility("read", "create", "update")
  payment?: InvoicePaymentTerms;

  /**
   * Validation issues reported by the invoice workflow.
   */
  @visibility("read")
  validationIssues?: ValidationIssue[];
}

/**
 * InvoiceAction represents the actions that can be performed on an invoice.
 */
@friendlyName("InvoiceAction")
enum InvoiceAction {
  /**
   * Advance the invoice to the next status.
   */
  advance: "advance",

  /**
   * Approve an invoice that requires manual approval.
   */
  approve: "approve",

  /**
   * Delete the invoice (only non-issued invoices can be deleted).
   */
  delete: "delete",

  /**
   * Retry an invoice issuing step that failed.
   */
  retry: "retry",

  /**
   * Void an already issued invoice.
   */
  `void`: "void",
}

/**
 * InvoiceStatusDetails represents the details of the invoice status.
 *
 * API users are encouraged to rely on the immutable/failed/avaliableActions fields to determine
 * the next steps of the invoice instead of the extendedStatus field.
 */
@friendlyName("InvoiceStatusDetails")
model InvoiceStatusDetails {
  /**
   * Is the invoice editable?
   */
  @visibility("read")
  immutable: boolean;

  /**
   * Is the invoice in a failed state?
   */
  @visibility("read")
  failed: boolean;

  /**
   * Extended status information for the invoice.
   */
  @visibility("read")
  extendedStatus: InvoiceExtendedStatus;

  /**
   * The actions that can be performed on the invoice.
   */
  availableActions: InvoiceAction[];
}

// TODO[later]: we can make this an enum, but only if we have reached a stable state with the statuses.
scalar InvoiceExtendedStatus extends string;

/**
 * InvoiceWorkflowSettings represents the workflow settings used by the invoice.
 *
 * This is a clone of the billing profile's workflow settings at the time of invoice creation
 * with customer overrides considered.
 */
@friendlyName("InvoiceWorkflowSettings")
model InvoiceWorkflowSettings {
  /**
   * The apps that will be used to orchestrate the invoice's workflow.
   */
  @visibility("read")
  apps?: OpenMeter.Billing.BillingProfileAppsOrReference;

  /**
   * sourceBillingProfileID is the billing profile on which the workflow was based on.
   *
   * The profile is snapshotted on invoice creation, after which it can be altered independently
   * of the profile itself.
   */
  @visibility("read")
  sourceBillingProfileID: ULID;

  /**
   * The workflow details used by this invoice.
   */
  @visibility("read")
  workflow: OpenMeter.Billing.BillingWorkflowSettings;

  /**
   * Timezone of the invoice's date fields.
   */
  @visibility("read")
  timezone: string;
}

/**
 * InvoiceStatus describes the status of an invoice.
 */
@friendlyName("InvoiceStatus")
enum InvoiceStatus {
  /**
   * The list of line items for the next invoice is being gathered.
   */
  gathering: "gathering",

  /**
   * The invoice is in draft status.
   */
  draft: "draft",

  /**
   * The invoice is in the process of being issued.
   */
  issuing: "issuing",

  /**
   * The invoice has been issued to the customer.
   */
  issued: "issued",
}

/*
 * Omitted types: proforma, corrected, debit-note, other
 */
/**
 * InvoiceType represents the type of invoice.
 *
 * The type of invoice determines the purpose of the invoice and how it should be handled.
 */
@friendlyName("InvoiceType")
enum InvoiceType {
  /**
   * A regular commercial invoice document between a supplier and customer.
   */
  standard: "standard",

  /**
   * Reflects a refund either partial or complete of the preceding document. A credit note effectively *extends* the previous document.
   */
  creditNote: "credit_note",
}

/**
 * Discount represents an allowance applied to the complete document independent from the individual lines.
 */
@friendlyName("InvoiceDiscount")
model InvoiceDiscount {
  /**
   * Base represents the value used as a base for percent calculations instead of the invoice's sum of lines.
   */
  @visibility("read", "create", "update")
  base?: Numeric;

  /**
   * Percentage to apply to the base or invoice's sum.
   */
  @visibility("read", "create", "update")
  percent?: Percentage;

  /**
   * Fixed discount amount to apply (calculated if percent present).
   */
  @visibility("read", "create", "update")
  amount: Numeric;

  /**
   * Text description as to why the discount was applied.
   */
  @visibility("read", "create", "update")
  reason?: string;

  // TODO: Add reference fields to plan/subscriptions if the discount is coming from there.
}

/**
 * BillingInvoiceLine represents a line item that is sold to the customer based on a specific (unit) price.
 */
@friendlyName("InvoiceLine")
@discriminator("type")
union InvoiceLine {
  usageBased: InvoiceUsageBasedLine,
  flatFee: InvoiceFlatFeeLine,
}

/**
 * InvoiceLineReplaceUpdate represents the update model for an invoice line.
 */
@friendlyName("InvoiceLineReplaceUpdate")
@discriminator("type")
union InvoiceLineReplaceUpdate {
  usageBased: Rest.Resource.ResourceReplaceModel<InvoiceUsageBasedLine>,
  flatFee: Rest.Resource.ResourceReplaceModel<InvoiceFlatFeeLine>,
}

/**
 * InvoiceLineCreate represents the create model for an invoice line.
 */
@friendlyName("InvoicePendingLineCreate")
@discriminator("type")
union InvoicePendingLineCreate {
  usageBased: InvoiceUsageBasedPendingLineCreate,
  flatFee: InvoiceFlatFeePendingLineCreate,
}

/**
 * InvoiceUsageBasedLineCreateWithCustomer represents the create model for an invoice line that is sold to the customer based on usage.
 */
@friendlyName("InvoiceUsageBasedPendingLineCreate")
model InvoiceUsageBasedPendingLineCreate {
  // Note: invoice is omitted as the line is assigned a new or existing gathering invoice
  ...Rest.Resource.ResourceCreateModel<OmitProperties<
    InvoiceUsageBasedLine,
    "invoice"
  >>;

  /**
   * The customer this line item belongs to.
   */
  @visibility("create")
  customerId: ULID;
}

/**
 * InvoiceFlatFeePendingLineCreate represents the create model for an invoice line that is sold to the customer as a manually added fee.
 */
@friendlyName("InvoiceFlatFeePendingLineCreate")
model InvoiceFlatFeePendingLineCreate {
  // Note: invoice is omitted as the line is assigned a new or existing gathering invoice
  ...Rest.Resource.ResourceCreateModel<OmitProperties<
    InvoiceFlatFeeLine,
    "invoice"
  >>;

  /**
   * The customer this line item belongs to.
   */
  @visibility("create")
  customerId: ULID;
}

/**
 * LineTypes represents the different types of lines that can be used in an invoice.
 */
@friendlyName("InvoiceLineTypes")
enum InvoiceLineTypes {
  flatFee: "flat_fee",
  usageBased: "usage_based",
}

/**
 * Line status specifies the status of the line.
 */
@friendlyName("InvoiceLineStatus")
enum InvoiceLineStatus {
  /**
   * The line is valid and can be used in the invoice.
   */
  valid: "valid",

  /**
   * The line is a detail line which is used to detail the individual
   * charges and discounts of a valid line.
   */
  detail: "detail",

  /**
   * The line has been split into multiple valid lines due to progressive
   * billing.
   */
  split: "split",
}

/**
 * InvoiceLine represents a single item or service sold to the customer.
 *
 * This is a base class for all line types, and should not be used directly.
 * */
@discriminator("type")
@friendlyName("InvoiceLine")
model InvoiceLineBase {
  // Note: ID has updated visibility as we support batch line creations and upserts
  ...OmitProperties<global.Resource, "id">;

  @visibility("read", "update")
  id: ULID;

  /**
   * Type of the line.
   *
   * A line's type cannot be changed after creation.
   */
  @visibility("read", "create")
  type: InvoiceLineTypes;

  /**
   * Status of the line.
   *
   * External calls always create valid lines, other line types are managed by the
   * billing engine of OpenMeter.
   */
  @visibility("read")
  status: InvoiceLineStatus;

  /**
   * Discounts detailes applied to this line.
   *
   * New discounts can be added via the invoice's discounts API, to facilitate
   * discounts that are affecting multiple lines.
   */
  @visibility("read")
  discounts?: InvoiceLineDiscount[];

  /**
   * Charges applied to this line. (like minimum spend)
   *
   * New charges can be added via the invoice's charges API, to facilitate
   * charges that are affecting multiple lines.
   */
  @visibility("read")
  charges?: InvoiceLineCharge[];

  /**
   * The invoice this item belongs to.
   */
  @visibility("read", "create")
  invoice?: InvoiceReference;

  /**
   * The currency of this line.
   */
  @visibility("read", "create")
  currency: CurrencyCode;

  /**
   * Taxes applied to the invoice totals.
   */
  @visibility("read") // Tax is handled by the tax provider, we only need to show the output of that here
  taxes?: InvoiceLineTaxItem[];

  /**
   * Tax config specify the tax configuration for this line.
   */
  @visibility("read", "create", "update")
  taxConfig?: OpenMeter.ProductCatalog.TaxConfig;

  /**
   * The lines detailing the item or service sold.
   */
  @visibility("read")
  children?: InvoiceLine[];

  /**
   * Totals for this line.
   */
  @visibility("read")
  totals: InvoiceTotals;

  /**
   * Period of the line item applies to for revenue recognition pruposes.
   *
   * Billing always treats periods as start being inclusive and end being exclusive.
   */
  @visibility("read", "create", "update")
  period: Period;

  /**
   * The time this line item should be invoiced.
   */
  @visibility("read", "create", "update")
  invoiceAt: DateTime;
}

/**
 * Reference to an invoice.
 */
@friendlyName("InvoiceReference")
model InvoiceReference {
  /**
   * The ID of the invoice.
   */
  @visibility("read")
  id: ULID;

  /**
   * The number of the invoice.
   */
  @visibility("read")
  number?: InvoiceNumber;
}

/**
 * InvoiceUsageBasedLine represents a line item that is sold to the customer based on usage.
 */
@friendlyName("InvoiceUsageBasedLine")
model InvoiceUsageBasedLine {
  ...OmitProperties<InvoiceLineBase, "type">;
  type: InvoiceLineTypes.usageBased;
  price: OpenMeter.ProductCatalog.RateCardUsageBasedPrice;

  /**
   * The feature that the usage is based on.
   */
  @visibility("read", "create")
  featureKey: Key;

  /**
   * The quantity of the item being sold.
   */
  @visibility("read")
  quantity?: Numeric;

  /**
   * The quantity of the item used in before this line's period.
   *
   * It is non-zero in case of progressive billing, when this shows how much of the usage was already billed.
   */
  @visibility("read")
  preLinePeriodQuantity?: Numeric;
}

/**
 * InvoiceFlatFeeLine represents a line item that is sold to the customer as a manually added fee.
 */
@friendlyName("InvoiceFlatFeeLine")
model InvoiceFlatFeeLine {
  ...OmitProperties<InvoiceLineBase, "type">;
  type: InvoiceLineTypes.flatFee;

  /**
   * Price of the item being sold.
   */
  @visibility("read", "create", "update")
  perUnitAmount: Money;

  /**
   * Payment term of the line.
   */
  @visibility("read", "create", "update")
  paymentTerm?: OpenMeter.ProductCatalog.PricePaymentTerm = OpenMeter.ProductCatalog.PricePaymentTerm.inAdvance;

  /**
   * Quantity of the item being sold.
   */
  @visibility("read", "create", "update")
  quantity: Numeric;
}

/**
 * InvoiceGenericCharge represents a charge or discount that can be applied to a line or the entire invoice.
 */
@friendlyName("InvoiceGenericCharge")
model InvoiceGenericCharge {
  ...ResourceTimestamps;

  /**
   * ID of the charge or discount.
   */
  @visibility("read")
  id: ULID;

  /**
   * Percentage if fixed amount not applied
   */
  @visibility("read", "create", "update")
  percent?: Percentage;

  /**
   * Fixed discount amount to apply (calculated if percent present).
   */
  @visibility("read", "create", "update")
  amount: Numeric;

  /**
   * Reason code.
   */
  @visibility("read", "create", "update")
  code?: string;

  /**
   * Text description as to why the discount was applied.
   */
  @visibility("read", "create", "update")
  description?: string;
}

/**
 * InvoiceLineDiscount represents an amount deducted from the line, and will be applied before taxes.
 */
@friendlyName("InvoiceLineDiscount")
model InvoiceLineDiscount {
  ...InvoiceGenericCharge;
}

/**
 * InvoiceLineCharge represents an amount added to the line, and will be applied before taxes.
 */
@friendlyName("BillingLineCharge")
model InvoiceLineCharge {
  ...InvoiceGenericCharge;
}

/*
 * Omitted fields:
 * - taxes: Summary of all the taxes included in the invoice.
 *    We don't need that detailed information here, as we only need the total tax amount.
 */
/**
 * Totals contains the summaries of all calculations for the invoice.
 */
@friendlyName("InvoiceTotals")
model InvoiceTotals {
  /**
   * The total value of the line before taxes, discounts and commitments.
   */
  @visibility("read")
  amount: Numeric;

  /**
   * The amount of value of the line that are due to additional charges.
   */
  @visibility("read")
  chargesTotal: Numeric;

  /**
   * The amount of value of the line that are due to discounts.
   */
  @visibility("read")
  discountsTotal: Numeric;

  /**
   * The total amount of taxes that are included in the line.
   */
  @visibility("read")
  taxesInclusiveTotal: Numeric;

  /**
   * The total amount of taxes that are added on top of amount from the line.
   */
  @visibility("read")
  taxesExclusiveTotal: Numeric;

  /**
   * The total amount of taxes for this line.
   */
  @visibility("read")
  taxesTotal: Numeric;

  /**
   * The total amount value of the line after taxes, discounts and commitments.
   */
  @visibility("read")
  total: Numeric;
}

/*
 * Omitted fields:
 * - payee: The party responsible for receiving payment of the invoice, if not the supplier.
 *    We don't need this information here, as we only need the payment terms.
 * - advances: Any amounts that have been paid in advance and should be deducted from the amount due.
 *    We are not supporting prepayments yet.
 * - instructions: Details on how payment should be made.
 *    This is deferred to the payment provider for now, if we start supporing more payment providers,
 *    we might need this information.
 */
/**
 * Payment contains details as to how the invoice should be paid.
 */
@friendlyName("InvoicePaymentTerms")
model InvoicePaymentTerms {
  /**
   * The terms of payment for the invoice.
   */
  @visibility("read", "create", "update")
  terms?: PaymentTerms;
}

/**
 * ValidationIssueSeverity describes the severity of a validation issue.
 *
 * Issues with severity "critical" will prevent the invoice from being issued.
 */
@friendlyName("ValidationIssueSeverity")
enum ValidationIssueSeverity {
  critical: "critical",
  warning: "warning",
}

/**
 * ValidationIssue captures any validation issues related to the invoice.
 *
 * Issues with severity "critical" will prevent the invoice from being issued.
 */
@friendlyName("ValidationIssue")
model ValidationIssue {
  ...ResourceTimestamps;

  /**
   * ID of the charge or discount.
   */
  @visibility("read")
  id: ULID;

  /**
   * The severity of the issue.
   */
  @visibility("read")
  severity: ValidationIssueSeverity;

  /**
   * The field that the issue is related to, if available in JSON path format.
   */
  @visibility("read")
  field?: string;

  /**
   * Machine indentifiable code for the issue, if available.
   */
  @visibility("read")
  code?: string;

  /**
   * Component reporting the issue.
   */
  @visibility("read")
  component: string;

  /**
   * A human-readable description of the issue.
   */
  @visibility("read")
  message: string;

  /**
   * Additional context for the issue.
   */
  @visibility("read")
  metadata?: Metadata;
}
