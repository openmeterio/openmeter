import "@typespec/http";
import "@typespec/rest";
import "@typespec/openapi3";
import "../../ratecards.tsp";

using TypeSpec.Http;
using TypeSpec.Rest;
using TypeSpec.OpenAPI;

namespace Invoices;

/**
 * InvoiceNumber is a unique identifier for the invoice, generated by the
 * invoicing app.
 *
 * The uniqueness depends on a lot of factors:
 * - app setting (unique per app or unique per customer)
 * - multiple app scenarios (multiple apps generating invoices with the same prefix)
 */
@example("INV-2024-01-01-01")
@minLength(1)
@maxLength(256)
@friendlyName("BillingInvoiceNumber")
scalar InvoiceNumber extends string;

/* Omitted fields (not required yet, from GOBL schema):
 * op_date: Date when the operation defined by the invoice became effective.
 * value_date: When the taxes of this invoice become accountable, if none set, the issue date is used.
 * exchange_rates: Exchange rates to be used when converting the invoices monetary values into other currencies.
 *    -> We are not supporting multi-currency invoices yet, so this is not supported.
 * charges: 	Charges or surcharges applied to the complete invoice.
 *    -> We are not supporting this yet.
 * outlays: 	Expenses paid for by the supplier but invoiced directly to the customer.
 *    -> We are not supporting this yet.
 * ordering: Ordering details including document references and buyer or seller parties.
 *    -> We are not supporting this yet (e.g. order handled by seperate entity, physical goods delivery details, etc.)
 * delivery: Specific details on delivery of the goods referenced in the invoice.
 *    -> We are not supporting physical goods delivery yet.
 * tax: Special tax configuration for billing.
 *    -> The prices include is the meaningful part, but we should make that an array, let's see if we need this as we implement more features.
 */
@summary("Invoice summary represents an extract of the invoice object")
@friendlyName("BillingInvoiceSummary")
model Invoice {
  ...OmitProperties<global.Resource, "updatedAt">;

  /**
   * Timestamp of when the resource was last updated.
   *
   * For updates the updatedAt field is used to detect conflicts.
   */
  @summary("Last Update Time")
  @visibility("read", "update")
  @example(DateTime.fromISO("2024-01-01T01:01:01.001Z"))
  updatedAt: DateTime;

  @visibility("read", "query")
  type?: InvoiceType;

  @summary("The taxable entity supplying the goods or services.")
  @visibility("read", "query", "update")
  supplier: Party;

  @summary("Legal entity receiving the goods or services.")
  @visibility("read", "query", "update")
  customer: Party;

  /**
   * Number specifies the human readable key used to reference this Invoice.
   *
   * The number only gets populated after the invoice had been issued.
   *
   * Please note that the number is (depending on the upstream settings) either unique for the
   * whole organization or unique for the customer, or in multi (stripe) account setups unique for the
   * account.
   */
  @summary("(Serial) Number of the invoice")
  @visibility("read", "query")
  number?: InvoiceNumber;

  @summary("Currency for all invoice totals.")
  @visibility("read", "query")
  currency: CurrencyCode;

  @summary("Key information regarding previous invoices and potentially details as to why they were corrected.")
  @visibility("read", "query") // We only populate this for voided invoices
  preceding?: DocumentRef[];

  @summary("Summary of all the invoice totals, including taxes (calculated).")
  @visibility("read", "query")
  totals: Totals;

  @visibility("read", "query")
  @summary("The status of the invoice.")
  status: InvoiceStatus;

  /**
   * The time the invoice was issued.
   *
   * Depending on the status of the invoice this can mean multiple things:
   * - draft, gathering: The time the invoice will be issued based on the workflow settings.
   * - issued: The time the invoice was issued.
   */
  @summary("The time the invoice was issued.")
  @visibility("read", "query")
  issuedAt?: DateTime;

  @summary("The workflow settings associated with this invoice")
  @visibility("read", "query", "update")
  workflow?: InvoiceWorkflowSettings;

  @summary("List of invoice lines representing each of the items sold to the customer.")
  @visibility("read", "query") // Seperate API endpoint is available for updating
  // TODO: we might want to group this by subscription, so that we don't have to add individual references
  // per line item, however that poses a problem, when a manually added line-item is added, as that should also be
  // bound to a subscription.
  lines?: Line[];

  @summary("Discounts or allowances applied to the complete invoice.")
  @visibility("read", "query") // Seperate API endpoint is available for updating
  discounts?: Discount[];

  @summary("Information on when, how, and to whom the invoice should be paid.")
  @visibility("read", "query") // Seperate API endpoint is available for updating
  payment?: Payment;
}

@friendlyName("BillingInvoiceWorkflowSettings")
model InvoiceWorkflowSettings {
  /**
   * updatedAt is the time when the invoice workflow was last updated.
   */
  @summary("Should the invoice auto advance to the next status?")
  autoAdvance: boolean;

  /**
   * The invoice stays in the draft status until this time.
   *
   * If auto advance is disabled the value will be empty.
   */
  draftUtil?: DateTime;

  /**
   * The period after which the invoice is due.
   */
  @encode(DurationKnownEncoding.ISO8601)
  @example("P1D")
  dueAfter?: string = "P7D";
}

/**
 * InvoiceStatus describes the status of an invoice.
 */
@friendlyName("BillingInvoiceStatus")
enum InvoiceStatus {
  /**
   * The list of line items for the next invoice is being gathered.
   */
  gathering: "gathering",

  /**
   * The invoice is waiting for review by our partner.
   */
  review: "review",

  /**
   * The invoice has been issued to the customer.
   */
  issued: "issued",

  /**
   * The invoice has been paid by the customer.
   */
  paymentReceived: "payment_received",

  /**
   * A manual approval is required before the invoice can be issued.
   */
  manualApprovalRequired: "manual_approval_required",

  /**
   * There's a validation issue with the invoice.
   */
  validationFailed: "validation_failed",
}

/*
 * Omitted types: proforma, corrected, debit-note, other
 */
@friendlyName("BillingInvoiceType")
enum InvoiceType {
  @summary("A regular commercial invoice document between a supplier and customer.")
  standard: "standard",

  @summary("Reflects a refund either partial or complete of the preceding document. A credit note effectively *extends* the previous document.")
  credit_note: "credit-note",
}

@friendlyName("BillingInvoiceDiscount")
@summary("Discount represents an allowance applied to the complete document independent from the individual lines.")
model Discount {
  @summary("Base represents the value used as a base for percent calculations instead of the invoice's sum of lines.")
  base?: Numeric;

  @summary("Percentage to apply to the base or invoice's sum.")
  percent?: Percentage;

  @summary("Amount to apply (calculated if percent present).")
  amount: Numeric;

  @summary("Text description as to why the discount was applied")
  reason?: string;

  // TODO: Add reference fields to plan/subscriptions if the discount is coming from there.
}

alias InvoiceLine = UnitPriceLine;

@summary("LineTypes represents the different types of lines that can be used in an invoice.")
@friendlyName("BillingLineTypes")
enum LineTypes {
  /*
   * The line represents a product or service that is sold to the customer.
   *
   * If the item is a single charge or based on a metered value it doesn't matter from the invoicing perspective.
   */
  unitPrice: "unit_price",
}

/**
 * Line represents a single item or service sold to the customer.
 *
 * This is a base class for all line types, and should not be used directly.
 * */
@discriminator("type")
@friendlyName("BillingLine")
model Line {
  @visibility("read", "query", "update")
  id: ULID;

  type: LineTypes;

  @summary("Discounts applied to this line.")
  discounts?: LineDiscount[];

  @summary("Charges applied to this line.")
  charges?: LineCharge[];

  @summary("Map of taxes to be applied and used in the invoice totals.")
  @visibility("read", "query") // Tax is handled by the tax provider, we only need to show the output of that here
  taxes?: TaxItem[];

  @visibility("read")
  @summary("Total sum of the line, including discounts and charges.")
  total: Numeric;

  @summary("Period of the line item applies to for revenue recognition pruposes.")
  period: Period;
}

@summary("Period represents a time range.")
@friendlyName("BillingPeriod")
model Period {
  @summary("Start of the period.")
  start: DateTime;

  @summary("End of the period.")
  end: DateTime;
}

/**
 * UnitPriceLine represents a line item that is sold to the customer based on a unit price.
 *
 * This is analogous to gobl's Line model, with the addition of the type and some metadata fields.
 */
@friendlyName("BillingUnitPriceLine")
model UnitPriceLine extends Line {
  type: LineTypes.unitPrice;

  @summary("Details about what is being sold.")
  item: OpenMeter.RateCard;

  @summary("Quantity of the item being sold.")
  quantity: Numeric;
}

@summary("GenericCharge represents a charge or discount that can be applied to a line or the entire invoice.")
@friendlyName("BillingGenericCharge")
model GenericCharge {
  /**
   * Percentage if fixed amount not applied
   */
  @summary("Percent")
  percent?: Percentage;

  /**
   * Fixed discount amount to apply (calculated if percent present).
   */
  @summary("Amount")
  amount: Numeric;

  @summary("Reason code.")
  code?: string;

  @summary("Text description as to why the discount was applied.")
  reason?: string;

  // TODO: Add fields required for referencing the charge/discount in the plan if it is coming from
  // there.
}

@summary("LineDiscount represents an amount deducted from the line, and will be applied before taxes.")
@friendlyName("BillingLineDiscount")
model LineDiscount {
  ...GenericCharge;
}

@summary("LineCharge represents an amount added to the line, and will be applied before taxes.")
@friendlyName("BillingLineCharge")
model LineCharge {
  ...GenericCharge;
}

/*
 * Omitted fields:
 * - taxes: Summary of all the taxes included in the invoice.
 *    We don't need that detailed information here, as we only need the total tax amount.
 */
@summary("Totals contains the summaries of all calculations for the invoice.")
@friendlyName("BillingInvoiceTotals")
model Totals {
  @summary("Sum of all line item sums")
  sum: Money;

  @summary("Sum of all document level discounts")
  discount?: Money;

  @summary("Sum of all document level charges")
  charge?: Money;

  @summary("If prices include tax, this is the total tax included in the price.")
  taxIncluded?: Money;

  @summary("Sum of all line sums minus the discounts, plus the charges, without tax.")
  total: Money;

  @summary("Total amount of tax to apply to the invoice.")
  tax?: Money;

  @summary("Grand total after all taxes have been applied.")
  totalWithTax: Money;

  @summary("Rounding amount to apply to the invoice in case the total and payable amounts don't quite match.")
  rounding?: Money;

  @summary("Total amount to be paid after applying taxes and outlays.")
  payable: Money;

  @summary("Total amount already paid in advance.")
  advance?: Money;

  @summary("How much actually needs to be paid now.")
  due?: Money;
}

/*
 * Omitted fields:
 * - payee: The party responsible for receiving payment of the invoice, if not the supplier.
 *    We don't need this information here, as we only need the payment terms.
 * - advances: Any amounts that have been paid in advance and should be deducted from the amount due.
 *    We are not supporting prepayments yet.
 * - instructions: Details on how payment should be made.
 *    This is deferred to the payment provider for now, if we start supporing more payment providers,
 *    we might need this information.
 */
@summary("Payment contains details as to how the invoice should be paid.")
@friendlyName("BillingInvoicePayment")
model Payment {
  terms?: PaymentTerms;
}
