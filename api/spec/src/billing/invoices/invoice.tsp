import "@typespec/http";
import "@typespec/rest";
import "@typespec/openapi3";

using TypeSpec.Http;
using TypeSpec.Rest;
using TypeSpec.OpenAPI;

using OpenMeter.ProductCatalog;

namespace Invoices;

/**
 * InvoiceNumber is a unique identifier for the invoice, generated by the
 * invoicing app.
 *
 * The uniqueness depends on a lot of factors:
 * - app setting (unique per app or unique per customer)
 * - multiple app scenarios (multiple apps generating invoices with the same prefix)
 */
@example("INV-2024-01-01-01")
@minLength(1)
@maxLength(256)
@friendlyName("BillingInvoiceNumber")
scalar InvoiceNumber extends string;

/* Omitted fields (not required yet, from GOBL schema):
 * op_date: Date when the operation defined by the invoice became effective.
 * value_date: When the taxes of this invoice become accountable, if none set, the issue date is used.
 * exchange_rates: Exchange rates to be used when converting the invoices monetary values into other currencies.
 *    -> We are not supporting multi-currency invoices yet, so this is not supported.
 * charges: 	Charges or surcharges applied to the complete invoice.
 *    -> We are not supporting this yet.
 * outlays: 	Expenses paid for by the supplier but invoiced directly to the customer.
 *    -> We are not supporting this yet.
 * ordering: Ordering details including document references and buyer or seller parties.
 *    -> We are not supporting this yet (e.g. order handled by seperate entity, physical goods delivery details, etc.)
 * delivery: Specific details on delivery of the goods referenced in the invoice.
 *    -> We are not supporting physical goods delivery yet.
 * tax: Special tax configuration for billing.
 *    -> The prices include is the meaningful part, but we should make that an array, let's see if we need this as we implement more features.
 */
/**
 * Invoice represents an invoice in the system.
 */
@friendlyName("BillingInvoice")
model Invoice {
  ...OmitProperties<global.Resource, "updatedAt" | "name">;

  /**
   * Timestamp of when the resource was last updated.
   *
   * For updates the updatedAt field is used to detect conflicts.
   */
  @summary("Last Update Time")
  @visibility("read", "update")
  @example(DateTime.fromISO("2024-01-01T01:01:01.001Z"))
  updatedAt: DateTime;

  @visibility("read", "query")
  type: InvoiceType;

  @summary("The taxable entity supplying the goods or services.")
  @visibility("read", "query", "update")
  supplier: Party;

  @summary("Legal entity receiving the goods or services.")
  @visibility("read", "query", "update")
  customer: Party;

  /**
   * Number specifies the human readable key used to reference this Invoice.
   *
   * The number only gets populated after the invoice had been issued.
   *
   * Please note that the number is (depending on the upstream settings) either unique for the
   * whole organization or unique for the customer, or in multi (stripe) account setups unique for the
   * account.
   */
  @summary("(Serial) Number of the invoice")
  @visibility("read", "query")
  number?: InvoiceNumber;

  @summary("Currency for all invoice totals.")
  @visibility("read", "query")
  currency: CurrencyCode;

  @summary("Key information regarding previous invoices and potentially details as to why they were corrected.")
  @visibility("read", "query") // We only populate this for voided invoices
  preceding?: DocumentRef[];

  @summary("Summary of all the invoice totals, including taxes (calculated).")
  @visibility("read", "query")
  totals: Totals;

  @visibility("read", "query")
  @summary("The status of the invoice.")
  status: InvoiceStatus;

  @visibility("read", "query")
  @summary("The details of the current invoice status")
  statusDetails: InvoiceStatusDetails;

  /**
   * The time the invoice was issued.
   *
   * Depending on the status of the invoice this can mean multiple things:
   * - draft, gathering: The time the invoice will be issued based on the workflow settings.
   * - issued: The time the invoice was issued.
   */
  @summary("The time the invoice was issued.")
  @visibility("read", "query")
  issuedAt?: DateTime;

  /**
   * The time until the invoice is in draft status.
   *
   * On draft invoice creation it is calculated from the workflow settings.
   *
   * If manual approval is required, the draftUntil time is set.
   */
  @summary("The time until the invoice is in draft status.")
  @visibility("read", "query", "update")
  draftUntil?: DateTime;

  @summary("Due time of the fulfillment of the invoice.")
  @visibility("read", "query")
  dueAt?: DateTime;

  @summary("The period the invoice covers. If the invoice has no line items, it's not set.")
  period?: Period;

  /**
   * The time the invoice was voided.
   *
   * If the invoice was voided, this field will be set to the time the invoice was voided.
   */
  @summary("The time the invoice was voided.")
  @visibility("read", "query")
  voidedAt?: DateTime;

  /**
   * The workflow associated with the invoice.
   *
   * It is always a snapshot of the workflow settings at the time of invoice creation. The
   * field is optional as it should be explicitly requested with expand options.
   */
  @summary("The workflow settings associated with this invoice")
  @visibility("read", "query", "update")
  workflow?: InvoiceWorkflowSettings;

  @summary("List of invoice lines representing each of the items sold to the customer.")
  @visibility("read", "query") // Seperate API endpoint is available for updating
  // TODO: we might want to group this by subscription, so that we don't have to add individual references
  // per line item, however that poses a problem, when a manually added line-item is added, as that should also be
  // bound to a subscription.
  lines?: InvoiceLine[];

  @summary("Discounts or allowances applied to the complete invoice.")
  @visibility("read", "query") // Seperate API endpoint is available for updating
  discounts?: Discount[];

  @summary("Information on when, how, and to whom the invoice should be paid.")
  @visibility("read", "query") // Seperate API endpoint is available for updating
  payment?: Payment;

  @summary("Validation issues reported by the invoice workflow.")
  @visibility("read", "query")
  validationIssues?: ValidationIssue[];
}

/**
 * BillingInvoiceAction represents the actions that can be performed on an invoice.
 */
@friendlyName("BillingInvoiceAction")
enum InvoiceAction {
  @summary("Advance the invoice to the next status.")
  advance: "advance",

  @summary("Approve an invoice that requires manual approval.")
  approve: "approve",

  @summary("Delete the invoice (only non-issued invoices can be deleted).")
  delete: "delete",

  @summary("Retry an invoice issuing step that failed.")
  retry: "retry",

  @summary("Void an already issued invoice.")
  `void`: "void",
}

/**
 * InvoiceStatusDetails represents the details of the invoice status.
 *
 * API users are encouraged to rely on the immutable/failed/avaliableActions fields to determine
 * the next steps of the invoice instead of the extendedStatus field.
 */
@friendlyName("BillingInvoiceStatusDetails")
model InvoiceStatusDetails {
  @summary("Is the invoice editable?")
  immutable: boolean;

  @summary("Is the invoice in a failed state?")
  failed: boolean;

  @summary("Extended status information for the invoice.")
  extendedStatus: InvoiceExtendedStatus;

  @summary("The actions that can be performed on the invoice.")
  availableActions: InvoiceAction[];
}

/**
 * InvoiceWorkflowSettings represents the workflow settings used by the invoice.
 *
 * This is a clone of the billing profile's workflow settings at the time of invoice creation
 * with customer overrides considered.
 */
@friendlyName("BillingInvoiceWorkflowSettings")
model InvoiceWorkflowSettings {
  @summary("The apps that will be used to orchestrate the invoice's workflow.")
  apps?: OpenMeter.Billing.ProfileAppsOrReference;

  /**
   * sourceBillingProfileID is the billing profile on which the workflow was based on.
   *
   * The profile is snapshotted on invoice creation, after which it can be altered independently
   * of the profile itself.
   */
  @summary("The billing profile on which the workflow was based on.")
  sourceBillingProfileID: ULID;

  @summary("The workflow details used by this invoice.")
  workflow: OpenMeter.Billing.WorkflowSettings;

  @summary("Timezone of the invoice's date fields.")
  @visibility("read", "query")
  timezone: string;
}

/**
 * InvoiceStatus describes the status of an invoice.
 */
@friendlyName("BillingInvoiceStatus")
enum InvoiceStatus {
  /**
   * The list of line items for the next invoice is being gathered.
   */
  gathering: "gathering",

  /**
   * The invoice is in draft status.
   */
  draft: "draft",

  /**
   * The invoice is in the process of being issued.
   */
  issuing: "issuing",

  /**
   * The invoice has been issued to the customer.
   */
  issued: "issued",
}

/**
 * InvoiceExtendedStatus describes the extended status of an invoice.
 *
 * This is used to provide more detailed information about the status of the invoice. Useful for
 * troubelshooting invoice workflow issues.
 */
@friendlyName("BillingInvoiceExtendedStatus")
enum InvoiceExtendedStatus {
  ...InvoiceStatus,

  @summary("The draft is available for processing.")
  draftCreated: "draft_created",

  @summary("The draft is waiting for manual approval.")
  draftManualApprovalNeeded: "draft_manual_approval_needed",

  @summary("The draft is being validated.")
  draftValidating: "draft_validating",

  @summary("The draft is invalid, needs fixes to apps or contents.")
  draftInvalid: "draft_invalid",

  @summary("The draft is syncing with external systems.")
  draftSyncing: "draft_syncing",

  @summary("The draft failed to sync with external systems.")
  draftSyncFailed: "draft_sync_failed",

  @summary("The draft is waiting for auto-approval.")
  draftWaitingAutoApproval: "draft_waiting_auto_approval",

  @summary("The draft is ready to be issued.")
  draftReadyToIssue: "draft_ready_to_issue",

  @summary("The draft is being issued.")
  issuingSyncing: "issuing_syncing",

  @summary("The draft failed to issue.")
  issuingSyncFailed: "issuing_sync_failed",
}

/*
 * Omitted types: proforma, corrected, debit-note, other
 */
/**
 * InvoiceType represents the type of invoice.
 *
 * The type of invoice determines the purpose of the invoice and how it should be handled.
 */
@friendlyName("BillingInvoiceType")
enum InvoiceType {
  @summary("A regular commercial invoice document between a supplier and customer.")
  standard: "standard",

  @summary("Reflects a refund either partial or complete of the preceding document. A credit note effectively *extends* the previous document.")
  creditNote: "credit_note",
}

/**
 * Discount represents an allowance applied to the complete document independent from the individual lines.
 */
@friendlyName("BillingInvoiceDiscount")
model Discount {
  @summary("Base represents the value used as a base for percent calculations instead of the invoice's sum of lines.")
  base?: Numeric;

  @summary("Percentage to apply to the base or invoice's sum.")
  percent?: Percentage;

  @summary("Amount to apply (calculated if percent present).")
  amount: Numeric;

  @summary("Text description as to why the discount was applied")
  reason?: string;

  // TODO: Add reference fields to plan/subscriptions if the discount is coming from there.
}

/**
 * BillingInvoiceLine represents a line item that is sold to the customer based on a specific (unit) price.
 */
@friendlyName("BillingInvoiceLine")
@discriminator("type")
union InvoiceLine {
  usageBased: UsageBasedLine,
  flatFee: FlatFeeLine,
}

/**
 * LineTypes represents the different types of lines that can be used in an invoice.
 */
@friendlyName("BillingLineTypes")
enum LineTypes {
  // TODO: Implement when we have support for subscriptions
  // subscriptionFlatFee: "subs_flat_fee",
  // subscriptionUsageBased: "subs_usage_based",

  flatFee: "flat_fee",

  usageBased: "usage_based",
}

/**
 * Line status specifies the status of the line.
 */
@friendlyName("BillingLineStatus")
enum LineStatus {
  valid: "valid",
  deleted: "deleted",
  split: "split",
}

/**
 * Line represents a single item or service sold to the customer.
 *
 * This is a base class for all line types, and should not be used directly.
 * */
@discriminator("type")
@friendlyName("BillingLine")
model Line {
  ...OmitProperties<global.Resource, "id">;

  @visibility("read", "query", "update")
  id: ULID;

  type: LineTypes;

  @visibility("read", "query")
  status: LineStatus;

  @summary("Discounts applied to this line.")
  discounts?: LineDiscount[];

  @summary("Charges applied to this line.")
  charges?: LineCharge[];

  @summary("The invoice this item belongs to.")
  invoice?: InvoiceReference;

  @summary("The currency of this line")
  currency: CurrencyCode;

  @summary("Map of taxes to be applied and used in the invoice totals.")
  @visibility("read", "query") // Tax is handled by the tax provider, we only need to show the output of that here
  taxes?: TaxItem[];

  @summary("Tax config specify the tax configuration for this line.")
  taxConfig?: OpenMeter.ProductCatalog.TaxConfig | null;

  @visibility("read")
  @summary("Total sum of the line, including discounts and charges.")
  total: Numeric;

  @summary("Period of the line item applies to for revenue recognition pruposes.")
  period: Period;

  @summary("The time this line item should be invoiced.")
  invoiceAt: DateTime;
}

/**
 * Reference to an invoice.
 */
@friendlyName("BillingInvoiceReference")
model InvoiceReference {
  @summary("The ID of the invoice.")
  id: ULID;

  @summary("The number of the invoice.")
  number?: InvoiceNumber;
}

/**
 * Period represents a time range.
 *
 * Billing always treats periods as start being inclusive and end being exclusive.
 */
@friendlyName("BillingPeriod")
model Period {
  @summary("Start of the period.")
  start: DateTime;

  @summary("End of the period.")
  end: DateTime;
}

/**
 * UsageBasedLine represents a line item that is sold to the customer based on usage.
 */
@friendlyName("BillingUsageBasedLine")
model UsageBasedLine {
  ...OmitProperties<Line, "type">;
  type: LineTypes.usageBased;
  price: OpenMeter.ProductCatalog.RateCardUsageBasedPrice;

  @summary("The feature that the usage is based on.")
  featureKey: Key;

  @summary("Quantity of the item being sold.")
  @visibility("read", "query")
  quantity?: Numeric;
}

/**
 * BillingFlatFeeLine represents a line item that is sold to the customer as a manually added fee.
 */
@friendlyName("BillingFlatFeeLine")
model FlatFeeLine {
  ...OmitProperties<Line, "type">;
  type: LineTypes.flatFee;

  @summary("Price of the item being sold.")
  amount: Money;

  @summary("Payment term of the line.")
  paymentTerm?: OpenMeter.ProductCatalog.PricePaymentTerm = OpenMeter.ProductCatalog.PricePaymentTerm.inAdvance;

  @summary("Quantity of the item being sold.")
  quantity: Numeric;
}

/**
 * GenericCharge represents a charge or discount that can be applied to a line or the entire invoice.
 */
@friendlyName("BillingGenericCharge")
model GenericCharge {
  /**
   * Percentage if fixed amount not applied
   */
  @summary("Percent")
  percent?: Percentage;

  /**
   * Fixed discount amount to apply (calculated if percent present).
   */
  @summary("Amount")
  amount: Numeric;

  @summary("Reason code.")
  code?: string;

  @summary("Text description as to why the discount was applied.")
  reason?: string;

  // TODO: Add fields required for referencing the charge/discount in the plan if it is coming from
  // there.
}

/**
 * LineDiscount represents an amount deducted from the line, and will be applied before taxes.
 */
@friendlyName("BillingLineDiscount")
model LineDiscount {
  ...GenericCharge;
}

/**
 * LineCharge represents an amount added to the line, and will be applied before taxes.
 */
@friendlyName("BillingLineCharge")
model LineCharge {
  ...GenericCharge;
}

/*
 * Omitted fields:
 * - taxes: Summary of all the taxes included in the invoice.
 *    We don't need that detailed information here, as we only need the total tax amount.
 */
/**
 * Totals contains the summaries of all calculations for the invoice.
 */
@friendlyName("BillingInvoiceTotals")
model Totals {
  @summary("Sum of all line item sums")
  sum: Money;

  @summary("Sum of all document level discounts")
  discount?: Money;

  @summary("Sum of all document level charges")
  charge?: Money;

  @summary("If prices include tax, this is the total tax included in the price.")
  taxIncluded?: Money;

  @summary("Sum of all line sums minus the discounts, plus the charges, without tax.")
  total: Money;

  @summary("Total amount of tax to apply to the invoice.")
  tax?: Money;

  @summary("Grand total after all taxes have been applied.")
  totalWithTax: Money;

  @summary("Rounding amount to apply to the invoice in case the total and payable amounts don't quite match.")
  rounding?: Money;

  @summary("Total amount to be paid after applying taxes and outlays.")
  payable: Money;

  @summary("Total amount already paid in advance.")
  advance?: Money;

  @summary("How much actually needs to be paid now.")
  due?: Money;
}

/*
 * Omitted fields:
 * - payee: The party responsible for receiving payment of the invoice, if not the supplier.
 *    We don't need this information here, as we only need the payment terms.
 * - advances: Any amounts that have been paid in advance and should be deducted from the amount due.
 *    We are not supporting prepayments yet.
 * - instructions: Details on how payment should be made.
 *    This is deferred to the payment provider for now, if we start supporing more payment providers,
 *    we might need this information.
 */
/**
 * Payment contains details as to how the invoice should be paid.
 */
@friendlyName("BillingInvoicePayment")
model Payment {
  terms?: PaymentTerms;
}

/**
 * ValidationIssueSeverity describes the severity of a validation issue.
 *
 * Issues with severity "critical" will prevent the invoice from being issued.
 */
@friendlyName("BillingValidationIssueSeverity")
enum ValidationIssueSeverity {
  critical: "critical",
  warning: "warning",
}

/**
 * ValidationIssue captures any validation issues related to the invoice.
 *
 * Issues with severity "critical" will prevent the invoice from being issued.
 */
@friendlyName("BillingValidationIssue")
model ValidationIssue {
  @summary("The severity of the issue.")
  severity: ValidationIssueSeverity;

  @summary("The field that the issue is related to, if available in JSON path format.")
  field?: string;

  @summary("Machine indentifiable code for the issue, if available.")
  // NOTE: on the long run we might make this an enum, but for now, let's keep it as a string, as
  // we would need to extract the codes from go code and maybe external systems too.
  code?: string;

  @summary("Component reporting the issue.")
  component: string;

  @summary("A human-readable description of the issue.")
  message: string;

  @summary("Metadata")
  metadata?: Metadata;
}
