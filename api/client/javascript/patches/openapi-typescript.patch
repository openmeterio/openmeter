diff --git a/dist/transform/schema-object.cjs b/dist/transform/schema-object.cjs
index b8175ac46f71af118272973c3915afab63268d2f..f719606cd4b88d4a4eec7ed5c4096e56c2e45726 100644
--- a/dist/transform/schema-object.cjs
+++ b/dist/transform/schema-object.cjs
@@ -117,12 +117,7 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
         }
         itemType = transformSchemaObject({ ...item, required: itemRequired }, options);
       }
-      const discriminator = "$ref" in item && options.ctx.discriminators.objects[item.$ref] || item.discriminator;
-      if (discriminator) {
-        output.push(ts.tsOmit(itemType, [discriminator.propertyName]));
-      } else {
-        output.push(itemType);
-      }
+      output.push(itemType);
     }
     return output;
   }
diff --git a/dist/transform/schema-object.cjs.map b/dist/transform/schema-object.cjs.map
index dd7a3e50be47a83b36e26756e9eac23baaf78b75..957c9395797025f484e549a3455ed262a2713910 100644
--- a/dist/transform/schema-object.cjs.map
+++ b/dist/transform/schema-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"schema-object.cjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  QUESTION_TOKEN,\n  STRING,\n  UNDEFINED,\n  UNKNOWN,\n  addJSDocComment,\n  oapiRef,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScriptâ€™s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min â€¦\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // donâ€™t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // canâ€™t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        const property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties\n    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {\n      const hasExplicitAdditionalProperties =\n        typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n      const addlType = hasExplicitAdditionalProperties\n        ? transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options)\n        : UNKNOWN;\n      return tsIntersection([\n        ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n        ts.factory.createTypeLiteralNode([\n          ts.factory.createIndexSignature(\n            /* modifiers  */ tsModifiers({\n              readonly: options.ctx.immutable,\n            }),\n            /* parameters */ [\n              ts.factory.createParameterDeclaration(\n                /* modifiers      */ undefined,\n                /* dotDotDotToken */ undefined,\n                /* name           */ ts.factory.createIdentifier(\"key\"),\n                /* questionToken  */ undefined,\n                /* type           */ STRING,\n              ),\n            ],\n            /* type       */ addlType,\n          ),\n        ]),\n      ]);\n    }\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["NEVER","UNKNOWN","oapiRef","tsLiteral","parseRef","enumType","tsEnum","ts","tsUnion","NULL","tsArrayLiteralExpression","tsWithRequired","tsOmit","tsIntersection","tsIsPrimitive","tsRecord","STRING","tsNullable","UNDEFINED","NUMBER","BOOLEAN","createDiscriminatorProperty","getEntries","QUESTION_TOKEN","createRef","tsModifiers","tsPropertyIndex","addJSDocComment"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"schema-object.cjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  QUESTION_TOKEN,\n  STRING,\n  UNDEFINED,\n  UNKNOWN,\n  addJSDocComment,\n  oapiRef,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      output.push(itemType);\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScriptâ€™s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min â€¦\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // donâ€™t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // canâ€™t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        const property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties\n    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {\n      const hasExplicitAdditionalProperties =\n        typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n      const addlType = hasExplicitAdditionalProperties\n        ? transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options)\n        : UNKNOWN;\n      return tsIntersection([\n        ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n        ts.factory.createTypeLiteralNode([\n          ts.factory.createIndexSignature(\n            /* modifiers  */ tsModifiers({\n              readonly: options.ctx.immutable,\n            }),\n            /* parameters */ [\n              ts.factory.createParameterDeclaration(\n                /* modifiers      */ undefined,\n                /* dotDotDotToken */ undefined,\n                /* name           */ ts.factory.createIdentifier(\"key\"),\n                /* questionToken  */ undefined,\n                /* type           */ STRING,\n              ),\n            ],\n            /* type       */ addlType,\n          ),\n        ]),\n      ]);\n    }\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["NEVER","UNKNOWN","oapiRef","tsLiteral","parseRef","enumType","tsEnum","ts","tsUnion","NULL","tsArrayLiteralExpression","tsWithRequired","tsIntersection","tsIsPrimitive","tsRecord","STRING","tsNullable","UNDEFINED","NUMBER","BOOLEAN","createDiscriminatorProperty","getEntries","QUESTION_TOKEN","createRef","tsModifiers","tsPropertyIndex","addJSDocComment"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/schema-object.mjs b/dist/transform/schema-object.mjs
index bfcae19270bf33024cc76dbc78aa24617ef7876e..21952be9acd322ad6774d93e561b1381ca28c764 100644
--- a/dist/transform/schema-object.mjs
+++ b/dist/transform/schema-object.mjs
@@ -1,6 +1,6 @@
 import { parseRef } from '@redocly/openapi-core/lib/ref-utils.js';
 import ts from 'typescript';
-import { NEVER, UNKNOWN, oapiRef, tsLiteral, tsEnum, tsUnion, NULL, tsArrayLiteralExpression, tsIntersection, tsIsPrimitive, tsRecord, STRING, tsNullable, UNDEFINED, NUMBER, BOOLEAN, QUESTION_TOKEN, tsModifiers, tsPropertyIndex, addJSDocComment, tsWithRequired, tsOmit } from '../lib/ts.mjs';
+import { NEVER, UNKNOWN, oapiRef, tsLiteral, tsEnum, tsUnion, NULL, tsArrayLiteralExpression, tsIntersection, tsIsPrimitive, tsRecord, STRING, tsNullable, UNDEFINED, NUMBER, BOOLEAN, QUESTION_TOKEN, tsModifiers, tsPropertyIndex, addJSDocComment, tsWithRequired } from '../lib/ts.mjs';
 import { createDiscriminatorProperty, getEntries, createRef } from '../lib/utils.mjs';
 
 function transformSchemaObject(schemaObject, options) {
@@ -109,12 +109,7 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
         }
         itemType = transformSchemaObject({ ...item, required: itemRequired }, options);
       }
-      const discriminator = "$ref" in item && options.ctx.discriminators.objects[item.$ref] || item.discriminator;
-      if (discriminator) {
-        output.push(tsOmit(itemType, [discriminator.propertyName]));
-      } else {
-        output.push(itemType);
-      }
+      output.push(itemType);
     }
     return output;
   }
diff --git a/dist/transform/schema-object.mjs.map b/dist/transform/schema-object.mjs.map
index 7b2c8d6ba4ebcb92e26820db1b7acf7db78e840b..23b3573f52f9814d6683f97ac5cac6f2d981a8bc 100644
--- a/dist/transform/schema-object.mjs.map
+++ b/dist/transform/schema-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"schema-object.mjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  QUESTION_TOKEN,\n  STRING,\n  UNDEFINED,\n  UNKNOWN,\n  addJSDocComment,\n  oapiRef,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScriptâ€™s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min â€¦\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // donâ€™t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // canâ€™t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        const property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties\n    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {\n      const hasExplicitAdditionalProperties =\n        typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n      const addlType = hasExplicitAdditionalProperties\n        ? transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options)\n        : UNKNOWN;\n      return tsIntersection([\n        ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n        ts.factory.createTypeLiteralNode([\n          ts.factory.createIndexSignature(\n            /* modifiers  */ tsModifiers({\n              readonly: options.ctx.immutable,\n            }),\n            /* parameters */ [\n              ts.factory.createParameterDeclaration(\n                /* modifiers      */ undefined,\n                /* dotDotDotToken */ undefined,\n                /* name           */ ts.factory.createIdentifier(\"key\"),\n                /* questionToken  */ undefined,\n                /* type           */ STRING,\n              ),\n            ],\n            /* type       */ addlType,\n          ),\n        ]),\n      ]);\n    }\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["enumType"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"schema-object.mjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  QUESTION_TOKEN,\n  STRING,\n  UNDEFINED,\n  UNKNOWN,\n  addJSDocComment,\n  oapiRef,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      output.push(itemType);\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScriptâ€™s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min â€¦\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // donâ€™t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // canâ€™t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        const property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties\n    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {\n      const hasExplicitAdditionalProperties =\n        typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n      const addlType = hasExplicitAdditionalProperties\n        ? transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options)\n        : UNKNOWN;\n      return tsIntersection([\n        ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n        ts.factory.createTypeLiteralNode([\n          ts.factory.createIndexSignature(\n            /* modifiers  */ tsModifiers({\n              readonly: options.ctx.immutable,\n            }),\n            /* parameters */ [\n              ts.factory.createParameterDeclaration(\n                /* modifiers      */ undefined,\n                /* dotDotDotToken */ undefined,\n                /* name           */ ts.factory.createIdentifier(\"key\"),\n                /* questionToken  */ undefined,\n                /* type           */ STRING,\n              ),\n            ],\n            /* type       */ addlType,\n          ),\n        ]),\n      ]);\n    }\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["enumType"],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/index.cjs b/package/dist/index.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..a2a38744991540e00b6a085aed403feedf0c51b6
--- /dev/null
+++ b/package/dist/index.cjs
@@ -0,0 +1,3362 @@
+"use strict";
+var __create = Object.create;
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __getOwnPropNames = Object.getOwnPropertyNames;
+var __getProtoOf = Object.getPrototypeOf;
+var __hasOwnProp = Object.prototype.hasOwnProperty;
+var __typeError = (msg) => {
+  throw TypeError(msg);
+};
+var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __commonJS = (cb, mod) => function __require() {
+  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
+};
+var __export = (target, all) => {
+  for (var name in all)
+    __defProp(target, name, { get: all[name], enumerable: true });
+};
+var __copyProps = (to, from, except, desc) => {
+  if (from && typeof from === "object" || typeof from === "function") {
+    for (let key of __getOwnPropNames(from))
+      if (!__hasOwnProp.call(to, key) && key !== except)
+        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+  }
+  return to;
+};
+var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
+  // If the importer is in node compatibility mode or this is not an ESM
+  // file that has been converted to a CommonJS file using a Babel-
+  // compatible transform (i.e. "__esModule" has not been set), then set
+  // "default" to the CommonJS "module.exports" for node compatibility.
+  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
+  mod
+));
+var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
+var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
+var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
+var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
+var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
+var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
+
+// ../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js
+var require_picocolors = __commonJS({
+  "../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js"(exports2, module2) {
+    var p = process || {};
+    var argv = p.argv || [];
+    var env2 = p.env || {};
+    var isColorSupported = !(!!env2.NO_COLOR || argv.includes("--no-color")) && (!!env2.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env2.TERM !== "dumb" || !!env2.CI);
+    var formatter = (open, close, replace = open) => (input) => {
+      let string = "" + input, index = string.indexOf(close, open.length);
+      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
+    };
+    var replaceClose = (string, close, replace, index) => {
+      let result = "", cursor = 0;
+      do {
+        result += string.substring(cursor, index) + replace;
+        cursor = index + close.length;
+        index = string.indexOf(close, cursor);
+      } while (~index);
+      return result + string.substring(cursor);
+    };
+    var createColors = (enabled = isColorSupported) => {
+      let f = enabled ? formatter : () => String;
+      return {
+        isColorSupported: enabled,
+        reset: f("\x1B[0m", "\x1B[0m"),
+        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
+        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
+        italic: f("\x1B[3m", "\x1B[23m"),
+        underline: f("\x1B[4m", "\x1B[24m"),
+        inverse: f("\x1B[7m", "\x1B[27m"),
+        hidden: f("\x1B[8m", "\x1B[28m"),
+        strikethrough: f("\x1B[9m", "\x1B[29m"),
+        black: f("\x1B[30m", "\x1B[39m"),
+        red: f("\x1B[31m", "\x1B[39m"),
+        green: f("\x1B[32m", "\x1B[39m"),
+        yellow: f("\x1B[33m", "\x1B[39m"),
+        blue: f("\x1B[34m", "\x1B[39m"),
+        magenta: f("\x1B[35m", "\x1B[39m"),
+        cyan: f("\x1B[36m", "\x1B[39m"),
+        white: f("\x1B[37m", "\x1B[39m"),
+        gray: f("\x1B[90m", "\x1B[39m"),
+        bgBlack: f("\x1B[40m", "\x1B[49m"),
+        bgRed: f("\x1B[41m", "\x1B[49m"),
+        bgGreen: f("\x1B[42m", "\x1B[49m"),
+        bgYellow: f("\x1B[43m", "\x1B[49m"),
+        bgBlue: f("\x1B[44m", "\x1B[49m"),
+        bgMagenta: f("\x1B[45m", "\x1B[49m"),
+        bgCyan: f("\x1B[46m", "\x1B[49m"),
+        bgWhite: f("\x1B[47m", "\x1B[49m"),
+        blackBright: f("\x1B[90m", "\x1B[39m"),
+        redBright: f("\x1B[91m", "\x1B[39m"),
+        greenBright: f("\x1B[92m", "\x1B[39m"),
+        yellowBright: f("\x1B[93m", "\x1B[39m"),
+        blueBright: f("\x1B[94m", "\x1B[39m"),
+        magentaBright: f("\x1B[95m", "\x1B[39m"),
+        cyanBright: f("\x1B[96m", "\x1B[39m"),
+        whiteBright: f("\x1B[97m", "\x1B[39m"),
+        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
+        bgRedBright: f("\x1B[101m", "\x1B[49m"),
+        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
+        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
+        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
+        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
+        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
+        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
+      };
+    };
+    module2.exports = createColors();
+    module2.exports.createColors = createColors;
+  }
+});
+
+// ../../node_modules/.pnpm/js-tokens@4.0.0/node_modules/js-tokens/index.js
+var require_js_tokens = __commonJS({
+  "../../node_modules/.pnpm/js-tokens@4.0.0/node_modules/js-tokens/index.js"(exports2) {
+    Object.defineProperty(exports2, "__esModule", {
+      value: true
+    });
+    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
+    exports2.matchToToken = function(match) {
+      var token = { type: "invalid", value: match[0], closed: void 0 };
+      if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
+      else if (match[5]) token.type = "comment";
+      else if (match[6]) token.type = "comment", token.closed = !!match[7];
+      else if (match[8]) token.type = "regex";
+      else if (match[9]) token.type = "number";
+      else if (match[10]) token.type = "name";
+      else if (match[11]) token.type = "punctuator";
+      else if (match[12]) token.type = "whitespace";
+      return token;
+    };
+  }
+});
+
+// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/identifier.js
+var require_identifier = __commonJS({
+  "../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
+    "use strict";
+    Object.defineProperty(exports2, "__esModule", {
+      value: true
+    });
+    exports2.isIdentifierChar = isIdentifierChar;
+    exports2.isIdentifierName = isIdentifierName;
+    exports2.isIdentifierStart = isIdentifierStart;
+    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
+    var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
+    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
+    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
+    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
+    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
+    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
+    function isInAstralSet(code, set) {
+      let pos = 65536;
+      for (let i = 0, length = set.length; i < length; i += 2) {
+        pos += set[i];
+        if (pos > code) return false;
+        pos += set[i + 1];
+        if (pos >= code) return true;
+      }
+      return false;
+    }
+    function isIdentifierStart(code) {
+      if (code < 65) return code === 36;
+      if (code <= 90) return true;
+      if (code < 97) return code === 95;
+      if (code <= 122) return true;
+      if (code <= 65535) {
+        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
+      }
+      return isInAstralSet(code, astralIdentifierStartCodes);
+    }
+    function isIdentifierChar(code) {
+      if (code < 48) return code === 36;
+      if (code < 58) return true;
+      if (code < 65) return false;
+      if (code <= 90) return true;
+      if (code < 97) return code === 95;
+      if (code <= 122) return true;
+      if (code <= 65535) {
+        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
+      }
+      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
+    }
+    function isIdentifierName(name) {
+      let isFirst = true;
+      for (let i = 0; i < name.length; i++) {
+        let cp = name.charCodeAt(i);
+        if ((cp & 64512) === 55296 && i + 1 < name.length) {
+          const trail = name.charCodeAt(++i);
+          if ((trail & 64512) === 56320) {
+            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
+          }
+        }
+        if (isFirst) {
+          isFirst = false;
+          if (!isIdentifierStart(cp)) {
+            return false;
+          }
+        } else if (!isIdentifierChar(cp)) {
+          return false;
+        }
+      }
+      return !isFirst;
+    }
+  }
+});
+
+// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/keyword.js
+var require_keyword = __commonJS({
+  "../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
+    "use strict";
+    Object.defineProperty(exports2, "__esModule", {
+      value: true
+    });
+    exports2.isKeyword = isKeyword;
+    exports2.isReservedWord = isReservedWord;
+    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
+    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
+    exports2.isStrictReservedWord = isStrictReservedWord;
+    var reservedWords = {
+      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
+      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
+      strictBind: ["eval", "arguments"]
+    };
+    var keywords = new Set(reservedWords.keyword);
+    var reservedWordsStrictSet = new Set(reservedWords.strict);
+    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
+    function isReservedWord(word, inModule) {
+      return inModule && word === "await" || word === "enum";
+    }
+    function isStrictReservedWord(word, inModule) {
+      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
+    }
+    function isStrictBindOnlyReservedWord(word) {
+      return reservedWordsStrictBindSet.has(word);
+    }
+    function isStrictBindReservedWord(word, inModule) {
+      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
+    }
+    function isKeyword(word) {
+      return keywords.has(word);
+    }
+  }
+});
+
+// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js
+var require_lib = __commonJS({
+  "../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
+    "use strict";
+    Object.defineProperty(exports2, "__esModule", {
+      value: true
+    });
+    Object.defineProperty(exports2, "isIdentifierChar", {
+      enumerable: true,
+      get: function() {
+        return _identifier.isIdentifierChar;
+      }
+    });
+    Object.defineProperty(exports2, "isIdentifierName", {
+      enumerable: true,
+      get: function() {
+        return _identifier.isIdentifierName;
+      }
+    });
+    Object.defineProperty(exports2, "isIdentifierStart", {
+      enumerable: true,
+      get: function() {
+        return _identifier.isIdentifierStart;
+      }
+    });
+    Object.defineProperty(exports2, "isKeyword", {
+      enumerable: true,
+      get: function() {
+        return _keyword.isKeyword;
+      }
+    });
+    Object.defineProperty(exports2, "isReservedWord", {
+      enumerable: true,
+      get: function() {
+        return _keyword.isReservedWord;
+      }
+    });
+    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
+      enumerable: true,
+      get: function() {
+        return _keyword.isStrictBindOnlyReservedWord;
+      }
+    });
+    Object.defineProperty(exports2, "isStrictBindReservedWord", {
+      enumerable: true,
+      get: function() {
+        return _keyword.isStrictBindReservedWord;
+      }
+    });
+    Object.defineProperty(exports2, "isStrictReservedWord", {
+      enumerable: true,
+      get: function() {
+        return _keyword.isStrictReservedWord;
+      }
+    });
+    var _identifier = require_identifier();
+    var _keyword = require_keyword();
+  }
+});
+
+// ../../node_modules/.pnpm/@babel+code-frame@7.26.2/node_modules/@babel/code-frame/lib/index.js
+var require_lib2 = __commonJS({
+  "../../node_modules/.pnpm/@babel+code-frame@7.26.2/node_modules/@babel/code-frame/lib/index.js"(exports2) {
+    "use strict";
+    Object.defineProperty(exports2, "__esModule", { value: true });
+    var picocolors = require_picocolors();
+    var jsTokens = require_js_tokens();
+    var helperValidatorIdentifier = require_lib();
+    function isColorSupported() {
+      return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
+    }
+    var compose = (f, g) => (v) => f(g(v));
+    function buildDefs(colors) {
+      return {
+        keyword: colors.cyan,
+        capitalized: colors.yellow,
+        jsxIdentifier: colors.yellow,
+        punctuator: colors.yellow,
+        number: colors.magenta,
+        string: colors.green,
+        regex: colors.magenta,
+        comment: colors.gray,
+        invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
+        gutter: colors.gray,
+        marker: compose(colors.red, colors.bold),
+        message: compose(colors.red, colors.bold),
+        reset: colors.reset
+      };
+    }
+    var defsOn = buildDefs(picocolors.createColors(true));
+    var defsOff = buildDefs(picocolors.createColors(false));
+    function getDefs(enabled) {
+      return enabled ? defsOn : defsOff;
+    }
+    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
+    var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
+    var BRACKET = /^[()[\]{}]$/;
+    var tokenize;
+    {
+      const JSX_TAG = /^[a-z][\w-]*$/i;
+      const getTokenType = function(token, offset, text) {
+        if (token.type === "name") {
+          if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
+            return "keyword";
+          }
+          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
+            return "jsxIdentifier";
+          }
+          if (token.value[0] !== token.value[0].toLowerCase()) {
+            return "capitalized";
+          }
+        }
+        if (token.type === "punctuator" && BRACKET.test(token.value)) {
+          return "bracket";
+        }
+        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
+          return "punctuator";
+        }
+        return token.type;
+      };
+      tokenize = function* (text) {
+        let match;
+        while (match = jsTokens.default.exec(text)) {
+          const token = jsTokens.matchToToken(match);
+          yield {
+            type: getTokenType(token, match.index, text),
+            value: token.value
+          };
+        }
+      };
+    }
+    function highlight(text) {
+      if (text === "") return "";
+      const defs = getDefs(true);
+      let highlighted = "";
+      for (const {
+        type,
+        value
+      } of tokenize(text)) {
+        if (type in defs) {
+          highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join("\n");
+        } else {
+          highlighted += value;
+        }
+      }
+      return highlighted;
+    }
+    var deprecationWarningShown = false;
+    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
+    function getMarkerLines(loc, source, opts) {
+      const startLoc = Object.assign({
+        column: 0,
+        line: -1
+      }, loc.start);
+      const endLoc = Object.assign({}, startLoc, loc.end);
+      const {
+        linesAbove = 2,
+        linesBelow = 3
+      } = opts || {};
+      const startLine = startLoc.line;
+      const startColumn = startLoc.column;
+      const endLine = endLoc.line;
+      const endColumn = endLoc.column;
+      let start = Math.max(startLine - (linesAbove + 1), 0);
+      let end = Math.min(source.length, endLine + linesBelow);
+      if (startLine === -1) {
+        start = 0;
+      }
+      if (endLine === -1) {
+        end = source.length;
+      }
+      const lineDiff = endLine - startLine;
+      const markerLines = {};
+      if (lineDiff) {
+        for (let i = 0; i <= lineDiff; i++) {
+          const lineNumber = i + startLine;
+          if (!startColumn) {
+            markerLines[lineNumber] = true;
+          } else if (i === 0) {
+            const sourceLength = source[lineNumber - 1].length;
+            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
+          } else if (i === lineDiff) {
+            markerLines[lineNumber] = [0, endColumn];
+          } else {
+            const sourceLength = source[lineNumber - i].length;
+            markerLines[lineNumber] = [0, sourceLength];
+          }
+        }
+      } else {
+        if (startColumn === endColumn) {
+          if (startColumn) {
+            markerLines[startLine] = [startColumn, 0];
+          } else {
+            markerLines[startLine] = true;
+          }
+        } else {
+          markerLines[startLine] = [startColumn, endColumn - startColumn];
+        }
+      }
+      return {
+        start,
+        end,
+        markerLines
+      };
+    }
+    function codeFrameColumns2(rawLines, loc, opts = {}) {
+      const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
+      const defs = getDefs(shouldHighlight);
+      const lines = rawLines.split(NEWLINE);
+      const {
+        start,
+        end,
+        markerLines
+      } = getMarkerLines(loc, lines, opts);
+      const hasColumns = loc.start && typeof loc.start.column === "number";
+      const numberMaxWidth = String(end).length;
+      const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
+      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index2) => {
+        const number = start + 1 + index2;
+        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
+        const gutter = ` ${paddedNumber} |`;
+        const hasMarker = markerLines[number];
+        const lastMarkerLine = !markerLines[number + 1];
+        if (hasMarker) {
+          let markerLine = "";
+          if (Array.isArray(hasMarker)) {
+            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
+            const numberOfMarkers = hasMarker[1] || 1;
+            markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
+            if (lastMarkerLine && opts.message) {
+              markerLine += " " + defs.message(opts.message);
+            }
+          }
+          return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
+        } else {
+          return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
+        }
+      }).join("\n");
+      if (opts.message && !hasColumns) {
+        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
+${frame}`;
+      }
+      if (shouldHighlight) {
+        return defs.reset(frame);
+      } else {
+        return frame;
+      }
+    }
+    function index(rawLines, lineNumber, colNumber, opts = {}) {
+      if (!deprecationWarningShown) {
+        deprecationWarningShown = true;
+        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
+        if (process.emitWarning) {
+          process.emitWarning(message, "DeprecationWarning");
+        } else {
+          const deprecationError = new Error(message);
+          deprecationError.name = "DeprecationWarning";
+          console.warn(new Error(message));
+        }
+      }
+      colNumber = Math.max(colNumber, 0);
+      const location = {
+        start: {
+          column: colNumber,
+          line: lineNumber
+        }
+      };
+      return codeFrameColumns2(rawLines, location, opts);
+    }
+    exports2.codeFrameColumns = codeFrameColumns2;
+    exports2.default = index;
+    exports2.highlight = highlight;
+  }
+});
+
+// ../../node_modules/.pnpm/ansi-colors@4.1.3/node_modules/ansi-colors/symbols.js
+var require_symbols = __commonJS({
+  "../../node_modules/.pnpm/ansi-colors@4.1.3/node_modules/ansi-colors/symbols.js"(exports2, module2) {
+    "use strict";
+    var isHyper = typeof process !== "undefined" && process.env.TERM_PROGRAM === "Hyper";
+    var isWindows = typeof process !== "undefined" && process.platform === "win32";
+    var isLinux = typeof process !== "undefined" && process.platform === "linux";
+    var common = {
+      ballotDisabled: "\u2612",
+      ballotOff: "\u2610",
+      ballotOn: "\u2611",
+      bullet: "\u2022",
+      bulletWhite: "\u25E6",
+      fullBlock: "\u2588",
+      heart: "\u2764",
+      identicalTo: "\u2261",
+      line: "\u2500",
+      mark: "\u203B",
+      middot: "\xB7",
+      minus: "\uFF0D",
+      multiplication: "\xD7",
+      obelus: "\xF7",
+      pencilDownRight: "\u270E",
+      pencilRight: "\u270F",
+      pencilUpRight: "\u2710",
+      percent: "%",
+      pilcrow2: "\u2761",
+      pilcrow: "\xB6",
+      plusMinus: "\xB1",
+      question: "?",
+      section: "\xA7",
+      starsOff: "\u2606",
+      starsOn: "\u2605",
+      upDownArrow: "\u2195"
+    };
+    var windows = Object.assign({}, common, {
+      check: "\u221A",
+      cross: "\xD7",
+      ellipsisLarge: "...",
+      ellipsis: "...",
+      info: "i",
+      questionSmall: "?",
+      pointer: ">",
+      pointerSmall: "\xBB",
+      radioOff: "( )",
+      radioOn: "(*)",
+      warning: "\u203C"
+    });
+    var other = Object.assign({}, common, {
+      ballotCross: "\u2718",
+      check: "\u2714",
+      cross: "\u2716",
+      ellipsisLarge: "\u22EF",
+      ellipsis: "\u2026",
+      info: "\u2139",
+      questionFull: "\uFF1F",
+      questionSmall: "\uFE56",
+      pointer: isLinux ? "\u25B8" : "\u276F",
+      pointerSmall: isLinux ? "\u2023" : "\u203A",
+      radioOff: "\u25EF",
+      radioOn: "\u25C9",
+      warning: "\u26A0"
+    });
+    module2.exports = isWindows && !isHyper ? windows : other;
+    Reflect.defineProperty(module2.exports, "common", { enumerable: false, value: common });
+    Reflect.defineProperty(module2.exports, "windows", { enumerable: false, value: windows });
+    Reflect.defineProperty(module2.exports, "other", { enumerable: false, value: other });
+  }
+});
+
+// ../../node_modules/.pnpm/ansi-colors@4.1.3/node_modules/ansi-colors/index.js
+var require_ansi_colors = __commonJS({
+  "../../node_modules/.pnpm/ansi-colors@4.1.3/node_modules/ansi-colors/index.js"(exports2, module2) {
+    "use strict";
+    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
+    var ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;
+    var hasColor = () => {
+      if (typeof process !== "undefined") {
+        return process.env.FORCE_COLOR !== "0";
+      }
+      return false;
+    };
+    var create = () => {
+      const colors = {
+        enabled: hasColor(),
+        visible: true,
+        styles: {},
+        keys: {}
+      };
+      const ansi = (style2) => {
+        let open = style2.open = `\x1B[${style2.codes[0]}m`;
+        let close = style2.close = `\x1B[${style2.codes[1]}m`;
+        let regex = style2.regex = new RegExp(`\\u001b\\[${style2.codes[1]}m`, "g");
+        style2.wrap = (input, newline) => {
+          if (input.includes(close)) input = input.replace(regex, close + open);
+          let output = open + input + close;
+          return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
+        };
+        return style2;
+      };
+      const wrap = (style2, input, newline) => {
+        return typeof style2 === "function" ? style2(input) : style2.wrap(input, newline);
+      };
+      const style = (input, stack) => {
+        if (input === "" || input == null) return "";
+        if (colors.enabled === false) return input;
+        if (colors.visible === false) return "";
+        let str = "" + input;
+        let nl = str.includes("\n");
+        let n = stack.length;
+        if (n > 0 && stack.includes("unstyle")) {
+          stack = [.../* @__PURE__ */ new Set(["unstyle", ...stack])].reverse();
+        }
+        while (n-- > 0) str = wrap(colors.styles[stack[n]], str, nl);
+        return str;
+      };
+      const define = (name, codes, type) => {
+        colors.styles[name] = ansi({ name, codes });
+        let keys = colors.keys[type] || (colors.keys[type] = []);
+        keys.push(name);
+        Reflect.defineProperty(colors, name, {
+          configurable: true,
+          enumerable: true,
+          set(value) {
+            colors.alias(name, value);
+          },
+          get() {
+            let color = (input) => style(input, color.stack);
+            Reflect.setPrototypeOf(color, colors);
+            color.stack = this.stack ? this.stack.concat(name) : [name];
+            return color;
+          }
+        });
+      };
+      define("reset", [0, 0], "modifier");
+      define("bold", [1, 22], "modifier");
+      define("dim", [2, 22], "modifier");
+      define("italic", [3, 23], "modifier");
+      define("underline", [4, 24], "modifier");
+      define("inverse", [7, 27], "modifier");
+      define("hidden", [8, 28], "modifier");
+      define("strikethrough", [9, 29], "modifier");
+      define("black", [30, 39], "color");
+      define("red", [31, 39], "color");
+      define("green", [32, 39], "color");
+      define("yellow", [33, 39], "color");
+      define("blue", [34, 39], "color");
+      define("magenta", [35, 39], "color");
+      define("cyan", [36, 39], "color");
+      define("white", [37, 39], "color");
+      define("gray", [90, 39], "color");
+      define("grey", [90, 39], "color");
+      define("bgBlack", [40, 49], "bg");
+      define("bgRed", [41, 49], "bg");
+      define("bgGreen", [42, 49], "bg");
+      define("bgYellow", [43, 49], "bg");
+      define("bgBlue", [44, 49], "bg");
+      define("bgMagenta", [45, 49], "bg");
+      define("bgCyan", [46, 49], "bg");
+      define("bgWhite", [47, 49], "bg");
+      define("blackBright", [90, 39], "bright");
+      define("redBright", [91, 39], "bright");
+      define("greenBright", [92, 39], "bright");
+      define("yellowBright", [93, 39], "bright");
+      define("blueBright", [94, 39], "bright");
+      define("magentaBright", [95, 39], "bright");
+      define("cyanBright", [96, 39], "bright");
+      define("whiteBright", [97, 39], "bright");
+      define("bgBlackBright", [100, 49], "bgBright");
+      define("bgRedBright", [101, 49], "bgBright");
+      define("bgGreenBright", [102, 49], "bgBright");
+      define("bgYellowBright", [103, 49], "bgBright");
+      define("bgBlueBright", [104, 49], "bgBright");
+      define("bgMagentaBright", [105, 49], "bgBright");
+      define("bgCyanBright", [106, 49], "bgBright");
+      define("bgWhiteBright", [107, 49], "bgBright");
+      colors.ansiRegex = ANSI_REGEX;
+      colors.hasColor = colors.hasAnsi = (str) => {
+        colors.ansiRegex.lastIndex = 0;
+        return typeof str === "string" && str !== "" && colors.ansiRegex.test(str);
+      };
+      colors.alias = (name, color) => {
+        let fn = typeof color === "string" ? colors[color] : color;
+        if (typeof fn !== "function") {
+          throw new TypeError("Expected alias to be the name of an existing color (string) or a function");
+        }
+        if (!fn.stack) {
+          Reflect.defineProperty(fn, "name", { value: name });
+          colors.styles[name] = fn;
+          fn.stack = [name];
+        }
+        Reflect.defineProperty(colors, name, {
+          configurable: true,
+          enumerable: true,
+          set(value) {
+            colors.alias(name, value);
+          },
+          get() {
+            let color2 = (input) => style(input, color2.stack);
+            Reflect.setPrototypeOf(color2, colors);
+            color2.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
+            return color2;
+          }
+        });
+      };
+      colors.theme = (custom) => {
+        if (!isObject(custom)) throw new TypeError("Expected theme to be an object");
+        for (let name of Object.keys(custom)) {
+          colors.alias(name, custom[name]);
+        }
+        return colors;
+      };
+      colors.alias("unstyle", (str) => {
+        if (typeof str === "string" && str !== "") {
+          colors.ansiRegex.lastIndex = 0;
+          return str.replace(colors.ansiRegex, "");
+        }
+        return "";
+      });
+      colors.alias("noop", (str) => str);
+      colors.none = colors.clear = colors.noop;
+      colors.stripColor = colors.unstyle;
+      colors.symbols = require_symbols();
+      colors.define = define;
+      return colors;
+    };
+    module2.exports = create();
+    module2.exports.create = create;
+  }
+});
+
+// src/index.ts
+var index_exports = {};
+__export(index_exports, {
+  BOOLEAN: () => BOOLEAN,
+  COMMENT_HEADER: () => COMMENT_HEADER,
+  FALSE: () => FALSE,
+  JS_ENUM_INVALID_CHARS_RE: () => JS_ENUM_INVALID_CHARS_RE,
+  JS_PROPERTY_INDEX_INVALID_CHARS_RE: () => JS_PROPERTY_INDEX_INVALID_CHARS_RE,
+  JS_PROPERTY_INDEX_RE: () => JS_PROPERTY_INDEX_RE,
+  NEVER: () => NEVER,
+  NULL: () => NULL,
+  NUMBER: () => NUMBER,
+  QUESTION_TOKEN: () => QUESTION_TOKEN,
+  SPECIAL_CHARACTER_MAP: () => SPECIAL_CHARACTER_MAP,
+  STRING: () => STRING,
+  TRUE: () => TRUE,
+  UNDEFINED: () => UNDEFINED,
+  UNKNOWN: () => UNKNOWN,
+  addJSDocComment: () => addJSDocComment,
+  astToString: () => astToString,
+  c: () => import_ansi_colors.default,
+  createDiscriminatorProperty: () => createDiscriminatorProperty,
+  createRef: () => createRef,
+  debug: () => debug,
+  default: () => openapiTS,
+  enumCache: () => enumCache,
+  error: () => error,
+  formatTime: () => formatTime,
+  getEntries: () => getEntries,
+  injectOperationObject: () => injectOperationObject,
+  oapiRef: () => oapiRef,
+  resolveRef: () => resolveRef,
+  scanDiscriminators: () => scanDiscriminators,
+  stringToAST: () => stringToAST,
+  transformComponentsObject: () => transformComponentsObject,
+  transformHeaderObject: () => transformHeaderObject,
+  transformMediaTypeObject: () => transformMediaTypeObject,
+  transformOperationObject: () => transformOperationObject,
+  transformParameterObject: () => transformParameterObject,
+  transformPathItemObject: () => transformPathItemObject,
+  transformPathsObject: () => transformPathsObject,
+  transformRequestBodyObject: () => transformRequestBodyObject,
+  transformResponseObject: () => transformResponseObject,
+  transformResponsesObject: () => transformResponsesObject,
+  transformSchema: () => transformSchema,
+  transformSchemaObject: () => transformSchemaObject,
+  transformSchemaObjectWithComposition: () => transformSchemaObjectWithComposition,
+  tsArrayLiteralExpression: () => tsArrayLiteralExpression,
+  tsDedupe: () => tsDedupe,
+  tsEnum: () => tsEnum,
+  tsEnumMember: () => tsEnumMember,
+  tsIntersection: () => tsIntersection,
+  tsIsPrimitive: () => tsIsPrimitive,
+  tsLiteral: () => tsLiteral,
+  tsModifiers: () => tsModifiers,
+  tsNullable: () => tsNullable,
+  tsOmit: () => tsOmit,
+  tsPropertyIndex: () => tsPropertyIndex,
+  tsReadonlyArray: () => tsReadonlyArray,
+  tsRecord: () => tsRecord,
+  tsUnion: () => tsUnion,
+  tsWithRequired: () => tsWithRequired,
+  walk: () => walk,
+  warn: () => warn
+});
+module.exports = __toCommonJS(index_exports);
+var import_openapi_core2 = require("@redocly/openapi-core");
+var import_node_perf_hooks5 = require("node:perf_hooks");
+
+// src/lib/redoc.ts
+var import_openapi_core = require("@redocly/openapi-core");
+var import_node_perf_hooks = require("node:perf_hooks");
+var import_node_stream = require("node:stream");
+var import_node_url = require("node:url");
+
+// ../../node_modules/.pnpm/parse-json@8.1.0/node_modules/parse-json/index.js
+var import_code_frame = __toESM(require_lib2(), 1);
+
+// ../../node_modules/.pnpm/index-to-position@0.1.2/node_modules/index-to-position/index.js
+var safeLastIndexOf = (string, searchString, index) => index < 0 ? -1 : string.lastIndexOf(searchString, index);
+function getPosition(text, textIndex) {
+  const lineBreakBefore = safeLastIndexOf(text, "\n", textIndex - 1);
+  const column = textIndex - lineBreakBefore - 1;
+  let line = 0;
+  for (let index = lineBreakBefore; index >= 0; index = safeLastIndexOf(text, "\n", index - 1)) {
+    line++;
+  }
+  return { line, column };
+}
+function indexToLineColumn(text, textIndex, { oneBased = false } = {}) {
+  if (textIndex < 0 || textIndex >= text.length && text.length > 0) {
+    throw new RangeError("Index out of bounds");
+  }
+  const position = getPosition(text, textIndex);
+  return oneBased ? { line: position.line + 1, column: position.column + 1 } : position;
+}
+
+// ../../node_modules/.pnpm/parse-json@8.1.0/node_modules/parse-json/index.js
+var getCodePoint = (character) => `\\u{${character.codePointAt(0).toString(16)}}`;
+var _message;
+var _JSONError = class _JSONError extends Error {
+  constructor(message) {
+    var _a;
+    super();
+    __publicField(this, "name", "JSONError");
+    __publicField(this, "fileName");
+    __publicField(this, "codeFrame");
+    __publicField(this, "rawCodeFrame");
+    __privateAdd(this, _message);
+    __privateSet(this, _message, message);
+    (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, this, _JSONError);
+  }
+  get message() {
+    const { fileName, codeFrame } = this;
+    return `${__privateGet(this, _message)}${fileName ? ` in ${fileName}` : ""}${codeFrame ? `
+
+${codeFrame}
+` : ""}`;
+  }
+  set message(message) {
+    __privateSet(this, _message, message);
+  }
+};
+_message = new WeakMap();
+var JSONError = _JSONError;
+var generateCodeFrame = (string, location, highlightCode = true) => (0, import_code_frame.codeFrameColumns)(string, { start: location }, { highlightCode });
+var getErrorLocation = (string, message) => {
+  const match = message.match(/in JSON at position (?<index>\d+)(?: \(line (?<line>\d+) column (?<column>\d+)\))?$/);
+  if (!match) {
+    return;
+  }
+  let { index, line, column } = match.groups;
+  if (line && column) {
+    return { line: Number(line), column: Number(column) };
+  }
+  index = Number(index);
+  if (index === string.length) {
+    const { line: line2, column: column2 } = indexToLineColumn(string, string.length - 1, { oneBased: true });
+    return { line: line2, column: column2 + 1 };
+  }
+  return indexToLineColumn(string, index, { oneBased: true });
+};
+var addCodePointToUnexpectedToken = (message) => message.replace(
+  // TODO[engine:node@>=20]: The token always quoted after Node.js 20
+  /(?<=^Unexpected token )(?<quote>')?(.)\k<quote>/,
+  (_, _quote, token) => `"${token}"(${getCodePoint(token)})`
+);
+function parseJson(string, reviver, fileName) {
+  if (typeof reviver === "string") {
+    fileName = reviver;
+    reviver = void 0;
+  }
+  let message;
+  try {
+    return JSON.parse(string, reviver);
+  } catch (error2) {
+    message = error2.message;
+  }
+  let location;
+  if (string) {
+    location = getErrorLocation(string, message);
+    message = addCodePointToUnexpectedToken(message);
+  } else {
+    message += " while parsing empty string";
+  }
+  const jsonError = new JSONError(message);
+  jsonError.fileName = fileName;
+  if (location) {
+    jsonError.codeFrame = generateCodeFrame(string, location);
+    jsonError.rawCodeFrame = generateCodeFrame(
+      string,
+      location,
+      /* highlightCode */
+      false
+    );
+  }
+  throw jsonError;
+}
+
+// src/lib/utils.ts
+var import_ref_utils2 = require("@redocly/openapi-core/lib/ref-utils.js");
+var import_ansi_colors = __toESM(require_ansi_colors(), 1);
+
+// ../../node_modules/.pnpm/supports-color@9.4.0/node_modules/supports-color/index.js
+var import_node_process = __toESM(require("node:process"), 1);
+var import_node_os = __toESM(require("node:os"), 1);
+var import_node_tty = __toESM(require("node:tty"), 1);
+function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
+  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
+  const position = argv.indexOf(prefix + flag);
+  const terminatorPosition = argv.indexOf("--");
+  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
+}
+var { env } = import_node_process.default;
+var flagForceColor;
+if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
+  flagForceColor = 0;
+} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
+  flagForceColor = 1;
+}
+function envForceColor() {
+  if ("FORCE_COLOR" in env) {
+    if (env.FORCE_COLOR === "true") {
+      return 1;
+    }
+    if (env.FORCE_COLOR === "false") {
+      return 0;
+    }
+    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
+  }
+}
+function translateLevel(level) {
+  if (level === 0) {
+    return false;
+  }
+  return {
+    level,
+    hasBasic: true,
+    has256: level >= 2,
+    has16m: level >= 3
+  };
+}
+function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
+  const noFlagForceColor = envForceColor();
+  if (noFlagForceColor !== void 0) {
+    flagForceColor = noFlagForceColor;
+  }
+  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
+  if (forceColor === 0) {
+    return 0;
+  }
+  if (sniffFlags) {
+    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
+      return 3;
+    }
+    if (hasFlag("color=256")) {
+      return 2;
+    }
+  }
+  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
+    return 1;
+  }
+  if (haveStream && !streamIsTTY && forceColor === void 0) {
+    return 0;
+  }
+  const min = forceColor || 0;
+  if (env.TERM === "dumb") {
+    return min;
+  }
+  if (import_node_process.default.platform === "win32") {
+    const osRelease = import_node_os.default.release().split(".");
+    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
+      return Number(osRelease[2]) >= 14931 ? 3 : 2;
+    }
+    return 1;
+  }
+  if ("CI" in env) {
+    if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env) {
+      return 3;
+    }
+    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
+      return 1;
+    }
+    return min;
+  }
+  if ("TEAMCITY_VERSION" in env) {
+    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
+  }
+  if (env.COLORTERM === "truecolor") {
+    return 3;
+  }
+  if (env.TERM === "xterm-kitty") {
+    return 3;
+  }
+  if ("TERM_PROGRAM" in env) {
+    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
+    switch (env.TERM_PROGRAM) {
+      case "iTerm.app": {
+        return version >= 3 ? 3 : 2;
+      }
+      case "Apple_Terminal": {
+        return 2;
+      }
+    }
+  }
+  if (/-256(color)?$/i.test(env.TERM)) {
+    return 2;
+  }
+  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
+    return 1;
+  }
+  if ("COLORTERM" in env) {
+    return 1;
+  }
+  return min;
+}
+function createSupportsColor(stream, options = {}) {
+  const level = _supportsColor(stream, {
+    streamIsTTY: stream && stream.isTTY,
+    ...options
+  });
+  return translateLevel(level);
+}
+var supportsColor = {
+  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
+  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
+};
+var supports_color_default = supportsColor;
+
+// src/lib/utils.ts
+var import_typescript2 = __toESM(require("typescript"), 1);
+
+// src/lib/ts.ts
+var import_ref_utils = require("@redocly/openapi-core/lib/ref-utils.js");
+var import_typescript = __toESM(require("typescript"), 1);
+var JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;
+var JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;
+var JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;
+var SPECIAL_CHARACTER_MAP = {
+  "+": "Plus"
+  // Add more mappings as needed
+};
+var BOOLEAN = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.BooleanKeyword);
+var FALSE = import_typescript.default.factory.createLiteralTypeNode(import_typescript.default.factory.createFalse());
+var NEVER = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.NeverKeyword);
+var NULL = import_typescript.default.factory.createLiteralTypeNode(import_typescript.default.factory.createNull());
+var NUMBER = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.NumberKeyword);
+var QUESTION_TOKEN = import_typescript.default.factory.createToken(import_typescript.default.SyntaxKind.QuestionToken);
+var STRING = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.StringKeyword);
+var TRUE = import_typescript.default.factory.createLiteralTypeNode(import_typescript.default.factory.createTrue());
+var UNDEFINED = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.UndefinedKeyword);
+var UNKNOWN = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.UnknownKeyword);
+var LB_RE = /\r?\n/g;
+var COMMENT_RE = /\*\//g;
+function addJSDocComment(schemaObject, node) {
+  if (!schemaObject || typeof schemaObject !== "object" || Array.isArray(schemaObject)) {
+    return;
+  }
+  const output = [];
+  if (schemaObject.title) {
+    output.push(schemaObject.title.replace(LB_RE, "\n *     "));
+  }
+  if (schemaObject.summary) {
+    output.push(schemaObject.summary.replace(LB_RE, "\n *     "));
+  }
+  if (schemaObject.format) {
+    output.push(`Format: ${schemaObject.format}`);
+  }
+  if (schemaObject.deprecated) {
+    output.push("@deprecated");
+  }
+  const supportedJsDocTags = ["description", "default", "example"];
+  for (const field of supportedJsDocTags) {
+    const allowEmptyString = field === "default" || field === "example";
+    if (schemaObject[field] === void 0) {
+      continue;
+    }
+    if (schemaObject[field] === "" && !allowEmptyString) {
+      continue;
+    }
+    const serialized = typeof schemaObject[field] === "object" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];
+    output.push(`@${field} ${String(serialized).replace(LB_RE, "\n *     ")}`);
+  }
+  if ("const" in schemaObject) {
+    output.push("@constant");
+  }
+  if (schemaObject.enum) {
+    let type = "unknown";
+    if (Array.isArray(schemaObject.type)) {
+      type = schemaObject.type.join("|");
+    } else if (typeof schemaObject.type === "string") {
+      type = schemaObject.type;
+    }
+    output.push(`@enum {${type}${schemaObject.nullable ? "|null" : ""}}`);
+  }
+  if (output.length) {
+    let text = output.length === 1 ? `* ${output.join("\n")} ` : `*
+ * ${output.join("\n * ")}
+ `;
+    text = text.replace(COMMENT_RE, "*\\/");
+    import_typescript.default.addSyntheticLeadingComment(
+      /* node               */
+      node,
+      /* kind               */
+      import_typescript.default.SyntaxKind.MultiLineCommentTrivia,
+      // note: MultiLine just refers to a "/* */" comment
+      /* text               */
+      text,
+      /* hasTrailingNewLine */
+      true
+    );
+  }
+}
+function oapiRef(path) {
+  const { pointer } = (0, import_ref_utils.parseRef)(path);
+  if (pointer.length === 0) {
+    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);
+  }
+  let t = import_typescript.default.factory.createTypeReferenceNode(
+    import_typescript.default.factory.createIdentifier(String(pointer[0]))
+  );
+  if (pointer.length > 1) {
+    for (let i = 1; i < pointer.length; i++) {
+      if (i > 2 && i < pointer.length - 1 && pointer[i] === "properties") {
+        continue;
+      }
+      t = import_typescript.default.factory.createIndexedAccessTypeNode(
+        t,
+        import_typescript.default.factory.createLiteralTypeNode(
+          typeof pointer[i] === "number" ? import_typescript.default.factory.createNumericLiteral(pointer[i]) : import_typescript.default.factory.createStringLiteral(pointer[i])
+        )
+      );
+    }
+  }
+  return t;
+}
+function astToString(ast, options) {
+  var _a, _b;
+  const sourceFile = import_typescript.default.createSourceFile(
+    (_a = options == null ? void 0 : options.fileName) != null ? _a : "openapi-ts.ts",
+    (_b = options == null ? void 0 : options.sourceText) != null ? _b : "",
+    import_typescript.default.ScriptTarget.ESNext,
+    false,
+    import_typescript.default.ScriptKind.TS
+  );
+  sourceFile.statements = import_typescript.default.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);
+  const printer = import_typescript.default.createPrinter({
+    newLine: import_typescript.default.NewLineKind.LineFeed,
+    removeComments: false,
+    ...options == null ? void 0 : options.formatOptions
+  });
+  return printer.printFile(sourceFile);
+}
+function stringToAST(source) {
+  return import_typescript.default.createSourceFile(
+    /* fileName        */
+    "stringInput",
+    /* sourceText      */
+    source,
+    /* languageVersion */
+    import_typescript.default.ScriptTarget.ESNext,
+    /* setParentNodes  */
+    void 0,
+    /* scriptKind      */
+    void 0
+  ).statements;
+}
+function tsDedupe(types) {
+  var _a, _b;
+  const encounteredTypes = /* @__PURE__ */ new Set();
+  const filteredTypes = [];
+  for (const t of types) {
+    if (!("text" in ((_a = t.literal) != null ? _a : t))) {
+      const { kind } = (_b = t.literal) != null ? _b : t;
+      if (encounteredTypes.has(kind)) {
+        continue;
+      }
+      if (tsIsPrimitive(t)) {
+        encounteredTypes.add(kind);
+      }
+    }
+    filteredTypes.push(t);
+  }
+  return filteredTypes;
+}
+var enumCache = /* @__PURE__ */ new Map();
+function tsEnum(name, members, metadata, options) {
+  var _a;
+  let enumName = sanitizeMemberName(name);
+  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;
+  let key = "";
+  if (options == null ? void 0 : options.shouldCache) {
+    key = `${members.slice(0).sort().map((v, i) => {
+      var _a2, _b, _c;
+      return `${(_b = (_a2 = metadata == null ? void 0 : metadata[i]) == null ? void 0 : _a2.name) != null ? _b : String(v)}:${((_c = metadata == null ? void 0 : metadata[i]) == null ? void 0 : _c.description) || ""}`;
+    }).join(",")}`;
+    if (enumCache.has(key)) {
+      return enumCache.get(key);
+    }
+  }
+  const enumDeclaration = import_typescript.default.factory.createEnumDeclaration(
+    /* modifiers */
+    options ? tsModifiers({ export: (_a = options.export) != null ? _a : false }) : void 0,
+    /* name      */
+    enumName,
+    /* members   */
+    members.map((value, i) => tsEnumMember(value, metadata == null ? void 0 : metadata[i]))
+  );
+  (options == null ? void 0 : options.shouldCache) && enumCache.set(key, enumDeclaration);
+  return enumDeclaration;
+}
+function tsArrayLiteralExpression(name, elementType, values, options) {
+  var _a;
+  let variableName = sanitizeMemberName(name);
+  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;
+  const arrayType = (options == null ? void 0 : options.readonly) ? tsReadonlyArray(elementType, options.injectFooter) : import_typescript.default.factory.createArrayTypeNode(elementType);
+  return import_typescript.default.factory.createVariableStatement(
+    options ? tsModifiers({ export: (_a = options.export) != null ? _a : false }) : void 0,
+    import_typescript.default.factory.createVariableDeclarationList(
+      [
+        import_typescript.default.factory.createVariableDeclaration(
+          variableName,
+          void 0,
+          arrayType,
+          import_typescript.default.factory.createArrayLiteralExpression(
+            values.map((value) => {
+              if (typeof value === "number") {
+                if (value < 0) {
+                  return import_typescript.default.factory.createPrefixUnaryExpression(
+                    import_typescript.default.SyntaxKind.MinusToken,
+                    import_typescript.default.factory.createNumericLiteral(Math.abs(value))
+                  );
+                } else {
+                  return import_typescript.default.factory.createNumericLiteral(value);
+                }
+              } else {
+                return import_typescript.default.factory.createStringLiteral(value);
+              }
+            })
+          )
+        )
+      ],
+      import_typescript.default.NodeFlags.Const
+    )
+  );
+}
+function sanitizeMemberName(name) {
+  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c2) => {
+    const last = c2[c2.length - 1];
+    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? "" : last.toUpperCase();
+  });
+  if (Number(name[0]) >= 0) {
+    sanitizedName = `Value${name}`;
+  }
+  return sanitizedName;
+}
+function tsEnumMember(value, metadata = {}) {
+  var _a;
+  let name = (_a = metadata.name) != null ? _a : String(value);
+  if (!JS_PROPERTY_INDEX_RE.test(name)) {
+    if (Number(name[0]) >= 0) {
+      name = `Value${name}`.replace(".", "_");
+    } else if (name[0] === "-") {
+      name = `ValueMinus${name.slice(1)}`;
+    }
+    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);
+    if (invalidCharMatch) {
+      if (invalidCharMatch[0] === name) {
+        name = `"${name}"`;
+      } else {
+        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {
+          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : "_";
+        });
+      }
+    }
+  }
+  let member;
+  if (typeof value === "number") {
+    const literal = value < 0 ? import_typescript.default.factory.createPrefixUnaryExpression(
+      import_typescript.default.SyntaxKind.MinusToken,
+      import_typescript.default.factory.createNumericLiteral(Math.abs(value))
+    ) : import_typescript.default.factory.createNumericLiteral(value);
+    member = import_typescript.default.factory.createEnumMember(name, literal);
+  } else {
+    member = import_typescript.default.factory.createEnumMember(name, import_typescript.default.factory.createStringLiteral(value));
+  }
+  if (metadata.description === void 0) {
+    return member;
+  }
+  return import_typescript.default.addSyntheticLeadingComment(
+    member,
+    import_typescript.default.SyntaxKind.SingleLineCommentTrivia,
+    " ".concat(metadata.description.trim()),
+    true
+  );
+}
+function tsIntersection(types) {
+  if (types.length === 0) {
+    return NEVER;
+  }
+  if (types.length === 1) {
+    return types[0];
+  }
+  return import_typescript.default.factory.createIntersectionTypeNode(tsDedupe(types));
+}
+function tsIsPrimitive(type) {
+  if (!type) {
+    return true;
+  }
+  return import_typescript.default.SyntaxKind[type.kind] === "BooleanKeyword" || import_typescript.default.SyntaxKind[type.kind] === "NeverKeyword" || import_typescript.default.SyntaxKind[type.kind] === "NullKeyword" || import_typescript.default.SyntaxKind[type.kind] === "NumberKeyword" || import_typescript.default.SyntaxKind[type.kind] === "StringKeyword" || import_typescript.default.SyntaxKind[type.kind] === "UndefinedKeyword" || "literal" in type && tsIsPrimitive(type.literal);
+}
+function tsLiteral(value) {
+  if (typeof value === "string") {
+    return import_typescript.default.factory.createIdentifier(JSON.stringify(value));
+  }
+  if (typeof value === "number") {
+    const literal = value < 0 ? import_typescript.default.factory.createPrefixUnaryExpression(
+      import_typescript.default.SyntaxKind.MinusToken,
+      import_typescript.default.factory.createNumericLiteral(Math.abs(value))
+    ) : import_typescript.default.factory.createNumericLiteral(value);
+    return import_typescript.default.factory.createLiteralTypeNode(literal);
+  }
+  if (typeof value === "boolean") {
+    return value === true ? TRUE : FALSE;
+  }
+  if (value === null) {
+    return NULL;
+  }
+  if (Array.isArray(value)) {
+    if (value.length === 0) {
+      return import_typescript.default.factory.createArrayTypeNode(NEVER);
+    }
+    return import_typescript.default.factory.createTupleTypeNode(value.map((v) => tsLiteral(v)));
+  }
+  if (typeof value === "object") {
+    const keys = [];
+    for (const [k, v] of Object.entries(value)) {
+      keys.push(
+        import_typescript.default.factory.createPropertySignature(
+          /* modifiers     */
+          void 0,
+          /* name          */
+          tsPropertyIndex(k),
+          /* questionToken */
+          void 0,
+          /* type          */
+          tsLiteral(v)
+        )
+      );
+    }
+    return keys.length ? import_typescript.default.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);
+  }
+  return UNKNOWN;
+}
+function tsModifiers(modifiers) {
+  const typeMods = [];
+  if (modifiers.export) {
+    typeMods.push(import_typescript.default.factory.createModifier(import_typescript.default.SyntaxKind.ExportKeyword));
+  }
+  if (modifiers.readonly) {
+    typeMods.push(import_typescript.default.factory.createModifier(import_typescript.default.SyntaxKind.ReadonlyKeyword));
+  }
+  return typeMods;
+}
+function tsNullable(types) {
+  return import_typescript.default.factory.createUnionTypeNode([...types, NULL]);
+}
+function tsOmit(type, keys) {
+  return import_typescript.default.factory.createTypeReferenceNode(import_typescript.default.factory.createIdentifier("Omit"), [
+    type,
+    import_typescript.default.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k)))
+  ]);
+}
+function tsRecord(key, value) {
+  return import_typescript.default.factory.createTypeReferenceNode(import_typescript.default.factory.createIdentifier("Record"), [key, value]);
+}
+function tsPropertyIndex(index) {
+  if (typeof index === "number" && !(index < 0) || typeof index === "string" && String(Number(index)) === index && index[0] !== "-") {
+    return import_typescript.default.factory.createNumericLiteral(index);
+  }
+  return typeof index === "string" && JS_PROPERTY_INDEX_RE.test(index) ? import_typescript.default.factory.createIdentifier(index) : import_typescript.default.factory.createStringLiteral(String(index));
+}
+function tsUnion(types) {
+  if (types.length === 0) {
+    return NEVER;
+  }
+  if (types.length === 1) {
+    return types[0];
+  }
+  return import_typescript.default.factory.createUnionTypeNode(tsDedupe(types));
+}
+function tsWithRequired(type, keys, injectFooter) {
+  if (keys.length === 0) {
+    return type;
+  }
+  if (!injectFooter.some((node) => {
+    var _a;
+    return import_typescript.default.isTypeAliasDeclaration(node) && ((_a = node == null ? void 0 : node.name) == null ? void 0 : _a.escapedText) === "WithRequired";
+  })) {
+    const helper = stringToAST("type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };")[0];
+    injectFooter.push(helper);
+  }
+  return import_typescript.default.factory.createTypeReferenceNode(import_typescript.default.factory.createIdentifier("WithRequired"), [
+    type,
+    tsUnion(keys.map((k) => tsLiteral(k)))
+  ]);
+}
+function tsReadonlyArray(type, injectFooter) {
+  if (injectFooter && !injectFooter.some((node) => {
+    var _a;
+    return import_typescript.default.isTypeAliasDeclaration(node) && ((_a = node == null ? void 0 : node.name) == null ? void 0 : _a.escapedText) === "ReadonlyArray";
+  })) {
+    const helper = stringToAST(
+      "type ReadonlyArray<T> = [Exclude<T, undefined>] extends [any[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;"
+    )[0];
+    injectFooter.push(helper);
+  }
+  return import_typescript.default.factory.createTypeReferenceNode(import_typescript.default.factory.createIdentifier("ReadonlyArray"), [type]);
+}
+
+// src/lib/utils.ts
+if (!supports_color_default.stdout || supports_color_default.stdout.hasBasic === false) {
+  import_ansi_colors.default.enabled = false;
+}
+var DEBUG_GROUPS = {
+  redoc: import_ansi_colors.default.cyanBright,
+  lint: import_ansi_colors.default.yellowBright,
+  bundle: import_ansi_colors.default.magentaBright,
+  ts: import_ansi_colors.default.blueBright
+};
+function createDiscriminatorProperty(discriminator, { path, readonly = false }) {
+  let value = (0, import_ref_utils2.parseRef)(path).pointer.pop();
+  if (discriminator.mapping) {
+    const matchedValue = Object.entries(discriminator.mapping).find(
+      ([, v]) => !v.startsWith("#") && v === value || v.startsWith("#") && (0, import_ref_utils2.parseRef)(v).pointer.pop() === value
+    );
+    if (matchedValue) {
+      value = matchedValue[0];
+    }
+  }
+  return import_typescript2.default.factory.createPropertySignature(
+    /* modifiers     */
+    tsModifiers({
+      readonly
+    }),
+    /* name          */
+    tsPropertyIndex(discriminator.propertyName),
+    /* questionToken */
+    void 0,
+    /* type          */
+    tsLiteral(value)
+  );
+}
+function createRef(parts) {
+  let pointer = "#";
+  for (const part of parts) {
+    if (part === void 0 || part === null || part === "") {
+      continue;
+    }
+    const maybeRef = (0, import_ref_utils2.parseRef)(String(part)).pointer;
+    if (maybeRef.length) {
+      for (const refPart of maybeRef) {
+        pointer += `/${(0, import_ref_utils2.escapePointer)(refPart)}`;
+      }
+    } else {
+      pointer += `/${(0, import_ref_utils2.escapePointer)(part)}`;
+    }
+  }
+  return pointer;
+}
+function debug(msg, group, time) {
+  if (process.env.DEBUG && (!group || process.env.DEBUG === "*" || process.env.DEBUG === "openapi-ts:*" || process.env.DEBUG.toLocaleLowerCase() === `openapi-ts:${group.toLocaleLowerCase()}`)) {
+    const groupColor = group && DEBUG_GROUPS[group] || import_ansi_colors.default.whiteBright;
+    const groupName = groupColor(`openapi-ts:${group != null ? group : "info"}`);
+    let timeFormatted = "";
+    if (typeof time === "number") {
+      timeFormatted = import_ansi_colors.default.green(` ${formatTime(time)} `);
+    }
+    console.debug(`  ${import_ansi_colors.default.bold(groupName)}${timeFormatted}${msg}`);
+  }
+}
+function error(msg) {
+  console.error(import_ansi_colors.default.red(` \u2718  ${msg}`));
+}
+function formatTime(t) {
+  if (typeof t === "number") {
+    if (t < 1e3) {
+      return `${Math.round(10 * t) / 10}ms`;
+    }
+    if (t < 6e4) {
+      return `${Math.round(t / 100) / 10}s`;
+    }
+    return `${Math.round(t / 6e3) / 10}m`;
+  }
+  return t;
+}
+function getEntries(obj, options) {
+  let entries = Object.entries(obj);
+  if (options == null ? void 0 : options.alphabetize) {
+    entries.sort(([a], [b]) => a.localeCompare(b, "en-us", { numeric: true }));
+  }
+  if (options == null ? void 0 : options.excludeDeprecated) {
+    entries = entries.filter(([, v]) => !(v && typeof v === "object" && "deprecated" in v && v.deprecated));
+  }
+  return entries;
+}
+function resolveRef(schema, $ref, { silent = false, visited = [] }) {
+  const { pointer } = (0, import_ref_utils2.parseRef)($ref);
+  if (!pointer.length) {
+    return void 0;
+  }
+  let node = schema;
+  for (const key of pointer) {
+    if (node && typeof node === "object" && node[key]) {
+      node = node[key];
+    } else {
+      warn(`Could not resolve $ref "${$ref}"`, silent);
+      return void 0;
+    }
+  }
+  if (node && typeof node === "object" && node.$ref) {
+    if (visited.includes(node.$ref)) {
+      warn(`Could not resolve circular $ref "${$ref}"`, silent);
+      return void 0;
+    }
+    return resolveRef(schema, node.$ref, {
+      silent,
+      visited: [...visited, node.$ref]
+    });
+  }
+  return node;
+}
+function createDiscriminatorEnum(values, prevSchema) {
+  return {
+    type: "string",
+    enum: values,
+    description: (prevSchema == null ? void 0 : prevSchema.description) ? `${prevSchema.description} (enum property replaced by openapi-typescript)` : "discriminator enum property added by openapi-typescript"
+  };
+}
+function patchDiscriminatorEnum(schema, ref, values, discriminator, discriminatorRef, options) {
+  var _a;
+  const resolvedSchema = resolveRef(schema, ref, {
+    silent: (_a = options.silent) != null ? _a : false
+  });
+  if (resolvedSchema == null ? void 0 : resolvedSchema.allOf) {
+    resolvedSchema.allOf.push({
+      type: "object",
+      // discriminator enum properties always need to be required
+      required: [discriminator.propertyName],
+      properties: {
+        [discriminator.propertyName]: createDiscriminatorEnum(values)
+      }
+    });
+    return true;
+  } else if (typeof resolvedSchema === "object" && "type" in resolvedSchema && resolvedSchema.type === "object") {
+    if (!resolvedSchema.properties) {
+      resolvedSchema.properties = {};
+    }
+    if (!resolvedSchema.required) {
+      resolvedSchema.required = [discriminator.propertyName];
+    } else if (!resolvedSchema.required.includes(discriminator.propertyName)) {
+      resolvedSchema.required.push(discriminator.propertyName);
+    }
+    resolvedSchema.properties[discriminator.propertyName] = createDiscriminatorEnum(
+      values,
+      resolvedSchema.properties[discriminator.propertyName]
+    );
+    return true;
+  }
+  warn(
+    `Discriminator mapping has an invalid schema (neither an object schema nor an allOf array): ${ref} => ${values.join(
+      ", "
+    )} (Discriminator: ${discriminatorRef})`,
+    options.silent
+  );
+  return false;
+}
+function scanDiscriminators(schema, options) {
+  const objects = {};
+  const refsHandled = [];
+  walk(schema, (obj, path) => {
+    var _a, _b;
+    const discriminator = obj == null ? void 0 : obj.discriminator;
+    if (!(discriminator == null ? void 0 : discriminator.propertyName)) {
+      return;
+    }
+    const ref = createRef(path);
+    objects[ref] = discriminator;
+    if (!(obj == null ? void 0 : obj.oneOf) || !Array.isArray(obj.oneOf)) {
+      return;
+    }
+    const oneOf = obj.oneOf;
+    const mapping = {};
+    for (const item of oneOf) {
+      if ("$ref" in item) {
+        const value = item.$ref.split("/").pop();
+        if (value) {
+          if (!mapping[item.$ref]) {
+            mapping[item.$ref] = { inferred: value };
+          } else {
+            mapping[item.$ref].inferred = value;
+          }
+        }
+      }
+    }
+    if (discriminator.mapping) {
+      for (const mappedValue in discriminator.mapping) {
+        const mappedRef = discriminator.mapping[mappedValue];
+        if (!mappedRef) {
+          continue;
+        }
+        if (!((_a = mapping[mappedRef]) == null ? void 0 : _a.defined)) {
+          mapping[mappedRef] = { defined: [] };
+        }
+        (_b = mapping[mappedRef].defined) == null ? void 0 : _b.push(mappedValue);
+      }
+    }
+    for (const [mappedRef, { inferred, defined }] of Object.entries(mapping)) {
+      if (refsHandled.includes(mappedRef)) {
+        continue;
+      }
+      if (!inferred && !defined) {
+        continue;
+      }
+      const mappedValues = defined != null ? defined : [inferred];
+      if (patchDiscriminatorEnum(schema, mappedRef, mappedValues, discriminator, ref, options)) {
+        refsHandled.push(mappedRef);
+      }
+    }
+  });
+  walk(schema, (obj, path) => {
+    var _a;
+    if (!obj || !Array.isArray(obj.allOf)) {
+      return;
+    }
+    for (const item of obj.allOf) {
+      if ("$ref" in item) {
+        if (!objects[item.$ref]) {
+          return;
+        }
+        const ref = createRef(path);
+        const discriminator = objects[item.$ref];
+        const mappedValues = [];
+        if (discriminator.mapping) {
+          for (const mappedValue in discriminator.mapping) {
+            if (discriminator.mapping[mappedValue] === ref) {
+              mappedValues.push(mappedValue);
+            }
+          }
+          if (mappedValues.length > 0) {
+            if (patchDiscriminatorEnum(
+              schema,
+              ref,
+              mappedValues,
+              discriminator,
+              item.$ref,
+              options
+            )) {
+              refsHandled.push(ref);
+            }
+          }
+        }
+        objects[ref] = {
+          ...objects[item.$ref]
+        };
+      } else if ((_a = item.discriminator) == null ? void 0 : _a.propertyName) {
+        objects[createRef(path)] = { ...item.discriminator };
+      }
+    }
+  });
+  return { objects, refsHandled };
+}
+function walk(obj, cb, path = []) {
+  if (!obj || typeof obj !== "object") {
+    return;
+  }
+  if (Array.isArray(obj)) {
+    for (let i = 0; i < obj.length; i++) {
+      walk(obj[i], cb, path.concat(i));
+    }
+    return;
+  }
+  cb(obj, path);
+  for (const k of Object.keys(obj)) {
+    walk(obj[k], cb, path.concat(k));
+  }
+}
+function warn(msg, silent = false) {
+  if (!silent) {
+    console.warn(import_ansi_colors.default.yellow(` \u26A0  ${msg}`));
+  }
+}
+
+// src/lib/redoc.ts
+async function parseSchema(schema, { absoluteRef, resolver }) {
+  if (!schema) {
+    throw new Error("Can\u2019t parse empty schema");
+  }
+  if (schema instanceof URL) {
+    const result = await resolver.resolveDocument(null, absoluteRef, true);
+    if ("parsed" in result) {
+      return result;
+    }
+    throw result.originalError;
+  }
+  if (schema instanceof import_node_stream.Readable) {
+    const contents = await new Promise((resolve) => {
+      schema.resume();
+      schema.setEncoding("utf8");
+      let content = "";
+      schema.on("data", (chunk) => {
+        content += chunk;
+      });
+      schema.on("end", () => {
+        resolve(content.trim());
+      });
+    });
+    return parseSchema(contents, { absoluteRef, resolver });
+  }
+  if (schema instanceof Buffer) {
+    return parseSchema(schema.toString("utf8"), { absoluteRef, resolver });
+  }
+  if (typeof schema === "string") {
+    if (schema.startsWith("http://") || schema.startsWith("https://") || schema.startsWith("file://")) {
+      const url = new URL(schema);
+      return parseSchema(url, {
+        absoluteRef: url.protocol === "file:" ? (0, import_node_url.fileURLToPath)(url) : url.href,
+        resolver
+      });
+    }
+    if (schema[0] === "{") {
+      return {
+        source: new import_openapi_core.Source(absoluteRef, schema, "application/json"),
+        parsed: parseJson(schema)
+      };
+    }
+    return (0, import_openapi_core.makeDocumentFromString)(schema, absoluteRef);
+  }
+  if (typeof schema === "object" && !Array.isArray(schema)) {
+    return {
+      source: new import_openapi_core.Source(absoluteRef, JSON.stringify(schema), "application/json"),
+      parsed: schema
+    };
+  }
+  throw new Error(`Expected string, object, or Buffer. Got ${Array.isArray(schema) ? "Array" : typeof schema}`);
+}
+function _processProblems(problems, options) {
+  var _a;
+  if (problems.length) {
+    let errorMessage = void 0;
+    for (const problem of problems) {
+      const problemLocation = (_a = problem.location) == null ? void 0 : _a[0].pointer;
+      const problemMessage = problemLocation ? `${problem.message} at ${problemLocation}` : problem.message;
+      if (problem.severity === "error") {
+        errorMessage = problemMessage;
+        error(problemMessage);
+      } else {
+        warn(problemMessage, options.silent);
+      }
+    }
+    if (errorMessage) {
+      throw new Error(errorMessage);
+    }
+  }
+}
+async function validateAndBundle(source, options) {
+  var _a;
+  const redocConfigT = import_node_perf_hooks.performance.now();
+  debug("Loaded Redoc config", "redoc", import_node_perf_hooks.performance.now() - redocConfigT);
+  const redocParseT = import_node_perf_hooks.performance.now();
+  let absoluteRef = (0, import_node_url.fileURLToPath)(new URL((_a = options == null ? void 0 : options.cwd) != null ? _a : `file://${process.cwd()}/`));
+  if (source instanceof URL) {
+    absoluteRef = source.protocol === "file:" ? (0, import_node_url.fileURLToPath)(source) : source.href;
+  }
+  const resolver = new import_openapi_core.BaseResolver(options.redoc.resolve);
+  const document = await parseSchema(source, {
+    absoluteRef,
+    resolver
+  });
+  debug("Parsed schema", "redoc", import_node_perf_hooks.performance.now() - redocParseT);
+  const openapiVersion = Number.parseFloat(document.parsed.openapi);
+  if (document.parsed.swagger || !document.parsed.openapi || Number.isNaN(openapiVersion) || openapiVersion < 3 || openapiVersion >= 4) {
+    if (document.parsed.swagger) {
+      throw new Error("Unsupported Swagger version: 2.x. Use OpenAPI 3.x instead.");
+    }
+    if (document.parsed.openapi || openapiVersion < 3 || openapiVersion >= 4) {
+      throw new Error(`Unsupported OpenAPI version: ${document.parsed.openapi}`);
+    }
+    throw new Error("Unsupported schema format, expected `openapi: 3.x`");
+  }
+  const redocLintT = import_node_perf_hooks.performance.now();
+  const problems = await (0, import_openapi_core.lintDocument)({
+    document,
+    config: options.redoc.styleguide,
+    externalRefResolver: resolver
+  });
+  _processProblems(problems, options);
+  debug("Linted schema", "lint", import_node_perf_hooks.performance.now() - redocLintT);
+  const redocBundleT = import_node_perf_hooks.performance.now();
+  const bundled = await (0, import_openapi_core.bundle)({
+    config: options.redoc,
+    dereference: false,
+    doc: document
+  });
+  _processProblems(bundled.problems, options);
+  debug("Bundled schema", "bundle", import_node_perf_hooks.performance.now() - redocBundleT);
+  return bundled.bundle.parsed;
+}
+
+// src/transform/index.ts
+var import_typescript14 = __toESM(require("typescript"), 1);
+var import_node_perf_hooks4 = require("node:perf_hooks");
+
+// src/transform/components-object.ts
+var import_typescript11 = __toESM(require("typescript"), 1);
+
+// ../../node_modules/.pnpm/change-case@5.4.4/node_modules/change-case/dist/index.js
+var SPLIT_LOWER_UPPER_RE = /([\p{Ll}\d])(\p{Lu})/gu;
+var SPLIT_UPPER_UPPER_RE = /(\p{Lu})([\p{Lu}][\p{Ll}])/gu;
+var SPLIT_SEPARATE_NUMBER_RE = /(\d)\p{Ll}|(\p{L})\d/u;
+var DEFAULT_STRIP_REGEXP = /[^\p{L}\d]+/giu;
+var SPLIT_REPLACE_VALUE = "$1\0$2";
+var DEFAULT_PREFIX_SUFFIX_CHARACTERS = "";
+function split(value) {
+  let result = value.trim();
+  result = result.replace(SPLIT_LOWER_UPPER_RE, SPLIT_REPLACE_VALUE).replace(SPLIT_UPPER_UPPER_RE, SPLIT_REPLACE_VALUE);
+  result = result.replace(DEFAULT_STRIP_REGEXP, "\0");
+  let start = 0;
+  let end = result.length;
+  while (result.charAt(start) === "\0")
+    start++;
+  if (start === end)
+    return [];
+  while (result.charAt(end - 1) === "\0")
+    end--;
+  return result.slice(start, end).split(/\0/g);
+}
+function splitSeparateNumbers(value) {
+  var _a;
+  const words = split(value);
+  for (let i = 0; i < words.length; i++) {
+    const word = words[i];
+    const match = SPLIT_SEPARATE_NUMBER_RE.exec(word);
+    if (match) {
+      const offset = match.index + ((_a = match[1]) != null ? _a : match[2]).length;
+      words.splice(i, 1, word.slice(0, offset), word.slice(offset));
+    }
+  }
+  return words;
+}
+function pascalCase(input, options) {
+  var _a;
+  const [prefix, words, suffix] = splitPrefixSuffix(input, options);
+  const lower = lowerFactory(options == null ? void 0 : options.locale);
+  const upper = upperFactory(options == null ? void 0 : options.locale);
+  const transform = (options == null ? void 0 : options.mergeAmbiguousCharacters) ? capitalCaseTransformFactory(lower, upper) : pascalCaseTransformFactory(lower, upper);
+  return prefix + words.map(transform).join((_a = options == null ? void 0 : options.delimiter) != null ? _a : "") + suffix;
+}
+function lowerFactory(locale) {
+  return locale === false ? (input) => input.toLowerCase() : (input) => input.toLocaleLowerCase(locale);
+}
+function upperFactory(locale) {
+  return locale === false ? (input) => input.toUpperCase() : (input) => input.toLocaleUpperCase(locale);
+}
+function capitalCaseTransformFactory(lower, upper) {
+  return (word) => `${upper(word[0])}${lower(word.slice(1))}`;
+}
+function pascalCaseTransformFactory(lower, upper) {
+  return (word, index) => {
+    const char0 = word[0];
+    const initial = index > 0 && char0 >= "0" && char0 <= "9" ? "_" + char0 : upper(char0);
+    return initial + lower(word.slice(1));
+  };
+}
+function splitPrefixSuffix(input, options = {}) {
+  var _a, _b, _c;
+  const splitFn = (_a = options.split) != null ? _a : options.separateNumbers ? splitSeparateNumbers : split;
+  const prefixCharacters = (_b = options.prefixCharacters) != null ? _b : DEFAULT_PREFIX_SUFFIX_CHARACTERS;
+  const suffixCharacters = (_c = options.suffixCharacters) != null ? _c : DEFAULT_PREFIX_SUFFIX_CHARACTERS;
+  let prefixIndex = 0;
+  let suffixIndex = input.length;
+  while (prefixIndex < input.length) {
+    const char = input.charAt(prefixIndex);
+    if (!prefixCharacters.includes(char))
+      break;
+    prefixIndex++;
+  }
+  while (suffixIndex > prefixIndex) {
+    const index = suffixIndex - 1;
+    const char = input.charAt(index);
+    if (!suffixCharacters.includes(char))
+      break;
+    suffixIndex = index;
+  }
+  return [
+    input.slice(0, prefixIndex),
+    splitFn(input.slice(prefixIndex, suffixIndex)),
+    input.slice(suffixIndex)
+  ];
+}
+
+// src/transform/components-object.ts
+var import_node_perf_hooks2 = require("node:perf_hooks");
+
+// src/transform/header-object.ts
+var import_ref_utils4 = require("@redocly/openapi-core/lib/ref-utils.js");
+var import_typescript4 = __toESM(require("typescript"), 1);
+
+// src/transform/schema-object.ts
+var import_ref_utils3 = require("@redocly/openapi-core/lib/ref-utils.js");
+var import_typescript3 = __toESM(require("typescript"), 1);
+function transformSchemaObject(schemaObject, options) {
+  const type = transformSchemaObjectWithComposition(schemaObject, options);
+  if (typeof options.ctx.postTransform === "function") {
+    const postTransformResult = options.ctx.postTransform(type, options);
+    if (postTransformResult) {
+      return postTransformResult;
+    }
+  }
+  return type;
+}
+function transformSchemaObjectWithComposition(schemaObject, options) {
+  var _a, _b, _c, _d, _e;
+  if (!schemaObject) {
+    return NEVER;
+  }
+  if (schemaObject === true) {
+    return UNKNOWN;
+  }
+  if (Array.isArray(schemaObject) || typeof schemaObject !== "object") {
+    throw new Error(
+      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? "Array" : typeof schemaObject} at ${options.path}`
+    );
+  }
+  if ("$ref" in schemaObject) {
+    return oapiRef(schemaObject.$ref);
+  }
+  if (schemaObject.const !== null && schemaObject.const !== void 0) {
+    return tsLiteral(schemaObject.const);
+  }
+  if (Array.isArray(schemaObject.enum) && (!("type" in schemaObject) || schemaObject.type !== "object") && !("properties" in schemaObject) && !("additionalProperties" in schemaObject)) {
+    if (options.ctx.enum && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number" || v === null)) {
+      let enumName = (0, import_ref_utils3.parseRef)((_a = options.path) != null ? _a : "").pointer.join("/");
+      enumName = enumName.replace("components/schemas", "");
+      const metadata = schemaObject.enum.map((_, i) => {
+        var _a2, _b2, _c2, _d2, _e2, _f;
+        return {
+          name: (_c2 = (_a2 = schemaObject["x-enum-varnames"]) == null ? void 0 : _a2[i]) != null ? _c2 : (_b2 = schemaObject["x-enumNames"]) == null ? void 0 : _b2[i],
+          description: (_f = (_d2 = schemaObject["x-enum-descriptions"]) == null ? void 0 : _d2[i]) != null ? _f : (_e2 = schemaObject["x-enumDescriptions"]) == null ? void 0 : _e2[i]
+        };
+      });
+      let hasNull = false;
+      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {
+        if (enumValue === null) {
+          hasNull = true;
+          return false;
+        }
+        return true;
+      });
+      const enumType2 = tsEnum(enumName, validSchemaEnums, metadata, {
+        shouldCache: options.ctx.dedupeEnums,
+        export: true
+        // readonly: TS enum do not support the readonly modifier
+      });
+      if (!options.ctx.injectFooter.includes(enumType2)) {
+        options.ctx.injectFooter.push(enumType2);
+      }
+      const ref = import_typescript3.default.factory.createTypeReferenceNode(enumType2.name);
+      return hasNull ? tsUnion([ref, NULL]) : ref;
+    }
+    const enumType = schemaObject.enum.map(tsLiteral);
+    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes("null") || schemaObject.nullable) && !schemaObject.default) {
+      enumType.push(NULL);
+    }
+    const unionType = tsUnion(enumType);
+    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number")) {
+      let enumValuesVariableName = (0, import_ref_utils3.parseRef)((_b = options.path) != null ? _b : "").pointer.join("/");
+      enumValuesVariableName = enumValuesVariableName.replace("components/schemas", "");
+      enumValuesVariableName = `${enumValuesVariableName}Values`;
+      const enumValuesArray = tsArrayLiteralExpression(
+        enumValuesVariableName,
+        oapiRef((_c = options.path) != null ? _c : ""),
+        schemaObject.enum,
+        {
+          export: true,
+          readonly: true,
+          injectFooter: options.ctx.injectFooter
+        }
+      );
+      options.ctx.injectFooter.push(enumValuesArray);
+    }
+    return unionType;
+  }
+  function collectUnionCompositions(items) {
+    const output = [];
+    for (const item of items) {
+      output.push(transformSchemaObject(item, options));
+    }
+    return output;
+  }
+  function collectAllOfCompositions(items, required) {
+    const output = [];
+    for (const item of items) {
+      let itemType;
+      if ("$ref" in item) {
+        itemType = transformSchemaObject(item, options);
+        const resolved = options.ctx.resolve(item.$ref);
+        if (resolved && typeof resolved === "object" && "properties" in resolved && // we have already handled this item (discriminator property was already added as required)
+        !options.ctx.discriminators.refsHandled.includes(item.$ref)) {
+          const validRequired = (required != null ? required : []).filter((key) => {
+            var _a2;
+            return !!((_a2 = resolved.properties) == null ? void 0 : _a2[key]);
+          });
+          if (validRequired.length) {
+            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);
+          }
+        }
+      } else {
+        const itemRequired = [...required != null ? required : []];
+        if (typeof item === "object" && Array.isArray(item.required)) {
+          itemRequired.push(...item.required);
+        }
+        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);
+      }
+      output.push(itemType);
+    }
+    return output;
+  }
+  let finalType = void 0;
+  const coreObjectType = transformSchemaObjectCore(schemaObject, options);
+  const allOfType = collectAllOfCompositions((_d = schemaObject.allOf) != null ? _d : [], schemaObject.required);
+  if (coreObjectType || allOfType.length) {
+    const allOf = allOfType.length ? tsIntersection(allOfType) : void 0;
+    finalType = tsIntersection([...coreObjectType ? [coreObjectType] : [], ...allOf ? [allOf] : []]);
+  }
+  const anyOfType = collectUnionCompositions((_e = schemaObject.anyOf) != null ? _e : []);
+  if (anyOfType.length) {
+    finalType = tsUnion([...finalType ? [finalType] : [], ...anyOfType]);
+  }
+  const oneOfType = collectUnionCompositions(
+    schemaObject.oneOf || "type" in schemaObject && schemaObject.type === "object" && schemaObject.enum || []
+  );
+  if (oneOfType.length) {
+    if (oneOfType.every(tsIsPrimitive)) {
+      finalType = tsUnion([...finalType ? [finalType] : [], ...oneOfType]);
+    } else {
+      finalType = tsIntersection([...finalType ? [finalType] : [], tsUnion(oneOfType)]);
+    }
+  }
+  if (!finalType) {
+    if ("type" in schemaObject) {
+      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);
+    } else {
+      finalType = UNKNOWN;
+    }
+  }
+  if (finalType !== UNKNOWN && schemaObject.nullable && !schemaObject.default) {
+    finalType = tsNullable([finalType]);
+  }
+  return finalType;
+}
+function transformSchemaObjectCore(schemaObject, options) {
+  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
+  if ("type" in schemaObject && schemaObject.type) {
+    if (typeof options.ctx.transform === "function") {
+      const result = options.ctx.transform(schemaObject, options);
+      if (result && typeof result === "object") {
+        if ("schema" in result) {
+          if (result.questionToken) {
+            return import_typescript3.default.factory.createUnionTypeNode([result.schema, UNDEFINED]);
+          } else {
+            return result.schema;
+          }
+        } else {
+          return result;
+        }
+      }
+    }
+    if (schemaObject.type === "null") {
+      return NULL;
+    }
+    if (schemaObject.type === "string") {
+      return STRING;
+    }
+    if (schemaObject.type === "number" || schemaObject.type === "integer") {
+      return NUMBER;
+    }
+    if (schemaObject.type === "boolean") {
+      return BOOLEAN;
+    }
+    if (schemaObject.type === "array") {
+      let itemType = UNKNOWN;
+      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {
+        const prefixItems = (_a = schemaObject.prefixItems) != null ? _a : schemaObject.items;
+        itemType = import_typescript3.default.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));
+      } else if (schemaObject.items) {
+        if ("type" in schemaObject.items && schemaObject.items.type === "array") {
+          itemType = import_typescript3.default.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));
+        } else {
+          itemType = transformSchemaObject(schemaObject.items, options);
+        }
+      }
+      const min = typeof schemaObject.minItems === "number" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;
+      const max = typeof schemaObject.maxItems === "number" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems ? schemaObject.maxItems : void 0;
+      const estimateCodeSize = typeof max !== "number" ? min : (max * (max + 1) - min * (min - 1)) / 2;
+      if (options.ctx.arrayLength && (min !== 0 || max !== void 0) && estimateCodeSize < 30) {
+        if (min === max) {
+          const elements = [];
+          for (let i = 0; i < min; i++) {
+            elements.push(itemType);
+          }
+          return tsUnion([import_typescript3.default.factory.createTupleTypeNode(elements)]);
+        } else if (schemaObject.maxItems > 0) {
+          const members = [];
+          for (let i = 0; i <= (max != null ? max : 0) - min; i++) {
+            const elements = [];
+            for (let j = min; j < i + min; j++) {
+              elements.push(itemType);
+            }
+            members.push(import_typescript3.default.factory.createTupleTypeNode(elements));
+          }
+          return tsUnion(members);
+        } else {
+          const elements = [];
+          for (let i = 0; i < min; i++) {
+            elements.push(itemType);
+          }
+          elements.push(import_typescript3.default.factory.createRestTypeNode(import_typescript3.default.factory.createArrayTypeNode(itemType)));
+          return import_typescript3.default.factory.createTupleTypeNode(elements);
+        }
+      }
+      const finalType = import_typescript3.default.isTupleTypeNode(itemType) || import_typescript3.default.isArrayTypeNode(itemType) ? itemType : import_typescript3.default.factory.createArrayTypeNode(itemType);
+      return options.ctx.immutable ? import_typescript3.default.factory.createTypeOperatorNode(import_typescript3.default.SyntaxKind.ReadonlyKeyword, finalType) : finalType;
+    }
+    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {
+      const uniqueTypes = [];
+      if (Array.isArray(schemaObject.oneOf)) {
+        for (const t of schemaObject.type) {
+          if ((t === "boolean" || t === "string" || t === "number" || t === "integer" || t === "null") && schemaObject.oneOf.find((o) => typeof o === "object" && "type" in o && o.type === t)) {
+            continue;
+          }
+          uniqueTypes.push(
+            t === "null" || t === null ? NULL : transformSchemaObject(
+              { ...schemaObject, type: t, oneOf: void 0 },
+              // donâ€™t stack oneOf transforms
+              options
+            )
+          );
+        }
+      } else {
+        for (const t of schemaObject.type) {
+          if (t === "null" || t === null) {
+            if (!schemaObject.default) {
+              uniqueTypes.push(NULL);
+            }
+          } else {
+            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t }, options));
+          }
+        }
+      }
+      return tsUnion(uniqueTypes);
+    }
+  }
+  const coreObjectType = [];
+  for (const k of ["allOf", "anyOf"]) {
+    if (!schemaObject[k]) {
+      continue;
+    }
+    const discriminator = !schemaObject.discriminator && !options.ctx.discriminators.refsHandled.includes((_b = options.path) != null ? _b : "") && options.ctx.discriminators.objects[(_c = options.path) != null ? _c : ""];
+    if (discriminator) {
+      coreObjectType.unshift(
+        createDiscriminatorProperty(discriminator, {
+          path: (_d = options.path) != null ? _d : "",
+          readonly: options.ctx.immutable
+        })
+      );
+      break;
+    }
+  }
+  if ("properties" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length || "additionalProperties" in schemaObject && schemaObject.additionalProperties || "$defs" in schemaObject && schemaObject.$defs) {
+    if (Object.keys((_e = schemaObject.properties) != null ? _e : {}).length) {
+      for (const [k, v] of getEntries((_f = schemaObject.properties) != null ? _f : {}, options.ctx)) {
+        if (typeof v !== "object" || Array.isArray(v)) {
+          throw new Error(
+            `${options.path}: invalid property ${k}. Expected Schema Object, got ${Array.isArray(v) ? "Array" : typeof v}`
+          );
+        }
+        if (options.ctx.excludeDeprecated) {
+          const resolved = "$ref" in v ? options.ctx.resolve(v.$ref) : v;
+          if (resolved == null ? void 0 : resolved.deprecated) {
+            continue;
+          }
+        }
+        let optional = ((_g = schemaObject.required) == null ? void 0 : _g.includes(k)) || schemaObject.required === void 0 && options.ctx.propertiesRequiredByDefault || "default" in v && options.ctx.defaultNonNullable && !((_h = options.path) == null ? void 0 : _h.includes("parameters")) && !((_i = options.path) == null ? void 0 : _i.includes("requestBody")) && !((_j = options.path) == null ? void 0 : _j.includes("requestBodies")) ? void 0 : QUESTION_TOKEN;
+        let type = "$ref" in v ? oapiRef(v.$ref) : transformSchemaObject(v, {
+          ...options,
+          path: createRef([options.path, k])
+        });
+        if (typeof options.ctx.transform === "function") {
+          const result = options.ctx.transform(v, options);
+          if (result && typeof result === "object") {
+            if ("schema" in result) {
+              type = result.schema;
+              optional = result.questionToken ? QUESTION_TOKEN : optional;
+            } else {
+              type = result;
+            }
+          }
+        }
+        const property = import_typescript3.default.factory.createPropertySignature(
+          /* modifiers     */
+          tsModifiers({
+            readonly: options.ctx.immutable || "readOnly" in v && !!v.readOnly
+          }),
+          /* name          */
+          tsPropertyIndex(k),
+          /* questionToken */
+          optional,
+          /* type          */
+          type
+        );
+        addJSDocComment(v, property);
+        coreObjectType.push(property);
+      }
+    }
+    if (schemaObject.$defs && typeof schemaObject.$defs === "object" && Object.keys(schemaObject.$defs).length) {
+      const defKeys = [];
+      for (const [k, v] of Object.entries(schemaObject.$defs)) {
+        const property = import_typescript3.default.factory.createPropertySignature(
+          /* modifiers    */
+          tsModifiers({
+            readonly: options.ctx.immutable || "readonly" in v && !!v.readOnly
+          }),
+          /* name          */
+          tsPropertyIndex(k),
+          /* questionToken */
+          void 0,
+          /* type          */
+          transformSchemaObject(v, {
+            ...options,
+            path: createRef([options.path, "$defs", k])
+          })
+        );
+        addJSDocComment(v, property);
+        defKeys.push(property);
+      }
+      coreObjectType.push(
+        import_typescript3.default.factory.createPropertySignature(
+          /* modifiers     */
+          void 0,
+          /* name          */
+          tsPropertyIndex("$defs"),
+          /* questionToken */
+          void 0,
+          /* type          */
+          import_typescript3.default.factory.createTypeLiteralNode(defKeys)
+        )
+      );
+    }
+    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {
+      const hasExplicitAdditionalProperties = typeof schemaObject.additionalProperties === "object" && Object.keys(schemaObject.additionalProperties).length;
+      const addlType = hasExplicitAdditionalProperties ? transformSchemaObject(schemaObject.additionalProperties, options) : UNKNOWN;
+      return tsIntersection([
+        ...coreObjectType.length ? [import_typescript3.default.factory.createTypeLiteralNode(coreObjectType)] : [],
+        import_typescript3.default.factory.createTypeLiteralNode([
+          import_typescript3.default.factory.createIndexSignature(
+            /* modifiers  */
+            tsModifiers({
+              readonly: options.ctx.immutable
+            }),
+            /* parameters */
+            [
+              import_typescript3.default.factory.createParameterDeclaration(
+                /* modifiers      */
+                void 0,
+                /* dotDotDotToken */
+                void 0,
+                /* name           */
+                import_typescript3.default.factory.createIdentifier("key"),
+                /* questionToken  */
+                void 0,
+                /* type           */
+                STRING
+              )
+            ],
+            /* type       */
+            addlType
+          )
+        ])
+      ]);
+    }
+  }
+  return coreObjectType.length ? import_typescript3.default.factory.createTypeLiteralNode(coreObjectType) : void 0;
+}
+
+// src/transform/media-type-object.ts
+function transformMediaTypeObject(mediaTypeObject, options) {
+  if (!mediaTypeObject.schema) {
+    return UNKNOWN;
+  }
+  return transformSchemaObject(mediaTypeObject.schema, options);
+}
+
+// src/transform/header-object.ts
+function transformHeaderObject(headerObject, options) {
+  var _a, _b;
+  if (headerObject.schema) {
+    return transformSchemaObject(headerObject.schema, options);
+  }
+  if (headerObject.content) {
+    const type = [];
+    for (const [contentType, mediaTypeObject] of getEntries((_a = headerObject.content) != null ? _a : {}, options.ctx)) {
+      const nextPath = `${(_b = options.path) != null ? _b : "#"}/${(0, import_ref_utils4.escapePointer)(contentType)}`;
+      const mediaType = "$ref" in mediaTypeObject ? transformSchemaObject(mediaTypeObject, {
+        ...options,
+        path: nextPath
+      }) : transformMediaTypeObject(mediaTypeObject, {
+        ...options,
+        path: nextPath
+      });
+      const property = import_typescript4.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(contentType),
+        /* questionToken */
+        void 0,
+        /* type          */
+        mediaType
+      );
+      addJSDocComment(mediaTypeObject, property);
+      type.push(property);
+    }
+    return import_typescript4.default.factory.createTypeLiteralNode(type);
+  }
+  return UNKNOWN;
+}
+
+// src/transform/parameter-object.ts
+function transformParameterObject(parameterObject, options) {
+  return parameterObject.schema ? transformSchemaObject(parameterObject.schema, options) : STRING;
+}
+
+// src/transform/path-item-object.ts
+var import_typescript10 = __toESM(require("typescript"), 1);
+
+// src/transform/operation-object.ts
+var import_typescript9 = __toESM(require("typescript"), 1);
+
+// src/transform/parameters-array.ts
+var import_typescript5 = __toESM(require("typescript"), 1);
+var PATH_PARAM_RE = /\{([^}]+)\}/g;
+function createPathParameter(paramName) {
+  return {
+    name: paramName,
+    in: "path",
+    required: true,
+    schema: { type: "string" }
+  };
+}
+function extractPathParamsFromUrl(path) {
+  const params = [];
+  const matches = path.match(PATH_PARAM_RE);
+  if (matches) {
+    for (const match of matches) {
+      const paramName = match.slice(1, -1);
+      params.push(createPathParameter(paramName));
+    }
+  }
+  return params;
+}
+function transformParametersArray(parametersArray, options) {
+  const type = [];
+  const workingParameters = [...parametersArray];
+  if (options.ctx.generatePathParams && options.path) {
+    const pathString = Array.isArray(options.path) ? options.path[0] : options.path;
+    if (typeof pathString === "string") {
+      const pathParams = extractPathParamsFromUrl(pathString);
+      for (const param of pathParams) {
+        const exists = workingParameters.some((p) => {
+          const resolved = "$ref" in p ? options.ctx.resolve(p.$ref) : p;
+          return (resolved == null ? void 0 : resolved.in) === "path" && (resolved == null ? void 0 : resolved.name) === param.name;
+        });
+        if (!exists) {
+          workingParameters.push(param);
+        }
+      }
+    }
+  }
+  const paramType = [];
+  for (const paramIn of ["query", "header", "path", "cookie"]) {
+    const paramLocType = [];
+    let operationParameters = workingParameters.map((param) => ({
+      original: param,
+      resolved: "$ref" in param ? options.ctx.resolve(param.$ref) : param
+    }));
+    if (options.ctx.alphabetize) {
+      operationParameters.sort((a, b) => {
+        var _a, _b, _c, _d;
+        return ((_b = (_a = a.resolved) == null ? void 0 : _a.name) != null ? _b : "").localeCompare((_d = (_c = b.resolved) == null ? void 0 : _c.name) != null ? _d : "");
+      });
+    }
+    if (options.ctx.excludeDeprecated) {
+      operationParameters = operationParameters.filter(
+        ({ resolved }) => {
+          var _a;
+          return !(resolved == null ? void 0 : resolved.deprecated) && !((_a = resolved == null ? void 0 : resolved.schema) == null ? void 0 : _a.deprecated);
+        }
+      );
+    }
+    for (const { original, resolved } of operationParameters) {
+      if ((resolved == null ? void 0 : resolved.in) !== paramIn) {
+        continue;
+      }
+      let optional = void 0;
+      if (paramIn !== "path" && !resolved.required) {
+        optional = QUESTION_TOKEN;
+      }
+      const subType = "$ref" in original ? oapiRef(original.$ref) : transformParameterObject(resolved, {
+        ...options,
+        path: createRef([options.path, "parameters", resolved.in, resolved.name])
+      });
+      const property = import_typescript5.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(resolved == null ? void 0 : resolved.name),
+        /* questionToken */
+        optional,
+        /* type          */
+        subType
+      );
+      addJSDocComment(resolved, property);
+      paramLocType.push(property);
+    }
+    const allOptional = paramLocType.every((node) => !!node.questionToken);
+    paramType.push(
+      import_typescript5.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(paramIn),
+        /* questionToken */
+        allOptional || !paramLocType.length ? QUESTION_TOKEN : void 0,
+        /* type          */
+        paramLocType.length ? import_typescript5.default.factory.createTypeLiteralNode(paramLocType) : NEVER
+      )
+    );
+  }
+  type.push(
+    import_typescript5.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex("parameters"),
+      /* questionToken */
+      !paramType.length ? QUESTION_TOKEN : void 0,
+      /* type          */
+      paramType.length ? import_typescript5.default.factory.createTypeLiteralNode(paramType) : NEVER
+    )
+  );
+  return type;
+}
+
+// src/transform/request-body-object.ts
+var import_typescript6 = __toESM(require("typescript"), 1);
+function transformRequestBodyObject(requestBodyObject, options) {
+  var _a;
+  const type = [];
+  for (const [contentType, mediaTypeObject] of getEntries((_a = requestBodyObject.content) != null ? _a : {}, options.ctx)) {
+    const nextPath = createRef([options.path, contentType]);
+    const mediaType = "$ref" in mediaTypeObject ? transformSchemaObject(mediaTypeObject, {
+      ...options,
+      path: nextPath
+    }) : transformMediaTypeObject(mediaTypeObject, {
+      ...options,
+      path: nextPath
+    });
+    const property = import_typescript6.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex(contentType),
+      /* questionToken */
+      void 0,
+      /* type          */
+      mediaType
+    );
+    addJSDocComment(mediaTypeObject, property);
+    type.push(property);
+  }
+  return import_typescript6.default.factory.createTypeLiteralNode([
+    import_typescript6.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex("content"),
+      /* questionToken */
+      void 0,
+      /* type          */
+      import_typescript6.default.factory.createTypeLiteralNode(
+        type.length ? type : (
+          // add `"*/*": never` if no media types are defined
+          [
+            import_typescript6.default.factory.createPropertySignature(
+              /* modifiers     */
+              void 0,
+              /* name          */
+              tsPropertyIndex("*/*"),
+              /* questionToken */
+              QUESTION_TOKEN,
+              /* type          */
+              NEVER
+            )
+          ]
+        )
+      )
+    )
+  ]);
+}
+
+// src/transform/responses-object.ts
+var import_typescript8 = __toESM(require("typescript"), 1);
+
+// src/transform/response-object.ts
+var import_typescript7 = __toESM(require("typescript"), 1);
+function transformResponseObject(responseObject, options) {
+  var _a;
+  const type = [];
+  const headersObject = [];
+  if (responseObject.headers) {
+    for (const [name, headerObject] of getEntries(responseObject.headers, options.ctx)) {
+      const optional = "$ref" in headerObject || headerObject.required ? void 0 : QUESTION_TOKEN;
+      const subType = "$ref" in headerObject ? oapiRef(headerObject.$ref) : transformHeaderObject(headerObject, {
+        ...options,
+        path: createRef([options.path, "headers", name])
+      });
+      const property = import_typescript7.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(name),
+        /* questionToken */
+        optional,
+        /* type          */
+        subType
+      );
+      addJSDocComment(headerObject, property);
+      headersObject.push(property);
+    }
+  }
+  headersObject.push(
+    import_typescript7.default.factory.createIndexSignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* parameters */
+      [
+        import_typescript7.default.factory.createParameterDeclaration(
+          /* modifiers      */
+          void 0,
+          /* dotDotDotToken */
+          void 0,
+          /* name           */
+          import_typescript7.default.factory.createIdentifier("name"),
+          /* questionToken  */
+          void 0,
+          /* type           */
+          STRING
+        )
+      ],
+      /* type          */
+      UNKNOWN
+    )
+  );
+  type.push(
+    import_typescript7.default.factory.createPropertySignature(
+      /* modifiers     */
+      void 0,
+      /* name          */
+      tsPropertyIndex("headers"),
+      /* questionToken */
+      void 0,
+      /* type          */
+      import_typescript7.default.factory.createTypeLiteralNode(headersObject)
+    )
+  );
+  const contentObject = [];
+  if (responseObject.content) {
+    for (const [contentType, mediaTypeObject] of getEntries((_a = responseObject.content) != null ? _a : {}, options.ctx)) {
+      const property = import_typescript7.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(contentType),
+        /* questionToken */
+        void 0,
+        /* type          */
+        transformMediaTypeObject(mediaTypeObject, {
+          ...options,
+          path: createRef([options.path, "content", contentType])
+        })
+      );
+      contentObject.push(property);
+    }
+  }
+  if (contentObject.length) {
+    type.push(
+      import_typescript7.default.factory.createPropertySignature(
+        /* modifiers     */
+        void 0,
+        /* name          */
+        tsPropertyIndex("content"),
+        /* questionToken */
+        void 0,
+        /* type          */
+        import_typescript7.default.factory.createTypeLiteralNode(contentObject)
+      )
+    );
+  } else {
+    type.push(
+      import_typescript7.default.factory.createPropertySignature(
+        /* modifiers     */
+        void 0,
+        /* name          */
+        tsPropertyIndex("content"),
+        /* questionToken */
+        QUESTION_TOKEN,
+        /* type          */
+        NEVER
+      )
+    );
+  }
+  return import_typescript7.default.factory.createTypeLiteralNode(type);
+}
+
+// src/transform/responses-object.ts
+function transformResponsesObject(responsesObject, options) {
+  const type = [];
+  for (const [responseCode, responseObject] of getEntries(responsesObject, options.ctx)) {
+    const responseType = "$ref" in responseObject ? oapiRef(responseObject.$ref) : transformResponseObject(responseObject, {
+      ...options,
+      path: createRef([options.path, "responses", responseCode])
+    });
+    const property = import_typescript8.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex(responseCode),
+      /* questionToken */
+      void 0,
+      /* type          */
+      responseType
+    );
+    addJSDocComment(responseObject, property);
+    type.push(property);
+  }
+  return type.length ? import_typescript8.default.factory.createTypeLiteralNode(type) : NEVER;
+}
+
+// src/transform/operation-object.ts
+function transformOperationObject(operationObject, options) {
+  var _a, _b, _c;
+  const type = [];
+  type.push(...transformParametersArray((_a = operationObject.parameters) != null ? _a : [], options));
+  if (operationObject.requestBody) {
+    const requestBodyType = "$ref" in operationObject.requestBody ? oapiRef(operationObject.requestBody.$ref) : transformRequestBodyObject(operationObject.requestBody, {
+      ...options,
+      path: createRef([options.path, "requestBody"])
+    });
+    const required = !!((_b = "$ref" in operationObject.requestBody ? options.ctx.resolve(operationObject.requestBody.$ref) : operationObject.requestBody) == null ? void 0 : _b.required);
+    const property = import_typescript9.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex("requestBody"),
+      /* questionToken */
+      required ? void 0 : QUESTION_TOKEN,
+      /* type          */
+      requestBodyType
+    );
+    addJSDocComment(operationObject.requestBody, property);
+    type.push(property);
+  } else {
+    type.push(
+      import_typescript9.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex("requestBody"),
+        /* questionToken */
+        QUESTION_TOKEN,
+        /* type          */
+        NEVER
+      )
+    );
+  }
+  type.push(
+    import_typescript9.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex("responses"),
+      /* questionToken */
+      void 0,
+      /* type          */
+      transformResponsesObject((_c = operationObject.responses) != null ? _c : {}, options)
+    )
+  );
+  return type;
+}
+function injectOperationObject(operationId, operationObject, options) {
+  let operations = options.ctx.injectFooter.find(
+    (node) => import_typescript9.default.isInterfaceDeclaration(node) && node.name.text === "operations"
+  );
+  if (!operations) {
+    operations = import_typescript9.default.factory.createInterfaceDeclaration(
+      /* modifiers       */
+      tsModifiers({
+        export: true
+        // important: do NOT make this immutable
+      }),
+      /* name            */
+      import_typescript9.default.factory.createIdentifier("operations"),
+      /* typeParameters  */
+      void 0,
+      /* heritageClauses */
+      void 0,
+      /* members         */
+      []
+    );
+    options.ctx.injectFooter.push(operations);
+  }
+  const type = transformOperationObject(operationObject, options);
+  operations.members = import_typescript9.default.factory.createNodeArray([
+    ...operations.members,
+    import_typescript9.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex(operationId),
+      /* questionToken */
+      void 0,
+      /* type          */
+      import_typescript9.default.factory.createTypeLiteralNode(type)
+    )
+  ]);
+}
+
+// src/transform/path-item-object.ts
+function transformPathItemObject(pathItem, options) {
+  var _a, _b, _c, _d, _e, _f;
+  const type = [];
+  type.push(
+    ...transformParametersArray((_a = pathItem.parameters) != null ? _a : [], {
+      ...options,
+      path: createRef([options.path, "parameters"])
+    })
+  );
+  for (const method of ["get", "put", "post", "delete", "options", "head", "patch", "trace"]) {
+    const operationObject = pathItem[method];
+    if (!operationObject || options.ctx.excludeDeprecated && ((_b = "$ref" in operationObject ? options.ctx.resolve(operationObject.$ref) : operationObject) == null ? void 0 : _b.deprecated)) {
+      type.push(
+        import_typescript10.default.factory.createPropertySignature(
+          /* modifiers     */
+          tsModifiers({ readonly: options.ctx.immutable }),
+          /* name          */
+          tsPropertyIndex(method),
+          /* questionToken */
+          QUESTION_TOKEN,
+          /* type          */
+          NEVER
+        )
+      );
+      continue;
+    }
+    const keyedParameters = {};
+    if (!("$ref" in operationObject)) {
+      for (const parameter of [...(_c = pathItem.parameters) != null ? _c : [], ...(_d = operationObject.parameters) != null ? _d : []]) {
+        const name = "$ref" in parameter ? `${(_e = options.ctx.resolve(parameter.$ref)) == null ? void 0 : _e.in}-${(_f = options.ctx.resolve(parameter.$ref)) == null ? void 0 : _f.name}` : `${parameter.in}-${parameter.name}`;
+        if (name) {
+          keyedParameters[name] = parameter;
+        }
+      }
+    }
+    let operationType;
+    if ("$ref" in operationObject) {
+      operationType = oapiRef(operationObject.$ref);
+    } else if (operationObject.operationId) {
+      const operationId = operationObject.operationId.replace(HASH_RE, "/");
+      operationType = oapiRef(createRef(["operations", operationId]));
+      injectOperationObject(
+        operationId,
+        { ...operationObject, parameters: Object.values(keyedParameters) },
+        { ...options, path: createRef([options.path, method]) }
+      );
+    } else {
+      operationType = import_typescript10.default.factory.createTypeLiteralNode(
+        transformOperationObject(
+          { ...operationObject, parameters: Object.values(keyedParameters) },
+          { ...options, path: createRef([options.path, method]) }
+        )
+      );
+    }
+    const property = import_typescript10.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex(method),
+      /* questionToken */
+      void 0,
+      /* type          */
+      operationType
+    );
+    addJSDocComment(operationObject, property);
+    type.push(property);
+  }
+  return import_typescript10.default.factory.createTypeLiteralNode(type);
+}
+var HASH_RE = /#/g;
+
+// src/transform/components-object.ts
+var transformers = {
+  schemas: transformSchemaObject,
+  responses: transformResponseObject,
+  parameters: transformParameterObject,
+  requestBodies: transformRequestBodyObject,
+  headers: transformHeaderObject,
+  pathItems: transformPathItemObject
+};
+function transformComponentsObject(componentsObject, ctx) {
+  const type = [];
+  const rootTypeAliases = {};
+  for (const key of Object.keys(transformers)) {
+    const componentT = import_node_perf_hooks2.performance.now();
+    const items = [];
+    if (componentsObject[key]) {
+      for (const [name, item] of getEntries(componentsObject[key], ctx)) {
+        let subType = transformers[key](item, {
+          path: createRef(["components", key, name]),
+          schema: item,
+          ctx
+        });
+        let hasQuestionToken = false;
+        if (ctx.transform) {
+          const result = ctx.transform(item, {
+            path: createRef(["components", key, name]),
+            schema: item,
+            ctx
+          });
+          if (result) {
+            if ("schema" in result) {
+              subType = result.schema;
+              hasQuestionToken = result.questionToken;
+            } else {
+              subType = result;
+            }
+          }
+        }
+        const property = import_typescript11.default.factory.createPropertySignature(
+          /* modifiers     */
+          tsModifiers({ readonly: ctx.immutable }),
+          /* name          */
+          tsPropertyIndex(name),
+          /* questionToken */
+          hasQuestionToken ? QUESTION_TOKEN : void 0,
+          /* type          */
+          subType
+        );
+        addJSDocComment(item, property);
+        items.push(property);
+        if (ctx.rootTypes) {
+          const componentKey = pascalCase(singularizeComponentKey(key));
+          let aliasName = `${componentKey}${pascalCase(name)}`;
+          let conflictCounter = 1;
+          while (rootTypeAliases[aliasName] !== void 0) {
+            conflictCounter++;
+            aliasName = `${componentKey}${pascalCase(name)}_${conflictCounter}`;
+          }
+          const ref = import_typescript11.default.factory.createTypeReferenceNode(`components['${key}']['${name}']`);
+          if (ctx.rootTypesNoSchemaPrefix && key === "schemas") {
+            aliasName = aliasName.replace(componentKey, "");
+          }
+          const typeAlias = import_typescript11.default.factory.createTypeAliasDeclaration(
+            /* modifiers      */
+            tsModifiers({ export: true }),
+            /* name           */
+            aliasName,
+            /* typeParameters */
+            void 0,
+            /* type           */
+            ref
+          );
+          rootTypeAliases[aliasName] = typeAlias;
+        }
+      }
+    }
+    type.push(
+      import_typescript11.default.factory.createPropertySignature(
+        /* modifiers     */
+        void 0,
+        /* name          */
+        tsPropertyIndex(key),
+        /* questionToken */
+        void 0,
+        /* type          */
+        items.length ? import_typescript11.default.factory.createTypeLiteralNode(items) : NEVER
+      )
+    );
+    debug(`Transformed components \u2192 ${key}`, "ts", import_node_perf_hooks2.performance.now() - componentT);
+  }
+  let rootTypes = [];
+  if (ctx.rootTypes) {
+    rootTypes = Object.keys(rootTypeAliases).map((k) => rootTypeAliases[k]);
+  }
+  return [import_typescript11.default.factory.createTypeLiteralNode(type), ...rootTypes];
+}
+function singularizeComponentKey(key) {
+  switch (key) {
+    // Handle special singular case
+    case "requestBodies":
+      return "requestBody";
+    // Default to removing the "s"
+    default:
+      return key.slice(0, -1);
+  }
+}
+
+// src/transform/paths-object.ts
+var import_typescript12 = __toESM(require("typescript"), 1);
+var import_node_perf_hooks3 = require("node:perf_hooks");
+var PATH_PARAM_RE2 = /\{[^}]+\}/g;
+function transformPathsObject(pathsObject, ctx) {
+  var _a, _b;
+  const type = [];
+  for (const [url, pathItemObject] of getEntries(pathsObject, ctx)) {
+    if (!pathItemObject || typeof pathItemObject !== "object") {
+      continue;
+    }
+    const pathT = import_node_perf_hooks3.performance.now();
+    if ("$ref" in pathItemObject) {
+      const property = import_typescript12.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(url),
+        /* questionToken */
+        void 0,
+        /* type          */
+        oapiRef(pathItemObject.$ref)
+      );
+      addJSDocComment(pathItemObject, property);
+      type.push(property);
+    } else {
+      const pathItemType = transformPathItemObject(pathItemObject, {
+        path: createRef(["paths", url]),
+        ctx
+      });
+      if (ctx.pathParamsAsTypes && url.includes("{")) {
+        const pathParams = extractPathParams(pathItemObject, ctx);
+        const matches = url.match(PATH_PARAM_RE2);
+        let rawPath = `\`${url}\``;
+        if (matches) {
+          for (const match of matches) {
+            const paramName = match.slice(1, -1);
+            const param = pathParams[paramName];
+            switch ((_a = param == null ? void 0 : param.schema) == null ? void 0 : _a.type) {
+              case "number":
+              case "integer":
+                rawPath = rawPath.replace(match, "${number}");
+                break;
+              case "boolean":
+                rawPath = rawPath.replace(match, "${boolean}");
+                break;
+              default:
+                rawPath = rawPath.replace(match, "${string}");
+                break;
+            }
+          }
+          const pathType = (_b = stringToAST(rawPath)[0]) == null ? void 0 : _b.expression;
+          if (pathType) {
+            type.push(
+              import_typescript12.default.factory.createIndexSignature(
+                /* modifiers     */
+                tsModifiers({ readonly: ctx.immutable }),
+                /* parameters    */
+                [
+                  import_typescript12.default.factory.createParameterDeclaration(
+                    /* modifiers      */
+                    void 0,
+                    /* dotDotDotToken */
+                    void 0,
+                    /* name           */
+                    "path",
+                    /* questionToken  */
+                    void 0,
+                    /* type           */
+                    pathType,
+                    /* initializer    */
+                    void 0
+                  )
+                ],
+                /* type          */
+                pathItemType
+              )
+            );
+            continue;
+          }
+        }
+      }
+      type.push(
+        import_typescript12.default.factory.createPropertySignature(
+          /* modifiers     */
+          tsModifiers({ readonly: ctx.immutable }),
+          /* name          */
+          tsPropertyIndex(url),
+          /* questionToken */
+          void 0,
+          /* type          */
+          pathItemType
+        )
+      );
+      debug(`Transformed path "${url}"`, "ts", import_node_perf_hooks3.performance.now() - pathT);
+    }
+  }
+  return import_typescript12.default.factory.createTypeLiteralNode(type);
+}
+function extractPathParams(pathItemObject, ctx) {
+  var _a;
+  const params = {};
+  for (const p of (_a = pathItemObject.parameters) != null ? _a : []) {
+    const resolved = "$ref" in p && p.$ref ? ctx.resolve(p.$ref) : p;
+    if (resolved && resolved.in === "path") {
+      params[resolved.name] = resolved;
+    }
+  }
+  for (const method of ["get", "put", "post", "delete", "options", "head", "patch", "trace"]) {
+    if (!(method in pathItemObject)) {
+      continue;
+    }
+    const resolvedMethod = pathItemObject[method].$ref ? ctx.resolve(pathItemObject[method].$ref) : pathItemObject[method];
+    if (resolvedMethod == null ? void 0 : resolvedMethod.parameters) {
+      for (const p of resolvedMethod.parameters) {
+        const resolvedParam = "$ref" in p && p.$ref ? ctx.resolve(p.$ref) : p;
+        if (resolvedParam && resolvedParam.in === "path") {
+          params[resolvedParam.name] = resolvedParam;
+        }
+      }
+    }
+  }
+  return params;
+}
+
+// src/transform/webhooks-object.ts
+var import_typescript13 = __toESM(require("typescript"), 1);
+function transformWebhooksObject(webhooksObject, options) {
+  const type = [];
+  for (const [name, pathItemObject] of getEntries(webhooksObject, options)) {
+    type.push(
+      import_typescript13.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({
+          readonly: options.immutable
+        }),
+        /* name          */
+        tsPropertyIndex(name),
+        /* questionToken */
+        void 0,
+        /* type          */
+        transformPathItemObject(pathItemObject, {
+          path: createRef(["webhooks", name]),
+          ctx: options
+        })
+      )
+    );
+  }
+  return import_typescript13.default.factory.createTypeLiteralNode(type);
+}
+
+// src/transform/paths-enum.ts
+function makeApiPathsEnum(pathsObject) {
+  const enumKeys = [];
+  const enumMetaData = [];
+  for (const [url, pathItemObject] of getEntries(pathsObject)) {
+    for (const [method, operation] of Object.entries(pathItemObject)) {
+      if (!["get", "put", "post", "delete", "options", "head", "patch", "trace"].includes(method)) {
+        continue;
+      }
+      let pathName;
+      if (operation.operationId) {
+        pathName = operation.operationId;
+      } else {
+        pathName = (method + url).split("/").map((part) => {
+          const capitalised = part.charAt(0).toUpperCase() + part.slice(1);
+          return capitalised.replace(/{.*}|:.*|[^a-zA-Z\d_]+/, "");
+        }).join("");
+      }
+      const adaptedUrl = url.replace(/{(\w+)}/g, ":$1");
+      enumKeys.push(adaptedUrl);
+      enumMetaData.push({
+        name: pathName
+      });
+    }
+  }
+  return tsEnum("ApiPaths", enumKeys, enumMetaData, {
+    export: true
+  });
+}
+
+// src/transform/index.ts
+var transformers2 = {
+  paths: transformPathsObject,
+  webhooks: transformWebhooksObject,
+  components: transformComponentsObject,
+  $defs: (node, options) => transformSchemaObject(node, { path: createRef(["$defs"]), ctx: options, schema: node })
+};
+function transformSchema(schema, ctx) {
+  var _a, _b;
+  const type = [];
+  if (ctx.inject) {
+    const injectNodes = stringToAST(ctx.inject);
+    type.push(...injectNodes);
+  }
+  for (const root of Object.keys(transformers2)) {
+    const emptyObj = import_typescript14.default.factory.createTypeAliasDeclaration(
+      /* modifiers      */
+      tsModifiers({ export: true }),
+      /* name           */
+      root,
+      /* typeParameters */
+      void 0,
+      /* type           */
+      tsRecord(STRING, NEVER)
+    );
+    if (schema[root] && typeof schema[root] === "object") {
+      const rootT = import_node_perf_hooks4.performance.now();
+      const subTypes = [].concat(transformers2[root](schema[root], ctx));
+      for (const subType of subTypes) {
+        if (import_typescript14.default.isTypeNode(subType)) {
+          if ((_a = subType.members) == null ? void 0 : _a.length) {
+            type.push(
+              ctx.exportType ? import_typescript14.default.factory.createTypeAliasDeclaration(
+                /* modifiers      */
+                tsModifiers({ export: true }),
+                /* name           */
+                root,
+                /* typeParameters */
+                void 0,
+                /* type           */
+                subType
+              ) : import_typescript14.default.factory.createInterfaceDeclaration(
+                /* modifiers       */
+                tsModifiers({ export: true }),
+                /* name            */
+                root,
+                /* typeParameters  */
+                void 0,
+                /* heritageClauses */
+                void 0,
+                /* members         */
+                subType.members
+              )
+            );
+            debug(`${root} done`, "ts", import_node_perf_hooks4.performance.now() - rootT);
+          } else {
+            type.push(emptyObj);
+            debug(`${root} done (skipped)`, "ts", 0);
+          }
+        } else if (import_typescript14.default.isTypeAliasDeclaration(subType)) {
+          type.push(subType);
+        } else {
+          type.push(emptyObj);
+          debug(`${root} done (skipped)`, "ts", 0);
+        }
+      }
+    } else {
+      type.push(emptyObj);
+      debug(`${root} done (skipped)`, "ts", 0);
+    }
+  }
+  let hasOperations = false;
+  for (const injectedType of ctx.injectFooter) {
+    if (!hasOperations && ((_b = injectedType == null ? void 0 : injectedType.name) == null ? void 0 : _b.escapedText) === "operations") {
+      hasOperations = true;
+    }
+    type.push(injectedType);
+  }
+  if (!hasOperations) {
+    type.push(
+      import_typescript14.default.factory.createTypeAliasDeclaration(
+        /* modifiers      */
+        tsModifiers({ export: true }),
+        /* name           */
+        "operations",
+        /* typeParameters */
+        void 0,
+        /* type           */
+        tsRecord(STRING, NEVER)
+      )
+    );
+  }
+  if (ctx.makePathsEnum && schema.paths) {
+    type.push(makeApiPathsEnum(schema.paths));
+  }
+  return type;
+}
+
+// src/index.ts
+var COMMENT_HEADER = `/**
+ * This file was auto-generated by openapi-typescript.
+ * Do not make direct changes to the file.
+ */
+
+`;
+async function openapiTS(source, options = {}) {
+  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
+  if (!source) {
+    throw new Error("Empty schema. Please specify a URL, file path, or Redocly Config");
+  }
+  const redoc = (_a = options.redocly) != null ? _a : await (0, import_openapi_core2.createConfig)(
+    {
+      rules: {
+        "operation-operationId-unique": { severity: "error" }
+        // throw error on duplicate operationIDs
+      }
+    },
+    { extends: ["minimal"] }
+  );
+  const schema = await validateAndBundle(source, {
+    redoc,
+    cwd: options.cwd instanceof URL ? options.cwd : new URL(`file://${(_b = options.cwd) != null ? _b : process.cwd()}/`),
+    silent: (_c = options.silent) != null ? _c : false
+  });
+  const ctx = {
+    additionalProperties: (_d = options.additionalProperties) != null ? _d : false,
+    alphabetize: (_e = options.alphabetize) != null ? _e : false,
+    arrayLength: (_f = options.arrayLength) != null ? _f : false,
+    defaultNonNullable: (_g = options.defaultNonNullable) != null ? _g : true,
+    discriminators: scanDiscriminators(schema, options),
+    emptyObjectsUnknown: (_h = options.emptyObjectsUnknown) != null ? _h : false,
+    enum: (_i = options.enum) != null ? _i : false,
+    enumValues: (_j = options.enumValues) != null ? _j : false,
+    dedupeEnums: (_k = options.dedupeEnums) != null ? _k : false,
+    excludeDeprecated: (_l = options.excludeDeprecated) != null ? _l : false,
+    exportType: (_m = options.exportType) != null ? _m : false,
+    immutable: (_n = options.immutable) != null ? _n : false,
+    rootTypes: (_o = options.rootTypes) != null ? _o : false,
+    rootTypesNoSchemaPrefix: (_p = options.rootTypesNoSchemaPrefix) != null ? _p : false,
+    injectFooter: [],
+    pathParamsAsTypes: (_q = options.pathParamsAsTypes) != null ? _q : false,
+    postTransform: typeof options.postTransform === "function" ? options.postTransform : void 0,
+    propertiesRequiredByDefault: (_r = options.propertiesRequiredByDefault) != null ? _r : false,
+    redoc,
+    silent: (_s = options.silent) != null ? _s : false,
+    inject: (_t = options.inject) != null ? _t : void 0,
+    transform: typeof options.transform === "function" ? options.transform : void 0,
+    makePathsEnum: (_u = options.makePathsEnum) != null ? _u : false,
+    generatePathParams: (_v = options.generatePathParams) != null ? _v : false,
+    resolve($ref) {
+      var _a2;
+      return resolveRef(schema, $ref, { silent: (_a2 = options.silent) != null ? _a2 : false });
+    }
+  };
+  const transformT = import_node_perf_hooks5.performance.now();
+  const result = transformSchema(schema, ctx);
+  debug("Completed AST transformation for entire document", "ts", import_node_perf_hooks5.performance.now() - transformT);
+  return result;
+}
+// Annotate the CommonJS export names for ESM import in node:
+0 && (module.exports = {
+  BOOLEAN,
+  COMMENT_HEADER,
+  FALSE,
+  JS_ENUM_INVALID_CHARS_RE,
+  JS_PROPERTY_INDEX_INVALID_CHARS_RE,
+  JS_PROPERTY_INDEX_RE,
+  NEVER,
+  NULL,
+  NUMBER,
+  QUESTION_TOKEN,
+  SPECIAL_CHARACTER_MAP,
+  STRING,
+  TRUE,
+  UNDEFINED,
+  UNKNOWN,
+  addJSDocComment,
+  astToString,
+  c,
+  createDiscriminatorProperty,
+  createRef,
+  debug,
+  enumCache,
+  error,
+  formatTime,
+  getEntries,
+  injectOperationObject,
+  oapiRef,
+  resolveRef,
+  scanDiscriminators,
+  stringToAST,
+  transformComponentsObject,
+  transformHeaderObject,
+  transformMediaTypeObject,
+  transformOperationObject,
+  transformParameterObject,
+  transformPathItemObject,
+  transformPathsObject,
+  transformRequestBodyObject,
+  transformResponseObject,
+  transformResponsesObject,
+  transformSchema,
+  transformSchemaObject,
+  transformSchemaObjectWithComposition,
+  tsArrayLiteralExpression,
+  tsDedupe,
+  tsEnum,
+  tsEnumMember,
+  tsIntersection,
+  tsIsPrimitive,
+  tsLiteral,
+  tsModifiers,
+  tsNullable,
+  tsOmit,
+  tsPropertyIndex,
+  tsReadonlyArray,
+  tsRecord,
+  tsUnion,
+  tsWithRequired,
+  walk,
+  warn
+});
diff --git a/package/dist/index.d.ts b/package/dist/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..000a7e05edfe9b4d794e28c01c7de1a569772d2e
--- /dev/null
+++ b/package/dist/index.d.ts
@@ -0,0 +1,23 @@
+import type { Readable } from "node:stream";
+import type ts from "typescript";
+import type { OpenAPI3, OpenAPITSOptions } from "./types.js";
+export * from "./lib/ts.js";
+export * from "./lib/utils.js";
+export { default as transformSchema } from "./transform/index.js";
+export { default as transformComponentsObject } from "./transform/components-object.js";
+export { default as transformHeaderObject } from "./transform/header-object.js";
+export { default as transformMediaTypeObject } from "./transform/media-type-object.js";
+export * from "./transform/operation-object.js";
+export { default as transformOperationObject } from "./transform/operation-object.js";
+export { default as transformParameterObject } from "./transform/parameter-object.js";
+export * from "./transform/path-item-object.js";
+export { default as transformPathItemObject } from "./transform/path-item-object.js";
+export { default as transformPathsObject } from "./transform/paths-object.js";
+export { default as transformRequestBodyObject } from "./transform/request-body-object.js";
+export { default as transformResponseObject } from "./transform/response-object.js";
+export { default as transformResponsesObject } from "./transform/responses-object.js";
+export * from "./transform/schema-object.js";
+export { default as transformSchemaObject } from "./transform/schema-object.js";
+export * from "./types.js";
+export declare const COMMENT_HEADER = "/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n";
+export default function openapiTS(source: string | URL | OpenAPI3 | Buffer | Readable, options?: OpenAPITSOptions): Promise<ts.Node[]>;
diff --git a/package/dist/index.js b/package/dist/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..874c6af113bb443a15f3adba77367db46019f88f
--- /dev/null
+++ b/package/dist/index.js
@@ -0,0 +1,79 @@
+import { createConfig } from "@redocly/openapi-core";
+import { performance } from "node:perf_hooks";
+import { validateAndBundle } from "./lib/redoc.js";
+import { debug, resolveRef, scanDiscriminators } from "./lib/utils.js";
+import transformSchema from "./transform/index.js";
+export * from "./lib/ts.js";
+export * from "./lib/utils.js";
+export { default as transformSchema } from "./transform/index.js";
+export { default as transformComponentsObject } from "./transform/components-object.js";
+export { default as transformHeaderObject } from "./transform/header-object.js";
+export { default as transformMediaTypeObject } from "./transform/media-type-object.js";
+export * from "./transform/operation-object.js";
+export { default as transformOperationObject } from "./transform/operation-object.js";
+export { default as transformParameterObject } from "./transform/parameter-object.js";
+export * from "./transform/path-item-object.js";
+export { default as transformPathItemObject } from "./transform/path-item-object.js";
+export { default as transformPathsObject } from "./transform/paths-object.js";
+export { default as transformRequestBodyObject } from "./transform/request-body-object.js";
+export { default as transformResponseObject } from "./transform/response-object.js";
+export { default as transformResponsesObject } from "./transform/responses-object.js";
+export * from "./transform/schema-object.js";
+export { default as transformSchemaObject } from "./transform/schema-object.js";
+export * from "./types.js";
+export const COMMENT_HEADER = `/**
+ * This file was auto-generated by openapi-typescript.
+ * Do not make direct changes to the file.
+ */
+
+`;
+export default async function openapiTS(source, options = {}) {
+    if (!source) {
+        throw new Error("Empty schema. Please specify a URL, file path, or Redocly Config");
+    }
+    const redoc = options.redocly ??
+        (await createConfig({
+            rules: {
+                "operation-operationId-unique": { severity: "error" },
+            },
+        }, { extends: ["minimal"] }));
+    const schema = await validateAndBundle(source, {
+        redoc,
+        cwd: options.cwd instanceof URL ? options.cwd : new URL(`file://${options.cwd ?? process.cwd()}/`),
+        silent: options.silent ?? false,
+    });
+    const ctx = {
+        additionalProperties: options.additionalProperties ?? false,
+        alphabetize: options.alphabetize ?? false,
+        arrayLength: options.arrayLength ?? false,
+        defaultNonNullable: options.defaultNonNullable ?? true,
+        discriminators: scanDiscriminators(schema, options),
+        emptyObjectsUnknown: options.emptyObjectsUnknown ?? false,
+        enum: options.enum ?? false,
+        enumValues: options.enumValues ?? false,
+        dedupeEnums: options.dedupeEnums ?? false,
+        excludeDeprecated: options.excludeDeprecated ?? false,
+        exportType: options.exportType ?? false,
+        immutable: options.immutable ?? false,
+        rootTypes: options.rootTypes ?? false,
+        rootTypesNoSchemaPrefix: options.rootTypesNoSchemaPrefix ?? false,
+        injectFooter: [],
+        pathParamsAsTypes: options.pathParamsAsTypes ?? false,
+        postTransform: typeof options.postTransform === "function" ? options.postTransform : undefined,
+        propertiesRequiredByDefault: options.propertiesRequiredByDefault ?? false,
+        redoc,
+        silent: options.silent ?? false,
+        inject: options.inject ?? undefined,
+        transform: typeof options.transform === "function" ? options.transform : undefined,
+        makePathsEnum: options.makePathsEnum ?? false,
+        generatePathParams: options.generatePathParams ?? false,
+        resolve($ref) {
+            return resolveRef(schema, $ref, { silent: options.silent ?? false });
+        },
+    };
+    const transformT = performance.now();
+    const result = transformSchema(schema, ctx);
+    debug("Completed AST transformation for entire document", "ts", performance.now() - transformT);
+    return result;
+}
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/package/dist/index.js.map b/package/dist/index.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..9361e8525760b511525673ac2d7103d807b5d2dc
--- /dev/null
+++ b/package/dist/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/lib/redoc.d.ts b/package/dist/lib/redoc.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9be3f02330d78a14c36dd338e1ef3955c7b6bf97
--- /dev/null
+++ b/package/dist/lib/redoc.d.ts
@@ -0,0 +1,15 @@
+import { BaseResolver, type Config as RedoclyConfig, type Document } from "@redocly/openapi-core";
+import { Readable } from "node:stream";
+import type { OpenAPI3 } from "../types.js";
+export interface ValidateAndBundleOptions {
+    redoc: RedoclyConfig;
+    silent: boolean;
+    cwd?: URL;
+}
+interface ParseSchemaOptions {
+    absoluteRef: string;
+    resolver: BaseResolver;
+}
+export declare function parseSchema(schema: unknown, { absoluteRef, resolver }: ParseSchemaOptions): Promise<Document>;
+export declare function validateAndBundle(source: string | URL | OpenAPI3 | Readable | Buffer, options: ValidateAndBundleOptions): Promise<any>;
+export {};
diff --git a/package/dist/lib/redoc.js b/package/dist/lib/redoc.js
new file mode 100644
index 0000000000000000000000000000000000000000..65b6a32871426d5bb3461c2c98c4cc76b4cd1098
--- /dev/null
+++ b/package/dist/lib/redoc.js
@@ -0,0 +1,124 @@
+import { BaseResolver, bundle, makeDocumentFromString, Source, lintDocument, } from "@redocly/openapi-core";
+import { performance } from "node:perf_hooks";
+import { Readable } from "node:stream";
+import { fileURLToPath } from "node:url";
+import parseJson from "parse-json";
+import { debug, error, warn } from "./utils.js";
+export async function parseSchema(schema, { absoluteRef, resolver }) {
+    if (!schema) {
+        throw new Error("Canâ€™t parse empty schema");
+    }
+    if (schema instanceof URL) {
+        const result = await resolver.resolveDocument(null, absoluteRef, true);
+        if ("parsed" in result) {
+            return result;
+        }
+        throw result.originalError;
+    }
+    if (schema instanceof Readable) {
+        const contents = await new Promise((resolve) => {
+            schema.resume();
+            schema.setEncoding("utf8");
+            let content = "";
+            schema.on("data", (chunk) => {
+                content += chunk;
+            });
+            schema.on("end", () => {
+                resolve(content.trim());
+            });
+        });
+        return parseSchema(contents, { absoluteRef, resolver });
+    }
+    if (schema instanceof Buffer) {
+        return parseSchema(schema.toString("utf8"), { absoluteRef, resolver });
+    }
+    if (typeof schema === "string") {
+        if (schema.startsWith("http://") || schema.startsWith("https://") || schema.startsWith("file://")) {
+            const url = new URL(schema);
+            return parseSchema(url, {
+                absoluteRef: url.protocol === "file:" ? fileURLToPath(url) : url.href,
+                resolver,
+            });
+        }
+        if (schema[0] === "{") {
+            return {
+                source: new Source(absoluteRef, schema, "application/json"),
+                parsed: parseJson(schema),
+            };
+        }
+        return makeDocumentFromString(schema, absoluteRef);
+    }
+    if (typeof schema === "object" && !Array.isArray(schema)) {
+        return {
+            source: new Source(absoluteRef, JSON.stringify(schema), "application/json"),
+            parsed: schema,
+        };
+    }
+    throw new Error(`Expected string, object, or Buffer. Got ${Array.isArray(schema) ? "Array" : typeof schema}`);
+}
+function _processProblems(problems, options) {
+    if (problems.length) {
+        let errorMessage = undefined;
+        for (const problem of problems) {
+            const problemLocation = problem.location?.[0].pointer;
+            const problemMessage = problemLocation ? `${problem.message} at ${problemLocation}` : problem.message;
+            if (problem.severity === "error") {
+                errorMessage = problemMessage;
+                error(problemMessage);
+            }
+            else {
+                warn(problemMessage, options.silent);
+            }
+        }
+        if (errorMessage) {
+            throw new Error(errorMessage);
+        }
+    }
+}
+export async function validateAndBundle(source, options) {
+    const redocConfigT = performance.now();
+    debug("Loaded Redoc config", "redoc", performance.now() - redocConfigT);
+    const redocParseT = performance.now();
+    let absoluteRef = fileURLToPath(new URL(options?.cwd ?? `file://${process.cwd()}/`));
+    if (source instanceof URL) {
+        absoluteRef = source.protocol === "file:" ? fileURLToPath(source) : source.href;
+    }
+    const resolver = new BaseResolver(options.redoc.resolve);
+    const document = await parseSchema(source, {
+        absoluteRef,
+        resolver,
+    });
+    debug("Parsed schema", "redoc", performance.now() - redocParseT);
+    const openapiVersion = Number.parseFloat(document.parsed.openapi);
+    if (document.parsed.swagger ||
+        !document.parsed.openapi ||
+        Number.isNaN(openapiVersion) ||
+        openapiVersion < 3 ||
+        openapiVersion >= 4) {
+        if (document.parsed.swagger) {
+            throw new Error("Unsupported Swagger version: 2.x. Use OpenAPI 3.x instead.");
+        }
+        if (document.parsed.openapi || openapiVersion < 3 || openapiVersion >= 4) {
+            throw new Error(`Unsupported OpenAPI version: ${document.parsed.openapi}`);
+        }
+        throw new Error("Unsupported schema format, expected `openapi: 3.x`");
+    }
+    const redocLintT = performance.now();
+    const problems = await lintDocument({
+        document,
+        config: options.redoc.styleguide,
+        externalRefResolver: resolver,
+    });
+    _processProblems(problems, options);
+    debug("Linted schema", "lint", performance.now() - redocLintT);
+    const redocBundleT = performance.now();
+    const bundled = await bundle({
+        config: options.redoc,
+        dereference: false,
+        doc: document,
+    });
+    _processProblems(bundled.problems, options);
+    debug("Bundled schema", "bundle", performance.now() - redocBundleT);
+    return bundled.bundle.parsed;
+}
+//# sourceMappingURL=redoc.js.map
\ No newline at end of file
diff --git a/package/dist/lib/redoc.js.map b/package/dist/lib/redoc.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..fe7a3c1a32ece9ba29d30496fb63ebb8747533d2
--- /dev/null
+++ b/package/dist/lib/redoc.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"redoc.js","sourceRoot":"","sources":["../../src/lib/redoc.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/lib/ts.d.ts b/package/dist/lib/ts.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6e31e0ec46ae870dc987766511a52ab26663cf8d
--- /dev/null
+++ b/package/dist/lib/ts.d.ts
@@ -0,0 +1,69 @@
+import ts from "typescript";
+export declare const JS_PROPERTY_INDEX_RE: RegExp;
+export declare const JS_ENUM_INVALID_CHARS_RE: RegExp;
+export declare const JS_PROPERTY_INDEX_INVALID_CHARS_RE: RegExp;
+export declare const SPECIAL_CHARACTER_MAP: Record<string, string>;
+export declare const BOOLEAN: ts.KeywordTypeNode<ts.SyntaxKind.BooleanKeyword>;
+export declare const FALSE: ts.LiteralTypeNode;
+export declare const NEVER: ts.KeywordTypeNode<ts.SyntaxKind.NeverKeyword>;
+export declare const NULL: ts.LiteralTypeNode;
+export declare const NUMBER: ts.KeywordTypeNode<ts.SyntaxKind.NumberKeyword>;
+export declare const QUESTION_TOKEN: ts.PunctuationToken<ts.SyntaxKind.QuestionToken>;
+export declare const STRING: ts.KeywordTypeNode<ts.SyntaxKind.StringKeyword>;
+export declare const TRUE: ts.LiteralTypeNode;
+export declare const UNDEFINED: ts.KeywordTypeNode<ts.SyntaxKind.UndefinedKeyword>;
+export declare const UNKNOWN: ts.KeywordTypeNode<ts.SyntaxKind.UnknownKeyword>;
+export interface AnnotatedSchemaObject {
+    const?: unknown;
+    default?: unknown;
+    deprecated?: boolean;
+    description?: string;
+    enum?: unknown[];
+    example?: string;
+    format?: string;
+    nullable?: boolean;
+    summary?: string;
+    title?: string;
+    type?: string | string[];
+}
+export declare function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void;
+export declare function oapiRef(path: string): ts.TypeNode;
+export interface AstToStringOptions {
+    fileName?: string;
+    sourceText?: string;
+    formatOptions?: ts.PrinterOptions;
+}
+export declare function astToString(ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[], options?: AstToStringOptions): string;
+export declare function stringToAST(source: string): unknown[];
+export declare function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[];
+export declare const enumCache: Map<string, ts.EnumDeclaration>;
+export declare function tsEnum(name: string, members: (string | number)[], metadata?: {
+    name?: string;
+    description?: string;
+}[], options?: {
+    export?: boolean;
+    shouldCache?: boolean;
+}): ts.EnumDeclaration;
+export declare function tsArrayLiteralExpression(name: string, elementType: ts.TypeNode, values: (string | number)[], options?: {
+    export?: boolean;
+    readonly?: boolean;
+    injectFooter?: ts.Node[];
+}): ts.VariableStatement;
+export declare function tsEnumMember(value: string | number, metadata?: {
+    name?: string;
+    description?: string;
+}): ts.EnumMember;
+export declare function tsIntersection(types: ts.TypeNode[]): ts.TypeNode;
+export declare function tsIsPrimitive(type: ts.TypeNode): boolean;
+export declare function tsLiteral(value: unknown): ts.TypeNode;
+export declare function tsModifiers(modifiers: {
+    readonly?: boolean;
+    export?: boolean;
+}): ts.Modifier[];
+export declare function tsNullable(types: ts.TypeNode[]): ts.TypeNode;
+export declare function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode;
+export declare function tsRecord(key: ts.TypeNode, value: ts.TypeNode): ts.TypeReferenceNode;
+export declare function tsPropertyIndex(index: string | number): ts.Identifier | ts.NumericLiteral | ts.StringLiteral;
+export declare function tsUnion(types: ts.TypeNode[]): ts.TypeNode;
+export declare function tsWithRequired(type: ts.TypeNode, keys: string[], injectFooter: ts.Node[]): ts.TypeNode;
+export declare function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode;
diff --git a/package/dist/lib/ts.js b/package/dist/lib/ts.js
new file mode 100644
index 0000000000000000000000000000000000000000..7f46f68fe5a4b6fab4b5cba34602cf1268903d5c
--- /dev/null
+++ b/package/dist/lib/ts.js
@@ -0,0 +1,322 @@
+import { parseRef } from "@redocly/openapi-core/lib/ref-utils.js";
+import ts from "typescript";
+export const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;
+export const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;
+export const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;
+export const SPECIAL_CHARACTER_MAP = {
+    "+": "Plus",
+};
+export const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
+export const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());
+export const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);
+export const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());
+export const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
+export const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);
+export const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
+export const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());
+export const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);
+export const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
+const LB_RE = /\r?\n/g;
+const COMMENT_RE = /\*\//g;
+export function addJSDocComment(schemaObject, node) {
+    if (!schemaObject || typeof schemaObject !== "object" || Array.isArray(schemaObject)) {
+        return;
+    }
+    const output = [];
+    if (schemaObject.title) {
+        output.push(schemaObject.title.replace(LB_RE, "\n *     "));
+    }
+    if (schemaObject.summary) {
+        output.push(schemaObject.summary.replace(LB_RE, "\n *     "));
+    }
+    if (schemaObject.format) {
+        output.push(`Format: ${schemaObject.format}`);
+    }
+    if (schemaObject.deprecated) {
+        output.push("@deprecated");
+    }
+    const supportedJsDocTags = ["description", "default", "example"];
+    for (const field of supportedJsDocTags) {
+        const allowEmptyString = field === "default" || field === "example";
+        if (schemaObject[field] === undefined) {
+            continue;
+        }
+        if (schemaObject[field] === "" && !allowEmptyString) {
+            continue;
+        }
+        const serialized = typeof schemaObject[field] === "object" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];
+        output.push(`@${field} ${String(serialized).replace(LB_RE, "\n *     ")}`);
+    }
+    if ("const" in schemaObject) {
+        output.push("@constant");
+    }
+    if (schemaObject.enum) {
+        let type = "unknown";
+        if (Array.isArray(schemaObject.type)) {
+            type = schemaObject.type.join("|");
+        }
+        else if (typeof schemaObject.type === "string") {
+            type = schemaObject.type;
+        }
+        output.push(`@enum {${type}${schemaObject.nullable ? "|null" : ""}}`);
+    }
+    if (output.length) {
+        let text = output.length === 1
+            ? `* ${output.join("\n")} `
+            : `*
+ * ${output.join("\n * ")}\n `;
+        text = text.replace(COMMENT_RE, "*\\/");
+        ts.addSyntheticLeadingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, text, true);
+    }
+}
+export function oapiRef(path) {
+    const { pointer } = parseRef(path);
+    if (pointer.length === 0) {
+        throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);
+    }
+    let t = ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(pointer[0])));
+    if (pointer.length > 1) {
+        for (let i = 1; i < pointer.length; i++) {
+            if (i > 2 && i < pointer.length - 1 && pointer[i] === "properties") {
+                continue;
+            }
+            t = ts.factory.createIndexedAccessTypeNode(t, ts.factory.createLiteralTypeNode(typeof pointer[i] === "number"
+                ? ts.factory.createNumericLiteral(pointer[i])
+                : ts.factory.createStringLiteral(pointer[i])));
+        }
+    }
+    return t;
+}
+export function astToString(ast, options) {
+    const sourceFile = ts.createSourceFile(options?.fileName ?? "openapi-ts.ts", options?.sourceText ?? "", ts.ScriptTarget.ESNext, false, ts.ScriptKind.TS);
+    sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);
+    const printer = ts.createPrinter({
+        newLine: ts.NewLineKind.LineFeed,
+        removeComments: false,
+        ...options?.formatOptions,
+    });
+    return printer.printFile(sourceFile);
+}
+export function stringToAST(source) {
+    return ts.createSourceFile("stringInput", source, ts.ScriptTarget.ESNext, undefined, undefined).statements;
+}
+export function tsDedupe(types) {
+    const encounteredTypes = new Set();
+    const filteredTypes = [];
+    for (const t of types) {
+        if (!("text" in (t.literal ?? t))) {
+            const { kind } = t.literal ?? t;
+            if (encounteredTypes.has(kind)) {
+                continue;
+            }
+            if (tsIsPrimitive(t)) {
+                encounteredTypes.add(kind);
+            }
+        }
+        filteredTypes.push(t);
+    }
+    return filteredTypes;
+}
+export const enumCache = new Map();
+export function tsEnum(name, members, metadata, options) {
+    let enumName = sanitizeMemberName(name);
+    enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;
+    let key = "";
+    if (options?.shouldCache) {
+        key = `${members
+            .slice(0)
+            .sort()
+            .map((v, i) => {
+            return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || ""}`;
+        })
+            .join(",")}`;
+        if (enumCache.has(key)) {
+            return enumCache.get(key);
+        }
+    }
+    const enumDeclaration = ts.factory.createEnumDeclaration(options ? tsModifiers({ export: options.export ?? false }) : undefined, enumName, members.map((value, i) => tsEnumMember(value, metadata?.[i])));
+    options?.shouldCache && enumCache.set(key, enumDeclaration);
+    return enumDeclaration;
+}
+export function tsArrayLiteralExpression(name, elementType, values, options) {
+    let variableName = sanitizeMemberName(name);
+    variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;
+    const arrayType = options?.readonly
+        ? tsReadonlyArray(elementType, options.injectFooter)
+        : ts.factory.createArrayTypeNode(elementType);
+    return ts.factory.createVariableStatement(options ? tsModifiers({ export: options.export ?? false }) : undefined, ts.factory.createVariableDeclarationList([
+        ts.factory.createVariableDeclaration(variableName, undefined, arrayType, ts.factory.createArrayLiteralExpression(values.map((value) => {
+            if (typeof value === "number") {
+                if (value < 0) {
+                    return ts.factory.createPrefixUnaryExpression(ts.SyntaxKind.MinusToken, ts.factory.createNumericLiteral(Math.abs(value)));
+                }
+                else {
+                    return ts.factory.createNumericLiteral(value);
+                }
+            }
+            else {
+                return ts.factory.createStringLiteral(value);
+            }
+        }))),
+    ], ts.NodeFlags.Const));
+}
+function sanitizeMemberName(name) {
+    let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {
+        const last = c[c.length - 1];
+        return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? "" : last.toUpperCase();
+    });
+    if (Number(name[0]) >= 0) {
+        sanitizedName = `Value${name}`;
+    }
+    return sanitizedName;
+}
+export function tsEnumMember(value, metadata = {}) {
+    let name = metadata.name ?? String(value);
+    if (!JS_PROPERTY_INDEX_RE.test(name)) {
+        if (Number(name[0]) >= 0) {
+            name = `Value${name}`.replace(".", "_");
+        }
+        else if (name[0] === "-") {
+            name = `ValueMinus${name.slice(1)}`;
+        }
+        const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);
+        if (invalidCharMatch) {
+            if (invalidCharMatch[0] === name) {
+                name = `"${name}"`;
+            }
+            else {
+                name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {
+                    return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : "_";
+                });
+            }
+        }
+    }
+    let member;
+    if (typeof value === "number") {
+        const literal = value < 0
+            ? ts.factory.createPrefixUnaryExpression(ts.SyntaxKind.MinusToken, ts.factory.createNumericLiteral(Math.abs(value)))
+            : ts.factory.createNumericLiteral(value);
+        member = ts.factory.createEnumMember(name, literal);
+    }
+    else {
+        member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));
+    }
+    if (metadata.description === undefined) {
+        return member;
+    }
+    return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, " ".concat(metadata.description.trim()), true);
+}
+export function tsIntersection(types) {
+    if (types.length === 0) {
+        return NEVER;
+    }
+    if (types.length === 1) {
+        return types[0];
+    }
+    return ts.factory.createIntersectionTypeNode(tsDedupe(types));
+}
+export function tsIsPrimitive(type) {
+    if (!type) {
+        return true;
+    }
+    return (ts.SyntaxKind[type.kind] === "BooleanKeyword" ||
+        ts.SyntaxKind[type.kind] === "NeverKeyword" ||
+        ts.SyntaxKind[type.kind] === "NullKeyword" ||
+        ts.SyntaxKind[type.kind] === "NumberKeyword" ||
+        ts.SyntaxKind[type.kind] === "StringKeyword" ||
+        ts.SyntaxKind[type.kind] === "UndefinedKeyword" ||
+        ("literal" in type && tsIsPrimitive(type.literal)));
+}
+export function tsLiteral(value) {
+    if (typeof value === "string") {
+        return ts.factory.createIdentifier(JSON.stringify(value));
+    }
+    if (typeof value === "number") {
+        const literal = value < 0
+            ? ts.factory.createPrefixUnaryExpression(ts.SyntaxKind.MinusToken, ts.factory.createNumericLiteral(Math.abs(value)))
+            : ts.factory.createNumericLiteral(value);
+        return ts.factory.createLiteralTypeNode(literal);
+    }
+    if (typeof value === "boolean") {
+        return value === true ? TRUE : FALSE;
+    }
+    if (value === null) {
+        return NULL;
+    }
+    if (Array.isArray(value)) {
+        if (value.length === 0) {
+            return ts.factory.createArrayTypeNode(NEVER);
+        }
+        return ts.factory.createTupleTypeNode(value.map((v) => tsLiteral(v)));
+    }
+    if (typeof value === "object") {
+        const keys = [];
+        for (const [k, v] of Object.entries(value)) {
+            keys.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex(k), undefined, tsLiteral(v)));
+        }
+        return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);
+    }
+    return UNKNOWN;
+}
+export function tsModifiers(modifiers) {
+    const typeMods = [];
+    if (modifiers.export) {
+        typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));
+    }
+    if (modifiers.readonly) {
+        typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));
+    }
+    return typeMods;
+}
+export function tsNullable(types) {
+    return ts.factory.createUnionTypeNode([...types, NULL]);
+}
+export function tsOmit(type, keys) {
+    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("Omit"), [
+        type,
+        ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),
+    ]);
+}
+export function tsRecord(key, value) {
+    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("Record"), [key, value]);
+}
+export function tsPropertyIndex(index) {
+    if ((typeof index === "number" && !(index < 0)) ||
+        (typeof index === "string" && String(Number(index)) === index && index[0] !== "-")) {
+        return ts.factory.createNumericLiteral(index);
+    }
+    return typeof index === "string" && JS_PROPERTY_INDEX_RE.test(index)
+        ? ts.factory.createIdentifier(index)
+        : ts.factory.createStringLiteral(String(index));
+}
+export function tsUnion(types) {
+    if (types.length === 0) {
+        return NEVER;
+    }
+    if (types.length === 1) {
+        return types[0];
+    }
+    return ts.factory.createUnionTypeNode(tsDedupe(types));
+}
+export function tsWithRequired(type, keys, injectFooter) {
+    if (keys.length === 0) {
+        return type;
+    }
+    if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === "WithRequired")) {
+        const helper = stringToAST("type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };")[0];
+        injectFooter.push(helper);
+    }
+    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("WithRequired"), [
+        type,
+        tsUnion(keys.map((k) => tsLiteral(k))),
+    ]);
+}
+export function tsReadonlyArray(type, injectFooter) {
+    if (injectFooter &&
+        !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === "ReadonlyArray")) {
+        const helper = stringToAST("type ReadonlyArray<T> = [Exclude<T, undefined>] extends [any[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;")[0];
+        injectFooter.push(helper);
+    }
+    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("ReadonlyArray"), [type]);
+}
+//# sourceMappingURL=ts.js.map
\ No newline at end of file
diff --git a/package/dist/lib/ts.js.map b/package/dist/lib/ts.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..c61104cffa627a398cf6a54a381e5c521d6b8772
--- /dev/null
+++ b/package/dist/lib/ts.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ts.js","sourceRoot":"","sources":["../../src/lib/ts.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/lib/utils.d.ts b/package/dist/lib/utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ef06148a9586058d0779e17e74013a850bb3eb85
--- /dev/null
+++ b/package/dist/lib/utils.d.ts
@@ -0,0 +1,26 @@
+import c from "ansi-colors";
+import ts from "typescript";
+import type { DiscriminatorObject, OpenAPI3, OpenAPITSOptions } from "../types.js";
+export { c };
+export declare function createDiscriminatorProperty(discriminator: DiscriminatorObject, { path, readonly }: {
+    path: string;
+    readonly?: boolean;
+}): ts.TypeElement;
+export declare function createRef(parts: (number | string | undefined | null)[]): string;
+export declare function debug(msg: string, group?: string, time?: number): void;
+export declare function error(msg: string): void;
+export declare function formatTime(t: number): string;
+export declare function getEntries<T>(obj: ArrayLike<T> | Record<string, T>, options?: {
+    alphabetize?: boolean;
+    excludeDeprecated?: boolean;
+}): [string, T][];
+export declare function resolveRef<T>(schema: any, $ref: string, { silent, visited }: {
+    silent: boolean;
+    visited?: string[];
+}): T | undefined;
+export declare function scanDiscriminators(schema: OpenAPI3, options: OpenAPITSOptions): {
+    objects: Record<string, DiscriminatorObject>;
+    refsHandled: string[];
+};
+export declare function walk(obj: unknown, cb: (value: Record<string, unknown>, path: (string | number)[]) => void, path?: (string | number)[]): void;
+export declare function warn(msg: string, silent?: boolean): void;
diff --git a/package/dist/lib/utils.js b/package/dist/lib/utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..bede54e75eee62b7ecadc33fd9f502ab101a8498
--- /dev/null
+++ b/package/dist/lib/utils.js
@@ -0,0 +1,260 @@
+import { escapePointer, parseRef } from "@redocly/openapi-core/lib/ref-utils.js";
+import c from "ansi-colors";
+import supportsColor from "supports-color";
+import ts from "typescript";
+import { tsLiteral, tsModifiers, tsPropertyIndex } from "./ts.js";
+if (!supportsColor.stdout || supportsColor.stdout.hasBasic === false) {
+    c.enabled = false;
+}
+const DEBUG_GROUPS = {
+    redoc: c.cyanBright,
+    lint: c.yellowBright,
+    bundle: c.magentaBright,
+    ts: c.blueBright,
+};
+export { c };
+export function createDiscriminatorProperty(discriminator, { path, readonly = false }) {
+    let value = parseRef(path).pointer.pop();
+    if (discriminator.mapping) {
+        const matchedValue = Object.entries(discriminator.mapping).find(([, v]) => (!v.startsWith("#") && v === value) || (v.startsWith("#") && parseRef(v).pointer.pop() === value));
+        if (matchedValue) {
+            value = matchedValue[0];
+        }
+    }
+    return ts.factory.createPropertySignature(tsModifiers({
+        readonly,
+    }), tsPropertyIndex(discriminator.propertyName), undefined, tsLiteral(value));
+}
+export function createRef(parts) {
+    let pointer = "#";
+    for (const part of parts) {
+        if (part === undefined || part === null || part === "") {
+            continue;
+        }
+        const maybeRef = parseRef(String(part)).pointer;
+        if (maybeRef.length) {
+            for (const refPart of maybeRef) {
+                pointer += `/${escapePointer(refPart)}`;
+            }
+        }
+        else {
+            pointer += `/${escapePointer(part)}`;
+        }
+    }
+    return pointer;
+}
+export function debug(msg, group, time) {
+    if (process.env.DEBUG &&
+        (!group ||
+            process.env.DEBUG === "*" ||
+            process.env.DEBUG === "openapi-ts:*" ||
+            process.env.DEBUG.toLocaleLowerCase() === `openapi-ts:${group.toLocaleLowerCase()}`)) {
+        const groupColor = (group && DEBUG_GROUPS[group]) || c.whiteBright;
+        const groupName = groupColor(`openapi-ts:${group ?? "info"}`);
+        let timeFormatted = "";
+        if (typeof time === "number") {
+            timeFormatted = c.green(` ${formatTime(time)} `);
+        }
+        console.debug(`  ${c.bold(groupName)}${timeFormatted}${msg}`);
+    }
+}
+export function error(msg) {
+    console.error(c.red(` âœ˜  ${msg}`));
+}
+export function formatTime(t) {
+    if (typeof t === "number") {
+        if (t < 1000) {
+            return `${Math.round(10 * t) / 10}ms`;
+        }
+        if (t < 60000) {
+            return `${Math.round(t / 100) / 10}s`;
+        }
+        return `${Math.round(t / 6000) / 10}m`;
+    }
+    return t;
+}
+export function getEntries(obj, options) {
+    let entries = Object.entries(obj);
+    if (options?.alphabetize) {
+        entries.sort(([a], [b]) => a.localeCompare(b, "en-us", { numeric: true }));
+    }
+    if (options?.excludeDeprecated) {
+        entries = entries.filter(([, v]) => !(v && typeof v === "object" && "deprecated" in v && v.deprecated));
+    }
+    return entries;
+}
+export function resolveRef(schema, $ref, { silent = false, visited = [] }) {
+    const { pointer } = parseRef($ref);
+    if (!pointer.length) {
+        return undefined;
+    }
+    let node = schema;
+    for (const key of pointer) {
+        if (node && typeof node === "object" && node[key]) {
+            node = node[key];
+        }
+        else {
+            warn(`Could not resolve $ref "${$ref}"`, silent);
+            return undefined;
+        }
+    }
+    if (node && typeof node === "object" && node.$ref) {
+        if (visited.includes(node.$ref)) {
+            warn(`Could not resolve circular $ref "${$ref}"`, silent);
+            return undefined;
+        }
+        return resolveRef(schema, node.$ref, {
+            silent,
+            visited: [...visited, node.$ref],
+        });
+    }
+    return node;
+}
+function createDiscriminatorEnum(values, prevSchema) {
+    return {
+        type: "string",
+        enum: values,
+        description: prevSchema?.description
+            ? `${prevSchema.description} (enum property replaced by openapi-typescript)`
+            : "discriminator enum property added by openapi-typescript",
+    };
+}
+function patchDiscriminatorEnum(schema, ref, values, discriminator, discriminatorRef, options) {
+    const resolvedSchema = resolveRef(schema, ref, {
+        silent: options.silent ?? false,
+    });
+    if (resolvedSchema?.allOf) {
+        resolvedSchema.allOf.push({
+            type: "object",
+            required: [discriminator.propertyName],
+            properties: {
+                [discriminator.propertyName]: createDiscriminatorEnum(values),
+            },
+        });
+        return true;
+    }
+    else if (typeof resolvedSchema === "object" && "type" in resolvedSchema && resolvedSchema.type === "object") {
+        if (!resolvedSchema.properties) {
+            resolvedSchema.properties = {};
+        }
+        if (!resolvedSchema.required) {
+            resolvedSchema.required = [discriminator.propertyName];
+        }
+        else if (!resolvedSchema.required.includes(discriminator.propertyName)) {
+            resolvedSchema.required.push(discriminator.propertyName);
+        }
+        resolvedSchema.properties[discriminator.propertyName] = createDiscriminatorEnum(values, resolvedSchema.properties[discriminator.propertyName]);
+        return true;
+    }
+    warn(`Discriminator mapping has an invalid schema (neither an object schema nor an allOf array): ${ref} => ${values.join(", ")} (Discriminator: ${discriminatorRef})`, options.silent);
+    return false;
+}
+export function scanDiscriminators(schema, options) {
+    const objects = {};
+    const refsHandled = [];
+    walk(schema, (obj, path) => {
+        const discriminator = obj?.discriminator;
+        if (!discriminator?.propertyName) {
+            return;
+        }
+        const ref = createRef(path);
+        objects[ref] = discriminator;
+        if (!obj?.oneOf || !Array.isArray(obj.oneOf)) {
+            return;
+        }
+        const oneOf = obj.oneOf;
+        const mapping = {};
+        for (const item of oneOf) {
+            if ("$ref" in item) {
+                const value = item.$ref.split("/").pop();
+                if (value) {
+                    if (!mapping[item.$ref]) {
+                        mapping[item.$ref] = { inferred: value };
+                    }
+                    else {
+                        mapping[item.$ref].inferred = value;
+                    }
+                }
+            }
+        }
+        if (discriminator.mapping) {
+            for (const mappedValue in discriminator.mapping) {
+                const mappedRef = discriminator.mapping[mappedValue];
+                if (!mappedRef) {
+                    continue;
+                }
+                if (!mapping[mappedRef]?.defined) {
+                    mapping[mappedRef] = { defined: [] };
+                }
+                mapping[mappedRef].defined?.push(mappedValue);
+            }
+        }
+        for (const [mappedRef, { inferred, defined }] of Object.entries(mapping)) {
+            if (refsHandled.includes(mappedRef)) {
+                continue;
+            }
+            if (!inferred && !defined) {
+                continue;
+            }
+            const mappedValues = defined ?? [inferred];
+            if (patchDiscriminatorEnum(schema, mappedRef, mappedValues, discriminator, ref, options)) {
+                refsHandled.push(mappedRef);
+            }
+        }
+    });
+    walk(schema, (obj, path) => {
+        if (!obj || !Array.isArray(obj.allOf)) {
+            return;
+        }
+        for (const item of obj.allOf) {
+            if ("$ref" in item) {
+                if (!objects[item.$ref]) {
+                    return;
+                }
+                const ref = createRef(path);
+                const discriminator = objects[item.$ref];
+                const mappedValues = [];
+                if (discriminator.mapping) {
+                    for (const mappedValue in discriminator.mapping) {
+                        if (discriminator.mapping[mappedValue] === ref) {
+                            mappedValues.push(mappedValue);
+                        }
+                    }
+                    if (mappedValues.length > 0) {
+                        if (patchDiscriminatorEnum(schema, ref, mappedValues, discriminator, item.$ref, options)) {
+                            refsHandled.push(ref);
+                        }
+                    }
+                }
+                objects[ref] = {
+                    ...objects[item.$ref],
+                };
+            }
+            else if (item.discriminator?.propertyName) {
+                objects[createRef(path)] = { ...item.discriminator };
+            }
+        }
+    });
+    return { objects, refsHandled };
+}
+export function walk(obj, cb, path = []) {
+    if (!obj || typeof obj !== "object") {
+        return;
+    }
+    if (Array.isArray(obj)) {
+        for (let i = 0; i < obj.length; i++) {
+            walk(obj[i], cb, path.concat(i));
+        }
+        return;
+    }
+    cb(obj, path);
+    for (const k of Object.keys(obj)) {
+        walk(obj[k], cb, path.concat(k));
+    }
+}
+export function warn(msg, silent = false) {
+    if (!silent) {
+        console.warn(c.yellow(` âš   ${msg}`));
+    }
+}
+//# sourceMappingURL=utils.js.map
\ No newline at end of file
diff --git a/package/dist/lib/utils.js.map b/package/dist/lib/utils.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..96db2780c2c0d15386fb7d94e6a268cf9340d96b
--- /dev/null
+++ b/package/dist/lib/utils.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/lib/utils.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/components-object.d.ts b/package/dist/transform/components-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7eeae8a73e573f1d51ce8cd199e26d82b9dd79bf
--- /dev/null
+++ b/package/dist/transform/components-object.d.ts
@@ -0,0 +1,4 @@
+import ts from "typescript";
+import type { ComponentsObject, GlobalContext } from "../types.js";
+export default function transformComponentsObject(componentsObject: ComponentsObject, ctx: GlobalContext): ts.Node[];
+export declare function singularizeComponentKey(key: `x-${string}` | "schemas" | "responses" | "parameters" | "requestBodies" | "headers" | "pathItems"): string;
diff --git a/package/dist/transform/components-object.js b/package/dist/transform/components-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..04e66ecb5918e3dba848e73061cdb4f601611bed
--- /dev/null
+++ b/package/dist/transform/components-object.js
@@ -0,0 +1,87 @@
+import ts from "typescript";
+import * as changeCase from "change-case";
+import { performance } from "node:perf_hooks";
+import { NEVER, QUESTION_TOKEN, addJSDocComment, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef, debug, getEntries } from "../lib/utils.js";
+import transformHeaderObject from "./header-object.js";
+import transformParameterObject from "./parameter-object.js";
+import transformPathItemObject from "./path-item-object.js";
+import transformRequestBodyObject from "./request-body-object.js";
+import transformResponseObject from "./response-object.js";
+import transformSchemaObject from "./schema-object.js";
+const transformers = {
+    schemas: transformSchemaObject,
+    responses: transformResponseObject,
+    parameters: transformParameterObject,
+    requestBodies: transformRequestBodyObject,
+    headers: transformHeaderObject,
+    pathItems: transformPathItemObject,
+};
+export default function transformComponentsObject(componentsObject, ctx) {
+    const type = [];
+    const rootTypeAliases = {};
+    for (const key of Object.keys(transformers)) {
+        const componentT = performance.now();
+        const items = [];
+        if (componentsObject[key]) {
+            for (const [name, item] of getEntries(componentsObject[key], ctx)) {
+                let subType = transformers[key](item, {
+                    path: createRef(["components", key, name]),
+                    schema: item,
+                    ctx,
+                });
+                let hasQuestionToken = false;
+                if (ctx.transform) {
+                    const result = ctx.transform(item, {
+                        path: createRef(["components", key, name]),
+                        schema: item,
+                        ctx,
+                    });
+                    if (result) {
+                        if ("schema" in result) {
+                            subType = result.schema;
+                            hasQuestionToken = result.questionToken;
+                        }
+                        else {
+                            subType = result;
+                        }
+                    }
+                }
+                const property = ts.factory.createPropertySignature(tsModifiers({ readonly: ctx.immutable }), tsPropertyIndex(name), hasQuestionToken ? QUESTION_TOKEN : undefined, subType);
+                addJSDocComment(item, property);
+                items.push(property);
+                if (ctx.rootTypes) {
+                    const componentKey = changeCase.pascalCase(singularizeComponentKey(key));
+                    let aliasName = `${componentKey}${changeCase.pascalCase(name)}`;
+                    let conflictCounter = 1;
+                    while (rootTypeAliases[aliasName] !== undefined) {
+                        conflictCounter++;
+                        aliasName = `${componentKey}${changeCase.pascalCase(name)}_${conflictCounter}`;
+                    }
+                    const ref = ts.factory.createTypeReferenceNode(`components['${key}']['${name}']`);
+                    if (ctx.rootTypesNoSchemaPrefix && key === "schemas") {
+                        aliasName = aliasName.replace(componentKey, "");
+                    }
+                    const typeAlias = ts.factory.createTypeAliasDeclaration(tsModifiers({ export: true }), aliasName, undefined, ref);
+                    rootTypeAliases[aliasName] = typeAlias;
+                }
+            }
+        }
+        type.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex(key), undefined, items.length ? ts.factory.createTypeLiteralNode(items) : NEVER));
+        debug(`Transformed components â†’ ${key}`, "ts", performance.now() - componentT);
+    }
+    let rootTypes = [];
+    if (ctx.rootTypes) {
+        rootTypes = Object.keys(rootTypeAliases).map((k) => rootTypeAliases[k]);
+    }
+    return [ts.factory.createTypeLiteralNode(type), ...rootTypes];
+}
+export function singularizeComponentKey(key) {
+    switch (key) {
+        case "requestBodies":
+            return "requestBody";
+        default:
+            return key.slice(0, -1);
+    }
+}
+//# sourceMappingURL=components-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/components-object.js.map b/package/dist/transform/components-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..abcb4f3dc37b3df73a738e988e6104a07f0d74c6
--- /dev/null
+++ b/package/dist/transform/components-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"components-object.js","sourceRoot":"","sources":["../../src/transform/components-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/header-object.d.ts b/package/dist/transform/header-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4a7b606cffec8e127812d30cde2640e6dc8a469f
--- /dev/null
+++ b/package/dist/transform/header-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { HeaderObject, TransformNodeOptions } from "../types.js";
+export default function transformHeaderObject(headerObject: HeaderObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/header-object.js b/package/dist/transform/header-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..c74c1eb5922fceb4f93936510aa8c7c681e252b1
--- /dev/null
+++ b/package/dist/transform/header-object.js
@@ -0,0 +1,32 @@
+import { escapePointer } from "@redocly/openapi-core/lib/ref-utils.js";
+import ts from "typescript";
+import { addJSDocComment, tsModifiers, tsPropertyIndex, UNKNOWN } from "../lib/ts.js";
+import { getEntries } from "../lib/utils.js";
+import transformMediaTypeObject from "./media-type-object.js";
+import transformSchemaObject from "./schema-object.js";
+export default function transformHeaderObject(headerObject, options) {
+    if (headerObject.schema) {
+        return transformSchemaObject(headerObject.schema, options);
+    }
+    if (headerObject.content) {
+        const type = [];
+        for (const [contentType, mediaTypeObject] of getEntries(headerObject.content ?? {}, options.ctx)) {
+            const nextPath = `${options.path ?? "#"}/${escapePointer(contentType)}`;
+            const mediaType = "$ref" in mediaTypeObject
+                ? transformSchemaObject(mediaTypeObject, {
+                    ...options,
+                    path: nextPath,
+                })
+                : transformMediaTypeObject(mediaTypeObject, {
+                    ...options,
+                    path: nextPath,
+                });
+            const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(contentType), undefined, mediaType);
+            addJSDocComment(mediaTypeObject, property);
+            type.push(property);
+        }
+        return ts.factory.createTypeLiteralNode(type);
+    }
+    return UNKNOWN;
+}
+//# sourceMappingURL=header-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/header-object.js.map b/package/dist/transform/header-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..eda3d1b9001db80a6c45ef27ebb629b825b0b88c
--- /dev/null
+++ b/package/dist/transform/header-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"header-object.js","sourceRoot":"","sources":["../../src/transform/header-object.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,wCAAwC,CAAC;AACvE,OAAO,EAAE,MAAM,YAAY,CAAC;AAC5B,OAAO,EAAE,eAAe,EAAE,WAAW,EAAE,eAAe,EAAE,OAAO,EAAE,MAAM,cAAc,CAAC;AACtF,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAE7C,OAAO,wBAAwB,MAAM,wBAAwB,CAAC;AAC9D,OAAO,qBAAqB,MAAM,oBAAoB,CAAC;AAMvD,MAAM,CAAC,OAAO,UAAU,qBAAqB,CAAC,YAA0B,EAAE,OAA6B;IACrG,IAAI,YAAY,CAAC,MAAM,EAAE,CAAC;QACxB,OAAO,qBAAqB,CAAC,YAAY,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAC7D,CAAC;IAED,IAAI,YAAY,CAAC,OAAO,EAAE,CAAC;QACzB,MAAM,IAAI,GAAqB,EAAE,CAAC;QAClC,KAAK,MAAM,CAAC,WAAW,EAAE,eAAe,CAAC,IAAI,UAAU,CAAC,YAAY,CAAC,OAAO,IAAI,EAAE,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;YACjG,MAAM,QAAQ,GAAG,GAAG,OAAO,CAAC,IAAI,IAAI,GAAG,IAAI,aAAa,CAAC,WAAW,CAAC,EAAE,CAAC;YACxE,MAAM,SAAS,GACb,MAAM,IAAI,eAAe;gBACvB,CAAC,CAAC,qBAAqB,CAAC,eAAe,EAAE;oBACrC,GAAG,OAAO;oBACV,IAAI,EAAE,QAAQ;iBACf,CAAC;gBACJ,CAAC,CAAC,wBAAwB,CAAC,eAAe,EAAE;oBACxC,GAAG,OAAO;oBACV,IAAI,EAAE,QAAQ;iBACf,CAAC,CAAC;YACT,MAAM,QAAQ,GAAG,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAC7B,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,WAAW,CAAC,EAC5B,SAAS,EACT,SAAS,CAC9B,CAAC;YACF,eAAe,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;YAC3C,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC;QACD,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;IAChD,CAAC;IAED,OAAO,OAAO,CAAC;AACjB,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/index.d.ts b/package/dist/transform/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..818da4cad15a26059d44d6b36680623ebe90abd0
--- /dev/null
+++ b/package/dist/transform/index.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { GlobalContext, OpenAPI3 } from "../types.js";
+export default function transformSchema(schema: OpenAPI3, ctx: GlobalContext): ts.Node[];
diff --git a/package/dist/transform/index.js b/package/dist/transform/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..2fb6e8d80aee60b2b921f0e7d08d66a8cb27679f
--- /dev/null
+++ b/package/dist/transform/index.js
@@ -0,0 +1,69 @@
+import ts from "typescript";
+import { performance } from "node:perf_hooks";
+import { NEVER, STRING, stringToAST, tsModifiers, tsRecord } from "../lib/ts.js";
+import { createRef, debug } from "../lib/utils.js";
+import transformComponentsObject from "./components-object.js";
+import transformPathsObject from "./paths-object.js";
+import transformSchemaObject from "./schema-object.js";
+import transformWebhooksObject from "./webhooks-object.js";
+import makeApiPathsEnum from "./paths-enum.js";
+const transformers = {
+    paths: transformPathsObject,
+    webhooks: transformWebhooksObject,
+    components: transformComponentsObject,
+    $defs: (node, options) => transformSchemaObject(node, { path: createRef(["$defs"]), ctx: options, schema: node }),
+};
+export default function transformSchema(schema, ctx) {
+    const type = [];
+    if (ctx.inject) {
+        const injectNodes = stringToAST(ctx.inject);
+        type.push(...injectNodes);
+    }
+    for (const root of Object.keys(transformers)) {
+        const emptyObj = ts.factory.createTypeAliasDeclaration(tsModifiers({ export: true }), root, undefined, tsRecord(STRING, NEVER));
+        if (schema[root] && typeof schema[root] === "object") {
+            const rootT = performance.now();
+            const subTypes = [].concat(transformers[root](schema[root], ctx));
+            for (const subType of subTypes) {
+                if (ts.isTypeNode(subType)) {
+                    if (subType.members?.length) {
+                        type.push(ctx.exportType
+                            ? ts.factory.createTypeAliasDeclaration(tsModifiers({ export: true }), root, undefined, subType)
+                            : ts.factory.createInterfaceDeclaration(tsModifiers({ export: true }), root, undefined, undefined, subType.members));
+                        debug(`${root} done`, "ts", performance.now() - rootT);
+                    }
+                    else {
+                        type.push(emptyObj);
+                        debug(`${root} done (skipped)`, "ts", 0);
+                    }
+                }
+                else if (ts.isTypeAliasDeclaration(subType)) {
+                    type.push(subType);
+                }
+                else {
+                    type.push(emptyObj);
+                    debug(`${root} done (skipped)`, "ts", 0);
+                }
+            }
+        }
+        else {
+            type.push(emptyObj);
+            debug(`${root} done (skipped)`, "ts", 0);
+        }
+    }
+    let hasOperations = false;
+    for (const injectedType of ctx.injectFooter) {
+        if (!hasOperations && injectedType?.name?.escapedText === "operations") {
+            hasOperations = true;
+        }
+        type.push(injectedType);
+    }
+    if (!hasOperations) {
+        type.push(ts.factory.createTypeAliasDeclaration(tsModifiers({ export: true }), "operations", undefined, tsRecord(STRING, NEVER)));
+    }
+    if (ctx.makePathsEnum && schema.paths) {
+        type.push(makeApiPathsEnum(schema.paths));
+    }
+    return type;
+}
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/package/dist/transform/index.js.map b/package/dist/transform/index.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..997cbe79a2f99383f848bf1b41b291ddd1669d12
--- /dev/null
+++ b/package/dist/transform/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/transform/index.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/media-type-object.d.ts b/package/dist/transform/media-type-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1cd36633da88911320975d8bf3e2655bdd4c7e
--- /dev/null
+++ b/package/dist/transform/media-type-object.d.ts
@@ -0,0 +1,3 @@
+import type ts from "typescript";
+import type { MediaTypeObject, TransformNodeOptions } from "../types.js";
+export default function transformMediaTypeObject(mediaTypeObject: MediaTypeObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/media-type-object.js b/package/dist/transform/media-type-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..8e983d83f07206fdaaf69e8aa38e1f5181b15fb8
--- /dev/null
+++ b/package/dist/transform/media-type-object.js
@@ -0,0 +1,9 @@
+import { UNKNOWN } from "../lib/ts.js";
+import transformSchemaObject from "./schema-object.js";
+export default function transformMediaTypeObject(mediaTypeObject, options) {
+    if (!mediaTypeObject.schema) {
+        return UNKNOWN;
+    }
+    return transformSchemaObject(mediaTypeObject.schema, options);
+}
+//# sourceMappingURL=media-type-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/media-type-object.js.map b/package/dist/transform/media-type-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f4f95f7c44f8e94b4f99afcc2908caf6ba66d407
--- /dev/null
+++ b/package/dist/transform/media-type-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"media-type-object.js","sourceRoot":"","sources":["../../src/transform/media-type-object.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,OAAO,EAAE,MAAM,cAAc,CAAC;AAEvC,OAAO,qBAAqB,MAAM,oBAAoB,CAAC;AAMvD,MAAM,CAAC,OAAO,UAAU,wBAAwB,CAC9C,eAAgC,EAChC,OAA6B;IAE7B,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;QAC5B,OAAO,OAAO,CAAC;IACjB,CAAC;IACD,OAAO,qBAAqB,CAAC,eAAe,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAChE,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/operation-object.d.ts b/package/dist/transform/operation-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..49953102780c120f77165776ddfaacc71716b386
--- /dev/null
+++ b/package/dist/transform/operation-object.d.ts
@@ -0,0 +1,4 @@
+import ts from "typescript";
+import type { OperationObject, TransformNodeOptions } from "../types.js";
+export default function transformOperationObject(operationObject: OperationObject, options: TransformNodeOptions): ts.TypeElement[];
+export declare function injectOperationObject(operationId: string, operationObject: OperationObject, options: TransformNodeOptions): void;
diff --git a/package/dist/transform/operation-object.js b/package/dist/transform/operation-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..d4203a0792594fbea2ae9a6edd30989e9d696819
--- /dev/null
+++ b/package/dist/transform/operation-object.js
@@ -0,0 +1,44 @@
+import ts from "typescript";
+import { NEVER, QUESTION_TOKEN, addJSDocComment, oapiRef, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef } from "../lib/utils.js";
+import { transformParametersArray } from "./parameters-array.js";
+import transformRequestBodyObject from "./request-body-object.js";
+import transformResponsesObject from "./responses-object.js";
+export default function transformOperationObject(operationObject, options) {
+    const type = [];
+    type.push(...transformParametersArray(operationObject.parameters ?? [], options));
+    if (operationObject.requestBody) {
+        const requestBodyType = "$ref" in operationObject.requestBody
+            ? oapiRef(operationObject.requestBody.$ref)
+            : transformRequestBodyObject(operationObject.requestBody, {
+                ...options,
+                path: createRef([options.path, "requestBody"]),
+            });
+        const required = !!("$ref" in operationObject.requestBody
+            ? options.ctx.resolve(operationObject.requestBody.$ref)
+            : operationObject.requestBody)?.required;
+        const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex("requestBody"), required ? undefined : QUESTION_TOKEN, requestBodyType);
+        addJSDocComment(operationObject.requestBody, property);
+        type.push(property);
+    }
+    else {
+        type.push(ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex("requestBody"), QUESTION_TOKEN, NEVER));
+    }
+    type.push(ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex("responses"), undefined, transformResponsesObject(operationObject.responses ?? {}, options)));
+    return type;
+}
+export function injectOperationObject(operationId, operationObject, options) {
+    let operations = options.ctx.injectFooter.find((node) => ts.isInterfaceDeclaration(node) && node.name.text === "operations");
+    if (!operations) {
+        operations = ts.factory.createInterfaceDeclaration(tsModifiers({
+            export: true,
+        }), ts.factory.createIdentifier("operations"), undefined, undefined, []);
+        options.ctx.injectFooter.push(operations);
+    }
+    const type = transformOperationObject(operationObject, options);
+    operations.members = ts.factory.createNodeArray([
+        ...operations.members,
+        ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(operationId), undefined, ts.factory.createTypeLiteralNode(type)),
+    ]);
+}
+//# sourceMappingURL=operation-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/operation-object.js.map b/package/dist/transform/operation-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..e347d2d374dc4a308bd1d74a3f3b9b5c242bb9bf
--- /dev/null
+++ b/package/dist/transform/operation-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"operation-object.js","sourceRoot":"","sources":["../../src/transform/operation-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/parameter-object.d.ts b/package/dist/transform/parameter-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bf6ee2436c3886b5decf5d321689eedb393877c2
--- /dev/null
+++ b/package/dist/transform/parameter-object.d.ts
@@ -0,0 +1,3 @@
+import type ts from "typescript";
+import type { ParameterObject, TransformNodeOptions } from "../types.js";
+export default function transformParameterObject(parameterObject: ParameterObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/parameter-object.js b/package/dist/transform/parameter-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..112fb125abd03c0d7d2b5cda42bf0db5a49f8389
--- /dev/null
+++ b/package/dist/transform/parameter-object.js
@@ -0,0 +1,6 @@
+import { STRING } from "../lib/ts.js";
+import transformSchemaObject from "./schema-object.js";
+export default function transformParameterObject(parameterObject, options) {
+    return parameterObject.schema ? transformSchemaObject(parameterObject.schema, options) : STRING;
+}
+//# sourceMappingURL=parameter-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/parameter-object.js.map b/package/dist/transform/parameter-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..21b286390ff2a6f81b4306e79278b8d874ab64ca
--- /dev/null
+++ b/package/dist/transform/parameter-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"parameter-object.js","sourceRoot":"","sources":["../../src/transform/parameter-object.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;AAEtC,OAAO,qBAAqB,MAAM,oBAAoB,CAAC;AAMvD,MAAM,CAAC,OAAO,UAAU,wBAAwB,CAC9C,eAAgC,EAChC,OAA6B;IAE7B,OAAO,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,qBAAqB,CAAC,eAAe,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;AAClG,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/parameters-array.d.ts b/package/dist/transform/parameters-array.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6d3d1d26639986155678becb40899e753312ba7
--- /dev/null
+++ b/package/dist/transform/parameters-array.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { ParameterObject, ReferenceObject, TransformNodeOptions } from "../types.js";
+export declare function transformParametersArray(parametersArray: (ParameterObject | ReferenceObject)[], options: TransformNodeOptions): ts.TypeElement[];
diff --git a/package/dist/transform/parameters-array.js b/package/dist/transform/parameters-array.js
new file mode 100644
index 0000000000000000000000000000000000000000..ed51d2f32c7fb3ae1bf48edb534beeac22526574
--- /dev/null
+++ b/package/dist/transform/parameters-array.js
@@ -0,0 +1,80 @@
+import ts from "typescript";
+import { NEVER, QUESTION_TOKEN, addJSDocComment, oapiRef, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef } from "../lib/utils.js";
+import transformParameterObject from "./parameter-object.js";
+const PATH_PARAM_RE = /\{([^}]+)\}/g;
+function createPathParameter(paramName) {
+    return {
+        name: paramName,
+        in: "path",
+        required: true,
+        schema: { type: "string" },
+    };
+}
+function extractPathParamsFromUrl(path) {
+    const params = [];
+    const matches = path.match(PATH_PARAM_RE);
+    if (matches) {
+        for (const match of matches) {
+            const paramName = match.slice(1, -1);
+            params.push(createPathParameter(paramName));
+        }
+    }
+    return params;
+}
+export function transformParametersArray(parametersArray, options) {
+    const type = [];
+    const workingParameters = [...parametersArray];
+    if (options.ctx.generatePathParams && options.path) {
+        const pathString = Array.isArray(options.path) ? options.path[0] : options.path;
+        if (typeof pathString === "string") {
+            const pathParams = extractPathParamsFromUrl(pathString);
+            for (const param of pathParams) {
+                const exists = workingParameters.some((p) => {
+                    const resolved = "$ref" in p ? options.ctx.resolve(p.$ref) : p;
+                    return resolved?.in === "path" && resolved?.name === param.name;
+                });
+                if (!exists) {
+                    workingParameters.push(param);
+                }
+            }
+        }
+    }
+    const paramType = [];
+    for (const paramIn of ["query", "header", "path", "cookie"]) {
+        const paramLocType = [];
+        let operationParameters = workingParameters.map((param) => ({
+            original: param,
+            resolved: "$ref" in param ? options.ctx.resolve(param.$ref) : param,
+        }));
+        if (options.ctx.alphabetize) {
+            operationParameters.sort((a, b) => (a.resolved?.name ?? "").localeCompare(b.resolved?.name ?? ""));
+        }
+        if (options.ctx.excludeDeprecated) {
+            operationParameters = operationParameters.filter(({ resolved }) => !resolved?.deprecated && !resolved?.schema?.deprecated);
+        }
+        for (const { original, resolved } of operationParameters) {
+            if (resolved?.in !== paramIn) {
+                continue;
+            }
+            let optional = undefined;
+            if (paramIn !== "path" && !resolved.required) {
+                optional = QUESTION_TOKEN;
+            }
+            const subType = "$ref" in original
+                ? oapiRef(original.$ref)
+                : transformParameterObject(resolved, {
+                    ...options,
+                    path: createRef([options.path, "parameters", resolved.in, resolved.name]),
+                });
+            const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(resolved?.name), optional, subType);
+            addJSDocComment(resolved, property);
+            paramLocType.push(property);
+        }
+        const allOptional = paramLocType.every((node) => !!node.questionToken);
+        paramType.push(ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(paramIn), allOptional || !paramLocType.length ? QUESTION_TOKEN : undefined, paramLocType.length ? ts.factory.createTypeLiteralNode(paramLocType) : NEVER));
+    }
+    type.push(ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex("parameters"), !paramType.length ? QUESTION_TOKEN : undefined, paramType.length ? ts.factory.createTypeLiteralNode(paramType) : NEVER));
+    return type;
+}
+//# sourceMappingURL=parameters-array.js.map
\ No newline at end of file
diff --git a/package/dist/transform/parameters-array.js.map b/package/dist/transform/parameters-array.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..2defd352db5e597a9354aab71896037d1df89627
--- /dev/null
+++ b/package/dist/transform/parameters-array.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"parameters-array.js","sourceRoot":"","sources":["../../src/transform/parameters-array.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/path-item-object.d.ts b/package/dist/transform/path-item-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e330caebe2df3f6120883d9ce78d14eb16ccfb06
--- /dev/null
+++ b/package/dist/transform/path-item-object.d.ts
@@ -0,0 +1,4 @@
+import ts from "typescript";
+import type { PathItemObject, TransformNodeOptions } from "../types.js";
+export type Method = "get" | "put" | "post" | "delete" | "options" | "head" | "patch" | "trace";
+export default function transformPathItemObject(pathItem: PathItemObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/path-item-object.js b/package/dist/transform/path-item-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..b51258b816192f3c357de5dcf5e4aeb401516f98
--- /dev/null
+++ b/package/dist/transform/path-item-object.js
@@ -0,0 +1,51 @@
+import ts from "typescript";
+import { NEVER, QUESTION_TOKEN, addJSDocComment, oapiRef, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef } from "../lib/utils.js";
+import transformOperationObject, { injectOperationObject } from "./operation-object.js";
+import { transformParametersArray } from "./parameters-array.js";
+export default function transformPathItemObject(pathItem, options) {
+    const type = [];
+    type.push(...transformParametersArray(pathItem.parameters ?? [], {
+        ...options,
+        path: createRef([options.path, "parameters"]),
+    }));
+    for (const method of ["get", "put", "post", "delete", "options", "head", "patch", "trace"]) {
+        const operationObject = pathItem[method];
+        if (!operationObject ||
+            (options.ctx.excludeDeprecated &&
+                ("$ref" in operationObject ? options.ctx.resolve(operationObject.$ref) : operationObject)
+                    ?.deprecated)) {
+            type.push(ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(method), QUESTION_TOKEN, NEVER));
+            continue;
+        }
+        const keyedParameters = {};
+        if (!("$ref" in operationObject)) {
+            for (const parameter of [...(pathItem.parameters ?? []), ...(operationObject.parameters ?? [])]) {
+                const name = "$ref" in parameter
+                    ? `${options.ctx.resolve(parameter.$ref)?.in}-${options.ctx.resolve(parameter.$ref)?.name}`
+                    : `${parameter.in}-${parameter.name}`;
+                if (name) {
+                    keyedParameters[name] = parameter;
+                }
+            }
+        }
+        let operationType;
+        if ("$ref" in operationObject) {
+            operationType = oapiRef(operationObject.$ref);
+        }
+        else if (operationObject.operationId) {
+            const operationId = operationObject.operationId.replace(HASH_RE, "/");
+            operationType = oapiRef(createRef(["operations", operationId]));
+            injectOperationObject(operationId, { ...operationObject, parameters: Object.values(keyedParameters) }, { ...options, path: createRef([options.path, method]) });
+        }
+        else {
+            operationType = ts.factory.createTypeLiteralNode(transformOperationObject({ ...operationObject, parameters: Object.values(keyedParameters) }, { ...options, path: createRef([options.path, method]) }));
+        }
+        const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(method), undefined, operationType);
+        addJSDocComment(operationObject, property);
+        type.push(property);
+    }
+    return ts.factory.createTypeLiteralNode(type);
+}
+const HASH_RE = /#/g;
+//# sourceMappingURL=path-item-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/path-item-object.js.map b/package/dist/transform/path-item-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..157372e89af06f4867b30e0b4be12849b155aebc
--- /dev/null
+++ b/package/dist/transform/path-item-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"path-item-object.js","sourceRoot":"","sources":["../../src/transform/path-item-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/paths-enum.d.ts b/package/dist/transform/paths-enum.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..700e7bb6076fc7a0b94980adc003fd2e25109611
--- /dev/null
+++ b/package/dist/transform/paths-enum.d.ts
@@ -0,0 +1,3 @@
+import type ts from "typescript";
+import type { PathsObject } from "../types.js";
+export default function makeApiPathsEnum(pathsObject: PathsObject): ts.EnumDeclaration;
diff --git a/package/dist/transform/paths-enum.js b/package/dist/transform/paths-enum.js
new file mode 100644
index 0000000000000000000000000000000000000000..d4a3362d33bd35430a062245bff721703b65f81f
--- /dev/null
+++ b/package/dist/transform/paths-enum.js
@@ -0,0 +1,35 @@
+import { tsEnum } from "../lib/ts.js";
+import { getEntries } from "../lib/utils.js";
+export default function makeApiPathsEnum(pathsObject) {
+    const enumKeys = [];
+    const enumMetaData = [];
+    for (const [url, pathItemObject] of getEntries(pathsObject)) {
+        for (const [method, operation] of Object.entries(pathItemObject)) {
+            if (!["get", "put", "post", "delete", "options", "head", "patch", "trace"].includes(method)) {
+                continue;
+            }
+            let pathName;
+            if (operation.operationId) {
+                pathName = operation.operationId;
+            }
+            else {
+                pathName = (method + url)
+                    .split("/")
+                    .map((part) => {
+                    const capitalised = part.charAt(0).toUpperCase() + part.slice(1);
+                    return capitalised.replace(/{.*}|:.*|[^a-zA-Z\d_]+/, "");
+                })
+                    .join("");
+            }
+            const adaptedUrl = url.replace(/{(\w+)}/g, ":$1");
+            enumKeys.push(adaptedUrl);
+            enumMetaData.push({
+                name: pathName,
+            });
+        }
+    }
+    return tsEnum("ApiPaths", enumKeys, enumMetaData, {
+        export: true,
+    });
+}
+//# sourceMappingURL=paths-enum.js.map
\ No newline at end of file
diff --git a/package/dist/transform/paths-enum.js.map b/package/dist/transform/paths-enum.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..507e308ddc3d0e11ba544a125e938a34596ea48e
--- /dev/null
+++ b/package/dist/transform/paths-enum.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"paths-enum.js","sourceRoot":"","sources":["../../src/transform/paths-enum.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;AACtC,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAG7C,MAAM,CAAC,OAAO,UAAU,gBAAgB,CAAC,WAAwB;IAC/D,MAAM,QAAQ,GAAG,EAAE,CAAC;IACpB,MAAM,YAAY,GAAG,EAAE,CAAC;IAExB,KAAK,MAAM,CAAC,GAAG,EAAE,cAAc,CAAC,IAAI,UAAU,CAAC,WAAW,CAAC,EAAE,CAAC;QAC5D,KAAK,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC;YACjE,IAAI,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;gBAC5F,SAAS;YACX,CAAC;YAGD,IAAI,QAAgB,CAAC;YACrB,IAAI,SAAS,CAAC,WAAW,EAAE,CAAC;gBAC1B,QAAQ,GAAG,SAAS,CAAC,WAAW,CAAC;YACnC,CAAC;iBAAM,CAAC;gBAEN,QAAQ,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC;qBACtB,KAAK,CAAC,GAAG,CAAC;qBACV,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;oBACZ,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBAIjE,OAAO,WAAW,CAAC,OAAO,CAAC,wBAAwB,EAAE,EAAE,CAAC,CAAC;gBAC3D,CAAC,CAAC;qBACD,IAAI,CAAC,EAAE,CAAC,CAAC;YACd,CAAC;YAGD,MAAM,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YAElD,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC1B,YAAY,CAAC,IAAI,CAAC;gBAChB,IAAI,EAAE,QAAQ;aACf,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED,OAAO,MAAM,CAAC,UAAU,EAAE,QAAQ,EAAE,YAAY,EAAE;QAChD,MAAM,EAAE,IAAI;KACb,CAAC,CAAC;AACL,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/paths-object.d.ts b/package/dist/transform/paths-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b623adf4d5c7da9b46f4371e7072ba85802724ad
--- /dev/null
+++ b/package/dist/transform/paths-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { GlobalContext, PathsObject } from "../types.js";
+export default function transformPathsObject(pathsObject: PathsObject, ctx: GlobalContext): ts.TypeNode;
diff --git a/package/dist/transform/paths-object.js b/package/dist/transform/paths-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..32afe59ed21f0794b10599979872e037f5e5c063
--- /dev/null
+++ b/package/dist/transform/paths-object.js
@@ -0,0 +1,86 @@
+import ts from "typescript";
+import { performance } from "node:perf_hooks";
+import { addJSDocComment, oapiRef, stringToAST, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef, debug, getEntries } from "../lib/utils.js";
+import transformPathItemObject from "./path-item-object.js";
+const PATH_PARAM_RE = /\{[^}]+\}/g;
+export default function transformPathsObject(pathsObject, ctx) {
+    const type = [];
+    for (const [url, pathItemObject] of getEntries(pathsObject, ctx)) {
+        if (!pathItemObject || typeof pathItemObject !== "object") {
+            continue;
+        }
+        const pathT = performance.now();
+        if ("$ref" in pathItemObject) {
+            const property = ts.factory.createPropertySignature(tsModifiers({ readonly: ctx.immutable }), tsPropertyIndex(url), undefined, oapiRef(pathItemObject.$ref));
+            addJSDocComment(pathItemObject, property);
+            type.push(property);
+        }
+        else {
+            const pathItemType = transformPathItemObject(pathItemObject, {
+                path: createRef(["paths", url]),
+                ctx,
+            });
+            if (ctx.pathParamsAsTypes && url.includes("{")) {
+                const pathParams = extractPathParams(pathItemObject, ctx);
+                const matches = url.match(PATH_PARAM_RE);
+                let rawPath = `\`${url}\``;
+                if (matches) {
+                    for (const match of matches) {
+                        const paramName = match.slice(1, -1);
+                        const param = pathParams[paramName];
+                        switch (param?.schema?.type) {
+                            case "number":
+                            case "integer":
+                                rawPath = rawPath.replace(match, "${number}");
+                                break;
+                            case "boolean":
+                                rawPath = rawPath.replace(match, "${boolean}");
+                                break;
+                            default:
+                                rawPath = rawPath.replace(match, "${string}");
+                                break;
+                        }
+                    }
+                    const pathType = stringToAST(rawPath)[0]?.expression;
+                    if (pathType) {
+                        type.push(ts.factory.createIndexSignature(tsModifiers({ readonly: ctx.immutable }), [
+                            ts.factory.createParameterDeclaration(undefined, undefined, "path", undefined, pathType, undefined),
+                        ], pathItemType));
+                        continue;
+                    }
+                }
+            }
+            type.push(ts.factory.createPropertySignature(tsModifiers({ readonly: ctx.immutable }), tsPropertyIndex(url), undefined, pathItemType));
+            debug(`Transformed path "${url}"`, "ts", performance.now() - pathT);
+        }
+    }
+    return ts.factory.createTypeLiteralNode(type);
+}
+function extractPathParams(pathItemObject, ctx) {
+    const params = {};
+    for (const p of pathItemObject.parameters ?? []) {
+        const resolved = "$ref" in p && p.$ref ? ctx.resolve(p.$ref) : p;
+        if (resolved && resolved.in === "path") {
+            params[resolved.name] = resolved;
+        }
+    }
+    for (const method of ["get", "put", "post", "delete", "options", "head", "patch", "trace"]) {
+        if (!(method in pathItemObject)) {
+            continue;
+        }
+        const resolvedMethod = pathItemObject[method].$ref
+            ? ctx.resolve(pathItemObject[method].$ref)
+            : pathItemObject[method];
+        if (resolvedMethod?.parameters) {
+            for (const p of resolvedMethod.parameters) {
+                const resolvedParam = "$ref" in p && p.$ref ? ctx.resolve(p.$ref) : p;
+                if (resolvedParam && resolvedParam.in === "path") {
+                    params[resolvedParam.name] = resolvedParam;
+                }
+            }
+        }
+    }
+    return params;
+}
+//# sourceMappingURL=paths-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/paths-object.js.map b/package/dist/transform/paths-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..9cc98a29a66c074ea496518bbe22404ce1d71068
--- /dev/null
+++ b/package/dist/transform/paths-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"paths-object.js","sourceRoot":"","sources":["../../src/transform/paths-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/request-body-object.d.ts b/package/dist/transform/request-body-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..78ba3e87926b34a1f9f32c3184cccd7924b3c257
--- /dev/null
+++ b/package/dist/transform/request-body-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { RequestBodyObject, TransformNodeOptions } from "../types.js";
+export default function transformRequestBodyObject(requestBodyObject: RequestBodyObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/request-body-object.js b/package/dist/transform/request-body-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..71b18fe99525aec345cf8b47842466d498944f95
--- /dev/null
+++ b/package/dist/transform/request-body-object.js
@@ -0,0 +1,32 @@
+import ts from "typescript";
+import { NEVER, QUESTION_TOKEN, addJSDocComment, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef, getEntries } from "../lib/utils.js";
+import transformMediaTypeObject from "./media-type-object.js";
+import transformSchemaObject from "./schema-object.js";
+export default function transformRequestBodyObject(requestBodyObject, options) {
+    const type = [];
+    for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {
+        const nextPath = createRef([options.path, contentType]);
+        const mediaType = "$ref" in mediaTypeObject
+            ? transformSchemaObject(mediaTypeObject, {
+                ...options,
+                path: nextPath,
+            })
+            : transformMediaTypeObject(mediaTypeObject, {
+                ...options,
+                path: nextPath,
+            });
+        const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(contentType), undefined, mediaType);
+        addJSDocComment(mediaTypeObject, property);
+        type.push(property);
+    }
+    return ts.factory.createTypeLiteralNode([
+        ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex("content"), undefined, ts.factory.createTypeLiteralNode(type.length
+            ? type
+            :
+                [
+                    ts.factory.createPropertySignature(undefined, tsPropertyIndex("*/*"), QUESTION_TOKEN, NEVER),
+                ])),
+    ]);
+}
+//# sourceMappingURL=request-body-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/request-body-object.js.map b/package/dist/transform/request-body-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..d258b8f890fa6bfc7c04c14402069809df8b9839
--- /dev/null
+++ b/package/dist/transform/request-body-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"request-body-object.js","sourceRoot":"","sources":["../../src/transform/request-body-object.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,YAAY,CAAC;AAC5B,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,eAAe,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AACpG,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAExD,OAAO,wBAAwB,MAAM,wBAAwB,CAAC;AAC9D,OAAO,qBAAqB,MAAM,oBAAoB,CAAC;AAMvD,MAAM,CAAC,OAAO,UAAU,0BAA0B,CAChD,iBAAoC,EACpC,OAA6B;IAE7B,MAAM,IAAI,GAAqB,EAAE,CAAC;IAClC,KAAK,MAAM,CAAC,WAAW,EAAE,eAAe,CAAC,IAAI,UAAU,CAAC,iBAAiB,CAAC,OAAO,IAAI,EAAE,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;QACtG,MAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC,CAAC;QACxD,MAAM,SAAS,GACb,MAAM,IAAI,eAAe;YACvB,CAAC,CAAC,qBAAqB,CAAC,eAAe,EAAE;gBACrC,GAAG,OAAO;gBACV,IAAI,EAAE,QAAQ;aACf,CAAC;YACJ,CAAC,CAAC,wBAAwB,CAAC,eAAe,EAAE;gBACxC,GAAG,OAAO;gBACV,IAAI,EAAE,QAAQ;aACf,CAAC,CAAC;QACT,MAAM,QAAQ,GAAG,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAC7B,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,WAAW,CAAC,EAC5B,SAAS,EACT,SAAS,CAC9B,CAAC;QACF,eAAe,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;QAC3C,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtB,CAAC;IAED,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC;QACtC,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACZ,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,SAAS,CAAC,EAC1B,SAAS,EACT,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAClD,IAAI,CAAC,MAAM;YACT,CAAC,CAAC,IAAI;YACN,CAAC;gBACC;oBACE,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACZ,SAAS,EACT,eAAe,CAAC,KAAK,CAAC,EACtB,cAAc,EACd,KAAK,CAC1B;iBACF,CACN,CACF;KACF,CAAC,CAAC;AACL,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/response-object.d.ts b/package/dist/transform/response-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a285ccf966cfabe6a3a2c5e26bdc29dd004803b5
--- /dev/null
+++ b/package/dist/transform/response-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { ResponseObject, TransformNodeOptions } from "../types.js";
+export default function transformResponseObject(responseObject: ResponseObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/response-object.js b/package/dist/transform/response-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..d16bb7ad730656f4d632c286aec7a830ed6eedf4
--- /dev/null
+++ b/package/dist/transform/response-object.js
@@ -0,0 +1,45 @@
+import ts from "typescript";
+import { NEVER, QUESTION_TOKEN, STRING, UNKNOWN, addJSDocComment, oapiRef, tsModifiers, tsPropertyIndex, } from "../lib/ts.js";
+import { createRef, getEntries } from "../lib/utils.js";
+import transformHeaderObject from "./header-object.js";
+import transformMediaTypeObject from "./media-type-object.js";
+export default function transformResponseObject(responseObject, options) {
+    const type = [];
+    const headersObject = [];
+    if (responseObject.headers) {
+        for (const [name, headerObject] of getEntries(responseObject.headers, options.ctx)) {
+            const optional = "$ref" in headerObject || headerObject.required ? undefined : QUESTION_TOKEN;
+            const subType = "$ref" in headerObject
+                ? oapiRef(headerObject.$ref)
+                : transformHeaderObject(headerObject, {
+                    ...options,
+                    path: createRef([options.path, "headers", name]),
+                });
+            const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(name), optional, subType);
+            addJSDocComment(headerObject, property);
+            headersObject.push(property);
+        }
+    }
+    headersObject.push(ts.factory.createIndexSignature(tsModifiers({ readonly: options.ctx.immutable }), [
+        ts.factory.createParameterDeclaration(undefined, undefined, ts.factory.createIdentifier("name"), undefined, STRING),
+    ], UNKNOWN));
+    type.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex("headers"), undefined, ts.factory.createTypeLiteralNode(headersObject)));
+    const contentObject = [];
+    if (responseObject.content) {
+        for (const [contentType, mediaTypeObject] of getEntries(responseObject.content ?? {}, options.ctx)) {
+            const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(contentType), undefined, transformMediaTypeObject(mediaTypeObject, {
+                ...options,
+                path: createRef([options.path, "content", contentType]),
+            }));
+            contentObject.push(property);
+        }
+    }
+    if (contentObject.length) {
+        type.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex("content"), undefined, ts.factory.createTypeLiteralNode(contentObject)));
+    }
+    else {
+        type.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex("content"), QUESTION_TOKEN, NEVER));
+    }
+    return ts.factory.createTypeLiteralNode(type);
+}
+//# sourceMappingURL=response-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/response-object.js.map b/package/dist/transform/response-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..c097c23d02649a25b59a7a261670e55dbc3e0811
--- /dev/null
+++ b/package/dist/transform/response-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"response-object.js","sourceRoot":"","sources":["../../src/transform/response-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/responses-object.d.ts b/package/dist/transform/responses-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..858eb915359176fcfacbfa143d594301e3fefe75
--- /dev/null
+++ b/package/dist/transform/responses-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { ResponsesObject, TransformNodeOptions } from "../types.js";
+export default function transformResponsesObject(responsesObject: ResponsesObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/responses-object.js b/package/dist/transform/responses-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..750b9d4b7e219096fea6b19a6f9ab1a6e1384d41
--- /dev/null
+++ b/package/dist/transform/responses-object.js
@@ -0,0 +1,20 @@
+import ts from "typescript";
+import { NEVER, addJSDocComment, tsModifiers, oapiRef, tsPropertyIndex } from "../lib/ts.js";
+import { createRef, getEntries } from "../lib/utils.js";
+import transformResponseObject from "./response-object.js";
+export default function transformResponsesObject(responsesObject, options) {
+    const type = [];
+    for (const [responseCode, responseObject] of getEntries(responsesObject, options.ctx)) {
+        const responseType = "$ref" in responseObject
+            ? oapiRef(responseObject.$ref)
+            : transformResponseObject(responseObject, {
+                ...options,
+                path: createRef([options.path, "responses", responseCode]),
+            });
+        const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(responseCode), undefined, responseType);
+        addJSDocComment(responseObject, property);
+        type.push(property);
+    }
+    return type.length ? ts.factory.createTypeLiteralNode(type) : NEVER;
+}
+//# sourceMappingURL=responses-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/responses-object.js.map b/package/dist/transform/responses-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..9b7ebcec5ebbf4f420ac57c8010e9d0989f21b56
--- /dev/null
+++ b/package/dist/transform/responses-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"responses-object.js","sourceRoot":"","sources":["../../src/transform/responses-object.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,YAAY,CAAC;AAC5B,OAAO,EAAE,KAAK,EAAE,eAAe,EAAE,WAAW,EAAE,OAAO,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAC7F,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAExD,OAAO,uBAAuB,MAAM,sBAAsB,CAAC;AAM3D,MAAM,CAAC,OAAO,UAAU,wBAAwB,CAC9C,eAAgC,EAChC,OAA6B;IAE7B,MAAM,IAAI,GAAqB,EAAE,CAAC;IAElC,KAAK,MAAM,CAAC,YAAY,EAAE,cAAc,CAAC,IAAI,UAAU,CAAC,eAAe,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;QACtF,MAAM,YAAY,GAChB,MAAM,IAAI,cAAc;YACtB,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC;YAC9B,CAAC,CAAC,uBAAuB,CAAC,cAAc,EAAE;gBACtC,GAAG,OAAO;gBACV,IAAI,EAAE,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC;aAC3D,CAAC,CAAC;QACT,MAAM,QAAQ,GAAG,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAC7B,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,YAAY,CAAC,EAC7B,SAAS,EACT,YAAY,CACjC,CAAC;QACF,eAAe,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;QAC1C,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtB,CAAC;IAED,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;AACtE,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/schema-object.d.ts b/package/dist/transform/schema-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3ed4d3e2191184a9c5338f8163a894b91dc4a5a6
--- /dev/null
+++ b/package/dist/transform/schema-object.d.ts
@@ -0,0 +1,4 @@
+import ts from "typescript";
+import type { ReferenceObject, SchemaObject, TransformNodeOptions } from "../types.js";
+export default function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
+export declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/schema-object.js b/package/dist/transform/schema-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..10d3271239348b81ea21763c56af076dd9077076
--- /dev/null
+++ b/package/dist/transform/schema-object.js
@@ -0,0 +1,363 @@
+import { parseRef } from "@redocly/openapi-core/lib/ref-utils.js";
+import ts from "typescript";
+import { BOOLEAN, NEVER, NULL, NUMBER, QUESTION_TOKEN, STRING, UNDEFINED, UNKNOWN, addJSDocComment, oapiRef, tsArrayLiteralExpression, tsEnum, tsIntersection, tsIsPrimitive, tsLiteral, tsModifiers, tsNullable, tsPropertyIndex, tsRecord, tsUnion, tsWithRequired, } from "../lib/ts.js";
+import { createDiscriminatorProperty, createRef, getEntries } from "../lib/utils.js";
+export default function transformSchemaObject(schemaObject, options) {
+    const type = transformSchemaObjectWithComposition(schemaObject, options);
+    if (typeof options.ctx.postTransform === "function") {
+        const postTransformResult = options.ctx.postTransform(type, options);
+        if (postTransformResult) {
+            return postTransformResult;
+        }
+    }
+    return type;
+}
+export function transformSchemaObjectWithComposition(schemaObject, options) {
+    if (!schemaObject) {
+        return NEVER;
+    }
+    if (schemaObject === true) {
+        return UNKNOWN;
+    }
+    if (Array.isArray(schemaObject) || typeof schemaObject !== "object") {
+        throw new Error(`Expected SchemaObject, received ${Array.isArray(schemaObject) ? "Array" : typeof schemaObject} at ${options.path}`);
+    }
+    if ("$ref" in schemaObject) {
+        return oapiRef(schemaObject.$ref);
+    }
+    if (schemaObject.const !== null && schemaObject.const !== undefined) {
+        return tsLiteral(schemaObject.const);
+    }
+    if (Array.isArray(schemaObject.enum) &&
+        (!("type" in schemaObject) || schemaObject.type !== "object") &&
+        !("properties" in schemaObject) &&
+        !("additionalProperties" in schemaObject)) {
+        if (options.ctx.enum &&
+            schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number" || v === null)) {
+            let enumName = parseRef(options.path ?? "").pointer.join("/");
+            enumName = enumName.replace("components/schemas", "");
+            const metadata = schemaObject.enum.map((_, i) => ({
+                name: schemaObject["x-enum-varnames"]?.[i] ?? schemaObject["x-enumNames"]?.[i],
+                description: schemaObject["x-enum-descriptions"]?.[i] ?? schemaObject["x-enumDescriptions"]?.[i],
+            }));
+            let hasNull = false;
+            const validSchemaEnums = schemaObject.enum.filter((enumValue) => {
+                if (enumValue === null) {
+                    hasNull = true;
+                    return false;
+                }
+                return true;
+            });
+            const enumType = tsEnum(enumName, validSchemaEnums, metadata, {
+                shouldCache: options.ctx.dedupeEnums,
+                export: true,
+            });
+            if (!options.ctx.injectFooter.includes(enumType)) {
+                options.ctx.injectFooter.push(enumType);
+            }
+            const ref = ts.factory.createTypeReferenceNode(enumType.name);
+            return hasNull ? tsUnion([ref, NULL]) : ref;
+        }
+        const enumType = schemaObject.enum.map(tsLiteral);
+        if (((Array.isArray(schemaObject.type) && schemaObject.type.includes("null")) || schemaObject.nullable) &&
+            !schemaObject.default) {
+            enumType.push(NULL);
+        }
+        const unionType = tsUnion(enumType);
+        if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number")) {
+            let enumValuesVariableName = parseRef(options.path ?? "").pointer.join("/");
+            enumValuesVariableName = enumValuesVariableName.replace("components/schemas", "");
+            enumValuesVariableName = `${enumValuesVariableName}Values`;
+            const enumValuesArray = tsArrayLiteralExpression(enumValuesVariableName, oapiRef(options.path ?? ""), schemaObject.enum, {
+                export: true,
+                readonly: true,
+                injectFooter: options.ctx.injectFooter,
+            });
+            options.ctx.injectFooter.push(enumValuesArray);
+        }
+        return unionType;
+    }
+    function collectUnionCompositions(items) {
+        const output = [];
+        for (const item of items) {
+            output.push(transformSchemaObject(item, options));
+        }
+        return output;
+    }
+    function collectAllOfCompositions(items, required) {
+        const output = [];
+        for (const item of items) {
+            let itemType;
+            if ("$ref" in item) {
+                itemType = transformSchemaObject(item, options);
+                const resolved = options.ctx.resolve(item.$ref);
+                if (resolved &&
+                    typeof resolved === "object" &&
+                    "properties" in resolved &&
+                    !options.ctx.discriminators.refsHandled.includes(item.$ref)) {
+                    const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);
+                    if (validRequired.length) {
+                        itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);
+                    }
+                }
+            }
+            else {
+                const itemRequired = [...(required ?? [])];
+                if (typeof item === "object" && Array.isArray(item.required)) {
+                    itemRequired.push(...item.required);
+                }
+                itemType = transformSchemaObject({ ...item, required: itemRequired }, options);
+            }
+            output.push(itemType);
+        }
+        return output;
+    }
+    let finalType = undefined;
+    const coreObjectType = transformSchemaObjectCore(schemaObject, options);
+    const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);
+    if (coreObjectType || allOfType.length) {
+        const allOf = allOfType.length ? tsIntersection(allOfType) : undefined;
+        finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);
+    }
+    const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);
+    if (anyOfType.length) {
+        finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);
+    }
+    const oneOfType = collectUnionCompositions(schemaObject.oneOf ||
+        ("type" in schemaObject &&
+            schemaObject.type === "object" &&
+            schemaObject.enum) ||
+        []);
+    if (oneOfType.length) {
+        if (oneOfType.every(tsIsPrimitive)) {
+            finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);
+        }
+        else {
+            finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);
+        }
+    }
+    if (!finalType) {
+        if ("type" in schemaObject) {
+            finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);
+        }
+        else {
+            finalType = UNKNOWN;
+        }
+    }
+    if (finalType !== UNKNOWN && schemaObject.nullable && !schemaObject.default) {
+        finalType = tsNullable([finalType]);
+    }
+    return finalType;
+}
+function transformSchemaObjectCore(schemaObject, options) {
+    if ("type" in schemaObject && schemaObject.type) {
+        if (typeof options.ctx.transform === "function") {
+            const result = options.ctx.transform(schemaObject, options);
+            if (result && typeof result === "object") {
+                if ("schema" in result) {
+                    if (result.questionToken) {
+                        return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);
+                    }
+                    else {
+                        return result.schema;
+                    }
+                }
+                else {
+                    return result;
+                }
+            }
+        }
+        if (schemaObject.type === "null") {
+            return NULL;
+        }
+        if (schemaObject.type === "string") {
+            return STRING;
+        }
+        if (schemaObject.type === "number" || schemaObject.type === "integer") {
+            return NUMBER;
+        }
+        if (schemaObject.type === "boolean") {
+            return BOOLEAN;
+        }
+        if (schemaObject.type === "array") {
+            let itemType = UNKNOWN;
+            if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {
+                const prefixItems = schemaObject.prefixItems ?? schemaObject.items;
+                itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));
+            }
+            else if (schemaObject.items) {
+                if ("type" in schemaObject.items && schemaObject.items.type === "array") {
+                    itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));
+                }
+                else {
+                    itemType = transformSchemaObject(schemaObject.items, options);
+                }
+            }
+            const min = typeof schemaObject.minItems === "number" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;
+            const max = typeof schemaObject.maxItems === "number" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems
+                ? schemaObject.maxItems
+                : undefined;
+            const estimateCodeSize = typeof max !== "number" ? min : (max * (max + 1) - min * (min - 1)) / 2;
+            if (options.ctx.arrayLength &&
+                (min !== 0 || max !== undefined) &&
+                estimateCodeSize < 30) {
+                if (min === max) {
+                    const elements = [];
+                    for (let i = 0; i < min; i++) {
+                        elements.push(itemType);
+                    }
+                    return tsUnion([ts.factory.createTupleTypeNode(elements)]);
+                }
+                else if (schemaObject.maxItems > 0) {
+                    const members = [];
+                    for (let i = 0; i <= (max ?? 0) - min; i++) {
+                        const elements = [];
+                        for (let j = min; j < i + min; j++) {
+                            elements.push(itemType);
+                        }
+                        members.push(ts.factory.createTupleTypeNode(elements));
+                    }
+                    return tsUnion(members);
+                }
+                else {
+                    const elements = [];
+                    for (let i = 0; i < min; i++) {
+                        elements.push(itemType);
+                    }
+                    elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));
+                    return ts.factory.createTupleTypeNode(elements);
+                }
+            }
+            const finalType = ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)
+                ? itemType
+                : ts.factory.createArrayTypeNode(itemType);
+            return options.ctx.immutable
+                ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)
+                : finalType;
+        }
+        if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {
+            const uniqueTypes = [];
+            if (Array.isArray(schemaObject.oneOf)) {
+                for (const t of schemaObject.type) {
+                    if ((t === "boolean" || t === "string" || t === "number" || t === "integer" || t === "null") &&
+                        schemaObject.oneOf.find((o) => typeof o === "object" && "type" in o && o.type === t)) {
+                        continue;
+                    }
+                    uniqueTypes.push(t === "null" || t === null
+                        ? NULL
+                        : transformSchemaObject({ ...schemaObject, type: t, oneOf: undefined }, options));
+                }
+            }
+            else {
+                for (const t of schemaObject.type) {
+                    if (t === "null" || t === null) {
+                        if (!schemaObject.default) {
+                            uniqueTypes.push(NULL);
+                        }
+                    }
+                    else {
+                        uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t }, options));
+                    }
+                }
+            }
+            return tsUnion(uniqueTypes);
+        }
+    }
+    const coreObjectType = [];
+    for (const k of ["allOf", "anyOf"]) {
+        if (!schemaObject[k]) {
+            continue;
+        }
+        const discriminator = !schemaObject.discriminator &&
+            !options.ctx.discriminators.refsHandled.includes(options.path ?? "") &&
+            options.ctx.discriminators.objects[options.path ?? ""];
+        if (discriminator) {
+            coreObjectType.unshift(createDiscriminatorProperty(discriminator, {
+                path: options.path ?? "",
+                readonly: options.ctx.immutable,
+            }));
+            break;
+        }
+    }
+    if (("properties" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||
+        ("additionalProperties" in schemaObject && schemaObject.additionalProperties) ||
+        ("$defs" in schemaObject && schemaObject.$defs)) {
+        if (Object.keys(schemaObject.properties ?? {}).length) {
+            for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {
+                if (typeof v !== "object" || Array.isArray(v)) {
+                    throw new Error(`${options.path}: invalid property ${k}. Expected Schema Object, got ${Array.isArray(v) ? "Array" : typeof v}`);
+                }
+                if (options.ctx.excludeDeprecated) {
+                    const resolved = "$ref" in v ? options.ctx.resolve(v.$ref) : v;
+                    if (resolved?.deprecated) {
+                        continue;
+                    }
+                }
+                let optional = schemaObject.required?.includes(k) ||
+                    (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||
+                    ("default" in v &&
+                        options.ctx.defaultNonNullable &&
+                        !options.path?.includes("parameters") &&
+                        !options.path?.includes("requestBody") &&
+                        !options.path?.includes("requestBodies"))
+                    ? undefined
+                    : QUESTION_TOKEN;
+                let type = "$ref" in v
+                    ? oapiRef(v.$ref)
+                    : transformSchemaObject(v, {
+                        ...options,
+                        path: createRef([options.path, k]),
+                    });
+                if (typeof options.ctx.transform === "function") {
+                    const result = options.ctx.transform(v, options);
+                    if (result && typeof result === "object") {
+                        if ("schema" in result) {
+                            type = result.schema;
+                            optional = result.questionToken ? QUESTION_TOKEN : optional;
+                        }
+                        else {
+                            type = result;
+                        }
+                    }
+                }
+                const property = ts.factory.createPropertySignature(tsModifiers({
+                    readonly: options.ctx.immutable || ("readOnly" in v && !!v.readOnly),
+                }), tsPropertyIndex(k), optional, type);
+                addJSDocComment(v, property);
+                coreObjectType.push(property);
+            }
+        }
+        if (schemaObject.$defs && typeof schemaObject.$defs === "object" && Object.keys(schemaObject.$defs).length) {
+            const defKeys = [];
+            for (const [k, v] of Object.entries(schemaObject.$defs)) {
+                const property = ts.factory.createPropertySignature(tsModifiers({
+                    readonly: options.ctx.immutable || ("readonly" in v && !!v.readOnly),
+                }), tsPropertyIndex(k), undefined, transformSchemaObject(v, {
+                    ...options,
+                    path: createRef([options.path, "$defs", k]),
+                }));
+                addJSDocComment(v, property);
+                defKeys.push(property);
+            }
+            coreObjectType.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex("$defs"), undefined, ts.factory.createTypeLiteralNode(defKeys)));
+        }
+        if (schemaObject.additionalProperties || options.ctx.additionalProperties) {
+            const hasExplicitAdditionalProperties = typeof schemaObject.additionalProperties === "object" && Object.keys(schemaObject.additionalProperties).length;
+            const addlType = hasExplicitAdditionalProperties
+                ? transformSchemaObject(schemaObject.additionalProperties, options)
+                : UNKNOWN;
+            return tsIntersection([
+                ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),
+                ts.factory.createTypeLiteralNode([
+                    ts.factory.createIndexSignature(tsModifiers({
+                        readonly: options.ctx.immutable,
+                    }), [
+                        ts.factory.createParameterDeclaration(undefined, undefined, ts.factory.createIdentifier("key"), undefined, STRING),
+                    ], addlType),
+                ]),
+            ]);
+        }
+    }
+    return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;
+}
+//# sourceMappingURL=schema-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/schema-object.js.map b/package/dist/transform/schema-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..fbe11e11385076d2f4f0cf2e54fc616eec061420
--- /dev/null
+++ b/package/dist/transform/schema-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"schema-object.js","sourceRoot":"","sources":["../../src/transform/schema-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/webhooks-object.d.ts b/package/dist/transform/webhooks-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..12cd2a4868227e4c4ab4dae316ef193e00d52568
--- /dev/null
+++ b/package/dist/transform/webhooks-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { GlobalContext, WebhooksObject } from "../types.js";
+export default function transformWebhooksObject(webhooksObject: WebhooksObject, options: GlobalContext): ts.TypeNode;
diff --git a/package/dist/transform/webhooks-object.js b/package/dist/transform/webhooks-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..3f2848200b31d4858e1cc0b391511536b070cd8d
--- /dev/null
+++ b/package/dist/transform/webhooks-object.js
@@ -0,0 +1,17 @@
+import ts from "typescript";
+import { tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef, getEntries } from "../lib/utils.js";
+import transformPathItemObject from "./path-item-object.js";
+export default function transformWebhooksObject(webhooksObject, options) {
+    const type = [];
+    for (const [name, pathItemObject] of getEntries(webhooksObject, options)) {
+        type.push(ts.factory.createPropertySignature(tsModifiers({
+            readonly: options.immutable,
+        }), tsPropertyIndex(name), undefined, transformPathItemObject(pathItemObject, {
+            path: createRef(["webhooks", name]),
+            ctx: options,
+        })));
+    }
+    return ts.factory.createTypeLiteralNode(type);
+}
+//# sourceMappingURL=webhooks-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/webhooks-object.js.map b/package/dist/transform/webhooks-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..e3c7c4f9663e5b14cbdf0072c8cd928f2d3b969f
--- /dev/null
+++ b/package/dist/transform/webhooks-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"webhooks-object.js","sourceRoot":"","sources":["../../src/transform/webhooks-object.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,YAAY,CAAC;AAC5B,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAC5D,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAExD,OAAO,uBAAuB,MAAM,uBAAuB,CAAC;AAE5D,MAAM,CAAC,OAAO,UAAU,uBAAuB,CAAC,cAA8B,EAAE,OAAsB;IACpG,MAAM,IAAI,GAAqB,EAAE,CAAC;IAElC,KAAK,MAAM,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,UAAU,CAAC,cAAc,EAAE,OAAO,CAAC,EAAE,CAAC;QACzE,IAAI,CAAC,IAAI,CACP,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACZ,WAAW,CAAC;YAC9B,QAAQ,EAAE,OAAO,CAAC,SAAS;SAC5B,CAAC,EACkB,eAAe,CAAC,IAAI,CAAC,EACrB,SAAS,EACT,uBAAuB,CAAC,cAAc,EAAE;YAC1D,IAAI,EAAE,SAAS,CAAC,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;YACnC,GAAG,EAAE,OAAO;SACb,CAAC,CACH,CACF,CAAC;IACJ,CAAC;IAED,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;AAChD,CAAC"}
\ No newline at end of file
diff --git a/package/dist/types.d.ts b/package/dist/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c08afb1fda3b04cca96e9ff887a7f5336fa6b087
--- /dev/null
+++ b/package/dist/types.d.ts
@@ -0,0 +1,372 @@
+import type { Config as RedoclyConfig } from "@redocly/openapi-core";
+import type { PathLike } from "node:fs";
+import type ts from "typescript";
+export interface Extensable {
+    [key: `x-${string}`]: any;
+}
+export interface OpenAPI3 extends Extensable {
+    openapi: string;
+    info: InfoObject;
+    jsonSchemaDialect?: string;
+    servers?: ServerObject[];
+    paths?: PathsObject;
+    webhooks?: {
+        [id: string]: PathItemObject | ReferenceObject;
+    };
+    components?: ComponentsObject;
+    security?: SecurityRequirementObject[];
+    tags?: TagObject[];
+    externalDocs?: ExternalDocumentationObject;
+    $defs?: $defs;
+}
+export interface InfoObject extends Extensable {
+    title: string;
+    summary?: string;
+    description?: string;
+    termsOfService?: string;
+    contact?: ContactObject;
+    license?: LicenseObject;
+    version: string;
+}
+export interface ContactObject extends Extensable {
+    name?: string;
+    url?: string;
+    email?: string;
+}
+export interface LicenseObject extends Extensable {
+    name: string;
+    identifier: string;
+    url: string;
+}
+export interface ServerObject extends Extensable {
+    url: string;
+    description: string;
+    variables: {
+        [name: string]: ServerVariableObject;
+    };
+}
+export interface ServerVariableObject extends Extensable {
+    enum?: string[];
+    default: string;
+    description?: string;
+}
+export interface ComponentsObject extends Extensable {
+    schemas?: Record<string, SchemaObject>;
+    responses?: Record<string, ResponseObject | ReferenceObject>;
+    parameters?: Record<string, ParameterObject | ReferenceObject>;
+    examples?: Record<string, ExampleObject | ReferenceObject>;
+    requestBodies?: Record<string, RequestBodyObject | ReferenceObject>;
+    headers?: Record<string, HeaderObject | ReferenceObject>;
+    securitySchemes?: Record<string, SecuritySchemeObject | ReferenceObject>;
+    links?: Record<string, LinkObject | ReferenceObject>;
+    callbacks?: Record<string, CallbackObject | ReferenceObject>;
+    pathItems?: Record<string, PathItemObject | ReferenceObject>;
+}
+export interface PathsObject {
+    [pathname: string]: PathItemObject | ReferenceObject;
+}
+export interface WebhooksObject {
+    [name: string]: PathItemObject;
+}
+export interface PathItemObject extends Extensable {
+    get?: OperationObject | ReferenceObject;
+    put?: OperationObject | ReferenceObject;
+    post?: OperationObject | ReferenceObject;
+    delete?: OperationObject | ReferenceObject;
+    options?: OperationObject | ReferenceObject;
+    head?: OperationObject | ReferenceObject;
+    patch?: OperationObject | ReferenceObject;
+    trace?: OperationObject | ReferenceObject;
+    servers?: ServerObject[];
+    parameters?: (ParameterObject | ReferenceObject)[];
+}
+export interface OperationObject extends Extensable {
+    tags?: string[];
+    summary?: string;
+    description?: string;
+    externalDocs?: ExternalDocumentationObject;
+    operationId?: string;
+    parameters?: (ParameterObject | ReferenceObject)[];
+    requestBody?: RequestBodyObject | ReferenceObject;
+    responses?: ResponsesObject;
+    callbacks?: Record<string, CallbackObject | ReferenceObject>;
+    deprecated?: boolean;
+    security?: SecurityRequirementObject[];
+    servers?: ServerObject[];
+}
+export interface ExternalDocumentationObject extends Extensable {
+    description?: string;
+    url: string;
+}
+export interface ParameterObject extends Extensable {
+    name: string;
+    in: "query" | "header" | "path" | "cookie";
+    description?: string;
+    required?: boolean;
+    deprecated?: boolean;
+    allowEmptyValue?: boolean;
+    style?: string;
+    explode?: boolean;
+    allowReserved?: boolean;
+    schema?: SchemaObject;
+    example?: any;
+    examples?: {
+        [name: string]: ExampleObject | ReferenceObject;
+    };
+    content?: {
+        [contentType: string]: MediaTypeObject | ReferenceObject;
+    };
+}
+export interface RequestBodyObject extends Extensable {
+    description?: string;
+    content: {
+        [contentType: string]: MediaTypeObject | ReferenceObject;
+    };
+    required?: boolean;
+}
+export interface MediaTypeObject extends Extensable {
+    schema?: SchemaObject | ReferenceObject;
+    example?: any;
+    examples?: {
+        [name: string]: ExampleObject | ReferenceObject;
+    };
+    encoding?: {
+        [propertyName: string]: EncodingObject;
+    };
+}
+export interface EncodingObject extends Extensable {
+    contentType?: string;
+    headers?: {
+        [name: string]: HeaderObject | ReferenceObject;
+    };
+    style?: string;
+    explode?: string;
+    allowReserved?: string;
+}
+export type ResponsesObject = {
+    [responseCode: string]: ResponseObject | ReferenceObject;
+} & {
+    default?: ResponseObject | ReferenceObject;
+};
+export interface ResponseObject extends Extensable {
+    description: string;
+    headers?: {
+        [name: string]: HeaderObject | ReferenceObject;
+    };
+    content?: {
+        [contentType: string]: MediaTypeObject;
+    };
+    links?: {
+        [name: string]: LinkObject | ReferenceObject;
+    };
+}
+export type CallbackObject = Record<string, PathItemObject>;
+export interface ExampleObject extends Extensable {
+    summary?: string;
+    description?: string;
+    value?: any;
+    externalValue?: string;
+}
+export interface LinkObject extends Extensable {
+    operationRef?: string;
+    operationId?: string;
+    parameters?: {
+        [name: string]: `$${string}`;
+    };
+    requestBody?: `$${string}`;
+    description?: string;
+    server?: ServerObject;
+}
+export type HeaderObject = Omit<ParameterObject, "name" | "in">;
+export interface TagObject extends Extensable {
+    name: string;
+    description?: string;
+    externalDocs?: ExternalDocumentationObject;
+}
+export interface ReferenceObject extends Extensable {
+    $ref: string;
+    summary?: string;
+    description?: string;
+}
+export type SchemaObject = {
+    discriminator?: DiscriminatorObject;
+    xml?: XMLObject;
+    externalDocs?: ExternalDocumentationObject;
+    example?: any;
+    title?: string;
+    description?: string;
+    $comment?: string;
+    deprecated?: boolean;
+    readOnly?: boolean;
+    writeOnly?: boolean;
+    enum?: unknown[];
+    const?: unknown;
+    default?: unknown;
+    format?: string;
+    nullable?: boolean;
+    oneOf?: (SchemaObject | ReferenceObject)[];
+    allOf?: (SchemaObject | ReferenceObject)[];
+    anyOf?: (SchemaObject | ReferenceObject)[];
+    required?: string[];
+    [key: `x-${string}`]: any;
+} & (StringSubtype | NumberSubtype | IntegerSubtype | ArraySubtype | BooleanSubtype | NullSubtype | ObjectSubtype | {
+    type: ("string" | "number" | "integer" | "array" | "boolean" | "null" | "object")[];
+});
+export interface TransformObject {
+    schema: ts.TypeNode;
+    questionToken: boolean;
+}
+export interface StringSubtype {
+    type: "string" | ["string", "null"];
+    enum?: (string | ReferenceObject)[];
+}
+export interface NumberSubtype {
+    type: "number" | ["number", "null"];
+    minimum?: number;
+    maximum?: number;
+    enum?: (number | ReferenceObject)[];
+}
+export interface IntegerSubtype {
+    type: "integer" | ["integer", "null"];
+    minimum?: number;
+    maximum?: number;
+    enum?: (number | ReferenceObject)[];
+}
+export interface ArraySubtype {
+    type: "array" | ["array", "null"];
+    prefixItems?: (SchemaObject | ReferenceObject)[];
+    items?: SchemaObject | ReferenceObject | (SchemaObject | ReferenceObject)[];
+    minItems?: number;
+    maxItems?: number;
+    enum?: (SchemaObject | ReferenceObject)[];
+}
+export interface BooleanSubtype {
+    type: "boolean" | ["boolean", "null"];
+    enum?: (boolean | ReferenceObject)[];
+}
+export interface NullSubtype {
+    type: "null";
+}
+export interface ObjectSubtype {
+    type: "object" | ["object", "null"];
+    properties?: {
+        [name: string]: SchemaObject | ReferenceObject;
+    };
+    additionalProperties?: boolean | Record<string, never> | SchemaObject | ReferenceObject;
+    required?: string[];
+    allOf?: (SchemaObject | ReferenceObject)[];
+    anyOf?: (SchemaObject | ReferenceObject)[];
+    enum?: (SchemaObject | ReferenceObject)[];
+    $defs?: $defs;
+}
+export interface DiscriminatorObject {
+    propertyName: string;
+    mapping?: Record<string, string>;
+    oneOf?: string[];
+}
+export interface XMLObject extends Extensable {
+    name?: string;
+    namespace?: string;
+    prefix?: string;
+    attribute?: boolean;
+    wrapped?: boolean;
+}
+export type SecuritySchemeObject = {
+    description?: string;
+    [key: `x-${string}`]: any;
+} & ({
+    type: "apiKey";
+    name: string;
+    in: "query" | "header" | "cookie";
+} | {
+    type: "http";
+    scheme: string;
+    bearer?: string;
+} | {
+    type: "mutualTLS";
+} | {
+    type: "oauth2";
+    flows: OAuthFlowsObject;
+} | {
+    type: "openIdConnect";
+    openIdConnectUrl: string;
+});
+export interface OAuthFlowsObject extends Extensable {
+    implicit?: OAuthFlowObject;
+    password?: OAuthFlowObject;
+    clientCredentials?: OAuthFlowObject;
+    authorizationCode?: OAuthFlowObject;
+}
+export interface OAuthFlowObject extends Extensable {
+    authorizationUrl: string;
+    tokenUrl: string;
+    refreshUrl: string;
+    scopes: {
+        [name: string]: string;
+    };
+}
+export type SecurityRequirementObject = {
+    [P in keyof ComponentsObject["securitySchemes"]]?: string[];
+};
+export interface OpenAPITSOptions {
+    additionalProperties?: boolean;
+    alphabetize?: boolean;
+    arrayLength?: boolean;
+    emptyObjectsUnknown?: boolean;
+    cwd?: PathLike;
+    defaultNonNullable?: boolean;
+    excludeDeprecated?: boolean;
+    transform?: (schemaObject: SchemaObject, options: TransformNodeOptions) => ts.TypeNode | TransformObject | undefined;
+    postTransform?: (type: ts.TypeNode, options: TransformNodeOptions) => ts.TypeNode | undefined;
+    immutable?: boolean;
+    silent?: boolean;
+    version?: number;
+    exportType?: boolean;
+    enum?: boolean;
+    enumValues?: boolean;
+    dedupeEnums?: boolean;
+    pathParamsAsTypes?: boolean;
+    propertiesRequiredByDefault?: boolean;
+    rootTypes?: boolean;
+    rootTypesNoSchemaPrefix?: boolean;
+    redocly?: RedoclyConfig;
+    inject?: string;
+    makePathsEnum?: boolean;
+    generatePathParams?: boolean;
+}
+export interface GlobalContext {
+    additionalProperties: boolean;
+    alphabetize: boolean;
+    arrayLength: boolean;
+    defaultNonNullable: boolean;
+    discriminators: {
+        objects: Record<string, DiscriminatorObject>;
+        refsHandled: string[];
+    };
+    emptyObjectsUnknown: boolean;
+    enum: boolean;
+    enumValues: boolean;
+    dedupeEnums: boolean;
+    excludeDeprecated: boolean;
+    exportType: boolean;
+    immutable: boolean;
+    injectFooter: ts.Node[];
+    pathParamsAsTypes: boolean;
+    postTransform: OpenAPITSOptions["postTransform"];
+    propertiesRequiredByDefault: boolean;
+    rootTypes: boolean;
+    rootTypesNoSchemaPrefix: boolean;
+    redoc: RedoclyConfig;
+    silent: boolean;
+    transform: OpenAPITSOptions["transform"];
+    resolve<T>($ref: string): T | undefined;
+    inject?: string;
+    makePathsEnum: boolean;
+    generatePathParams: boolean;
+}
+export type $defs = Record<string, SchemaObject>;
+export interface TransformNodeOptions {
+    path?: string;
+    schema?: SchemaObject | ReferenceObject;
+    ctx: GlobalContext;
+}
diff --git a/package/dist/types.js b/package/dist/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..718fd38ae40c67ea23b242517cf9919f602c5a3e
--- /dev/null
+++ b/package/dist/types.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/package/dist/types.js.map b/package/dist/types.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..c768b79002615c0e69cc6efdcad6a509c1abaaec
--- /dev/null
+++ b/package/dist/types.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/src/transform/schema-object.ts b/src/transform/schema-object.ts
index 9c572512609561a144786b8f8773342e9499cdfb..fd7b0b9cbd9f289831496c2ded7b1be10dca38bc 100644
--- a/src/transform/schema-object.ts
+++ b/src/transform/schema-object.ts
@@ -18,7 +18,6 @@ import {
   tsLiteral,
   tsModifiers,
   tsNullable,
-  tsOmit,
   tsPropertyIndex,
   tsRecord,
   tsUnion,
@@ -210,13 +209,7 @@ export function transformSchemaObjectWithComposition(
         itemType = transformSchemaObject({ ...item, required: itemRequired }, options);
       }
 
-      const discriminator =
-        ("$ref" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;
-      if (discriminator) {
-        output.push(tsOmit(itemType, [discriminator.propertyName]));
-      } else {
-        output.push(itemType);
-      }
+      output.push(itemType);
     }
     return output;
   }
