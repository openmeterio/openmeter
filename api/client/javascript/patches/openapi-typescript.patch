diff --git a/dist/index.cjs.map b/dist/index.cjs.map
index 90e8135c064a2001546ae11cec6799d3e502f773..06e4138d8be0f83246debf495d05354f8bc023c0 100644
--- a/dist/index.cjs.map
+++ b/dist/index.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport type { Readable } from \"node:stream\";\nimport { createConfig } from \"@redocly/openapi-core\";\nimport type ts from \"typescript\";\nimport { validateAndBundle } from \"./lib/redoc.js\";\nimport { debug, resolveRef, scanDiscriminators } from \"./lib/utils.js\";\nimport transformSchema from \"./transform/index.js\";\nimport type { GlobalContext, OpenAPI3, OpenAPITSOptions } from \"./types.js\";\n\nexport * from \"./lib/ts.js\";\nexport * from \"./lib/utils.js\";\nexport { default as transformComponentsObject } from \"./transform/components-object.js\";\nexport { default as transformHeaderObject } from \"./transform/header-object.js\";\nexport { default as transformSchema } from \"./transform/index.js\";\nexport { default as transformMediaTypeObject } from \"./transform/media-type-object.js\";\nexport * from \"./transform/operation-object.js\";\nexport { default as transformOperationObject } from \"./transform/operation-object.js\";\nexport { default as transformParameterObject } from \"./transform/parameter-object.js\";\nexport * from \"./transform/path-item-object.js\";\nexport { default as transformPathItemObject } from \"./transform/path-item-object.js\";\nexport { default as transformPathsObject } from \"./transform/paths-object.js\";\nexport { default as transformRequestBodyObject } from \"./transform/request-body-object.js\";\nexport { default as transformResponseObject } from \"./transform/response-object.js\";\nexport { default as transformResponsesObject } from \"./transform/responses-object.js\";\nexport * from \"./transform/schema-object.js\";\nexport { default as transformSchemaObject } from \"./transform/schema-object.js\";\nexport * from \"./types.js\";\n\nexport const COMMENT_HEADER = `/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n`;\n\n/**\n * Convert an OpenAPI schema to TypesScript AST\n * @param {string|URL|object|Readable} source OpenAPI schema source:\n *   - YAML: string\n *   - JSON: parsed object\n *   - URL: URL to a YAML or JSON file (local or remote)\n *   - Readable: Readable stream of YAML or JSON\n */\nexport default async function openapiTS(\n  source: string | URL | OpenAPI3 | Buffer | Readable,\n  options: OpenAPITSOptions = {} as Partial<OpenAPITSOptions>,\n): Promise<ts.Node[]> {\n  if (!source) {\n    throw new Error(\"Empty schema. Please specify a URL, file path, or Redocly Config\");\n  }\n\n  const redoc =\n    options.redocly ??\n    (await createConfig(\n      {\n        rules: {\n          \"operation-operationId-unique\": { severity: \"error\" }, // throw error on duplicate operationIDs\n        },\n      },\n      { extends: [\"minimal\"] },\n    ));\n\n  const schema = await validateAndBundle(source, {\n    redoc,\n    cwd: options.cwd instanceof URL ? options.cwd : new URL(`file://${options.cwd ?? process.cwd()}/`),\n    silent: options.silent ?? false,\n  });\n\n  const ctx: GlobalContext = {\n    additionalProperties: options.additionalProperties ?? false,\n    alphabetize: options.alphabetize ?? false,\n    arrayLength: options.arrayLength ?? false,\n    defaultNonNullable: options.defaultNonNullable ?? true,\n    discriminators: scanDiscriminators(schema, options),\n    emptyObjectsUnknown: options.emptyObjectsUnknown ?? false,\n    enum: options.enum ?? false,\n    enumValues: options.enumValues ?? false,\n    dedupeEnums: options.dedupeEnums ?? false,\n    excludeDeprecated: options.excludeDeprecated ?? false,\n    exportType: options.exportType ?? false,\n    immutable: options.immutable ?? false,\n    rootTypes: options.rootTypes ?? false,\n    rootTypesNoSchemaPrefix: options.rootTypesNoSchemaPrefix ?? false,\n    injectFooter: [],\n    pathParamsAsTypes: options.pathParamsAsTypes ?? false,\n    postTransform: typeof options.postTransform === \"function\" ? options.postTransform : undefined,\n    propertiesRequiredByDefault: options.propertiesRequiredByDefault ?? false,\n    redoc,\n    silent: options.silent ?? false,\n    inject: options.inject ?? undefined,\n    transform: typeof options.transform === \"function\" ? options.transform : undefined,\n    transformProperty: typeof options.transformProperty === \"function\" ? options.transformProperty : undefined,\n    makePathsEnum: options.makePathsEnum ?? false,\n    generatePathParams: options.generatePathParams ?? false,\n    resolve($ref) {\n      return resolveRef(schema, $ref, { silent: options.silent ?? false });\n    },\n  };\n\n  const transformT = performance.now();\n  const result = transformSchema(schema, ctx);\n  debug(\"Completed AST transformation for entire document\", \"ts\", performance.now() - transformT);\n\n  return result;\n}\n"],"names":["redoc","createConfig","validateAndBundle","scanDiscriminators","resolveRef","performance","transformSchema","debug"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport type { Readable } from \"node:stream\";\nimport { createConfig } from \"@redocly/openapi-core\";\nimport type ts from \"typescript\";\nimport { validateAndBundle } from \"./lib/redoc.js\";\nimport { debug, resolveRef, scanDiscriminators } from \"./lib/utils.js\";\nimport transformSchema from \"./transform/index.js\";\nimport type { GlobalContext, OpenAPI3, OpenAPITSOptions } from \"./types.js\";\n\nexport * from \"./lib/ts.js\";\nexport * from \"./lib/utils.js\";\nexport { default as transformComponentsObject } from \"./transform/components-object.js\";\nexport { default as transformHeaderObject } from \"./transform/header-object.js\";\nexport { default as transformSchema } from \"./transform/index.js\";\nexport { default as transformMediaTypeObject } from \"./transform/media-type-object.js\";\nexport * from \"./transform/operation-object.js\";\nexport { default as transformOperationObject } from \"./transform/operation-object.js\";\nexport { default as transformParameterObject } from \"./transform/parameter-object.js\";\nexport * from \"./transform/path-item-object.js\";\nexport { default as transformPathItemObject } from \"./transform/path-item-object.js\";\nexport { default as transformPathsObject } from \"./transform/paths-object.js\";\nexport { default as transformRequestBodyObject } from \"./transform/request-body-object.js\";\nexport { default as transformResponseObject } from \"./transform/response-object.js\";\nexport { default as transformResponsesObject } from \"./transform/responses-object.js\";\nexport * from \"./transform/schema-object.js\";\nexport { default as transformSchemaObject } from \"./transform/schema-object.js\";\nexport * from \"./types.js\";\n\nexport const COMMENT_HEADER = `/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n`;\n\n/**\n * Convert an OpenAPI schema to TypesScript AST\n * @param {string|URL|object|Readable} source OpenAPI schema source:\n *   - YAML: string\n *   - JSON: parsed object\n *   - URL: URL to a YAML or JSON file (local or remote)\n *   - Readable: Readable stream of YAML or JSON\n */\nexport default async function openapiTS(\n  source: string | URL | OpenAPI3 | Buffer | Readable,\n  options: OpenAPITSOptions = {} as Partial<OpenAPITSOptions>,\n): Promise<ts.Node[]> {\n  if (!source) {\n    throw new Error(\"Empty schema. Please specify a URL, file path, or Redocly Config\");\n  }\n\n  const redoc =\n    options.redocly ??\n    (await createConfig(\n      {\n        rules: {\n          \"operation-operationId-unique\": { severity: \"error\" }, // throw error on duplicate operationIDs\n        },\n      },\n      { extends: [\"minimal\"] },\n    ));\n\n  const schema = await validateAndBundle(source, {\n    redoc,\n    cwd: options.cwd instanceof URL ? options.cwd : new URL(`file://${options.cwd ?? process.cwd()}/`),\n    silent: options.silent ?? false,\n  });\n\n  const ctx: GlobalContext = {\n    additionalProperties: options.additionalProperties ?? false,\n    alphabetize: options.alphabetize ?? false,\n    arrayLength: options.arrayLength ?? false,\n    defaultNonNullable: options.defaultNonNullable ?? true,\n    discriminators: scanDiscriminators(schema, options),\n    emptyObjectsUnknown: options.emptyObjectsUnknown ?? false,\n    enum: options.enum ?? false,\n    enumValues: options.enumValues ?? false,\n    dedupeEnums: options.dedupeEnums ?? false,\n    excludeDeprecated: options.excludeDeprecated ?? false,\n    exportType: options.exportType ?? false,\n    immutable: options.immutable ?? false,\n    rootTypes: options.rootTypes ?? false,\n    rootTypesNoSchemaPrefix: options.rootTypesNoSchemaPrefix ?? false,\n    injectFooter: [],\n    pathParamsAsTypes: options.pathParamsAsTypes ?? false,\n    postTransform: typeof options.postTransform === \"function\" ? options.postTransform : undefined,\n    propertiesRequiredByDefault: options.propertiesRequiredByDefault ?? false,\n    redoc,\n    silent: options.silent ?? false,\n    inject: options.inject ?? undefined,\n    transform: typeof options.transform === \"function\" ? options.transform : undefined,\n    transformProperty: typeof options.transformProperty === \"function\" ? options.transformProperty : undefined,\n    makePathsEnum: options.makePathsEnum ?? false,\n    generatePathParams: options.generatePathParams ?? false,\n    resolve($ref) {\n      return resolveRef(schema, $ref, { silent: options.silent ?? false });\n    },\n  };\n\n  const transformT = performance.now();\n  const result = transformSchema(schema, ctx);\n  debug(\"Completed AST transformation for entire document\", \"ts\", performance.now() - transformT);\n\n  return result;\n}\n"],"names":["redoc","createConfig","validateAndBundle","scanDiscriminators","resolveRef","performance","transformSchema","debug"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/index.d.cts b/dist/index.d.cts
index 7574dccb07513b11366a8f5f92730f5987354e02..539bdd80864ab319e08da4bb46bf344b373220f1 100644
--- a/dist/index.d.cts
+++ b/dist/index.d.cts
@@ -407,7 +407,7 @@ interface AnnotatedSchemaObject {
 }
 declare function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void;
 type OapiRefResolved = Referenced<ParameterObject>;
-declare function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode;
+declare function oapiRef(path: string, resolved?: OapiRefResolved, deep?: boolean): ts.TypeNode;
 interface AstToStringOptions {
     fileName?: string;
     sourceText?: string;
@@ -495,8 +495,8 @@ declare function transformResponseObject(responseObject: ResponseObject, options
 
 declare function transformResponsesObject(responsesObject: ResponsesObject, options: TransformNodeOptions): ts.TypeNode;
 
-declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
-declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
+declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
+declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
 
 declare const COMMENT_HEADER = "/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n";
 declare function openapiTS(source: string | URL | OpenAPI3 | Buffer | Readable, options?: OpenAPITSOptions): Promise<ts.Node[]>;
diff --git a/dist/index.d.mts b/dist/index.d.mts
index e0eaea7b5812ad4efcaa838a945edc0c5fd6af77..e53f927efa14cd9adf1d3ae9db716e2b787e0233 100644
--- a/dist/index.d.mts
+++ b/dist/index.d.mts
@@ -407,7 +407,7 @@ interface AnnotatedSchemaObject {
 }
 declare function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void;
 type OapiRefResolved = Referenced<ParameterObject>;
-declare function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode;
+declare function oapiRef(path: string, resolved?: OapiRefResolved, deep?: boolean): ts.TypeNode;
 interface AstToStringOptions {
     fileName?: string;
     sourceText?: string;
@@ -495,8 +495,8 @@ declare function transformResponseObject(responseObject: ResponseObject, options
 
 declare function transformResponsesObject(responsesObject: ResponsesObject, options: TransformNodeOptions): ts.TypeNode;
 
-declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
-declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
+declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
+declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
 
 declare const COMMENT_HEADER = "/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n";
 declare function openapiTS(source: string | URL | OpenAPI3 | Buffer | Readable, options?: OpenAPITSOptions): Promise<ts.Node[]>;
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 7574dccb07513b11366a8f5f92730f5987354e02..539bdd80864ab319e08da4bb46bf344b373220f1 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -407,7 +407,7 @@ interface AnnotatedSchemaObject {
 }
 declare function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void;
 type OapiRefResolved = Referenced<ParameterObject>;
-declare function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode;
+declare function oapiRef(path: string, resolved?: OapiRefResolved, deep?: boolean): ts.TypeNode;
 interface AstToStringOptions {
     fileName?: string;
     sourceText?: string;
@@ -495,8 +495,8 @@ declare function transformResponseObject(responseObject: ResponseObject, options
 
 declare function transformResponsesObject(responsesObject: ResponsesObject, options: TransformNodeOptions): ts.TypeNode;
 
-declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
-declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
+declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
+declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
 
 declare const COMMENT_HEADER = "/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n";
 declare function openapiTS(source: string | URL | OpenAPI3 | Buffer | Readable, options?: OpenAPITSOptions): Promise<ts.Node[]>;
diff --git a/dist/index.mjs.map b/dist/index.mjs.map
index 964062295b5a943edc730d636155fe899d722b36..e869d3dc2a3a89d4192f06c4c90c9c14ae2bef08 100644
--- a/dist/index.mjs.map
+++ b/dist/index.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport type { Readable } from \"node:stream\";\nimport { createConfig } from \"@redocly/openapi-core\";\nimport type ts from \"typescript\";\nimport { validateAndBundle } from \"./lib/redoc.js\";\nimport { debug, resolveRef, scanDiscriminators } from \"./lib/utils.js\";\nimport transformSchema from \"./transform/index.js\";\nimport type { GlobalContext, OpenAPI3, OpenAPITSOptions } from \"./types.js\";\n\nexport * from \"./lib/ts.js\";\nexport * from \"./lib/utils.js\";\nexport { default as transformComponentsObject } from \"./transform/components-object.js\";\nexport { default as transformHeaderObject } from \"./transform/header-object.js\";\nexport { default as transformSchema } from \"./transform/index.js\";\nexport { default as transformMediaTypeObject } from \"./transform/media-type-object.js\";\nexport * from \"./transform/operation-object.js\";\nexport { default as transformOperationObject } from \"./transform/operation-object.js\";\nexport { default as transformParameterObject } from \"./transform/parameter-object.js\";\nexport * from \"./transform/path-item-object.js\";\nexport { default as transformPathItemObject } from \"./transform/path-item-object.js\";\nexport { default as transformPathsObject } from \"./transform/paths-object.js\";\nexport { default as transformRequestBodyObject } from \"./transform/request-body-object.js\";\nexport { default as transformResponseObject } from \"./transform/response-object.js\";\nexport { default as transformResponsesObject } from \"./transform/responses-object.js\";\nexport * from \"./transform/schema-object.js\";\nexport { default as transformSchemaObject } from \"./transform/schema-object.js\";\nexport * from \"./types.js\";\n\nexport const COMMENT_HEADER = `/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n`;\n\n/**\n * Convert an OpenAPI schema to TypesScript AST\n * @param {string|URL|object|Readable} source OpenAPI schema source:\n *   - YAML: string\n *   - JSON: parsed object\n *   - URL: URL to a YAML or JSON file (local or remote)\n *   - Readable: Readable stream of YAML or JSON\n */\nexport default async function openapiTS(\n  source: string | URL | OpenAPI3 | Buffer | Readable,\n  options: OpenAPITSOptions = {} as Partial<OpenAPITSOptions>,\n): Promise<ts.Node[]> {\n  if (!source) {\n    throw new Error(\"Empty schema. Please specify a URL, file path, or Redocly Config\");\n  }\n\n  const redoc =\n    options.redocly ??\n    (await createConfig(\n      {\n        rules: {\n          \"operation-operationId-unique\": { severity: \"error\" }, // throw error on duplicate operationIDs\n        },\n      },\n      { extends: [\"minimal\"] },\n    ));\n\n  const schema = await validateAndBundle(source, {\n    redoc,\n    cwd: options.cwd instanceof URL ? options.cwd : new URL(`file://${options.cwd ?? process.cwd()}/`),\n    silent: options.silent ?? false,\n  });\n\n  const ctx: GlobalContext = {\n    additionalProperties: options.additionalProperties ?? false,\n    alphabetize: options.alphabetize ?? false,\n    arrayLength: options.arrayLength ?? false,\n    defaultNonNullable: options.defaultNonNullable ?? true,\n    discriminators: scanDiscriminators(schema, options),\n    emptyObjectsUnknown: options.emptyObjectsUnknown ?? false,\n    enum: options.enum ?? false,\n    enumValues: options.enumValues ?? false,\n    dedupeEnums: options.dedupeEnums ?? false,\n    excludeDeprecated: options.excludeDeprecated ?? false,\n    exportType: options.exportType ?? false,\n    immutable: options.immutable ?? false,\n    rootTypes: options.rootTypes ?? false,\n    rootTypesNoSchemaPrefix: options.rootTypesNoSchemaPrefix ?? false,\n    injectFooter: [],\n    pathParamsAsTypes: options.pathParamsAsTypes ?? false,\n    postTransform: typeof options.postTransform === \"function\" ? options.postTransform : undefined,\n    propertiesRequiredByDefault: options.propertiesRequiredByDefault ?? false,\n    redoc,\n    silent: options.silent ?? false,\n    inject: options.inject ?? undefined,\n    transform: typeof options.transform === \"function\" ? options.transform : undefined,\n    transformProperty: typeof options.transformProperty === \"function\" ? options.transformProperty : undefined,\n    makePathsEnum: options.makePathsEnum ?? false,\n    generatePathParams: options.generatePathParams ?? false,\n    resolve($ref) {\n      return resolveRef(schema, $ref, { silent: options.silent ?? false });\n    },\n  };\n\n  const transformT = performance.now();\n  const result = transformSchema(schema, ctx);\n  debug(\"Completed AST transformation for entire document\", \"ts\", performance.now() - transformT);\n\n  return result;\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport type { Readable } from \"node:stream\";\nimport { createConfig } from \"@redocly/openapi-core\";\nimport type ts from \"typescript\";\nimport { validateAndBundle } from \"./lib/redoc.js\";\nimport { debug, resolveRef, scanDiscriminators } from \"./lib/utils.js\";\nimport transformSchema from \"./transform/index.js\";\nimport type { GlobalContext, OpenAPI3, OpenAPITSOptions } from \"./types.js\";\n\nexport * from \"./lib/ts.js\";\nexport * from \"./lib/utils.js\";\nexport { default as transformComponentsObject } from \"./transform/components-object.js\";\nexport { default as transformHeaderObject } from \"./transform/header-object.js\";\nexport { default as transformSchema } from \"./transform/index.js\";\nexport { default as transformMediaTypeObject } from \"./transform/media-type-object.js\";\nexport * from \"./transform/operation-object.js\";\nexport { default as transformOperationObject } from \"./transform/operation-object.js\";\nexport { default as transformParameterObject } from \"./transform/parameter-object.js\";\nexport * from \"./transform/path-item-object.js\";\nexport { default as transformPathItemObject } from \"./transform/path-item-object.js\";\nexport { default as transformPathsObject } from \"./transform/paths-object.js\";\nexport { default as transformRequestBodyObject } from \"./transform/request-body-object.js\";\nexport { default as transformResponseObject } from \"./transform/response-object.js\";\nexport { default as transformResponsesObject } from \"./transform/responses-object.js\";\nexport * from \"./transform/schema-object.js\";\nexport { default as transformSchemaObject } from \"./transform/schema-object.js\";\nexport * from \"./types.js\";\n\nexport const COMMENT_HEADER = `/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n`;\n\n/**\n * Convert an OpenAPI schema to TypesScript AST\n * @param {string|URL|object|Readable} source OpenAPI schema source:\n *   - YAML: string\n *   - JSON: parsed object\n *   - URL: URL to a YAML or JSON file (local or remote)\n *   - Readable: Readable stream of YAML or JSON\n */\nexport default async function openapiTS(\n  source: string | URL | OpenAPI3 | Buffer | Readable,\n  options: OpenAPITSOptions = {} as Partial<OpenAPITSOptions>,\n): Promise<ts.Node[]> {\n  if (!source) {\n    throw new Error(\"Empty schema. Please specify a URL, file path, or Redocly Config\");\n  }\n\n  const redoc =\n    options.redocly ??\n    (await createConfig(\n      {\n        rules: {\n          \"operation-operationId-unique\": { severity: \"error\" }, // throw error on duplicate operationIDs\n        },\n      },\n      { extends: [\"minimal\"] },\n    ));\n\n  const schema = await validateAndBundle(source, {\n    redoc,\n    cwd: options.cwd instanceof URL ? options.cwd : new URL(`file://${options.cwd ?? process.cwd()}/`),\n    silent: options.silent ?? false,\n  });\n\n  const ctx: GlobalContext = {\n    additionalProperties: options.additionalProperties ?? false,\n    alphabetize: options.alphabetize ?? false,\n    arrayLength: options.arrayLength ?? false,\n    defaultNonNullable: options.defaultNonNullable ?? true,\n    discriminators: scanDiscriminators(schema, options),\n    emptyObjectsUnknown: options.emptyObjectsUnknown ?? false,\n    enum: options.enum ?? false,\n    enumValues: options.enumValues ?? false,\n    dedupeEnums: options.dedupeEnums ?? false,\n    excludeDeprecated: options.excludeDeprecated ?? false,\n    exportType: options.exportType ?? false,\n    immutable: options.immutable ?? false,\n    rootTypes: options.rootTypes ?? false,\n    rootTypesNoSchemaPrefix: options.rootTypesNoSchemaPrefix ?? false,\n    injectFooter: [],\n    pathParamsAsTypes: options.pathParamsAsTypes ?? false,\n    postTransform: typeof options.postTransform === \"function\" ? options.postTransform : undefined,\n    propertiesRequiredByDefault: options.propertiesRequiredByDefault ?? false,\n    redoc,\n    silent: options.silent ?? false,\n    inject: options.inject ?? undefined,\n    transform: typeof options.transform === \"function\" ? options.transform : undefined,\n    transformProperty: typeof options.transformProperty === \"function\" ? options.transformProperty : undefined,\n    makePathsEnum: options.makePathsEnum ?? false,\n    generatePathParams: options.generatePathParams ?? false,\n    resolve($ref) {\n      return resolveRef(schema, $ref, { silent: options.silent ?? false });\n    },\n  };\n\n  const transformT = performance.now();\n  const result = transformSchema(schema, ctx);\n  debug(\"Completed AST transformation for entire document\", \"ts\", performance.now() - transformT);\n\n  return result;\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/lib/redoc.cjs.map b/dist/lib/redoc.cjs.map
index a2a2787140353f0c03c92da35ff821b38e8c63c1..58e029d34c204a4778645cbcfc8c6a921d498412 100644
--- a/dist/lib/redoc.cjs.map
+++ b/dist/lib/redoc.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"redoc.cjs","sources":["../../src/lib/redoc.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport { Readable } from \"node:stream\";\nimport { fileURLToPath } from \"node:url\";\nimport {\n  BaseResolver,\n  bundle,\n  type Document,\n  lintDocument,\n  makeDocumentFromString,\n  type NormalizedProblem,\n  type Config as RedoclyConfig,\n  Source,\n} from \"@redocly/openapi-core\";\nimport parseJson from \"parse-json\";\nimport type { OpenAPI3 } from \"../types.js\";\nimport { debug, error, warn } from \"./utils.js\";\n\nexport interface ValidateAndBundleOptions {\n  redoc: RedoclyConfig;\n  silent: boolean;\n  cwd?: URL;\n}\n\ninterface ParseSchemaOptions {\n  absoluteRef: string;\n  resolver: BaseResolver;\n}\n\nexport async function parseSchema(schema: unknown, { absoluteRef, resolver }: ParseSchemaOptions): Promise<Document> {\n  if (!schema) {\n    throw new Error(\"Can’t parse empty schema\");\n  }\n  if (schema instanceof URL) {\n    const result = await resolver.resolveDocument(null, absoluteRef, true);\n    if (\"parsed\" in result) {\n      return result;\n    }\n    throw result.originalError;\n  }\n  if (schema instanceof Readable) {\n    const contents = await new Promise<string>((resolve) => {\n      schema.resume();\n      schema.setEncoding(\"utf8\");\n      let content = \"\";\n      schema.on(\"data\", (chunk: string) => {\n        content += chunk;\n      });\n      schema.on(\"end\", () => {\n        resolve(content.trim());\n      });\n    });\n    return parseSchema(contents, { absoluteRef, resolver });\n  }\n  if (schema instanceof Buffer) {\n    return parseSchema(schema.toString(\"utf8\"), { absoluteRef, resolver });\n  }\n  if (typeof schema === \"string\") {\n    // URL\n    if (schema.startsWith(\"http://\") || schema.startsWith(\"https://\") || schema.startsWith(\"file://\")) {\n      const url = new URL(schema);\n      return parseSchema(url, {\n        absoluteRef: url.protocol === \"file:\" ? fileURLToPath(url) : url.href,\n        resolver,\n      });\n    }\n    // JSON\n    if (schema[0] === \"{\") {\n      return {\n        source: new Source(absoluteRef, schema, \"application/json\"),\n        parsed: parseJson(schema),\n      };\n    }\n    // YAML\n    return makeDocumentFromString(schema, absoluteRef);\n  }\n  if (typeof schema === \"object\" && !Array.isArray(schema)) {\n    return {\n      source: new Source(absoluteRef, JSON.stringify(schema), \"application/json\"),\n      parsed: schema,\n    };\n  }\n  throw new Error(`Expected string, object, or Buffer. Got ${Array.isArray(schema) ? \"Array\" : typeof schema}`);\n}\n\nfunction _processProblems(problems: NormalizedProblem[], options: { silent: boolean }) {\n  if (problems.length) {\n    let errorMessage: string | undefined = undefined;\n    for (const problem of problems) {\n      const problemLocation = problem.location?.[0].pointer;\n      const problemMessage = problemLocation ? `${problem.message} at ${problemLocation}` : problem.message;\n      if (problem.severity === \"error\") {\n        errorMessage = problemMessage;\n        error(problemMessage);\n      } else {\n        warn(problemMessage, options.silent);\n      }\n    }\n    if (errorMessage) {\n      throw new Error(errorMessage);\n    }\n  }\n}\n\n/**\n * Validate an OpenAPI schema and flatten into a single schema using Redocly CLI\n */\nexport async function validateAndBundle(\n  source: string | URL | OpenAPI3 | Readable | Buffer,\n  options: ValidateAndBundleOptions,\n) {\n  const redocConfigT = performance.now();\n  debug(\"Loaded Redoc config\", \"redoc\", performance.now() - redocConfigT);\n  const redocParseT = performance.now();\n  let absoluteRef = fileURLToPath(new URL(options?.cwd ?? `file://${process.cwd()}/`));\n  if (source instanceof URL) {\n    absoluteRef = source.protocol === \"file:\" ? fileURLToPath(source) : source.href;\n  }\n  const resolver = new BaseResolver(options.redoc.resolve);\n  const document = await parseSchema(source, {\n    absoluteRef,\n    resolver,\n  });\n  debug(\"Parsed schema\", \"redoc\", performance.now() - redocParseT);\n\n  // 1. check for OpenAPI 3 or greater\n  const openapiVersion = Number.parseFloat(document.parsed.openapi);\n  if (\n    document.parsed.swagger ||\n    !document.parsed.openapi ||\n    Number.isNaN(openapiVersion) ||\n    openapiVersion < 3 ||\n    openapiVersion >= 4\n  ) {\n    if (document.parsed.swagger) {\n      throw new Error(\"Unsupported Swagger version: 2.x. Use OpenAPI 3.x instead.\");\n    }\n    if (document.parsed.openapi || openapiVersion < 3 || openapiVersion >= 4) {\n      throw new Error(`Unsupported OpenAPI version: ${document.parsed.openapi}`);\n    }\n    throw new Error(\"Unsupported schema format, expected `openapi: 3.x`\");\n  }\n\n  // 2. lint\n  const redocLintT = performance.now();\n  const problems = await lintDocument({\n    document,\n    config: options.redoc.styleguide,\n    externalRefResolver: resolver,\n  });\n  _processProblems(problems, options);\n  debug(\"Linted schema\", \"lint\", performance.now() - redocLintT);\n\n  // 3. bundle\n  const redocBundleT = performance.now();\n  const bundled = await bundle({\n    config: options.redoc,\n    dereference: false,\n    doc: document,\n  });\n  _processProblems(bundled.problems, options);\n  debug(\"Bundled schema\", \"bundle\", performance.now() - redocBundleT);\n\n  return bundled.bundle.parsed;\n}\n"],"names":["Readable","fileURLToPath","Source","parseJson","makeDocumentFromString","error","warn","performance","debug","BaseResolver","lintDocument","bundle"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"redoc.cjs","sources":["../../src/lib/redoc.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport { Readable } from \"node:stream\";\nimport { fileURLToPath } from \"node:url\";\nimport {\n  BaseResolver,\n  bundle,\n  type Document,\n  lintDocument,\n  makeDocumentFromString,\n  type NormalizedProblem,\n  type Config as RedoclyConfig,\n  Source,\n} from \"@redocly/openapi-core\";\nimport parseJson from \"parse-json\";\nimport type { OpenAPI3 } from \"../types.js\";\nimport { debug, error, warn } from \"./utils.js\";\n\nexport interface ValidateAndBundleOptions {\n  redoc: RedoclyConfig;\n  silent: boolean;\n  cwd?: URL;\n}\n\ninterface ParseSchemaOptions {\n  absoluteRef: string;\n  resolver: BaseResolver;\n}\n\nexport async function parseSchema(schema: unknown, { absoluteRef, resolver }: ParseSchemaOptions): Promise<Document> {\n  if (!schema) {\n    throw new Error(\"Can’t parse empty schema\");\n  }\n  if (schema instanceof URL) {\n    const result = await resolver.resolveDocument(null, absoluteRef, true);\n    if (\"parsed\" in result) {\n      return result;\n    }\n    throw result.originalError;\n  }\n  if (schema instanceof Readable) {\n    const contents = await new Promise<string>((resolve) => {\n      schema.resume();\n      schema.setEncoding(\"utf8\");\n      let content = \"\";\n      schema.on(\"data\", (chunk: string) => {\n        content += chunk;\n      });\n      schema.on(\"end\", () => {\n        resolve(content.trim());\n      });\n    });\n    return parseSchema(contents, { absoluteRef, resolver });\n  }\n  if (schema instanceof Buffer) {\n    return parseSchema(schema.toString(\"utf8\"), { absoluteRef, resolver });\n  }\n  if (typeof schema === \"string\") {\n    // URL\n    if (schema.startsWith(\"http://\") || schema.startsWith(\"https://\") || schema.startsWith(\"file://\")) {\n      const url = new URL(schema);\n      return parseSchema(url, {\n        absoluteRef: url.protocol === \"file:\" ? fileURLToPath(url) : url.href,\n        resolver,\n      });\n    }\n    // JSON\n    if (schema[0] === \"{\") {\n      return {\n        source: new Source(absoluteRef, schema, \"application/json\"),\n        parsed: parseJson(schema),\n      };\n    }\n    // YAML\n    return makeDocumentFromString(schema, absoluteRef);\n  }\n  if (typeof schema === \"object\" && !Array.isArray(schema)) {\n    return {\n      source: new Source(absoluteRef, JSON.stringify(schema), \"application/json\"),\n      parsed: schema,\n    };\n  }\n  throw new Error(`Expected string, object, or Buffer. Got ${Array.isArray(schema) ? \"Array\" : typeof schema}`);\n}\n\nfunction _processProblems(problems: NormalizedProblem[], options: { silent: boolean }) {\n  if (problems.length) {\n    let errorMessage: string | undefined = undefined;\n    for (const problem of problems) {\n      const problemLocation = problem.location?.[0].pointer;\n      const problemMessage = problemLocation ? `${problem.message} at ${problemLocation}` : problem.message;\n      if (problem.severity === \"error\") {\n        errorMessage = problemMessage;\n        error(problemMessage);\n      } else {\n        warn(problemMessage, options.silent);\n      }\n    }\n    if (errorMessage) {\n      throw new Error(errorMessage);\n    }\n  }\n}\n\n/**\n * Validate an OpenAPI schema and flatten into a single schema using Redocly CLI\n */\nexport async function validateAndBundle(\n  source: string | URL | OpenAPI3 | Readable | Buffer,\n  options: ValidateAndBundleOptions,\n) {\n  const redocConfigT = performance.now();\n  debug(\"Loaded Redoc config\", \"redoc\", performance.now() - redocConfigT);\n  const redocParseT = performance.now();\n  let absoluteRef = fileURLToPath(new URL(options?.cwd ?? `file://${process.cwd()}/`));\n  if (source instanceof URL) {\n    absoluteRef = source.protocol === \"file:\" ? fileURLToPath(source) : source.href;\n  }\n  const resolver = new BaseResolver(options.redoc.resolve);\n  const document = await parseSchema(source, {\n    absoluteRef,\n    resolver,\n  });\n  debug(\"Parsed schema\", \"redoc\", performance.now() - redocParseT);\n\n  // 1. check for OpenAPI 3 or greater\n  const openapiVersion = Number.parseFloat(document.parsed.openapi);\n  if (\n    document.parsed.swagger ||\n    !document.parsed.openapi ||\n    Number.isNaN(openapiVersion) ||\n    openapiVersion < 3 ||\n    openapiVersion >= 4\n  ) {\n    if (document.parsed.swagger) {\n      throw new Error(\"Unsupported Swagger version: 2.x. Use OpenAPI 3.x instead.\");\n    }\n    if (document.parsed.openapi || openapiVersion < 3 || openapiVersion >= 4) {\n      throw new Error(`Unsupported OpenAPI version: ${document.parsed.openapi}`);\n    }\n    throw new Error(\"Unsupported schema format, expected `openapi: 3.x`\");\n  }\n\n  // 2. lint\n  const redocLintT = performance.now();\n  const problems = await lintDocument({\n    document,\n    config: options.redoc.styleguide,\n    externalRefResolver: resolver,\n  });\n  _processProblems(problems, options);\n  debug(\"Linted schema\", \"lint\", performance.now() - redocLintT);\n\n  // 3. bundle\n  const redocBundleT = performance.now();\n  const bundled = await bundle({\n    config: options.redoc,\n    dereference: false,\n    doc: document,\n  });\n  _processProblems(bundled.problems, options);\n  debug(\"Bundled schema\", \"bundle\", performance.now() - redocBundleT);\n\n  return bundled.bundle.parsed;\n}\n"],"names":["Readable","fileURLToPath","Source","parseJson","makeDocumentFromString","error","warn","performance","debug","BaseResolver","lintDocument","bundle"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/lib/redoc.mjs.map b/dist/lib/redoc.mjs.map
index 3128ca75d0205067f3410850e47b210dd7480311..bcf6103014f1916e96a4cfc36a8efa3a445cdd11 100644
--- a/dist/lib/redoc.mjs.map
+++ b/dist/lib/redoc.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"redoc.mjs","sources":["../../src/lib/redoc.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport { Readable } from \"node:stream\";\nimport { fileURLToPath } from \"node:url\";\nimport {\n  BaseResolver,\n  bundle,\n  type Document,\n  lintDocument,\n  makeDocumentFromString,\n  type NormalizedProblem,\n  type Config as RedoclyConfig,\n  Source,\n} from \"@redocly/openapi-core\";\nimport parseJson from \"parse-json\";\nimport type { OpenAPI3 } from \"../types.js\";\nimport { debug, error, warn } from \"./utils.js\";\n\nexport interface ValidateAndBundleOptions {\n  redoc: RedoclyConfig;\n  silent: boolean;\n  cwd?: URL;\n}\n\ninterface ParseSchemaOptions {\n  absoluteRef: string;\n  resolver: BaseResolver;\n}\n\nexport async function parseSchema(schema: unknown, { absoluteRef, resolver }: ParseSchemaOptions): Promise<Document> {\n  if (!schema) {\n    throw new Error(\"Can’t parse empty schema\");\n  }\n  if (schema instanceof URL) {\n    const result = await resolver.resolveDocument(null, absoluteRef, true);\n    if (\"parsed\" in result) {\n      return result;\n    }\n    throw result.originalError;\n  }\n  if (schema instanceof Readable) {\n    const contents = await new Promise<string>((resolve) => {\n      schema.resume();\n      schema.setEncoding(\"utf8\");\n      let content = \"\";\n      schema.on(\"data\", (chunk: string) => {\n        content += chunk;\n      });\n      schema.on(\"end\", () => {\n        resolve(content.trim());\n      });\n    });\n    return parseSchema(contents, { absoluteRef, resolver });\n  }\n  if (schema instanceof Buffer) {\n    return parseSchema(schema.toString(\"utf8\"), { absoluteRef, resolver });\n  }\n  if (typeof schema === \"string\") {\n    // URL\n    if (schema.startsWith(\"http://\") || schema.startsWith(\"https://\") || schema.startsWith(\"file://\")) {\n      const url = new URL(schema);\n      return parseSchema(url, {\n        absoluteRef: url.protocol === \"file:\" ? fileURLToPath(url) : url.href,\n        resolver,\n      });\n    }\n    // JSON\n    if (schema[0] === \"{\") {\n      return {\n        source: new Source(absoluteRef, schema, \"application/json\"),\n        parsed: parseJson(schema),\n      };\n    }\n    // YAML\n    return makeDocumentFromString(schema, absoluteRef);\n  }\n  if (typeof schema === \"object\" && !Array.isArray(schema)) {\n    return {\n      source: new Source(absoluteRef, JSON.stringify(schema), \"application/json\"),\n      parsed: schema,\n    };\n  }\n  throw new Error(`Expected string, object, or Buffer. Got ${Array.isArray(schema) ? \"Array\" : typeof schema}`);\n}\n\nfunction _processProblems(problems: NormalizedProblem[], options: { silent: boolean }) {\n  if (problems.length) {\n    let errorMessage: string | undefined = undefined;\n    for (const problem of problems) {\n      const problemLocation = problem.location?.[0].pointer;\n      const problemMessage = problemLocation ? `${problem.message} at ${problemLocation}` : problem.message;\n      if (problem.severity === \"error\") {\n        errorMessage = problemMessage;\n        error(problemMessage);\n      } else {\n        warn(problemMessage, options.silent);\n      }\n    }\n    if (errorMessage) {\n      throw new Error(errorMessage);\n    }\n  }\n}\n\n/**\n * Validate an OpenAPI schema and flatten into a single schema using Redocly CLI\n */\nexport async function validateAndBundle(\n  source: string | URL | OpenAPI3 | Readable | Buffer,\n  options: ValidateAndBundleOptions,\n) {\n  const redocConfigT = performance.now();\n  debug(\"Loaded Redoc config\", \"redoc\", performance.now() - redocConfigT);\n  const redocParseT = performance.now();\n  let absoluteRef = fileURLToPath(new URL(options?.cwd ?? `file://${process.cwd()}/`));\n  if (source instanceof URL) {\n    absoluteRef = source.protocol === \"file:\" ? fileURLToPath(source) : source.href;\n  }\n  const resolver = new BaseResolver(options.redoc.resolve);\n  const document = await parseSchema(source, {\n    absoluteRef,\n    resolver,\n  });\n  debug(\"Parsed schema\", \"redoc\", performance.now() - redocParseT);\n\n  // 1. check for OpenAPI 3 or greater\n  const openapiVersion = Number.parseFloat(document.parsed.openapi);\n  if (\n    document.parsed.swagger ||\n    !document.parsed.openapi ||\n    Number.isNaN(openapiVersion) ||\n    openapiVersion < 3 ||\n    openapiVersion >= 4\n  ) {\n    if (document.parsed.swagger) {\n      throw new Error(\"Unsupported Swagger version: 2.x. Use OpenAPI 3.x instead.\");\n    }\n    if (document.parsed.openapi || openapiVersion < 3 || openapiVersion >= 4) {\n      throw new Error(`Unsupported OpenAPI version: ${document.parsed.openapi}`);\n    }\n    throw new Error(\"Unsupported schema format, expected `openapi: 3.x`\");\n  }\n\n  // 2. lint\n  const redocLintT = performance.now();\n  const problems = await lintDocument({\n    document,\n    config: options.redoc.styleguide,\n    externalRefResolver: resolver,\n  });\n  _processProblems(problems, options);\n  debug(\"Linted schema\", \"lint\", performance.now() - redocLintT);\n\n  // 3. bundle\n  const redocBundleT = performance.now();\n  const bundled = await bundle({\n    config: options.redoc,\n    dereference: false,\n    doc: document,\n  });\n  _processProblems(bundled.problems, options);\n  debug(\"Bundled schema\", \"bundle\", performance.now() - redocBundleT);\n\n  return bundled.bundle.parsed;\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"redoc.mjs","sources":["../../src/lib/redoc.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport { Readable } from \"node:stream\";\nimport { fileURLToPath } from \"node:url\";\nimport {\n  BaseResolver,\n  bundle,\n  type Document,\n  lintDocument,\n  makeDocumentFromString,\n  type NormalizedProblem,\n  type Config as RedoclyConfig,\n  Source,\n} from \"@redocly/openapi-core\";\nimport parseJson from \"parse-json\";\nimport type { OpenAPI3 } from \"../types.js\";\nimport { debug, error, warn } from \"./utils.js\";\n\nexport interface ValidateAndBundleOptions {\n  redoc: RedoclyConfig;\n  silent: boolean;\n  cwd?: URL;\n}\n\ninterface ParseSchemaOptions {\n  absoluteRef: string;\n  resolver: BaseResolver;\n}\n\nexport async function parseSchema(schema: unknown, { absoluteRef, resolver }: ParseSchemaOptions): Promise<Document> {\n  if (!schema) {\n    throw new Error(\"Can’t parse empty schema\");\n  }\n  if (schema instanceof URL) {\n    const result = await resolver.resolveDocument(null, absoluteRef, true);\n    if (\"parsed\" in result) {\n      return result;\n    }\n    throw result.originalError;\n  }\n  if (schema instanceof Readable) {\n    const contents = await new Promise<string>((resolve) => {\n      schema.resume();\n      schema.setEncoding(\"utf8\");\n      let content = \"\";\n      schema.on(\"data\", (chunk: string) => {\n        content += chunk;\n      });\n      schema.on(\"end\", () => {\n        resolve(content.trim());\n      });\n    });\n    return parseSchema(contents, { absoluteRef, resolver });\n  }\n  if (schema instanceof Buffer) {\n    return parseSchema(schema.toString(\"utf8\"), { absoluteRef, resolver });\n  }\n  if (typeof schema === \"string\") {\n    // URL\n    if (schema.startsWith(\"http://\") || schema.startsWith(\"https://\") || schema.startsWith(\"file://\")) {\n      const url = new URL(schema);\n      return parseSchema(url, {\n        absoluteRef: url.protocol === \"file:\" ? fileURLToPath(url) : url.href,\n        resolver,\n      });\n    }\n    // JSON\n    if (schema[0] === \"{\") {\n      return {\n        source: new Source(absoluteRef, schema, \"application/json\"),\n        parsed: parseJson(schema),\n      };\n    }\n    // YAML\n    return makeDocumentFromString(schema, absoluteRef);\n  }\n  if (typeof schema === \"object\" && !Array.isArray(schema)) {\n    return {\n      source: new Source(absoluteRef, JSON.stringify(schema), \"application/json\"),\n      parsed: schema,\n    };\n  }\n  throw new Error(`Expected string, object, or Buffer. Got ${Array.isArray(schema) ? \"Array\" : typeof schema}`);\n}\n\nfunction _processProblems(problems: NormalizedProblem[], options: { silent: boolean }) {\n  if (problems.length) {\n    let errorMessage: string | undefined = undefined;\n    for (const problem of problems) {\n      const problemLocation = problem.location?.[0].pointer;\n      const problemMessage = problemLocation ? `${problem.message} at ${problemLocation}` : problem.message;\n      if (problem.severity === \"error\") {\n        errorMessage = problemMessage;\n        error(problemMessage);\n      } else {\n        warn(problemMessage, options.silent);\n      }\n    }\n    if (errorMessage) {\n      throw new Error(errorMessage);\n    }\n  }\n}\n\n/**\n * Validate an OpenAPI schema and flatten into a single schema using Redocly CLI\n */\nexport async function validateAndBundle(\n  source: string | URL | OpenAPI3 | Readable | Buffer,\n  options: ValidateAndBundleOptions,\n) {\n  const redocConfigT = performance.now();\n  debug(\"Loaded Redoc config\", \"redoc\", performance.now() - redocConfigT);\n  const redocParseT = performance.now();\n  let absoluteRef = fileURLToPath(new URL(options?.cwd ?? `file://${process.cwd()}/`));\n  if (source instanceof URL) {\n    absoluteRef = source.protocol === \"file:\" ? fileURLToPath(source) : source.href;\n  }\n  const resolver = new BaseResolver(options.redoc.resolve);\n  const document = await parseSchema(source, {\n    absoluteRef,\n    resolver,\n  });\n  debug(\"Parsed schema\", \"redoc\", performance.now() - redocParseT);\n\n  // 1. check for OpenAPI 3 or greater\n  const openapiVersion = Number.parseFloat(document.parsed.openapi);\n  if (\n    document.parsed.swagger ||\n    !document.parsed.openapi ||\n    Number.isNaN(openapiVersion) ||\n    openapiVersion < 3 ||\n    openapiVersion >= 4\n  ) {\n    if (document.parsed.swagger) {\n      throw new Error(\"Unsupported Swagger version: 2.x. Use OpenAPI 3.x instead.\");\n    }\n    if (document.parsed.openapi || openapiVersion < 3 || openapiVersion >= 4) {\n      throw new Error(`Unsupported OpenAPI version: ${document.parsed.openapi}`);\n    }\n    throw new Error(\"Unsupported schema format, expected `openapi: 3.x`\");\n  }\n\n  // 2. lint\n  const redocLintT = performance.now();\n  const problems = await lintDocument({\n    document,\n    config: options.redoc.styleguide,\n    externalRefResolver: resolver,\n  });\n  _processProblems(problems, options);\n  debug(\"Linted schema\", \"lint\", performance.now() - redocLintT);\n\n  // 3. bundle\n  const redocBundleT = performance.now();\n  const bundled = await bundle({\n    config: options.redoc,\n    dereference: false,\n    doc: document,\n  });\n  _processProblems(bundled.problems, options);\n  debug(\"Bundled schema\", \"bundle\", performance.now() - redocBundleT);\n\n  return bundled.bundle.parsed;\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/lib/ts.cjs b/dist/lib/ts.cjs
index f82d2112011268c636186732d8f6418fae037e78..7c7e8349cdf13fa046e013878f707ad76ae55a23 100644
--- a/dist/lib/ts.cjs
+++ b/dist/lib/ts.cjs
@@ -108,7 +108,7 @@ function addIndexedAccess(node, ...segments) {
     );
   }, node);
 }
-function oapiRef(path, resolved) {
+function oapiRef(path, resolved, deep = false) {
   const { pointer } = refUtils_js.parseRef(path);
   if (pointer.length === 0) {
     throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);
@@ -118,7 +118,9 @@ function oapiRef(path, resolved) {
   const leadingSegments = pointer.slice(1, 3);
   const restSegments = pointer.slice(3);
   const leadingType = addIndexedAccess(
-    ts__default.factory.createTypeReferenceNode(ts__default.factory.createIdentifier(String(initialSegment))),
+    ts__default.factory.createTypeReferenceNode(
+      ts__default.factory.createIdentifier(deep ? `FlattenedDeepRequired<${String(initialSegment)}>` : String(initialSegment))
+    ),
     ...leadingSegments
   );
   return restSegments.reduce((acc, segment, index, original) => {
@@ -205,6 +207,14 @@ function tsEnum(name, members, metadata, options) {
 function tsArrayLiteralExpression(name, elementType, values, options) {
   let variableName = sanitizeMemberName(name);
   variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;
+  if (options?.injectFooter && !options.injectFooter.some(
+    (node) => ts__default.isTypeAliasDeclaration(node) && node?.name?.escapedText === "FlattenedDeepRequired"
+  )) {
+    const helper = stringToAST(
+      "type FlattenedDeepRequired<T> = { [K in keyof T]-?: FlattenedDeepRequired<T[K] extends unknown[] | undefined | null ? Extract<T[K], unknown[]>[number] : T[K]>; };"
+    )[0];
+    options.injectFooter.push(helper);
+  }
   const arrayType = options?.readonly ? tsReadonlyArray(elementType, options.injectFooter) : ts__default.factory.createArrayTypeNode(elementType);
   return ts__default.factory.createVariableStatement(
     options ? tsModifiers({ export: options.export ?? false }) : void 0,
diff --git a/dist/lib/ts.cjs.map b/dist/lib/ts.cjs.map
index abbfe7849fcbc2f8452f27bf4af9afb3260690ab..a26704d602db405d817b068aef1c44b10eee2267 100644
--- a/dist/lib/ts.cjs.map
+++ b/dist/lib/ts.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"ts.cjs","sources":["../../src/lib/ts.ts"],"sourcesContent":["import type { OasRef, Referenced } from \"@redocly/openapi-core\";\nimport { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts, { type LiteralTypeNode, type TypeLiteralNode } from \"typescript\";\nimport type { ParameterObject } from \"../types.js\";\n\nexport const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;\nexport const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;\nexport const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;\nexport const SPECIAL_CHARACTER_MAP: Record<string, string> = {\n  \"+\": \"Plus\",\n  // Add more mappings as needed\n};\n\nexport const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\nexport const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());\nexport const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\nexport const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());\nexport const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\nexport const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);\nexport const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\nexport const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());\nexport const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\nexport const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n\nconst LB_RE = /\\r?\\n/g;\nconst COMMENT_RE = /\\*\\//g;\n\nexport interface AnnotatedSchemaObject {\n  const?: unknown; // jsdoc without value\n  default?: unknown; // jsdoc with value\n  deprecated?: boolean; // jsdoc without value\n  description?: string; // jsdoc with value\n  enum?: unknown[]; // jsdoc without value\n  example?: string; // jsdoc with value\n  examples?: unknown;\n  format?: string; // not jsdoc\n  nullable?: boolean; // Node information\n  summary?: string; // not jsdoc\n  title?: string; // not jsdoc\n  type?: string | string[]; // Type of node\n}\n\n/**\n * Preparing comments from fields\n * @see {comment} for output examples\n * @returns void if not comments or jsdoc format comment string\n */\nexport function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void {\n  if (!schemaObject || typeof schemaObject !== \"object\" || Array.isArray(schemaObject)) {\n    return;\n  }\n  const output: string[] = [];\n\n  // Not JSDoc tags: [title, format]\n  if (schemaObject.title) {\n    output.push(schemaObject.title.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.summary) {\n    output.push(schemaObject.summary.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.format) {\n    output.push(`Format: ${schemaObject.format}`);\n  }\n\n  // JSDoc tags without value\n  // 'Deprecated' without value\n  if (schemaObject.deprecated) {\n    output.push(\"@deprecated\");\n  }\n\n  // JSDoc tags with value\n  const supportedJsDocTags = [\"description\", \"default\", \"example\"] as const;\n  for (const field of supportedJsDocTags) {\n    const allowEmptyString = field === \"default\" || field === \"example\";\n    if (schemaObject[field] === undefined) {\n      continue;\n    }\n    if (schemaObject[field] === \"\" && !allowEmptyString) {\n      continue;\n    }\n    const serialized =\n      typeof schemaObject[field] === \"object\" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];\n    output.push(`@${field} ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n  }\n\n  if (Array.isArray(schemaObject.examples)) {\n    for (const example of schemaObject.examples) {\n      const serialized = typeof example === \"object\" ? JSON.stringify(example, null, 2) : example;\n      output.push(`@example ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n    }\n  }\n\n  // JSDoc 'Constant' without value\n  if (\"const\" in schemaObject) {\n    output.push(\"@constant\");\n  }\n\n  // JSDoc 'Enum' with type\n  if (schemaObject.enum) {\n    let type = \"unknown\";\n    if (Array.isArray(schemaObject.type)) {\n      type = schemaObject.type.join(\"|\");\n    } else if (typeof schemaObject.type === \"string\") {\n      type = schemaObject.type;\n    }\n    output.push(`@enum {${type}${schemaObject.nullable ? \"|null\" : \"\"}}`);\n  }\n\n  // attach comment if it has content\n\n  if (output.length) {\n    // Check if any output item contains multi-line content (has internal line breaks)\n    const hasMultiLineContent = output.some((item) => item.includes(\"\\n\"));\n\n    let text =\n      output.length === 1 && !hasMultiLineContent ? `* ${output.join(\"\\n\")} ` : `*\\n * ${output.join(\"\\n * \")}\\n `;\n    text = text.replace(COMMENT_RE, \"*\\\\/\"); // prevent inner comments from leaking\n\n    ts.addSyntheticLeadingComment(\n      /* node               */ node,\n      /* kind               */ ts.SyntaxKind.MultiLineCommentTrivia, // note: MultiLine just refers to a \"/* */\" comment\n      /* text               */ text,\n      /* hasTrailingNewLine */ true,\n    );\n  }\n}\n\nfunction isOasRef<T>(obj: Referenced<T>): obj is OasRef {\n  return Boolean((obj as OasRef).$ref);\n}\ntype OapiRefResolved = Referenced<ParameterObject>;\n\nfunction isParameterObject(obj: OapiRefResolved | undefined): obj is ParameterObject {\n  return Boolean(obj && !isOasRef(obj) && obj.in);\n}\n\nfunction addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode, ...segments: readonly string[]) {\n  return segments.reduce((acc, segment) => {\n    return ts.factory.createIndexedAccessTypeNode(\n      acc,\n      ts.factory.createLiteralTypeNode(\n        typeof segment === \"number\"\n          ? ts.factory.createNumericLiteral(segment)\n          : ts.factory.createStringLiteral(segment),\n      ),\n    );\n  }, node);\n}\n\n/**\n * Convert OpenAPI ref into TS indexed access node (ex: `components[\"schemas\"][\"Foo\"]`)\n * `path` is a JSON Pointer to a location within an OpenAPI document.\n * Transform it into a TypeScript type reference into the generated types.\n *\n * In most cases the structures of the openapi-typescript generated types and the\n * JSON Pointer paths into the OpenAPI document are the same. However, in some cases\n * special transformations are necessary to account for the ways they differ.\n *   * Object schemas\n *       $refs into the `properties` of object schemas are valid, but openapi-typescript\n *       flattens these objects, so we omit  so the index into the schema skips [\"properties\"]\n *   * Parameters\n *       $refs into the `parameters` of paths are valid, but openapi-ts represents\n *       them according to their type; path, query, header, etc… so in these cases we\n *       must check the parameter definition to determine the how to index into\n *       the openapi-typescript type.\n **/\nexport function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode {\n  const { pointer } = parseRef(path);\n  if (pointer.length === 0) {\n    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);\n  }\n\n  const parametersObject = isParameterObject(resolved);\n\n  // Initial segments are handled in a fixed , then remaining segments are treated\n  // according to heuristics based on the initial segments\n  const initialSegment = pointer[0];\n  const leadingSegments = pointer.slice(1, 3);\n  const restSegments = pointer.slice(3);\n\n  const leadingType = addIndexedAccess(\n    ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(initialSegment))),\n    ...leadingSegments,\n  );\n\n  return restSegments.reduce<ts.TypeReferenceNode | ts.IndexedAccessTypeNode>((acc, segment, index, original) => {\n    // Skip `properties` items when in the middle of the pointer\n    // See: https://github.com/openapi-ts/openapi-typescript/issues/1742\n    if (segment === \"properties\") {\n      return acc;\n    }\n\n    if (parametersObject && index === original.length - 1) {\n      return addIndexedAccess(acc, resolved.in, resolved.name);\n    }\n\n    return addIndexedAccess(acc, segment);\n  }, leadingType);\n}\n\nexport interface AstToStringOptions {\n  fileName?: string;\n  sourceText?: string;\n  formatOptions?: ts.PrinterOptions;\n}\n\n/** Convert TypeScript AST to string */\nexport function astToString(\n  ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[],\n  options?: AstToStringOptions,\n): string {\n  const sourceFile = ts.createSourceFile(\n    options?.fileName ?? \"openapi-ts.ts\",\n    options?.sourceText ?? \"\",\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\n  // @ts-expect-error it’s OK to overwrite statements once\n  sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);\n\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    ...options?.formatOptions,\n  });\n  return printer.printFile(sourceFile);\n}\n\n/** Convert an arbitrary string to TS (assuming it’s valid) */\nexport function stringToAST(source: string): unknown[] {\n  return ts.createSourceFile(\n    /* fileName        */ \"stringInput\",\n    /* sourceText      */ source,\n    /* languageVersion */ ts.ScriptTarget.ESNext,\n    /* setParentNodes  */ undefined,\n    /* scriptKind      */ undefined,\n  ).statements as any;\n}\n\n/**\n * Deduplicate simple primitive types from an array of nodes\n * Note: won’t deduplicate complex types like objects\n */\nexport function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[] {\n  const encounteredTypes = new Set<number>();\n  const filteredTypes: ts.TypeNode[] = [];\n  for (const t of types) {\n    // only mark for deduplication if this is not a const (\"text\" means it is a const)\n    if (!(\"text\" in ((t as LiteralTypeNode).literal ?? t))) {\n      const { kind } = (t as LiteralTypeNode).literal ?? t;\n      if (encounteredTypes.has(kind)) {\n        continue;\n      }\n      if (tsIsPrimitive(t)) {\n        encounteredTypes.add(kind);\n      }\n    }\n    filteredTypes.push(t);\n  }\n  return filteredTypes;\n}\n\nexport const enumCache = new Map<string, ts.EnumDeclaration>();\n\n/** Create a TS enum (with sanitized name and members) */\nexport function tsEnum(\n  name: string,\n  members: (string | number)[],\n  metadata?: { name?: string; description?: string | null }[],\n  options?: { export?: boolean; shouldCache?: boolean },\n) {\n  let enumName = sanitizeMemberName(name);\n  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;\n  let key = \"\";\n  if (options?.shouldCache) {\n    key = `${members\n      .slice(0)\n      .sort()\n      .map((v, i) => {\n        return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || \"\"}`;\n      })\n      .join(\",\")}`;\n    if (enumCache.has(key)) {\n      return enumCache.get(key) as ts.EnumDeclaration;\n    }\n  }\n  const enumDeclaration = ts.factory.createEnumDeclaration(\n    /* modifiers */ options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    /* name      */ enumName,\n    /* members   */ members.map((value, i) => tsEnumMember(value, metadata?.[i])),\n  );\n  options?.shouldCache && enumCache.set(key, enumDeclaration);\n  return enumDeclaration;\n}\n\n/** Create an exported TS array literal expression  */\nexport function tsArrayLiteralExpression(\n  name: string,\n  elementType: ts.TypeNode,\n  values: (string | number)[],\n  options?: { export?: boolean; readonly?: boolean; injectFooter?: ts.Node[] },\n) {\n  let variableName = sanitizeMemberName(name);\n  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;\n\n  const arrayType = options?.readonly\n    ? tsReadonlyArray(elementType, options.injectFooter)\n    : ts.factory.createArrayTypeNode(elementType);\n\n  return ts.factory.createVariableStatement(\n    options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    ts.factory.createVariableDeclarationList(\n      [\n        ts.factory.createVariableDeclaration(\n          variableName,\n          undefined,\n          arrayType,\n          ts.factory.createArrayLiteralExpression(\n            values.map((value) => {\n              if (typeof value === \"number\") {\n                if (value < 0) {\n                  return ts.factory.createPrefixUnaryExpression(\n                    ts.SyntaxKind.MinusToken,\n                    ts.factory.createNumericLiteral(Math.abs(value)),\n                  );\n                } else {\n                  return ts.factory.createNumericLiteral(value);\n                }\n              } else {\n                return ts.factory.createStringLiteral(value);\n              }\n            }),\n          ),\n        ),\n      ],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\nfunction sanitizeMemberName(name: string) {\n  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {\n    const last = c[c.length - 1];\n    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? \"\" : last.toUpperCase();\n  });\n  if (Number(name[0]) >= 0) {\n    sanitizedName = `Value${name}`;\n  }\n  return sanitizedName;\n}\n\n/** Sanitize TS enum member expression */\nexport function tsEnumMember(value: string | number, metadata: { name?: string; description?: string | null } = {}) {\n  let name = metadata.name ?? String(value);\n  if (!JS_PROPERTY_INDEX_RE.test(name)) {\n    if (Number(name[0]) >= 0) {\n      name = `Value${name}`.replace(\".\", \"_\"); // don't forged decimals;\n    } else if (name[0] === \"-\") {\n      name = `ValueMinus${name.slice(1)}`;\n    }\n\n    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);\n    if (invalidCharMatch) {\n      if (invalidCharMatch[0] === name) {\n        name = `\"${name}\"`;\n      } else {\n        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {\n          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : \"_\";\n        });\n      }\n    }\n  }\n\n  let member: ts.EnumMember;\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n\n    member = ts.factory.createEnumMember(name, literal);\n  } else {\n    member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));\n  }\n\n  const trimmedDescription = metadata.description?.trim();\n  if (trimmedDescription === undefined || trimmedDescription === null || trimmedDescription === \"\") {\n    return member;\n  }\n\n  return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, ` ${trimmedDescription}`, true);\n}\n\n/** Create an intersection type */\nexport function tsIntersection(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createIntersectionTypeNode(tsDedupe(types));\n}\n\n/** Is this a primitive type (string, number, boolean, null, undefined)? */\nexport function tsIsPrimitive(type: ts.TypeNode): boolean {\n  if (!type) {\n    return true;\n  }\n  return (\n    ts.SyntaxKind[type.kind] === \"BooleanKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NeverKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NullKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NumberKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"StringKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"UndefinedKeyword\" ||\n    (\"literal\" in type && tsIsPrimitive(type.literal as TypeLiteralNode))\n  );\n}\n\n/** Create a literal type */\nexport function tsLiteral(value: unknown): ts.TypeNode {\n  if (typeof value === \"string\") {\n    // workaround for UTF-8: https://github.com/microsoft/TypeScript/issues/36174\n    return ts.factory.createIdentifier(JSON.stringify(value)) as unknown as ts.TypeNode;\n  }\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n    return ts.factory.createLiteralTypeNode(literal);\n  }\n  if (typeof value === \"boolean\") {\n    return value === true ? TRUE : FALSE;\n  }\n  if (value === null) {\n    return NULL;\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return ts.factory.createArrayTypeNode(NEVER);\n    }\n    return ts.factory.createTupleTypeNode(value.map((v: unknown) => tsLiteral(v)));\n  }\n  if (typeof value === \"object\") {\n    const keys: ts.TypeElement[] = [];\n    for (const [k, v] of Object.entries(value)) {\n      keys.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ tsLiteral(v),\n        ),\n      );\n    }\n    return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);\n  }\n  return UNKNOWN;\n}\n\n/** Modifiers (readonly) */\nexport function tsModifiers(modifiers: { readonly?: boolean; export?: boolean }): ts.Modifier[] {\n  const typeMods: ts.Modifier[] = [];\n  if (modifiers.export) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));\n  }\n  if (modifiers.readonly) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));\n  }\n  return typeMods;\n}\n\n/** Create a T | null union */\nexport function tsNullable(types: ts.TypeNode[]): ts.TypeNode {\n  return ts.factory.createUnionTypeNode([...types, NULL]);\n}\n\n/** Create a TS Omit<X, Y> type */\nexport function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Omit\"), [\n    type,\n    ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/** Create a TS Record<X, Y> type */\nexport function tsRecord(key: ts.TypeNode, value: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Record\"), [key, value]);\n}\n\n/** Create a valid property index */\nexport function tsPropertyIndex(index: string | number) {\n  if (\n    (typeof index === \"number\" && !(index < 0)) ||\n    (typeof index === \"string\" && String(Number(index)) === index && index[0] !== \"-\")\n  ) {\n    return ts.factory.createNumericLiteral(index);\n  }\n  return typeof index === \"string\" && JS_PROPERTY_INDEX_RE.test(index)\n    ? ts.factory.createIdentifier(index)\n    : ts.factory.createStringLiteral(String(index));\n}\n\n/** Create a union type */\nexport function tsUnion(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createUnionTypeNode(tsDedupe(types));\n}\n\n/** Create a WithRequired<X, Y> type */\nexport function tsWithRequired(\n  type: ts.TypeNode,\n  keys: string[],\n  injectFooter: ts.Node[], // needed to inject type helper if used\n): ts.TypeNode {\n  if (keys.length === 0) {\n    return type;\n  }\n\n  // inject helper, if needed\n  if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"WithRequired\")) {\n    const helper = stringToAST(\"type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\")[0] as any;\n    injectFooter.push(helper);\n  }\n\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"WithRequired\"), [\n    type,\n    tsUnion(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/**\n * Enhanced ReadonlyArray.\n * eg: type Foo = ReadonlyArray<T>; type Bar = ReadonlyArray<T[]>\n * Foo and Bar are both of type `readonly T[]`\n */\nexport function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode {\n  if (\n    injectFooter &&\n    !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"ReadonlyArray\")\n  ) {\n    const helper = stringToAST(\n      \"type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;\",\n    )[0] as any;\n    injectFooter.push(helper);\n  }\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"ReadonlyArray\"), [type]);\n}\n"],"names":["ts","parseRef"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"ts.cjs","sources":["../../src/lib/ts.ts"],"sourcesContent":["import type { OasRef, Referenced } from \"@redocly/openapi-core\";\nimport { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts, { type LiteralTypeNode, type TypeLiteralNode } from \"typescript\";\nimport type { ParameterObject } from \"../types.js\";\n\nexport const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;\nexport const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;\nexport const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;\nexport const SPECIAL_CHARACTER_MAP: Record<string, string> = {\n  \"+\": \"Plus\",\n  // Add more mappings as needed\n};\n\nexport const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\nexport const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());\nexport const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\nexport const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());\nexport const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\nexport const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);\nexport const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\nexport const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());\nexport const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\nexport const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n\nconst LB_RE = /\\r?\\n/g;\nconst COMMENT_RE = /\\*\\//g;\n\nexport interface AnnotatedSchemaObject {\n  const?: unknown; // jsdoc without value\n  default?: unknown; // jsdoc with value\n  deprecated?: boolean; // jsdoc without value\n  description?: string; // jsdoc with value\n  enum?: unknown[]; // jsdoc without value\n  example?: string; // jsdoc with value\n  examples?: unknown;\n  format?: string; // not jsdoc\n  nullable?: boolean; // Node information\n  summary?: string; // not jsdoc\n  title?: string; // not jsdoc\n  type?: string | string[]; // Type of node\n}\n\n/**\n * Preparing comments from fields\n * @see {comment} for output examples\n * @returns void if not comments or jsdoc format comment string\n */\nexport function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void {\n  if (!schemaObject || typeof schemaObject !== \"object\" || Array.isArray(schemaObject)) {\n    return;\n  }\n  const output: string[] = [];\n\n  // Not JSDoc tags: [title, format]\n  if (schemaObject.title) {\n    output.push(schemaObject.title.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.summary) {\n    output.push(schemaObject.summary.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.format) {\n    output.push(`Format: ${schemaObject.format}`);\n  }\n\n  // JSDoc tags without value\n  // 'Deprecated' without value\n  if (schemaObject.deprecated) {\n    output.push(\"@deprecated\");\n  }\n\n  // JSDoc tags with value\n  const supportedJsDocTags = [\"description\", \"default\", \"example\"] as const;\n  for (const field of supportedJsDocTags) {\n    const allowEmptyString = field === \"default\" || field === \"example\";\n    if (schemaObject[field] === undefined) {\n      continue;\n    }\n    if (schemaObject[field] === \"\" && !allowEmptyString) {\n      continue;\n    }\n    const serialized =\n      typeof schemaObject[field] === \"object\" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];\n    output.push(`@${field} ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n  }\n\n  if (Array.isArray(schemaObject.examples)) {\n    for (const example of schemaObject.examples) {\n      const serialized = typeof example === \"object\" ? JSON.stringify(example, null, 2) : example;\n      output.push(`@example ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n    }\n  }\n\n  // JSDoc 'Constant' without value\n  if (\"const\" in schemaObject) {\n    output.push(\"@constant\");\n  }\n\n  // JSDoc 'Enum' with type\n  if (schemaObject.enum) {\n    let type = \"unknown\";\n    if (Array.isArray(schemaObject.type)) {\n      type = schemaObject.type.join(\"|\");\n    } else if (typeof schemaObject.type === \"string\") {\n      type = schemaObject.type;\n    }\n    output.push(`@enum {${type}${schemaObject.nullable ? \"|null\" : \"\"}}`);\n  }\n\n  // attach comment if it has content\n\n  if (output.length) {\n    // Check if any output item contains multi-line content (has internal line breaks)\n    const hasMultiLineContent = output.some((item) => item.includes(\"\\n\"));\n\n    let text =\n      output.length === 1 && !hasMultiLineContent ? `* ${output.join(\"\\n\")} ` : `*\\n * ${output.join(\"\\n * \")}\\n `;\n    text = text.replace(COMMENT_RE, \"*\\\\/\"); // prevent inner comments from leaking\n\n    ts.addSyntheticLeadingComment(\n      /* node               */ node,\n      /* kind               */ ts.SyntaxKind.MultiLineCommentTrivia, // note: MultiLine just refers to a \"/* */\" comment\n      /* text               */ text,\n      /* hasTrailingNewLine */ true,\n    );\n  }\n}\n\nfunction isOasRef<T>(obj: Referenced<T>): obj is OasRef {\n  return Boolean((obj as OasRef).$ref);\n}\ntype OapiRefResolved = Referenced<ParameterObject>;\n\nfunction isParameterObject(obj: OapiRefResolved | undefined): obj is ParameterObject {\n  return Boolean(obj && !isOasRef(obj) && obj.in);\n}\n\nfunction addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode, ...segments: readonly string[]) {\n  return segments.reduce((acc, segment) => {\n    return ts.factory.createIndexedAccessTypeNode(\n      acc,\n      ts.factory.createLiteralTypeNode(\n        typeof segment === \"number\"\n          ? ts.factory.createNumericLiteral(segment)\n          : ts.factory.createStringLiteral(segment),\n      ),\n    );\n  }, node);\n}\n\n/**\n * Convert OpenAPI ref into TS indexed access node (ex: `components[\"schemas\"][\"Foo\"]`)\n * `path` is a JSON Pointer to a location within an OpenAPI document.\n * Transform it into a TypeScript type reference into the generated types.\n *\n * In most cases the structures of the openapi-typescript generated types and the\n * JSON Pointer paths into the OpenAPI document are the same. However, in some cases\n * special transformations are necessary to account for the ways they differ.\n *   * Object schemas\n *       $refs into the `properties` of object schemas are valid, but openapi-typescript\n *       flattens these objects, so we omit  so the index into the schema skips [\"properties\"]\n *   * Parameters\n *       $refs into the `parameters` of paths are valid, but openapi-ts represents\n *       them according to their type; path, query, header, etc… so in these cases we\n *       must check the parameter definition to determine the how to index into\n *       the openapi-typescript type.\n **/\nexport function oapiRef(path: string, resolved?: OapiRefResolved, deep = false): ts.TypeNode {\n  const { pointer } = parseRef(path);\n  if (pointer.length === 0) {\n    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);\n  }\n\n  const parametersObject = isParameterObject(resolved);\n\n  // Initial segments are handled in a fixed , then remaining segments are treated\n  // according to heuristics based on the initial segments\n  const initialSegment = pointer[0];\n  const leadingSegments = pointer.slice(1, 3);\n  const restSegments = pointer.slice(3);\n\n  const leadingType = addIndexedAccess(\n    ts.factory.createTypeReferenceNode(\n      ts.factory.createIdentifier(deep ? `FlattenedDeepRequired<${String(initialSegment)}>` : String(initialSegment)),\n    ),\n    ...leadingSegments,\n  );\n\n  return restSegments.reduce<ts.TypeReferenceNode | ts.IndexedAccessTypeNode>((acc, segment, index, original) => {\n    // Skip `properties` items when in the middle of the pointer\n    // See: https://github.com/openapi-ts/openapi-typescript/issues/1742\n    if (segment === \"properties\") {\n      return acc;\n    }\n\n    if (parametersObject && index === original.length - 1) {\n      return addIndexedAccess(acc, resolved.in, resolved.name);\n    }\n\n    return addIndexedAccess(acc, segment);\n  }, leadingType);\n}\n\nexport interface AstToStringOptions {\n  fileName?: string;\n  sourceText?: string;\n  formatOptions?: ts.PrinterOptions;\n}\n\n/** Convert TypeScript AST to string */\nexport function astToString(\n  ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[],\n  options?: AstToStringOptions,\n): string {\n  const sourceFile = ts.createSourceFile(\n    options?.fileName ?? \"openapi-ts.ts\",\n    options?.sourceText ?? \"\",\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\n  // @ts-expect-error it’s OK to overwrite statements once\n  sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);\n\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    ...options?.formatOptions,\n  });\n  return printer.printFile(sourceFile);\n}\n\n/** Convert an arbitrary string to TS (assuming it’s valid) */\nexport function stringToAST(source: string): unknown[] {\n  return ts.createSourceFile(\n    /* fileName        */ \"stringInput\",\n    /* sourceText      */ source,\n    /* languageVersion */ ts.ScriptTarget.ESNext,\n    /* setParentNodes  */ undefined,\n    /* scriptKind      */ undefined,\n  ).statements as any;\n}\n\n/**\n * Deduplicate simple primitive types from an array of nodes\n * Note: won’t deduplicate complex types like objects\n */\nexport function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[] {\n  const encounteredTypes = new Set<number>();\n  const filteredTypes: ts.TypeNode[] = [];\n  for (const t of types) {\n    // only mark for deduplication if this is not a const (\"text\" means it is a const)\n    if (!(\"text\" in ((t as LiteralTypeNode).literal ?? t))) {\n      const { kind } = (t as LiteralTypeNode).literal ?? t;\n      if (encounteredTypes.has(kind)) {\n        continue;\n      }\n      if (tsIsPrimitive(t)) {\n        encounteredTypes.add(kind);\n      }\n    }\n    filteredTypes.push(t);\n  }\n  return filteredTypes;\n}\n\nexport const enumCache = new Map<string, ts.EnumDeclaration>();\n\n/** Create a TS enum (with sanitized name and members) */\nexport function tsEnum(\n  name: string,\n  members: (string | number)[],\n  metadata?: { name?: string; description?: string | null }[],\n  options?: { export?: boolean; shouldCache?: boolean },\n) {\n  let enumName = sanitizeMemberName(name);\n  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;\n  let key = \"\";\n  if (options?.shouldCache) {\n    key = `${members\n      .slice(0)\n      .sort()\n      .map((v, i) => {\n        return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || \"\"}`;\n      })\n      .join(\",\")}`;\n    if (enumCache.has(key)) {\n      return enumCache.get(key) as ts.EnumDeclaration;\n    }\n  }\n  const enumDeclaration = ts.factory.createEnumDeclaration(\n    /* modifiers */ options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    /* name      */ enumName,\n    /* members   */ members.map((value, i) => tsEnumMember(value, metadata?.[i])),\n  );\n  options?.shouldCache && enumCache.set(key, enumDeclaration);\n  return enumDeclaration;\n}\n\n/** Create an exported TS array literal expression  */\nexport function tsArrayLiteralExpression(\n  name: string,\n  elementType: ts.TypeNode,\n  values: (string | number)[],\n  options?: { export?: boolean; readonly?: boolean; injectFooter?: ts.Node[] },\n) {\n  let variableName = sanitizeMemberName(name);\n  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;\n\n  if (\n    options?.injectFooter &&\n    !options.injectFooter.some(\n      (node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"FlattenedDeepRequired\",\n    )\n  ) {\n    const helper = stringToAST(\n      \"type FlattenedDeepRequired<T> = { [K in keyof T]-?: FlattenedDeepRequired<T[K] extends unknown[] | undefined | null ? Extract<T[K], unknown[]>[number] : T[K]>; };\",\n    )[0] as any;\n    options.injectFooter.push(helper);\n  }\n\n  const arrayType = options?.readonly\n    ? tsReadonlyArray(elementType, options.injectFooter)\n    : ts.factory.createArrayTypeNode(elementType);\n\n  return ts.factory.createVariableStatement(\n    options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    ts.factory.createVariableDeclarationList(\n      [\n        ts.factory.createVariableDeclaration(\n          variableName,\n          undefined,\n          arrayType,\n          ts.factory.createArrayLiteralExpression(\n            values.map((value) => {\n              if (typeof value === \"number\") {\n                if (value < 0) {\n                  return ts.factory.createPrefixUnaryExpression(\n                    ts.SyntaxKind.MinusToken,\n                    ts.factory.createNumericLiteral(Math.abs(value)),\n                  );\n                } else {\n                  return ts.factory.createNumericLiteral(value);\n                }\n              } else {\n                return ts.factory.createStringLiteral(value);\n              }\n            }),\n          ),\n        ),\n      ],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\nfunction sanitizeMemberName(name: string) {\n  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {\n    const last = c[c.length - 1];\n    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? \"\" : last.toUpperCase();\n  });\n  if (Number(name[0]) >= 0) {\n    sanitizedName = `Value${name}`;\n  }\n  return sanitizedName;\n}\n\n/** Sanitize TS enum member expression */\nexport function tsEnumMember(value: string | number, metadata: { name?: string; description?: string | null } = {}) {\n  let name = metadata.name ?? String(value);\n  if (!JS_PROPERTY_INDEX_RE.test(name)) {\n    if (Number(name[0]) >= 0) {\n      name = `Value${name}`.replace(\".\", \"_\"); // don't forged decimals;\n    } else if (name[0] === \"-\") {\n      name = `ValueMinus${name.slice(1)}`;\n    }\n\n    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);\n    if (invalidCharMatch) {\n      if (invalidCharMatch[0] === name) {\n        name = `\"${name}\"`;\n      } else {\n        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {\n          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : \"_\";\n        });\n      }\n    }\n  }\n\n  let member: ts.EnumMember;\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n\n    member = ts.factory.createEnumMember(name, literal);\n  } else {\n    member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));\n  }\n\n  const trimmedDescription = metadata.description?.trim();\n  if (trimmedDescription === undefined || trimmedDescription === null || trimmedDescription === \"\") {\n    return member;\n  }\n\n  return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, ` ${trimmedDescription}`, true);\n}\n\n/** Create an intersection type */\nexport function tsIntersection(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createIntersectionTypeNode(tsDedupe(types));\n}\n\n/** Is this a primitive type (string, number, boolean, null, undefined)? */\nexport function tsIsPrimitive(type: ts.TypeNode): boolean {\n  if (!type) {\n    return true;\n  }\n  return (\n    ts.SyntaxKind[type.kind] === \"BooleanKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NeverKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NullKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NumberKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"StringKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"UndefinedKeyword\" ||\n    (\"literal\" in type && tsIsPrimitive(type.literal as TypeLiteralNode))\n  );\n}\n\n/** Create a literal type */\nexport function tsLiteral(value: unknown): ts.TypeNode {\n  if (typeof value === \"string\") {\n    // workaround for UTF-8: https://github.com/microsoft/TypeScript/issues/36174\n    return ts.factory.createIdentifier(JSON.stringify(value)) as unknown as ts.TypeNode;\n  }\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n    return ts.factory.createLiteralTypeNode(literal);\n  }\n  if (typeof value === \"boolean\") {\n    return value === true ? TRUE : FALSE;\n  }\n  if (value === null) {\n    return NULL;\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return ts.factory.createArrayTypeNode(NEVER);\n    }\n    return ts.factory.createTupleTypeNode(value.map((v: unknown) => tsLiteral(v)));\n  }\n  if (typeof value === \"object\") {\n    const keys: ts.TypeElement[] = [];\n    for (const [k, v] of Object.entries(value)) {\n      keys.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ tsLiteral(v),\n        ),\n      );\n    }\n    return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);\n  }\n  return UNKNOWN;\n}\n\n/** Modifiers (readonly) */\nexport function tsModifiers(modifiers: { readonly?: boolean; export?: boolean }): ts.Modifier[] {\n  const typeMods: ts.Modifier[] = [];\n  if (modifiers.export) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));\n  }\n  if (modifiers.readonly) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));\n  }\n  return typeMods;\n}\n\n/** Create a T | null union */\nexport function tsNullable(types: ts.TypeNode[]): ts.TypeNode {\n  return ts.factory.createUnionTypeNode([...types, NULL]);\n}\n\n/** Create a TS Omit<X, Y> type */\nexport function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Omit\"), [\n    type,\n    ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/** Create a TS Record<X, Y> type */\nexport function tsRecord(key: ts.TypeNode, value: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Record\"), [key, value]);\n}\n\n/** Create a valid property index */\nexport function tsPropertyIndex(index: string | number) {\n  if (\n    (typeof index === \"number\" && !(index < 0)) ||\n    (typeof index === \"string\" && String(Number(index)) === index && index[0] !== \"-\")\n  ) {\n    return ts.factory.createNumericLiteral(index);\n  }\n  return typeof index === \"string\" && JS_PROPERTY_INDEX_RE.test(index)\n    ? ts.factory.createIdentifier(index)\n    : ts.factory.createStringLiteral(String(index));\n}\n\n/** Create a union type */\nexport function tsUnion(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createUnionTypeNode(tsDedupe(types));\n}\n\n/** Create a WithRequired<X, Y> type */\nexport function tsWithRequired(\n  type: ts.TypeNode,\n  keys: string[],\n  injectFooter: ts.Node[], // needed to inject type helper if used\n): ts.TypeNode {\n  if (keys.length === 0) {\n    return type;\n  }\n\n  // inject helper, if needed\n  if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"WithRequired\")) {\n    const helper = stringToAST(\"type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\")[0] as any;\n    injectFooter.push(helper);\n  }\n\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"WithRequired\"), [\n    type,\n    tsUnion(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/**\n * Enhanced ReadonlyArray.\n * eg: type Foo = ReadonlyArray<T>; type Bar = ReadonlyArray<T[]>\n * Foo and Bar are both of type `readonly T[]`\n */\nexport function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode {\n  if (\n    injectFooter &&\n    !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"ReadonlyArray\")\n  ) {\n    const helper = stringToAST(\n      \"type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;\",\n    )[0] as any;\n    injectFooter.push(helper);\n  }\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"ReadonlyArray\"), [type]);\n}\n"],"names":["ts","parseRef"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/lib/ts.mjs b/dist/lib/ts.mjs
index 6cd1ce99a98b4be4b333167afcfc03bed4f78786..93724bc4e4b66d1ea8a3e6de8e7a8f1ff444d187 100644
--- a/dist/lib/ts.mjs
+++ b/dist/lib/ts.mjs
@@ -102,7 +102,7 @@ function addIndexedAccess(node, ...segments) {
     );
   }, node);
 }
-function oapiRef(path, resolved) {
+function oapiRef(path, resolved, deep = false) {
   const { pointer } = parseRef(path);
   if (pointer.length === 0) {
     throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);
@@ -112,7 +112,9 @@ function oapiRef(path, resolved) {
   const leadingSegments = pointer.slice(1, 3);
   const restSegments = pointer.slice(3);
   const leadingType = addIndexedAccess(
-    ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(initialSegment))),
+    ts.factory.createTypeReferenceNode(
+      ts.factory.createIdentifier(deep ? `FlattenedDeepRequired<${String(initialSegment)}>` : String(initialSegment))
+    ),
     ...leadingSegments
   );
   return restSegments.reduce((acc, segment, index, original) => {
@@ -199,6 +201,14 @@ function tsEnum(name, members, metadata, options) {
 function tsArrayLiteralExpression(name, elementType, values, options) {
   let variableName = sanitizeMemberName(name);
   variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;
+  if (options?.injectFooter && !options.injectFooter.some(
+    (node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === "FlattenedDeepRequired"
+  )) {
+    const helper = stringToAST(
+      "type FlattenedDeepRequired<T> = { [K in keyof T]-?: FlattenedDeepRequired<T[K] extends unknown[] | undefined | null ? Extract<T[K], unknown[]>[number] : T[K]>; };"
+    )[0];
+    options.injectFooter.push(helper);
+  }
   const arrayType = options?.readonly ? tsReadonlyArray(elementType, options.injectFooter) : ts.factory.createArrayTypeNode(elementType);
   return ts.factory.createVariableStatement(
     options ? tsModifiers({ export: options.export ?? false }) : void 0,
diff --git a/dist/lib/ts.mjs.map b/dist/lib/ts.mjs.map
index 543cd035324e2aaa37793666b31caca98fd91139..670c4710ef1c6567492790a6c4a12a01f4745276 100644
--- a/dist/lib/ts.mjs.map
+++ b/dist/lib/ts.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"ts.mjs","sources":["../../src/lib/ts.ts"],"sourcesContent":["import type { OasRef, Referenced } from \"@redocly/openapi-core\";\nimport { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts, { type LiteralTypeNode, type TypeLiteralNode } from \"typescript\";\nimport type { ParameterObject } from \"../types.js\";\n\nexport const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;\nexport const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;\nexport const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;\nexport const SPECIAL_CHARACTER_MAP: Record<string, string> = {\n  \"+\": \"Plus\",\n  // Add more mappings as needed\n};\n\nexport const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\nexport const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());\nexport const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\nexport const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());\nexport const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\nexport const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);\nexport const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\nexport const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());\nexport const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\nexport const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n\nconst LB_RE = /\\r?\\n/g;\nconst COMMENT_RE = /\\*\\//g;\n\nexport interface AnnotatedSchemaObject {\n  const?: unknown; // jsdoc without value\n  default?: unknown; // jsdoc with value\n  deprecated?: boolean; // jsdoc without value\n  description?: string; // jsdoc with value\n  enum?: unknown[]; // jsdoc without value\n  example?: string; // jsdoc with value\n  examples?: unknown;\n  format?: string; // not jsdoc\n  nullable?: boolean; // Node information\n  summary?: string; // not jsdoc\n  title?: string; // not jsdoc\n  type?: string | string[]; // Type of node\n}\n\n/**\n * Preparing comments from fields\n * @see {comment} for output examples\n * @returns void if not comments or jsdoc format comment string\n */\nexport function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void {\n  if (!schemaObject || typeof schemaObject !== \"object\" || Array.isArray(schemaObject)) {\n    return;\n  }\n  const output: string[] = [];\n\n  // Not JSDoc tags: [title, format]\n  if (schemaObject.title) {\n    output.push(schemaObject.title.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.summary) {\n    output.push(schemaObject.summary.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.format) {\n    output.push(`Format: ${schemaObject.format}`);\n  }\n\n  // JSDoc tags without value\n  // 'Deprecated' without value\n  if (schemaObject.deprecated) {\n    output.push(\"@deprecated\");\n  }\n\n  // JSDoc tags with value\n  const supportedJsDocTags = [\"description\", \"default\", \"example\"] as const;\n  for (const field of supportedJsDocTags) {\n    const allowEmptyString = field === \"default\" || field === \"example\";\n    if (schemaObject[field] === undefined) {\n      continue;\n    }\n    if (schemaObject[field] === \"\" && !allowEmptyString) {\n      continue;\n    }\n    const serialized =\n      typeof schemaObject[field] === \"object\" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];\n    output.push(`@${field} ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n  }\n\n  if (Array.isArray(schemaObject.examples)) {\n    for (const example of schemaObject.examples) {\n      const serialized = typeof example === \"object\" ? JSON.stringify(example, null, 2) : example;\n      output.push(`@example ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n    }\n  }\n\n  // JSDoc 'Constant' without value\n  if (\"const\" in schemaObject) {\n    output.push(\"@constant\");\n  }\n\n  // JSDoc 'Enum' with type\n  if (schemaObject.enum) {\n    let type = \"unknown\";\n    if (Array.isArray(schemaObject.type)) {\n      type = schemaObject.type.join(\"|\");\n    } else if (typeof schemaObject.type === \"string\") {\n      type = schemaObject.type;\n    }\n    output.push(`@enum {${type}${schemaObject.nullable ? \"|null\" : \"\"}}`);\n  }\n\n  // attach comment if it has content\n\n  if (output.length) {\n    // Check if any output item contains multi-line content (has internal line breaks)\n    const hasMultiLineContent = output.some((item) => item.includes(\"\\n\"));\n\n    let text =\n      output.length === 1 && !hasMultiLineContent ? `* ${output.join(\"\\n\")} ` : `*\\n * ${output.join(\"\\n * \")}\\n `;\n    text = text.replace(COMMENT_RE, \"*\\\\/\"); // prevent inner comments from leaking\n\n    ts.addSyntheticLeadingComment(\n      /* node               */ node,\n      /* kind               */ ts.SyntaxKind.MultiLineCommentTrivia, // note: MultiLine just refers to a \"/* */\" comment\n      /* text               */ text,\n      /* hasTrailingNewLine */ true,\n    );\n  }\n}\n\nfunction isOasRef<T>(obj: Referenced<T>): obj is OasRef {\n  return Boolean((obj as OasRef).$ref);\n}\ntype OapiRefResolved = Referenced<ParameterObject>;\n\nfunction isParameterObject(obj: OapiRefResolved | undefined): obj is ParameterObject {\n  return Boolean(obj && !isOasRef(obj) && obj.in);\n}\n\nfunction addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode, ...segments: readonly string[]) {\n  return segments.reduce((acc, segment) => {\n    return ts.factory.createIndexedAccessTypeNode(\n      acc,\n      ts.factory.createLiteralTypeNode(\n        typeof segment === \"number\"\n          ? ts.factory.createNumericLiteral(segment)\n          : ts.factory.createStringLiteral(segment),\n      ),\n    );\n  }, node);\n}\n\n/**\n * Convert OpenAPI ref into TS indexed access node (ex: `components[\"schemas\"][\"Foo\"]`)\n * `path` is a JSON Pointer to a location within an OpenAPI document.\n * Transform it into a TypeScript type reference into the generated types.\n *\n * In most cases the structures of the openapi-typescript generated types and the\n * JSON Pointer paths into the OpenAPI document are the same. However, in some cases\n * special transformations are necessary to account for the ways they differ.\n *   * Object schemas\n *       $refs into the `properties` of object schemas are valid, but openapi-typescript\n *       flattens these objects, so we omit  so the index into the schema skips [\"properties\"]\n *   * Parameters\n *       $refs into the `parameters` of paths are valid, but openapi-ts represents\n *       them according to their type; path, query, header, etc… so in these cases we\n *       must check the parameter definition to determine the how to index into\n *       the openapi-typescript type.\n **/\nexport function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode {\n  const { pointer } = parseRef(path);\n  if (pointer.length === 0) {\n    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);\n  }\n\n  const parametersObject = isParameterObject(resolved);\n\n  // Initial segments are handled in a fixed , then remaining segments are treated\n  // according to heuristics based on the initial segments\n  const initialSegment = pointer[0];\n  const leadingSegments = pointer.slice(1, 3);\n  const restSegments = pointer.slice(3);\n\n  const leadingType = addIndexedAccess(\n    ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(initialSegment))),\n    ...leadingSegments,\n  );\n\n  return restSegments.reduce<ts.TypeReferenceNode | ts.IndexedAccessTypeNode>((acc, segment, index, original) => {\n    // Skip `properties` items when in the middle of the pointer\n    // See: https://github.com/openapi-ts/openapi-typescript/issues/1742\n    if (segment === \"properties\") {\n      return acc;\n    }\n\n    if (parametersObject && index === original.length - 1) {\n      return addIndexedAccess(acc, resolved.in, resolved.name);\n    }\n\n    return addIndexedAccess(acc, segment);\n  }, leadingType);\n}\n\nexport interface AstToStringOptions {\n  fileName?: string;\n  sourceText?: string;\n  formatOptions?: ts.PrinterOptions;\n}\n\n/** Convert TypeScript AST to string */\nexport function astToString(\n  ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[],\n  options?: AstToStringOptions,\n): string {\n  const sourceFile = ts.createSourceFile(\n    options?.fileName ?? \"openapi-ts.ts\",\n    options?.sourceText ?? \"\",\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\n  // @ts-expect-error it’s OK to overwrite statements once\n  sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);\n\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    ...options?.formatOptions,\n  });\n  return printer.printFile(sourceFile);\n}\n\n/** Convert an arbitrary string to TS (assuming it’s valid) */\nexport function stringToAST(source: string): unknown[] {\n  return ts.createSourceFile(\n    /* fileName        */ \"stringInput\",\n    /* sourceText      */ source,\n    /* languageVersion */ ts.ScriptTarget.ESNext,\n    /* setParentNodes  */ undefined,\n    /* scriptKind      */ undefined,\n  ).statements as any;\n}\n\n/**\n * Deduplicate simple primitive types from an array of nodes\n * Note: won’t deduplicate complex types like objects\n */\nexport function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[] {\n  const encounteredTypes = new Set<number>();\n  const filteredTypes: ts.TypeNode[] = [];\n  for (const t of types) {\n    // only mark for deduplication if this is not a const (\"text\" means it is a const)\n    if (!(\"text\" in ((t as LiteralTypeNode).literal ?? t))) {\n      const { kind } = (t as LiteralTypeNode).literal ?? t;\n      if (encounteredTypes.has(kind)) {\n        continue;\n      }\n      if (tsIsPrimitive(t)) {\n        encounteredTypes.add(kind);\n      }\n    }\n    filteredTypes.push(t);\n  }\n  return filteredTypes;\n}\n\nexport const enumCache = new Map<string, ts.EnumDeclaration>();\n\n/** Create a TS enum (with sanitized name and members) */\nexport function tsEnum(\n  name: string,\n  members: (string | number)[],\n  metadata?: { name?: string; description?: string | null }[],\n  options?: { export?: boolean; shouldCache?: boolean },\n) {\n  let enumName = sanitizeMemberName(name);\n  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;\n  let key = \"\";\n  if (options?.shouldCache) {\n    key = `${members\n      .slice(0)\n      .sort()\n      .map((v, i) => {\n        return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || \"\"}`;\n      })\n      .join(\",\")}`;\n    if (enumCache.has(key)) {\n      return enumCache.get(key) as ts.EnumDeclaration;\n    }\n  }\n  const enumDeclaration = ts.factory.createEnumDeclaration(\n    /* modifiers */ options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    /* name      */ enumName,\n    /* members   */ members.map((value, i) => tsEnumMember(value, metadata?.[i])),\n  );\n  options?.shouldCache && enumCache.set(key, enumDeclaration);\n  return enumDeclaration;\n}\n\n/** Create an exported TS array literal expression  */\nexport function tsArrayLiteralExpression(\n  name: string,\n  elementType: ts.TypeNode,\n  values: (string | number)[],\n  options?: { export?: boolean; readonly?: boolean; injectFooter?: ts.Node[] },\n) {\n  let variableName = sanitizeMemberName(name);\n  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;\n\n  const arrayType = options?.readonly\n    ? tsReadonlyArray(elementType, options.injectFooter)\n    : ts.factory.createArrayTypeNode(elementType);\n\n  return ts.factory.createVariableStatement(\n    options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    ts.factory.createVariableDeclarationList(\n      [\n        ts.factory.createVariableDeclaration(\n          variableName,\n          undefined,\n          arrayType,\n          ts.factory.createArrayLiteralExpression(\n            values.map((value) => {\n              if (typeof value === \"number\") {\n                if (value < 0) {\n                  return ts.factory.createPrefixUnaryExpression(\n                    ts.SyntaxKind.MinusToken,\n                    ts.factory.createNumericLiteral(Math.abs(value)),\n                  );\n                } else {\n                  return ts.factory.createNumericLiteral(value);\n                }\n              } else {\n                return ts.factory.createStringLiteral(value);\n              }\n            }),\n          ),\n        ),\n      ],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\nfunction sanitizeMemberName(name: string) {\n  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {\n    const last = c[c.length - 1];\n    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? \"\" : last.toUpperCase();\n  });\n  if (Number(name[0]) >= 0) {\n    sanitizedName = `Value${name}`;\n  }\n  return sanitizedName;\n}\n\n/** Sanitize TS enum member expression */\nexport function tsEnumMember(value: string | number, metadata: { name?: string; description?: string | null } = {}) {\n  let name = metadata.name ?? String(value);\n  if (!JS_PROPERTY_INDEX_RE.test(name)) {\n    if (Number(name[0]) >= 0) {\n      name = `Value${name}`.replace(\".\", \"_\"); // don't forged decimals;\n    } else if (name[0] === \"-\") {\n      name = `ValueMinus${name.slice(1)}`;\n    }\n\n    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);\n    if (invalidCharMatch) {\n      if (invalidCharMatch[0] === name) {\n        name = `\"${name}\"`;\n      } else {\n        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {\n          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : \"_\";\n        });\n      }\n    }\n  }\n\n  let member: ts.EnumMember;\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n\n    member = ts.factory.createEnumMember(name, literal);\n  } else {\n    member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));\n  }\n\n  const trimmedDescription = metadata.description?.trim();\n  if (trimmedDescription === undefined || trimmedDescription === null || trimmedDescription === \"\") {\n    return member;\n  }\n\n  return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, ` ${trimmedDescription}`, true);\n}\n\n/** Create an intersection type */\nexport function tsIntersection(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createIntersectionTypeNode(tsDedupe(types));\n}\n\n/** Is this a primitive type (string, number, boolean, null, undefined)? */\nexport function tsIsPrimitive(type: ts.TypeNode): boolean {\n  if (!type) {\n    return true;\n  }\n  return (\n    ts.SyntaxKind[type.kind] === \"BooleanKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NeverKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NullKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NumberKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"StringKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"UndefinedKeyword\" ||\n    (\"literal\" in type && tsIsPrimitive(type.literal as TypeLiteralNode))\n  );\n}\n\n/** Create a literal type */\nexport function tsLiteral(value: unknown): ts.TypeNode {\n  if (typeof value === \"string\") {\n    // workaround for UTF-8: https://github.com/microsoft/TypeScript/issues/36174\n    return ts.factory.createIdentifier(JSON.stringify(value)) as unknown as ts.TypeNode;\n  }\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n    return ts.factory.createLiteralTypeNode(literal);\n  }\n  if (typeof value === \"boolean\") {\n    return value === true ? TRUE : FALSE;\n  }\n  if (value === null) {\n    return NULL;\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return ts.factory.createArrayTypeNode(NEVER);\n    }\n    return ts.factory.createTupleTypeNode(value.map((v: unknown) => tsLiteral(v)));\n  }\n  if (typeof value === \"object\") {\n    const keys: ts.TypeElement[] = [];\n    for (const [k, v] of Object.entries(value)) {\n      keys.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ tsLiteral(v),\n        ),\n      );\n    }\n    return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);\n  }\n  return UNKNOWN;\n}\n\n/** Modifiers (readonly) */\nexport function tsModifiers(modifiers: { readonly?: boolean; export?: boolean }): ts.Modifier[] {\n  const typeMods: ts.Modifier[] = [];\n  if (modifiers.export) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));\n  }\n  if (modifiers.readonly) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));\n  }\n  return typeMods;\n}\n\n/** Create a T | null union */\nexport function tsNullable(types: ts.TypeNode[]): ts.TypeNode {\n  return ts.factory.createUnionTypeNode([...types, NULL]);\n}\n\n/** Create a TS Omit<X, Y> type */\nexport function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Omit\"), [\n    type,\n    ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/** Create a TS Record<X, Y> type */\nexport function tsRecord(key: ts.TypeNode, value: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Record\"), [key, value]);\n}\n\n/** Create a valid property index */\nexport function tsPropertyIndex(index: string | number) {\n  if (\n    (typeof index === \"number\" && !(index < 0)) ||\n    (typeof index === \"string\" && String(Number(index)) === index && index[0] !== \"-\")\n  ) {\n    return ts.factory.createNumericLiteral(index);\n  }\n  return typeof index === \"string\" && JS_PROPERTY_INDEX_RE.test(index)\n    ? ts.factory.createIdentifier(index)\n    : ts.factory.createStringLiteral(String(index));\n}\n\n/** Create a union type */\nexport function tsUnion(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createUnionTypeNode(tsDedupe(types));\n}\n\n/** Create a WithRequired<X, Y> type */\nexport function tsWithRequired(\n  type: ts.TypeNode,\n  keys: string[],\n  injectFooter: ts.Node[], // needed to inject type helper if used\n): ts.TypeNode {\n  if (keys.length === 0) {\n    return type;\n  }\n\n  // inject helper, if needed\n  if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"WithRequired\")) {\n    const helper = stringToAST(\"type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\")[0] as any;\n    injectFooter.push(helper);\n  }\n\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"WithRequired\"), [\n    type,\n    tsUnion(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/**\n * Enhanced ReadonlyArray.\n * eg: type Foo = ReadonlyArray<T>; type Bar = ReadonlyArray<T[]>\n * Foo and Bar are both of type `readonly T[]`\n */\nexport function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode {\n  if (\n    injectFooter &&\n    !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"ReadonlyArray\")\n  ) {\n    const helper = stringToAST(\n      \"type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;\",\n    )[0] as any;\n    injectFooter.push(helper);\n  }\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"ReadonlyArray\"), [type]);\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"ts.mjs","sources":["../../src/lib/ts.ts"],"sourcesContent":["import type { OasRef, Referenced } from \"@redocly/openapi-core\";\nimport { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts, { type LiteralTypeNode, type TypeLiteralNode } from \"typescript\";\nimport type { ParameterObject } from \"../types.js\";\n\nexport const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;\nexport const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;\nexport const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;\nexport const SPECIAL_CHARACTER_MAP: Record<string, string> = {\n  \"+\": \"Plus\",\n  // Add more mappings as needed\n};\n\nexport const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\nexport const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());\nexport const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\nexport const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());\nexport const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\nexport const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);\nexport const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\nexport const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());\nexport const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\nexport const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n\nconst LB_RE = /\\r?\\n/g;\nconst COMMENT_RE = /\\*\\//g;\n\nexport interface AnnotatedSchemaObject {\n  const?: unknown; // jsdoc without value\n  default?: unknown; // jsdoc with value\n  deprecated?: boolean; // jsdoc without value\n  description?: string; // jsdoc with value\n  enum?: unknown[]; // jsdoc without value\n  example?: string; // jsdoc with value\n  examples?: unknown;\n  format?: string; // not jsdoc\n  nullable?: boolean; // Node information\n  summary?: string; // not jsdoc\n  title?: string; // not jsdoc\n  type?: string | string[]; // Type of node\n}\n\n/**\n * Preparing comments from fields\n * @see {comment} for output examples\n * @returns void if not comments or jsdoc format comment string\n */\nexport function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void {\n  if (!schemaObject || typeof schemaObject !== \"object\" || Array.isArray(schemaObject)) {\n    return;\n  }\n  const output: string[] = [];\n\n  // Not JSDoc tags: [title, format]\n  if (schemaObject.title) {\n    output.push(schemaObject.title.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.summary) {\n    output.push(schemaObject.summary.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.format) {\n    output.push(`Format: ${schemaObject.format}`);\n  }\n\n  // JSDoc tags without value\n  // 'Deprecated' without value\n  if (schemaObject.deprecated) {\n    output.push(\"@deprecated\");\n  }\n\n  // JSDoc tags with value\n  const supportedJsDocTags = [\"description\", \"default\", \"example\"] as const;\n  for (const field of supportedJsDocTags) {\n    const allowEmptyString = field === \"default\" || field === \"example\";\n    if (schemaObject[field] === undefined) {\n      continue;\n    }\n    if (schemaObject[field] === \"\" && !allowEmptyString) {\n      continue;\n    }\n    const serialized =\n      typeof schemaObject[field] === \"object\" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];\n    output.push(`@${field} ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n  }\n\n  if (Array.isArray(schemaObject.examples)) {\n    for (const example of schemaObject.examples) {\n      const serialized = typeof example === \"object\" ? JSON.stringify(example, null, 2) : example;\n      output.push(`@example ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n    }\n  }\n\n  // JSDoc 'Constant' without value\n  if (\"const\" in schemaObject) {\n    output.push(\"@constant\");\n  }\n\n  // JSDoc 'Enum' with type\n  if (schemaObject.enum) {\n    let type = \"unknown\";\n    if (Array.isArray(schemaObject.type)) {\n      type = schemaObject.type.join(\"|\");\n    } else if (typeof schemaObject.type === \"string\") {\n      type = schemaObject.type;\n    }\n    output.push(`@enum {${type}${schemaObject.nullable ? \"|null\" : \"\"}}`);\n  }\n\n  // attach comment if it has content\n\n  if (output.length) {\n    // Check if any output item contains multi-line content (has internal line breaks)\n    const hasMultiLineContent = output.some((item) => item.includes(\"\\n\"));\n\n    let text =\n      output.length === 1 && !hasMultiLineContent ? `* ${output.join(\"\\n\")} ` : `*\\n * ${output.join(\"\\n * \")}\\n `;\n    text = text.replace(COMMENT_RE, \"*\\\\/\"); // prevent inner comments from leaking\n\n    ts.addSyntheticLeadingComment(\n      /* node               */ node,\n      /* kind               */ ts.SyntaxKind.MultiLineCommentTrivia, // note: MultiLine just refers to a \"/* */\" comment\n      /* text               */ text,\n      /* hasTrailingNewLine */ true,\n    );\n  }\n}\n\nfunction isOasRef<T>(obj: Referenced<T>): obj is OasRef {\n  return Boolean((obj as OasRef).$ref);\n}\ntype OapiRefResolved = Referenced<ParameterObject>;\n\nfunction isParameterObject(obj: OapiRefResolved | undefined): obj is ParameterObject {\n  return Boolean(obj && !isOasRef(obj) && obj.in);\n}\n\nfunction addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode, ...segments: readonly string[]) {\n  return segments.reduce((acc, segment) => {\n    return ts.factory.createIndexedAccessTypeNode(\n      acc,\n      ts.factory.createLiteralTypeNode(\n        typeof segment === \"number\"\n          ? ts.factory.createNumericLiteral(segment)\n          : ts.factory.createStringLiteral(segment),\n      ),\n    );\n  }, node);\n}\n\n/**\n * Convert OpenAPI ref into TS indexed access node (ex: `components[\"schemas\"][\"Foo\"]`)\n * `path` is a JSON Pointer to a location within an OpenAPI document.\n * Transform it into a TypeScript type reference into the generated types.\n *\n * In most cases the structures of the openapi-typescript generated types and the\n * JSON Pointer paths into the OpenAPI document are the same. However, in some cases\n * special transformations are necessary to account for the ways they differ.\n *   * Object schemas\n *       $refs into the `properties` of object schemas are valid, but openapi-typescript\n *       flattens these objects, so we omit  so the index into the schema skips [\"properties\"]\n *   * Parameters\n *       $refs into the `parameters` of paths are valid, but openapi-ts represents\n *       them according to their type; path, query, header, etc… so in these cases we\n *       must check the parameter definition to determine the how to index into\n *       the openapi-typescript type.\n **/\nexport function oapiRef(path: string, resolved?: OapiRefResolved, deep = false): ts.TypeNode {\n  const { pointer } = parseRef(path);\n  if (pointer.length === 0) {\n    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);\n  }\n\n  const parametersObject = isParameterObject(resolved);\n\n  // Initial segments are handled in a fixed , then remaining segments are treated\n  // according to heuristics based on the initial segments\n  const initialSegment = pointer[0];\n  const leadingSegments = pointer.slice(1, 3);\n  const restSegments = pointer.slice(3);\n\n  const leadingType = addIndexedAccess(\n    ts.factory.createTypeReferenceNode(\n      ts.factory.createIdentifier(deep ? `FlattenedDeepRequired<${String(initialSegment)}>` : String(initialSegment)),\n    ),\n    ...leadingSegments,\n  );\n\n  return restSegments.reduce<ts.TypeReferenceNode | ts.IndexedAccessTypeNode>((acc, segment, index, original) => {\n    // Skip `properties` items when in the middle of the pointer\n    // See: https://github.com/openapi-ts/openapi-typescript/issues/1742\n    if (segment === \"properties\") {\n      return acc;\n    }\n\n    if (parametersObject && index === original.length - 1) {\n      return addIndexedAccess(acc, resolved.in, resolved.name);\n    }\n\n    return addIndexedAccess(acc, segment);\n  }, leadingType);\n}\n\nexport interface AstToStringOptions {\n  fileName?: string;\n  sourceText?: string;\n  formatOptions?: ts.PrinterOptions;\n}\n\n/** Convert TypeScript AST to string */\nexport function astToString(\n  ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[],\n  options?: AstToStringOptions,\n): string {\n  const sourceFile = ts.createSourceFile(\n    options?.fileName ?? \"openapi-ts.ts\",\n    options?.sourceText ?? \"\",\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\n  // @ts-expect-error it’s OK to overwrite statements once\n  sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);\n\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    ...options?.formatOptions,\n  });\n  return printer.printFile(sourceFile);\n}\n\n/** Convert an arbitrary string to TS (assuming it’s valid) */\nexport function stringToAST(source: string): unknown[] {\n  return ts.createSourceFile(\n    /* fileName        */ \"stringInput\",\n    /* sourceText      */ source,\n    /* languageVersion */ ts.ScriptTarget.ESNext,\n    /* setParentNodes  */ undefined,\n    /* scriptKind      */ undefined,\n  ).statements as any;\n}\n\n/**\n * Deduplicate simple primitive types from an array of nodes\n * Note: won’t deduplicate complex types like objects\n */\nexport function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[] {\n  const encounteredTypes = new Set<number>();\n  const filteredTypes: ts.TypeNode[] = [];\n  for (const t of types) {\n    // only mark for deduplication if this is not a const (\"text\" means it is a const)\n    if (!(\"text\" in ((t as LiteralTypeNode).literal ?? t))) {\n      const { kind } = (t as LiteralTypeNode).literal ?? t;\n      if (encounteredTypes.has(kind)) {\n        continue;\n      }\n      if (tsIsPrimitive(t)) {\n        encounteredTypes.add(kind);\n      }\n    }\n    filteredTypes.push(t);\n  }\n  return filteredTypes;\n}\n\nexport const enumCache = new Map<string, ts.EnumDeclaration>();\n\n/** Create a TS enum (with sanitized name and members) */\nexport function tsEnum(\n  name: string,\n  members: (string | number)[],\n  metadata?: { name?: string; description?: string | null }[],\n  options?: { export?: boolean; shouldCache?: boolean },\n) {\n  let enumName = sanitizeMemberName(name);\n  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;\n  let key = \"\";\n  if (options?.shouldCache) {\n    key = `${members\n      .slice(0)\n      .sort()\n      .map((v, i) => {\n        return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || \"\"}`;\n      })\n      .join(\",\")}`;\n    if (enumCache.has(key)) {\n      return enumCache.get(key) as ts.EnumDeclaration;\n    }\n  }\n  const enumDeclaration = ts.factory.createEnumDeclaration(\n    /* modifiers */ options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    /* name      */ enumName,\n    /* members   */ members.map((value, i) => tsEnumMember(value, metadata?.[i])),\n  );\n  options?.shouldCache && enumCache.set(key, enumDeclaration);\n  return enumDeclaration;\n}\n\n/** Create an exported TS array literal expression  */\nexport function tsArrayLiteralExpression(\n  name: string,\n  elementType: ts.TypeNode,\n  values: (string | number)[],\n  options?: { export?: boolean; readonly?: boolean; injectFooter?: ts.Node[] },\n) {\n  let variableName = sanitizeMemberName(name);\n  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;\n\n  if (\n    options?.injectFooter &&\n    !options.injectFooter.some(\n      (node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"FlattenedDeepRequired\",\n    )\n  ) {\n    const helper = stringToAST(\n      \"type FlattenedDeepRequired<T> = { [K in keyof T]-?: FlattenedDeepRequired<T[K] extends unknown[] | undefined | null ? Extract<T[K], unknown[]>[number] : T[K]>; };\",\n    )[0] as any;\n    options.injectFooter.push(helper);\n  }\n\n  const arrayType = options?.readonly\n    ? tsReadonlyArray(elementType, options.injectFooter)\n    : ts.factory.createArrayTypeNode(elementType);\n\n  return ts.factory.createVariableStatement(\n    options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    ts.factory.createVariableDeclarationList(\n      [\n        ts.factory.createVariableDeclaration(\n          variableName,\n          undefined,\n          arrayType,\n          ts.factory.createArrayLiteralExpression(\n            values.map((value) => {\n              if (typeof value === \"number\") {\n                if (value < 0) {\n                  return ts.factory.createPrefixUnaryExpression(\n                    ts.SyntaxKind.MinusToken,\n                    ts.factory.createNumericLiteral(Math.abs(value)),\n                  );\n                } else {\n                  return ts.factory.createNumericLiteral(value);\n                }\n              } else {\n                return ts.factory.createStringLiteral(value);\n              }\n            }),\n          ),\n        ),\n      ],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\nfunction sanitizeMemberName(name: string) {\n  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {\n    const last = c[c.length - 1];\n    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? \"\" : last.toUpperCase();\n  });\n  if (Number(name[0]) >= 0) {\n    sanitizedName = `Value${name}`;\n  }\n  return sanitizedName;\n}\n\n/** Sanitize TS enum member expression */\nexport function tsEnumMember(value: string | number, metadata: { name?: string; description?: string | null } = {}) {\n  let name = metadata.name ?? String(value);\n  if (!JS_PROPERTY_INDEX_RE.test(name)) {\n    if (Number(name[0]) >= 0) {\n      name = `Value${name}`.replace(\".\", \"_\"); // don't forged decimals;\n    } else if (name[0] === \"-\") {\n      name = `ValueMinus${name.slice(1)}`;\n    }\n\n    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);\n    if (invalidCharMatch) {\n      if (invalidCharMatch[0] === name) {\n        name = `\"${name}\"`;\n      } else {\n        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {\n          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : \"_\";\n        });\n      }\n    }\n  }\n\n  let member: ts.EnumMember;\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n\n    member = ts.factory.createEnumMember(name, literal);\n  } else {\n    member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));\n  }\n\n  const trimmedDescription = metadata.description?.trim();\n  if (trimmedDescription === undefined || trimmedDescription === null || trimmedDescription === \"\") {\n    return member;\n  }\n\n  return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, ` ${trimmedDescription}`, true);\n}\n\n/** Create an intersection type */\nexport function tsIntersection(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createIntersectionTypeNode(tsDedupe(types));\n}\n\n/** Is this a primitive type (string, number, boolean, null, undefined)? */\nexport function tsIsPrimitive(type: ts.TypeNode): boolean {\n  if (!type) {\n    return true;\n  }\n  return (\n    ts.SyntaxKind[type.kind] === \"BooleanKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NeverKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NullKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NumberKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"StringKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"UndefinedKeyword\" ||\n    (\"literal\" in type && tsIsPrimitive(type.literal as TypeLiteralNode))\n  );\n}\n\n/** Create a literal type */\nexport function tsLiteral(value: unknown): ts.TypeNode {\n  if (typeof value === \"string\") {\n    // workaround for UTF-8: https://github.com/microsoft/TypeScript/issues/36174\n    return ts.factory.createIdentifier(JSON.stringify(value)) as unknown as ts.TypeNode;\n  }\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n    return ts.factory.createLiteralTypeNode(literal);\n  }\n  if (typeof value === \"boolean\") {\n    return value === true ? TRUE : FALSE;\n  }\n  if (value === null) {\n    return NULL;\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return ts.factory.createArrayTypeNode(NEVER);\n    }\n    return ts.factory.createTupleTypeNode(value.map((v: unknown) => tsLiteral(v)));\n  }\n  if (typeof value === \"object\") {\n    const keys: ts.TypeElement[] = [];\n    for (const [k, v] of Object.entries(value)) {\n      keys.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ tsLiteral(v),\n        ),\n      );\n    }\n    return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);\n  }\n  return UNKNOWN;\n}\n\n/** Modifiers (readonly) */\nexport function tsModifiers(modifiers: { readonly?: boolean; export?: boolean }): ts.Modifier[] {\n  const typeMods: ts.Modifier[] = [];\n  if (modifiers.export) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));\n  }\n  if (modifiers.readonly) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));\n  }\n  return typeMods;\n}\n\n/** Create a T | null union */\nexport function tsNullable(types: ts.TypeNode[]): ts.TypeNode {\n  return ts.factory.createUnionTypeNode([...types, NULL]);\n}\n\n/** Create a TS Omit<X, Y> type */\nexport function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Omit\"), [\n    type,\n    ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/** Create a TS Record<X, Y> type */\nexport function tsRecord(key: ts.TypeNode, value: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Record\"), [key, value]);\n}\n\n/** Create a valid property index */\nexport function tsPropertyIndex(index: string | number) {\n  if (\n    (typeof index === \"number\" && !(index < 0)) ||\n    (typeof index === \"string\" && String(Number(index)) === index && index[0] !== \"-\")\n  ) {\n    return ts.factory.createNumericLiteral(index);\n  }\n  return typeof index === \"string\" && JS_PROPERTY_INDEX_RE.test(index)\n    ? ts.factory.createIdentifier(index)\n    : ts.factory.createStringLiteral(String(index));\n}\n\n/** Create a union type */\nexport function tsUnion(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createUnionTypeNode(tsDedupe(types));\n}\n\n/** Create a WithRequired<X, Y> type */\nexport function tsWithRequired(\n  type: ts.TypeNode,\n  keys: string[],\n  injectFooter: ts.Node[], // needed to inject type helper if used\n): ts.TypeNode {\n  if (keys.length === 0) {\n    return type;\n  }\n\n  // inject helper, if needed\n  if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"WithRequired\")) {\n    const helper = stringToAST(\"type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\")[0] as any;\n    injectFooter.push(helper);\n  }\n\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"WithRequired\"), [\n    type,\n    tsUnion(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/**\n * Enhanced ReadonlyArray.\n * eg: type Foo = ReadonlyArray<T>; type Bar = ReadonlyArray<T[]>\n * Foo and Bar are both of type `readonly T[]`\n */\nexport function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode {\n  if (\n    injectFooter &&\n    !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"ReadonlyArray\")\n  ) {\n    const helper = stringToAST(\n      \"type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;\",\n    )[0] as any;\n    injectFooter.push(helper);\n  }\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"ReadonlyArray\"), [type]);\n}\n"],"names":[],"mappings":";;;AAKO,MAAM,oBAAuB,GAAA;AAC7B,MAAM,wBAA2B,GAAA;AACjC,MAAM,kCAAqC,GAAA;AAC3C,MAAM,qBAAgD,GAAA;AAAA,EAC3D,GAAK,EAAA;AAAA;AAEP;AAEO,MAAM,UAAU,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,cAAc;AAC7E,MAAM,QAAQ,EAAG,CAAA,OAAA,CAAQ,sBAAsB,EAAG,CAAA,OAAA,CAAQ,aAAa;AACvE,MAAM,QAAQ,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,YAAY;AACzE,MAAM,OAAO,EAAG,CAAA,OAAA,CAAQ,sBAAsB,EAAG,CAAA,OAAA,CAAQ,YAAY;AACrE,MAAM,SAAS,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,aAAa;AAC3E,MAAM,iBAAiB,EAAG,CAAA,OAAA,CAAQ,WAAY,CAAA,EAAA,CAAG,WAAW,aAAa;AACzE,MAAM,SAAS,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,aAAa;AAC3E,MAAM,OAAO,EAAG,CAAA,OAAA,CAAQ,sBAAsB,EAAG,CAAA,OAAA,CAAQ,YAAY;AACrE,MAAM,YAAY,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,gBAAgB;AACjF,MAAM,UAAU,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,cAAc;AAEpF,MAAM,KAAQ,GAAA,QAAA;AACd,MAAM,UAAa,GAAA,OAAA;AAsBH,SAAA,eAAA,CAAgB,cAAqC,IAAkC,EAAA;AACrG,EAAI,IAAA,CAAC,gBAAgB,OAAO,YAAA,KAAiB,YAAY,KAAM,CAAA,OAAA,CAAQ,YAAY,CAAG,EAAA;AACpF,IAAA;AAAA;AAEF,EAAA,MAAM,SAAmB,EAAC;AAG1B,EAAA,IAAI,aAAa,KAAO,EAAA;AACtB,IAAO,MAAA,CAAA,IAAA,CAAK,aAAa,KAAM,CAAA,IAAA,GAAO,OAAQ,CAAA,KAAA,EAAO,WAAW,CAAC,CAAA;AAAA;AAEnE,EAAA,IAAI,aAAa,OAAS,EAAA;AACxB,IAAO,MAAA,CAAA,IAAA,CAAK,aAAa,OAAQ,CAAA,IAAA,GAAO,OAAQ,CAAA,KAAA,EAAO,WAAW,CAAC,CAAA;AAAA;AAErE,EAAA,IAAI,aAAa,MAAQ,EAAA;AACvB,IAAA,MAAA,CAAO,IAAK,CAAA,CAAA,QAAA,EAAW,YAAa,CAAA,MAAM,CAAE,CAAA,CAAA;AAAA;AAK9C,EAAA,IAAI,aAAa,UAAY,EAAA;AAC3B,IAAA,MAAA,CAAO,KAAK,aAAa,CAAA;AAAA;AAI3B,EAAA,MAAM,kBAAqB,GAAA,CAAC,aAAe,EAAA,SAAA,EAAW,SAAS,CAAA;AAC/D,EAAA,KAAA,MAAW,SAAS,kBAAoB,EAAA;AACtC,IAAM,MAAA,gBAAA,GAAmB,KAAU,KAAA,SAAA,IAAa,KAAU,KAAA,SAAA;AAC1D,IAAI,IAAA,YAAA,CAAa,KAAK,CAAA,KAAM,MAAW,EAAA;AACrC,MAAA;AAAA;AAEF,IAAA,IAAI,YAAa,CAAA,KAAK,CAAM,KAAA,EAAA,IAAM,CAAC,gBAAkB,EAAA;AACnD,MAAA;AAAA;AAEF,IAAA,MAAM,UACJ,GAAA,OAAO,YAAa,CAAA,KAAK,MAAM,QAAW,GAAA,IAAA,CAAK,SAAU,CAAA,YAAA,CAAa,KAAK,CAAG,EAAA,IAAA,EAAM,CAAC,CAAA,GAAI,aAAa,KAAK,CAAA;AAC7G,IAAA,MAAA,CAAO,IAAK,CAAA,CAAA,CAAA,EAAI,KAAK,CAAA,CAAA,EAAI,MAAO,CAAA,UAAU,CAAE,CAAA,IAAA,EAAO,CAAA,OAAA,CAAQ,KAAO,EAAA,WAAW,CAAC,CAAE,CAAA,CAAA;AAAA;AAGlF,EAAA,IAAI,KAAM,CAAA,OAAA,CAAQ,YAAa,CAAA,QAAQ,CAAG,EAAA;AACxC,IAAW,KAAA,MAAA,OAAA,IAAW,aAAa,QAAU,EAAA;AAC3C,MAAM,MAAA,UAAA,GAAa,OAAO,OAAY,KAAA,QAAA,GAAW,KAAK,SAAU,CAAA,OAAA,EAAS,IAAM,EAAA,CAAC,CAAI,GAAA,OAAA;AACpF,MAAO,MAAA,CAAA,IAAA,CAAK,CAAY,SAAA,EAAA,MAAA,CAAO,UAAU,CAAA,CAAE,IAAK,EAAA,CAAE,OAAQ,CAAA,KAAA,EAAO,WAAW,CAAC,CAAE,CAAA,CAAA;AAAA;AACjF;AAIF,EAAA,IAAI,WAAW,YAAc,EAAA;AAC3B,IAAA,MAAA,CAAO,KAAK,WAAW,CAAA;AAAA;AAIzB,EAAA,IAAI,aAAa,IAAM,EAAA;AACrB,IAAA,IAAI,IAAO,GAAA,SAAA;AACX,IAAA,IAAI,KAAM,CAAA,OAAA,CAAQ,YAAa,CAAA,IAAI,CAAG,EAAA;AACpC,MAAO,IAAA,GAAA,YAAA,CAAa,IAAK,CAAA,IAAA,CAAK,GAAG,CAAA;AAAA,KACxB,MAAA,IAAA,OAAO,YAAa,CAAA,IAAA,KAAS,QAAU,EAAA;AAChD,MAAA,IAAA,GAAO,YAAa,CAAA,IAAA;AAAA;AAEtB,IAAO,MAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,EAAG,aAAa,QAAW,GAAA,OAAA,GAAU,EAAE,CAAG,CAAA,CAAA,CAAA;AAAA;AAKtE,EAAA,IAAI,OAAO,MAAQ,EAAA;AAEjB,IAAM,MAAA,mBAAA,GAAsB,OAAO,IAAK,CAAA,CAAC,SAAS,IAAK,CAAA,QAAA,CAAS,IAAI,CAAC,CAAA;AAErE,IAAI,IAAA,IAAA,GACF,MAAO,CAAA,MAAA,KAAW,CAAK,IAAA,CAAC,mBAAsB,GAAA,CAAA,EAAA,EAAK,MAAO,CAAA,IAAA,CAAK,IAAI,CAAC,CAAM,CAAA,CAAA,GAAA,CAAA;AAAA,GAAS,EAAA,MAAA,CAAO,IAAK,CAAA,OAAO,CAAC;AAAA,CAAA,CAAA;AACzG,IAAO,IAAA,GAAA,IAAA,CAAK,OAAQ,CAAA,UAAA,EAAY,MAAM,CAAA;AAEtC,IAAG,EAAA,CAAA,0BAAA;AAAA;AAAA,MACwB,IAAA;AAAA;AAAA,MACA,GAAG,UAAW,CAAA,sBAAA;AAAA;AAAA;AAAA,MACd,IAAA;AAAA;AAAA,MACA;AAAA,KAC3B;AAAA;AAEJ;AAEA,SAAS,SAAY,GAAmC,EAAA;AACtD,EAAO,OAAA,OAAA,CAAS,IAAe,IAAI,CAAA;AACrC;AAGA,SAAS,kBAAkB,GAA0D,EAAA;AACnF,EAAA,OAAO,QAAQ,GAAO,IAAA,CAAC,SAAS,GAAG,CAAA,IAAK,IAAI,EAAE,CAAA;AAChD;AAEA,SAAS,gBAAA,CAAiB,SAA0D,QAA6B,EAAA;AAC/G,EAAA,OAAO,QAAS,CAAA,MAAA,CAAO,CAAC,GAAA,EAAK,OAAY,KAAA;AACvC,IAAA,OAAO,GAAG,OAAQ,CAAA,2BAAA;AAAA,MAChB,GAAA;AAAA,MACA,GAAG,OAAQ,CAAA,qBAAA;AAAA,QACT,OAAO,OAAY,KAAA,QAAA,GACf,EAAG,CAAA,OAAA,CAAQ,oBAAqB,CAAA,OAAO,CACvC,GAAA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,OAAO;AAAA;AAC5C,KACF;AAAA,KACC,IAAI,CAAA;AACT;AAmBO,SAAS,OAAQ,CAAA,IAAA,EAAc,QAA4B,EAAA,IAAA,GAAO,KAAoB,EAAA;AAC3F,EAAA,MAAM,EAAE,OAAA,EAAY,GAAA,QAAA,CAAS,IAAI,CAAA;AACjC,EAAI,IAAA,OAAA,CAAQ,WAAW,CAAG,EAAA;AACxB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAuB,oBAAA,EAAA,IAAI,CAAyB,uBAAA,CAAA,CAAA;AAAA;AAGtE,EAAM,MAAA,gBAAA,GAAmB,kBAAkB,QAAQ,CAAA;AAInD,EAAM,MAAA,cAAA,GAAiB,QAAQ,CAAC,CAAA;AAChC,EAAA,MAAM,eAAkB,GAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,EAAG,CAAC,CAAA;AAC1C,EAAM,MAAA,YAAA,GAAe,OAAQ,CAAA,KAAA,CAAM,CAAC,CAAA;AAEpC,EAAA,MAAM,WAAc,GAAA,gBAAA;AAAA,IAClB,GAAG,OAAQ,CAAA,uBAAA;AAAA,MACT,EAAA,CAAG,OAAQ,CAAA,gBAAA,CAAiB,IAAO,GAAA,CAAA,sBAAA,EAAyB,MAAO,CAAA,cAAc,CAAC,CAAA,CAAA,CAAA,GAAM,MAAO,CAAA,cAAc,CAAC;AAAA,KAChH;AAAA,IACA,GAAG;AAAA,GACL;AAEA,EAAA,OAAO,aAAa,MAAwD,CAAA,CAAC,GAAK,EAAA,OAAA,EAAS,OAAO,QAAa,KAAA;AAG7G,IAAA,IAAI,YAAY,YAAc,EAAA;AAC5B,MAAO,OAAA,GAAA;AAAA;AAGT,IAAA,IAAI,gBAAoB,IAAA,KAAA,KAAU,QAAS,CAAA,MAAA,GAAS,CAAG,EAAA;AACrD,MAAA,OAAO,gBAAiB,CAAA,GAAA,EAAK,QAAS,CAAA,EAAA,EAAI,SAAS,IAAI,CAAA;AAAA;AAGzD,IAAO,OAAA,gBAAA,CAAiB,KAAK,OAAO,CAAA;AAAA,KACnC,WAAW,CAAA;AAChB;AASgB,SAAA,WAAA,CACd,KACA,OACQ,EAAA;AACR,EAAA,MAAM,aAAa,EAAG,CAAA,gBAAA;AAAA,IACpB,SAAS,QAAY,IAAA,eAAA;AAAA,IACrB,SAAS,UAAc,IAAA,EAAA;AAAA,IACvB,GAAG,YAAa,CAAA,MAAA;AAAA,IAChB,KAAA;AAAA,IACA,GAAG,UAAW,CAAA;AAAA,GAChB;AAGA,EAAW,UAAA,CAAA,UAAA,GAAa,EAAG,CAAA,OAAA,CAAQ,eAAgB,CAAA,KAAA,CAAM,OAAQ,CAAA,GAAG,CAAI,GAAA,GAAA,GAAM,CAAC,GAAG,CAAC,CAAA;AAEnF,EAAM,MAAA,OAAA,GAAU,GAAG,aAAc,CAAA;AAAA,IAC/B,OAAA,EAAS,GAAG,WAAY,CAAA,QAAA;AAAA,IACxB,cAAgB,EAAA,KAAA;AAAA,IAChB,GAAG,OAAS,EAAA;AAAA,GACb,CAAA;AACD,EAAO,OAAA,OAAA,CAAQ,UAAU,UAAU,CAAA;AACrC;AAGO,SAAS,YAAY,MAA2B,EAAA;AACrD,EAAA,OAAO,EAAG,CAAA,gBAAA;AAAA;AAAA,IACc,aAAA;AAAA;AAAA,IACA,MAAA;AAAA;AAAA,IACA,GAAG,YAAa,CAAA,MAAA;AAAA;AAAA,IAChB,MAAA;AAAA;AAAA,IACA;AAAA,GACtB,CAAA,UAAA;AACJ;AAMO,SAAS,SAAS,KAAqC,EAAA;AAC5D,EAAM,MAAA,gBAAA,uBAAuB,GAAY,EAAA;AACzC,EAAA,MAAM,gBAA+B,EAAC;AACtC,EAAA,KAAA,MAAW,KAAK,KAAO,EAAA;AAErB,IAAA,IAAI,EAAE,MAAA,KAAY,CAAsB,CAAA,OAAA,IAAW,CAAK,CAAA,CAAA,EAAA;AACtD,MAAA,MAAM,EAAE,IAAA,EAAU,GAAA,CAAA,CAAsB,OAAW,IAAA,CAAA;AACnD,MAAI,IAAA,gBAAA,CAAiB,GAAI,CAAA,IAAI,CAAG,EAAA;AAC9B,QAAA;AAAA;AAEF,MAAI,IAAA,aAAA,CAAc,CAAC,CAAG,EAAA;AACpB,QAAA,gBAAA,CAAiB,IAAI,IAAI,CAAA;AAAA;AAC3B;AAEF,IAAA,aAAA,CAAc,KAAK,CAAC,CAAA;AAAA;AAEtB,EAAO,OAAA,aAAA;AACT;AAEa,MAAA,SAAA,uBAAgB,GAAgC;AAGtD,SAAS,MACd,CAAA,IAAA,EACA,OACA,EAAA,QAAA,EACA,OACA,EAAA;AACA,EAAI,IAAA,QAAA,GAAW,mBAAmB,IAAI,CAAA;AACtC,EAAW,QAAA,GAAA,CAAA,EAAG,QAAS,CAAA,CAAC,CAAE,CAAA,WAAA,EAAa,CAAG,EAAA,QAAA,CAAS,SAAU,CAAA,CAAC,CAAC,CAAA,CAAA;AAC/D,EAAA,IAAI,GAAM,GAAA,EAAA;AACV,EAAA,IAAI,SAAS,WAAa,EAAA;AACxB,IAAM,GAAA,GAAA,CAAA,EAAG,OACN,CAAA,KAAA,CAAM,CAAC,CAAA,CACP,MACA,CAAA,GAAA,CAAI,CAAC,CAAA,EAAG,CAAM,KAAA;AACb,MAAA,OAAO,CAAG,EAAA,QAAA,GAAW,CAAC,CAAA,EAAG,IAAQ,IAAA,MAAA,CAAO,CAAC,CAAC,CAAI,CAAA,EAAA,QAAA,GAAW,CAAC,CAAA,EAAG,eAAe,EAAE,CAAA,CAAA;AAAA,KAC/E,CAAA,CACA,IAAK,CAAA,GAAG,CAAC,CAAA,CAAA;AACZ,IAAI,IAAA,SAAA,CAAU,GAAI,CAAA,GAAG,CAAG,EAAA;AACtB,MAAO,OAAA,SAAA,CAAU,IAAI,GAAG,CAAA;AAAA;AAC1B;AAEF,EAAM,MAAA,eAAA,GAAkB,GAAG,OAAQ,CAAA,qBAAA;AAAA;AAAA,IACjB,OAAA,GAAU,YAAY,EAAE,MAAA,EAAQ,QAAQ,MAAU,IAAA,KAAA,EAAO,CAAI,GAAA,MAAA;AAAA;AAAA,IAC7D,QAAA;AAAA;AAAA,IACA,OAAA,CAAQ,GAAI,CAAA,CAAC,KAAO,EAAA,CAAA,KAAM,aAAa,KAAO,EAAA,QAAA,GAAW,CAAC,CAAC,CAAC;AAAA,GAC9E;AACA,EAAA,OAAA,EAAS,WAAe,IAAA,SAAA,CAAU,GAAI,CAAA,GAAA,EAAK,eAAe,CAAA;AAC1D,EAAO,OAAA,eAAA;AACT;AAGO,SAAS,wBACd,CAAA,IAAA,EACA,WACA,EAAA,MAAA,EACA,OACA,EAAA;AACA,EAAI,IAAA,YAAA,GAAe,mBAAmB,IAAI,CAAA;AAC1C,EAAe,YAAA,GAAA,CAAA,EAAG,YAAa,CAAA,CAAC,CAAE,CAAA,WAAA,EAAa,CAAG,EAAA,YAAA,CAAa,SAAU,CAAA,CAAC,CAAC,CAAA,CAAA;AAE3E,EAAA,IACE,OAAS,EAAA,YAAA,IACT,CAAC,OAAA,CAAQ,YAAa,CAAA,IAAA;AAAA,IACpB,CAAC,SAAS,EAAG,CAAA,sBAAA,CAAuB,IAAI,CAAK,IAAA,IAAA,EAAM,MAAM,WAAgB,KAAA;AAAA,GAE3E,EAAA;AACA,IAAA,MAAM,MAAS,GAAA,WAAA;AAAA,MACb;AAAA,MACA,CAAC,CAAA;AACH,IAAQ,OAAA,CAAA,YAAA,CAAa,KAAK,MAAM,CAAA;AAAA;AAGlC,EAAM,MAAA,SAAA,GAAY,OAAS,EAAA,QAAA,GACvB,eAAgB,CAAA,WAAA,EAAa,OAAQ,CAAA,YAAY,CACjD,GAAA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,WAAW,CAAA;AAE9C,EAAA,OAAO,GAAG,OAAQ,CAAA,uBAAA;AAAA,IAChB,OAAA,GAAU,YAAY,EAAE,MAAA,EAAQ,QAAQ,MAAU,IAAA,KAAA,EAAO,CAAI,GAAA,MAAA;AAAA,IAC7D,GAAG,OAAQ,CAAA,6BAAA;AAAA,MACT;AAAA,QACE,GAAG,OAAQ,CAAA,yBAAA;AAAA,UACT,YAAA;AAAA,UACA,MAAA;AAAA,UACA,SAAA;AAAA,UACA,GAAG,OAAQ,CAAA,4BAAA;AAAA,YACT,MAAA,CAAO,GAAI,CAAA,CAAC,KAAU,KAAA;AACpB,cAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,gBAAA,IAAI,QAAQ,CAAG,EAAA;AACb,kBAAA,OAAO,GAAG,OAAQ,CAAA,2BAAA;AAAA,oBAChB,GAAG,UAAW,CAAA,UAAA;AAAA,oBACd,GAAG,OAAQ,CAAA,oBAAA,CAAqB,IAAK,CAAA,GAAA,CAAI,KAAK,CAAC;AAAA,mBACjD;AAAA,iBACK,MAAA;AACL,kBAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,oBAAA,CAAqB,KAAK,CAAA;AAAA;AAC9C,eACK,MAAA;AACL,gBAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,KAAK,CAAA;AAAA;AAC7C,aACD;AAAA;AACH;AACF,OACF;AAAA,MACA,GAAG,SAAU,CAAA;AAAA;AACf,GACF;AACF;AAEA,SAAS,mBAAmB,IAAc,EAAA;AACxC,EAAA,IAAI,aAAgB,GAAA,IAAA,CAAK,OAAQ,CAAA,wBAAA,EAA0B,CAAC,CAAM,KAAA;AAChE,IAAA,MAAM,IAAO,GAAA,CAAA,CAAE,CAAE,CAAA,MAAA,GAAS,CAAC,CAAA;AAC3B,IAAA,OAAO,mCAAmC,IAAK,CAAA,IAAI,CAAI,GAAA,EAAA,GAAK,KAAK,WAAY,EAAA;AAAA,GAC9E,CAAA;AACD,EAAA,IAAI,MAAO,CAAA,IAAA,CAAK,CAAC,CAAC,KAAK,CAAG,EAAA;AACxB,IAAA,aAAA,GAAgB,QAAQ,IAAI,CAAA,CAAA;AAAA;AAE9B,EAAO,OAAA,aAAA;AACT;AAGO,SAAS,YAAa,CAAA,KAAA,EAAwB,QAA2D,GAAA,EAAI,EAAA;AAClH,EAAA,IAAI,IAAO,GAAA,QAAA,CAAS,IAAQ,IAAA,MAAA,CAAO,KAAK,CAAA;AACxC,EAAA,IAAI,CAAC,oBAAA,CAAqB,IAAK,CAAA,IAAI,CAAG,EAAA;AACpC,IAAA,IAAI,MAAO,CAAA,IAAA,CAAK,CAAC,CAAC,KAAK,CAAG,EAAA;AACxB,MAAA,IAAA,GAAO,CAAQ,KAAA,EAAA,IAAI,CAAG,CAAA,CAAA,OAAA,CAAQ,KAAK,GAAG,CAAA;AAAA,KAC7B,MAAA,IAAA,IAAA,CAAK,CAAC,CAAA,KAAM,GAAK,EAAA;AAC1B,MAAA,IAAA,GAAO,CAAa,UAAA,EAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA;AAGnC,IAAM,MAAA,gBAAA,GAAmB,IAAK,CAAA,KAAA,CAAM,kCAAkC,CAAA;AACtE,IAAA,IAAI,gBAAkB,EAAA;AACpB,MAAI,IAAA,gBAAA,CAAiB,CAAC,CAAA,KAAM,IAAM,EAAA;AAChC,QAAA,IAAA,GAAO,IAAI,IAAI,CAAA,CAAA,CAAA;AAAA,OACV,MAAA;AACL,QAAA,IAAA,GAAO,IAAK,CAAA,OAAA,CAAQ,kCAAoC,EAAA,CAAC,CAAM,KAAA;AAC7D,UAAA,OAAO,CAAK,IAAA,qBAAA,GAAwB,qBAAsB,CAAA,CAAC,CAAI,GAAA,GAAA;AAAA,SAChE,CAAA;AAAA;AACH;AACF;AAGF,EAAI,IAAA,MAAA;AACJ,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,IAAA,MAAM,OACJ,GAAA,KAAA,GAAQ,CACJ,GAAA,EAAA,CAAG,OAAQ,CAAA,2BAAA;AAAA,MACT,GAAG,UAAW,CAAA,UAAA;AAAA,MACd,GAAG,OAAQ,CAAA,oBAAA,CAAqB,IAAK,CAAA,GAAA,CAAI,KAAK,CAAC;AAAA,KAEjD,GAAA,EAAA,CAAG,OAAQ,CAAA,oBAAA,CAAqB,KAAK,CAAA;AAE3C,IAAA,MAAA,GAAS,EAAG,CAAA,OAAA,CAAQ,gBAAiB,CAAA,IAAA,EAAM,OAAO,CAAA;AAAA,GAC7C,MAAA;AACL,IAAS,MAAA,GAAA,EAAA,CAAG,QAAQ,gBAAiB,CAAA,IAAA,EAAM,GAAG,OAAQ,CAAA,mBAAA,CAAoB,KAAK,CAAC,CAAA;AAAA;AAGlF,EAAM,MAAA,kBAAA,GAAqB,QAAS,CAAA,WAAA,EAAa,IAAK,EAAA;AACtD,EAAA,IAAI,kBAAuB,KAAA,MAAA,IAAa,kBAAuB,KAAA,IAAA,IAAQ,uBAAuB,EAAI,EAAA;AAChG,IAAO,OAAA,MAAA;AAAA;AAGT,EAAO,OAAA,EAAA,CAAG,2BAA2B,MAAQ,EAAA,EAAA,CAAG,WAAW,uBAAyB,EAAA,CAAA,CAAA,EAAI,kBAAkB,CAAA,CAAA,EAAI,IAAI,CAAA;AACpH;AAGO,SAAS,eAAe,KAAmC,EAAA;AAChE,EAAI,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACtB,IAAO,OAAA,KAAA;AAAA;AAET,EAAI,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACtB,IAAA,OAAO,MAAM,CAAC,CAAA;AAAA;AAEhB,EAAA,OAAO,EAAG,CAAA,OAAA,CAAQ,0BAA2B,CAAA,QAAA,CAAS,KAAK,CAAC,CAAA;AAC9D;AAGO,SAAS,cAAc,IAA4B,EAAA;AACxD,EAAA,IAAI,CAAC,IAAM,EAAA;AACT,IAAO,OAAA,IAAA;AAAA;AAET,EAAA,OACE,GAAG,UAAW,CAAA,IAAA,CAAK,IAAI,CAAM,KAAA,gBAAA,IAC7B,GAAG,UAAW,CAAA,IAAA,CAAK,IAAI,CAAA,KAAM,kBAC7B,EAAG,CAAA,UAAA,CAAW,KAAK,IAAI,CAAA,KAAM,iBAC7B,EAAG,CAAA,UAAA,CAAW,IAAK,CAAA,IAAI,MAAM,eAC7B,IAAA,EAAA,CAAG,WAAW,IAAK,CAAA,IAAI,MAAM,eAC7B,IAAA,EAAA,CAAG,UAAW,CAAA,IAAA,CAAK,IAAI,CAAM,KAAA,kBAAA,IAC5B,aAAa,IAAQ,IAAA,aAAA,CAAc,KAAK,OAA0B,CAAA;AAEvE;AAGO,SAAS,UAAU,KAA6B,EAAA;AACrD,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAE7B,IAAA,OAAO,GAAG,OAAQ,CAAA,gBAAA,CAAiB,IAAK,CAAA,SAAA,CAAU,KAAK,CAAC,CAAA;AAAA;AAE1D,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,IAAA,MAAM,OACJ,GAAA,KAAA,GAAQ,CACJ,GAAA,EAAA,CAAG,OAAQ,CAAA,2BAAA;AAAA,MACT,GAAG,UAAW,CAAA,UAAA;AAAA,MACd,GAAG,OAAQ,CAAA,oBAAA,CAAqB,IAAK,CAAA,GAAA,CAAI,KAAK,CAAC;AAAA,KAEjD,GAAA,EAAA,CAAG,OAAQ,CAAA,oBAAA,CAAqB,KAAK,CAAA;AAC3C,IAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,qBAAA,CAAsB,OAAO,CAAA;AAAA;AAEjD,EAAI,IAAA,OAAO,UAAU,SAAW,EAAA;AAC9B,IAAO,OAAA,KAAA,KAAU,OAAO,IAAO,GAAA,KAAA;AAAA;AAEjC,EAAA,IAAI,UAAU,IAAM,EAAA;AAClB,IAAO,OAAA,IAAA;AAAA;AAET,EAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,KAAK,CAAG,EAAA;AACxB,IAAI,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACtB,MAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,KAAK,CAAA;AAAA;AAE7C,IAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,KAAM,CAAA,GAAA,CAAI,CAAC,CAAe,KAAA,SAAA,CAAU,CAAC,CAAC,CAAC,CAAA;AAAA;AAE/E,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,IAAA,MAAM,OAAyB,EAAC;AAChC,IAAA,KAAA,MAAW,CAAC,CAAG,EAAA,CAAC,KAAK,MAAO,CAAA,OAAA,CAAQ,KAAK,CAAG,EAAA;AAC1C,MAAK,IAAA,CAAA,IAAA;AAAA,QACH,GAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,UACW,MAAA;AAAA;AAAA,UACA,gBAAgB,CAAC,CAAA;AAAA;AAAA,UACjB,MAAA;AAAA;AAAA,UACA,UAAU,CAAC;AAAA;AACjC,OACF;AAAA;AAEF,IAAO,OAAA,IAAA,CAAK,SAAS,EAAG,CAAA,OAAA,CAAQ,sBAAsB,IAAI,CAAA,GAAI,QAAS,CAAA,MAAA,EAAQ,KAAK,CAAA;AAAA;AAEtF,EAAO,OAAA,OAAA;AACT;AAGO,SAAS,YAAY,SAAoE,EAAA;AAC9F,EAAA,MAAM,WAA0B,EAAC;AACjC,EAAA,IAAI,UAAU,MAAQ,EAAA;AACpB,IAAA,QAAA,CAAS,KAAK,EAAG,CAAA,OAAA,CAAQ,eAAe,EAAG,CAAA,UAAA,CAAW,aAAa,CAAC,CAAA;AAAA;AAEtE,EAAA,IAAI,UAAU,QAAU,EAAA;AACtB,IAAA,QAAA,CAAS,KAAK,EAAG,CAAA,OAAA,CAAQ,eAAe,EAAG,CAAA,UAAA,CAAW,eAAe,CAAC,CAAA;AAAA;AAExE,EAAO,OAAA,QAAA;AACT;AAGO,SAAS,WAAW,KAAmC,EAAA;AAC5D,EAAA,OAAO,GAAG,OAAQ,CAAA,mBAAA,CAAoB,CAAC,GAAG,KAAA,EAAO,IAAI,CAAC,CAAA;AACxD;AAGgB,SAAA,MAAA,CAAO,MAAmB,IAA6B,EAAA;AACrE,EAAA,OAAO,GAAG,OAAQ,CAAA,uBAAA,CAAwB,GAAG,OAAQ,CAAA,gBAAA,CAAiB,MAAM,CAAG,EAAA;AAAA,IAC7E,IAAA;AAAA,IACA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,IAAK,CAAA,GAAA,CAAI,CAAC,CAAM,KAAA,SAAA,CAAU,CAAC,CAAC,CAAC;AAAA,GAC7D,CAAA;AACH;AAGgB,SAAA,QAAA,CAAS,KAAkB,KAAoB,EAAA;AAC7D,EAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,uBAAA,CAAwB,EAAG,CAAA,OAAA,CAAQ,gBAAiB,CAAA,QAAQ,CAAG,EAAA,CAAC,GAAK,EAAA,KAAK,CAAC,CAAA;AAC/F;AAGO,SAAS,gBAAgB,KAAwB,EAAA;AACtD,EAAA,IACG,OAAO,KAAU,KAAA,QAAA,IAAY,EAAE,KAAQ,GAAA,CAAA,CAAA,IACvC,OAAO,KAAU,KAAA,QAAA,IAAY,MAAO,CAAA,MAAA,CAAO,KAAK,CAAC,CAAA,KAAM,SAAS,KAAM,CAAA,CAAC,MAAM,GAC9E,EAAA;AACA,IAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,oBAAA,CAAqB,KAAK,CAAA;AAAA;AAE9C,EAAA,OAAO,OAAO,KAAU,KAAA,QAAA,IAAY,oBAAqB,CAAA,IAAA,CAAK,KAAK,CAC/D,GAAA,EAAA,CAAG,OAAQ,CAAA,gBAAA,CAAiB,KAAK,CACjC,GAAA,EAAA,CAAG,QAAQ,mBAAoB,CAAA,MAAA,CAAO,KAAK,CAAC,CAAA;AAClD;AAGO,SAAS,QAAQ,KAAmC,EAAA;AACzD,EAAI,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACtB,IAAO,OAAA,KAAA;AAAA;AAET,EAAI,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACtB,IAAA,OAAO,MAAM,CAAC,CAAA;AAAA;AAEhB,EAAA,OAAO,EAAG,CAAA,OAAA,CAAQ,mBAAoB,CAAA,QAAA,CAAS,KAAK,CAAC,CAAA;AACvD;AAGgB,SAAA,cAAA,CACd,IACA,EAAA,IAAA,EACA,YACa,EAAA;AACb,EAAI,IAAA,IAAA,CAAK,WAAW,CAAG,EAAA;AACrB,IAAO,OAAA,IAAA;AAAA;AAIT,EAAA,IAAI,CAAC,YAAA,CAAa,IAAK,CAAA,CAAC,IAAS,KAAA,EAAA,CAAG,sBAAuB,CAAA,IAAI,CAAK,IAAA,IAAA,EAAM,IAAM,EAAA,WAAA,KAAgB,cAAc,CAAG,EAAA;AAC/G,IAAA,MAAM,MAAS,GAAA,WAAA,CAAY,qEAAqE,CAAA,CAAE,CAAC,CAAA;AACnG,IAAA,YAAA,CAAa,KAAK,MAAM,CAAA;AAAA;AAG1B,EAAA,OAAO,GAAG,OAAQ,CAAA,uBAAA,CAAwB,GAAG,OAAQ,CAAA,gBAAA,CAAiB,cAAc,CAAG,EAAA;AAAA,IACrF,IAAA;AAAA,IACA,OAAA,CAAQ,KAAK,GAAI,CAAA,CAAC,MAAM,SAAU,CAAA,CAAC,CAAC,CAAC;AAAA,GACtC,CAAA;AACH;AAOgB,SAAA,eAAA,CAAgB,MAAmB,YAAuC,EAAA;AACxF,EAAA,IACE,YACA,IAAA,CAAC,YAAa,CAAA,IAAA,CAAK,CAAC,IAAS,KAAA,EAAA,CAAG,sBAAuB,CAAA,IAAI,CAAK,IAAA,IAAA,EAAM,IAAM,EAAA,WAAA,KAAgB,eAAe,CAC3G,EAAA;AACA,IAAA,MAAM,MAAS,GAAA,WAAA;AAAA,MACb;AAAA,MACA,CAAC,CAAA;AACH,IAAA,YAAA,CAAa,KAAK,MAAM,CAAA;AAAA;AAE1B,EAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,uBAAA,CAAwB,EAAG,CAAA,OAAA,CAAQ,iBAAiB,eAAe,CAAA,EAAG,CAAC,IAAI,CAAC,CAAA;AAChG;;;;"}
\ No newline at end of file
diff --git a/dist/lib/utils.cjs.map b/dist/lib/utils.cjs.map
index 47bab3b9947c76adf5ed9b6a49786c9dfdf0d471..ceb4e69162d1f60cfcde0fe9b48058ecaed81cd9 100644
--- a/dist/lib/utils.cjs.map
+++ b/dist/lib/utils.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"utils.cjs","sources":["../../src/lib/utils.ts"],"sourcesContent":["import { escapePointer, parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport c from \"ansi-colors\";\nimport supportsColor from \"supports-color\";\nimport ts from \"typescript\";\nimport type { DiscriminatorObject, OpenAPI3, OpenAPITSOptions, ReferenceObject, SchemaObject } from \"../types.js\";\nimport { tsLiteral, tsModifiers, tsPropertyIndex } from \"./ts.js\";\n\nif (!supportsColor.stdout || supportsColor.stdout.hasBasic === false) {\n  c.enabled = false;\n}\n\nconst DEBUG_GROUPS: Record<string, c.StyleFunction | undefined> = {\n  redoc: c.cyanBright,\n  lint: c.yellowBright,\n  bundle: c.magentaBright,\n  ts: c.blueBright,\n};\n\nexport { c };\n\n/** Given a discriminator object, get the property name */\nexport function createDiscriminatorProperty(\n  discriminator: DiscriminatorObject,\n  { path, readonly = false }: { path: string; readonly?: boolean },\n): ts.TypeElement {\n  // get the inferred propertyName value from the last section of the path (as the spec suggests to do)\n  let value = parseRef(path).pointer.pop();\n  // if mapping, and there’s a match, use this rather than the inferred name\n  if (discriminator.mapping) {\n    // Mapping value can either be a fully-qualified ref (#/components/schemas/XYZ) or a schema name (XYZ)\n    const matchedValue = Object.entries(discriminator.mapping).find(\n      ([, v]) => (!v.startsWith(\"#\") && v === value) || (v.startsWith(\"#\") && parseRef(v).pointer.pop() === value),\n    );\n    if (matchedValue) {\n      value = matchedValue[0]; // why was this designed backwards!?\n    }\n  }\n  return ts.factory.createPropertySignature(\n    /* modifiers     */ tsModifiers({\n      readonly,\n    }),\n    /* name          */ tsPropertyIndex(discriminator.propertyName),\n    /* questionToken */ undefined,\n    /* type          */ tsLiteral(value),\n  );\n}\n\n/** Create a $ref pointer (even from other $refs) */\nexport function createRef(parts: (number | string | undefined | null)[]): string {\n  let pointer = \"#\";\n  for (const part of parts) {\n    if (part === undefined || part === null || part === \"\") {\n      continue;\n    }\n    const maybeRef = parseRef(String(part)).pointer;\n    if (maybeRef.length) {\n      for (const refPart of maybeRef) {\n        pointer += `/${escapePointer(refPart)}`;\n      }\n    } else {\n      pointer += `/${escapePointer(part)}`;\n    }\n  }\n  return pointer;\n}\n\n/** Print debug message (cribbed from the `debug` package, but without all the bells & whistles */\nexport function debug(msg: string, group?: string, time?: number) {\n  if (\n    process.env.DEBUG &&\n    (!group ||\n      process.env.DEBUG === \"*\" ||\n      process.env.DEBUG === \"openapi-ts:*\" ||\n      process.env.DEBUG.toLocaleLowerCase() === `openapi-ts:${group.toLocaleLowerCase()}`)\n  ) {\n    const groupColor = (group && DEBUG_GROUPS[group]) || c.whiteBright;\n    const groupName = groupColor(`openapi-ts:${group ?? \"info\"}`);\n    let timeFormatted = \"\";\n    if (typeof time === \"number\") {\n      timeFormatted = c.green(` ${formatTime(time)} `);\n    }\n    // biome-ignore lint/suspicious/noConsole: this is a CLI\n    console.debug(`  ${c.bold(groupName)}${timeFormatted}${msg}`);\n  }\n}\n\n/** Print error message */\nexport function error(msg: string) {\n  // biome-ignore lint/suspicious/noConsole: this is a CLI\n  console.error(c.red(` ✘  ${msg}`));\n}\n\n/** Format a performance log in a friendly format */\nexport function formatTime(t: number) {\n  if (typeof t === \"number\") {\n    if (t < 1000) {\n      return `${Math.round(10 * t) / 10}ms`;\n    }\n    if (t < 60000) {\n      return `${Math.round(t / 100) / 10}s`;\n    }\n    return `${Math.round(t / 6000) / 10}m`;\n  }\n  return t;\n}\n\n/** Call Object.entries() and optionally sort */\nexport function getEntries<T>(\n  obj: ArrayLike<T> | Record<string, T>,\n  options?: {\n    alphabetize?: boolean;\n    excludeDeprecated?: boolean;\n  },\n) {\n  let entries = Object.entries(obj);\n  if (options?.alphabetize) {\n    entries.sort(([a], [b]) => a.localeCompare(b, \"en-us\", { numeric: true }));\n  }\n  if (options?.excludeDeprecated) {\n    entries = entries.filter(([, v]) => !(v && typeof v === \"object\" && \"deprecated\" in v && v.deprecated));\n  }\n  return entries;\n}\n\n/** resolve a $ref in a schema */\nexport function resolveRef<T>(\n  schema: any,\n  $ref: string,\n  { silent = false, visited = [] }: { silent: boolean; visited?: string[] },\n): T | undefined {\n  const { pointer } = parseRef($ref);\n  if (!pointer.length) {\n    return undefined;\n  }\n  let node = schema;\n  for (const key of pointer) {\n    if (node && typeof node === \"object\" && node[key]) {\n      node = node[key];\n    } else {\n      warn(`Could not resolve $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n  }\n\n  // if this is also a $ref, keep tracing\n  if (node && typeof node === \"object\" && node.$ref) {\n    if (visited.includes(node.$ref)) {\n      warn(`Could not resolve circular $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n    return resolveRef(schema, node.$ref, {\n      silent,\n      visited: [...visited, node.$ref],\n    });\n  }\n\n  return node;\n}\n\nfunction createDiscriminatorEnum(values: string[], prevSchema?: SchemaObject): SchemaObject {\n  return {\n    type: \"string\",\n    enum: values,\n    description: prevSchema?.description\n      ? `${prevSchema.description} (enum property replaced by openapi-typescript)`\n      : \"discriminator enum property added by openapi-typescript\",\n  };\n}\n\n/** Adds or replaces the discriminator enum with the passed `values` in a schema defined by `ref` */\nfunction patchDiscriminatorEnum(\n  schema: SchemaObject,\n  ref: string,\n  values: string[],\n  discriminator: DiscriminatorObject,\n  discriminatorRef: string,\n  options: OpenAPITSOptions,\n): boolean {\n  const resolvedSchema = resolveRef<SchemaObject>(schema, ref, {\n    silent: options.silent ?? false,\n  });\n\n  if (resolvedSchema?.allOf) {\n    // if the schema is an allOf, we can append a new schema object to the allOf array\n    resolvedSchema.allOf.push({\n      type: \"object\",\n      // discriminator enum properties always need to be required\n      required: [discriminator.propertyName],\n      properties: {\n        [discriminator.propertyName]: createDiscriminatorEnum(values),\n      },\n    });\n\n    return true;\n  } else if (typeof resolvedSchema === \"object\" && \"type\" in resolvedSchema && resolvedSchema.type === \"object\") {\n    // if the schema is an object, we can apply the discriminator enums to its properties\n    if (!resolvedSchema.properties) {\n      resolvedSchema.properties = {};\n    }\n\n    // discriminator enum properties always need to be required\n    if (!resolvedSchema.required) {\n      resolvedSchema.required = [discriminator.propertyName];\n    } else if (!resolvedSchema.required.includes(discriminator.propertyName)) {\n      resolvedSchema.required.push(discriminator.propertyName);\n    }\n\n    // add/replace the discriminator enum property\n    resolvedSchema.properties[discriminator.propertyName] = createDiscriminatorEnum(\n      values,\n      resolvedSchema.properties[discriminator.propertyName] as SchemaObject,\n    );\n\n    return true;\n  }\n\n  warn(\n    `Discriminator mapping has an invalid schema (neither an object schema nor an allOf array): ${ref} => ${values.join(\n      \", \",\n    )} (Discriminator: ${discriminatorRef})`,\n    options.silent,\n  );\n\n  return false;\n}\n\ntype InternalDiscriminatorMapping = Record<string, { inferred?: string; defined?: string[] }>;\n\n/** Return a key–value map of discriminator objects found in a schema */\nexport function scanDiscriminators(schema: OpenAPI3, options: OpenAPITSOptions) {\n  // all discriminator objects found in the schema\n  const objects: Record<string, DiscriminatorObject> = {};\n\n  // refs of all mapped schema objects we have successfully handled to infer the discriminator enum value\n  const refsHandled: string[] = [];\n\n  // perform 2 passes: first, collect all discriminator definitions and handle oneOf and mappings\n  walk(schema, (obj, path) => {\n    const discriminator = obj?.discriminator as DiscriminatorObject | undefined;\n    if (!discriminator?.propertyName) {\n      return;\n    }\n\n    // collect discriminator object for later usage\n    const ref = createRef(path);\n\n    objects[ref] = discriminator;\n\n    // if a mapping is available we will help Typescript to infer properties by adding the discriminator enum with its single mapped value to each schema\n    // we only handle the mapping in advance for discriminator + oneOf compositions right now\n    if (!obj?.oneOf || !Array.isArray(obj.oneOf)) {\n      return;\n    }\n\n    const oneOf: (SchemaObject | ReferenceObject)[] = obj.oneOf;\n    const mapping: InternalDiscriminatorMapping = {};\n\n    // the mapping can be inferred from the oneOf refs next to the discriminator object\n    for (const item of oneOf) {\n      if (\"$ref\" in item) {\n        // the name of the schema is the inferred discriminator enum value\n        const value = item.$ref.split(\"/\").pop();\n\n        if (value) {\n          if (!mapping[item.$ref]) {\n            mapping[item.$ref] = { inferred: value };\n          } else {\n            mapping[item.$ref].inferred = value;\n          }\n        }\n      }\n    }\n\n    // the mapping can be defined in the discriminator object itself\n    if (discriminator.mapping) {\n      for (const mappedValue in discriminator.mapping) {\n        const mappedRef = discriminator.mapping[mappedValue];\n        if (!mappedRef) {\n          continue;\n        }\n\n        if (!mapping[mappedRef]?.defined) {\n          // this overrides inferred values, but we don't need them anymore as soon as we have a defined value\n          mapping[mappedRef] = { defined: [] };\n        }\n\n        mapping[mappedRef].defined?.push(mappedValue);\n      }\n    }\n\n    for (const [mappedRef, { inferred, defined }] of Object.entries(mapping)) {\n      if (refsHandled.includes(mappedRef)) {\n        continue;\n      }\n\n      if (!inferred && !defined) {\n        continue;\n      }\n\n      // prefer defined values over automatically inferred ones\n      // the inferred enum values from the schema might not represent the actual enum values of the discriminator,\n      // so if we have defined values, use them instead\n      // biome-ignore lint/style/noNonNullAssertion: we just checked for this\n      const mappedValues = defined ?? [inferred!];\n\n      if (\n        patchDiscriminatorEnum(schema as unknown as SchemaObject, mappedRef, mappedValues, discriminator, ref, options)\n      ) {\n        refsHandled.push(mappedRef);\n      }\n    }\n  });\n\n  // second, collect the schema objects that inherit from discriminators\n  // (sometimes this mapping is implicit, so it can’t be done until we know\n  // about every discriminator in the document)\n  walk(schema, (obj, path) => {\n    if (!obj || !Array.isArray(obj.allOf)) {\n      return;\n    }\n\n    for (const item of (obj as any).allOf) {\n      if (\"$ref\" in item) {\n        if (!objects[item.$ref]) {\n          return;\n        }\n\n        const ref = createRef(path);\n        const discriminator = objects[item.$ref];\n        const mappedValues: string[] = [];\n\n        if (discriminator.mapping) {\n          for (const mappedValue in discriminator.mapping) {\n            if (discriminator.mapping[mappedValue] === ref) {\n              mappedValues.push(mappedValue);\n            }\n          }\n\n          if (mappedValues.length > 0) {\n            if (\n              patchDiscriminatorEnum(\n                schema as unknown as SchemaObject,\n                ref,\n                mappedValues,\n                discriminator,\n                item.$ref,\n                options,\n              )\n            ) {\n              refsHandled.push(ref);\n            }\n          }\n        }\n\n        objects[ref] = {\n          ...objects[item.$ref],\n        };\n      } else if (item.discriminator?.propertyName) {\n        objects[createRef(path)] = { ...item.discriminator };\n      }\n    }\n  });\n\n  return { objects, refsHandled };\n}\n\n/** Walk through any JSON-serializable (i.e. non-circular) object */\nexport function walk(\n  obj: unknown,\n  cb: (value: Record<string, unknown>, path: (string | number)[]) => void,\n  path: (string | number)[] = [],\n): void {\n  if (!obj || typeof obj !== \"object\") {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      walk(obj[i], cb, path.concat(i));\n    }\n    return;\n  }\n  cb(obj as Record<string, unknown>, path);\n  for (const k of Object.keys(obj)) {\n    walk((obj as Record<string, unknown>)[k], cb, path.concat(k));\n  }\n}\n\n/** Print warning message */\nexport function warn(msg: string, silent = false) {\n  if (!silent) {\n    // biome-ignore lint/suspicious/noConsole: this is a CLI\n    console.warn(c.yellow(` ⚠  ${msg}`));\n  }\n}\n"],"names":["supportsColor","c","parseRef","ts","tsModifiers","tsPropertyIndex","tsLiteral","escapePointer"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"utils.cjs","sources":["../../src/lib/utils.ts"],"sourcesContent":["import { escapePointer, parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport c from \"ansi-colors\";\nimport supportsColor from \"supports-color\";\nimport ts from \"typescript\";\nimport type { DiscriminatorObject, OpenAPI3, OpenAPITSOptions, ReferenceObject, SchemaObject } from \"../types.js\";\nimport { tsLiteral, tsModifiers, tsPropertyIndex } from \"./ts.js\";\n\nif (!supportsColor.stdout || supportsColor.stdout.hasBasic === false) {\n  c.enabled = false;\n}\n\nconst DEBUG_GROUPS: Record<string, c.StyleFunction | undefined> = {\n  redoc: c.cyanBright,\n  lint: c.yellowBright,\n  bundle: c.magentaBright,\n  ts: c.blueBright,\n};\n\nexport { c };\n\n/** Given a discriminator object, get the property name */\nexport function createDiscriminatorProperty(\n  discriminator: DiscriminatorObject,\n  { path, readonly = false }: { path: string; readonly?: boolean },\n): ts.TypeElement {\n  // get the inferred propertyName value from the last section of the path (as the spec suggests to do)\n  let value = parseRef(path).pointer.pop();\n  // if mapping, and there’s a match, use this rather than the inferred name\n  if (discriminator.mapping) {\n    // Mapping value can either be a fully-qualified ref (#/components/schemas/XYZ) or a schema name (XYZ)\n    const matchedValue = Object.entries(discriminator.mapping).find(\n      ([, v]) => (!v.startsWith(\"#\") && v === value) || (v.startsWith(\"#\") && parseRef(v).pointer.pop() === value),\n    );\n    if (matchedValue) {\n      value = matchedValue[0]; // why was this designed backwards!?\n    }\n  }\n  return ts.factory.createPropertySignature(\n    /* modifiers     */ tsModifiers({\n      readonly,\n    }),\n    /* name          */ tsPropertyIndex(discriminator.propertyName),\n    /* questionToken */ undefined,\n    /* type          */ tsLiteral(value),\n  );\n}\n\n/** Create a $ref pointer (even from other $refs) */\nexport function createRef(parts: (number | string | undefined | null)[]): string {\n  let pointer = \"#\";\n  for (const part of parts) {\n    if (part === undefined || part === null || part === \"\") {\n      continue;\n    }\n    const maybeRef = parseRef(String(part)).pointer;\n    if (maybeRef.length) {\n      for (const refPart of maybeRef) {\n        pointer += `/${escapePointer(refPart)}`;\n      }\n    } else {\n      pointer += `/${escapePointer(part)}`;\n    }\n  }\n  return pointer;\n}\n\n/** Print debug message (cribbed from the `debug` package, but without all the bells & whistles */\nexport function debug(msg: string, group?: string, time?: number) {\n  if (\n    process.env.DEBUG &&\n    (!group ||\n      process.env.DEBUG === \"*\" ||\n      process.env.DEBUG === \"openapi-ts:*\" ||\n      process.env.DEBUG.toLocaleLowerCase() === `openapi-ts:${group.toLocaleLowerCase()}`)\n  ) {\n    const groupColor = (group && DEBUG_GROUPS[group]) || c.whiteBright;\n    const groupName = groupColor(`openapi-ts:${group ?? \"info\"}`);\n    let timeFormatted = \"\";\n    if (typeof time === \"number\") {\n      timeFormatted = c.green(` ${formatTime(time)} `);\n    }\n    // biome-ignore lint/suspicious/noConsole: this is a CLI\n    console.debug(`  ${c.bold(groupName)}${timeFormatted}${msg}`);\n  }\n}\n\n/** Print error message */\nexport function error(msg: string) {\n  // biome-ignore lint/suspicious/noConsole: this is a CLI\n  console.error(c.red(` ✘  ${msg}`));\n}\n\n/** Format a performance log in a friendly format */\nexport function formatTime(t: number) {\n  if (typeof t === \"number\") {\n    if (t < 1000) {\n      return `${Math.round(10 * t) / 10}ms`;\n    }\n    if (t < 60000) {\n      return `${Math.round(t / 100) / 10}s`;\n    }\n    return `${Math.round(t / 6000) / 10}m`;\n  }\n  return t;\n}\n\n/** Call Object.entries() and optionally sort */\nexport function getEntries<T>(\n  obj: ArrayLike<T> | Record<string, T>,\n  options?: {\n    alphabetize?: boolean;\n    excludeDeprecated?: boolean;\n  },\n) {\n  let entries = Object.entries(obj);\n  if (options?.alphabetize) {\n    entries.sort(([a], [b]) => a.localeCompare(b, \"en-us\", { numeric: true }));\n  }\n  if (options?.excludeDeprecated) {\n    entries = entries.filter(([, v]) => !(v && typeof v === \"object\" && \"deprecated\" in v && v.deprecated));\n  }\n  return entries;\n}\n\n/** resolve a $ref in a schema */\nexport function resolveRef<T>(\n  schema: any,\n  $ref: string,\n  { silent = false, visited = [] }: { silent: boolean; visited?: string[] },\n): T | undefined {\n  const { pointer } = parseRef($ref);\n  if (!pointer.length) {\n    return undefined;\n  }\n  let node = schema;\n  for (const key of pointer) {\n    if (node && typeof node === \"object\" && node[key]) {\n      node = node[key];\n    } else {\n      warn(`Could not resolve $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n  }\n\n  // if this is also a $ref, keep tracing\n  if (node && typeof node === \"object\" && node.$ref) {\n    if (visited.includes(node.$ref)) {\n      warn(`Could not resolve circular $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n    return resolveRef(schema, node.$ref, {\n      silent,\n      visited: [...visited, node.$ref],\n    });\n  }\n\n  return node;\n}\n\nfunction createDiscriminatorEnum(values: string[], prevSchema?: SchemaObject): SchemaObject {\n  return {\n    type: \"string\",\n    enum: values,\n    description: prevSchema?.description\n      ? `${prevSchema.description} (enum property replaced by openapi-typescript)`\n      : \"discriminator enum property added by openapi-typescript\",\n  };\n}\n\n/** Adds or replaces the discriminator enum with the passed `values` in a schema defined by `ref` */\nfunction patchDiscriminatorEnum(\n  schema: SchemaObject,\n  ref: string,\n  values: string[],\n  discriminator: DiscriminatorObject,\n  discriminatorRef: string,\n  options: OpenAPITSOptions,\n): boolean {\n  const resolvedSchema = resolveRef<SchemaObject>(schema, ref, {\n    silent: options.silent ?? false,\n  });\n\n  if (resolvedSchema?.allOf) {\n    // if the schema is an allOf, we can append a new schema object to the allOf array\n    resolvedSchema.allOf.push({\n      type: \"object\",\n      // discriminator enum properties always need to be required\n      required: [discriminator.propertyName],\n      properties: {\n        [discriminator.propertyName]: createDiscriminatorEnum(values),\n      },\n    });\n\n    return true;\n  } else if (typeof resolvedSchema === \"object\" && \"type\" in resolvedSchema && resolvedSchema.type === \"object\") {\n    // if the schema is an object, we can apply the discriminator enums to its properties\n    if (!resolvedSchema.properties) {\n      resolvedSchema.properties = {};\n    }\n\n    // discriminator enum properties always need to be required\n    if (!resolvedSchema.required) {\n      resolvedSchema.required = [discriminator.propertyName];\n    } else if (!resolvedSchema.required.includes(discriminator.propertyName)) {\n      resolvedSchema.required.push(discriminator.propertyName);\n    }\n\n    // add/replace the discriminator enum property\n    resolvedSchema.properties[discriminator.propertyName] = createDiscriminatorEnum(\n      values,\n      resolvedSchema.properties[discriminator.propertyName] as SchemaObject,\n    );\n\n    return true;\n  }\n\n  warn(\n    `Discriminator mapping has an invalid schema (neither an object schema nor an allOf array): ${ref} => ${values.join(\n      \", \",\n    )} (Discriminator: ${discriminatorRef})`,\n    options.silent,\n  );\n\n  return false;\n}\n\ntype InternalDiscriminatorMapping = Record<string, { inferred?: string; defined?: string[] }>;\n\n/** Return a key–value map of discriminator objects found in a schema */\nexport function scanDiscriminators(schema: OpenAPI3, options: OpenAPITSOptions) {\n  // all discriminator objects found in the schema\n  const objects: Record<string, DiscriminatorObject> = {};\n\n  // refs of all mapped schema objects we have successfully handled to infer the discriminator enum value\n  const refsHandled: string[] = [];\n\n  // perform 2 passes: first, collect all discriminator definitions and handle oneOf and mappings\n  walk(schema, (obj, path) => {\n    const discriminator = obj?.discriminator as DiscriminatorObject | undefined;\n    if (!discriminator?.propertyName) {\n      return;\n    }\n\n    // collect discriminator object for later usage\n    const ref = createRef(path);\n\n    objects[ref] = discriminator;\n\n    // if a mapping is available we will help Typescript to infer properties by adding the discriminator enum with its single mapped value to each schema\n    // we only handle the mapping in advance for discriminator + oneOf compositions right now\n    if (!obj?.oneOf || !Array.isArray(obj.oneOf)) {\n      return;\n    }\n\n    const oneOf: (SchemaObject | ReferenceObject)[] = obj.oneOf;\n    const mapping: InternalDiscriminatorMapping = {};\n\n    // the mapping can be inferred from the oneOf refs next to the discriminator object\n    for (const item of oneOf) {\n      if (\"$ref\" in item) {\n        // the name of the schema is the inferred discriminator enum value\n        const value = item.$ref.split(\"/\").pop();\n\n        if (value) {\n          if (!mapping[item.$ref]) {\n            mapping[item.$ref] = { inferred: value };\n          } else {\n            mapping[item.$ref].inferred = value;\n          }\n        }\n      }\n    }\n\n    // the mapping can be defined in the discriminator object itself\n    if (discriminator.mapping) {\n      for (const mappedValue in discriminator.mapping) {\n        const mappedRef = discriminator.mapping[mappedValue];\n        if (!mappedRef) {\n          continue;\n        }\n\n        if (!mapping[mappedRef]?.defined) {\n          // this overrides inferred values, but we don't need them anymore as soon as we have a defined value\n          mapping[mappedRef] = { defined: [] };\n        }\n\n        mapping[mappedRef].defined?.push(mappedValue);\n      }\n    }\n\n    for (const [mappedRef, { inferred, defined }] of Object.entries(mapping)) {\n      if (refsHandled.includes(mappedRef)) {\n        continue;\n      }\n\n      if (!inferred && !defined) {\n        continue;\n      }\n\n      // prefer defined values over automatically inferred ones\n      // the inferred enum values from the schema might not represent the actual enum values of the discriminator,\n      // so if we have defined values, use them instead\n      // biome-ignore lint/style/noNonNullAssertion: we just checked for this\n      const mappedValues = defined ?? [inferred!];\n\n      if (\n        patchDiscriminatorEnum(schema as unknown as SchemaObject, mappedRef, mappedValues, discriminator, ref, options)\n      ) {\n        refsHandled.push(mappedRef);\n      }\n    }\n  });\n\n  // second, collect the schema objects that inherit from discriminators\n  // (sometimes this mapping is implicit, so it can’t be done until we know\n  // about every discriminator in the document)\n  walk(schema, (obj, path) => {\n    if (!obj || !Array.isArray(obj.allOf)) {\n      return;\n    }\n\n    for (const item of (obj as any).allOf) {\n      if (\"$ref\" in item) {\n        if (!objects[item.$ref]) {\n          return;\n        }\n\n        const ref = createRef(path);\n        const discriminator = objects[item.$ref];\n        const mappedValues: string[] = [];\n\n        if (discriminator.mapping) {\n          for (const mappedValue in discriminator.mapping) {\n            if (discriminator.mapping[mappedValue] === ref) {\n              mappedValues.push(mappedValue);\n            }\n          }\n\n          if (mappedValues.length > 0) {\n            if (\n              patchDiscriminatorEnum(\n                schema as unknown as SchemaObject,\n                ref,\n                mappedValues,\n                discriminator,\n                item.$ref,\n                options,\n              )\n            ) {\n              refsHandled.push(ref);\n            }\n          }\n        }\n\n        objects[ref] = {\n          ...objects[item.$ref],\n        };\n      } else if (item.discriminator?.propertyName) {\n        objects[createRef(path)] = { ...item.discriminator };\n      }\n    }\n  });\n\n  return { objects, refsHandled };\n}\n\n/** Walk through any JSON-serializable (i.e. non-circular) object */\nexport function walk(\n  obj: unknown,\n  cb: (value: Record<string, unknown>, path: (string | number)[]) => void,\n  path: (string | number)[] = [],\n): void {\n  if (!obj || typeof obj !== \"object\") {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      walk(obj[i], cb, path.concat(i));\n    }\n    return;\n  }\n  cb(obj as Record<string, unknown>, path);\n  for (const k of Object.keys(obj)) {\n    walk((obj as Record<string, unknown>)[k], cb, path.concat(k));\n  }\n}\n\n/** Print warning message */\nexport function warn(msg: string, silent = false) {\n  if (!silent) {\n    // biome-ignore lint/suspicious/noConsole: this is a CLI\n    console.warn(c.yellow(` ⚠  ${msg}`));\n  }\n}\n"],"names":["supportsColor","c","parseRef","ts","tsModifiers","tsPropertyIndex","tsLiteral","escapePointer"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/lib/utils.mjs.map b/dist/lib/utils.mjs.map
index 61902bb79db725624b933e79f5d3aa686932d51b..be482f6fdfc417e1561ea600e0e1f1f998adf387 100644
--- a/dist/lib/utils.mjs.map
+++ b/dist/lib/utils.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"utils.mjs","sources":["../../src/lib/utils.ts"],"sourcesContent":["import { escapePointer, parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport c from \"ansi-colors\";\nimport supportsColor from \"supports-color\";\nimport ts from \"typescript\";\nimport type { DiscriminatorObject, OpenAPI3, OpenAPITSOptions, ReferenceObject, SchemaObject } from \"../types.js\";\nimport { tsLiteral, tsModifiers, tsPropertyIndex } from \"./ts.js\";\n\nif (!supportsColor.stdout || supportsColor.stdout.hasBasic === false) {\n  c.enabled = false;\n}\n\nconst DEBUG_GROUPS: Record<string, c.StyleFunction | undefined> = {\n  redoc: c.cyanBright,\n  lint: c.yellowBright,\n  bundle: c.magentaBright,\n  ts: c.blueBright,\n};\n\nexport { c };\n\n/** Given a discriminator object, get the property name */\nexport function createDiscriminatorProperty(\n  discriminator: DiscriminatorObject,\n  { path, readonly = false }: { path: string; readonly?: boolean },\n): ts.TypeElement {\n  // get the inferred propertyName value from the last section of the path (as the spec suggests to do)\n  let value = parseRef(path).pointer.pop();\n  // if mapping, and there’s a match, use this rather than the inferred name\n  if (discriminator.mapping) {\n    // Mapping value can either be a fully-qualified ref (#/components/schemas/XYZ) or a schema name (XYZ)\n    const matchedValue = Object.entries(discriminator.mapping).find(\n      ([, v]) => (!v.startsWith(\"#\") && v === value) || (v.startsWith(\"#\") && parseRef(v).pointer.pop() === value),\n    );\n    if (matchedValue) {\n      value = matchedValue[0]; // why was this designed backwards!?\n    }\n  }\n  return ts.factory.createPropertySignature(\n    /* modifiers     */ tsModifiers({\n      readonly,\n    }),\n    /* name          */ tsPropertyIndex(discriminator.propertyName),\n    /* questionToken */ undefined,\n    /* type          */ tsLiteral(value),\n  );\n}\n\n/** Create a $ref pointer (even from other $refs) */\nexport function createRef(parts: (number | string | undefined | null)[]): string {\n  let pointer = \"#\";\n  for (const part of parts) {\n    if (part === undefined || part === null || part === \"\") {\n      continue;\n    }\n    const maybeRef = parseRef(String(part)).pointer;\n    if (maybeRef.length) {\n      for (const refPart of maybeRef) {\n        pointer += `/${escapePointer(refPart)}`;\n      }\n    } else {\n      pointer += `/${escapePointer(part)}`;\n    }\n  }\n  return pointer;\n}\n\n/** Print debug message (cribbed from the `debug` package, but without all the bells & whistles */\nexport function debug(msg: string, group?: string, time?: number) {\n  if (\n    process.env.DEBUG &&\n    (!group ||\n      process.env.DEBUG === \"*\" ||\n      process.env.DEBUG === \"openapi-ts:*\" ||\n      process.env.DEBUG.toLocaleLowerCase() === `openapi-ts:${group.toLocaleLowerCase()}`)\n  ) {\n    const groupColor = (group && DEBUG_GROUPS[group]) || c.whiteBright;\n    const groupName = groupColor(`openapi-ts:${group ?? \"info\"}`);\n    let timeFormatted = \"\";\n    if (typeof time === \"number\") {\n      timeFormatted = c.green(` ${formatTime(time)} `);\n    }\n    // biome-ignore lint/suspicious/noConsole: this is a CLI\n    console.debug(`  ${c.bold(groupName)}${timeFormatted}${msg}`);\n  }\n}\n\n/** Print error message */\nexport function error(msg: string) {\n  // biome-ignore lint/suspicious/noConsole: this is a CLI\n  console.error(c.red(` ✘  ${msg}`));\n}\n\n/** Format a performance log in a friendly format */\nexport function formatTime(t: number) {\n  if (typeof t === \"number\") {\n    if (t < 1000) {\n      return `${Math.round(10 * t) / 10}ms`;\n    }\n    if (t < 60000) {\n      return `${Math.round(t / 100) / 10}s`;\n    }\n    return `${Math.round(t / 6000) / 10}m`;\n  }\n  return t;\n}\n\n/** Call Object.entries() and optionally sort */\nexport function getEntries<T>(\n  obj: ArrayLike<T> | Record<string, T>,\n  options?: {\n    alphabetize?: boolean;\n    excludeDeprecated?: boolean;\n  },\n) {\n  let entries = Object.entries(obj);\n  if (options?.alphabetize) {\n    entries.sort(([a], [b]) => a.localeCompare(b, \"en-us\", { numeric: true }));\n  }\n  if (options?.excludeDeprecated) {\n    entries = entries.filter(([, v]) => !(v && typeof v === \"object\" && \"deprecated\" in v && v.deprecated));\n  }\n  return entries;\n}\n\n/** resolve a $ref in a schema */\nexport function resolveRef<T>(\n  schema: any,\n  $ref: string,\n  { silent = false, visited = [] }: { silent: boolean; visited?: string[] },\n): T | undefined {\n  const { pointer } = parseRef($ref);\n  if (!pointer.length) {\n    return undefined;\n  }\n  let node = schema;\n  for (const key of pointer) {\n    if (node && typeof node === \"object\" && node[key]) {\n      node = node[key];\n    } else {\n      warn(`Could not resolve $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n  }\n\n  // if this is also a $ref, keep tracing\n  if (node && typeof node === \"object\" && node.$ref) {\n    if (visited.includes(node.$ref)) {\n      warn(`Could not resolve circular $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n    return resolveRef(schema, node.$ref, {\n      silent,\n      visited: [...visited, node.$ref],\n    });\n  }\n\n  return node;\n}\n\nfunction createDiscriminatorEnum(values: string[], prevSchema?: SchemaObject): SchemaObject {\n  return {\n    type: \"string\",\n    enum: values,\n    description: prevSchema?.description\n      ? `${prevSchema.description} (enum property replaced by openapi-typescript)`\n      : \"discriminator enum property added by openapi-typescript\",\n  };\n}\n\n/** Adds or replaces the discriminator enum with the passed `values` in a schema defined by `ref` */\nfunction patchDiscriminatorEnum(\n  schema: SchemaObject,\n  ref: string,\n  values: string[],\n  discriminator: DiscriminatorObject,\n  discriminatorRef: string,\n  options: OpenAPITSOptions,\n): boolean {\n  const resolvedSchema = resolveRef<SchemaObject>(schema, ref, {\n    silent: options.silent ?? false,\n  });\n\n  if (resolvedSchema?.allOf) {\n    // if the schema is an allOf, we can append a new schema object to the allOf array\n    resolvedSchema.allOf.push({\n      type: \"object\",\n      // discriminator enum properties always need to be required\n      required: [discriminator.propertyName],\n      properties: {\n        [discriminator.propertyName]: createDiscriminatorEnum(values),\n      },\n    });\n\n    return true;\n  } else if (typeof resolvedSchema === \"object\" && \"type\" in resolvedSchema && resolvedSchema.type === \"object\") {\n    // if the schema is an object, we can apply the discriminator enums to its properties\n    if (!resolvedSchema.properties) {\n      resolvedSchema.properties = {};\n    }\n\n    // discriminator enum properties always need to be required\n    if (!resolvedSchema.required) {\n      resolvedSchema.required = [discriminator.propertyName];\n    } else if (!resolvedSchema.required.includes(discriminator.propertyName)) {\n      resolvedSchema.required.push(discriminator.propertyName);\n    }\n\n    // add/replace the discriminator enum property\n    resolvedSchema.properties[discriminator.propertyName] = createDiscriminatorEnum(\n      values,\n      resolvedSchema.properties[discriminator.propertyName] as SchemaObject,\n    );\n\n    return true;\n  }\n\n  warn(\n    `Discriminator mapping has an invalid schema (neither an object schema nor an allOf array): ${ref} => ${values.join(\n      \", \",\n    )} (Discriminator: ${discriminatorRef})`,\n    options.silent,\n  );\n\n  return false;\n}\n\ntype InternalDiscriminatorMapping = Record<string, { inferred?: string; defined?: string[] }>;\n\n/** Return a key–value map of discriminator objects found in a schema */\nexport function scanDiscriminators(schema: OpenAPI3, options: OpenAPITSOptions) {\n  // all discriminator objects found in the schema\n  const objects: Record<string, DiscriminatorObject> = {};\n\n  // refs of all mapped schema objects we have successfully handled to infer the discriminator enum value\n  const refsHandled: string[] = [];\n\n  // perform 2 passes: first, collect all discriminator definitions and handle oneOf and mappings\n  walk(schema, (obj, path) => {\n    const discriminator = obj?.discriminator as DiscriminatorObject | undefined;\n    if (!discriminator?.propertyName) {\n      return;\n    }\n\n    // collect discriminator object for later usage\n    const ref = createRef(path);\n\n    objects[ref] = discriminator;\n\n    // if a mapping is available we will help Typescript to infer properties by adding the discriminator enum with its single mapped value to each schema\n    // we only handle the mapping in advance for discriminator + oneOf compositions right now\n    if (!obj?.oneOf || !Array.isArray(obj.oneOf)) {\n      return;\n    }\n\n    const oneOf: (SchemaObject | ReferenceObject)[] = obj.oneOf;\n    const mapping: InternalDiscriminatorMapping = {};\n\n    // the mapping can be inferred from the oneOf refs next to the discriminator object\n    for (const item of oneOf) {\n      if (\"$ref\" in item) {\n        // the name of the schema is the inferred discriminator enum value\n        const value = item.$ref.split(\"/\").pop();\n\n        if (value) {\n          if (!mapping[item.$ref]) {\n            mapping[item.$ref] = { inferred: value };\n          } else {\n            mapping[item.$ref].inferred = value;\n          }\n        }\n      }\n    }\n\n    // the mapping can be defined in the discriminator object itself\n    if (discriminator.mapping) {\n      for (const mappedValue in discriminator.mapping) {\n        const mappedRef = discriminator.mapping[mappedValue];\n        if (!mappedRef) {\n          continue;\n        }\n\n        if (!mapping[mappedRef]?.defined) {\n          // this overrides inferred values, but we don't need them anymore as soon as we have a defined value\n          mapping[mappedRef] = { defined: [] };\n        }\n\n        mapping[mappedRef].defined?.push(mappedValue);\n      }\n    }\n\n    for (const [mappedRef, { inferred, defined }] of Object.entries(mapping)) {\n      if (refsHandled.includes(mappedRef)) {\n        continue;\n      }\n\n      if (!inferred && !defined) {\n        continue;\n      }\n\n      // prefer defined values over automatically inferred ones\n      // the inferred enum values from the schema might not represent the actual enum values of the discriminator,\n      // so if we have defined values, use them instead\n      // biome-ignore lint/style/noNonNullAssertion: we just checked for this\n      const mappedValues = defined ?? [inferred!];\n\n      if (\n        patchDiscriminatorEnum(schema as unknown as SchemaObject, mappedRef, mappedValues, discriminator, ref, options)\n      ) {\n        refsHandled.push(mappedRef);\n      }\n    }\n  });\n\n  // second, collect the schema objects that inherit from discriminators\n  // (sometimes this mapping is implicit, so it can’t be done until we know\n  // about every discriminator in the document)\n  walk(schema, (obj, path) => {\n    if (!obj || !Array.isArray(obj.allOf)) {\n      return;\n    }\n\n    for (const item of (obj as any).allOf) {\n      if (\"$ref\" in item) {\n        if (!objects[item.$ref]) {\n          return;\n        }\n\n        const ref = createRef(path);\n        const discriminator = objects[item.$ref];\n        const mappedValues: string[] = [];\n\n        if (discriminator.mapping) {\n          for (const mappedValue in discriminator.mapping) {\n            if (discriminator.mapping[mappedValue] === ref) {\n              mappedValues.push(mappedValue);\n            }\n          }\n\n          if (mappedValues.length > 0) {\n            if (\n              patchDiscriminatorEnum(\n                schema as unknown as SchemaObject,\n                ref,\n                mappedValues,\n                discriminator,\n                item.$ref,\n                options,\n              )\n            ) {\n              refsHandled.push(ref);\n            }\n          }\n        }\n\n        objects[ref] = {\n          ...objects[item.$ref],\n        };\n      } else if (item.discriminator?.propertyName) {\n        objects[createRef(path)] = { ...item.discriminator };\n      }\n    }\n  });\n\n  return { objects, refsHandled };\n}\n\n/** Walk through any JSON-serializable (i.e. non-circular) object */\nexport function walk(\n  obj: unknown,\n  cb: (value: Record<string, unknown>, path: (string | number)[]) => void,\n  path: (string | number)[] = [],\n): void {\n  if (!obj || typeof obj !== \"object\") {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      walk(obj[i], cb, path.concat(i));\n    }\n    return;\n  }\n  cb(obj as Record<string, unknown>, path);\n  for (const k of Object.keys(obj)) {\n    walk((obj as Record<string, unknown>)[k], cb, path.concat(k));\n  }\n}\n\n/** Print warning message */\nexport function warn(msg: string, silent = false) {\n  if (!silent) {\n    // biome-ignore lint/suspicious/noConsole: this is a CLI\n    console.warn(c.yellow(` ⚠  ${msg}`));\n  }\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"utils.mjs","sources":["../../src/lib/utils.ts"],"sourcesContent":["import { escapePointer, parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport c from \"ansi-colors\";\nimport supportsColor from \"supports-color\";\nimport ts from \"typescript\";\nimport type { DiscriminatorObject, OpenAPI3, OpenAPITSOptions, ReferenceObject, SchemaObject } from \"../types.js\";\nimport { tsLiteral, tsModifiers, tsPropertyIndex } from \"./ts.js\";\n\nif (!supportsColor.stdout || supportsColor.stdout.hasBasic === false) {\n  c.enabled = false;\n}\n\nconst DEBUG_GROUPS: Record<string, c.StyleFunction | undefined> = {\n  redoc: c.cyanBright,\n  lint: c.yellowBright,\n  bundle: c.magentaBright,\n  ts: c.blueBright,\n};\n\nexport { c };\n\n/** Given a discriminator object, get the property name */\nexport function createDiscriminatorProperty(\n  discriminator: DiscriminatorObject,\n  { path, readonly = false }: { path: string; readonly?: boolean },\n): ts.TypeElement {\n  // get the inferred propertyName value from the last section of the path (as the spec suggests to do)\n  let value = parseRef(path).pointer.pop();\n  // if mapping, and there’s a match, use this rather than the inferred name\n  if (discriminator.mapping) {\n    // Mapping value can either be a fully-qualified ref (#/components/schemas/XYZ) or a schema name (XYZ)\n    const matchedValue = Object.entries(discriminator.mapping).find(\n      ([, v]) => (!v.startsWith(\"#\") && v === value) || (v.startsWith(\"#\") && parseRef(v).pointer.pop() === value),\n    );\n    if (matchedValue) {\n      value = matchedValue[0]; // why was this designed backwards!?\n    }\n  }\n  return ts.factory.createPropertySignature(\n    /* modifiers     */ tsModifiers({\n      readonly,\n    }),\n    /* name          */ tsPropertyIndex(discriminator.propertyName),\n    /* questionToken */ undefined,\n    /* type          */ tsLiteral(value),\n  );\n}\n\n/** Create a $ref pointer (even from other $refs) */\nexport function createRef(parts: (number | string | undefined | null)[]): string {\n  let pointer = \"#\";\n  for (const part of parts) {\n    if (part === undefined || part === null || part === \"\") {\n      continue;\n    }\n    const maybeRef = parseRef(String(part)).pointer;\n    if (maybeRef.length) {\n      for (const refPart of maybeRef) {\n        pointer += `/${escapePointer(refPart)}`;\n      }\n    } else {\n      pointer += `/${escapePointer(part)}`;\n    }\n  }\n  return pointer;\n}\n\n/** Print debug message (cribbed from the `debug` package, but without all the bells & whistles */\nexport function debug(msg: string, group?: string, time?: number) {\n  if (\n    process.env.DEBUG &&\n    (!group ||\n      process.env.DEBUG === \"*\" ||\n      process.env.DEBUG === \"openapi-ts:*\" ||\n      process.env.DEBUG.toLocaleLowerCase() === `openapi-ts:${group.toLocaleLowerCase()}`)\n  ) {\n    const groupColor = (group && DEBUG_GROUPS[group]) || c.whiteBright;\n    const groupName = groupColor(`openapi-ts:${group ?? \"info\"}`);\n    let timeFormatted = \"\";\n    if (typeof time === \"number\") {\n      timeFormatted = c.green(` ${formatTime(time)} `);\n    }\n    // biome-ignore lint/suspicious/noConsole: this is a CLI\n    console.debug(`  ${c.bold(groupName)}${timeFormatted}${msg}`);\n  }\n}\n\n/** Print error message */\nexport function error(msg: string) {\n  // biome-ignore lint/suspicious/noConsole: this is a CLI\n  console.error(c.red(` ✘  ${msg}`));\n}\n\n/** Format a performance log in a friendly format */\nexport function formatTime(t: number) {\n  if (typeof t === \"number\") {\n    if (t < 1000) {\n      return `${Math.round(10 * t) / 10}ms`;\n    }\n    if (t < 60000) {\n      return `${Math.round(t / 100) / 10}s`;\n    }\n    return `${Math.round(t / 6000) / 10}m`;\n  }\n  return t;\n}\n\n/** Call Object.entries() and optionally sort */\nexport function getEntries<T>(\n  obj: ArrayLike<T> | Record<string, T>,\n  options?: {\n    alphabetize?: boolean;\n    excludeDeprecated?: boolean;\n  },\n) {\n  let entries = Object.entries(obj);\n  if (options?.alphabetize) {\n    entries.sort(([a], [b]) => a.localeCompare(b, \"en-us\", { numeric: true }));\n  }\n  if (options?.excludeDeprecated) {\n    entries = entries.filter(([, v]) => !(v && typeof v === \"object\" && \"deprecated\" in v && v.deprecated));\n  }\n  return entries;\n}\n\n/** resolve a $ref in a schema */\nexport function resolveRef<T>(\n  schema: any,\n  $ref: string,\n  { silent = false, visited = [] }: { silent: boolean; visited?: string[] },\n): T | undefined {\n  const { pointer } = parseRef($ref);\n  if (!pointer.length) {\n    return undefined;\n  }\n  let node = schema;\n  for (const key of pointer) {\n    if (node && typeof node === \"object\" && node[key]) {\n      node = node[key];\n    } else {\n      warn(`Could not resolve $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n  }\n\n  // if this is also a $ref, keep tracing\n  if (node && typeof node === \"object\" && node.$ref) {\n    if (visited.includes(node.$ref)) {\n      warn(`Could not resolve circular $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n    return resolveRef(schema, node.$ref, {\n      silent,\n      visited: [...visited, node.$ref],\n    });\n  }\n\n  return node;\n}\n\nfunction createDiscriminatorEnum(values: string[], prevSchema?: SchemaObject): SchemaObject {\n  return {\n    type: \"string\",\n    enum: values,\n    description: prevSchema?.description\n      ? `${prevSchema.description} (enum property replaced by openapi-typescript)`\n      : \"discriminator enum property added by openapi-typescript\",\n  };\n}\n\n/** Adds or replaces the discriminator enum with the passed `values` in a schema defined by `ref` */\nfunction patchDiscriminatorEnum(\n  schema: SchemaObject,\n  ref: string,\n  values: string[],\n  discriminator: DiscriminatorObject,\n  discriminatorRef: string,\n  options: OpenAPITSOptions,\n): boolean {\n  const resolvedSchema = resolveRef<SchemaObject>(schema, ref, {\n    silent: options.silent ?? false,\n  });\n\n  if (resolvedSchema?.allOf) {\n    // if the schema is an allOf, we can append a new schema object to the allOf array\n    resolvedSchema.allOf.push({\n      type: \"object\",\n      // discriminator enum properties always need to be required\n      required: [discriminator.propertyName],\n      properties: {\n        [discriminator.propertyName]: createDiscriminatorEnum(values),\n      },\n    });\n\n    return true;\n  } else if (typeof resolvedSchema === \"object\" && \"type\" in resolvedSchema && resolvedSchema.type === \"object\") {\n    // if the schema is an object, we can apply the discriminator enums to its properties\n    if (!resolvedSchema.properties) {\n      resolvedSchema.properties = {};\n    }\n\n    // discriminator enum properties always need to be required\n    if (!resolvedSchema.required) {\n      resolvedSchema.required = [discriminator.propertyName];\n    } else if (!resolvedSchema.required.includes(discriminator.propertyName)) {\n      resolvedSchema.required.push(discriminator.propertyName);\n    }\n\n    // add/replace the discriminator enum property\n    resolvedSchema.properties[discriminator.propertyName] = createDiscriminatorEnum(\n      values,\n      resolvedSchema.properties[discriminator.propertyName] as SchemaObject,\n    );\n\n    return true;\n  }\n\n  warn(\n    `Discriminator mapping has an invalid schema (neither an object schema nor an allOf array): ${ref} => ${values.join(\n      \", \",\n    )} (Discriminator: ${discriminatorRef})`,\n    options.silent,\n  );\n\n  return false;\n}\n\ntype InternalDiscriminatorMapping = Record<string, { inferred?: string; defined?: string[] }>;\n\n/** Return a key–value map of discriminator objects found in a schema */\nexport function scanDiscriminators(schema: OpenAPI3, options: OpenAPITSOptions) {\n  // all discriminator objects found in the schema\n  const objects: Record<string, DiscriminatorObject> = {};\n\n  // refs of all mapped schema objects we have successfully handled to infer the discriminator enum value\n  const refsHandled: string[] = [];\n\n  // perform 2 passes: first, collect all discriminator definitions and handle oneOf and mappings\n  walk(schema, (obj, path) => {\n    const discriminator = obj?.discriminator as DiscriminatorObject | undefined;\n    if (!discriminator?.propertyName) {\n      return;\n    }\n\n    // collect discriminator object for later usage\n    const ref = createRef(path);\n\n    objects[ref] = discriminator;\n\n    // if a mapping is available we will help Typescript to infer properties by adding the discriminator enum with its single mapped value to each schema\n    // we only handle the mapping in advance for discriminator + oneOf compositions right now\n    if (!obj?.oneOf || !Array.isArray(obj.oneOf)) {\n      return;\n    }\n\n    const oneOf: (SchemaObject | ReferenceObject)[] = obj.oneOf;\n    const mapping: InternalDiscriminatorMapping = {};\n\n    // the mapping can be inferred from the oneOf refs next to the discriminator object\n    for (const item of oneOf) {\n      if (\"$ref\" in item) {\n        // the name of the schema is the inferred discriminator enum value\n        const value = item.$ref.split(\"/\").pop();\n\n        if (value) {\n          if (!mapping[item.$ref]) {\n            mapping[item.$ref] = { inferred: value };\n          } else {\n            mapping[item.$ref].inferred = value;\n          }\n        }\n      }\n    }\n\n    // the mapping can be defined in the discriminator object itself\n    if (discriminator.mapping) {\n      for (const mappedValue in discriminator.mapping) {\n        const mappedRef = discriminator.mapping[mappedValue];\n        if (!mappedRef) {\n          continue;\n        }\n\n        if (!mapping[mappedRef]?.defined) {\n          // this overrides inferred values, but we don't need them anymore as soon as we have a defined value\n          mapping[mappedRef] = { defined: [] };\n        }\n\n        mapping[mappedRef].defined?.push(mappedValue);\n      }\n    }\n\n    for (const [mappedRef, { inferred, defined }] of Object.entries(mapping)) {\n      if (refsHandled.includes(mappedRef)) {\n        continue;\n      }\n\n      if (!inferred && !defined) {\n        continue;\n      }\n\n      // prefer defined values over automatically inferred ones\n      // the inferred enum values from the schema might not represent the actual enum values of the discriminator,\n      // so if we have defined values, use them instead\n      // biome-ignore lint/style/noNonNullAssertion: we just checked for this\n      const mappedValues = defined ?? [inferred!];\n\n      if (\n        patchDiscriminatorEnum(schema as unknown as SchemaObject, mappedRef, mappedValues, discriminator, ref, options)\n      ) {\n        refsHandled.push(mappedRef);\n      }\n    }\n  });\n\n  // second, collect the schema objects that inherit from discriminators\n  // (sometimes this mapping is implicit, so it can’t be done until we know\n  // about every discriminator in the document)\n  walk(schema, (obj, path) => {\n    if (!obj || !Array.isArray(obj.allOf)) {\n      return;\n    }\n\n    for (const item of (obj as any).allOf) {\n      if (\"$ref\" in item) {\n        if (!objects[item.$ref]) {\n          return;\n        }\n\n        const ref = createRef(path);\n        const discriminator = objects[item.$ref];\n        const mappedValues: string[] = [];\n\n        if (discriminator.mapping) {\n          for (const mappedValue in discriminator.mapping) {\n            if (discriminator.mapping[mappedValue] === ref) {\n              mappedValues.push(mappedValue);\n            }\n          }\n\n          if (mappedValues.length > 0) {\n            if (\n              patchDiscriminatorEnum(\n                schema as unknown as SchemaObject,\n                ref,\n                mappedValues,\n                discriminator,\n                item.$ref,\n                options,\n              )\n            ) {\n              refsHandled.push(ref);\n            }\n          }\n        }\n\n        objects[ref] = {\n          ...objects[item.$ref],\n        };\n      } else if (item.discriminator?.propertyName) {\n        objects[createRef(path)] = { ...item.discriminator };\n      }\n    }\n  });\n\n  return { objects, refsHandled };\n}\n\n/** Walk through any JSON-serializable (i.e. non-circular) object */\nexport function walk(\n  obj: unknown,\n  cb: (value: Record<string, unknown>, path: (string | number)[]) => void,\n  path: (string | number)[] = [],\n): void {\n  if (!obj || typeof obj !== \"object\") {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      walk(obj[i], cb, path.concat(i));\n    }\n    return;\n  }\n  cb(obj as Record<string, unknown>, path);\n  for (const k of Object.keys(obj)) {\n    walk((obj as Record<string, unknown>)[k], cb, path.concat(k));\n  }\n}\n\n/** Print warning message */\nexport function warn(msg: string, silent = false) {\n  if (!silent) {\n    // biome-ignore lint/suspicious/noConsole: this is a CLI\n    console.warn(c.yellow(` ⚠  ${msg}`));\n  }\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/components-object.cjs.map b/dist/transform/components-object.cjs.map
index e462792ded6af1eea8d61da7d3c5d88389b6b9c2..e0d6dea4a2cd59f56cd32a8c224262f6da3a8315 100644
--- a/dist/transform/components-object.cjs.map
+++ b/dist/transform/components-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"components-object.cjs","sources":["../../src/transform/components-object.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport * as changeCase from \"change-case\";\nimport ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, debug, getEntries } from \"../lib/utils.js\";\nimport type { ComponentsObject, GlobalContext, SchemaObject, TransformNodeOptions } from \"../types.js\";\nimport transformHeaderObject from \"./header-object.js\";\nimport transformParameterObject from \"./parameter-object.js\";\nimport transformPathItemObject from \"./path-item-object.js\";\nimport transformRequestBodyObject from \"./request-body-object.js\";\nimport transformResponseObject from \"./response-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Determines if a schema object represents an enum type to prevent duplicate exports\n * when using --root-types and --enum flags together.\n *\n * When both flags are enabled:\n * - --enum flag generates TypeScript enums at the bottom of the file\n * - --root-types flag would normally also export these as root type aliases\n * - This results in duplicate exports (both enum and type alias for the same schema)\n *\n * This function identifies enum schemas so they can be excluded from root type generation,\n * allowing only the TypeScript enum to be generated.\n *\n * @param schema The schema object to check\n * @returns true if the schema represents an enum type\n */\nexport function isEnumSchema(schema: unknown): boolean {\n  return (\n    typeof schema === \"object\" &&\n    schema !== null &&\n    !Array.isArray(schema) &&\n    \"enum\" in schema &&\n    Array.isArray((schema as any).enum) &&\n    (!(\"type\" in schema) || (schema as any).type !== \"object\") &&\n    !(\"properties\" in schema) &&\n    !(\"additionalProperties\" in schema)\n  );\n}\n\ntype ComponentTransforms = keyof Omit<ComponentsObject, \"examples\" | \"securitySchemes\" | \"links\" | \"callbacks\">;\n\nconst transformers: Record<ComponentTransforms, (node: any, options: TransformNodeOptions) => ts.TypeNode> = {\n  schemas: transformSchemaObject,\n  responses: transformResponseObject,\n  parameters: transformParameterObject,\n  requestBodies: transformRequestBodyObject,\n  headers: transformHeaderObject,\n  pathItems: transformPathItemObject,\n};\n\n/**\n * Transform the ComponentsObject (4.8.7)\n * @see https://spec.openapis.org/oas/latest.html#components-object\n */\nexport default function transformComponentsObject(componentsObject: ComponentsObject, ctx: GlobalContext): ts.Node[] {\n  const type: ts.TypeElement[] = [];\n  const rootTypeAliases: { [key: string]: ts.TypeAliasDeclaration } = {};\n  for (const key of Object.keys(transformers) as ComponentTransforms[]) {\n    const componentT = performance.now();\n\n    const items: ts.TypeElement[] = [];\n    if (componentsObject[key]) {\n      for (const [name, item] of getEntries<SchemaObject>(componentsObject[key], ctx)) {\n        let subType = transformers[key](item, {\n          path: createRef([\"components\", key, name]),\n          schema: item,\n          ctx,\n        });\n\n        let hasQuestionToken = false;\n        if (ctx.transform) {\n          const result = ctx.transform(item, {\n            path: createRef([\"components\", key, name]),\n            schema: item,\n            ctx,\n          });\n          if (result) {\n            if (\"schema\" in result) {\n              subType = result.schema;\n              hasQuestionToken = result.questionToken;\n            } else {\n              subType = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n          /* name          */ tsPropertyIndex(name),\n          /* questionToken */ hasQuestionToken ? QUESTION_TOKEN : undefined,\n          /* type          */ subType,\n        );\n        addJSDocComment(item as unknown as any, property);\n        items.push(property);\n\n        if (ctx.rootTypes) {\n          // Skip enum schemas when generating root types to prevent duplication (only when --enum flag is enabled)\n          const shouldSkipEnumSchema = ctx.enum && key === \"schemas\" && isEnumSchema(item);\n\n          if (!shouldSkipEnumSchema) {\n            const componentKey = changeCase.pascalCase(singularizeComponentKey(key));\n            let aliasName = `${componentKey}${changeCase.pascalCase(name)}`;\n\n            // Add counter suffix (e.g. \"_2\") if conflict in name\n            let conflictCounter = 1;\n\n            while (rootTypeAliases[aliasName] !== undefined) {\n              conflictCounter++;\n              aliasName = `${componentKey}${changeCase.pascalCase(name)}_${conflictCounter}`;\n            }\n            const ref = ts.factory.createTypeReferenceNode(`components['${key}']['${name}']`);\n            if (ctx.rootTypesNoSchemaPrefix && key === \"schemas\") {\n              aliasName = aliasName.replace(componentKey, \"\");\n            }\n            const typeAlias = ts.factory.createTypeAliasDeclaration(\n              /* modifiers      */ tsModifiers({ export: true }),\n              /* name           */ aliasName,\n              /* typeParameters */ undefined,\n              /* type           */ ref,\n            );\n            rootTypeAliases[aliasName] = typeAlias;\n          }\n        }\n      }\n    }\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(key),\n        /* questionToken */ undefined,\n        /* type          */ items.length ? ts.factory.createTypeLiteralNode(items) : NEVER,\n      ),\n    );\n\n    debug(`Transformed components → ${key}`, \"ts\", performance.now() - componentT);\n  }\n\n  // Extract root types\n  let rootTypes: ts.TypeAliasDeclaration[] = [];\n  if (ctx.rootTypes) {\n    rootTypes = Object.keys(rootTypeAliases).map((k) => rootTypeAliases[k]);\n  }\n\n  return [ts.factory.createTypeLiteralNode(type), ...rootTypes];\n}\n\nexport function singularizeComponentKey(\n  key: `x-${string}` | \"schemas\" | \"responses\" | \"parameters\" | \"requestBodies\" | \"headers\" | \"pathItems\",\n): string {\n  switch (key) {\n    // Handle special singular case\n    case \"requestBodies\":\n      return \"requestBody\";\n    // Default to removing the \"s\"\n    default:\n      return key.slice(0, -1);\n  }\n}\n"],"names":["transformSchemaObject","transformResponseObject","transformParameterObject","transformRequestBodyObject","transformHeaderObject","transformPathItemObject","performance","getEntries","createRef","ts","tsModifiers","tsPropertyIndex","QUESTION_TOKEN","addJSDocComment","changeCase","NEVER","debug"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"components-object.cjs","sources":["../../src/transform/components-object.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport * as changeCase from \"change-case\";\nimport ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, debug, getEntries } from \"../lib/utils.js\";\nimport type { ComponentsObject, GlobalContext, SchemaObject, TransformNodeOptions } from \"../types.js\";\nimport transformHeaderObject from \"./header-object.js\";\nimport transformParameterObject from \"./parameter-object.js\";\nimport transformPathItemObject from \"./path-item-object.js\";\nimport transformRequestBodyObject from \"./request-body-object.js\";\nimport transformResponseObject from \"./response-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Determines if a schema object represents an enum type to prevent duplicate exports\n * when using --root-types and --enum flags together.\n *\n * When both flags are enabled:\n * - --enum flag generates TypeScript enums at the bottom of the file\n * - --root-types flag would normally also export these as root type aliases\n * - This results in duplicate exports (both enum and type alias for the same schema)\n *\n * This function identifies enum schemas so they can be excluded from root type generation,\n * allowing only the TypeScript enum to be generated.\n *\n * @param schema The schema object to check\n * @returns true if the schema represents an enum type\n */\nexport function isEnumSchema(schema: unknown): boolean {\n  return (\n    typeof schema === \"object\" &&\n    schema !== null &&\n    !Array.isArray(schema) &&\n    \"enum\" in schema &&\n    Array.isArray((schema as any).enum) &&\n    (!(\"type\" in schema) || (schema as any).type !== \"object\") &&\n    !(\"properties\" in schema) &&\n    !(\"additionalProperties\" in schema)\n  );\n}\n\ntype ComponentTransforms = keyof Omit<ComponentsObject, \"examples\" | \"securitySchemes\" | \"links\" | \"callbacks\">;\n\nconst transformers: Record<ComponentTransforms, (node: any, options: TransformNodeOptions) => ts.TypeNode> = {\n  schemas: transformSchemaObject,\n  responses: transformResponseObject,\n  parameters: transformParameterObject,\n  requestBodies: transformRequestBodyObject,\n  headers: transformHeaderObject,\n  pathItems: transformPathItemObject,\n};\n\n/**\n * Transform the ComponentsObject (4.8.7)\n * @see https://spec.openapis.org/oas/latest.html#components-object\n */\nexport default function transformComponentsObject(componentsObject: ComponentsObject, ctx: GlobalContext): ts.Node[] {\n  const type: ts.TypeElement[] = [];\n  const rootTypeAliases: { [key: string]: ts.TypeAliasDeclaration } = {};\n  for (const key of Object.keys(transformers) as ComponentTransforms[]) {\n    const componentT = performance.now();\n\n    const items: ts.TypeElement[] = [];\n    if (componentsObject[key]) {\n      for (const [name, item] of getEntries<SchemaObject>(componentsObject[key], ctx)) {\n        let subType = transformers[key](item, {\n          path: createRef([\"components\", key, name]),\n          schema: item,\n          ctx,\n        });\n\n        let hasQuestionToken = false;\n        if (ctx.transform) {\n          const result = ctx.transform(item, {\n            path: createRef([\"components\", key, name]),\n            schema: item,\n            ctx,\n          });\n          if (result) {\n            if (\"schema\" in result) {\n              subType = result.schema;\n              hasQuestionToken = result.questionToken;\n            } else {\n              subType = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n          /* name          */ tsPropertyIndex(name),\n          /* questionToken */ hasQuestionToken ? QUESTION_TOKEN : undefined,\n          /* type          */ subType,\n        );\n        addJSDocComment(item as unknown as any, property);\n        items.push(property);\n\n        if (ctx.rootTypes) {\n          // Skip enum schemas when generating root types to prevent duplication (only when --enum flag is enabled)\n          const shouldSkipEnumSchema = ctx.enum && key === \"schemas\" && isEnumSchema(item);\n\n          if (!shouldSkipEnumSchema) {\n            const componentKey = changeCase.pascalCase(singularizeComponentKey(key));\n            let aliasName = `${componentKey}${changeCase.pascalCase(name)}`;\n\n            // Add counter suffix (e.g. \"_2\") if conflict in name\n            let conflictCounter = 1;\n\n            while (rootTypeAliases[aliasName] !== undefined) {\n              conflictCounter++;\n              aliasName = `${componentKey}${changeCase.pascalCase(name)}_${conflictCounter}`;\n            }\n            const ref = ts.factory.createTypeReferenceNode(`components['${key}']['${name}']`);\n            if (ctx.rootTypesNoSchemaPrefix && key === \"schemas\") {\n              aliasName = aliasName.replace(componentKey, \"\");\n            }\n            const typeAlias = ts.factory.createTypeAliasDeclaration(\n              /* modifiers      */ tsModifiers({ export: true }),\n              /* name           */ aliasName,\n              /* typeParameters */ undefined,\n              /* type           */ ref,\n            );\n            rootTypeAliases[aliasName] = typeAlias;\n          }\n        }\n      }\n    }\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(key),\n        /* questionToken */ undefined,\n        /* type          */ items.length ? ts.factory.createTypeLiteralNode(items) : NEVER,\n      ),\n    );\n\n    debug(`Transformed components → ${key}`, \"ts\", performance.now() - componentT);\n  }\n\n  // Extract root types\n  let rootTypes: ts.TypeAliasDeclaration[] = [];\n  if (ctx.rootTypes) {\n    rootTypes = Object.keys(rootTypeAliases).map((k) => rootTypeAliases[k]);\n  }\n\n  return [ts.factory.createTypeLiteralNode(type), ...rootTypes];\n}\n\nexport function singularizeComponentKey(\n  key: `x-${string}` | \"schemas\" | \"responses\" | \"parameters\" | \"requestBodies\" | \"headers\" | \"pathItems\",\n): string {\n  switch (key) {\n    // Handle special singular case\n    case \"requestBodies\":\n      return \"requestBody\";\n    // Default to removing the \"s\"\n    default:\n      return key.slice(0, -1);\n  }\n}\n"],"names":["transformSchemaObject","transformResponseObject","transformParameterObject","transformRequestBodyObject","transformHeaderObject","transformPathItemObject","performance","getEntries","createRef","ts","tsModifiers","tsPropertyIndex","QUESTION_TOKEN","addJSDocComment","changeCase","NEVER","debug"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/components-object.mjs.map b/dist/transform/components-object.mjs.map
index 42f812c51dbb5217c1e0e40d5aa428dd26770162..13e1b0311f66df9f63c0710f17c6b0a2d04936c6 100644
--- a/dist/transform/components-object.mjs.map
+++ b/dist/transform/components-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"components-object.mjs","sources":["../../src/transform/components-object.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport * as changeCase from \"change-case\";\nimport ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, debug, getEntries } from \"../lib/utils.js\";\nimport type { ComponentsObject, GlobalContext, SchemaObject, TransformNodeOptions } from \"../types.js\";\nimport transformHeaderObject from \"./header-object.js\";\nimport transformParameterObject from \"./parameter-object.js\";\nimport transformPathItemObject from \"./path-item-object.js\";\nimport transformRequestBodyObject from \"./request-body-object.js\";\nimport transformResponseObject from \"./response-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Determines if a schema object represents an enum type to prevent duplicate exports\n * when using --root-types and --enum flags together.\n *\n * When both flags are enabled:\n * - --enum flag generates TypeScript enums at the bottom of the file\n * - --root-types flag would normally also export these as root type aliases\n * - This results in duplicate exports (both enum and type alias for the same schema)\n *\n * This function identifies enum schemas so they can be excluded from root type generation,\n * allowing only the TypeScript enum to be generated.\n *\n * @param schema The schema object to check\n * @returns true if the schema represents an enum type\n */\nexport function isEnumSchema(schema: unknown): boolean {\n  return (\n    typeof schema === \"object\" &&\n    schema !== null &&\n    !Array.isArray(schema) &&\n    \"enum\" in schema &&\n    Array.isArray((schema as any).enum) &&\n    (!(\"type\" in schema) || (schema as any).type !== \"object\") &&\n    !(\"properties\" in schema) &&\n    !(\"additionalProperties\" in schema)\n  );\n}\n\ntype ComponentTransforms = keyof Omit<ComponentsObject, \"examples\" | \"securitySchemes\" | \"links\" | \"callbacks\">;\n\nconst transformers: Record<ComponentTransforms, (node: any, options: TransformNodeOptions) => ts.TypeNode> = {\n  schemas: transformSchemaObject,\n  responses: transformResponseObject,\n  parameters: transformParameterObject,\n  requestBodies: transformRequestBodyObject,\n  headers: transformHeaderObject,\n  pathItems: transformPathItemObject,\n};\n\n/**\n * Transform the ComponentsObject (4.8.7)\n * @see https://spec.openapis.org/oas/latest.html#components-object\n */\nexport default function transformComponentsObject(componentsObject: ComponentsObject, ctx: GlobalContext): ts.Node[] {\n  const type: ts.TypeElement[] = [];\n  const rootTypeAliases: { [key: string]: ts.TypeAliasDeclaration } = {};\n  for (const key of Object.keys(transformers) as ComponentTransforms[]) {\n    const componentT = performance.now();\n\n    const items: ts.TypeElement[] = [];\n    if (componentsObject[key]) {\n      for (const [name, item] of getEntries<SchemaObject>(componentsObject[key], ctx)) {\n        let subType = transformers[key](item, {\n          path: createRef([\"components\", key, name]),\n          schema: item,\n          ctx,\n        });\n\n        let hasQuestionToken = false;\n        if (ctx.transform) {\n          const result = ctx.transform(item, {\n            path: createRef([\"components\", key, name]),\n            schema: item,\n            ctx,\n          });\n          if (result) {\n            if (\"schema\" in result) {\n              subType = result.schema;\n              hasQuestionToken = result.questionToken;\n            } else {\n              subType = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n          /* name          */ tsPropertyIndex(name),\n          /* questionToken */ hasQuestionToken ? QUESTION_TOKEN : undefined,\n          /* type          */ subType,\n        );\n        addJSDocComment(item as unknown as any, property);\n        items.push(property);\n\n        if (ctx.rootTypes) {\n          // Skip enum schemas when generating root types to prevent duplication (only when --enum flag is enabled)\n          const shouldSkipEnumSchema = ctx.enum && key === \"schemas\" && isEnumSchema(item);\n\n          if (!shouldSkipEnumSchema) {\n            const componentKey = changeCase.pascalCase(singularizeComponentKey(key));\n            let aliasName = `${componentKey}${changeCase.pascalCase(name)}`;\n\n            // Add counter suffix (e.g. \"_2\") if conflict in name\n            let conflictCounter = 1;\n\n            while (rootTypeAliases[aliasName] !== undefined) {\n              conflictCounter++;\n              aliasName = `${componentKey}${changeCase.pascalCase(name)}_${conflictCounter}`;\n            }\n            const ref = ts.factory.createTypeReferenceNode(`components['${key}']['${name}']`);\n            if (ctx.rootTypesNoSchemaPrefix && key === \"schemas\") {\n              aliasName = aliasName.replace(componentKey, \"\");\n            }\n            const typeAlias = ts.factory.createTypeAliasDeclaration(\n              /* modifiers      */ tsModifiers({ export: true }),\n              /* name           */ aliasName,\n              /* typeParameters */ undefined,\n              /* type           */ ref,\n            );\n            rootTypeAliases[aliasName] = typeAlias;\n          }\n        }\n      }\n    }\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(key),\n        /* questionToken */ undefined,\n        /* type          */ items.length ? ts.factory.createTypeLiteralNode(items) : NEVER,\n      ),\n    );\n\n    debug(`Transformed components → ${key}`, \"ts\", performance.now() - componentT);\n  }\n\n  // Extract root types\n  let rootTypes: ts.TypeAliasDeclaration[] = [];\n  if (ctx.rootTypes) {\n    rootTypes = Object.keys(rootTypeAliases).map((k) => rootTypeAliases[k]);\n  }\n\n  return [ts.factory.createTypeLiteralNode(type), ...rootTypes];\n}\n\nexport function singularizeComponentKey(\n  key: `x-${string}` | \"schemas\" | \"responses\" | \"parameters\" | \"requestBodies\" | \"headers\" | \"pathItems\",\n): string {\n  switch (key) {\n    // Handle special singular case\n    case \"requestBodies\":\n      return \"requestBody\";\n    // Default to removing the \"s\"\n    default:\n      return key.slice(0, -1);\n  }\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"components-object.mjs","sources":["../../src/transform/components-object.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport * as changeCase from \"change-case\";\nimport ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, debug, getEntries } from \"../lib/utils.js\";\nimport type { ComponentsObject, GlobalContext, SchemaObject, TransformNodeOptions } from \"../types.js\";\nimport transformHeaderObject from \"./header-object.js\";\nimport transformParameterObject from \"./parameter-object.js\";\nimport transformPathItemObject from \"./path-item-object.js\";\nimport transformRequestBodyObject from \"./request-body-object.js\";\nimport transformResponseObject from \"./response-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Determines if a schema object represents an enum type to prevent duplicate exports\n * when using --root-types and --enum flags together.\n *\n * When both flags are enabled:\n * - --enum flag generates TypeScript enums at the bottom of the file\n * - --root-types flag would normally also export these as root type aliases\n * - This results in duplicate exports (both enum and type alias for the same schema)\n *\n * This function identifies enum schemas so they can be excluded from root type generation,\n * allowing only the TypeScript enum to be generated.\n *\n * @param schema The schema object to check\n * @returns true if the schema represents an enum type\n */\nexport function isEnumSchema(schema: unknown): boolean {\n  return (\n    typeof schema === \"object\" &&\n    schema !== null &&\n    !Array.isArray(schema) &&\n    \"enum\" in schema &&\n    Array.isArray((schema as any).enum) &&\n    (!(\"type\" in schema) || (schema as any).type !== \"object\") &&\n    !(\"properties\" in schema) &&\n    !(\"additionalProperties\" in schema)\n  );\n}\n\ntype ComponentTransforms = keyof Omit<ComponentsObject, \"examples\" | \"securitySchemes\" | \"links\" | \"callbacks\">;\n\nconst transformers: Record<ComponentTransforms, (node: any, options: TransformNodeOptions) => ts.TypeNode> = {\n  schemas: transformSchemaObject,\n  responses: transformResponseObject,\n  parameters: transformParameterObject,\n  requestBodies: transformRequestBodyObject,\n  headers: transformHeaderObject,\n  pathItems: transformPathItemObject,\n};\n\n/**\n * Transform the ComponentsObject (4.8.7)\n * @see https://spec.openapis.org/oas/latest.html#components-object\n */\nexport default function transformComponentsObject(componentsObject: ComponentsObject, ctx: GlobalContext): ts.Node[] {\n  const type: ts.TypeElement[] = [];\n  const rootTypeAliases: { [key: string]: ts.TypeAliasDeclaration } = {};\n  for (const key of Object.keys(transformers) as ComponentTransforms[]) {\n    const componentT = performance.now();\n\n    const items: ts.TypeElement[] = [];\n    if (componentsObject[key]) {\n      for (const [name, item] of getEntries<SchemaObject>(componentsObject[key], ctx)) {\n        let subType = transformers[key](item, {\n          path: createRef([\"components\", key, name]),\n          schema: item,\n          ctx,\n        });\n\n        let hasQuestionToken = false;\n        if (ctx.transform) {\n          const result = ctx.transform(item, {\n            path: createRef([\"components\", key, name]),\n            schema: item,\n            ctx,\n          });\n          if (result) {\n            if (\"schema\" in result) {\n              subType = result.schema;\n              hasQuestionToken = result.questionToken;\n            } else {\n              subType = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n          /* name          */ tsPropertyIndex(name),\n          /* questionToken */ hasQuestionToken ? QUESTION_TOKEN : undefined,\n          /* type          */ subType,\n        );\n        addJSDocComment(item as unknown as any, property);\n        items.push(property);\n\n        if (ctx.rootTypes) {\n          // Skip enum schemas when generating root types to prevent duplication (only when --enum flag is enabled)\n          const shouldSkipEnumSchema = ctx.enum && key === \"schemas\" && isEnumSchema(item);\n\n          if (!shouldSkipEnumSchema) {\n            const componentKey = changeCase.pascalCase(singularizeComponentKey(key));\n            let aliasName = `${componentKey}${changeCase.pascalCase(name)}`;\n\n            // Add counter suffix (e.g. \"_2\") if conflict in name\n            let conflictCounter = 1;\n\n            while (rootTypeAliases[aliasName] !== undefined) {\n              conflictCounter++;\n              aliasName = `${componentKey}${changeCase.pascalCase(name)}_${conflictCounter}`;\n            }\n            const ref = ts.factory.createTypeReferenceNode(`components['${key}']['${name}']`);\n            if (ctx.rootTypesNoSchemaPrefix && key === \"schemas\") {\n              aliasName = aliasName.replace(componentKey, \"\");\n            }\n            const typeAlias = ts.factory.createTypeAliasDeclaration(\n              /* modifiers      */ tsModifiers({ export: true }),\n              /* name           */ aliasName,\n              /* typeParameters */ undefined,\n              /* type           */ ref,\n            );\n            rootTypeAliases[aliasName] = typeAlias;\n          }\n        }\n      }\n    }\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(key),\n        /* questionToken */ undefined,\n        /* type          */ items.length ? ts.factory.createTypeLiteralNode(items) : NEVER,\n      ),\n    );\n\n    debug(`Transformed components → ${key}`, \"ts\", performance.now() - componentT);\n  }\n\n  // Extract root types\n  let rootTypes: ts.TypeAliasDeclaration[] = [];\n  if (ctx.rootTypes) {\n    rootTypes = Object.keys(rootTypeAliases).map((k) => rootTypeAliases[k]);\n  }\n\n  return [ts.factory.createTypeLiteralNode(type), ...rootTypes];\n}\n\nexport function singularizeComponentKey(\n  key: `x-${string}` | \"schemas\" | \"responses\" | \"parameters\" | \"requestBodies\" | \"headers\" | \"pathItems\",\n): string {\n  switch (key) {\n    // Handle special singular case\n    case \"requestBodies\":\n      return \"requestBody\";\n    // Default to removing the \"s\"\n    default:\n      return key.slice(0, -1);\n  }\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/header-object.cjs.map b/dist/transform/header-object.cjs.map
index 5f9f7cdfd1ae7a53cf028f68480fab06db9aed15..b255677862e7fb97e5c7f081642eb193b64e9af7 100644
--- a/dist/transform/header-object.cjs.map
+++ b/dist/transform/header-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"header-object.cjs","sources":["../../src/transform/header-object.ts"],"sourcesContent":["import { escapePointer } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport { addJSDocComment, tsModifiers, tsPropertyIndex, UNKNOWN } from \"../lib/ts.js\";\nimport { getEntries } from \"../lib/utils.js\";\nimport type { HeaderObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform HeaderObject nodes (4.8.21)\n * @see https://spec.openapis.org/oas/v3.1.0#header-object\n */\nexport default function transformHeaderObject(headerObject: HeaderObject, options: TransformNodeOptions): ts.TypeNode {\n  if (headerObject.schema) {\n    return transformSchemaObject(headerObject.schema, options);\n  }\n\n  if (headerObject.content) {\n    const type: ts.TypeElement[] = [];\n    for (const [contentType, mediaTypeObject] of getEntries(headerObject.content ?? {}, options.ctx)) {\n      const nextPath = `${options.path ?? \"#\"}/${escapePointer(contentType)}`;\n      const mediaType =\n        \"$ref\" in mediaTypeObject\n          ? transformSchemaObject(mediaTypeObject, {\n              ...options,\n              path: nextPath,\n            })\n          : transformMediaTypeObject(mediaTypeObject, {\n              ...options,\n              path: nextPath,\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(contentType),\n        /* questionToken */ undefined,\n        /* type          */ mediaType,\n      );\n      addJSDocComment(mediaTypeObject, property);\n      type.push(property);\n    }\n    return ts.factory.createTypeLiteralNode(type);\n  }\n\n  return UNKNOWN;\n}\n"],"names":["transformSchemaObject","mediaTypeObject","getEntries","escapePointer","transformMediaTypeObject","ts","tsModifiers","tsPropertyIndex","addJSDocComment","UNKNOWN"],"mappings":";;;;;;;;;;;;;AAYA,SAAwB,qBAAA,CAAsB,cAA4B,OAAA,EAA4C;AACpH,EAAA,IAAI,aAAa,MAAA,EAAQ;AACvB,IAAA,OAAOA,oBAAA,CAAsB,YAAA,CAAa,MAAA,EAAQ,OAAO,CAAA;AAAA,EAC3D;AAEA,EAAA,IAAI,aAAa,OAAA,EAAS;AACxB,IAAA,MAAM,OAAyB,EAAC;AAChC,IAAA,KAAA,MAAW,CAAC,WAAA,EAAaC,iBAAe,CAAA,IAAKC,gBAAA,CAAW,YAAA,CAAa,OAAA,IAAW,EAAC,EAAG,OAAA,CAAQ,GAAG,CAAA,EAAG;AAChG,MAAA,MAAM,QAAA,GAAW,GAAG,OAAA,CAAQ,IAAA,IAAQ,GAAG,CAAA,CAAA,EAAIC,yBAAA,CAAc,WAAW,CAAC,CAAA,CAAA;AACrE,MAAA,MAAM,SAAA,GACJ,MAAA,IAAUF,iBAAA,GACND,oBAAA,CAAsBC,iBAAA,EAAiB;AAAA,QACrC,GAAG,OAAA;AAAA,QACH,IAAA,EAAM;AAAA,OACP,CAAA,GACDG,eAAA,CAAyBH,iBAAA,EAAiB;AAAA,QACxC,GAAG,OAAA;AAAA,QACH,IAAA,EAAM;AAAA,OACP,CAAA;AACP,MAAA,MAAM,QAAA,GAAWI,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,QACNC,iBAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,QAC/CC,qBAAgB,WAAW,CAAA;AAAA;AAAA,QAC3B,MAAA;AAAA;AAAA,QACA;AAAA,OACtB;AACA,MAAAC,oBAAA,CAAgBP,mBAAiB,QAAQ,CAAA;AACzC,MAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,IACpB;AACA,IAAA,OAAOI,WAAA,CAAG,OAAA,CAAQ,qBAAA,CAAsB,IAAI,CAAA;AAAA,EAC9C;AAEA,EAAA,OAAOI,YAAA;AACT;;;;"}
\ No newline at end of file
+{"version":3,"file":"header-object.cjs","sources":["../../src/transform/header-object.ts"],"sourcesContent":["import { escapePointer } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport { addJSDocComment, tsModifiers, tsPropertyIndex, UNKNOWN } from \"../lib/ts.js\";\nimport { getEntries } from \"../lib/utils.js\";\nimport type { HeaderObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform HeaderObject nodes (4.8.21)\n * @see https://spec.openapis.org/oas/v3.1.0#header-object\n */\nexport default function transformHeaderObject(headerObject: HeaderObject, options: TransformNodeOptions): ts.TypeNode {\n  if (headerObject.schema) {\n    return transformSchemaObject(headerObject.schema, options);\n  }\n\n  if (headerObject.content) {\n    const type: ts.TypeElement[] = [];\n    for (const [contentType, mediaTypeObject] of getEntries(headerObject.content ?? {}, options.ctx)) {\n      const nextPath = `${options.path ?? \"#\"}/${escapePointer(contentType)}`;\n      const mediaType =\n        \"$ref\" in mediaTypeObject\n          ? transformSchemaObject(mediaTypeObject, {\n              ...options,\n              path: nextPath,\n            })\n          : transformMediaTypeObject(mediaTypeObject, {\n              ...options,\n              path: nextPath,\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(contentType),\n        /* questionToken */ undefined,\n        /* type          */ mediaType,\n      );\n      addJSDocComment(mediaTypeObject, property);\n      type.push(property);\n    }\n    return ts.factory.createTypeLiteralNode(type);\n  }\n\n  return UNKNOWN;\n}\n"],"names":["transformSchemaObject","mediaTypeObject","getEntries","escapePointer","transformMediaTypeObject","ts","tsModifiers","tsPropertyIndex","addJSDocComment","UNKNOWN"],"mappings":";;;;;;;;;;;;;AAYwB,SAAA,qBAAA,CAAsB,cAA4B,OAA4C,EAAA;AACpH,EAAA,IAAI,aAAa,MAAQ,EAAA;AACvB,IAAO,OAAAA,oBAAA,CAAsB,YAAa,CAAA,MAAA,EAAQ,OAAO,CAAA;AAAA;AAG3D,EAAA,IAAI,aAAa,OAAS,EAAA;AACxB,IAAA,MAAM,OAAyB,EAAC;AAChC,IAAW,KAAA,MAAA,CAAC,WAAa,EAAAC,iBAAe,CAAK,IAAAC,gBAAA,CAAW,YAAa,CAAA,OAAA,IAAW,EAAC,EAAG,OAAQ,CAAA,GAAG,CAAG,EAAA;AAChG,MAAM,MAAA,QAAA,GAAW,GAAG,OAAQ,CAAA,IAAA,IAAQ,GAAG,CAAI,CAAA,EAAAC,yBAAA,CAAc,WAAW,CAAC,CAAA,CAAA;AACrE,MAAA,MAAM,SACJ,GAAA,MAAA,IAAUF,iBACN,GAAAD,oBAAA,CAAsBC,iBAAiB,EAAA;AAAA,QACrC,GAAG,OAAA;AAAA,QACH,IAAM,EAAA;AAAA,OACP,CACD,GAAAG,eAAA,CAAyBH,iBAAiB,EAAA;AAAA,QACxC,GAAG,OAAA;AAAA,QACH,IAAM,EAAA;AAAA,OACP,CAAA;AACP,MAAM,MAAA,QAAA,GAAWI,YAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,QACNC,iBAAY,EAAE,QAAA,EAAU,OAAQ,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,QAC/CC,qBAAgB,WAAW,CAAA;AAAA;AAAA,QAC3B,MAAA;AAAA;AAAA,QACA;AAAA,OACtB;AACA,MAAAC,oBAAA,CAAgBP,mBAAiB,QAAQ,CAAA;AACzC,MAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA;AAEpB,IAAO,OAAAI,WAAA,CAAG,OAAQ,CAAA,qBAAA,CAAsB,IAAI,CAAA;AAAA;AAG9C,EAAO,OAAAI,YAAA;AACT;;;;"}
\ No newline at end of file
diff --git a/dist/transform/header-object.mjs.map b/dist/transform/header-object.mjs.map
index 3a758586dc0457fa2614c7d1c2521037300d84a3..ef8e3c1fb772e667747f4e30f5a21833e96e4b47 100644
--- a/dist/transform/header-object.mjs.map
+++ b/dist/transform/header-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"header-object.mjs","sources":["../../src/transform/header-object.ts"],"sourcesContent":["import { escapePointer } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport { addJSDocComment, tsModifiers, tsPropertyIndex, UNKNOWN } from \"../lib/ts.js\";\nimport { getEntries } from \"../lib/utils.js\";\nimport type { HeaderObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform HeaderObject nodes (4.8.21)\n * @see https://spec.openapis.org/oas/v3.1.0#header-object\n */\nexport default function transformHeaderObject(headerObject: HeaderObject, options: TransformNodeOptions): ts.TypeNode {\n  if (headerObject.schema) {\n    return transformSchemaObject(headerObject.schema, options);\n  }\n\n  if (headerObject.content) {\n    const type: ts.TypeElement[] = [];\n    for (const [contentType, mediaTypeObject] of getEntries(headerObject.content ?? {}, options.ctx)) {\n      const nextPath = `${options.path ?? \"#\"}/${escapePointer(contentType)}`;\n      const mediaType =\n        \"$ref\" in mediaTypeObject\n          ? transformSchemaObject(mediaTypeObject, {\n              ...options,\n              path: nextPath,\n            })\n          : transformMediaTypeObject(mediaTypeObject, {\n              ...options,\n              path: nextPath,\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(contentType),\n        /* questionToken */ undefined,\n        /* type          */ mediaType,\n      );\n      addJSDocComment(mediaTypeObject, property);\n      type.push(property);\n    }\n    return ts.factory.createTypeLiteralNode(type);\n  }\n\n  return UNKNOWN;\n}\n"],"names":[],"mappings":";;;;;;;AAYA,SAAwB,qBAAA,CAAsB,cAA4B,OAAA,EAA4C;AACpH,EAAA,IAAI,aAAa,MAAA,EAAQ;AACvB,IAAA,OAAO,qBAAA,CAAsB,YAAA,CAAa,MAAA,EAAQ,OAAO,CAAA;AAAA,EAC3D;AAEA,EAAA,IAAI,aAAa,OAAA,EAAS;AACxB,IAAA,MAAM,OAAyB,EAAC;AAChC,IAAA,KAAA,MAAW,CAAC,WAAA,EAAa,eAAe,CAAA,IAAK,UAAA,CAAW,YAAA,CAAa,OAAA,IAAW,EAAC,EAAG,OAAA,CAAQ,GAAG,CAAA,EAAG;AAChG,MAAA,MAAM,QAAA,GAAW,GAAG,OAAA,CAAQ,IAAA,IAAQ,GAAG,CAAA,CAAA,EAAI,aAAA,CAAc,WAAW,CAAC,CAAA,CAAA;AACrE,MAAA,MAAM,SAAA,GACJ,MAAA,IAAU,eAAA,GACN,qBAAA,CAAsB,eAAA,EAAiB;AAAA,QACrC,GAAG,OAAA;AAAA,QACH,IAAA,EAAM;AAAA,OACP,CAAA,GACD,wBAAA,CAAyB,eAAA,EAAiB;AAAA,QACxC,GAAG,OAAA;AAAA,QACH,IAAA,EAAM;AAAA,OACP,CAAA;AACP,MAAA,MAAM,QAAA,GAAW,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,QACN,YAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,QAC/C,gBAAgB,WAAW,CAAA;AAAA;AAAA,QAC3B,MAAA;AAAA;AAAA,QACA;AAAA,OACtB;AACA,MAAA,eAAA,CAAgB,iBAAiB,QAAQ,CAAA;AACzC,MAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,IACpB;AACA,IAAA,OAAO,EAAA,CAAG,OAAA,CAAQ,qBAAA,CAAsB,IAAI,CAAA;AAAA,EAC9C;AAEA,EAAA,OAAO,OAAA;AACT;;;;"}
\ No newline at end of file
+{"version":3,"file":"header-object.mjs","sources":["../../src/transform/header-object.ts"],"sourcesContent":["import { escapePointer } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport { addJSDocComment, tsModifiers, tsPropertyIndex, UNKNOWN } from \"../lib/ts.js\";\nimport { getEntries } from \"../lib/utils.js\";\nimport type { HeaderObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform HeaderObject nodes (4.8.21)\n * @see https://spec.openapis.org/oas/v3.1.0#header-object\n */\nexport default function transformHeaderObject(headerObject: HeaderObject, options: TransformNodeOptions): ts.TypeNode {\n  if (headerObject.schema) {\n    return transformSchemaObject(headerObject.schema, options);\n  }\n\n  if (headerObject.content) {\n    const type: ts.TypeElement[] = [];\n    for (const [contentType, mediaTypeObject] of getEntries(headerObject.content ?? {}, options.ctx)) {\n      const nextPath = `${options.path ?? \"#\"}/${escapePointer(contentType)}`;\n      const mediaType =\n        \"$ref\" in mediaTypeObject\n          ? transformSchemaObject(mediaTypeObject, {\n              ...options,\n              path: nextPath,\n            })\n          : transformMediaTypeObject(mediaTypeObject, {\n              ...options,\n              path: nextPath,\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(contentType),\n        /* questionToken */ undefined,\n        /* type          */ mediaType,\n      );\n      addJSDocComment(mediaTypeObject, property);\n      type.push(property);\n    }\n    return ts.factory.createTypeLiteralNode(type);\n  }\n\n  return UNKNOWN;\n}\n"],"names":[],"mappings":";;;;;;;AAYwB,SAAA,qBAAA,CAAsB,cAA4B,OAA4C,EAAA;AACpH,EAAA,IAAI,aAAa,MAAQ,EAAA;AACvB,IAAO,OAAA,qBAAA,CAAsB,YAAa,CAAA,MAAA,EAAQ,OAAO,CAAA;AAAA;AAG3D,EAAA,IAAI,aAAa,OAAS,EAAA;AACxB,IAAA,MAAM,OAAyB,EAAC;AAChC,IAAW,KAAA,MAAA,CAAC,WAAa,EAAA,eAAe,CAAK,IAAA,UAAA,CAAW,YAAa,CAAA,OAAA,IAAW,EAAC,EAAG,OAAQ,CAAA,GAAG,CAAG,EAAA;AAChG,MAAM,MAAA,QAAA,GAAW,GAAG,OAAQ,CAAA,IAAA,IAAQ,GAAG,CAAI,CAAA,EAAA,aAAA,CAAc,WAAW,CAAC,CAAA,CAAA;AACrE,MAAA,MAAM,SACJ,GAAA,MAAA,IAAU,eACN,GAAA,qBAAA,CAAsB,eAAiB,EAAA;AAAA,QACrC,GAAG,OAAA;AAAA,QACH,IAAM,EAAA;AAAA,OACP,CACD,GAAA,wBAAA,CAAyB,eAAiB,EAAA;AAAA,QACxC,GAAG,OAAA;AAAA,QACH,IAAM,EAAA;AAAA,OACP,CAAA;AACP,MAAM,MAAA,QAAA,GAAW,GAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,QACN,YAAY,EAAE,QAAA,EAAU,OAAQ,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,QAC/C,gBAAgB,WAAW,CAAA;AAAA;AAAA,QAC3B,MAAA;AAAA;AAAA,QACA;AAAA,OACtB;AACA,MAAA,eAAA,CAAgB,iBAAiB,QAAQ,CAAA;AACzC,MAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA;AAEpB,IAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,qBAAA,CAAsB,IAAI,CAAA;AAAA;AAG9C,EAAO,OAAA,OAAA;AACT;;;;"}
\ No newline at end of file
diff --git a/dist/transform/index.cjs.map b/dist/transform/index.cjs.map
index 5de381bde0f275d86ff2bfc529d48f7994a6f3c1..d13209146bf3c2262d3bf785ffce76e7d7b93e13 100644
--- a/dist/transform/index.cjs.map
+++ b/dist/transform/index.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs","sources":["../../src/transform/index.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport ts, { type InterfaceDeclaration, type TypeLiteralNode } from \"typescript\";\nimport { NEVER, STRING, stringToAST, tsModifiers, tsRecord } from \"../lib/ts.js\";\nimport { createRef, debug } from \"../lib/utils.js\";\nimport type { GlobalContext, OpenAPI3 } from \"../types.js\";\nimport transformComponentsObject from \"./components-object.js\";\nimport makeApiPathsEnum from \"./paths-enum.js\";\nimport transformPathsObject from \"./paths-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\nimport transformWebhooksObject from \"./webhooks-object.js\";\n\ntype SchemaTransforms = keyof Pick<OpenAPI3, \"paths\" | \"webhooks\" | \"components\" | \"$defs\">;\n\nconst transformers: Record<SchemaTransforms, (node: any, options: GlobalContext) => ts.Node | ts.Node[]> = {\n  paths: transformPathsObject,\n  webhooks: transformWebhooksObject,\n  components: transformComponentsObject,\n  $defs: (node, options) => transformSchemaObject(node, { path: createRef([\"$defs\"]), ctx: options, schema: node }),\n};\n\nexport default function transformSchema(schema: OpenAPI3, ctx: GlobalContext) {\n  const type: ts.Node[] = [];\n\n  if (ctx.inject) {\n    const injectNodes = stringToAST(ctx.inject) as ts.Node[];\n    type.push(...injectNodes);\n  }\n\n  for (const root of Object.keys(transformers) as SchemaTransforms[]) {\n    const emptyObj = ts.factory.createTypeAliasDeclaration(\n      /* modifiers      */ tsModifiers({ export: true }),\n      /* name           */ root,\n      /* typeParameters */ undefined,\n      /* type           */ tsRecord(STRING, NEVER),\n    );\n\n    if (schema[root] && typeof schema[root] === \"object\") {\n      const rootT = performance.now();\n      const subTypes = ([] as ts.Node[]).concat(transformers[root](schema[root], ctx));\n      for (const subType of subTypes) {\n        if (ts.isTypeNode(subType)) {\n          if ((subType as ts.TypeLiteralNode).members?.length) {\n            type.push(\n              ctx.exportType\n                ? ts.factory.createTypeAliasDeclaration(\n                    /* modifiers      */ tsModifiers({ export: true }),\n                    /* name           */ root,\n                    /* typeParameters */ undefined,\n                    /* type           */ subType,\n                  )\n                : ts.factory.createInterfaceDeclaration(\n                    /* modifiers       */ tsModifiers({ export: true }),\n                    /* name            */ root,\n                    /* typeParameters  */ undefined,\n                    /* heritageClauses */ undefined,\n                    /* members         */ (subType as TypeLiteralNode).members,\n                  ),\n            );\n            debug(`${root} done`, \"ts\", performance.now() - rootT);\n          } else {\n            type.push(emptyObj);\n            debug(`${root} done (skipped)`, \"ts\", 0);\n          }\n        } else if (ts.isTypeAliasDeclaration(subType)) {\n          type.push(subType);\n        } else {\n          type.push(emptyObj);\n          debug(`${root} done (skipped)`, \"ts\", 0);\n        }\n      }\n    } else {\n      type.push(emptyObj);\n      debug(`${root} done (skipped)`, \"ts\", 0);\n    }\n  }\n\n  // inject\n  let hasOperations = false;\n  for (const injectedType of ctx.injectFooter) {\n    if (!hasOperations && (injectedType as InterfaceDeclaration)?.name?.escapedText === \"operations\") {\n      hasOperations = true;\n    }\n    type.push(injectedType);\n  }\n  if (!hasOperations) {\n    // if no operations created, inject empty operations type\n    type.push(\n      ts.factory.createTypeAliasDeclaration(\n        /* modifiers      */ tsModifiers({ export: true }),\n        /* name           */ \"operations\",\n        /* typeParameters */ undefined,\n        /* type           */ tsRecord(STRING, NEVER),\n      ),\n    );\n  }\n\n  if (ctx.makePathsEnum && schema.paths) {\n    type.push(makeApiPathsEnum(schema.paths));\n  }\n\n  return type;\n}\n"],"names":["transformPathsObject","transformWebhooksObject","transformComponentsObject","transformSchemaObject","createRef","stringToAST","ts","tsModifiers","tsRecord","STRING","NEVER","performance","debug","makeApiPathsEnum"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.cjs","sources":["../../src/transform/index.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport ts, { type InterfaceDeclaration, type TypeLiteralNode } from \"typescript\";\nimport { NEVER, STRING, stringToAST, tsModifiers, tsRecord } from \"../lib/ts.js\";\nimport { createRef, debug } from \"../lib/utils.js\";\nimport type { GlobalContext, OpenAPI3 } from \"../types.js\";\nimport transformComponentsObject from \"./components-object.js\";\nimport makeApiPathsEnum from \"./paths-enum.js\";\nimport transformPathsObject from \"./paths-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\nimport transformWebhooksObject from \"./webhooks-object.js\";\n\ntype SchemaTransforms = keyof Pick<OpenAPI3, \"paths\" | \"webhooks\" | \"components\" | \"$defs\">;\n\nconst transformers: Record<SchemaTransforms, (node: any, options: GlobalContext) => ts.Node | ts.Node[]> = {\n  paths: transformPathsObject,\n  webhooks: transformWebhooksObject,\n  components: transformComponentsObject,\n  $defs: (node, options) => transformSchemaObject(node, { path: createRef([\"$defs\"]), ctx: options, schema: node }),\n};\n\nexport default function transformSchema(schema: OpenAPI3, ctx: GlobalContext) {\n  const type: ts.Node[] = [];\n\n  if (ctx.inject) {\n    const injectNodes = stringToAST(ctx.inject) as ts.Node[];\n    type.push(...injectNodes);\n  }\n\n  for (const root of Object.keys(transformers) as SchemaTransforms[]) {\n    const emptyObj = ts.factory.createTypeAliasDeclaration(\n      /* modifiers      */ tsModifiers({ export: true }),\n      /* name           */ root,\n      /* typeParameters */ undefined,\n      /* type           */ tsRecord(STRING, NEVER),\n    );\n\n    if (schema[root] && typeof schema[root] === \"object\") {\n      const rootT = performance.now();\n      const subTypes = ([] as ts.Node[]).concat(transformers[root](schema[root], ctx));\n      for (const subType of subTypes) {\n        if (ts.isTypeNode(subType)) {\n          if ((subType as ts.TypeLiteralNode).members?.length) {\n            type.push(\n              ctx.exportType\n                ? ts.factory.createTypeAliasDeclaration(\n                    /* modifiers      */ tsModifiers({ export: true }),\n                    /* name           */ root,\n                    /* typeParameters */ undefined,\n                    /* type           */ subType,\n                  )\n                : ts.factory.createInterfaceDeclaration(\n                    /* modifiers       */ tsModifiers({ export: true }),\n                    /* name            */ root,\n                    /* typeParameters  */ undefined,\n                    /* heritageClauses */ undefined,\n                    /* members         */ (subType as TypeLiteralNode).members,\n                  ),\n            );\n            debug(`${root} done`, \"ts\", performance.now() - rootT);\n          } else {\n            type.push(emptyObj);\n            debug(`${root} done (skipped)`, \"ts\", 0);\n          }\n        } else if (ts.isTypeAliasDeclaration(subType)) {\n          type.push(subType);\n        } else {\n          type.push(emptyObj);\n          debug(`${root} done (skipped)`, \"ts\", 0);\n        }\n      }\n    } else {\n      type.push(emptyObj);\n      debug(`${root} done (skipped)`, \"ts\", 0);\n    }\n  }\n\n  // inject\n  let hasOperations = false;\n  for (const injectedType of ctx.injectFooter) {\n    if (!hasOperations && (injectedType as InterfaceDeclaration)?.name?.escapedText === \"operations\") {\n      hasOperations = true;\n    }\n    type.push(injectedType);\n  }\n  if (!hasOperations) {\n    // if no operations created, inject empty operations type\n    type.push(\n      ts.factory.createTypeAliasDeclaration(\n        /* modifiers      */ tsModifiers({ export: true }),\n        /* name           */ \"operations\",\n        /* typeParameters */ undefined,\n        /* type           */ tsRecord(STRING, NEVER),\n      ),\n    );\n  }\n\n  if (ctx.makePathsEnum && schema.paths) {\n    type.push(makeApiPathsEnum(schema.paths));\n  }\n\n  return type;\n}\n"],"names":["transformPathsObject","transformWebhooksObject","transformComponentsObject","transformSchemaObject","createRef","stringToAST","ts","tsModifiers","tsRecord","STRING","NEVER","performance","debug","makeApiPathsEnum"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/index.mjs.map b/dist/transform/index.mjs.map
index 221f577674a150cb869f157acbab360fce5017f9..843f629cd058df983b399a091662d29d2c463504 100644
--- a/dist/transform/index.mjs.map
+++ b/dist/transform/index.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.mjs","sources":["../../src/transform/index.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport ts, { type InterfaceDeclaration, type TypeLiteralNode } from \"typescript\";\nimport { NEVER, STRING, stringToAST, tsModifiers, tsRecord } from \"../lib/ts.js\";\nimport { createRef, debug } from \"../lib/utils.js\";\nimport type { GlobalContext, OpenAPI3 } from \"../types.js\";\nimport transformComponentsObject from \"./components-object.js\";\nimport makeApiPathsEnum from \"./paths-enum.js\";\nimport transformPathsObject from \"./paths-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\nimport transformWebhooksObject from \"./webhooks-object.js\";\n\ntype SchemaTransforms = keyof Pick<OpenAPI3, \"paths\" | \"webhooks\" | \"components\" | \"$defs\">;\n\nconst transformers: Record<SchemaTransforms, (node: any, options: GlobalContext) => ts.Node | ts.Node[]> = {\n  paths: transformPathsObject,\n  webhooks: transformWebhooksObject,\n  components: transformComponentsObject,\n  $defs: (node, options) => transformSchemaObject(node, { path: createRef([\"$defs\"]), ctx: options, schema: node }),\n};\n\nexport default function transformSchema(schema: OpenAPI3, ctx: GlobalContext) {\n  const type: ts.Node[] = [];\n\n  if (ctx.inject) {\n    const injectNodes = stringToAST(ctx.inject) as ts.Node[];\n    type.push(...injectNodes);\n  }\n\n  for (const root of Object.keys(transformers) as SchemaTransforms[]) {\n    const emptyObj = ts.factory.createTypeAliasDeclaration(\n      /* modifiers      */ tsModifiers({ export: true }),\n      /* name           */ root,\n      /* typeParameters */ undefined,\n      /* type           */ tsRecord(STRING, NEVER),\n    );\n\n    if (schema[root] && typeof schema[root] === \"object\") {\n      const rootT = performance.now();\n      const subTypes = ([] as ts.Node[]).concat(transformers[root](schema[root], ctx));\n      for (const subType of subTypes) {\n        if (ts.isTypeNode(subType)) {\n          if ((subType as ts.TypeLiteralNode).members?.length) {\n            type.push(\n              ctx.exportType\n                ? ts.factory.createTypeAliasDeclaration(\n                    /* modifiers      */ tsModifiers({ export: true }),\n                    /* name           */ root,\n                    /* typeParameters */ undefined,\n                    /* type           */ subType,\n                  )\n                : ts.factory.createInterfaceDeclaration(\n                    /* modifiers       */ tsModifiers({ export: true }),\n                    /* name            */ root,\n                    /* typeParameters  */ undefined,\n                    /* heritageClauses */ undefined,\n                    /* members         */ (subType as TypeLiteralNode).members,\n                  ),\n            );\n            debug(`${root} done`, \"ts\", performance.now() - rootT);\n          } else {\n            type.push(emptyObj);\n            debug(`${root} done (skipped)`, \"ts\", 0);\n          }\n        } else if (ts.isTypeAliasDeclaration(subType)) {\n          type.push(subType);\n        } else {\n          type.push(emptyObj);\n          debug(`${root} done (skipped)`, \"ts\", 0);\n        }\n      }\n    } else {\n      type.push(emptyObj);\n      debug(`${root} done (skipped)`, \"ts\", 0);\n    }\n  }\n\n  // inject\n  let hasOperations = false;\n  for (const injectedType of ctx.injectFooter) {\n    if (!hasOperations && (injectedType as InterfaceDeclaration)?.name?.escapedText === \"operations\") {\n      hasOperations = true;\n    }\n    type.push(injectedType);\n  }\n  if (!hasOperations) {\n    // if no operations created, inject empty operations type\n    type.push(\n      ts.factory.createTypeAliasDeclaration(\n        /* modifiers      */ tsModifiers({ export: true }),\n        /* name           */ \"operations\",\n        /* typeParameters */ undefined,\n        /* type           */ tsRecord(STRING, NEVER),\n      ),\n    );\n  }\n\n  if (ctx.makePathsEnum && schema.paths) {\n    type.push(makeApiPathsEnum(schema.paths));\n  }\n\n  return type;\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.mjs","sources":["../../src/transform/index.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport ts, { type InterfaceDeclaration, type TypeLiteralNode } from \"typescript\";\nimport { NEVER, STRING, stringToAST, tsModifiers, tsRecord } from \"../lib/ts.js\";\nimport { createRef, debug } from \"../lib/utils.js\";\nimport type { GlobalContext, OpenAPI3 } from \"../types.js\";\nimport transformComponentsObject from \"./components-object.js\";\nimport makeApiPathsEnum from \"./paths-enum.js\";\nimport transformPathsObject from \"./paths-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\nimport transformWebhooksObject from \"./webhooks-object.js\";\n\ntype SchemaTransforms = keyof Pick<OpenAPI3, \"paths\" | \"webhooks\" | \"components\" | \"$defs\">;\n\nconst transformers: Record<SchemaTransforms, (node: any, options: GlobalContext) => ts.Node | ts.Node[]> = {\n  paths: transformPathsObject,\n  webhooks: transformWebhooksObject,\n  components: transformComponentsObject,\n  $defs: (node, options) => transformSchemaObject(node, { path: createRef([\"$defs\"]), ctx: options, schema: node }),\n};\n\nexport default function transformSchema(schema: OpenAPI3, ctx: GlobalContext) {\n  const type: ts.Node[] = [];\n\n  if (ctx.inject) {\n    const injectNodes = stringToAST(ctx.inject) as ts.Node[];\n    type.push(...injectNodes);\n  }\n\n  for (const root of Object.keys(transformers) as SchemaTransforms[]) {\n    const emptyObj = ts.factory.createTypeAliasDeclaration(\n      /* modifiers      */ tsModifiers({ export: true }),\n      /* name           */ root,\n      /* typeParameters */ undefined,\n      /* type           */ tsRecord(STRING, NEVER),\n    );\n\n    if (schema[root] && typeof schema[root] === \"object\") {\n      const rootT = performance.now();\n      const subTypes = ([] as ts.Node[]).concat(transformers[root](schema[root], ctx));\n      for (const subType of subTypes) {\n        if (ts.isTypeNode(subType)) {\n          if ((subType as ts.TypeLiteralNode).members?.length) {\n            type.push(\n              ctx.exportType\n                ? ts.factory.createTypeAliasDeclaration(\n                    /* modifiers      */ tsModifiers({ export: true }),\n                    /* name           */ root,\n                    /* typeParameters */ undefined,\n                    /* type           */ subType,\n                  )\n                : ts.factory.createInterfaceDeclaration(\n                    /* modifiers       */ tsModifiers({ export: true }),\n                    /* name            */ root,\n                    /* typeParameters  */ undefined,\n                    /* heritageClauses */ undefined,\n                    /* members         */ (subType as TypeLiteralNode).members,\n                  ),\n            );\n            debug(`${root} done`, \"ts\", performance.now() - rootT);\n          } else {\n            type.push(emptyObj);\n            debug(`${root} done (skipped)`, \"ts\", 0);\n          }\n        } else if (ts.isTypeAliasDeclaration(subType)) {\n          type.push(subType);\n        } else {\n          type.push(emptyObj);\n          debug(`${root} done (skipped)`, \"ts\", 0);\n        }\n      }\n    } else {\n      type.push(emptyObj);\n      debug(`${root} done (skipped)`, \"ts\", 0);\n    }\n  }\n\n  // inject\n  let hasOperations = false;\n  for (const injectedType of ctx.injectFooter) {\n    if (!hasOperations && (injectedType as InterfaceDeclaration)?.name?.escapedText === \"operations\") {\n      hasOperations = true;\n    }\n    type.push(injectedType);\n  }\n  if (!hasOperations) {\n    // if no operations created, inject empty operations type\n    type.push(\n      ts.factory.createTypeAliasDeclaration(\n        /* modifiers      */ tsModifiers({ export: true }),\n        /* name           */ \"operations\",\n        /* typeParameters */ undefined,\n        /* type           */ tsRecord(STRING, NEVER),\n      ),\n    );\n  }\n\n  if (ctx.makePathsEnum && schema.paths) {\n    type.push(makeApiPathsEnum(schema.paths));\n  }\n\n  return type;\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/media-type-object.cjs.map b/dist/transform/media-type-object.cjs.map
index f80f7960ee367ba487f90c4d6fb8f47f9ac25730..748ef28ced072742caafa256c61d082ba86f5f29 100644
--- a/dist/transform/media-type-object.cjs.map
+++ b/dist/transform/media-type-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"media-type-object.cjs","sources":["../../src/transform/media-type-object.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { UNKNOWN } from \"../lib/ts.js\";\nimport type { MediaTypeObject, TransformNodeOptions } from \"../types.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform MediaTypeObject nodes (4.8.14)\n * @see https://spec.openapis.org/oas/v3.1.0#media-type-object\n */\nexport default function transformMediaTypeObject(\n  mediaTypeObject: MediaTypeObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  if (!mediaTypeObject.schema) {\n    return UNKNOWN;\n  }\n  return transformSchemaObject(mediaTypeObject.schema, options);\n}\n"],"names":["UNKNOWN","transformSchemaObject"],"mappings":";;;;;AASA,SAAwB,wBAAA,CACtB,iBACA,OAAA,EACa;AACb,EAAA,IAAI,CAAC,gBAAgB,MAAA,EAAQ;AAC3B,IAAA,OAAOA,UAAA;AAAA,EACT;AACA,EAAA,OAAOC,oBAAA,CAAsB,eAAA,CAAgB,MAAA,EAAQ,OAAO,CAAA;AAC9D;;;;"}
\ No newline at end of file
+{"version":3,"file":"media-type-object.cjs","sources":["../../src/transform/media-type-object.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { UNKNOWN } from \"../lib/ts.js\";\nimport type { MediaTypeObject, TransformNodeOptions } from \"../types.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform MediaTypeObject nodes (4.8.14)\n * @see https://spec.openapis.org/oas/v3.1.0#media-type-object\n */\nexport default function transformMediaTypeObject(\n  mediaTypeObject: MediaTypeObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  if (!mediaTypeObject.schema) {\n    return UNKNOWN;\n  }\n  return transformSchemaObject(mediaTypeObject.schema, options);\n}\n"],"names":["UNKNOWN","transformSchemaObject"],"mappings":";;;;;AASwB,SAAA,wBAAA,CACtB,iBACA,OACa,EAAA;AACb,EAAI,IAAA,CAAC,gBAAgB,MAAQ,EAAA;AAC3B,IAAO,OAAAA,UAAA;AAAA;AAET,EAAO,OAAAC,oBAAA,CAAsB,eAAgB,CAAA,MAAA,EAAQ,OAAO,CAAA;AAC9D;;;;"}
\ No newline at end of file
diff --git a/dist/transform/media-type-object.mjs.map b/dist/transform/media-type-object.mjs.map
index 1255251347102226877ccd3685924e8c20e5a571..38bcad94a57486191d6c5464d30161eafb385d0c 100644
--- a/dist/transform/media-type-object.mjs.map
+++ b/dist/transform/media-type-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"media-type-object.mjs","sources":["../../src/transform/media-type-object.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { UNKNOWN } from \"../lib/ts.js\";\nimport type { MediaTypeObject, TransformNodeOptions } from \"../types.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform MediaTypeObject nodes (4.8.14)\n * @see https://spec.openapis.org/oas/v3.1.0#media-type-object\n */\nexport default function transformMediaTypeObject(\n  mediaTypeObject: MediaTypeObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  if (!mediaTypeObject.schema) {\n    return UNKNOWN;\n  }\n  return transformSchemaObject(mediaTypeObject.schema, options);\n}\n"],"names":[],"mappings":";;;AASA,SAAwB,wBAAA,CACtB,iBACA,OAAA,EACa;AACb,EAAA,IAAI,CAAC,gBAAgB,MAAA,EAAQ;AAC3B,IAAA,OAAO,OAAA;AAAA,EACT;AACA,EAAA,OAAO,qBAAA,CAAsB,eAAA,CAAgB,MAAA,EAAQ,OAAO,CAAA;AAC9D;;;;"}
\ No newline at end of file
+{"version":3,"file":"media-type-object.mjs","sources":["../../src/transform/media-type-object.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { UNKNOWN } from \"../lib/ts.js\";\nimport type { MediaTypeObject, TransformNodeOptions } from \"../types.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform MediaTypeObject nodes (4.8.14)\n * @see https://spec.openapis.org/oas/v3.1.0#media-type-object\n */\nexport default function transformMediaTypeObject(\n  mediaTypeObject: MediaTypeObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  if (!mediaTypeObject.schema) {\n    return UNKNOWN;\n  }\n  return transformSchemaObject(mediaTypeObject.schema, options);\n}\n"],"names":[],"mappings":";;;AASwB,SAAA,wBAAA,CACtB,iBACA,OACa,EAAA;AACb,EAAI,IAAA,CAAC,gBAAgB,MAAQ,EAAA;AAC3B,IAAO,OAAA,OAAA;AAAA;AAET,EAAO,OAAA,qBAAA,CAAsB,eAAgB,CAAA,MAAA,EAAQ,OAAO,CAAA;AAC9D;;;;"}
\ No newline at end of file
diff --git a/dist/transform/operation-object.cjs.map b/dist/transform/operation-object.cjs.map
index cae22ad7edf2dd6028c92ba1662c1c4bd48eb3a6..9336e02c9ec6a590d33ab00cbefe6ece55c3ce5b 100644
--- a/dist/transform/operation-object.cjs.map
+++ b/dist/transform/operation-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"operation-object.cjs","sources":["../../src/transform/operation-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type { OperationObject, RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport { transformParametersArray } from \"./parameters-array.js\";\nimport transformRequestBodyObject from \"./request-body-object.js\";\nimport transformResponsesObject from \"./responses-object.js\";\n\n/**\n * Transform OperationObject nodes (4.8.10)\n * @see https://spec.openapis.org/oas/v3.1.0#operation-object\n */\nexport default function transformOperationObject(\n  operationObject: OperationObject,\n  options: TransformNodeOptions,\n): ts.TypeElement[] {\n  const type: ts.TypeElement[] = [];\n\n  // parameters\n  type.push(...transformParametersArray(operationObject.parameters ?? [], options));\n\n  // requestBody\n  if (operationObject.requestBody) {\n    const requestBodyType =\n      \"$ref\" in operationObject.requestBody\n        ? oapiRef(operationObject.requestBody.$ref)\n        : transformRequestBodyObject(operationObject.requestBody, {\n            ...options,\n            path: createRef([options.path, \"requestBody\"]),\n          });\n    const required = !!(\n      \"$ref\" in operationObject.requestBody\n        ? options.ctx.resolve<RequestBodyObject>(operationObject.requestBody.$ref)\n        : operationObject.requestBody\n    )?.required;\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"requestBody\"),\n      /* questionToken */ required ? undefined : QUESTION_TOKEN,\n      /* type          */ requestBodyType,\n    );\n    addJSDocComment(operationObject.requestBody, property);\n    type.push(property);\n  } else {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(\"requestBody\"),\n        /* questionToken */ QUESTION_TOKEN,\n        /* type          */ NEVER,\n      ),\n    );\n  }\n\n  // responses\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"responses\"),\n      /* questionToken */ undefined,\n      /* type          */ transformResponsesObject(operationObject.responses ?? {}, options),\n    ),\n  );\n\n  return type;\n}\n\n/** inject an operation at the top level */\nexport function injectOperationObject(\n  operationId: string,\n  operationObject: OperationObject,\n  options: TransformNodeOptions,\n): void {\n  // find or create top-level operations interface\n  let operations = options.ctx.injectFooter.find(\n    (node) => ts.isInterfaceDeclaration(node) && (node as ts.InterfaceDeclaration).name.text === \"operations\",\n  ) as unknown as ts.InterfaceDeclaration;\n  if (!operations) {\n    operations = ts.factory.createInterfaceDeclaration(\n      /* modifiers       */ tsModifiers({\n        export: true,\n        // important: do NOT make this immutable\n      }),\n      /* name            */ ts.factory.createIdentifier(\"operations\"),\n      /* typeParameters  */ undefined,\n      /* heritageClauses */ undefined,\n      /* members         */ [],\n    );\n    options.ctx.injectFooter.push(operations);\n  }\n\n  // inject operation object\n  const type = transformOperationObject(operationObject, options);\n  // @ts-expect-error this is OK to mutate\n  operations.members = ts.factory.createNodeArray([\n    ...operations.members,\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(operationId),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(type),\n    ),\n  ]);\n}\n"],"names":["transformParametersArray","oapiRef","transformRequestBodyObject","createRef","ts","tsModifiers","tsPropertyIndex","QUESTION_TOKEN","addJSDocComment","NEVER","transformResponsesObject"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"operation-object.cjs","sources":["../../src/transform/operation-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type { OperationObject, RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport { transformParametersArray } from \"./parameters-array.js\";\nimport transformRequestBodyObject from \"./request-body-object.js\";\nimport transformResponsesObject from \"./responses-object.js\";\n\n/**\n * Transform OperationObject nodes (4.8.10)\n * @see https://spec.openapis.org/oas/v3.1.0#operation-object\n */\nexport default function transformOperationObject(\n  operationObject: OperationObject,\n  options: TransformNodeOptions,\n): ts.TypeElement[] {\n  const type: ts.TypeElement[] = [];\n\n  // parameters\n  type.push(...transformParametersArray(operationObject.parameters ?? [], options));\n\n  // requestBody\n  if (operationObject.requestBody) {\n    const requestBodyType =\n      \"$ref\" in operationObject.requestBody\n        ? oapiRef(operationObject.requestBody.$ref)\n        : transformRequestBodyObject(operationObject.requestBody, {\n            ...options,\n            path: createRef([options.path, \"requestBody\"]),\n          });\n    const required = !!(\n      \"$ref\" in operationObject.requestBody\n        ? options.ctx.resolve<RequestBodyObject>(operationObject.requestBody.$ref)\n        : operationObject.requestBody\n    )?.required;\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"requestBody\"),\n      /* questionToken */ required ? undefined : QUESTION_TOKEN,\n      /* type          */ requestBodyType,\n    );\n    addJSDocComment(operationObject.requestBody, property);\n    type.push(property);\n  } else {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(\"requestBody\"),\n        /* questionToken */ QUESTION_TOKEN,\n        /* type          */ NEVER,\n      ),\n    );\n  }\n\n  // responses\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"responses\"),\n      /* questionToken */ undefined,\n      /* type          */ transformResponsesObject(operationObject.responses ?? {}, options),\n    ),\n  );\n\n  return type;\n}\n\n/** inject an operation at the top level */\nexport function injectOperationObject(\n  operationId: string,\n  operationObject: OperationObject,\n  options: TransformNodeOptions,\n): void {\n  // find or create top-level operations interface\n  let operations = options.ctx.injectFooter.find(\n    (node) => ts.isInterfaceDeclaration(node) && (node as ts.InterfaceDeclaration).name.text === \"operations\",\n  ) as unknown as ts.InterfaceDeclaration;\n  if (!operations) {\n    operations = ts.factory.createInterfaceDeclaration(\n      /* modifiers       */ tsModifiers({\n        export: true,\n        // important: do NOT make this immutable\n      }),\n      /* name            */ ts.factory.createIdentifier(\"operations\"),\n      /* typeParameters  */ undefined,\n      /* heritageClauses */ undefined,\n      /* members         */ [],\n    );\n    options.ctx.injectFooter.push(operations);\n  }\n\n  // inject operation object\n  const type = transformOperationObject(operationObject, options);\n  // @ts-expect-error this is OK to mutate\n  operations.members = ts.factory.createNodeArray([\n    ...operations.members,\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(operationId),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(type),\n    ),\n  ]);\n}\n"],"names":["transformParametersArray","oapiRef","transformRequestBodyObject","createRef","ts","tsModifiers","tsPropertyIndex","QUESTION_TOKEN","addJSDocComment","NEVER","transformResponsesObject"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/operation-object.mjs.map b/dist/transform/operation-object.mjs.map
index d38b845fc2b354bc7eb91b82d0fe08c1d931db34..0e0581241d22a90c1b7a4a46da419293bdda8567 100644
--- a/dist/transform/operation-object.mjs.map
+++ b/dist/transform/operation-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"operation-object.mjs","sources":["../../src/transform/operation-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type { OperationObject, RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport { transformParametersArray } from \"./parameters-array.js\";\nimport transformRequestBodyObject from \"./request-body-object.js\";\nimport transformResponsesObject from \"./responses-object.js\";\n\n/**\n * Transform OperationObject nodes (4.8.10)\n * @see https://spec.openapis.org/oas/v3.1.0#operation-object\n */\nexport default function transformOperationObject(\n  operationObject: OperationObject,\n  options: TransformNodeOptions,\n): ts.TypeElement[] {\n  const type: ts.TypeElement[] = [];\n\n  // parameters\n  type.push(...transformParametersArray(operationObject.parameters ?? [], options));\n\n  // requestBody\n  if (operationObject.requestBody) {\n    const requestBodyType =\n      \"$ref\" in operationObject.requestBody\n        ? oapiRef(operationObject.requestBody.$ref)\n        : transformRequestBodyObject(operationObject.requestBody, {\n            ...options,\n            path: createRef([options.path, \"requestBody\"]),\n          });\n    const required = !!(\n      \"$ref\" in operationObject.requestBody\n        ? options.ctx.resolve<RequestBodyObject>(operationObject.requestBody.$ref)\n        : operationObject.requestBody\n    )?.required;\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"requestBody\"),\n      /* questionToken */ required ? undefined : QUESTION_TOKEN,\n      /* type          */ requestBodyType,\n    );\n    addJSDocComment(operationObject.requestBody, property);\n    type.push(property);\n  } else {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(\"requestBody\"),\n        /* questionToken */ QUESTION_TOKEN,\n        /* type          */ NEVER,\n      ),\n    );\n  }\n\n  // responses\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"responses\"),\n      /* questionToken */ undefined,\n      /* type          */ transformResponsesObject(operationObject.responses ?? {}, options),\n    ),\n  );\n\n  return type;\n}\n\n/** inject an operation at the top level */\nexport function injectOperationObject(\n  operationId: string,\n  operationObject: OperationObject,\n  options: TransformNodeOptions,\n): void {\n  // find or create top-level operations interface\n  let operations = options.ctx.injectFooter.find(\n    (node) => ts.isInterfaceDeclaration(node) && (node as ts.InterfaceDeclaration).name.text === \"operations\",\n  ) as unknown as ts.InterfaceDeclaration;\n  if (!operations) {\n    operations = ts.factory.createInterfaceDeclaration(\n      /* modifiers       */ tsModifiers({\n        export: true,\n        // important: do NOT make this immutable\n      }),\n      /* name            */ ts.factory.createIdentifier(\"operations\"),\n      /* typeParameters  */ undefined,\n      /* heritageClauses */ undefined,\n      /* members         */ [],\n    );\n    options.ctx.injectFooter.push(operations);\n  }\n\n  // inject operation object\n  const type = transformOperationObject(operationObject, options);\n  // @ts-expect-error this is OK to mutate\n  operations.members = ts.factory.createNodeArray([\n    ...operations.members,\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(operationId),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(type),\n    ),\n  ]);\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"operation-object.mjs","sources":["../../src/transform/operation-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type { OperationObject, RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport { transformParametersArray } from \"./parameters-array.js\";\nimport transformRequestBodyObject from \"./request-body-object.js\";\nimport transformResponsesObject from \"./responses-object.js\";\n\n/**\n * Transform OperationObject nodes (4.8.10)\n * @see https://spec.openapis.org/oas/v3.1.0#operation-object\n */\nexport default function transformOperationObject(\n  operationObject: OperationObject,\n  options: TransformNodeOptions,\n): ts.TypeElement[] {\n  const type: ts.TypeElement[] = [];\n\n  // parameters\n  type.push(...transformParametersArray(operationObject.parameters ?? [], options));\n\n  // requestBody\n  if (operationObject.requestBody) {\n    const requestBodyType =\n      \"$ref\" in operationObject.requestBody\n        ? oapiRef(operationObject.requestBody.$ref)\n        : transformRequestBodyObject(operationObject.requestBody, {\n            ...options,\n            path: createRef([options.path, \"requestBody\"]),\n          });\n    const required = !!(\n      \"$ref\" in operationObject.requestBody\n        ? options.ctx.resolve<RequestBodyObject>(operationObject.requestBody.$ref)\n        : operationObject.requestBody\n    )?.required;\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"requestBody\"),\n      /* questionToken */ required ? undefined : QUESTION_TOKEN,\n      /* type          */ requestBodyType,\n    );\n    addJSDocComment(operationObject.requestBody, property);\n    type.push(property);\n  } else {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(\"requestBody\"),\n        /* questionToken */ QUESTION_TOKEN,\n        /* type          */ NEVER,\n      ),\n    );\n  }\n\n  // responses\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"responses\"),\n      /* questionToken */ undefined,\n      /* type          */ transformResponsesObject(operationObject.responses ?? {}, options),\n    ),\n  );\n\n  return type;\n}\n\n/** inject an operation at the top level */\nexport function injectOperationObject(\n  operationId: string,\n  operationObject: OperationObject,\n  options: TransformNodeOptions,\n): void {\n  // find or create top-level operations interface\n  let operations = options.ctx.injectFooter.find(\n    (node) => ts.isInterfaceDeclaration(node) && (node as ts.InterfaceDeclaration).name.text === \"operations\",\n  ) as unknown as ts.InterfaceDeclaration;\n  if (!operations) {\n    operations = ts.factory.createInterfaceDeclaration(\n      /* modifiers       */ tsModifiers({\n        export: true,\n        // important: do NOT make this immutable\n      }),\n      /* name            */ ts.factory.createIdentifier(\"operations\"),\n      /* typeParameters  */ undefined,\n      /* heritageClauses */ undefined,\n      /* members         */ [],\n    );\n    options.ctx.injectFooter.push(operations);\n  }\n\n  // inject operation object\n  const type = transformOperationObject(operationObject, options);\n  // @ts-expect-error this is OK to mutate\n  operations.members = ts.factory.createNodeArray([\n    ...operations.members,\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(operationId),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(type),\n    ),\n  ]);\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/parameter-object.cjs.map b/dist/transform/parameter-object.cjs.map
index 584244160b74a62e382461c2720661205c3aab53..786d6c7570ce77fbd74debba2fbef165235f1390 100644
--- a/dist/transform/parameter-object.cjs.map
+++ b/dist/transform/parameter-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"parameter-object.cjs","sources":["../../src/transform/parameter-object.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { STRING } from \"../lib/ts.js\";\nimport type { ParameterObject, TransformNodeOptions } from \"../types.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform ParameterObject nodes (4.8.12)\n * @see https://spec.openapis.org/oas/v3.1.0#parameter-object\n */\nexport default function transformParameterObject(\n  parameterObject: ParameterObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  return parameterObject.schema ? transformSchemaObject(parameterObject.schema, options) : STRING; // assume a parameter is a string by default rather than \"unknown\"\n}\n"],"names":["transformSchemaObject","STRING"],"mappings":";;;;;AASA,SAAwB,wBAAA,CACtB,iBACA,OAAA,EACa;AACb,EAAA,OAAO,gBAAgB,MAAA,GAASA,oBAAA,CAAsB,eAAA,CAAgB,MAAA,EAAQ,OAAO,CAAA,GAAIC,SAAA;AAC3F;;;;"}
\ No newline at end of file
+{"version":3,"file":"parameter-object.cjs","sources":["../../src/transform/parameter-object.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { STRING } from \"../lib/ts.js\";\nimport type { ParameterObject, TransformNodeOptions } from \"../types.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform ParameterObject nodes (4.8.12)\n * @see https://spec.openapis.org/oas/v3.1.0#parameter-object\n */\nexport default function transformParameterObject(\n  parameterObject: ParameterObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  return parameterObject.schema ? transformSchemaObject(parameterObject.schema, options) : STRING; // assume a parameter is a string by default rather than \"unknown\"\n}\n"],"names":["transformSchemaObject","STRING"],"mappings":";;;;;AASwB,SAAA,wBAAA,CACtB,iBACA,OACa,EAAA;AACb,EAAA,OAAO,gBAAgB,MAAS,GAAAA,oBAAA,CAAsB,eAAgB,CAAA,MAAA,EAAQ,OAAO,CAAI,GAAAC,SAAA;AAC3F;;;;"}
\ No newline at end of file
diff --git a/dist/transform/parameter-object.mjs.map b/dist/transform/parameter-object.mjs.map
index 6b0dab02573e300ad39762f8333ac7c3a7e66e2b..1f329f47f7d8d738343d7d44011cde1f886db494 100644
--- a/dist/transform/parameter-object.mjs.map
+++ b/dist/transform/parameter-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"parameter-object.mjs","sources":["../../src/transform/parameter-object.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { STRING } from \"../lib/ts.js\";\nimport type { ParameterObject, TransformNodeOptions } from \"../types.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform ParameterObject nodes (4.8.12)\n * @see https://spec.openapis.org/oas/v3.1.0#parameter-object\n */\nexport default function transformParameterObject(\n  parameterObject: ParameterObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  return parameterObject.schema ? transformSchemaObject(parameterObject.schema, options) : STRING; // assume a parameter is a string by default rather than \"unknown\"\n}\n"],"names":[],"mappings":";;;AASA,SAAwB,wBAAA,CACtB,iBACA,OAAA,EACa;AACb,EAAA,OAAO,gBAAgB,MAAA,GAAS,qBAAA,CAAsB,eAAA,CAAgB,MAAA,EAAQ,OAAO,CAAA,GAAI,MAAA;AAC3F;;;;"}
\ No newline at end of file
+{"version":3,"file":"parameter-object.mjs","sources":["../../src/transform/parameter-object.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { STRING } from \"../lib/ts.js\";\nimport type { ParameterObject, TransformNodeOptions } from \"../types.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform ParameterObject nodes (4.8.12)\n * @see https://spec.openapis.org/oas/v3.1.0#parameter-object\n */\nexport default function transformParameterObject(\n  parameterObject: ParameterObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  return parameterObject.schema ? transformSchemaObject(parameterObject.schema, options) : STRING; // assume a parameter is a string by default rather than \"unknown\"\n}\n"],"names":[],"mappings":";;;AASwB,SAAA,wBAAA,CACtB,iBACA,OACa,EAAA;AACb,EAAA,OAAO,gBAAgB,MAAS,GAAA,qBAAA,CAAsB,eAAgB,CAAA,MAAA,EAAQ,OAAO,CAAI,GAAA,MAAA;AAC3F;;;;"}
\ No newline at end of file
diff --git a/dist/transform/parameters-array.cjs.map b/dist/transform/parameters-array.cjs.map
index c0a679049efc767bd1f0444f1924151d053d47d3..2fbd9dbc678334dc7026452cf8ea783339fe8fb2 100644
--- a/dist/transform/parameters-array.cjs.map
+++ b/dist/transform/parameters-array.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"parameters-array.cjs","sources":["../../src/transform/parameters-array.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type { ParameterObject, ReferenceObject, TransformNodeOptions } from \"../types.js\";\nimport transformParameterObject from \"./parameter-object.js\";\n\n// Regex to match path parameters in URL\nconst PATH_PARAM_RE = /\\{([^}]+)\\}/g;\n\n/**\n * Create a synthetic path parameter object from a parameter name\n */\nfunction createPathParameter(paramName: string): ParameterObject {\n  return {\n    name: paramName,\n    in: \"path\",\n    required: true,\n    schema: { type: \"string\" },\n  };\n}\n\n/**\n * Extract path parameters from a URL\n */\nfunction extractPathParamsFromUrl(path: string): ParameterObject[] {\n  const params: ParameterObject[] = [];\n  const matches = path.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      const paramName = match.slice(1, -1);\n      params.push(createPathParameter(paramName));\n    }\n  }\n  return params;\n}\n\n/**\n * Synthetic type. Array of (ParameterObject | ReferenceObject)s found in OperationObject and PathItemObject.\n */\nexport function transformParametersArray(\n  parametersArray: (ParameterObject | ReferenceObject)[],\n  options: TransformNodeOptions,\n): ts.TypeElement[] {\n  const type: ts.TypeElement[] = [];\n\n  // Create a working copy of parameters array\n  const workingParameters = [...parametersArray];\n\n  // Generate path parameters if enabled\n  if (options.ctx.generatePathParams && options.path) {\n    const pathString = Array.isArray(options.path) ? options.path[0] : options.path;\n    if (typeof pathString === \"string\") {\n      const pathParams = extractPathParamsFromUrl(pathString);\n      // Only add path parameters that aren't already defined\n      for (const param of pathParams) {\n        const exists = workingParameters.some((p) => {\n          const resolved = \"$ref\" in p ? options.ctx.resolve<ParameterObject>(p.$ref) : p;\n          return resolved?.in === \"path\" && resolved?.name === param.name;\n        });\n        if (!exists) {\n          workingParameters.push(param);\n        }\n      }\n    }\n  }\n\n  // parameters\n  const paramType: ts.TypeElement[] = [];\n  for (const paramIn of [\"query\", \"header\", \"path\", \"cookie\"] as ParameterObject[\"in\"][]) {\n    const paramLocType: ts.TypeElement[] = [];\n    let operationParameters = workingParameters.map((param) => ({\n      original: param,\n      resolved: \"$ref\" in param ? options.ctx.resolve<ParameterObject>(param.$ref) : param,\n    }));\n\n    // this is the only array type in the spec, so we have to one-off sort here\n    if (options.ctx.alphabetize) {\n      operationParameters.sort((a, b) => (a.resolved?.name ?? \"\").localeCompare(b.resolved?.name ?? \"\"));\n    }\n    if (options.ctx.excludeDeprecated) {\n      operationParameters = operationParameters.filter(\n        ({ resolved }) => !resolved?.deprecated && !resolved?.schema?.deprecated,\n      );\n    }\n    for (const { original, resolved } of operationParameters) {\n      if (resolved?.in !== paramIn) {\n        continue;\n      }\n      let optional: ts.QuestionToken | undefined = undefined;\n      if (paramIn !== \"path\" && !(resolved as ParameterObject).required) {\n        optional = QUESTION_TOKEN;\n      }\n      const subType =\n        \"$ref\" in original\n          ? oapiRef(original.$ref, resolved)\n          : transformParameterObject(resolved as ParameterObject, {\n              ...options,\n              path: createRef([options.path, \"parameters\", resolved.in, resolved.name]),\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(resolved?.name),\n        /* questionToken */ optional,\n        /* type          */ subType,\n      );\n      addJSDocComment(resolved, property);\n      paramLocType.push(property);\n    }\n    const allOptional = paramLocType.every((node) => !!node.questionToken);\n    paramType.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(paramIn),\n        /* questionToken */ allOptional || !paramLocType.length ? QUESTION_TOKEN : undefined,\n        /* type          */ paramLocType.length ? ts.factory.createTypeLiteralNode(paramLocType) : NEVER,\n      ),\n    );\n  }\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"parameters\"),\n      /* questionToken */ !paramType.length ? QUESTION_TOKEN : undefined,\n      /* type          */ paramType.length ? ts.factory.createTypeLiteralNode(paramType) : NEVER,\n    ),\n  );\n\n  return type;\n}\n"],"names":["QUESTION_TOKEN","oapiRef","transformParameterObject","createRef","ts","tsModifiers","tsPropertyIndex","addJSDocComment","NEVER"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"parameters-array.cjs","sources":["../../src/transform/parameters-array.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type { ParameterObject, ReferenceObject, TransformNodeOptions } from \"../types.js\";\nimport transformParameterObject from \"./parameter-object.js\";\n\n// Regex to match path parameters in URL\nconst PATH_PARAM_RE = /\\{([^}]+)\\}/g;\n\n/**\n * Create a synthetic path parameter object from a parameter name\n */\nfunction createPathParameter(paramName: string): ParameterObject {\n  return {\n    name: paramName,\n    in: \"path\",\n    required: true,\n    schema: { type: \"string\" },\n  };\n}\n\n/**\n * Extract path parameters from a URL\n */\nfunction extractPathParamsFromUrl(path: string): ParameterObject[] {\n  const params: ParameterObject[] = [];\n  const matches = path.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      const paramName = match.slice(1, -1);\n      params.push(createPathParameter(paramName));\n    }\n  }\n  return params;\n}\n\n/**\n * Synthetic type. Array of (ParameterObject | ReferenceObject)s found in OperationObject and PathItemObject.\n */\nexport function transformParametersArray(\n  parametersArray: (ParameterObject | ReferenceObject)[],\n  options: TransformNodeOptions,\n): ts.TypeElement[] {\n  const type: ts.TypeElement[] = [];\n\n  // Create a working copy of parameters array\n  const workingParameters = [...parametersArray];\n\n  // Generate path parameters if enabled\n  if (options.ctx.generatePathParams && options.path) {\n    const pathString = Array.isArray(options.path) ? options.path[0] : options.path;\n    if (typeof pathString === \"string\") {\n      const pathParams = extractPathParamsFromUrl(pathString);\n      // Only add path parameters that aren't already defined\n      for (const param of pathParams) {\n        const exists = workingParameters.some((p) => {\n          const resolved = \"$ref\" in p ? options.ctx.resolve<ParameterObject>(p.$ref) : p;\n          return resolved?.in === \"path\" && resolved?.name === param.name;\n        });\n        if (!exists) {\n          workingParameters.push(param);\n        }\n      }\n    }\n  }\n\n  // parameters\n  const paramType: ts.TypeElement[] = [];\n  for (const paramIn of [\"query\", \"header\", \"path\", \"cookie\"] as ParameterObject[\"in\"][]) {\n    const paramLocType: ts.TypeElement[] = [];\n    let operationParameters = workingParameters.map((param) => ({\n      original: param,\n      resolved: \"$ref\" in param ? options.ctx.resolve<ParameterObject>(param.$ref) : param,\n    }));\n\n    // this is the only array type in the spec, so we have to one-off sort here\n    if (options.ctx.alphabetize) {\n      operationParameters.sort((a, b) => (a.resolved?.name ?? \"\").localeCompare(b.resolved?.name ?? \"\"));\n    }\n    if (options.ctx.excludeDeprecated) {\n      operationParameters = operationParameters.filter(\n        ({ resolved }) => !resolved?.deprecated && !resolved?.schema?.deprecated,\n      );\n    }\n    for (const { original, resolved } of operationParameters) {\n      if (resolved?.in !== paramIn) {\n        continue;\n      }\n      let optional: ts.QuestionToken | undefined = undefined;\n      if (paramIn !== \"path\" && !(resolved as ParameterObject).required) {\n        optional = QUESTION_TOKEN;\n      }\n      const subType =\n        \"$ref\" in original\n          ? oapiRef(original.$ref, resolved)\n          : transformParameterObject(resolved as ParameterObject, {\n              ...options,\n              path: createRef([options.path, \"parameters\", resolved.in, resolved.name]),\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(resolved?.name),\n        /* questionToken */ optional,\n        /* type          */ subType,\n      );\n      addJSDocComment(resolved, property);\n      paramLocType.push(property);\n    }\n    const allOptional = paramLocType.every((node) => !!node.questionToken);\n    paramType.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(paramIn),\n        /* questionToken */ allOptional || !paramLocType.length ? QUESTION_TOKEN : undefined,\n        /* type          */ paramLocType.length ? ts.factory.createTypeLiteralNode(paramLocType) : NEVER,\n      ),\n    );\n  }\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"parameters\"),\n      /* questionToken */ !paramType.length ? QUESTION_TOKEN : undefined,\n      /* type          */ paramType.length ? ts.factory.createTypeLiteralNode(paramType) : NEVER,\n    ),\n  );\n\n  return type;\n}\n"],"names":["QUESTION_TOKEN","oapiRef","transformParameterObject","createRef","ts","tsModifiers","tsPropertyIndex","addJSDocComment","NEVER"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/parameters-array.mjs.map b/dist/transform/parameters-array.mjs.map
index b02c098d94f6fa61c742d0f92906fc78f256a46b..ca718ddc2aec7cb197931817acf67e4186c7154f 100644
--- a/dist/transform/parameters-array.mjs.map
+++ b/dist/transform/parameters-array.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"parameters-array.mjs","sources":["../../src/transform/parameters-array.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type { ParameterObject, ReferenceObject, TransformNodeOptions } from \"../types.js\";\nimport transformParameterObject from \"./parameter-object.js\";\n\n// Regex to match path parameters in URL\nconst PATH_PARAM_RE = /\\{([^}]+)\\}/g;\n\n/**\n * Create a synthetic path parameter object from a parameter name\n */\nfunction createPathParameter(paramName: string): ParameterObject {\n  return {\n    name: paramName,\n    in: \"path\",\n    required: true,\n    schema: { type: \"string\" },\n  };\n}\n\n/**\n * Extract path parameters from a URL\n */\nfunction extractPathParamsFromUrl(path: string): ParameterObject[] {\n  const params: ParameterObject[] = [];\n  const matches = path.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      const paramName = match.slice(1, -1);\n      params.push(createPathParameter(paramName));\n    }\n  }\n  return params;\n}\n\n/**\n * Synthetic type. Array of (ParameterObject | ReferenceObject)s found in OperationObject and PathItemObject.\n */\nexport function transformParametersArray(\n  parametersArray: (ParameterObject | ReferenceObject)[],\n  options: TransformNodeOptions,\n): ts.TypeElement[] {\n  const type: ts.TypeElement[] = [];\n\n  // Create a working copy of parameters array\n  const workingParameters = [...parametersArray];\n\n  // Generate path parameters if enabled\n  if (options.ctx.generatePathParams && options.path) {\n    const pathString = Array.isArray(options.path) ? options.path[0] : options.path;\n    if (typeof pathString === \"string\") {\n      const pathParams = extractPathParamsFromUrl(pathString);\n      // Only add path parameters that aren't already defined\n      for (const param of pathParams) {\n        const exists = workingParameters.some((p) => {\n          const resolved = \"$ref\" in p ? options.ctx.resolve<ParameterObject>(p.$ref) : p;\n          return resolved?.in === \"path\" && resolved?.name === param.name;\n        });\n        if (!exists) {\n          workingParameters.push(param);\n        }\n      }\n    }\n  }\n\n  // parameters\n  const paramType: ts.TypeElement[] = [];\n  for (const paramIn of [\"query\", \"header\", \"path\", \"cookie\"] as ParameterObject[\"in\"][]) {\n    const paramLocType: ts.TypeElement[] = [];\n    let operationParameters = workingParameters.map((param) => ({\n      original: param,\n      resolved: \"$ref\" in param ? options.ctx.resolve<ParameterObject>(param.$ref) : param,\n    }));\n\n    // this is the only array type in the spec, so we have to one-off sort here\n    if (options.ctx.alphabetize) {\n      operationParameters.sort((a, b) => (a.resolved?.name ?? \"\").localeCompare(b.resolved?.name ?? \"\"));\n    }\n    if (options.ctx.excludeDeprecated) {\n      operationParameters = operationParameters.filter(\n        ({ resolved }) => !resolved?.deprecated && !resolved?.schema?.deprecated,\n      );\n    }\n    for (const { original, resolved } of operationParameters) {\n      if (resolved?.in !== paramIn) {\n        continue;\n      }\n      let optional: ts.QuestionToken | undefined = undefined;\n      if (paramIn !== \"path\" && !(resolved as ParameterObject).required) {\n        optional = QUESTION_TOKEN;\n      }\n      const subType =\n        \"$ref\" in original\n          ? oapiRef(original.$ref, resolved)\n          : transformParameterObject(resolved as ParameterObject, {\n              ...options,\n              path: createRef([options.path, \"parameters\", resolved.in, resolved.name]),\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(resolved?.name),\n        /* questionToken */ optional,\n        /* type          */ subType,\n      );\n      addJSDocComment(resolved, property);\n      paramLocType.push(property);\n    }\n    const allOptional = paramLocType.every((node) => !!node.questionToken);\n    paramType.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(paramIn),\n        /* questionToken */ allOptional || !paramLocType.length ? QUESTION_TOKEN : undefined,\n        /* type          */ paramLocType.length ? ts.factory.createTypeLiteralNode(paramLocType) : NEVER,\n      ),\n    );\n  }\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"parameters\"),\n      /* questionToken */ !paramType.length ? QUESTION_TOKEN : undefined,\n      /* type          */ paramType.length ? ts.factory.createTypeLiteralNode(paramType) : NEVER,\n    ),\n  );\n\n  return type;\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"parameters-array.mjs","sources":["../../src/transform/parameters-array.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type { ParameterObject, ReferenceObject, TransformNodeOptions } from \"../types.js\";\nimport transformParameterObject from \"./parameter-object.js\";\n\n// Regex to match path parameters in URL\nconst PATH_PARAM_RE = /\\{([^}]+)\\}/g;\n\n/**\n * Create a synthetic path parameter object from a parameter name\n */\nfunction createPathParameter(paramName: string): ParameterObject {\n  return {\n    name: paramName,\n    in: \"path\",\n    required: true,\n    schema: { type: \"string\" },\n  };\n}\n\n/**\n * Extract path parameters from a URL\n */\nfunction extractPathParamsFromUrl(path: string): ParameterObject[] {\n  const params: ParameterObject[] = [];\n  const matches = path.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      const paramName = match.slice(1, -1);\n      params.push(createPathParameter(paramName));\n    }\n  }\n  return params;\n}\n\n/**\n * Synthetic type. Array of (ParameterObject | ReferenceObject)s found in OperationObject and PathItemObject.\n */\nexport function transformParametersArray(\n  parametersArray: (ParameterObject | ReferenceObject)[],\n  options: TransformNodeOptions,\n): ts.TypeElement[] {\n  const type: ts.TypeElement[] = [];\n\n  // Create a working copy of parameters array\n  const workingParameters = [...parametersArray];\n\n  // Generate path parameters if enabled\n  if (options.ctx.generatePathParams && options.path) {\n    const pathString = Array.isArray(options.path) ? options.path[0] : options.path;\n    if (typeof pathString === \"string\") {\n      const pathParams = extractPathParamsFromUrl(pathString);\n      // Only add path parameters that aren't already defined\n      for (const param of pathParams) {\n        const exists = workingParameters.some((p) => {\n          const resolved = \"$ref\" in p ? options.ctx.resolve<ParameterObject>(p.$ref) : p;\n          return resolved?.in === \"path\" && resolved?.name === param.name;\n        });\n        if (!exists) {\n          workingParameters.push(param);\n        }\n      }\n    }\n  }\n\n  // parameters\n  const paramType: ts.TypeElement[] = [];\n  for (const paramIn of [\"query\", \"header\", \"path\", \"cookie\"] as ParameterObject[\"in\"][]) {\n    const paramLocType: ts.TypeElement[] = [];\n    let operationParameters = workingParameters.map((param) => ({\n      original: param,\n      resolved: \"$ref\" in param ? options.ctx.resolve<ParameterObject>(param.$ref) : param,\n    }));\n\n    // this is the only array type in the spec, so we have to one-off sort here\n    if (options.ctx.alphabetize) {\n      operationParameters.sort((a, b) => (a.resolved?.name ?? \"\").localeCompare(b.resolved?.name ?? \"\"));\n    }\n    if (options.ctx.excludeDeprecated) {\n      operationParameters = operationParameters.filter(\n        ({ resolved }) => !resolved?.deprecated && !resolved?.schema?.deprecated,\n      );\n    }\n    for (const { original, resolved } of operationParameters) {\n      if (resolved?.in !== paramIn) {\n        continue;\n      }\n      let optional: ts.QuestionToken | undefined = undefined;\n      if (paramIn !== \"path\" && !(resolved as ParameterObject).required) {\n        optional = QUESTION_TOKEN;\n      }\n      const subType =\n        \"$ref\" in original\n          ? oapiRef(original.$ref, resolved)\n          : transformParameterObject(resolved as ParameterObject, {\n              ...options,\n              path: createRef([options.path, \"parameters\", resolved.in, resolved.name]),\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(resolved?.name),\n        /* questionToken */ optional,\n        /* type          */ subType,\n      );\n      addJSDocComment(resolved, property);\n      paramLocType.push(property);\n    }\n    const allOptional = paramLocType.every((node) => !!node.questionToken);\n    paramType.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(paramIn),\n        /* questionToken */ allOptional || !paramLocType.length ? QUESTION_TOKEN : undefined,\n        /* type          */ paramLocType.length ? ts.factory.createTypeLiteralNode(paramLocType) : NEVER,\n      ),\n    );\n  }\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"parameters\"),\n      /* questionToken */ !paramType.length ? QUESTION_TOKEN : undefined,\n      /* type          */ paramType.length ? ts.factory.createTypeLiteralNode(paramType) : NEVER,\n    ),\n  );\n\n  return type;\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/path-item-object.cjs.map b/dist/transform/path-item-object.cjs.map
index d65077883eb30fa3a5575e583105433917074276..9a4dcbae888c713b85b86ed0c53b7c8d77b13bdb 100644
--- a/dist/transform/path-item-object.cjs.map
+++ b/dist/transform/path-item-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"path-item-object.cjs","sources":["../../src/transform/path-item-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type {\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  ReferenceObject,\n  TransformNodeOptions,\n} from \"../types.js\";\nimport transformOperationObject, { injectOperationObject } from \"./operation-object.js\";\nimport { transformParametersArray } from \"./parameters-array.js\";\n\nexport type Method = \"get\" | \"put\" | \"post\" | \"delete\" | \"options\" | \"head\" | \"patch\" | \"trace\";\n\n/**\n * Transform PathItem nodes (4.8.9)\n * @see https://spec.openapis.org/oas/v3.1.0#path-item-object\n */\nexport default function transformPathItemObject(pathItem: PathItemObject, options: TransformNodeOptions): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  // parameters\n  type.push(\n    ...transformParametersArray(pathItem.parameters ?? [], {\n      ...options,\n      path: createRef([options.path, \"parameters\"]),\n    }),\n  );\n\n  // methods\n  for (const method of [\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"] as Method[]) {\n    const operationObject = pathItem[method];\n    if (\n      !operationObject ||\n      (options.ctx.excludeDeprecated &&\n        (\"$ref\" in operationObject ? options.ctx.resolve<OperationObject>(operationObject.$ref) : operationObject)\n          ?.deprecated)\n    ) {\n      type.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n          /* name          */ tsPropertyIndex(method),\n          /* questionToken */ QUESTION_TOKEN,\n          /* type          */ NEVER,\n        ),\n      );\n      continue;\n    }\n\n    // fold top-level PathItem parameters into method-level, with the latter overriding the former\n    const keyedParameters: Record<string, ParameterObject | ReferenceObject> = {};\n    if (!(\"$ref\" in operationObject)) {\n      // important: OperationObject parameters come last, and will override any conflicts with PathItem parameters\n      for (const parameter of [...(pathItem.parameters ?? []), ...(operationObject.parameters ?? [])]) {\n        // fix: #1798, use unique key\n        const name =\n          \"$ref\" in parameter\n            ? `${options.ctx.resolve<ParameterObject>(parameter.$ref)?.in}-${options.ctx.resolve<ParameterObject>(parameter.$ref)?.name}`\n            : `${parameter.in}-${parameter.name}`;\n        if (name) {\n          keyedParameters[name] = parameter;\n        }\n      }\n    }\n\n    let operationType: ts.TypeNode;\n    if (\"$ref\" in operationObject) {\n      operationType = oapiRef(operationObject.$ref);\n    }\n    // if operationId exists, move into an `operations` export and pass the reference in here\n    else if (operationObject.operationId) {\n      // workaround for issue caused by redocly ref parsing: https://github.com/openapi-ts/openapi-typescript/issues/1542\n      const operationId = operationObject.operationId.replace(HASH_RE, \"/\");\n      operationType = oapiRef(createRef([\"operations\", operationId]));\n      injectOperationObject(\n        operationId,\n        { ...operationObject, parameters: Object.values(keyedParameters) },\n        { ...options, path: createRef([options.path, method]) },\n      );\n    } else {\n      operationType = ts.factory.createTypeLiteralNode(\n        transformOperationObject(\n          { ...operationObject, parameters: Object.values(keyedParameters) },\n          { ...options, path: createRef([options.path, method]) },\n        ),\n      );\n    }\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(method),\n      /* questionToken */ undefined,\n      /* type          */ operationType,\n    );\n    addJSDocComment(operationObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n\nconst HASH_RE = /#/g;\n"],"names":["transformParametersArray","createRef","operationObject","ts","tsModifiers","tsPropertyIndex","QUESTION_TOKEN","NEVER","oapiRef","injectOperationObject","transformOperationObject","addJSDocComment"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"path-item-object.cjs","sources":["../../src/transform/path-item-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type {\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  ReferenceObject,\n  TransformNodeOptions,\n} from \"../types.js\";\nimport transformOperationObject, { injectOperationObject } from \"./operation-object.js\";\nimport { transformParametersArray } from \"./parameters-array.js\";\n\nexport type Method = \"get\" | \"put\" | \"post\" | \"delete\" | \"options\" | \"head\" | \"patch\" | \"trace\";\n\n/**\n * Transform PathItem nodes (4.8.9)\n * @see https://spec.openapis.org/oas/v3.1.0#path-item-object\n */\nexport default function transformPathItemObject(pathItem: PathItemObject, options: TransformNodeOptions): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  // parameters\n  type.push(\n    ...transformParametersArray(pathItem.parameters ?? [], {\n      ...options,\n      path: createRef([options.path, \"parameters\"]),\n    }),\n  );\n\n  // methods\n  for (const method of [\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"] as Method[]) {\n    const operationObject = pathItem[method];\n    if (\n      !operationObject ||\n      (options.ctx.excludeDeprecated &&\n        (\"$ref\" in operationObject ? options.ctx.resolve<OperationObject>(operationObject.$ref) : operationObject)\n          ?.deprecated)\n    ) {\n      type.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n          /* name          */ tsPropertyIndex(method),\n          /* questionToken */ QUESTION_TOKEN,\n          /* type          */ NEVER,\n        ),\n      );\n      continue;\n    }\n\n    // fold top-level PathItem parameters into method-level, with the latter overriding the former\n    const keyedParameters: Record<string, ParameterObject | ReferenceObject> = {};\n    if (!(\"$ref\" in operationObject)) {\n      // important: OperationObject parameters come last, and will override any conflicts with PathItem parameters\n      for (const parameter of [...(pathItem.parameters ?? []), ...(operationObject.parameters ?? [])]) {\n        // fix: #1798, use unique key\n        const name =\n          \"$ref\" in parameter\n            ? `${options.ctx.resolve<ParameterObject>(parameter.$ref)?.in}-${options.ctx.resolve<ParameterObject>(parameter.$ref)?.name}`\n            : `${parameter.in}-${parameter.name}`;\n        if (name) {\n          keyedParameters[name] = parameter;\n        }\n      }\n    }\n\n    let operationType: ts.TypeNode;\n    if (\"$ref\" in operationObject) {\n      operationType = oapiRef(operationObject.$ref);\n    }\n    // if operationId exists, move into an `operations` export and pass the reference in here\n    else if (operationObject.operationId) {\n      // workaround for issue caused by redocly ref parsing: https://github.com/openapi-ts/openapi-typescript/issues/1542\n      const operationId = operationObject.operationId.replace(HASH_RE, \"/\");\n      operationType = oapiRef(createRef([\"operations\", operationId]));\n      injectOperationObject(\n        operationId,\n        { ...operationObject, parameters: Object.values(keyedParameters) },\n        { ...options, path: createRef([options.path, method]) },\n      );\n    } else {\n      operationType = ts.factory.createTypeLiteralNode(\n        transformOperationObject(\n          { ...operationObject, parameters: Object.values(keyedParameters) },\n          { ...options, path: createRef([options.path, method]) },\n        ),\n      );\n    }\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(method),\n      /* questionToken */ undefined,\n      /* type          */ operationType,\n    );\n    addJSDocComment(operationObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n\nconst HASH_RE = /#/g;\n"],"names":["transformParametersArray","createRef","operationObject","ts","tsModifiers","tsPropertyIndex","QUESTION_TOKEN","NEVER","oapiRef","injectOperationObject","transformOperationObject","addJSDocComment"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/path-item-object.mjs.map b/dist/transform/path-item-object.mjs.map
index 306a76c2d81445b95645cafa0f73b9f87ea62438..b67e0646452642c87e2e934eb3d9b5836199bf0d 100644
--- a/dist/transform/path-item-object.mjs.map
+++ b/dist/transform/path-item-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"path-item-object.mjs","sources":["../../src/transform/path-item-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type {\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  ReferenceObject,\n  TransformNodeOptions,\n} from \"../types.js\";\nimport transformOperationObject, { injectOperationObject } from \"./operation-object.js\";\nimport { transformParametersArray } from \"./parameters-array.js\";\n\nexport type Method = \"get\" | \"put\" | \"post\" | \"delete\" | \"options\" | \"head\" | \"patch\" | \"trace\";\n\n/**\n * Transform PathItem nodes (4.8.9)\n * @see https://spec.openapis.org/oas/v3.1.0#path-item-object\n */\nexport default function transformPathItemObject(pathItem: PathItemObject, options: TransformNodeOptions): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  // parameters\n  type.push(\n    ...transformParametersArray(pathItem.parameters ?? [], {\n      ...options,\n      path: createRef([options.path, \"parameters\"]),\n    }),\n  );\n\n  // methods\n  for (const method of [\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"] as Method[]) {\n    const operationObject = pathItem[method];\n    if (\n      !operationObject ||\n      (options.ctx.excludeDeprecated &&\n        (\"$ref\" in operationObject ? options.ctx.resolve<OperationObject>(operationObject.$ref) : operationObject)\n          ?.deprecated)\n    ) {\n      type.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n          /* name          */ tsPropertyIndex(method),\n          /* questionToken */ QUESTION_TOKEN,\n          /* type          */ NEVER,\n        ),\n      );\n      continue;\n    }\n\n    // fold top-level PathItem parameters into method-level, with the latter overriding the former\n    const keyedParameters: Record<string, ParameterObject | ReferenceObject> = {};\n    if (!(\"$ref\" in operationObject)) {\n      // important: OperationObject parameters come last, and will override any conflicts with PathItem parameters\n      for (const parameter of [...(pathItem.parameters ?? []), ...(operationObject.parameters ?? [])]) {\n        // fix: #1798, use unique key\n        const name =\n          \"$ref\" in parameter\n            ? `${options.ctx.resolve<ParameterObject>(parameter.$ref)?.in}-${options.ctx.resolve<ParameterObject>(parameter.$ref)?.name}`\n            : `${parameter.in}-${parameter.name}`;\n        if (name) {\n          keyedParameters[name] = parameter;\n        }\n      }\n    }\n\n    let operationType: ts.TypeNode;\n    if (\"$ref\" in operationObject) {\n      operationType = oapiRef(operationObject.$ref);\n    }\n    // if operationId exists, move into an `operations` export and pass the reference in here\n    else if (operationObject.operationId) {\n      // workaround for issue caused by redocly ref parsing: https://github.com/openapi-ts/openapi-typescript/issues/1542\n      const operationId = operationObject.operationId.replace(HASH_RE, \"/\");\n      operationType = oapiRef(createRef([\"operations\", operationId]));\n      injectOperationObject(\n        operationId,\n        { ...operationObject, parameters: Object.values(keyedParameters) },\n        { ...options, path: createRef([options.path, method]) },\n      );\n    } else {\n      operationType = ts.factory.createTypeLiteralNode(\n        transformOperationObject(\n          { ...operationObject, parameters: Object.values(keyedParameters) },\n          { ...options, path: createRef([options.path, method]) },\n        ),\n      );\n    }\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(method),\n      /* questionToken */ undefined,\n      /* type          */ operationType,\n    );\n    addJSDocComment(operationObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n\nconst HASH_RE = /#/g;\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"path-item-object.mjs","sources":["../../src/transform/path-item-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type {\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  ReferenceObject,\n  TransformNodeOptions,\n} from \"../types.js\";\nimport transformOperationObject, { injectOperationObject } from \"./operation-object.js\";\nimport { transformParametersArray } from \"./parameters-array.js\";\n\nexport type Method = \"get\" | \"put\" | \"post\" | \"delete\" | \"options\" | \"head\" | \"patch\" | \"trace\";\n\n/**\n * Transform PathItem nodes (4.8.9)\n * @see https://spec.openapis.org/oas/v3.1.0#path-item-object\n */\nexport default function transformPathItemObject(pathItem: PathItemObject, options: TransformNodeOptions): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  // parameters\n  type.push(\n    ...transformParametersArray(pathItem.parameters ?? [], {\n      ...options,\n      path: createRef([options.path, \"parameters\"]),\n    }),\n  );\n\n  // methods\n  for (const method of [\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"] as Method[]) {\n    const operationObject = pathItem[method];\n    if (\n      !operationObject ||\n      (options.ctx.excludeDeprecated &&\n        (\"$ref\" in operationObject ? options.ctx.resolve<OperationObject>(operationObject.$ref) : operationObject)\n          ?.deprecated)\n    ) {\n      type.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n          /* name          */ tsPropertyIndex(method),\n          /* questionToken */ QUESTION_TOKEN,\n          /* type          */ NEVER,\n        ),\n      );\n      continue;\n    }\n\n    // fold top-level PathItem parameters into method-level, with the latter overriding the former\n    const keyedParameters: Record<string, ParameterObject | ReferenceObject> = {};\n    if (!(\"$ref\" in operationObject)) {\n      // important: OperationObject parameters come last, and will override any conflicts with PathItem parameters\n      for (const parameter of [...(pathItem.parameters ?? []), ...(operationObject.parameters ?? [])]) {\n        // fix: #1798, use unique key\n        const name =\n          \"$ref\" in parameter\n            ? `${options.ctx.resolve<ParameterObject>(parameter.$ref)?.in}-${options.ctx.resolve<ParameterObject>(parameter.$ref)?.name}`\n            : `${parameter.in}-${parameter.name}`;\n        if (name) {\n          keyedParameters[name] = parameter;\n        }\n      }\n    }\n\n    let operationType: ts.TypeNode;\n    if (\"$ref\" in operationObject) {\n      operationType = oapiRef(operationObject.$ref);\n    }\n    // if operationId exists, move into an `operations` export and pass the reference in here\n    else if (operationObject.operationId) {\n      // workaround for issue caused by redocly ref parsing: https://github.com/openapi-ts/openapi-typescript/issues/1542\n      const operationId = operationObject.operationId.replace(HASH_RE, \"/\");\n      operationType = oapiRef(createRef([\"operations\", operationId]));\n      injectOperationObject(\n        operationId,\n        { ...operationObject, parameters: Object.values(keyedParameters) },\n        { ...options, path: createRef([options.path, method]) },\n      );\n    } else {\n      operationType = ts.factory.createTypeLiteralNode(\n        transformOperationObject(\n          { ...operationObject, parameters: Object.values(keyedParameters) },\n          { ...options, path: createRef([options.path, method]) },\n        ),\n      );\n    }\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(method),\n      /* questionToken */ undefined,\n      /* type          */ operationType,\n    );\n    addJSDocComment(operationObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n\nconst HASH_RE = /#/g;\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/paths-enum.cjs.map b/dist/transform/paths-enum.cjs.map
index ec930109780243ffd00b0ec5fee567bb9f618d47..5b41c5bb911301c37b7aafa5f32af27cf215cb52 100644
--- a/dist/transform/paths-enum.cjs.map
+++ b/dist/transform/paths-enum.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"paths-enum.cjs","sources":["../../src/transform/paths-enum.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { tsEnum } from \"../lib/ts.js\";\nimport { getEntries } from \"../lib/utils.js\";\nimport type { PathsObject } from \"../types.js\";\n\nexport default function makeApiPathsEnum(pathsObject: PathsObject): ts.EnumDeclaration {\n  const enumKeys = [];\n  const enumMetaData = [];\n\n  for (const [url, pathItemObject] of getEntries(pathsObject)) {\n    for (const [method, operation] of Object.entries(pathItemObject)) {\n      if (![\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"].includes(method)) {\n        continue;\n      }\n\n      // Generate a name from the operation ID\n      let pathName: string;\n      if (operation.operationId) {\n        pathName = operation.operationId;\n      } else {\n        // If the operation ID is not present, construct a name from the method and path\n        pathName = (method + url)\n          .split(\"/\")\n          .map((part) => {\n            const capitalised = part.charAt(0).toUpperCase() + part.slice(1);\n\n            // Remove any characters not allowed as enum keys, and attempt to remove\n            //  named parameters.\n            return capitalised.replace(/{.*}|:.*|[^a-zA-Z\\d_]+/, \"\");\n          })\n          .join(\"\");\n      }\n      enumKeys.push(url);\n      enumMetaData.push({\n        name: pathName,\n      });\n    }\n  }\n\n  return tsEnum(\"ApiPaths\", enumKeys, enumMetaData, {\n    export: true,\n  });\n}\n"],"names":["getEntries","tsEnum"],"mappings":";;;;;AAKA,SAAwB,iBAAiB,WAAA,EAA8C;AACrF,EAAA,MAAM,WAAW,EAAC;AAClB,EAAA,MAAM,eAAe,EAAC;AAEtB,EAAA,KAAA,MAAW,CAAC,GAAA,EAAK,cAAc,CAAA,IAAKA,gBAAA,CAAW,WAAW,CAAA,EAAG;AAC3D,IAAA,KAAA,MAAW,CAAC,MAAA,EAAQ,SAAS,KAAK,MAAA,CAAO,OAAA,CAAQ,cAAc,CAAA,EAAG;AAChE,MAAA,IAAI,CAAC,CAAC,KAAA,EAAO,KAAA,EAAO,MAAA,EAAQ,QAAA,EAAU,SAAA,EAAW,MAAA,EAAQ,OAAA,EAAS,OAAO,CAAA,CAAE,QAAA,CAAS,MAAM,CAAA,EAAG;AAC3F,QAAA;AAAA,MACF;AAGA,MAAA,IAAI,QAAA;AACJ,MAAA,IAAI,UAAU,WAAA,EAAa;AACzB,QAAA,QAAA,GAAW,SAAA,CAAU,WAAA;AAAA,MACvB,CAAA,MAAO;AAEL,QAAA,QAAA,GAAA,CAAY,SAAS,GAAA,EAClB,KAAA,CAAM,GAAG,CAAA,CACT,GAAA,CAAI,CAAC,IAAA,KAAS;AACb,UAAA,MAAM,WAAA,GAAc,KAAK,MAAA,CAAO,CAAC,EAAE,WAAA,EAAY,GAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;AAI/D,UAAA,OAAO,WAAA,CAAY,OAAA,CAAQ,wBAAA,EAA0B,EAAE,CAAA;AAAA,QACzD,CAAC,CAAA,CACA,IAAA,CAAK,EAAE,CAAA;AAAA,MACZ;AACA,MAAA,QAAA,CAAS,KAAK,GAAG,CAAA;AACjB,MAAA,YAAA,CAAa,IAAA,CAAK;AAAA,QAChB,IAAA,EAAM;AAAA,OACP,CAAA;AAAA,IACH;AAAA,EACF;AAEA,EAAA,OAAOC,SAAA,CAAO,UAAA,EAAY,QAAA,EAAU,YAAA,EAAc;AAAA,IAChD,MAAA,EAAQ;AAAA,GACT,CAAA;AACH;;;;"}
\ No newline at end of file
+{"version":3,"file":"paths-enum.cjs","sources":["../../src/transform/paths-enum.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { tsEnum } from \"../lib/ts.js\";\nimport { getEntries } from \"../lib/utils.js\";\nimport type { PathsObject } from \"../types.js\";\n\nexport default function makeApiPathsEnum(pathsObject: PathsObject): ts.EnumDeclaration {\n  const enumKeys = [];\n  const enumMetaData = [];\n\n  for (const [url, pathItemObject] of getEntries(pathsObject)) {\n    for (const [method, operation] of Object.entries(pathItemObject)) {\n      if (![\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"].includes(method)) {\n        continue;\n      }\n\n      // Generate a name from the operation ID\n      let pathName: string;\n      if (operation.operationId) {\n        pathName = operation.operationId;\n      } else {\n        // If the operation ID is not present, construct a name from the method and path\n        pathName = (method + url)\n          .split(\"/\")\n          .map((part) => {\n            const capitalised = part.charAt(0).toUpperCase() + part.slice(1);\n\n            // Remove any characters not allowed as enum keys, and attempt to remove\n            //  named parameters.\n            return capitalised.replace(/{.*}|:.*|[^a-zA-Z\\d_]+/, \"\");\n          })\n          .join(\"\");\n      }\n      enumKeys.push(url);\n      enumMetaData.push({\n        name: pathName,\n      });\n    }\n  }\n\n  return tsEnum(\"ApiPaths\", enumKeys, enumMetaData, {\n    export: true,\n  });\n}\n"],"names":["getEntries","tsEnum"],"mappings":";;;;;AAKA,SAAwB,iBAAiB,WAA8C,EAAA;AACrF,EAAA,MAAM,WAAW,EAAC;AAClB,EAAA,MAAM,eAAe,EAAC;AAEtB,EAAA,KAAA,MAAW,CAAC,GAAK,EAAA,cAAc,CAAK,IAAAA,gBAAA,CAAW,WAAW,CAAG,EAAA;AAC3D,IAAA,KAAA,MAAW,CAAC,MAAQ,EAAA,SAAS,KAAK,MAAO,CAAA,OAAA,CAAQ,cAAc,CAAG,EAAA;AAChE,MAAA,IAAI,CAAC,CAAC,KAAO,EAAA,KAAA,EAAO,MAAQ,EAAA,QAAA,EAAU,SAAW,EAAA,MAAA,EAAQ,OAAS,EAAA,OAAO,CAAE,CAAA,QAAA,CAAS,MAAM,CAAG,EAAA;AAC3F,QAAA;AAAA;AAIF,MAAI,IAAA,QAAA;AACJ,MAAA,IAAI,UAAU,WAAa,EAAA;AACzB,QAAA,QAAA,GAAW,SAAU,CAAA,WAAA;AAAA,OAChB,MAAA;AAEL,QAAA,QAAA,GAAA,CAAY,SAAS,GAClB,EAAA,KAAA,CAAM,GAAG,CACT,CAAA,GAAA,CAAI,CAAC,IAAS,KAAA;AACb,UAAM,MAAA,WAAA,GAAc,KAAK,MAAO,CAAA,CAAC,EAAE,WAAY,EAAA,GAAI,IAAK,CAAA,KAAA,CAAM,CAAC,CAAA;AAI/D,UAAO,OAAA,WAAA,CAAY,OAAQ,CAAA,wBAAA,EAA0B,EAAE,CAAA;AAAA,SACxD,CACA,CAAA,IAAA,CAAK,EAAE,CAAA;AAAA;AAEZ,MAAA,QAAA,CAAS,KAAK,GAAG,CAAA;AACjB,MAAA,YAAA,CAAa,IAAK,CAAA;AAAA,QAChB,IAAM,EAAA;AAAA,OACP,CAAA;AAAA;AACH;AAGF,EAAO,OAAAC,SAAA,CAAO,UAAY,EAAA,QAAA,EAAU,YAAc,EAAA;AAAA,IAChD,MAAQ,EAAA;AAAA,GACT,CAAA;AACH;;;;"}
\ No newline at end of file
diff --git a/dist/transform/paths-enum.mjs.map b/dist/transform/paths-enum.mjs.map
index ef202fe2554d259d65305aaac7ba04303cc0ee29..95e925f6ea948ed1b175dc99d4392f0f6a63cb11 100644
--- a/dist/transform/paths-enum.mjs.map
+++ b/dist/transform/paths-enum.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"paths-enum.mjs","sources":["../../src/transform/paths-enum.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { tsEnum } from \"../lib/ts.js\";\nimport { getEntries } from \"../lib/utils.js\";\nimport type { PathsObject } from \"../types.js\";\n\nexport default function makeApiPathsEnum(pathsObject: PathsObject): ts.EnumDeclaration {\n  const enumKeys = [];\n  const enumMetaData = [];\n\n  for (const [url, pathItemObject] of getEntries(pathsObject)) {\n    for (const [method, operation] of Object.entries(pathItemObject)) {\n      if (![\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"].includes(method)) {\n        continue;\n      }\n\n      // Generate a name from the operation ID\n      let pathName: string;\n      if (operation.operationId) {\n        pathName = operation.operationId;\n      } else {\n        // If the operation ID is not present, construct a name from the method and path\n        pathName = (method + url)\n          .split(\"/\")\n          .map((part) => {\n            const capitalised = part.charAt(0).toUpperCase() + part.slice(1);\n\n            // Remove any characters not allowed as enum keys, and attempt to remove\n            //  named parameters.\n            return capitalised.replace(/{.*}|:.*|[^a-zA-Z\\d_]+/, \"\");\n          })\n          .join(\"\");\n      }\n      enumKeys.push(url);\n      enumMetaData.push({\n        name: pathName,\n      });\n    }\n  }\n\n  return tsEnum(\"ApiPaths\", enumKeys, enumMetaData, {\n    export: true,\n  });\n}\n"],"names":[],"mappings":";;;AAKA,SAAwB,iBAAiB,WAAA,EAA8C;AACrF,EAAA,MAAM,WAAW,EAAC;AAClB,EAAA,MAAM,eAAe,EAAC;AAEtB,EAAA,KAAA,MAAW,CAAC,GAAA,EAAK,cAAc,CAAA,IAAK,UAAA,CAAW,WAAW,CAAA,EAAG;AAC3D,IAAA,KAAA,MAAW,CAAC,MAAA,EAAQ,SAAS,KAAK,MAAA,CAAO,OAAA,CAAQ,cAAc,CAAA,EAAG;AAChE,MAAA,IAAI,CAAC,CAAC,KAAA,EAAO,KAAA,EAAO,MAAA,EAAQ,QAAA,EAAU,SAAA,EAAW,MAAA,EAAQ,OAAA,EAAS,OAAO,CAAA,CAAE,QAAA,CAAS,MAAM,CAAA,EAAG;AAC3F,QAAA;AAAA,MACF;AAGA,MAAA,IAAI,QAAA;AACJ,MAAA,IAAI,UAAU,WAAA,EAAa;AACzB,QAAA,QAAA,GAAW,SAAA,CAAU,WAAA;AAAA,MACvB,CAAA,MAAO;AAEL,QAAA,QAAA,GAAA,CAAY,SAAS,GAAA,EAClB,KAAA,CAAM,GAAG,CAAA,CACT,GAAA,CAAI,CAAC,IAAA,KAAS;AACb,UAAA,MAAM,WAAA,GAAc,KAAK,MAAA,CAAO,CAAC,EAAE,WAAA,EAAY,GAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;AAI/D,UAAA,OAAO,WAAA,CAAY,OAAA,CAAQ,wBAAA,EAA0B,EAAE,CAAA;AAAA,QACzD,CAAC,CAAA,CACA,IAAA,CAAK,EAAE,CAAA;AAAA,MACZ;AACA,MAAA,QAAA,CAAS,KAAK,GAAG,CAAA;AACjB,MAAA,YAAA,CAAa,IAAA,CAAK;AAAA,QAChB,IAAA,EAAM;AAAA,OACP,CAAA;AAAA,IACH;AAAA,EACF;AAEA,EAAA,OAAO,MAAA,CAAO,UAAA,EAAY,QAAA,EAAU,YAAA,EAAc;AAAA,IAChD,MAAA,EAAQ;AAAA,GACT,CAAA;AACH;;;;"}
\ No newline at end of file
+{"version":3,"file":"paths-enum.mjs","sources":["../../src/transform/paths-enum.ts"],"sourcesContent":["import type ts from \"typescript\";\nimport { tsEnum } from \"../lib/ts.js\";\nimport { getEntries } from \"../lib/utils.js\";\nimport type { PathsObject } from \"../types.js\";\n\nexport default function makeApiPathsEnum(pathsObject: PathsObject): ts.EnumDeclaration {\n  const enumKeys = [];\n  const enumMetaData = [];\n\n  for (const [url, pathItemObject] of getEntries(pathsObject)) {\n    for (const [method, operation] of Object.entries(pathItemObject)) {\n      if (![\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"].includes(method)) {\n        continue;\n      }\n\n      // Generate a name from the operation ID\n      let pathName: string;\n      if (operation.operationId) {\n        pathName = operation.operationId;\n      } else {\n        // If the operation ID is not present, construct a name from the method and path\n        pathName = (method + url)\n          .split(\"/\")\n          .map((part) => {\n            const capitalised = part.charAt(0).toUpperCase() + part.slice(1);\n\n            // Remove any characters not allowed as enum keys, and attempt to remove\n            //  named parameters.\n            return capitalised.replace(/{.*}|:.*|[^a-zA-Z\\d_]+/, \"\");\n          })\n          .join(\"\");\n      }\n      enumKeys.push(url);\n      enumMetaData.push({\n        name: pathName,\n      });\n    }\n  }\n\n  return tsEnum(\"ApiPaths\", enumKeys, enumMetaData, {\n    export: true,\n  });\n}\n"],"names":[],"mappings":";;;AAKA,SAAwB,iBAAiB,WAA8C,EAAA;AACrF,EAAA,MAAM,WAAW,EAAC;AAClB,EAAA,MAAM,eAAe,EAAC;AAEtB,EAAA,KAAA,MAAW,CAAC,GAAK,EAAA,cAAc,CAAK,IAAA,UAAA,CAAW,WAAW,CAAG,EAAA;AAC3D,IAAA,KAAA,MAAW,CAAC,MAAQ,EAAA,SAAS,KAAK,MAAO,CAAA,OAAA,CAAQ,cAAc,CAAG,EAAA;AAChE,MAAA,IAAI,CAAC,CAAC,KAAO,EAAA,KAAA,EAAO,MAAQ,EAAA,QAAA,EAAU,SAAW,EAAA,MAAA,EAAQ,OAAS,EAAA,OAAO,CAAE,CAAA,QAAA,CAAS,MAAM,CAAG,EAAA;AAC3F,QAAA;AAAA;AAIF,MAAI,IAAA,QAAA;AACJ,MAAA,IAAI,UAAU,WAAa,EAAA;AACzB,QAAA,QAAA,GAAW,SAAU,CAAA,WAAA;AAAA,OAChB,MAAA;AAEL,QAAA,QAAA,GAAA,CAAY,SAAS,GAClB,EAAA,KAAA,CAAM,GAAG,CACT,CAAA,GAAA,CAAI,CAAC,IAAS,KAAA;AACb,UAAM,MAAA,WAAA,GAAc,KAAK,MAAO,CAAA,CAAC,EAAE,WAAY,EAAA,GAAI,IAAK,CAAA,KAAA,CAAM,CAAC,CAAA;AAI/D,UAAO,OAAA,WAAA,CAAY,OAAQ,CAAA,wBAAA,EAA0B,EAAE,CAAA;AAAA,SACxD,CACA,CAAA,IAAA,CAAK,EAAE,CAAA;AAAA;AAEZ,MAAA,QAAA,CAAS,KAAK,GAAG,CAAA;AACjB,MAAA,YAAA,CAAa,IAAK,CAAA;AAAA,QAChB,IAAM,EAAA;AAAA,OACP,CAAA;AAAA;AACH;AAGF,EAAO,OAAA,MAAA,CAAO,UAAY,EAAA,QAAA,EAAU,YAAc,EAAA;AAAA,IAChD,MAAQ,EAAA;AAAA,GACT,CAAA;AACH;;;;"}
\ No newline at end of file
diff --git a/dist/transform/paths-object.cjs.map b/dist/transform/paths-object.cjs.map
index fcb59c47bf3641e6db08ee6e6e1dbecca069416a..565e8e6de6dc85ce9a9ef4b2ca21cfc898627ad8 100644
--- a/dist/transform/paths-object.cjs.map
+++ b/dist/transform/paths-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"paths-object.cjs","sources":["../../src/transform/paths-object.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport ts from \"typescript\";\nimport { addJSDocComment, oapiRef, stringToAST, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, debug, getEntries } from \"../lib/utils.js\";\nimport type {\n  GlobalContext,\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  PathsObject,\n  ReferenceObject,\n} from \"../types.js\";\nimport transformPathItemObject, { type Method } from \"./path-item-object.js\";\n\nconst PATH_PARAM_RE = /\\{[^}]+\\}/g;\n\n/**\n * Transform the PathsObject node (4.8.8)\n * @see https://spec.openapis.org/oas/v3.1.0#operation-object\n */\nexport default function transformPathsObject(pathsObject: PathsObject, ctx: GlobalContext): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [url, pathItemObject] of getEntries(pathsObject, ctx)) {\n    if (!pathItemObject || typeof pathItemObject !== \"object\") {\n      continue;\n    }\n\n    const pathT = performance.now();\n\n    // handle $ref\n    if (\"$ref\" in pathItemObject) {\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n        /* name          */ tsPropertyIndex(url),\n        /* questionToken */ undefined,\n        /* type          */ oapiRef(pathItemObject.$ref),\n      );\n      addJSDocComment(pathItemObject, property);\n      type.push(property);\n    } else {\n      const pathItemType = transformPathItemObject(pathItemObject, {\n        path: createRef([\"paths\", url]),\n        ctx,\n      });\n\n      // pathParamsAsTypes\n      if (ctx.pathParamsAsTypes && url.includes(\"{\")) {\n        const pathParams = extractPathParams(pathItemObject, ctx);\n        const matches = url.match(PATH_PARAM_RE);\n        let rawPath = `\\`${url}\\``;\n        if (matches) {\n          for (const match of matches) {\n            const paramName = match.slice(1, -1);\n            const param = pathParams[paramName];\n            switch (param?.schema?.type) {\n              case \"number\":\n              case \"integer\":\n                rawPath = rawPath.replace(match, \"${number}\");\n                break;\n              case \"boolean\":\n                rawPath = rawPath.replace(match, \"${boolean}\");\n                break;\n              default:\n                rawPath = rawPath.replace(match, \"${string}\");\n                break;\n            }\n          }\n          // note: creating a string template literal’s AST manually is hard!\n          // just pass an arbitrary string to TS\n          const pathType = (stringToAST(rawPath)[0] as any)?.expression;\n          if (pathType) {\n            type.push(\n              ts.factory.createIndexSignature(\n                /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n                /* parameters    */ [\n                  ts.factory.createParameterDeclaration(\n                    /* modifiers      */ undefined,\n                    /* dotDotDotToken */ undefined,\n                    /* name           */ \"path\",\n                    /* questionToken  */ undefined,\n                    /* type           */ pathType,\n                    /* initializer    */ undefined,\n                  ),\n                ],\n                /* type          */ pathItemType,\n              ),\n            );\n            continue;\n          }\n        }\n      }\n\n      type.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n          /* name          */ tsPropertyIndex(url),\n          /* questionToken */ undefined,\n          /* type          */ pathItemType,\n        ),\n      );\n\n      debug(`Transformed path \"${url}\"`, \"ts\", performance.now() - pathT);\n    }\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n\nfunction extractPathParams(pathItemObject: PathItemObject, ctx: GlobalContext) {\n  const params: Record<string, ParameterObject> = {};\n  for (const p of pathItemObject.parameters ?? []) {\n    const resolved = \"$ref\" in p && p.$ref ? ctx.resolve<ParameterObject>(p.$ref) : (p as ParameterObject);\n    if (resolved && resolved.in === \"path\") {\n      params[resolved.name] = resolved;\n    }\n  }\n  for (const method of [\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"] as Method[]) {\n    if (!(method in pathItemObject)) {\n      continue;\n    }\n    const resolvedMethod = (pathItemObject[method] as ReferenceObject).$ref\n      ? ctx.resolve<OperationObject>((pathItemObject[method] as ReferenceObject).$ref)\n      : (pathItemObject[method] as OperationObject);\n    if (resolvedMethod?.parameters) {\n      for (const p of resolvedMethod.parameters) {\n        const resolvedParam = \"$ref\" in p && p.$ref ? ctx.resolve<ParameterObject>(p.$ref) : (p as ParameterObject);\n        if (resolvedParam && resolvedParam.in === \"path\") {\n          params[resolvedParam.name] = resolvedParam;\n        }\n      }\n    }\n  }\n  return params;\n}\n"],"names":["pathItemObject","getEntries","performance","ts","tsModifiers","tsPropertyIndex","oapiRef","addJSDocComment","transformPathItemObject","createRef","stringToAST","debug"],"mappings":";;;;;;;;;;;;AAcA,MAAM,aAAA,GAAgB,YAAA;AAMtB,SAAwB,oBAAA,CAAqB,aAA0B,GAAA,EAAiC;AACtG,EAAA,MAAM,OAAyB,EAAC;AAChC,EAAA,KAAA,MAAW,CAAC,GAAA,EAAKA,gBAAc,KAAKC,gBAAA,CAAW,WAAA,EAAa,GAAG,CAAA,EAAG;AAChE,IAAA,IAAI,CAACD,gBAAA,IAAkB,OAAOA,gBAAA,KAAmB,QAAA,EAAU;AACzD,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,KAAA,GAAQE,4BAAY,GAAA,EAAI;AAG9B,IAAA,IAAI,UAAUF,gBAAA,EAAgB;AAC5B,MAAA,MAAM,QAAA,GAAWG,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,QACNC,gBAAA,CAAY,EAAE,QAAA,EAAU,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,QACvCC,qBAAgB,GAAG,CAAA;AAAA;AAAA,QACnB,MAAA;AAAA;AAAA,QACAC,YAAA,CAAQN,iBAAe,IAAI;AAAA,OACjD;AACA,MAAAO,oBAAA,CAAgBP,kBAAgB,QAAQ,CAAA;AACxC,MAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,IACpB,CAAA,MAAO;AACL,MAAA,MAAM,YAAA,GAAeQ,eAAwBR,gBAAA,EAAgB;AAAA,QAC3D,IAAA,EAAMS,eAAA,CAAU,CAAC,OAAA,EAAS,GAAG,CAAC,CAAA;AAAA,QAC9B;AAAA,OACD,CAAA;AAGD,MAAA,IAAI,GAAA,CAAI,iBAAA,IAAqB,GAAA,CAAI,QAAA,CAAS,GAAG,CAAA,EAAG;AAC9C,QAAA,MAAM,UAAA,GAAa,iBAAA,CAAkBT,gBAAA,EAAgB,GAAG,CAAA;AACxD,QAAA,MAAM,OAAA,GAAU,GAAA,CAAI,KAAA,CAAM,aAAa,CAAA;AACvC,QAAA,IAAI,OAAA,GAAU,KAAK,GAAG,CAAA,EAAA,CAAA;AACtB,QAAA,IAAI,OAAA,EAAS;AACX,UAAA,KAAA,MAAW,SAAS,OAAA,EAAS;AAC3B,YAAA,MAAM,SAAA,GAAY,KAAA,CAAM,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA;AACnC,YAAA,MAAM,KAAA,GAAQ,WAAW,SAAS,CAAA;AAClC,YAAA,QAAQ,KAAA,EAAO,QAAQ,IAAA;AAAM,cAC3B,KAAK,QAAA;AAAA,cACL,KAAK,SAAA;AACH,gBAAA,OAAA,GAAU,OAAA,CAAQ,OAAA,CAAQ,KAAA,EAAO,WAAW,CAAA;AAC5C,gBAAA;AAAA,cACF,KAAK,SAAA;AACH,gBAAA,OAAA,GAAU,OAAA,CAAQ,OAAA,CAAQ,KAAA,EAAO,YAAY,CAAA;AAC7C,gBAAA;AAAA,cACF;AACE,gBAAA,OAAA,GAAU,OAAA,CAAQ,OAAA,CAAQ,KAAA,EAAO,WAAW,CAAA;AAC5C,gBAAA;AAAA;AACJ,UACF;AAGA,UAAA,MAAM,QAAA,GAAYU,gBAAA,CAAY,OAAO,CAAA,CAAE,CAAC,CAAA,EAAW,UAAA;AACnD,UAAA,IAAI,QAAA,EAAU;AACZ,YAAA,IAAA,CAAK,IAAA;AAAA,cACHP,YAAG,OAAA,CAAQ,oBAAA;AAAA;AAAA,gBACWC,gBAAA,CAAY,EAAE,QAAA,EAAU,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,gBACvC;AAAA,kBAClBD,YAAG,OAAA,CAAQ,0BAAA;AAAA;AAAA,oBACY,MAAA;AAAA;AAAA,oBACA,MAAA;AAAA;AAAA,oBACA,MAAA;AAAA;AAAA,oBACA,MAAA;AAAA;AAAA,oBACA,QAAA;AAAA;AAAA,oBACA;AAAA;AACvB,iBACF;AAAA;AAAA,gBACoB;AAAA;AACtB,aACF;AACA,YAAA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,MAAA,IAAA,CAAK,IAAA;AAAA,QACHA,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,UACWC,gBAAA,CAAY,EAAE,QAAA,EAAU,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,UACvCC,qBAAgB,GAAG,CAAA;AAAA;AAAA,UACnB,MAAA;AAAA;AAAA,UACA;AAAA;AACtB,OACF;AAEA,MAAAM,WAAA,CAAM,qBAAqB,GAAG,CAAA,CAAA,CAAA,EAAK,MAAMT,2BAAA,CAAY,GAAA,KAAQ,KAAK,CAAA;AAAA,IACpE;AAAA,EACF;AAEA,EAAA,OAAOC,WAAA,CAAG,OAAA,CAAQ,qBAAA,CAAsB,IAAI,CAAA;AAC9C;AAEA,SAAS,iBAAA,CAAkB,gBAAgC,GAAA,EAAoB;AAC7E,EAAA,MAAM,SAA0C,EAAC;AACjD,EAAA,KAAA,MAAW,CAAA,IAAK,cAAA,CAAe,UAAA,IAAc,EAAC,EAAG;AAC/C,IAAA,MAAM,QAAA,GAAW,UAAU,CAAA,IAAK,CAAA,CAAE,OAAO,GAAA,CAAI,OAAA,CAAyB,CAAA,CAAE,IAAI,CAAA,GAAK,CAAA;AACjF,IAAA,IAAI,QAAA,IAAY,QAAA,CAAS,EAAA,KAAO,MAAA,EAAQ;AACtC,MAAA,MAAA,CAAO,QAAA,CAAS,IAAI,CAAA,GAAI,QAAA;AAAA,IAC1B;AAAA,EACF;AACA,EAAA,KAAA,MAAW,MAAA,IAAU,CAAC,KAAA,EAAO,KAAA,EAAO,MAAA,EAAQ,UAAU,SAAA,EAAW,MAAA,EAAQ,OAAA,EAAS,OAAO,CAAA,EAAe;AACtG,IAAA,IAAI,EAAE,UAAU,cAAA,CAAA,EAAiB;AAC/B,MAAA;AAAA,IACF;AACA,IAAA,MAAM,cAAA,GAAkB,cAAA,CAAe,MAAM,CAAA,CAAsB,IAAA,GAC/D,GAAA,CAAI,OAAA,CAA0B,cAAA,CAAe,MAAM,CAAA,CAAsB,IAAI,CAAA,GAC5E,eAAe,MAAM,CAAA;AAC1B,IAAA,IAAI,gBAAgB,UAAA,EAAY;AAC9B,MAAA,KAAA,MAAW,CAAA,IAAK,eAAe,UAAA,EAAY;AACzC,QAAA,MAAM,aAAA,GAAgB,UAAU,CAAA,IAAK,CAAA,CAAE,OAAO,GAAA,CAAI,OAAA,CAAyB,CAAA,CAAE,IAAI,CAAA,GAAK,CAAA;AACtF,QAAA,IAAI,aAAA,IAAiB,aAAA,CAAc,EAAA,KAAO,MAAA,EAAQ;AAChD,UAAA,MAAA,CAAO,aAAA,CAAc,IAAI,CAAA,GAAI,aAAA;AAAA,QAC/B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,EAAA,OAAO,MAAA;AACT;;;;"}
\ No newline at end of file
+{"version":3,"file":"paths-object.cjs","sources":["../../src/transform/paths-object.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport ts from \"typescript\";\nimport { addJSDocComment, oapiRef, stringToAST, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, debug, getEntries } from \"../lib/utils.js\";\nimport type {\n  GlobalContext,\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  PathsObject,\n  ReferenceObject,\n} from \"../types.js\";\nimport transformPathItemObject, { type Method } from \"./path-item-object.js\";\n\nconst PATH_PARAM_RE = /\\{[^}]+\\}/g;\n\n/**\n * Transform the PathsObject node (4.8.8)\n * @see https://spec.openapis.org/oas/v3.1.0#operation-object\n */\nexport default function transformPathsObject(pathsObject: PathsObject, ctx: GlobalContext): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [url, pathItemObject] of getEntries(pathsObject, ctx)) {\n    if (!pathItemObject || typeof pathItemObject !== \"object\") {\n      continue;\n    }\n\n    const pathT = performance.now();\n\n    // handle $ref\n    if (\"$ref\" in pathItemObject) {\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n        /* name          */ tsPropertyIndex(url),\n        /* questionToken */ undefined,\n        /* type          */ oapiRef(pathItemObject.$ref),\n      );\n      addJSDocComment(pathItemObject, property);\n      type.push(property);\n    } else {\n      const pathItemType = transformPathItemObject(pathItemObject, {\n        path: createRef([\"paths\", url]),\n        ctx,\n      });\n\n      // pathParamsAsTypes\n      if (ctx.pathParamsAsTypes && url.includes(\"{\")) {\n        const pathParams = extractPathParams(pathItemObject, ctx);\n        const matches = url.match(PATH_PARAM_RE);\n        let rawPath = `\\`${url}\\``;\n        if (matches) {\n          for (const match of matches) {\n            const paramName = match.slice(1, -1);\n            const param = pathParams[paramName];\n            switch (param?.schema?.type) {\n              case \"number\":\n              case \"integer\":\n                rawPath = rawPath.replace(match, \"${number}\");\n                break;\n              case \"boolean\":\n                rawPath = rawPath.replace(match, \"${boolean}\");\n                break;\n              default:\n                rawPath = rawPath.replace(match, \"${string}\");\n                break;\n            }\n          }\n          // note: creating a string template literal’s AST manually is hard!\n          // just pass an arbitrary string to TS\n          const pathType = (stringToAST(rawPath)[0] as any)?.expression;\n          if (pathType) {\n            type.push(\n              ts.factory.createIndexSignature(\n                /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n                /* parameters    */ [\n                  ts.factory.createParameterDeclaration(\n                    /* modifiers      */ undefined,\n                    /* dotDotDotToken */ undefined,\n                    /* name           */ \"path\",\n                    /* questionToken  */ undefined,\n                    /* type           */ pathType,\n                    /* initializer    */ undefined,\n                  ),\n                ],\n                /* type          */ pathItemType,\n              ),\n            );\n            continue;\n          }\n        }\n      }\n\n      type.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n          /* name          */ tsPropertyIndex(url),\n          /* questionToken */ undefined,\n          /* type          */ pathItemType,\n        ),\n      );\n\n      debug(`Transformed path \"${url}\"`, \"ts\", performance.now() - pathT);\n    }\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n\nfunction extractPathParams(pathItemObject: PathItemObject, ctx: GlobalContext) {\n  const params: Record<string, ParameterObject> = {};\n  for (const p of pathItemObject.parameters ?? []) {\n    const resolved = \"$ref\" in p && p.$ref ? ctx.resolve<ParameterObject>(p.$ref) : (p as ParameterObject);\n    if (resolved && resolved.in === \"path\") {\n      params[resolved.name] = resolved;\n    }\n  }\n  for (const method of [\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"] as Method[]) {\n    if (!(method in pathItemObject)) {\n      continue;\n    }\n    const resolvedMethod = (pathItemObject[method] as ReferenceObject).$ref\n      ? ctx.resolve<OperationObject>((pathItemObject[method] as ReferenceObject).$ref)\n      : (pathItemObject[method] as OperationObject);\n    if (resolvedMethod?.parameters) {\n      for (const p of resolvedMethod.parameters) {\n        const resolvedParam = \"$ref\" in p && p.$ref ? ctx.resolve<ParameterObject>(p.$ref) : (p as ParameterObject);\n        if (resolvedParam && resolvedParam.in === \"path\") {\n          params[resolvedParam.name] = resolvedParam;\n        }\n      }\n    }\n  }\n  return params;\n}\n"],"names":["pathItemObject","getEntries","performance","ts","tsModifiers","tsPropertyIndex","oapiRef","addJSDocComment","transformPathItemObject","createRef","stringToAST","debug"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/paths-object.mjs.map b/dist/transform/paths-object.mjs.map
index 15e26683569271a191f182804e3409962118efc4..ecb7f719785e2722044ee8c395a18d4adf595e57 100644
--- a/dist/transform/paths-object.mjs.map
+++ b/dist/transform/paths-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"paths-object.mjs","sources":["../../src/transform/paths-object.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport ts from \"typescript\";\nimport { addJSDocComment, oapiRef, stringToAST, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, debug, getEntries } from \"../lib/utils.js\";\nimport type {\n  GlobalContext,\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  PathsObject,\n  ReferenceObject,\n} from \"../types.js\";\nimport transformPathItemObject, { type Method } from \"./path-item-object.js\";\n\nconst PATH_PARAM_RE = /\\{[^}]+\\}/g;\n\n/**\n * Transform the PathsObject node (4.8.8)\n * @see https://spec.openapis.org/oas/v3.1.0#operation-object\n */\nexport default function transformPathsObject(pathsObject: PathsObject, ctx: GlobalContext): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [url, pathItemObject] of getEntries(pathsObject, ctx)) {\n    if (!pathItemObject || typeof pathItemObject !== \"object\") {\n      continue;\n    }\n\n    const pathT = performance.now();\n\n    // handle $ref\n    if (\"$ref\" in pathItemObject) {\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n        /* name          */ tsPropertyIndex(url),\n        /* questionToken */ undefined,\n        /* type          */ oapiRef(pathItemObject.$ref),\n      );\n      addJSDocComment(pathItemObject, property);\n      type.push(property);\n    } else {\n      const pathItemType = transformPathItemObject(pathItemObject, {\n        path: createRef([\"paths\", url]),\n        ctx,\n      });\n\n      // pathParamsAsTypes\n      if (ctx.pathParamsAsTypes && url.includes(\"{\")) {\n        const pathParams = extractPathParams(pathItemObject, ctx);\n        const matches = url.match(PATH_PARAM_RE);\n        let rawPath = `\\`${url}\\``;\n        if (matches) {\n          for (const match of matches) {\n            const paramName = match.slice(1, -1);\n            const param = pathParams[paramName];\n            switch (param?.schema?.type) {\n              case \"number\":\n              case \"integer\":\n                rawPath = rawPath.replace(match, \"${number}\");\n                break;\n              case \"boolean\":\n                rawPath = rawPath.replace(match, \"${boolean}\");\n                break;\n              default:\n                rawPath = rawPath.replace(match, \"${string}\");\n                break;\n            }\n          }\n          // note: creating a string template literal’s AST manually is hard!\n          // just pass an arbitrary string to TS\n          const pathType = (stringToAST(rawPath)[0] as any)?.expression;\n          if (pathType) {\n            type.push(\n              ts.factory.createIndexSignature(\n                /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n                /* parameters    */ [\n                  ts.factory.createParameterDeclaration(\n                    /* modifiers      */ undefined,\n                    /* dotDotDotToken */ undefined,\n                    /* name           */ \"path\",\n                    /* questionToken  */ undefined,\n                    /* type           */ pathType,\n                    /* initializer    */ undefined,\n                  ),\n                ],\n                /* type          */ pathItemType,\n              ),\n            );\n            continue;\n          }\n        }\n      }\n\n      type.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n          /* name          */ tsPropertyIndex(url),\n          /* questionToken */ undefined,\n          /* type          */ pathItemType,\n        ),\n      );\n\n      debug(`Transformed path \"${url}\"`, \"ts\", performance.now() - pathT);\n    }\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n\nfunction extractPathParams(pathItemObject: PathItemObject, ctx: GlobalContext) {\n  const params: Record<string, ParameterObject> = {};\n  for (const p of pathItemObject.parameters ?? []) {\n    const resolved = \"$ref\" in p && p.$ref ? ctx.resolve<ParameterObject>(p.$ref) : (p as ParameterObject);\n    if (resolved && resolved.in === \"path\") {\n      params[resolved.name] = resolved;\n    }\n  }\n  for (const method of [\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"] as Method[]) {\n    if (!(method in pathItemObject)) {\n      continue;\n    }\n    const resolvedMethod = (pathItemObject[method] as ReferenceObject).$ref\n      ? ctx.resolve<OperationObject>((pathItemObject[method] as ReferenceObject).$ref)\n      : (pathItemObject[method] as OperationObject);\n    if (resolvedMethod?.parameters) {\n      for (const p of resolvedMethod.parameters) {\n        const resolvedParam = \"$ref\" in p && p.$ref ? ctx.resolve<ParameterObject>(p.$ref) : (p as ParameterObject);\n        if (resolvedParam && resolvedParam.in === \"path\") {\n          params[resolvedParam.name] = resolvedParam;\n        }\n      }\n    }\n  }\n  return params;\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"paths-object.mjs","sources":["../../src/transform/paths-object.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport ts from \"typescript\";\nimport { addJSDocComment, oapiRef, stringToAST, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, debug, getEntries } from \"../lib/utils.js\";\nimport type {\n  GlobalContext,\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  PathsObject,\n  ReferenceObject,\n} from \"../types.js\";\nimport transformPathItemObject, { type Method } from \"./path-item-object.js\";\n\nconst PATH_PARAM_RE = /\\{[^}]+\\}/g;\n\n/**\n * Transform the PathsObject node (4.8.8)\n * @see https://spec.openapis.org/oas/v3.1.0#operation-object\n */\nexport default function transformPathsObject(pathsObject: PathsObject, ctx: GlobalContext): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [url, pathItemObject] of getEntries(pathsObject, ctx)) {\n    if (!pathItemObject || typeof pathItemObject !== \"object\") {\n      continue;\n    }\n\n    const pathT = performance.now();\n\n    // handle $ref\n    if (\"$ref\" in pathItemObject) {\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n        /* name          */ tsPropertyIndex(url),\n        /* questionToken */ undefined,\n        /* type          */ oapiRef(pathItemObject.$ref),\n      );\n      addJSDocComment(pathItemObject, property);\n      type.push(property);\n    } else {\n      const pathItemType = transformPathItemObject(pathItemObject, {\n        path: createRef([\"paths\", url]),\n        ctx,\n      });\n\n      // pathParamsAsTypes\n      if (ctx.pathParamsAsTypes && url.includes(\"{\")) {\n        const pathParams = extractPathParams(pathItemObject, ctx);\n        const matches = url.match(PATH_PARAM_RE);\n        let rawPath = `\\`${url}\\``;\n        if (matches) {\n          for (const match of matches) {\n            const paramName = match.slice(1, -1);\n            const param = pathParams[paramName];\n            switch (param?.schema?.type) {\n              case \"number\":\n              case \"integer\":\n                rawPath = rawPath.replace(match, \"${number}\");\n                break;\n              case \"boolean\":\n                rawPath = rawPath.replace(match, \"${boolean}\");\n                break;\n              default:\n                rawPath = rawPath.replace(match, \"${string}\");\n                break;\n            }\n          }\n          // note: creating a string template literal’s AST manually is hard!\n          // just pass an arbitrary string to TS\n          const pathType = (stringToAST(rawPath)[0] as any)?.expression;\n          if (pathType) {\n            type.push(\n              ts.factory.createIndexSignature(\n                /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n                /* parameters    */ [\n                  ts.factory.createParameterDeclaration(\n                    /* modifiers      */ undefined,\n                    /* dotDotDotToken */ undefined,\n                    /* name           */ \"path\",\n                    /* questionToken  */ undefined,\n                    /* type           */ pathType,\n                    /* initializer    */ undefined,\n                  ),\n                ],\n                /* type          */ pathItemType,\n              ),\n            );\n            continue;\n          }\n        }\n      }\n\n      type.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({ readonly: ctx.immutable }),\n          /* name          */ tsPropertyIndex(url),\n          /* questionToken */ undefined,\n          /* type          */ pathItemType,\n        ),\n      );\n\n      debug(`Transformed path \"${url}\"`, \"ts\", performance.now() - pathT);\n    }\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n\nfunction extractPathParams(pathItemObject: PathItemObject, ctx: GlobalContext) {\n  const params: Record<string, ParameterObject> = {};\n  for (const p of pathItemObject.parameters ?? []) {\n    const resolved = \"$ref\" in p && p.$ref ? ctx.resolve<ParameterObject>(p.$ref) : (p as ParameterObject);\n    if (resolved && resolved.in === \"path\") {\n      params[resolved.name] = resolved;\n    }\n  }\n  for (const method of [\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"] as Method[]) {\n    if (!(method in pathItemObject)) {\n      continue;\n    }\n    const resolvedMethod = (pathItemObject[method] as ReferenceObject).$ref\n      ? ctx.resolve<OperationObject>((pathItemObject[method] as ReferenceObject).$ref)\n      : (pathItemObject[method] as OperationObject);\n    if (resolvedMethod?.parameters) {\n      for (const p of resolvedMethod.parameters) {\n        const resolvedParam = \"$ref\" in p && p.$ref ? ctx.resolve<ParameterObject>(p.$ref) : (p as ParameterObject);\n        if (resolvedParam && resolvedParam.in === \"path\") {\n          params[resolvedParam.name] = resolvedParam;\n        }\n      }\n    }\n  }\n  return params;\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/request-body-object.cjs b/dist/transform/request-body-object.cjs
index 16034a1aa6cd15b4f95d2ac76c9282564db42472..75bdd3c9873ca9843c32786afa31dc952d3ba8b4 100644
--- a/dist/transform/request-body-object.cjs
+++ b/dist/transform/request-body-object.cjs
@@ -13,7 +13,7 @@ const ts__default = /*#__PURE__*/_interopDefaultCompat(ts);
 function transformRequestBodyObject(requestBodyObject, options) {
   const type = [];
   for (const [contentType, mediaTypeObject$1] of utils.getEntries(requestBodyObject.content ?? {}, options.ctx)) {
-    const nextPath = utils.createRef([options.path, contentType]);
+    const nextPath = utils.createRef([options.path, "content", contentType]);
     const mediaType = "$ref" in mediaTypeObject$1 ? schemaObject.default(mediaTypeObject$1, {
       ...options,
       path: nextPath
diff --git a/dist/transform/request-body-object.cjs.map b/dist/transform/request-body-object.cjs.map
index 3ccd074a54c8b495d480558c1f547e3475f1b3a3..fcf6ef2df41aa90440b34aa4259a269d0f3b3d7d 100644
--- a/dist/transform/request-body-object.cjs.map
+++ b/dist/transform/request-body-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"request-body-object.cjs","sources":["../../src/transform/request-body-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform RequestBodyObject nodes (4.8.13)\n * @see https://spec.openapis.org/oas/v3.1.0#request-body-object\n */\nexport default function transformRequestBodyObject(\n  requestBodyObject: RequestBodyObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {\n    const nextPath = createRef([options.path, contentType]);\n    const mediaType =\n      \"$ref\" in mediaTypeObject\n        ? transformSchemaObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          })\n        : transformMediaTypeObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(contentType),\n      /* questionToken */ undefined,\n      /* type          */ mediaType,\n    );\n    addJSDocComment(mediaTypeObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode([\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"content\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(\n        type.length\n          ? type\n          : // add `\"*/*\": never` if no media types are defined\n            [\n              ts.factory.createPropertySignature(\n                /* modifiers     */ undefined,\n                /* name          */ tsPropertyIndex(\"*/*\"),\n                /* questionToken */ QUESTION_TOKEN,\n                /* type          */ NEVER,\n              ),\n            ],\n      ),\n    ),\n  ]);\n}\n"],"names":["mediaTypeObject","getEntries","createRef","transformSchemaObject","transformMediaTypeObject","ts","tsModifiers","tsPropertyIndex","addJSDocComment","QUESTION_TOKEN","NEVER"],"mappings":";;;;;;;;;;;;AAWA,SAAwB,0BAAA,CACtB,mBACA,OAAA,EACa;AACb,EAAA,MAAM,OAAyB,EAAC;AAChC,EAAA,KAAA,MAAW,CAAC,WAAA,EAAaA,iBAAe,CAAA,IAAKC,gBAAA,CAAW,iBAAA,CAAkB,OAAA,IAAW,EAAC,EAAG,OAAA,CAAQ,GAAG,CAAA,EAAG;AACrG,IAAA,MAAM,WAAWC,eAAA,CAAU,CAAC,OAAA,CAAQ,IAAA,EAAM,WAAW,CAAC,CAAA;AACtD,IAAA,MAAM,SAAA,GACJ,MAAA,IAAUF,iBAAA,GACNG,oBAAA,CAAsBH,iBAAA,EAAiB;AAAA,MACrC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA,GACDI,eAAA,CAAyBJ,iBAAA,EAAiB;AAAA,MACxC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA;AACP,IAAA,MAAM,QAAA,GAAWK,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACNC,iBAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/CC,qBAAgB,WAAW,CAAA;AAAA;AAAA,MAC3B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAAC,oBAAA,CAAgBR,mBAAiB,QAAQ,CAAA;AACzC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,EACpB;AAEA,EAAA,OAAOK,WAAA,CAAG,QAAQ,qBAAA,CAAsB;AAAA,IACtCA,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACWC,iBAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/CC,qBAAgB,SAAS,CAAA;AAAA;AAAA,MACzB,MAAA;AAAA;AAAA,MACAF,YAAG,OAAA,CAAQ,qBAAA;AAAA,QAC7B,KAAK,MAAA,GACD,IAAA;AAAA;AAAA,UAEA;AAAA,YACEA,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,cACW,MAAA;AAAA;AAAA,cACAE,qBAAgB,KAAK,CAAA;AAAA;AAAA,cACrBE,mBAAA;AAAA;AAAA,cACAC;AAAA;AACtB;AACF;AAAA;AACN;AACF,GACD,CAAA;AACH;;;;"}
\ No newline at end of file
+{"version":3,"file":"request-body-object.cjs","sources":["../../src/transform/request-body-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform RequestBodyObject nodes (4.8.13)\n * @see https://spec.openapis.org/oas/v3.1.0#request-body-object\n */\nexport default function transformRequestBodyObject(\n  requestBodyObject: RequestBodyObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {\n    const nextPath = createRef([options.path, \"content\", contentType]);\n    const mediaType =\n      \"$ref\" in mediaTypeObject\n        ? transformSchemaObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          })\n        : transformMediaTypeObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(contentType),\n      /* questionToken */ undefined,\n      /* type          */ mediaType,\n    );\n    addJSDocComment(mediaTypeObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode([\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"content\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(\n        type.length\n          ? type\n          : // add `\"*/*\": never` if no media types are defined\n            [\n              ts.factory.createPropertySignature(\n                /* modifiers     */ undefined,\n                /* name          */ tsPropertyIndex(\"*/*\"),\n                /* questionToken */ QUESTION_TOKEN,\n                /* type          */ NEVER,\n              ),\n            ],\n      ),\n    ),\n  ]);\n}\n"],"names":["mediaTypeObject","getEntries","createRef","transformSchemaObject","transformMediaTypeObject","ts","tsModifiers","tsPropertyIndex","addJSDocComment","QUESTION_TOKEN","NEVER"],"mappings":";;;;;;;;;;;;AAWwB,SAAA,0BAAA,CACtB,mBACA,OACa,EAAA;AACb,EAAA,MAAM,OAAyB,EAAC;AAChC,EAAW,KAAA,MAAA,CAAC,WAAa,EAAAA,iBAAe,CAAK,IAAAC,gBAAA,CAAW,iBAAkB,CAAA,OAAA,IAAW,EAAC,EAAG,OAAQ,CAAA,GAAG,CAAG,EAAA;AACrG,IAAA,MAAM,WAAWC,eAAU,CAAA,CAAC,QAAQ,IAAM,EAAA,SAAA,EAAW,WAAW,CAAC,CAAA;AACjE,IAAA,MAAM,SACJ,GAAA,MAAA,IAAUF,iBACN,GAAAG,oBAAA,CAAsBH,iBAAiB,EAAA;AAAA,MACrC,GAAG,OAAA;AAAA,MACH,IAAM,EAAA;AAAA,KACP,CACD,GAAAI,eAAA,CAAyBJ,iBAAiB,EAAA;AAAA,MACxC,GAAG,OAAA;AAAA,MACH,IAAM,EAAA;AAAA,KACP,CAAA;AACP,IAAM,MAAA,QAAA,GAAWK,YAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,MACNC,iBAAY,EAAE,QAAA,EAAU,OAAQ,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/CC,qBAAgB,WAAW,CAAA;AAAA;AAAA,MAC3B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAAC,oBAAA,CAAgBR,mBAAiB,QAAQ,CAAA;AACzC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA;AAGpB,EAAO,OAAAK,WAAA,CAAG,QAAQ,qBAAsB,CAAA;AAAA,IACtCA,YAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,MACWC,iBAAY,EAAE,QAAA,EAAU,OAAQ,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/CC,qBAAgB,SAAS,CAAA;AAAA;AAAA,MACzB,MAAA;AAAA;AAAA,MACAF,YAAG,OAAQ,CAAA,qBAAA;AAAA,QAC7B,KAAK,MACD,GAAA,IAAA;AAAA;AAAA,UAEA;AAAA,YACEA,YAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,cACW,MAAA;AAAA;AAAA,cACAE,qBAAgB,KAAK,CAAA;AAAA;AAAA,cACrBE,mBAAA;AAAA;AAAA,cACAC;AAAA;AACtB;AACF;AAAA;AACN;AACF,GACD,CAAA;AACH;;;;"}
\ No newline at end of file
diff --git a/dist/transform/request-body-object.mjs b/dist/transform/request-body-object.mjs
index b076cb1067987aadbe2f12fb1b7b0fd8cd3db670..0f6583f03382c26a842d1b70d93f3ec374d97696 100644
--- a/dist/transform/request-body-object.mjs
+++ b/dist/transform/request-body-object.mjs
@@ -7,7 +7,7 @@ import transformSchemaObject from './schema-object.mjs';
 function transformRequestBodyObject(requestBodyObject, options) {
   const type = [];
   for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {
-    const nextPath = createRef([options.path, contentType]);
+    const nextPath = createRef([options.path, "content", contentType]);
     const mediaType = "$ref" in mediaTypeObject ? transformSchemaObject(mediaTypeObject, {
       ...options,
       path: nextPath
diff --git a/dist/transform/request-body-object.mjs.map b/dist/transform/request-body-object.mjs.map
index 5ad7781c257f8c4bce4ea1d463cbd925bf2f51a2..eadea2f785359016f53a7937333f70dcb5fd26c2 100644
--- a/dist/transform/request-body-object.mjs.map
+++ b/dist/transform/request-body-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"request-body-object.mjs","sources":["../../src/transform/request-body-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform RequestBodyObject nodes (4.8.13)\n * @see https://spec.openapis.org/oas/v3.1.0#request-body-object\n */\nexport default function transformRequestBodyObject(\n  requestBodyObject: RequestBodyObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {\n    const nextPath = createRef([options.path, contentType]);\n    const mediaType =\n      \"$ref\" in mediaTypeObject\n        ? transformSchemaObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          })\n        : transformMediaTypeObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(contentType),\n      /* questionToken */ undefined,\n      /* type          */ mediaType,\n    );\n    addJSDocComment(mediaTypeObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode([\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"content\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(\n        type.length\n          ? type\n          : // add `\"*/*\": never` if no media types are defined\n            [\n              ts.factory.createPropertySignature(\n                /* modifiers     */ undefined,\n                /* name          */ tsPropertyIndex(\"*/*\"),\n                /* questionToken */ QUESTION_TOKEN,\n                /* type          */ NEVER,\n              ),\n            ],\n      ),\n    ),\n  ]);\n}\n"],"names":[],"mappings":";;;;;;AAWA,SAAwB,0BAAA,CACtB,mBACA,OAAA,EACa;AACb,EAAA,MAAM,OAAyB,EAAC;AAChC,EAAA,KAAA,MAAW,CAAC,WAAA,EAAa,eAAe,CAAA,IAAK,UAAA,CAAW,iBAAA,CAAkB,OAAA,IAAW,EAAC,EAAG,OAAA,CAAQ,GAAG,CAAA,EAAG;AACrG,IAAA,MAAM,WAAW,SAAA,CAAU,CAAC,OAAA,CAAQ,IAAA,EAAM,WAAW,CAAC,CAAA;AACtD,IAAA,MAAM,SAAA,GACJ,MAAA,IAAU,eAAA,GACN,qBAAA,CAAsB,eAAA,EAAiB;AAAA,MACrC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA,GACD,wBAAA,CAAyB,eAAA,EAAiB;AAAA,MACxC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA;AACP,IAAA,MAAM,QAAA,GAAW,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACN,YAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/C,gBAAgB,WAAW,CAAA;AAAA;AAAA,MAC3B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAA,eAAA,CAAgB,iBAAiB,QAAQ,CAAA;AACzC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,EACpB;AAEA,EAAA,OAAO,EAAA,CAAG,QAAQ,qBAAA,CAAsB;AAAA,IACtC,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACW,YAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/C,gBAAgB,SAAS,CAAA;AAAA;AAAA,MACzB,MAAA;AAAA;AAAA,MACA,GAAG,OAAA,CAAQ,qBAAA;AAAA,QAC7B,KAAK,MAAA,GACD,IAAA;AAAA;AAAA,UAEA;AAAA,YACE,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,cACW,MAAA;AAAA;AAAA,cACA,gBAAgB,KAAK,CAAA;AAAA;AAAA,cACrB,cAAA;AAAA;AAAA,cACA;AAAA;AACtB;AACF;AAAA;AACN;AACF,GACD,CAAA;AACH;;;;"}
\ No newline at end of file
+{"version":3,"file":"request-body-object.mjs","sources":["../../src/transform/request-body-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform RequestBodyObject nodes (4.8.13)\n * @see https://spec.openapis.org/oas/v3.1.0#request-body-object\n */\nexport default function transformRequestBodyObject(\n  requestBodyObject: RequestBodyObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {\n    const nextPath = createRef([options.path, \"content\", contentType]);\n    const mediaType =\n      \"$ref\" in mediaTypeObject\n        ? transformSchemaObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          })\n        : transformMediaTypeObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(contentType),\n      /* questionToken */ undefined,\n      /* type          */ mediaType,\n    );\n    addJSDocComment(mediaTypeObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode([\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"content\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(\n        type.length\n          ? type\n          : // add `\"*/*\": never` if no media types are defined\n            [\n              ts.factory.createPropertySignature(\n                /* modifiers     */ undefined,\n                /* name          */ tsPropertyIndex(\"*/*\"),\n                /* questionToken */ QUESTION_TOKEN,\n                /* type          */ NEVER,\n              ),\n            ],\n      ),\n    ),\n  ]);\n}\n"],"names":[],"mappings":";;;;;;AAWwB,SAAA,0BAAA,CACtB,mBACA,OACa,EAAA;AACb,EAAA,MAAM,OAAyB,EAAC;AAChC,EAAW,KAAA,MAAA,CAAC,WAAa,EAAA,eAAe,CAAK,IAAA,UAAA,CAAW,iBAAkB,CAAA,OAAA,IAAW,EAAC,EAAG,OAAQ,CAAA,GAAG,CAAG,EAAA;AACrG,IAAA,MAAM,WAAW,SAAU,CAAA,CAAC,QAAQ,IAAM,EAAA,SAAA,EAAW,WAAW,CAAC,CAAA;AACjE,IAAA,MAAM,SACJ,GAAA,MAAA,IAAU,eACN,GAAA,qBAAA,CAAsB,eAAiB,EAAA;AAAA,MACrC,GAAG,OAAA;AAAA,MACH,IAAM,EAAA;AAAA,KACP,CACD,GAAA,wBAAA,CAAyB,eAAiB,EAAA;AAAA,MACxC,GAAG,OAAA;AAAA,MACH,IAAM,EAAA;AAAA,KACP,CAAA;AACP,IAAM,MAAA,QAAA,GAAW,GAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,MACN,YAAY,EAAE,QAAA,EAAU,OAAQ,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/C,gBAAgB,WAAW,CAAA;AAAA;AAAA,MAC3B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAA,eAAA,CAAgB,iBAAiB,QAAQ,CAAA;AACzC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA;AAGpB,EAAO,OAAA,EAAA,CAAG,QAAQ,qBAAsB,CAAA;AAAA,IACtC,GAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,MACW,YAAY,EAAE,QAAA,EAAU,OAAQ,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/C,gBAAgB,SAAS,CAAA;AAAA;AAAA,MACzB,MAAA;AAAA;AAAA,MACA,GAAG,OAAQ,CAAA,qBAAA;AAAA,QAC7B,KAAK,MACD,GAAA,IAAA;AAAA;AAAA,UAEA;AAAA,YACE,GAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,cACW,MAAA;AAAA;AAAA,cACA,gBAAgB,KAAK,CAAA;AAAA;AAAA,cACrB,cAAA;AAAA;AAAA,cACA;AAAA;AACtB;AACF;AAAA;AACN;AACF,GACD,CAAA;AACH;;;;"}
\ No newline at end of file
diff --git a/dist/transform/response-object.cjs.map b/dist/transform/response-object.cjs.map
index 3077d88f3f0f4196d09408126898b9fcedbd4034..84dd39f03c2c1cb8b6a1baa285c1e7d1b4001d1c 100644
--- a/dist/transform/response-object.cjs.map
+++ b/dist/transform/response-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"response-object.cjs","sources":["../../src/transform/response-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport {\n  addJSDocComment,\n  NEVER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsModifiers,\n  tsPropertyIndex,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { ResponseObject, TransformNodeOptions } from \"../types.js\";\nimport transformHeaderObject from \"./header-object.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\n\n/**\n * Transform ResponseObject nodes (4.8.17)\n * @see https://spec.openapis.org/oas/v3.1.0#response-object\n */\nexport default function transformResponseObject(\n  responseObject: ResponseObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  // headers\n  const headersObject: ts.TypeElement[] = [];\n  if (responseObject.headers) {\n    for (const [name, headerObject] of getEntries(responseObject.headers, options.ctx)) {\n      const optional = \"$ref\" in headerObject || headerObject.required ? undefined : QUESTION_TOKEN;\n      const subType =\n        \"$ref\" in headerObject\n          ? oapiRef(headerObject.$ref)\n          : transformHeaderObject(headerObject, {\n              ...options,\n              path: createRef([options.path, \"headers\", name]),\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(name),\n        /* questionToken */ optional,\n        /* type          */ subType,\n      );\n      addJSDocComment(headerObject, property);\n      headersObject.push(property);\n    }\n  }\n  // allow additional unknown headers\n  headersObject.push(\n    ts.factory.createIndexSignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* parameters */ [\n        ts.factory.createParameterDeclaration(\n          /* modifiers      */ undefined,\n          /* dotDotDotToken */ undefined,\n          /* name           */ ts.factory.createIdentifier(\"name\"),\n          /* questionToken  */ undefined,\n          /* type           */ STRING,\n        ),\n      ],\n      /* type          */ UNKNOWN,\n    ),\n  );\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ undefined,\n      /* name          */ tsPropertyIndex(\"headers\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(headersObject),\n    ),\n  );\n\n  // content\n  const contentObject: ts.TypeElement[] = [];\n  if (responseObject.content) {\n    for (const [contentType, mediaTypeObject] of getEntries(responseObject.content ?? {}, options.ctx)) {\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(contentType),\n        /* questionToken */ undefined,\n        /* type          */ transformMediaTypeObject(mediaTypeObject, {\n          ...options,\n          path: createRef([options.path, \"content\", contentType]),\n        }),\n      );\n      addJSDocComment(mediaTypeObject, property);\n      contentObject.push(property);\n    }\n  }\n  if (contentObject.length) {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(\"content\"),\n        /* questionToken */ undefined,\n        /* type          */ ts.factory.createTypeLiteralNode(contentObject),\n      ),\n    );\n  } else {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(\"content\"),\n        /* questionToken */ QUESTION_TOKEN,\n        /* type          */ NEVER,\n      ),\n    );\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n"],"names":["headerObject","getEntries","QUESTION_TOKEN","oapiRef","transformHeaderObject","createRef","ts","tsModifiers","tsPropertyIndex","addJSDocComment","STRING","UNKNOWN","mediaTypeObject","transformMediaTypeObject","NEVER"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"response-object.cjs","sources":["../../src/transform/response-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport {\n  addJSDocComment,\n  NEVER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsModifiers,\n  tsPropertyIndex,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { ResponseObject, TransformNodeOptions } from \"../types.js\";\nimport transformHeaderObject from \"./header-object.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\n\n/**\n * Transform ResponseObject nodes (4.8.17)\n * @see https://spec.openapis.org/oas/v3.1.0#response-object\n */\nexport default function transformResponseObject(\n  responseObject: ResponseObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  // headers\n  const headersObject: ts.TypeElement[] = [];\n  if (responseObject.headers) {\n    for (const [name, headerObject] of getEntries(responseObject.headers, options.ctx)) {\n      const optional = \"$ref\" in headerObject || headerObject.required ? undefined : QUESTION_TOKEN;\n      const subType =\n        \"$ref\" in headerObject\n          ? oapiRef(headerObject.$ref)\n          : transformHeaderObject(headerObject, {\n              ...options,\n              path: createRef([options.path, \"headers\", name]),\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(name),\n        /* questionToken */ optional,\n        /* type          */ subType,\n      );\n      addJSDocComment(headerObject, property);\n      headersObject.push(property);\n    }\n  }\n  // allow additional unknown headers\n  headersObject.push(\n    ts.factory.createIndexSignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* parameters */ [\n        ts.factory.createParameterDeclaration(\n          /* modifiers      */ undefined,\n          /* dotDotDotToken */ undefined,\n          /* name           */ ts.factory.createIdentifier(\"name\"),\n          /* questionToken  */ undefined,\n          /* type           */ STRING,\n        ),\n      ],\n      /* type          */ UNKNOWN,\n    ),\n  );\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ undefined,\n      /* name          */ tsPropertyIndex(\"headers\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(headersObject),\n    ),\n  );\n\n  // content\n  const contentObject: ts.TypeElement[] = [];\n  if (responseObject.content) {\n    for (const [contentType, mediaTypeObject] of getEntries(responseObject.content ?? {}, options.ctx)) {\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(contentType),\n        /* questionToken */ undefined,\n        /* type          */ transformMediaTypeObject(mediaTypeObject, {\n          ...options,\n          path: createRef([options.path, \"content\", contentType]),\n        }),\n      );\n      addJSDocComment(mediaTypeObject, property);\n      contentObject.push(property);\n    }\n  }\n  if (contentObject.length) {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(\"content\"),\n        /* questionToken */ undefined,\n        /* type          */ ts.factory.createTypeLiteralNode(contentObject),\n      ),\n    );\n  } else {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(\"content\"),\n        /* questionToken */ QUESTION_TOKEN,\n        /* type          */ NEVER,\n      ),\n    );\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n"],"names":["headerObject","getEntries","QUESTION_TOKEN","oapiRef","transformHeaderObject","createRef","ts","tsModifiers","tsPropertyIndex","addJSDocComment","STRING","UNKNOWN","mediaTypeObject","transformMediaTypeObject","NEVER"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/response-object.mjs.map b/dist/transform/response-object.mjs.map
index 89505159bd4425da611c52629dae6c630ffb807f..cd975ddab280d3b7c11105fc5f4448030a4a9fdd 100644
--- a/dist/transform/response-object.mjs.map
+++ b/dist/transform/response-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"response-object.mjs","sources":["../../src/transform/response-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport {\n  addJSDocComment,\n  NEVER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsModifiers,\n  tsPropertyIndex,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { ResponseObject, TransformNodeOptions } from \"../types.js\";\nimport transformHeaderObject from \"./header-object.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\n\n/**\n * Transform ResponseObject nodes (4.8.17)\n * @see https://spec.openapis.org/oas/v3.1.0#response-object\n */\nexport default function transformResponseObject(\n  responseObject: ResponseObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  // headers\n  const headersObject: ts.TypeElement[] = [];\n  if (responseObject.headers) {\n    for (const [name, headerObject] of getEntries(responseObject.headers, options.ctx)) {\n      const optional = \"$ref\" in headerObject || headerObject.required ? undefined : QUESTION_TOKEN;\n      const subType =\n        \"$ref\" in headerObject\n          ? oapiRef(headerObject.$ref)\n          : transformHeaderObject(headerObject, {\n              ...options,\n              path: createRef([options.path, \"headers\", name]),\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(name),\n        /* questionToken */ optional,\n        /* type          */ subType,\n      );\n      addJSDocComment(headerObject, property);\n      headersObject.push(property);\n    }\n  }\n  // allow additional unknown headers\n  headersObject.push(\n    ts.factory.createIndexSignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* parameters */ [\n        ts.factory.createParameterDeclaration(\n          /* modifiers      */ undefined,\n          /* dotDotDotToken */ undefined,\n          /* name           */ ts.factory.createIdentifier(\"name\"),\n          /* questionToken  */ undefined,\n          /* type           */ STRING,\n        ),\n      ],\n      /* type          */ UNKNOWN,\n    ),\n  );\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ undefined,\n      /* name          */ tsPropertyIndex(\"headers\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(headersObject),\n    ),\n  );\n\n  // content\n  const contentObject: ts.TypeElement[] = [];\n  if (responseObject.content) {\n    for (const [contentType, mediaTypeObject] of getEntries(responseObject.content ?? {}, options.ctx)) {\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(contentType),\n        /* questionToken */ undefined,\n        /* type          */ transformMediaTypeObject(mediaTypeObject, {\n          ...options,\n          path: createRef([options.path, \"content\", contentType]),\n        }),\n      );\n      addJSDocComment(mediaTypeObject, property);\n      contentObject.push(property);\n    }\n  }\n  if (contentObject.length) {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(\"content\"),\n        /* questionToken */ undefined,\n        /* type          */ ts.factory.createTypeLiteralNode(contentObject),\n      ),\n    );\n  } else {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(\"content\"),\n        /* questionToken */ QUESTION_TOKEN,\n        /* type          */ NEVER,\n      ),\n    );\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"response-object.mjs","sources":["../../src/transform/response-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport {\n  addJSDocComment,\n  NEVER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsModifiers,\n  tsPropertyIndex,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { ResponseObject, TransformNodeOptions } from \"../types.js\";\nimport transformHeaderObject from \"./header-object.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\n\n/**\n * Transform ResponseObject nodes (4.8.17)\n * @see https://spec.openapis.org/oas/v3.1.0#response-object\n */\nexport default function transformResponseObject(\n  responseObject: ResponseObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  // headers\n  const headersObject: ts.TypeElement[] = [];\n  if (responseObject.headers) {\n    for (const [name, headerObject] of getEntries(responseObject.headers, options.ctx)) {\n      const optional = \"$ref\" in headerObject || headerObject.required ? undefined : QUESTION_TOKEN;\n      const subType =\n        \"$ref\" in headerObject\n          ? oapiRef(headerObject.$ref)\n          : transformHeaderObject(headerObject, {\n              ...options,\n              path: createRef([options.path, \"headers\", name]),\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(name),\n        /* questionToken */ optional,\n        /* type          */ subType,\n      );\n      addJSDocComment(headerObject, property);\n      headersObject.push(property);\n    }\n  }\n  // allow additional unknown headers\n  headersObject.push(\n    ts.factory.createIndexSignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* parameters */ [\n        ts.factory.createParameterDeclaration(\n          /* modifiers      */ undefined,\n          /* dotDotDotToken */ undefined,\n          /* name           */ ts.factory.createIdentifier(\"name\"),\n          /* questionToken  */ undefined,\n          /* type           */ STRING,\n        ),\n      ],\n      /* type          */ UNKNOWN,\n    ),\n  );\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ undefined,\n      /* name          */ tsPropertyIndex(\"headers\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(headersObject),\n    ),\n  );\n\n  // content\n  const contentObject: ts.TypeElement[] = [];\n  if (responseObject.content) {\n    for (const [contentType, mediaTypeObject] of getEntries(responseObject.content ?? {}, options.ctx)) {\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(contentType),\n        /* questionToken */ undefined,\n        /* type          */ transformMediaTypeObject(mediaTypeObject, {\n          ...options,\n          path: createRef([options.path, \"content\", contentType]),\n        }),\n      );\n      addJSDocComment(mediaTypeObject, property);\n      contentObject.push(property);\n    }\n  }\n  if (contentObject.length) {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(\"content\"),\n        /* questionToken */ undefined,\n        /* type          */ ts.factory.createTypeLiteralNode(contentObject),\n      ),\n    );\n  } else {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ undefined,\n        /* name          */ tsPropertyIndex(\"content\"),\n        /* questionToken */ QUESTION_TOKEN,\n        /* type          */ NEVER,\n      ),\n    );\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/responses-object.cjs.map b/dist/transform/responses-object.cjs.map
index e954f4070c7263914b4a8744361d2306e9ed9f70..282443342337abf451ec13e32887dfb283a35a5c 100644
--- a/dist/transform/responses-object.cjs.map
+++ b/dist/transform/responses-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"responses-object.cjs","sources":["../../src/transform/responses-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { ResponsesObject, TransformNodeOptions } from \"../types.js\";\nimport transformResponseObject from \"./response-object.js\";\n\n/**\n * Transform ResponsesObject nodes (4.8.16)\n * @see https://spec.openapis.org/oas/v3.1.0#responses-object\n */\nexport default function transformResponsesObject(\n  responsesObject: ResponsesObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  for (const [responseCode, responseObject] of getEntries(responsesObject, options.ctx)) {\n    const responseType =\n      \"$ref\" in responseObject\n        ? oapiRef(responseObject.$ref)\n        : transformResponseObject(responseObject, {\n            ...options,\n            path: createRef([options.path, \"responses\", responseCode]),\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(responseCode),\n      /* questionToken */ undefined,\n      /* type          */ responseType,\n    );\n    addJSDocComment(responseObject, property);\n    type.push(property);\n  }\n\n  return type.length ? ts.factory.createTypeLiteralNode(type) : NEVER;\n}\n"],"names":["responseObject","getEntries","oapiRef","transformResponseObject","createRef","ts","tsModifiers","tsPropertyIndex","addJSDocComment","NEVER"],"mappings":";;;;;;;;;;;AAUA,SAAwB,wBAAA,CACtB,iBACA,OAAA,EACa;AACb,EAAA,MAAM,OAAyB,EAAC;AAEhC,EAAA,KAAA,MAAW,CAAC,cAAcA,gBAAc,CAAA,IAAKC,iBAAW,eAAA,EAAiB,OAAA,CAAQ,GAAG,CAAA,EAAG;AACrF,IAAA,MAAM,YAAA,GACJ,UAAUD,gBAAA,GACNE,UAAA,CAAQF,iBAAe,IAAI,CAAA,GAC3BG,eAAwBH,gBAAA,EAAgB;AAAA,MACtC,GAAG,OAAA;AAAA,MACH,MAAMI,eAAA,CAAU,CAAC,QAAQ,IAAA,EAAM,WAAA,EAAa,YAAY,CAAC;AAAA,KAC1D,CAAA;AACP,IAAA,MAAM,QAAA,GAAWC,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACNC,eAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/CC,mBAAgB,YAAY,CAAA;AAAA;AAAA,MAC5B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAAC,kBAAA,CAAgBR,kBAAgB,QAAQ,CAAA;AACxC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,EACpB;AAEA,EAAA,OAAO,KAAK,MAAA,GAASK,WAAA,CAAG,OAAA,CAAQ,qBAAA,CAAsB,IAAI,CAAA,GAAII,QAAA;AAChE;;;;"}
\ No newline at end of file
+{"version":3,"file":"responses-object.cjs","sources":["../../src/transform/responses-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { ResponsesObject, TransformNodeOptions } from \"../types.js\";\nimport transformResponseObject from \"./response-object.js\";\n\n/**\n * Transform ResponsesObject nodes (4.8.16)\n * @see https://spec.openapis.org/oas/v3.1.0#responses-object\n */\nexport default function transformResponsesObject(\n  responsesObject: ResponsesObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  for (const [responseCode, responseObject] of getEntries(responsesObject, options.ctx)) {\n    const responseType =\n      \"$ref\" in responseObject\n        ? oapiRef(responseObject.$ref)\n        : transformResponseObject(responseObject, {\n            ...options,\n            path: createRef([options.path, \"responses\", responseCode]),\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(responseCode),\n      /* questionToken */ undefined,\n      /* type          */ responseType,\n    );\n    addJSDocComment(responseObject, property);\n    type.push(property);\n  }\n\n  return type.length ? ts.factory.createTypeLiteralNode(type) : NEVER;\n}\n"],"names":["responseObject","getEntries","oapiRef","transformResponseObject","createRef","ts","tsModifiers","tsPropertyIndex","addJSDocComment","NEVER"],"mappings":";;;;;;;;;;;AAUwB,SAAA,wBAAA,CACtB,iBACA,OACa,EAAA;AACb,EAAA,MAAM,OAAyB,EAAC;AAEhC,EAAW,KAAA,MAAA,CAAC,cAAcA,gBAAc,CAAA,IAAKC,iBAAW,eAAiB,EAAA,OAAA,CAAQ,GAAG,CAAG,EAAA;AACrF,IAAM,MAAA,YAAA,GACJ,UAAUD,gBACN,GAAAE,UAAA,CAAQF,iBAAe,IAAI,CAAA,GAC3BG,eAAwBH,gBAAgB,EAAA;AAAA,MACtC,GAAG,OAAA;AAAA,MACH,MAAMI,eAAU,CAAA,CAAC,QAAQ,IAAM,EAAA,WAAA,EAAa,YAAY,CAAC;AAAA,KAC1D,CAAA;AACP,IAAM,MAAA,QAAA,GAAWC,YAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,MACNC,eAAY,EAAE,QAAA,EAAU,OAAQ,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/CC,mBAAgB,YAAY,CAAA;AAAA;AAAA,MAC5B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAAC,kBAAA,CAAgBR,kBAAgB,QAAQ,CAAA;AACxC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA;AAGpB,EAAA,OAAO,KAAK,MAAS,GAAAK,WAAA,CAAG,OAAQ,CAAA,qBAAA,CAAsB,IAAI,CAAI,GAAAI,QAAA;AAChE;;;;"}
\ No newline at end of file
diff --git a/dist/transform/responses-object.mjs.map b/dist/transform/responses-object.mjs.map
index 9b40438a8056341dd4ec478ec69423bc9384b4e7..a958eb5a3c5849c5ede6a201df263eabbf5d7565 100644
--- a/dist/transform/responses-object.mjs.map
+++ b/dist/transform/responses-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"responses-object.mjs","sources":["../../src/transform/responses-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { ResponsesObject, TransformNodeOptions } from \"../types.js\";\nimport transformResponseObject from \"./response-object.js\";\n\n/**\n * Transform ResponsesObject nodes (4.8.16)\n * @see https://spec.openapis.org/oas/v3.1.0#responses-object\n */\nexport default function transformResponsesObject(\n  responsesObject: ResponsesObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  for (const [responseCode, responseObject] of getEntries(responsesObject, options.ctx)) {\n    const responseType =\n      \"$ref\" in responseObject\n        ? oapiRef(responseObject.$ref)\n        : transformResponseObject(responseObject, {\n            ...options,\n            path: createRef([options.path, \"responses\", responseCode]),\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(responseCode),\n      /* questionToken */ undefined,\n      /* type          */ responseType,\n    );\n    addJSDocComment(responseObject, property);\n    type.push(property);\n  }\n\n  return type.length ? ts.factory.createTypeLiteralNode(type) : NEVER;\n}\n"],"names":[],"mappings":";;;;;AAUA,SAAwB,wBAAA,CACtB,iBACA,OAAA,EACa;AACb,EAAA,MAAM,OAAyB,EAAC;AAEhC,EAAA,KAAA,MAAW,CAAC,cAAc,cAAc,CAAA,IAAK,WAAW,eAAA,EAAiB,OAAA,CAAQ,GAAG,CAAA,EAAG;AACrF,IAAA,MAAM,YAAA,GACJ,UAAU,cAAA,GACN,OAAA,CAAQ,eAAe,IAAI,CAAA,GAC3B,wBAAwB,cAAA,EAAgB;AAAA,MACtC,GAAG,OAAA;AAAA,MACH,MAAM,SAAA,CAAU,CAAC,QAAQ,IAAA,EAAM,WAAA,EAAa,YAAY,CAAC;AAAA,KAC1D,CAAA;AACP,IAAA,MAAM,QAAA,GAAW,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACN,YAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/C,gBAAgB,YAAY,CAAA;AAAA;AAAA,MAC5B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAA,eAAA,CAAgB,gBAAgB,QAAQ,CAAA;AACxC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,EACpB;AAEA,EAAA,OAAO,KAAK,MAAA,GAAS,EAAA,CAAG,OAAA,CAAQ,qBAAA,CAAsB,IAAI,CAAA,GAAI,KAAA;AAChE;;;;"}
\ No newline at end of file
+{"version":3,"file":"responses-object.mjs","sources":["../../src/transform/responses-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { ResponsesObject, TransformNodeOptions } from \"../types.js\";\nimport transformResponseObject from \"./response-object.js\";\n\n/**\n * Transform ResponsesObject nodes (4.8.16)\n * @see https://spec.openapis.org/oas/v3.1.0#responses-object\n */\nexport default function transformResponsesObject(\n  responsesObject: ResponsesObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  for (const [responseCode, responseObject] of getEntries(responsesObject, options.ctx)) {\n    const responseType =\n      \"$ref\" in responseObject\n        ? oapiRef(responseObject.$ref)\n        : transformResponseObject(responseObject, {\n            ...options,\n            path: createRef([options.path, \"responses\", responseCode]),\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(responseCode),\n      /* questionToken */ undefined,\n      /* type          */ responseType,\n    );\n    addJSDocComment(responseObject, property);\n    type.push(property);\n  }\n\n  return type.length ? ts.factory.createTypeLiteralNode(type) : NEVER;\n}\n"],"names":[],"mappings":";;;;;AAUwB,SAAA,wBAAA,CACtB,iBACA,OACa,EAAA;AACb,EAAA,MAAM,OAAyB,EAAC;AAEhC,EAAW,KAAA,MAAA,CAAC,cAAc,cAAc,CAAA,IAAK,WAAW,eAAiB,EAAA,OAAA,CAAQ,GAAG,CAAG,EAAA;AACrF,IAAM,MAAA,YAAA,GACJ,UAAU,cACN,GAAA,OAAA,CAAQ,eAAe,IAAI,CAAA,GAC3B,wBAAwB,cAAgB,EAAA;AAAA,MACtC,GAAG,OAAA;AAAA,MACH,MAAM,SAAU,CAAA,CAAC,QAAQ,IAAM,EAAA,WAAA,EAAa,YAAY,CAAC;AAAA,KAC1D,CAAA;AACP,IAAM,MAAA,QAAA,GAAW,GAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,MACN,YAAY,EAAE,QAAA,EAAU,OAAQ,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/C,gBAAgB,YAAY,CAAA;AAAA;AAAA,MAC5B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAA,eAAA,CAAgB,gBAAgB,QAAQ,CAAA;AACxC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA;AAGpB,EAAA,OAAO,KAAK,MAAS,GAAA,EAAA,CAAG,OAAQ,CAAA,qBAAA,CAAsB,IAAI,CAAI,GAAA,KAAA;AAChE;;;;"}
\ No newline at end of file
diff --git a/dist/transform/schema-object.cjs b/dist/transform/schema-object.cjs
index 862ee9d753202fe920065df98af815258b217f4e..c89d1b266d1551fedf8c0c1b30fa81174365057e 100644
--- a/dist/transform/schema-object.cjs
+++ b/dist/transform/schema-object.cjs
@@ -11,8 +11,8 @@ function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'defau
 
 const ts__default = /*#__PURE__*/_interopDefaultCompat(ts$1);
 
-function transformSchemaObject(schemaObject, options) {
-  const type = transformSchemaObjectWithComposition(schemaObject, options);
+function transformSchemaObject(schemaObject, options, fromAdditionalProperties = false) {
+  const type = transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties);
   if (typeof options.ctx.postTransform === "function") {
     const postTransformResult = options.ctx.postTransform(type, options);
     if (postTransformResult) {
@@ -21,7 +21,7 @@ function transformSchemaObject(schemaObject, options) {
   }
   return type;
 }
-function transformSchemaObjectWithComposition(schemaObject, options) {
+function transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties = false) {
   if (!schemaObject) {
     return ts.NEVER;
   }
@@ -72,12 +72,30 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     }
     const unionType = ts.tsUnion(enumType);
     if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number")) {
-      let enumValuesVariableName = refUtils_js.parseRef(options.path ?? "").pointer.join("/");
+      const parsed = refUtils_js.parseRef(options.path ?? "");
+      let enumValuesVariableName = parsed.pointer.join("/");
       enumValuesVariableName = enumValuesVariableName.replace("components/schemas", "");
       enumValuesVariableName = `${enumValuesVariableName}Values`;
+      const cleanedPointer = [];
+      for (let i = 0; i < parsed.pointer.length; i++) {
+        const segment = parsed.pointer[i];
+        if ((segment === "anyOf" || segment === "oneOf") && i < parsed.pointer.length - 1) {
+          const next = parsed.pointer[i + 1];
+          if (/^\d+$/.test(next)) {
+            i++;
+            continue;
+          }
+        }
+        cleanedPointer.push(segment);
+      }
+      const cleanedRefPath = utils.createRef(cleanedPointer);
       const enumValuesArray = ts.tsArrayLiteralExpression(
         enumValuesVariableName,
-        ts.oapiRef(options.path ?? ""),
+        // If fromAdditionalProperties is true we are dealing with a record type and we should append [string] to the generated type
+        fromAdditionalProperties ? ts__default.factory.createIndexedAccessTypeNode(
+          ts.oapiRef(cleanedRefPath, void 0, true),
+          ts__default.factory.createTypeReferenceNode(ts__default.factory.createIdentifier("string"))
+        ) : ts.oapiRef(cleanedRefPath, void 0, true),
         schemaObject.enum,
         {
           export: true,
@@ -89,10 +107,16 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     }
     return unionType;
   }
-  function collectUnionCompositions(items) {
+  function collectUnionCompositions(items, unionKey) {
     const output = [];
-    for (const item of items) {
-      output.push(transformSchemaObject(item, options));
+    for (const [index, item] of items.entries()) {
+      output.push(
+        transformSchemaObject(item, {
+          ...options,
+          // include index in path so generated names from nested enums/enumValues are unique
+          path: utils.createRef([options.path, unionKey, String(index)])
+        })
+      );
     }
     return output;
   }
@@ -117,12 +141,7 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
         }
         itemType = transformSchemaObject({ ...item, required: itemRequired }, options);
       }
-      const discriminator = "$ref" in item && options.ctx.discriminators.objects[item.$ref] || item.discriminator;
-      if (discriminator) {
-        output.push(ts.tsOmit(itemType, [discriminator.propertyName]));
-      } else {
-        output.push(itemType);
-      }
+      output.push(itemType);
     }
     return output;
   }
@@ -133,12 +152,13 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     const allOf = allOfType.length ? ts.tsIntersection(allOfType) : void 0;
     finalType = ts.tsIntersection([...coreObjectType ? [coreObjectType] : [], ...allOf ? [allOf] : []]);
   }
-  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);
+  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? [], "anyOf");
   if (anyOfType.length) {
     finalType = ts.tsUnion([...finalType ? [finalType] : [], ...anyOfType]);
   }
   const oneOfType = collectUnionCompositions(
-    schemaObject.oneOf || "type" in schemaObject && schemaObject.type === "object" && schemaObject.enum || []
+    schemaObject.oneOf || "type" in schemaObject && schemaObject.type === "object" && schemaObject.enum || [],
+    "oneOf"
   );
   if (oneOfType.length) {
     if (oneOfType.every(ts.tsIsPrimitive)) {
@@ -382,7 +402,7 @@ function transformSchemaObjectCore(schemaObject, options) {
     const hasExplicitPatternProperties = typeof schemaObject.patternProperties === "object" && Object.keys(schemaObject.patternProperties).length;
     const stringIndexTypes = [];
     if (hasExplicitAdditionalProperties) {
-      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties, options));
+      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties, options, true));
     }
     if (hasImplicitAdditionalProperties || !schemaObject.additionalProperties && options.ctx.additionalProperties) {
       stringIndexTypes.push(ts.UNKNOWN);
diff --git a/dist/transform/schema-object.cjs.map b/dist/transform/schema-object.cjs.map
index cbabe4f51233f50aa4d0ff2ca722fc846fbb9dda..ee72088920bbee9368c43f3cca1562680953fd38 100644
--- a/dist/transform/schema-object.cjs.map
+++ b/dist/transform/schema-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"schema-object.cjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  addJSDocComment,\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n  UNDEFINED,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"patternProperties\" in schemaObject && schemaObject.patternProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        let property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        let property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties / patternProperties\n    const hasExplicitAdditionalProperties =\n      typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n    const hasImplicitAdditionalProperties =\n      schemaObject.additionalProperties === true ||\n      (typeof schemaObject.additionalProperties === \"object\" &&\n        Object.keys(schemaObject.additionalProperties).length === 0);\n    const hasExplicitPatternProperties =\n      typeof schemaObject.patternProperties === \"object\" && Object.keys(schemaObject.patternProperties).length;\n    const stringIndexTypes = [];\n    if (hasExplicitAdditionalProperties) {\n      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options));\n    }\n    if (hasImplicitAdditionalProperties || (!schemaObject.additionalProperties && options.ctx.additionalProperties)) {\n      stringIndexTypes.push(UNKNOWN);\n    }\n    if (hasExplicitPatternProperties) {\n      for (const [_, v] of getEntries(schemaObject.patternProperties ?? {}, options.ctx)) {\n        stringIndexTypes.push(transformSchemaObject(v, options));\n      }\n    }\n\n    if (stringIndexTypes.length === 0) {\n      return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n    }\n\n    const stringIndexType = tsUnion(stringIndexTypes);\n\n    return tsIntersection([\n      ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n      ts.factory.createTypeLiteralNode([\n        ts.factory.createIndexSignature(\n          /* modifiers  */ tsModifiers({\n            readonly: options.ctx.immutable,\n          }),\n          /* parameters */ [\n            ts.factory.createParameterDeclaration(\n              /* modifiers      */ undefined,\n              /* dotDotDotToken */ undefined,\n              /* name           */ ts.factory.createIdentifier(\"key\"),\n              /* questionToken  */ undefined,\n              /* type           */ STRING,\n            ),\n          ],\n          /* type       */ stringIndexType,\n        ),\n      ]),\n    ]);\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["NEVER","UNKNOWN","oapiRef","tsLiteral","parseRef","enumType","tsEnum","ts","tsUnion","NULL","tsArrayLiteralExpression","tsWithRequired","tsOmit","tsIntersection","tsIsPrimitive","tsRecord","STRING","tsNullable","UNDEFINED","NUMBER","BOOLEAN","createDiscriminatorProperty","getEntries","QUESTION_TOKEN","createRef","tsModifiers","tsPropertyIndex","addJSDocComment"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"schema-object.cjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  addJSDocComment,\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n  UNDEFINED,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n  fromAdditionalProperties = false,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n  fromAdditionalProperties = false,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      const parsed = parseRef(options.path ?? \"\");\n      let enumValuesVariableName = parsed.pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      // build a ref path for the type that ignores union indices (anyOf/oneOf) so\n      // type references remain stable even when names include union positions\n      const cleanedPointer: string[] = [];\n      for (let i = 0; i < parsed.pointer.length; i++) {\n        // Example: #/paths/analytics/data/get/responses/400/content/application/json/anyOf/0/message\n        const segment = parsed.pointer[i];\n        if ((segment === \"anyOf\" || segment === \"oneOf\") && i < parsed.pointer.length - 1) {\n          const next = parsed.pointer[i + 1];\n          if (/^\\d+$/.test(next)) {\n            // If we encounter something like \"anyOf/0\", we want to skip that part of the path\n            i++;\n            continue;\n          }\n        }\n        cleanedPointer.push(segment);\n      }\n      const cleanedRefPath = createRef(cleanedPointer);\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        // If fromAdditionalProperties is true we are dealing with a record type and we should append [string] to the generated type\n        fromAdditionalProperties\n          ? ts.factory.createIndexedAccessTypeNode(\n              oapiRef(cleanedRefPath, undefined, true),\n              ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"string\")),\n            )\n          : oapiRef(cleanedRefPath, undefined, true),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[], unionKey: \"anyOf\" | \"oneOf\") {\n    const output: ts.TypeNode[] = [];\n    for (const [index, item] of items.entries()) {\n      output.push(\n        transformSchemaObject(item, {\n          ...options,\n          // include index in path so generated names from nested enums/enumValues are unique\n          path: createRef([options.path, unionKey, String(index)]),\n        }),\n      );\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      output.push(itemType);\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? [], \"anyOf\");\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n    \"oneOf\",\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"patternProperties\" in schemaObject && schemaObject.patternProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        let property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        let property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties / patternProperties\n    const hasExplicitAdditionalProperties =\n      typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n    const hasImplicitAdditionalProperties =\n      schemaObject.additionalProperties === true ||\n      (typeof schemaObject.additionalProperties === \"object\" &&\n        Object.keys(schemaObject.additionalProperties).length === 0);\n    const hasExplicitPatternProperties =\n      typeof schemaObject.patternProperties === \"object\" && Object.keys(schemaObject.patternProperties).length;\n    const stringIndexTypes = [];\n    if (hasExplicitAdditionalProperties) {\n      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options, true));\n    }\n    if (hasImplicitAdditionalProperties || (!schemaObject.additionalProperties && options.ctx.additionalProperties)) {\n      stringIndexTypes.push(UNKNOWN);\n    }\n    if (hasExplicitPatternProperties) {\n      for (const [_, v] of getEntries(schemaObject.patternProperties ?? {}, options.ctx)) {\n        stringIndexTypes.push(transformSchemaObject(v, options));\n      }\n    }\n\n    if (stringIndexTypes.length === 0) {\n      return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n    }\n\n    const stringIndexType = tsUnion(stringIndexTypes);\n\n    return tsIntersection([\n      ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n      ts.factory.createTypeLiteralNode([\n        ts.factory.createIndexSignature(\n          /* modifiers  */ tsModifiers({\n            readonly: options.ctx.immutable,\n          }),\n          /* parameters */ [\n            ts.factory.createParameterDeclaration(\n              /* modifiers      */ undefined,\n              /* dotDotDotToken */ undefined,\n              /* name           */ ts.factory.createIdentifier(\"key\"),\n              /* questionToken  */ undefined,\n              /* type           */ STRING,\n            ),\n          ],\n          /* type       */ stringIndexType,\n        ),\n      ]),\n    ]);\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["NEVER","UNKNOWN","oapiRef","tsLiteral","parseRef","enumType","tsEnum","ts","tsUnion","NULL","createRef","tsArrayLiteralExpression","tsWithRequired","tsIntersection","tsIsPrimitive","tsRecord","STRING","tsNullable","UNDEFINED","NUMBER","BOOLEAN","createDiscriminatorProperty","getEntries","QUESTION_TOKEN","tsModifiers","tsPropertyIndex","addJSDocComment"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/schema-object.mjs b/dist/transform/schema-object.mjs
index f13ebbad3bee4844d1fb5e9c1563e6fb7a21610d..508c4ea8fd8255c438508550493eadc0377c90d5 100644
--- a/dist/transform/schema-object.mjs
+++ b/dist/transform/schema-object.mjs
@@ -1,10 +1,10 @@
 import { parseRef } from '@redocly/openapi-core/lib/ref-utils.js';
 import ts from 'typescript';
-import { NEVER, UNKNOWN, oapiRef, tsLiteral, tsEnum, tsUnion, NULL, tsArrayLiteralExpression, tsIntersection, tsIsPrimitive, tsRecord, STRING, tsNullable, UNDEFINED, NUMBER, BOOLEAN, QUESTION_TOKEN, tsModifiers, tsPropertyIndex, addJSDocComment, tsWithRequired, tsOmit } from '../lib/ts.mjs';
-import { createDiscriminatorProperty, getEntries, createRef } from '../lib/utils.mjs';
+import { NEVER, UNKNOWN, oapiRef, tsLiteral, tsEnum, tsUnion, NULL, tsArrayLiteralExpression, tsIntersection, tsIsPrimitive, tsRecord, STRING, tsNullable, UNDEFINED, NUMBER, BOOLEAN, QUESTION_TOKEN, tsModifiers, tsPropertyIndex, addJSDocComment, tsWithRequired } from '../lib/ts.mjs';
+import { createRef, createDiscriminatorProperty, getEntries } from '../lib/utils.mjs';
 
-function transformSchemaObject(schemaObject, options) {
-  const type = transformSchemaObjectWithComposition(schemaObject, options);
+function transformSchemaObject(schemaObject, options, fromAdditionalProperties = false) {
+  const type = transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties);
   if (typeof options.ctx.postTransform === "function") {
     const postTransformResult = options.ctx.postTransform(type, options);
     if (postTransformResult) {
@@ -13,7 +13,7 @@ function transformSchemaObject(schemaObject, options) {
   }
   return type;
 }
-function transformSchemaObjectWithComposition(schemaObject, options) {
+function transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties = false) {
   if (!schemaObject) {
     return NEVER;
   }
@@ -64,12 +64,30 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     }
     const unionType = tsUnion(enumType);
     if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number")) {
-      let enumValuesVariableName = parseRef(options.path ?? "").pointer.join("/");
+      const parsed = parseRef(options.path ?? "");
+      let enumValuesVariableName = parsed.pointer.join("/");
       enumValuesVariableName = enumValuesVariableName.replace("components/schemas", "");
       enumValuesVariableName = `${enumValuesVariableName}Values`;
+      const cleanedPointer = [];
+      for (let i = 0; i < parsed.pointer.length; i++) {
+        const segment = parsed.pointer[i];
+        if ((segment === "anyOf" || segment === "oneOf") && i < parsed.pointer.length - 1) {
+          const next = parsed.pointer[i + 1];
+          if (/^\d+$/.test(next)) {
+            i++;
+            continue;
+          }
+        }
+        cleanedPointer.push(segment);
+      }
+      const cleanedRefPath = createRef(cleanedPointer);
       const enumValuesArray = tsArrayLiteralExpression(
         enumValuesVariableName,
-        oapiRef(options.path ?? ""),
+        // If fromAdditionalProperties is true we are dealing with a record type and we should append [string] to the generated type
+        fromAdditionalProperties ? ts.factory.createIndexedAccessTypeNode(
+          oapiRef(cleanedRefPath, void 0, true),
+          ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("string"))
+        ) : oapiRef(cleanedRefPath, void 0, true),
         schemaObject.enum,
         {
           export: true,
@@ -81,10 +99,16 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     }
     return unionType;
   }
-  function collectUnionCompositions(items) {
+  function collectUnionCompositions(items, unionKey) {
     const output = [];
-    for (const item of items) {
-      output.push(transformSchemaObject(item, options));
+    for (const [index, item] of items.entries()) {
+      output.push(
+        transformSchemaObject(item, {
+          ...options,
+          // include index in path so generated names from nested enums/enumValues are unique
+          path: createRef([options.path, unionKey, String(index)])
+        })
+      );
     }
     return output;
   }
@@ -109,12 +133,7 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
         }
         itemType = transformSchemaObject({ ...item, required: itemRequired }, options);
       }
-      const discriminator = "$ref" in item && options.ctx.discriminators.objects[item.$ref] || item.discriminator;
-      if (discriminator) {
-        output.push(tsOmit(itemType, [discriminator.propertyName]));
-      } else {
-        output.push(itemType);
-      }
+      output.push(itemType);
     }
     return output;
   }
@@ -125,12 +144,13 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     const allOf = allOfType.length ? tsIntersection(allOfType) : void 0;
     finalType = tsIntersection([...coreObjectType ? [coreObjectType] : [], ...allOf ? [allOf] : []]);
   }
-  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);
+  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? [], "anyOf");
   if (anyOfType.length) {
     finalType = tsUnion([...finalType ? [finalType] : [], ...anyOfType]);
   }
   const oneOfType = collectUnionCompositions(
-    schemaObject.oneOf || "type" in schemaObject && schemaObject.type === "object" && schemaObject.enum || []
+    schemaObject.oneOf || "type" in schemaObject && schemaObject.type === "object" && schemaObject.enum || [],
+    "oneOf"
   );
   if (oneOfType.length) {
     if (oneOfType.every(tsIsPrimitive)) {
@@ -374,7 +394,7 @@ function transformSchemaObjectCore(schemaObject, options) {
     const hasExplicitPatternProperties = typeof schemaObject.patternProperties === "object" && Object.keys(schemaObject.patternProperties).length;
     const stringIndexTypes = [];
     if (hasExplicitAdditionalProperties) {
-      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties, options));
+      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties, options, true));
     }
     if (hasImplicitAdditionalProperties || !schemaObject.additionalProperties && options.ctx.additionalProperties) {
       stringIndexTypes.push(UNKNOWN);
diff --git a/dist/transform/schema-object.mjs.map b/dist/transform/schema-object.mjs.map
index 3d87a1c0c7eccce598985d3815eeb89919b7398d..8f2555b229e22b61f971ccacadda303beedff16d 100644
--- a/dist/transform/schema-object.mjs.map
+++ b/dist/transform/schema-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"schema-object.mjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  addJSDocComment,\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n  UNDEFINED,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"patternProperties\" in schemaObject && schemaObject.patternProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        let property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        let property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties / patternProperties\n    const hasExplicitAdditionalProperties =\n      typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n    const hasImplicitAdditionalProperties =\n      schemaObject.additionalProperties === true ||\n      (typeof schemaObject.additionalProperties === \"object\" &&\n        Object.keys(schemaObject.additionalProperties).length === 0);\n    const hasExplicitPatternProperties =\n      typeof schemaObject.patternProperties === \"object\" && Object.keys(schemaObject.patternProperties).length;\n    const stringIndexTypes = [];\n    if (hasExplicitAdditionalProperties) {\n      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options));\n    }\n    if (hasImplicitAdditionalProperties || (!schemaObject.additionalProperties && options.ctx.additionalProperties)) {\n      stringIndexTypes.push(UNKNOWN);\n    }\n    if (hasExplicitPatternProperties) {\n      for (const [_, v] of getEntries(schemaObject.patternProperties ?? {}, options.ctx)) {\n        stringIndexTypes.push(transformSchemaObject(v, options));\n      }\n    }\n\n    if (stringIndexTypes.length === 0) {\n      return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n    }\n\n    const stringIndexType = tsUnion(stringIndexTypes);\n\n    return tsIntersection([\n      ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n      ts.factory.createTypeLiteralNode([\n        ts.factory.createIndexSignature(\n          /* modifiers  */ tsModifiers({\n            readonly: options.ctx.immutable,\n          }),\n          /* parameters */ [\n            ts.factory.createParameterDeclaration(\n              /* modifiers      */ undefined,\n              /* dotDotDotToken */ undefined,\n              /* name           */ ts.factory.createIdentifier(\"key\"),\n              /* questionToken  */ undefined,\n              /* type           */ STRING,\n            ),\n          ],\n          /* type       */ stringIndexType,\n        ),\n      ]),\n    ]);\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["enumType"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"schema-object.mjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  addJSDocComment,\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n  UNDEFINED,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n  fromAdditionalProperties = false,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n  fromAdditionalProperties = false,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      const parsed = parseRef(options.path ?? \"\");\n      let enumValuesVariableName = parsed.pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      // build a ref path for the type that ignores union indices (anyOf/oneOf) so\n      // type references remain stable even when names include union positions\n      const cleanedPointer: string[] = [];\n      for (let i = 0; i < parsed.pointer.length; i++) {\n        // Example: #/paths/analytics/data/get/responses/400/content/application/json/anyOf/0/message\n        const segment = parsed.pointer[i];\n        if ((segment === \"anyOf\" || segment === \"oneOf\") && i < parsed.pointer.length - 1) {\n          const next = parsed.pointer[i + 1];\n          if (/^\\d+$/.test(next)) {\n            // If we encounter something like \"anyOf/0\", we want to skip that part of the path\n            i++;\n            continue;\n          }\n        }\n        cleanedPointer.push(segment);\n      }\n      const cleanedRefPath = createRef(cleanedPointer);\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        // If fromAdditionalProperties is true we are dealing with a record type and we should append [string] to the generated type\n        fromAdditionalProperties\n          ? ts.factory.createIndexedAccessTypeNode(\n              oapiRef(cleanedRefPath, undefined, true),\n              ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"string\")),\n            )\n          : oapiRef(cleanedRefPath, undefined, true),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[], unionKey: \"anyOf\" | \"oneOf\") {\n    const output: ts.TypeNode[] = [];\n    for (const [index, item] of items.entries()) {\n      output.push(\n        transformSchemaObject(item, {\n          ...options,\n          // include index in path so generated names from nested enums/enumValues are unique\n          path: createRef([options.path, unionKey, String(index)]),\n        }),\n      );\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      output.push(itemType);\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? [], \"anyOf\");\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n    \"oneOf\",\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"patternProperties\" in schemaObject && schemaObject.patternProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        let property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        let property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties / patternProperties\n    const hasExplicitAdditionalProperties =\n      typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n    const hasImplicitAdditionalProperties =\n      schemaObject.additionalProperties === true ||\n      (typeof schemaObject.additionalProperties === \"object\" &&\n        Object.keys(schemaObject.additionalProperties).length === 0);\n    const hasExplicitPatternProperties =\n      typeof schemaObject.patternProperties === \"object\" && Object.keys(schemaObject.patternProperties).length;\n    const stringIndexTypes = [];\n    if (hasExplicitAdditionalProperties) {\n      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options, true));\n    }\n    if (hasImplicitAdditionalProperties || (!schemaObject.additionalProperties && options.ctx.additionalProperties)) {\n      stringIndexTypes.push(UNKNOWN);\n    }\n    if (hasExplicitPatternProperties) {\n      for (const [_, v] of getEntries(schemaObject.patternProperties ?? {}, options.ctx)) {\n        stringIndexTypes.push(transformSchemaObject(v, options));\n      }\n    }\n\n    if (stringIndexTypes.length === 0) {\n      return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n    }\n\n    const stringIndexType = tsUnion(stringIndexTypes);\n\n    return tsIntersection([\n      ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n      ts.factory.createTypeLiteralNode([\n        ts.factory.createIndexSignature(\n          /* modifiers  */ tsModifiers({\n            readonly: options.ctx.immutable,\n          }),\n          /* parameters */ [\n            ts.factory.createParameterDeclaration(\n              /* modifiers      */ undefined,\n              /* dotDotDotToken */ undefined,\n              /* name           */ ts.factory.createIdentifier(\"key\"),\n              /* questionToken  */ undefined,\n              /* type           */ STRING,\n            ),\n          ],\n          /* type       */ stringIndexType,\n        ),\n      ]),\n    ]);\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["enumType"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/webhooks-object.cjs.map b/dist/transform/webhooks-object.cjs.map
index 7a001a46090bf9336a2e9b2ab43bde68b811fa5e..c91eb662367b6f85c40b3f96e5f6ec7ce3985858 100644
--- a/dist/transform/webhooks-object.cjs.map
+++ b/dist/transform/webhooks-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"webhooks-object.cjs","sources":["../../src/transform/webhooks-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { GlobalContext, WebhooksObject } from \"../types.js\";\nimport transformPathItemObject from \"./path-item-object.js\";\n\nexport default function transformWebhooksObject(webhooksObject: WebhooksObject, options: GlobalContext): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  for (const [name, pathItemObject] of getEntries(webhooksObject, options)) {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({\n          readonly: options.immutable,\n        }),\n        /* name          */ tsPropertyIndex(name),\n        /* questionToken */ undefined,\n        /* type          */ transformPathItemObject(pathItemObject, {\n          path: createRef([\"webhooks\", name]),\n          ctx: options,\n        }),\n      ),\n    );\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n"],"names":["pathItemObject","getEntries","ts","tsModifiers","tsPropertyIndex","transformPathItemObject","createRef"],"mappings":";;;;;;;;;;;AAMA,SAAwB,uBAAA,CAAwB,gBAAgC,OAAA,EAAqC;AACnH,EAAA,MAAM,OAAyB,EAAC;AAEhC,EAAA,KAAA,MAAW,CAAC,IAAA,EAAMA,gBAAc,KAAKC,gBAAA,CAAW,cAAA,EAAgB,OAAO,CAAA,EAAG;AACxE,IAAA,IAAA,CAAK,IAAA;AAAA,MACHC,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,QACWC,gBAAA,CAAY;AAAA,UAC9B,UAAU,OAAA,CAAQ;AAAA,SACnB,CAAA;AAAA;AAAA,QACmBC,qBAAgB,IAAI,CAAA;AAAA;AAAA,QACpB,MAAA;AAAA;AAAA,QACAC,eAAwBL,gBAAA,EAAgB;AAAA,UAC1D,IAAA,EAAMM,eAAA,CAAU,CAAC,UAAA,EAAY,IAAI,CAAC,CAAA;AAAA,UAClC,GAAA,EAAK;AAAA,SACN;AAAA;AACH,KACF;AAAA,EACF;AAEA,EAAA,OAAOJ,WAAA,CAAG,OAAA,CAAQ,qBAAA,CAAsB,IAAI,CAAA;AAC9C;;;;"}
\ No newline at end of file
+{"version":3,"file":"webhooks-object.cjs","sources":["../../src/transform/webhooks-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { GlobalContext, WebhooksObject } from \"../types.js\";\nimport transformPathItemObject from \"./path-item-object.js\";\n\nexport default function transformWebhooksObject(webhooksObject: WebhooksObject, options: GlobalContext): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  for (const [name, pathItemObject] of getEntries(webhooksObject, options)) {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({\n          readonly: options.immutable,\n        }),\n        /* name          */ tsPropertyIndex(name),\n        /* questionToken */ undefined,\n        /* type          */ transformPathItemObject(pathItemObject, {\n          path: createRef([\"webhooks\", name]),\n          ctx: options,\n        }),\n      ),\n    );\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n"],"names":["pathItemObject","getEntries","ts","tsModifiers","tsPropertyIndex","transformPathItemObject","createRef"],"mappings":";;;;;;;;;;;AAMwB,SAAA,uBAAA,CAAwB,gBAAgC,OAAqC,EAAA;AACnH,EAAA,MAAM,OAAyB,EAAC;AAEhC,EAAA,KAAA,MAAW,CAAC,IAAM,EAAAA,gBAAc,KAAKC,gBAAW,CAAA,cAAA,EAAgB,OAAO,CAAG,EAAA;AACxE,IAAK,IAAA,CAAA,IAAA;AAAA,MACHC,YAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,QACWC,gBAAY,CAAA;AAAA,UAC9B,UAAU,OAAQ,CAAA;AAAA,SACnB,CAAA;AAAA;AAAA,QACmBC,qBAAgB,IAAI,CAAA;AAAA;AAAA,QACpB,MAAA;AAAA;AAAA,QACAC,eAAwBL,gBAAgB,EAAA;AAAA,UAC1D,IAAM,EAAAM,eAAA,CAAU,CAAC,UAAA,EAAY,IAAI,CAAC,CAAA;AAAA,UAClC,GAAK,EAAA;AAAA,SACN;AAAA;AACH,KACF;AAAA;AAGF,EAAO,OAAAJ,WAAA,CAAG,OAAQ,CAAA,qBAAA,CAAsB,IAAI,CAAA;AAC9C;;;;"}
\ No newline at end of file
diff --git a/dist/transform/webhooks-object.mjs.map b/dist/transform/webhooks-object.mjs.map
index 6e0df8932f95eb82969b1f810ce7919b6d5a2ad0..c042702935befb5ad51f3c9fdb2852b0dcec459e 100644
--- a/dist/transform/webhooks-object.mjs.map
+++ b/dist/transform/webhooks-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"webhooks-object.mjs","sources":["../../src/transform/webhooks-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { GlobalContext, WebhooksObject } from \"../types.js\";\nimport transformPathItemObject from \"./path-item-object.js\";\n\nexport default function transformWebhooksObject(webhooksObject: WebhooksObject, options: GlobalContext): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  for (const [name, pathItemObject] of getEntries(webhooksObject, options)) {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({\n          readonly: options.immutable,\n        }),\n        /* name          */ tsPropertyIndex(name),\n        /* questionToken */ undefined,\n        /* type          */ transformPathItemObject(pathItemObject, {\n          path: createRef([\"webhooks\", name]),\n          ctx: options,\n        }),\n      ),\n    );\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n"],"names":[],"mappings":";;;;;AAMA,SAAwB,uBAAA,CAAwB,gBAAgC,OAAA,EAAqC;AACnH,EAAA,MAAM,OAAyB,EAAC;AAEhC,EAAA,KAAA,MAAW,CAAC,IAAA,EAAM,cAAc,KAAK,UAAA,CAAW,cAAA,EAAgB,OAAO,CAAA,EAAG;AACxE,IAAA,IAAA,CAAK,IAAA;AAAA,MACH,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,QACW,WAAA,CAAY;AAAA,UAC9B,UAAU,OAAA,CAAQ;AAAA,SACnB,CAAA;AAAA;AAAA,QACmB,gBAAgB,IAAI,CAAA;AAAA;AAAA,QACpB,MAAA;AAAA;AAAA,QACA,wBAAwB,cAAA,EAAgB;AAAA,UAC1D,IAAA,EAAM,SAAA,CAAU,CAAC,UAAA,EAAY,IAAI,CAAC,CAAA;AAAA,UAClC,GAAA,EAAK;AAAA,SACN;AAAA;AACH,KACF;AAAA,EACF;AAEA,EAAA,OAAO,EAAA,CAAG,OAAA,CAAQ,qBAAA,CAAsB,IAAI,CAAA;AAC9C;;;;"}
\ No newline at end of file
+{"version":3,"file":"webhooks-object.mjs","sources":["../../src/transform/webhooks-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { GlobalContext, WebhooksObject } from \"../types.js\";\nimport transformPathItemObject from \"./path-item-object.js\";\n\nexport default function transformWebhooksObject(webhooksObject: WebhooksObject, options: GlobalContext): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n\n  for (const [name, pathItemObject] of getEntries(webhooksObject, options)) {\n    type.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({\n          readonly: options.immutable,\n        }),\n        /* name          */ tsPropertyIndex(name),\n        /* questionToken */ undefined,\n        /* type          */ transformPathItemObject(pathItemObject, {\n          path: createRef([\"webhooks\", name]),\n          ctx: options,\n        }),\n      ),\n    );\n  }\n\n  return ts.factory.createTypeLiteralNode(type);\n}\n"],"names":[],"mappings":";;;;;AAMwB,SAAA,uBAAA,CAAwB,gBAAgC,OAAqC,EAAA;AACnH,EAAA,MAAM,OAAyB,EAAC;AAEhC,EAAA,KAAA,MAAW,CAAC,IAAM,EAAA,cAAc,KAAK,UAAW,CAAA,cAAA,EAAgB,OAAO,CAAG,EAAA;AACxE,IAAK,IAAA,CAAA,IAAA;AAAA,MACH,GAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,QACW,WAAY,CAAA;AAAA,UAC9B,UAAU,OAAQ,CAAA;AAAA,SACnB,CAAA;AAAA;AAAA,QACmB,gBAAgB,IAAI,CAAA;AAAA;AAAA,QACpB,MAAA;AAAA;AAAA,QACA,wBAAwB,cAAgB,EAAA;AAAA,UAC1D,IAAM,EAAA,SAAA,CAAU,CAAC,UAAA,EAAY,IAAI,CAAC,CAAA;AAAA,UAClC,GAAK,EAAA;AAAA,SACN;AAAA;AACH,KACF;AAAA;AAGF,EAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,qBAAA,CAAsB,IAAI,CAAA;AAC9C;;;;"}
\ No newline at end of file
diff --git a/package/dist/index.cjs b/package/dist/index.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..a2a38744991540e00b6a085aed403feedf0c51b6
--- /dev/null
+++ b/package/dist/index.cjs
@@ -0,0 +1,3362 @@
+"use strict";
+var __create = Object.create;
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __getOwnPropNames = Object.getOwnPropertyNames;
+var __getProtoOf = Object.getPrototypeOf;
+var __hasOwnProp = Object.prototype.hasOwnProperty;
+var __typeError = (msg) => {
+  throw TypeError(msg);
+};
+var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __commonJS = (cb, mod) => function __require() {
+  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
+};
+var __export = (target, all) => {
+  for (var name in all)
+    __defProp(target, name, { get: all[name], enumerable: true });
+};
+var __copyProps = (to, from, except, desc) => {
+  if (from && typeof from === "object" || typeof from === "function") {
+    for (let key of __getOwnPropNames(from))
+      if (!__hasOwnProp.call(to, key) && key !== except)
+        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+  }
+  return to;
+};
+var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
+  // If the importer is in node compatibility mode or this is not an ESM
+  // file that has been converted to a CommonJS file using a Babel-
+  // compatible transform (i.e. "__esModule" has not been set), then set
+  // "default" to the CommonJS "module.exports" for node compatibility.
+  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
+  mod
+));
+var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
+var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
+var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
+var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
+var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
+var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
+
+// ../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js
+var require_picocolors = __commonJS({
+  "../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js"(exports2, module2) {
+    var p = process || {};
+    var argv = p.argv || [];
+    var env2 = p.env || {};
+    var isColorSupported = !(!!env2.NO_COLOR || argv.includes("--no-color")) && (!!env2.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env2.TERM !== "dumb" || !!env2.CI);
+    var formatter = (open, close, replace = open) => (input) => {
+      let string = "" + input, index = string.indexOf(close, open.length);
+      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
+    };
+    var replaceClose = (string, close, replace, index) => {
+      let result = "", cursor = 0;
+      do {
+        result += string.substring(cursor, index) + replace;
+        cursor = index + close.length;
+        index = string.indexOf(close, cursor);
+      } while (~index);
+      return result + string.substring(cursor);
+    };
+    var createColors = (enabled = isColorSupported) => {
+      let f = enabled ? formatter : () => String;
+      return {
+        isColorSupported: enabled,
+        reset: f("\x1B[0m", "\x1B[0m"),
+        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
+        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
+        italic: f("\x1B[3m", "\x1B[23m"),
+        underline: f("\x1B[4m", "\x1B[24m"),
+        inverse: f("\x1B[7m", "\x1B[27m"),
+        hidden: f("\x1B[8m", "\x1B[28m"),
+        strikethrough: f("\x1B[9m", "\x1B[29m"),
+        black: f("\x1B[30m", "\x1B[39m"),
+        red: f("\x1B[31m", "\x1B[39m"),
+        green: f("\x1B[32m", "\x1B[39m"),
+        yellow: f("\x1B[33m", "\x1B[39m"),
+        blue: f("\x1B[34m", "\x1B[39m"),
+        magenta: f("\x1B[35m", "\x1B[39m"),
+        cyan: f("\x1B[36m", "\x1B[39m"),
+        white: f("\x1B[37m", "\x1B[39m"),
+        gray: f("\x1B[90m", "\x1B[39m"),
+        bgBlack: f("\x1B[40m", "\x1B[49m"),
+        bgRed: f("\x1B[41m", "\x1B[49m"),
+        bgGreen: f("\x1B[42m", "\x1B[49m"),
+        bgYellow: f("\x1B[43m", "\x1B[49m"),
+        bgBlue: f("\x1B[44m", "\x1B[49m"),
+        bgMagenta: f("\x1B[45m", "\x1B[49m"),
+        bgCyan: f("\x1B[46m", "\x1B[49m"),
+        bgWhite: f("\x1B[47m", "\x1B[49m"),
+        blackBright: f("\x1B[90m", "\x1B[39m"),
+        redBright: f("\x1B[91m", "\x1B[39m"),
+        greenBright: f("\x1B[92m", "\x1B[39m"),
+        yellowBright: f("\x1B[93m", "\x1B[39m"),
+        blueBright: f("\x1B[94m", "\x1B[39m"),
+        magentaBright: f("\x1B[95m", "\x1B[39m"),
+        cyanBright: f("\x1B[96m", "\x1B[39m"),
+        whiteBright: f("\x1B[97m", "\x1B[39m"),
+        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
+        bgRedBright: f("\x1B[101m", "\x1B[49m"),
+        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
+        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
+        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
+        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
+        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
+        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
+      };
+    };
+    module2.exports = createColors();
+    module2.exports.createColors = createColors;
+  }
+});
+
+// ../../node_modules/.pnpm/js-tokens@4.0.0/node_modules/js-tokens/index.js
+var require_js_tokens = __commonJS({
+  "../../node_modules/.pnpm/js-tokens@4.0.0/node_modules/js-tokens/index.js"(exports2) {
+    Object.defineProperty(exports2, "__esModule", {
+      value: true
+    });
+    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
+    exports2.matchToToken = function(match) {
+      var token = { type: "invalid", value: match[0], closed: void 0 };
+      if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
+      else if (match[5]) token.type = "comment";
+      else if (match[6]) token.type = "comment", token.closed = !!match[7];
+      else if (match[8]) token.type = "regex";
+      else if (match[9]) token.type = "number";
+      else if (match[10]) token.type = "name";
+      else if (match[11]) token.type = "punctuator";
+      else if (match[12]) token.type = "whitespace";
+      return token;
+    };
+  }
+});
+
+// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/identifier.js
+var require_identifier = __commonJS({
+  "../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
+    "use strict";
+    Object.defineProperty(exports2, "__esModule", {
+      value: true
+    });
+    exports2.isIdentifierChar = isIdentifierChar;
+    exports2.isIdentifierName = isIdentifierName;
+    exports2.isIdentifierStart = isIdentifierStart;
+    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
+    var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
+    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
+    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
+    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
+    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
+    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
+    function isInAstralSet(code, set) {
+      let pos = 65536;
+      for (let i = 0, length = set.length; i < length; i += 2) {
+        pos += set[i];
+        if (pos > code) return false;
+        pos += set[i + 1];
+        if (pos >= code) return true;
+      }
+      return false;
+    }
+    function isIdentifierStart(code) {
+      if (code < 65) return code === 36;
+      if (code <= 90) return true;
+      if (code < 97) return code === 95;
+      if (code <= 122) return true;
+      if (code <= 65535) {
+        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
+      }
+      return isInAstralSet(code, astralIdentifierStartCodes);
+    }
+    function isIdentifierChar(code) {
+      if (code < 48) return code === 36;
+      if (code < 58) return true;
+      if (code < 65) return false;
+      if (code <= 90) return true;
+      if (code < 97) return code === 95;
+      if (code <= 122) return true;
+      if (code <= 65535) {
+        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
+      }
+      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
+    }
+    function isIdentifierName(name) {
+      let isFirst = true;
+      for (let i = 0; i < name.length; i++) {
+        let cp = name.charCodeAt(i);
+        if ((cp & 64512) === 55296 && i + 1 < name.length) {
+          const trail = name.charCodeAt(++i);
+          if ((trail & 64512) === 56320) {
+            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
+          }
+        }
+        if (isFirst) {
+          isFirst = false;
+          if (!isIdentifierStart(cp)) {
+            return false;
+          }
+        } else if (!isIdentifierChar(cp)) {
+          return false;
+        }
+      }
+      return !isFirst;
+    }
+  }
+});
+
+// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/keyword.js
+var require_keyword = __commonJS({
+  "../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
+    "use strict";
+    Object.defineProperty(exports2, "__esModule", {
+      value: true
+    });
+    exports2.isKeyword = isKeyword;
+    exports2.isReservedWord = isReservedWord;
+    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
+    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
+    exports2.isStrictReservedWord = isStrictReservedWord;
+    var reservedWords = {
+      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
+      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
+      strictBind: ["eval", "arguments"]
+    };
+    var keywords = new Set(reservedWords.keyword);
+    var reservedWordsStrictSet = new Set(reservedWords.strict);
+    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
+    function isReservedWord(word, inModule) {
+      return inModule && word === "await" || word === "enum";
+    }
+    function isStrictReservedWord(word, inModule) {
+      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
+    }
+    function isStrictBindOnlyReservedWord(word) {
+      return reservedWordsStrictBindSet.has(word);
+    }
+    function isStrictBindReservedWord(word, inModule) {
+      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
+    }
+    function isKeyword(word) {
+      return keywords.has(word);
+    }
+  }
+});
+
+// ../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js
+var require_lib = __commonJS({
+  "../../node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
+    "use strict";
+    Object.defineProperty(exports2, "__esModule", {
+      value: true
+    });
+    Object.defineProperty(exports2, "isIdentifierChar", {
+      enumerable: true,
+      get: function() {
+        return _identifier.isIdentifierChar;
+      }
+    });
+    Object.defineProperty(exports2, "isIdentifierName", {
+      enumerable: true,
+      get: function() {
+        return _identifier.isIdentifierName;
+      }
+    });
+    Object.defineProperty(exports2, "isIdentifierStart", {
+      enumerable: true,
+      get: function() {
+        return _identifier.isIdentifierStart;
+      }
+    });
+    Object.defineProperty(exports2, "isKeyword", {
+      enumerable: true,
+      get: function() {
+        return _keyword.isKeyword;
+      }
+    });
+    Object.defineProperty(exports2, "isReservedWord", {
+      enumerable: true,
+      get: function() {
+        return _keyword.isReservedWord;
+      }
+    });
+    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
+      enumerable: true,
+      get: function() {
+        return _keyword.isStrictBindOnlyReservedWord;
+      }
+    });
+    Object.defineProperty(exports2, "isStrictBindReservedWord", {
+      enumerable: true,
+      get: function() {
+        return _keyword.isStrictBindReservedWord;
+      }
+    });
+    Object.defineProperty(exports2, "isStrictReservedWord", {
+      enumerable: true,
+      get: function() {
+        return _keyword.isStrictReservedWord;
+      }
+    });
+    var _identifier = require_identifier();
+    var _keyword = require_keyword();
+  }
+});
+
+// ../../node_modules/.pnpm/@babel+code-frame@7.26.2/node_modules/@babel/code-frame/lib/index.js
+var require_lib2 = __commonJS({
+  "../../node_modules/.pnpm/@babel+code-frame@7.26.2/node_modules/@babel/code-frame/lib/index.js"(exports2) {
+    "use strict";
+    Object.defineProperty(exports2, "__esModule", { value: true });
+    var picocolors = require_picocolors();
+    var jsTokens = require_js_tokens();
+    var helperValidatorIdentifier = require_lib();
+    function isColorSupported() {
+      return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
+    }
+    var compose = (f, g) => (v) => f(g(v));
+    function buildDefs(colors) {
+      return {
+        keyword: colors.cyan,
+        capitalized: colors.yellow,
+        jsxIdentifier: colors.yellow,
+        punctuator: colors.yellow,
+        number: colors.magenta,
+        string: colors.green,
+        regex: colors.magenta,
+        comment: colors.gray,
+        invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
+        gutter: colors.gray,
+        marker: compose(colors.red, colors.bold),
+        message: compose(colors.red, colors.bold),
+        reset: colors.reset
+      };
+    }
+    var defsOn = buildDefs(picocolors.createColors(true));
+    var defsOff = buildDefs(picocolors.createColors(false));
+    function getDefs(enabled) {
+      return enabled ? defsOn : defsOff;
+    }
+    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
+    var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
+    var BRACKET = /^[()[\]{}]$/;
+    var tokenize;
+    {
+      const JSX_TAG = /^[a-z][\w-]*$/i;
+      const getTokenType = function(token, offset, text) {
+        if (token.type === "name") {
+          if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
+            return "keyword";
+          }
+          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
+            return "jsxIdentifier";
+          }
+          if (token.value[0] !== token.value[0].toLowerCase()) {
+            return "capitalized";
+          }
+        }
+        if (token.type === "punctuator" && BRACKET.test(token.value)) {
+          return "bracket";
+        }
+        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
+          return "punctuator";
+        }
+        return token.type;
+      };
+      tokenize = function* (text) {
+        let match;
+        while (match = jsTokens.default.exec(text)) {
+          const token = jsTokens.matchToToken(match);
+          yield {
+            type: getTokenType(token, match.index, text),
+            value: token.value
+          };
+        }
+      };
+    }
+    function highlight(text) {
+      if (text === "") return "";
+      const defs = getDefs(true);
+      let highlighted = "";
+      for (const {
+        type,
+        value
+      } of tokenize(text)) {
+        if (type in defs) {
+          highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join("\n");
+        } else {
+          highlighted += value;
+        }
+      }
+      return highlighted;
+    }
+    var deprecationWarningShown = false;
+    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
+    function getMarkerLines(loc, source, opts) {
+      const startLoc = Object.assign({
+        column: 0,
+        line: -1
+      }, loc.start);
+      const endLoc = Object.assign({}, startLoc, loc.end);
+      const {
+        linesAbove = 2,
+        linesBelow = 3
+      } = opts || {};
+      const startLine = startLoc.line;
+      const startColumn = startLoc.column;
+      const endLine = endLoc.line;
+      const endColumn = endLoc.column;
+      let start = Math.max(startLine - (linesAbove + 1), 0);
+      let end = Math.min(source.length, endLine + linesBelow);
+      if (startLine === -1) {
+        start = 0;
+      }
+      if (endLine === -1) {
+        end = source.length;
+      }
+      const lineDiff = endLine - startLine;
+      const markerLines = {};
+      if (lineDiff) {
+        for (let i = 0; i <= lineDiff; i++) {
+          const lineNumber = i + startLine;
+          if (!startColumn) {
+            markerLines[lineNumber] = true;
+          } else if (i === 0) {
+            const sourceLength = source[lineNumber - 1].length;
+            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
+          } else if (i === lineDiff) {
+            markerLines[lineNumber] = [0, endColumn];
+          } else {
+            const sourceLength = source[lineNumber - i].length;
+            markerLines[lineNumber] = [0, sourceLength];
+          }
+        }
+      } else {
+        if (startColumn === endColumn) {
+          if (startColumn) {
+            markerLines[startLine] = [startColumn, 0];
+          } else {
+            markerLines[startLine] = true;
+          }
+        } else {
+          markerLines[startLine] = [startColumn, endColumn - startColumn];
+        }
+      }
+      return {
+        start,
+        end,
+        markerLines
+      };
+    }
+    function codeFrameColumns2(rawLines, loc, opts = {}) {
+      const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
+      const defs = getDefs(shouldHighlight);
+      const lines = rawLines.split(NEWLINE);
+      const {
+        start,
+        end,
+        markerLines
+      } = getMarkerLines(loc, lines, opts);
+      const hasColumns = loc.start && typeof loc.start.column === "number";
+      const numberMaxWidth = String(end).length;
+      const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
+      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index2) => {
+        const number = start + 1 + index2;
+        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
+        const gutter = ` ${paddedNumber} |`;
+        const hasMarker = markerLines[number];
+        const lastMarkerLine = !markerLines[number + 1];
+        if (hasMarker) {
+          let markerLine = "";
+          if (Array.isArray(hasMarker)) {
+            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
+            const numberOfMarkers = hasMarker[1] || 1;
+            markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
+            if (lastMarkerLine && opts.message) {
+              markerLine += " " + defs.message(opts.message);
+            }
+          }
+          return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
+        } else {
+          return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
+        }
+      }).join("\n");
+      if (opts.message && !hasColumns) {
+        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
+${frame}`;
+      }
+      if (shouldHighlight) {
+        return defs.reset(frame);
+      } else {
+        return frame;
+      }
+    }
+    function index(rawLines, lineNumber, colNumber, opts = {}) {
+      if (!deprecationWarningShown) {
+        deprecationWarningShown = true;
+        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
+        if (process.emitWarning) {
+          process.emitWarning(message, "DeprecationWarning");
+        } else {
+          const deprecationError = new Error(message);
+          deprecationError.name = "DeprecationWarning";
+          console.warn(new Error(message));
+        }
+      }
+      colNumber = Math.max(colNumber, 0);
+      const location = {
+        start: {
+          column: colNumber,
+          line: lineNumber
+        }
+      };
+      return codeFrameColumns2(rawLines, location, opts);
+    }
+    exports2.codeFrameColumns = codeFrameColumns2;
+    exports2.default = index;
+    exports2.highlight = highlight;
+  }
+});
+
+// ../../node_modules/.pnpm/ansi-colors@4.1.3/node_modules/ansi-colors/symbols.js
+var require_symbols = __commonJS({
+  "../../node_modules/.pnpm/ansi-colors@4.1.3/node_modules/ansi-colors/symbols.js"(exports2, module2) {
+    "use strict";
+    var isHyper = typeof process !== "undefined" && process.env.TERM_PROGRAM === "Hyper";
+    var isWindows = typeof process !== "undefined" && process.platform === "win32";
+    var isLinux = typeof process !== "undefined" && process.platform === "linux";
+    var common = {
+      ballotDisabled: "\u2612",
+      ballotOff: "\u2610",
+      ballotOn: "\u2611",
+      bullet: "\u2022",
+      bulletWhite: "\u25E6",
+      fullBlock: "\u2588",
+      heart: "\u2764",
+      identicalTo: "\u2261",
+      line: "\u2500",
+      mark: "\u203B",
+      middot: "\xB7",
+      minus: "\uFF0D",
+      multiplication: "\xD7",
+      obelus: "\xF7",
+      pencilDownRight: "\u270E",
+      pencilRight: "\u270F",
+      pencilUpRight: "\u2710",
+      percent: "%",
+      pilcrow2: "\u2761",
+      pilcrow: "\xB6",
+      plusMinus: "\xB1",
+      question: "?",
+      section: "\xA7",
+      starsOff: "\u2606",
+      starsOn: "\u2605",
+      upDownArrow: "\u2195"
+    };
+    var windows = Object.assign({}, common, {
+      check: "\u221A",
+      cross: "\xD7",
+      ellipsisLarge: "...",
+      ellipsis: "...",
+      info: "i",
+      questionSmall: "?",
+      pointer: ">",
+      pointerSmall: "\xBB",
+      radioOff: "( )",
+      radioOn: "(*)",
+      warning: "\u203C"
+    });
+    var other = Object.assign({}, common, {
+      ballotCross: "\u2718",
+      check: "\u2714",
+      cross: "\u2716",
+      ellipsisLarge: "\u22EF",
+      ellipsis: "\u2026",
+      info: "\u2139",
+      questionFull: "\uFF1F",
+      questionSmall: "\uFE56",
+      pointer: isLinux ? "\u25B8" : "\u276F",
+      pointerSmall: isLinux ? "\u2023" : "\u203A",
+      radioOff: "\u25EF",
+      radioOn: "\u25C9",
+      warning: "\u26A0"
+    });
+    module2.exports = isWindows && !isHyper ? windows : other;
+    Reflect.defineProperty(module2.exports, "common", { enumerable: false, value: common });
+    Reflect.defineProperty(module2.exports, "windows", { enumerable: false, value: windows });
+    Reflect.defineProperty(module2.exports, "other", { enumerable: false, value: other });
+  }
+});
+
+// ../../node_modules/.pnpm/ansi-colors@4.1.3/node_modules/ansi-colors/index.js
+var require_ansi_colors = __commonJS({
+  "../../node_modules/.pnpm/ansi-colors@4.1.3/node_modules/ansi-colors/index.js"(exports2, module2) {
+    "use strict";
+    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
+    var ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;
+    var hasColor = () => {
+      if (typeof process !== "undefined") {
+        return process.env.FORCE_COLOR !== "0";
+      }
+      return false;
+    };
+    var create = () => {
+      const colors = {
+        enabled: hasColor(),
+        visible: true,
+        styles: {},
+        keys: {}
+      };
+      const ansi = (style2) => {
+        let open = style2.open = `\x1B[${style2.codes[0]}m`;
+        let close = style2.close = `\x1B[${style2.codes[1]}m`;
+        let regex = style2.regex = new RegExp(`\\u001b\\[${style2.codes[1]}m`, "g");
+        style2.wrap = (input, newline) => {
+          if (input.includes(close)) input = input.replace(regex, close + open);
+          let output = open + input + close;
+          return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
+        };
+        return style2;
+      };
+      const wrap = (style2, input, newline) => {
+        return typeof style2 === "function" ? style2(input) : style2.wrap(input, newline);
+      };
+      const style = (input, stack) => {
+        if (input === "" || input == null) return "";
+        if (colors.enabled === false) return input;
+        if (colors.visible === false) return "";
+        let str = "" + input;
+        let nl = str.includes("\n");
+        let n = stack.length;
+        if (n > 0 && stack.includes("unstyle")) {
+          stack = [.../* @__PURE__ */ new Set(["unstyle", ...stack])].reverse();
+        }
+        while (n-- > 0) str = wrap(colors.styles[stack[n]], str, nl);
+        return str;
+      };
+      const define = (name, codes, type) => {
+        colors.styles[name] = ansi({ name, codes });
+        let keys = colors.keys[type] || (colors.keys[type] = []);
+        keys.push(name);
+        Reflect.defineProperty(colors, name, {
+          configurable: true,
+          enumerable: true,
+          set(value) {
+            colors.alias(name, value);
+          },
+          get() {
+            let color = (input) => style(input, color.stack);
+            Reflect.setPrototypeOf(color, colors);
+            color.stack = this.stack ? this.stack.concat(name) : [name];
+            return color;
+          }
+        });
+      };
+      define("reset", [0, 0], "modifier");
+      define("bold", [1, 22], "modifier");
+      define("dim", [2, 22], "modifier");
+      define("italic", [3, 23], "modifier");
+      define("underline", [4, 24], "modifier");
+      define("inverse", [7, 27], "modifier");
+      define("hidden", [8, 28], "modifier");
+      define("strikethrough", [9, 29], "modifier");
+      define("black", [30, 39], "color");
+      define("red", [31, 39], "color");
+      define("green", [32, 39], "color");
+      define("yellow", [33, 39], "color");
+      define("blue", [34, 39], "color");
+      define("magenta", [35, 39], "color");
+      define("cyan", [36, 39], "color");
+      define("white", [37, 39], "color");
+      define("gray", [90, 39], "color");
+      define("grey", [90, 39], "color");
+      define("bgBlack", [40, 49], "bg");
+      define("bgRed", [41, 49], "bg");
+      define("bgGreen", [42, 49], "bg");
+      define("bgYellow", [43, 49], "bg");
+      define("bgBlue", [44, 49], "bg");
+      define("bgMagenta", [45, 49], "bg");
+      define("bgCyan", [46, 49], "bg");
+      define("bgWhite", [47, 49], "bg");
+      define("blackBright", [90, 39], "bright");
+      define("redBright", [91, 39], "bright");
+      define("greenBright", [92, 39], "bright");
+      define("yellowBright", [93, 39], "bright");
+      define("blueBright", [94, 39], "bright");
+      define("magentaBright", [95, 39], "bright");
+      define("cyanBright", [96, 39], "bright");
+      define("whiteBright", [97, 39], "bright");
+      define("bgBlackBright", [100, 49], "bgBright");
+      define("bgRedBright", [101, 49], "bgBright");
+      define("bgGreenBright", [102, 49], "bgBright");
+      define("bgYellowBright", [103, 49], "bgBright");
+      define("bgBlueBright", [104, 49], "bgBright");
+      define("bgMagentaBright", [105, 49], "bgBright");
+      define("bgCyanBright", [106, 49], "bgBright");
+      define("bgWhiteBright", [107, 49], "bgBright");
+      colors.ansiRegex = ANSI_REGEX;
+      colors.hasColor = colors.hasAnsi = (str) => {
+        colors.ansiRegex.lastIndex = 0;
+        return typeof str === "string" && str !== "" && colors.ansiRegex.test(str);
+      };
+      colors.alias = (name, color) => {
+        let fn = typeof color === "string" ? colors[color] : color;
+        if (typeof fn !== "function") {
+          throw new TypeError("Expected alias to be the name of an existing color (string) or a function");
+        }
+        if (!fn.stack) {
+          Reflect.defineProperty(fn, "name", { value: name });
+          colors.styles[name] = fn;
+          fn.stack = [name];
+        }
+        Reflect.defineProperty(colors, name, {
+          configurable: true,
+          enumerable: true,
+          set(value) {
+            colors.alias(name, value);
+          },
+          get() {
+            let color2 = (input) => style(input, color2.stack);
+            Reflect.setPrototypeOf(color2, colors);
+            color2.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
+            return color2;
+          }
+        });
+      };
+      colors.theme = (custom) => {
+        if (!isObject(custom)) throw new TypeError("Expected theme to be an object");
+        for (let name of Object.keys(custom)) {
+          colors.alias(name, custom[name]);
+        }
+        return colors;
+      };
+      colors.alias("unstyle", (str) => {
+        if (typeof str === "string" && str !== "") {
+          colors.ansiRegex.lastIndex = 0;
+          return str.replace(colors.ansiRegex, "");
+        }
+        return "";
+      });
+      colors.alias("noop", (str) => str);
+      colors.none = colors.clear = colors.noop;
+      colors.stripColor = colors.unstyle;
+      colors.symbols = require_symbols();
+      colors.define = define;
+      return colors;
+    };
+    module2.exports = create();
+    module2.exports.create = create;
+  }
+});
+
+// src/index.ts
+var index_exports = {};
+__export(index_exports, {
+  BOOLEAN: () => BOOLEAN,
+  COMMENT_HEADER: () => COMMENT_HEADER,
+  FALSE: () => FALSE,
+  JS_ENUM_INVALID_CHARS_RE: () => JS_ENUM_INVALID_CHARS_RE,
+  JS_PROPERTY_INDEX_INVALID_CHARS_RE: () => JS_PROPERTY_INDEX_INVALID_CHARS_RE,
+  JS_PROPERTY_INDEX_RE: () => JS_PROPERTY_INDEX_RE,
+  NEVER: () => NEVER,
+  NULL: () => NULL,
+  NUMBER: () => NUMBER,
+  QUESTION_TOKEN: () => QUESTION_TOKEN,
+  SPECIAL_CHARACTER_MAP: () => SPECIAL_CHARACTER_MAP,
+  STRING: () => STRING,
+  TRUE: () => TRUE,
+  UNDEFINED: () => UNDEFINED,
+  UNKNOWN: () => UNKNOWN,
+  addJSDocComment: () => addJSDocComment,
+  astToString: () => astToString,
+  c: () => import_ansi_colors.default,
+  createDiscriminatorProperty: () => createDiscriminatorProperty,
+  createRef: () => createRef,
+  debug: () => debug,
+  default: () => openapiTS,
+  enumCache: () => enumCache,
+  error: () => error,
+  formatTime: () => formatTime,
+  getEntries: () => getEntries,
+  injectOperationObject: () => injectOperationObject,
+  oapiRef: () => oapiRef,
+  resolveRef: () => resolveRef,
+  scanDiscriminators: () => scanDiscriminators,
+  stringToAST: () => stringToAST,
+  transformComponentsObject: () => transformComponentsObject,
+  transformHeaderObject: () => transformHeaderObject,
+  transformMediaTypeObject: () => transformMediaTypeObject,
+  transformOperationObject: () => transformOperationObject,
+  transformParameterObject: () => transformParameterObject,
+  transformPathItemObject: () => transformPathItemObject,
+  transformPathsObject: () => transformPathsObject,
+  transformRequestBodyObject: () => transformRequestBodyObject,
+  transformResponseObject: () => transformResponseObject,
+  transformResponsesObject: () => transformResponsesObject,
+  transformSchema: () => transformSchema,
+  transformSchemaObject: () => transformSchemaObject,
+  transformSchemaObjectWithComposition: () => transformSchemaObjectWithComposition,
+  tsArrayLiteralExpression: () => tsArrayLiteralExpression,
+  tsDedupe: () => tsDedupe,
+  tsEnum: () => tsEnum,
+  tsEnumMember: () => tsEnumMember,
+  tsIntersection: () => tsIntersection,
+  tsIsPrimitive: () => tsIsPrimitive,
+  tsLiteral: () => tsLiteral,
+  tsModifiers: () => tsModifiers,
+  tsNullable: () => tsNullable,
+  tsOmit: () => tsOmit,
+  tsPropertyIndex: () => tsPropertyIndex,
+  tsReadonlyArray: () => tsReadonlyArray,
+  tsRecord: () => tsRecord,
+  tsUnion: () => tsUnion,
+  tsWithRequired: () => tsWithRequired,
+  walk: () => walk,
+  warn: () => warn
+});
+module.exports = __toCommonJS(index_exports);
+var import_openapi_core2 = require("@redocly/openapi-core");
+var import_node_perf_hooks5 = require("node:perf_hooks");
+
+// src/lib/redoc.ts
+var import_openapi_core = require("@redocly/openapi-core");
+var import_node_perf_hooks = require("node:perf_hooks");
+var import_node_stream = require("node:stream");
+var import_node_url = require("node:url");
+
+// ../../node_modules/.pnpm/parse-json@8.1.0/node_modules/parse-json/index.js
+var import_code_frame = __toESM(require_lib2(), 1);
+
+// ../../node_modules/.pnpm/index-to-position@0.1.2/node_modules/index-to-position/index.js
+var safeLastIndexOf = (string, searchString, index) => index < 0 ? -1 : string.lastIndexOf(searchString, index);
+function getPosition(text, textIndex) {
+  const lineBreakBefore = safeLastIndexOf(text, "\n", textIndex - 1);
+  const column = textIndex - lineBreakBefore - 1;
+  let line = 0;
+  for (let index = lineBreakBefore; index >= 0; index = safeLastIndexOf(text, "\n", index - 1)) {
+    line++;
+  }
+  return { line, column };
+}
+function indexToLineColumn(text, textIndex, { oneBased = false } = {}) {
+  if (textIndex < 0 || textIndex >= text.length && text.length > 0) {
+    throw new RangeError("Index out of bounds");
+  }
+  const position = getPosition(text, textIndex);
+  return oneBased ? { line: position.line + 1, column: position.column + 1 } : position;
+}
+
+// ../../node_modules/.pnpm/parse-json@8.1.0/node_modules/parse-json/index.js
+var getCodePoint = (character) => `\\u{${character.codePointAt(0).toString(16)}}`;
+var _message;
+var _JSONError = class _JSONError extends Error {
+  constructor(message) {
+    var _a;
+    super();
+    __publicField(this, "name", "JSONError");
+    __publicField(this, "fileName");
+    __publicField(this, "codeFrame");
+    __publicField(this, "rawCodeFrame");
+    __privateAdd(this, _message);
+    __privateSet(this, _message, message);
+    (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, this, _JSONError);
+  }
+  get message() {
+    const { fileName, codeFrame } = this;
+    return `${__privateGet(this, _message)}${fileName ? ` in ${fileName}` : ""}${codeFrame ? `
+
+${codeFrame}
+` : ""}`;
+  }
+  set message(message) {
+    __privateSet(this, _message, message);
+  }
+};
+_message = new WeakMap();
+var JSONError = _JSONError;
+var generateCodeFrame = (string, location, highlightCode = true) => (0, import_code_frame.codeFrameColumns)(string, { start: location }, { highlightCode });
+var getErrorLocation = (string, message) => {
+  const match = message.match(/in JSON at position (?<index>\d+)(?: \(line (?<line>\d+) column (?<column>\d+)\))?$/);
+  if (!match) {
+    return;
+  }
+  let { index, line, column } = match.groups;
+  if (line && column) {
+    return { line: Number(line), column: Number(column) };
+  }
+  index = Number(index);
+  if (index === string.length) {
+    const { line: line2, column: column2 } = indexToLineColumn(string, string.length - 1, { oneBased: true });
+    return { line: line2, column: column2 + 1 };
+  }
+  return indexToLineColumn(string, index, { oneBased: true });
+};
+var addCodePointToUnexpectedToken = (message) => message.replace(
+  // TODO[engine:node@>=20]: The token always quoted after Node.js 20
+  /(?<=^Unexpected token )(?<quote>')?(.)\k<quote>/,
+  (_, _quote, token) => `"${token}"(${getCodePoint(token)})`
+);
+function parseJson(string, reviver, fileName) {
+  if (typeof reviver === "string") {
+    fileName = reviver;
+    reviver = void 0;
+  }
+  let message;
+  try {
+    return JSON.parse(string, reviver);
+  } catch (error2) {
+    message = error2.message;
+  }
+  let location;
+  if (string) {
+    location = getErrorLocation(string, message);
+    message = addCodePointToUnexpectedToken(message);
+  } else {
+    message += " while parsing empty string";
+  }
+  const jsonError = new JSONError(message);
+  jsonError.fileName = fileName;
+  if (location) {
+    jsonError.codeFrame = generateCodeFrame(string, location);
+    jsonError.rawCodeFrame = generateCodeFrame(
+      string,
+      location,
+      /* highlightCode */
+      false
+    );
+  }
+  throw jsonError;
+}
+
+// src/lib/utils.ts
+var import_ref_utils2 = require("@redocly/openapi-core/lib/ref-utils.js");
+var import_ansi_colors = __toESM(require_ansi_colors(), 1);
+
+// ../../node_modules/.pnpm/supports-color@9.4.0/node_modules/supports-color/index.js
+var import_node_process = __toESM(require("node:process"), 1);
+var import_node_os = __toESM(require("node:os"), 1);
+var import_node_tty = __toESM(require("node:tty"), 1);
+function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
+  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
+  const position = argv.indexOf(prefix + flag);
+  const terminatorPosition = argv.indexOf("--");
+  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
+}
+var { env } = import_node_process.default;
+var flagForceColor;
+if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
+  flagForceColor = 0;
+} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
+  flagForceColor = 1;
+}
+function envForceColor() {
+  if ("FORCE_COLOR" in env) {
+    if (env.FORCE_COLOR === "true") {
+      return 1;
+    }
+    if (env.FORCE_COLOR === "false") {
+      return 0;
+    }
+    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
+  }
+}
+function translateLevel(level) {
+  if (level === 0) {
+    return false;
+  }
+  return {
+    level,
+    hasBasic: true,
+    has256: level >= 2,
+    has16m: level >= 3
+  };
+}
+function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
+  const noFlagForceColor = envForceColor();
+  if (noFlagForceColor !== void 0) {
+    flagForceColor = noFlagForceColor;
+  }
+  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
+  if (forceColor === 0) {
+    return 0;
+  }
+  if (sniffFlags) {
+    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
+      return 3;
+    }
+    if (hasFlag("color=256")) {
+      return 2;
+    }
+  }
+  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
+    return 1;
+  }
+  if (haveStream && !streamIsTTY && forceColor === void 0) {
+    return 0;
+  }
+  const min = forceColor || 0;
+  if (env.TERM === "dumb") {
+    return min;
+  }
+  if (import_node_process.default.platform === "win32") {
+    const osRelease = import_node_os.default.release().split(".");
+    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
+      return Number(osRelease[2]) >= 14931 ? 3 : 2;
+    }
+    return 1;
+  }
+  if ("CI" in env) {
+    if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env) {
+      return 3;
+    }
+    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
+      return 1;
+    }
+    return min;
+  }
+  if ("TEAMCITY_VERSION" in env) {
+    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
+  }
+  if (env.COLORTERM === "truecolor") {
+    return 3;
+  }
+  if (env.TERM === "xterm-kitty") {
+    return 3;
+  }
+  if ("TERM_PROGRAM" in env) {
+    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
+    switch (env.TERM_PROGRAM) {
+      case "iTerm.app": {
+        return version >= 3 ? 3 : 2;
+      }
+      case "Apple_Terminal": {
+        return 2;
+      }
+    }
+  }
+  if (/-256(color)?$/i.test(env.TERM)) {
+    return 2;
+  }
+  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
+    return 1;
+  }
+  if ("COLORTERM" in env) {
+    return 1;
+  }
+  return min;
+}
+function createSupportsColor(stream, options = {}) {
+  const level = _supportsColor(stream, {
+    streamIsTTY: stream && stream.isTTY,
+    ...options
+  });
+  return translateLevel(level);
+}
+var supportsColor = {
+  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
+  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
+};
+var supports_color_default = supportsColor;
+
+// src/lib/utils.ts
+var import_typescript2 = __toESM(require("typescript"), 1);
+
+// src/lib/ts.ts
+var import_ref_utils = require("@redocly/openapi-core/lib/ref-utils.js");
+var import_typescript = __toESM(require("typescript"), 1);
+var JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;
+var JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;
+var JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;
+var SPECIAL_CHARACTER_MAP = {
+  "+": "Plus"
+  // Add more mappings as needed
+};
+var BOOLEAN = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.BooleanKeyword);
+var FALSE = import_typescript.default.factory.createLiteralTypeNode(import_typescript.default.factory.createFalse());
+var NEVER = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.NeverKeyword);
+var NULL = import_typescript.default.factory.createLiteralTypeNode(import_typescript.default.factory.createNull());
+var NUMBER = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.NumberKeyword);
+var QUESTION_TOKEN = import_typescript.default.factory.createToken(import_typescript.default.SyntaxKind.QuestionToken);
+var STRING = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.StringKeyword);
+var TRUE = import_typescript.default.factory.createLiteralTypeNode(import_typescript.default.factory.createTrue());
+var UNDEFINED = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.UndefinedKeyword);
+var UNKNOWN = import_typescript.default.factory.createKeywordTypeNode(import_typescript.default.SyntaxKind.UnknownKeyword);
+var LB_RE = /\r?\n/g;
+var COMMENT_RE = /\*\//g;
+function addJSDocComment(schemaObject, node) {
+  if (!schemaObject || typeof schemaObject !== "object" || Array.isArray(schemaObject)) {
+    return;
+  }
+  const output = [];
+  if (schemaObject.title) {
+    output.push(schemaObject.title.replace(LB_RE, "\n *     "));
+  }
+  if (schemaObject.summary) {
+    output.push(schemaObject.summary.replace(LB_RE, "\n *     "));
+  }
+  if (schemaObject.format) {
+    output.push(`Format: ${schemaObject.format}`);
+  }
+  if (schemaObject.deprecated) {
+    output.push("@deprecated");
+  }
+  const supportedJsDocTags = ["description", "default", "example"];
+  for (const field of supportedJsDocTags) {
+    const allowEmptyString = field === "default" || field === "example";
+    if (schemaObject[field] === void 0) {
+      continue;
+    }
+    if (schemaObject[field] === "" && !allowEmptyString) {
+      continue;
+    }
+    const serialized = typeof schemaObject[field] === "object" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];
+    output.push(`@${field} ${String(serialized).replace(LB_RE, "\n *     ")}`);
+  }
+  if ("const" in schemaObject) {
+    output.push("@constant");
+  }
+  if (schemaObject.enum) {
+    let type = "unknown";
+    if (Array.isArray(schemaObject.type)) {
+      type = schemaObject.type.join("|");
+    } else if (typeof schemaObject.type === "string") {
+      type = schemaObject.type;
+    }
+    output.push(`@enum {${type}${schemaObject.nullable ? "|null" : ""}}`);
+  }
+  if (output.length) {
+    let text = output.length === 1 ? `* ${output.join("\n")} ` : `*
+ * ${output.join("\n * ")}
+ `;
+    text = text.replace(COMMENT_RE, "*\\/");
+    import_typescript.default.addSyntheticLeadingComment(
+      /* node               */
+      node,
+      /* kind               */
+      import_typescript.default.SyntaxKind.MultiLineCommentTrivia,
+      // note: MultiLine just refers to a "/* */" comment
+      /* text               */
+      text,
+      /* hasTrailingNewLine */
+      true
+    );
+  }
+}
+function oapiRef(path) {
+  const { pointer } = (0, import_ref_utils.parseRef)(path);
+  if (pointer.length === 0) {
+    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);
+  }
+  let t = import_typescript.default.factory.createTypeReferenceNode(
+    import_typescript.default.factory.createIdentifier(String(pointer[0]))
+  );
+  if (pointer.length > 1) {
+    for (let i = 1; i < pointer.length; i++) {
+      if (i > 2 && i < pointer.length - 1 && pointer[i] === "properties") {
+        continue;
+      }
+      t = import_typescript.default.factory.createIndexedAccessTypeNode(
+        t,
+        import_typescript.default.factory.createLiteralTypeNode(
+          typeof pointer[i] === "number" ? import_typescript.default.factory.createNumericLiteral(pointer[i]) : import_typescript.default.factory.createStringLiteral(pointer[i])
+        )
+      );
+    }
+  }
+  return t;
+}
+function astToString(ast, options) {
+  var _a, _b;
+  const sourceFile = import_typescript.default.createSourceFile(
+    (_a = options == null ? void 0 : options.fileName) != null ? _a : "openapi-ts.ts",
+    (_b = options == null ? void 0 : options.sourceText) != null ? _b : "",
+    import_typescript.default.ScriptTarget.ESNext,
+    false,
+    import_typescript.default.ScriptKind.TS
+  );
+  sourceFile.statements = import_typescript.default.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);
+  const printer = import_typescript.default.createPrinter({
+    newLine: import_typescript.default.NewLineKind.LineFeed,
+    removeComments: false,
+    ...options == null ? void 0 : options.formatOptions
+  });
+  return printer.printFile(sourceFile);
+}
+function stringToAST(source) {
+  return import_typescript.default.createSourceFile(
+    /* fileName        */
+    "stringInput",
+    /* sourceText      */
+    source,
+    /* languageVersion */
+    import_typescript.default.ScriptTarget.ESNext,
+    /* setParentNodes  */
+    void 0,
+    /* scriptKind      */
+    void 0
+  ).statements;
+}
+function tsDedupe(types) {
+  var _a, _b;
+  const encounteredTypes = /* @__PURE__ */ new Set();
+  const filteredTypes = [];
+  for (const t of types) {
+    if (!("text" in ((_a = t.literal) != null ? _a : t))) {
+      const { kind } = (_b = t.literal) != null ? _b : t;
+      if (encounteredTypes.has(kind)) {
+        continue;
+      }
+      if (tsIsPrimitive(t)) {
+        encounteredTypes.add(kind);
+      }
+    }
+    filteredTypes.push(t);
+  }
+  return filteredTypes;
+}
+var enumCache = /* @__PURE__ */ new Map();
+function tsEnum(name, members, metadata, options) {
+  var _a;
+  let enumName = sanitizeMemberName(name);
+  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;
+  let key = "";
+  if (options == null ? void 0 : options.shouldCache) {
+    key = `${members.slice(0).sort().map((v, i) => {
+      var _a2, _b, _c;
+      return `${(_b = (_a2 = metadata == null ? void 0 : metadata[i]) == null ? void 0 : _a2.name) != null ? _b : String(v)}:${((_c = metadata == null ? void 0 : metadata[i]) == null ? void 0 : _c.description) || ""}`;
+    }).join(",")}`;
+    if (enumCache.has(key)) {
+      return enumCache.get(key);
+    }
+  }
+  const enumDeclaration = import_typescript.default.factory.createEnumDeclaration(
+    /* modifiers */
+    options ? tsModifiers({ export: (_a = options.export) != null ? _a : false }) : void 0,
+    /* name      */
+    enumName,
+    /* members   */
+    members.map((value, i) => tsEnumMember(value, metadata == null ? void 0 : metadata[i]))
+  );
+  (options == null ? void 0 : options.shouldCache) && enumCache.set(key, enumDeclaration);
+  return enumDeclaration;
+}
+function tsArrayLiteralExpression(name, elementType, values, options) {
+  var _a;
+  let variableName = sanitizeMemberName(name);
+  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;
+  const arrayType = (options == null ? void 0 : options.readonly) ? tsReadonlyArray(elementType, options.injectFooter) : import_typescript.default.factory.createArrayTypeNode(elementType);
+  return import_typescript.default.factory.createVariableStatement(
+    options ? tsModifiers({ export: (_a = options.export) != null ? _a : false }) : void 0,
+    import_typescript.default.factory.createVariableDeclarationList(
+      [
+        import_typescript.default.factory.createVariableDeclaration(
+          variableName,
+          void 0,
+          arrayType,
+          import_typescript.default.factory.createArrayLiteralExpression(
+            values.map((value) => {
+              if (typeof value === "number") {
+                if (value < 0) {
+                  return import_typescript.default.factory.createPrefixUnaryExpression(
+                    import_typescript.default.SyntaxKind.MinusToken,
+                    import_typescript.default.factory.createNumericLiteral(Math.abs(value))
+                  );
+                } else {
+                  return import_typescript.default.factory.createNumericLiteral(value);
+                }
+              } else {
+                return import_typescript.default.factory.createStringLiteral(value);
+              }
+            })
+          )
+        )
+      ],
+      import_typescript.default.NodeFlags.Const
+    )
+  );
+}
+function sanitizeMemberName(name) {
+  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c2) => {
+    const last = c2[c2.length - 1];
+    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? "" : last.toUpperCase();
+  });
+  if (Number(name[0]) >= 0) {
+    sanitizedName = `Value${name}`;
+  }
+  return sanitizedName;
+}
+function tsEnumMember(value, metadata = {}) {
+  var _a;
+  let name = (_a = metadata.name) != null ? _a : String(value);
+  if (!JS_PROPERTY_INDEX_RE.test(name)) {
+    if (Number(name[0]) >= 0) {
+      name = `Value${name}`.replace(".", "_");
+    } else if (name[0] === "-") {
+      name = `ValueMinus${name.slice(1)}`;
+    }
+    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);
+    if (invalidCharMatch) {
+      if (invalidCharMatch[0] === name) {
+        name = `"${name}"`;
+      } else {
+        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {
+          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : "_";
+        });
+      }
+    }
+  }
+  let member;
+  if (typeof value === "number") {
+    const literal = value < 0 ? import_typescript.default.factory.createPrefixUnaryExpression(
+      import_typescript.default.SyntaxKind.MinusToken,
+      import_typescript.default.factory.createNumericLiteral(Math.abs(value))
+    ) : import_typescript.default.factory.createNumericLiteral(value);
+    member = import_typescript.default.factory.createEnumMember(name, literal);
+  } else {
+    member = import_typescript.default.factory.createEnumMember(name, import_typescript.default.factory.createStringLiteral(value));
+  }
+  if (metadata.description === void 0) {
+    return member;
+  }
+  return import_typescript.default.addSyntheticLeadingComment(
+    member,
+    import_typescript.default.SyntaxKind.SingleLineCommentTrivia,
+    " ".concat(metadata.description.trim()),
+    true
+  );
+}
+function tsIntersection(types) {
+  if (types.length === 0) {
+    return NEVER;
+  }
+  if (types.length === 1) {
+    return types[0];
+  }
+  return import_typescript.default.factory.createIntersectionTypeNode(tsDedupe(types));
+}
+function tsIsPrimitive(type) {
+  if (!type) {
+    return true;
+  }
+  return import_typescript.default.SyntaxKind[type.kind] === "BooleanKeyword" || import_typescript.default.SyntaxKind[type.kind] === "NeverKeyword" || import_typescript.default.SyntaxKind[type.kind] === "NullKeyword" || import_typescript.default.SyntaxKind[type.kind] === "NumberKeyword" || import_typescript.default.SyntaxKind[type.kind] === "StringKeyword" || import_typescript.default.SyntaxKind[type.kind] === "UndefinedKeyword" || "literal" in type && tsIsPrimitive(type.literal);
+}
+function tsLiteral(value) {
+  if (typeof value === "string") {
+    return import_typescript.default.factory.createIdentifier(JSON.stringify(value));
+  }
+  if (typeof value === "number") {
+    const literal = value < 0 ? import_typescript.default.factory.createPrefixUnaryExpression(
+      import_typescript.default.SyntaxKind.MinusToken,
+      import_typescript.default.factory.createNumericLiteral(Math.abs(value))
+    ) : import_typescript.default.factory.createNumericLiteral(value);
+    return import_typescript.default.factory.createLiteralTypeNode(literal);
+  }
+  if (typeof value === "boolean") {
+    return value === true ? TRUE : FALSE;
+  }
+  if (value === null) {
+    return NULL;
+  }
+  if (Array.isArray(value)) {
+    if (value.length === 0) {
+      return import_typescript.default.factory.createArrayTypeNode(NEVER);
+    }
+    return import_typescript.default.factory.createTupleTypeNode(value.map((v) => tsLiteral(v)));
+  }
+  if (typeof value === "object") {
+    const keys = [];
+    for (const [k, v] of Object.entries(value)) {
+      keys.push(
+        import_typescript.default.factory.createPropertySignature(
+          /* modifiers     */
+          void 0,
+          /* name          */
+          tsPropertyIndex(k),
+          /* questionToken */
+          void 0,
+          /* type          */
+          tsLiteral(v)
+        )
+      );
+    }
+    return keys.length ? import_typescript.default.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);
+  }
+  return UNKNOWN;
+}
+function tsModifiers(modifiers) {
+  const typeMods = [];
+  if (modifiers.export) {
+    typeMods.push(import_typescript.default.factory.createModifier(import_typescript.default.SyntaxKind.ExportKeyword));
+  }
+  if (modifiers.readonly) {
+    typeMods.push(import_typescript.default.factory.createModifier(import_typescript.default.SyntaxKind.ReadonlyKeyword));
+  }
+  return typeMods;
+}
+function tsNullable(types) {
+  return import_typescript.default.factory.createUnionTypeNode([...types, NULL]);
+}
+function tsOmit(type, keys) {
+  return import_typescript.default.factory.createTypeReferenceNode(import_typescript.default.factory.createIdentifier("Omit"), [
+    type,
+    import_typescript.default.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k)))
+  ]);
+}
+function tsRecord(key, value) {
+  return import_typescript.default.factory.createTypeReferenceNode(import_typescript.default.factory.createIdentifier("Record"), [key, value]);
+}
+function tsPropertyIndex(index) {
+  if (typeof index === "number" && !(index < 0) || typeof index === "string" && String(Number(index)) === index && index[0] !== "-") {
+    return import_typescript.default.factory.createNumericLiteral(index);
+  }
+  return typeof index === "string" && JS_PROPERTY_INDEX_RE.test(index) ? import_typescript.default.factory.createIdentifier(index) : import_typescript.default.factory.createStringLiteral(String(index));
+}
+function tsUnion(types) {
+  if (types.length === 0) {
+    return NEVER;
+  }
+  if (types.length === 1) {
+    return types[0];
+  }
+  return import_typescript.default.factory.createUnionTypeNode(tsDedupe(types));
+}
+function tsWithRequired(type, keys, injectFooter) {
+  if (keys.length === 0) {
+    return type;
+  }
+  if (!injectFooter.some((node) => {
+    var _a;
+    return import_typescript.default.isTypeAliasDeclaration(node) && ((_a = node == null ? void 0 : node.name) == null ? void 0 : _a.escapedText) === "WithRequired";
+  })) {
+    const helper = stringToAST("type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };")[0];
+    injectFooter.push(helper);
+  }
+  return import_typescript.default.factory.createTypeReferenceNode(import_typescript.default.factory.createIdentifier("WithRequired"), [
+    type,
+    tsUnion(keys.map((k) => tsLiteral(k)))
+  ]);
+}
+function tsReadonlyArray(type, injectFooter) {
+  if (injectFooter && !injectFooter.some((node) => {
+    var _a;
+    return import_typescript.default.isTypeAliasDeclaration(node) && ((_a = node == null ? void 0 : node.name) == null ? void 0 : _a.escapedText) === "ReadonlyArray";
+  })) {
+    const helper = stringToAST(
+      "type ReadonlyArray<T> = [Exclude<T, undefined>] extends [any[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;"
+    )[0];
+    injectFooter.push(helper);
+  }
+  return import_typescript.default.factory.createTypeReferenceNode(import_typescript.default.factory.createIdentifier("ReadonlyArray"), [type]);
+}
+
+// src/lib/utils.ts
+if (!supports_color_default.stdout || supports_color_default.stdout.hasBasic === false) {
+  import_ansi_colors.default.enabled = false;
+}
+var DEBUG_GROUPS = {
+  redoc: import_ansi_colors.default.cyanBright,
+  lint: import_ansi_colors.default.yellowBright,
+  bundle: import_ansi_colors.default.magentaBright,
+  ts: import_ansi_colors.default.blueBright
+};
+function createDiscriminatorProperty(discriminator, { path, readonly = false }) {
+  let value = (0, import_ref_utils2.parseRef)(path).pointer.pop();
+  if (discriminator.mapping) {
+    const matchedValue = Object.entries(discriminator.mapping).find(
+      ([, v]) => !v.startsWith("#") && v === value || v.startsWith("#") && (0, import_ref_utils2.parseRef)(v).pointer.pop() === value
+    );
+    if (matchedValue) {
+      value = matchedValue[0];
+    }
+  }
+  return import_typescript2.default.factory.createPropertySignature(
+    /* modifiers     */
+    tsModifiers({
+      readonly
+    }),
+    /* name          */
+    tsPropertyIndex(discriminator.propertyName),
+    /* questionToken */
+    void 0,
+    /* type          */
+    tsLiteral(value)
+  );
+}
+function createRef(parts) {
+  let pointer = "#";
+  for (const part of parts) {
+    if (part === void 0 || part === null || part === "") {
+      continue;
+    }
+    const maybeRef = (0, import_ref_utils2.parseRef)(String(part)).pointer;
+    if (maybeRef.length) {
+      for (const refPart of maybeRef) {
+        pointer += `/${(0, import_ref_utils2.escapePointer)(refPart)}`;
+      }
+    } else {
+      pointer += `/${(0, import_ref_utils2.escapePointer)(part)}`;
+    }
+  }
+  return pointer;
+}
+function debug(msg, group, time) {
+  if (process.env.DEBUG && (!group || process.env.DEBUG === "*" || process.env.DEBUG === "openapi-ts:*" || process.env.DEBUG.toLocaleLowerCase() === `openapi-ts:${group.toLocaleLowerCase()}`)) {
+    const groupColor = group && DEBUG_GROUPS[group] || import_ansi_colors.default.whiteBright;
+    const groupName = groupColor(`openapi-ts:${group != null ? group : "info"}`);
+    let timeFormatted = "";
+    if (typeof time === "number") {
+      timeFormatted = import_ansi_colors.default.green(` ${formatTime(time)} `);
+    }
+    console.debug(`  ${import_ansi_colors.default.bold(groupName)}${timeFormatted}${msg}`);
+  }
+}
+function error(msg) {
+  console.error(import_ansi_colors.default.red(` \u2718  ${msg}`));
+}
+function formatTime(t) {
+  if (typeof t === "number") {
+    if (t < 1e3) {
+      return `${Math.round(10 * t) / 10}ms`;
+    }
+    if (t < 6e4) {
+      return `${Math.round(t / 100) / 10}s`;
+    }
+    return `${Math.round(t / 6e3) / 10}m`;
+  }
+  return t;
+}
+function getEntries(obj, options) {
+  let entries = Object.entries(obj);
+  if (options == null ? void 0 : options.alphabetize) {
+    entries.sort(([a], [b]) => a.localeCompare(b, "en-us", { numeric: true }));
+  }
+  if (options == null ? void 0 : options.excludeDeprecated) {
+    entries = entries.filter(([, v]) => !(v && typeof v === "object" && "deprecated" in v && v.deprecated));
+  }
+  return entries;
+}
+function resolveRef(schema, $ref, { silent = false, visited = [] }) {
+  const { pointer } = (0, import_ref_utils2.parseRef)($ref);
+  if (!pointer.length) {
+    return void 0;
+  }
+  let node = schema;
+  for (const key of pointer) {
+    if (node && typeof node === "object" && node[key]) {
+      node = node[key];
+    } else {
+      warn(`Could not resolve $ref "${$ref}"`, silent);
+      return void 0;
+    }
+  }
+  if (node && typeof node === "object" && node.$ref) {
+    if (visited.includes(node.$ref)) {
+      warn(`Could not resolve circular $ref "${$ref}"`, silent);
+      return void 0;
+    }
+    return resolveRef(schema, node.$ref, {
+      silent,
+      visited: [...visited, node.$ref]
+    });
+  }
+  return node;
+}
+function createDiscriminatorEnum(values, prevSchema) {
+  return {
+    type: "string",
+    enum: values,
+    description: (prevSchema == null ? void 0 : prevSchema.description) ? `${prevSchema.description} (enum property replaced by openapi-typescript)` : "discriminator enum property added by openapi-typescript"
+  };
+}
+function patchDiscriminatorEnum(schema, ref, values, discriminator, discriminatorRef, options) {
+  var _a;
+  const resolvedSchema = resolveRef(schema, ref, {
+    silent: (_a = options.silent) != null ? _a : false
+  });
+  if (resolvedSchema == null ? void 0 : resolvedSchema.allOf) {
+    resolvedSchema.allOf.push({
+      type: "object",
+      // discriminator enum properties always need to be required
+      required: [discriminator.propertyName],
+      properties: {
+        [discriminator.propertyName]: createDiscriminatorEnum(values)
+      }
+    });
+    return true;
+  } else if (typeof resolvedSchema === "object" && "type" in resolvedSchema && resolvedSchema.type === "object") {
+    if (!resolvedSchema.properties) {
+      resolvedSchema.properties = {};
+    }
+    if (!resolvedSchema.required) {
+      resolvedSchema.required = [discriminator.propertyName];
+    } else if (!resolvedSchema.required.includes(discriminator.propertyName)) {
+      resolvedSchema.required.push(discriminator.propertyName);
+    }
+    resolvedSchema.properties[discriminator.propertyName] = createDiscriminatorEnum(
+      values,
+      resolvedSchema.properties[discriminator.propertyName]
+    );
+    return true;
+  }
+  warn(
+    `Discriminator mapping has an invalid schema (neither an object schema nor an allOf array): ${ref} => ${values.join(
+      ", "
+    )} (Discriminator: ${discriminatorRef})`,
+    options.silent
+  );
+  return false;
+}
+function scanDiscriminators(schema, options) {
+  const objects = {};
+  const refsHandled = [];
+  walk(schema, (obj, path) => {
+    var _a, _b;
+    const discriminator = obj == null ? void 0 : obj.discriminator;
+    if (!(discriminator == null ? void 0 : discriminator.propertyName)) {
+      return;
+    }
+    const ref = createRef(path);
+    objects[ref] = discriminator;
+    if (!(obj == null ? void 0 : obj.oneOf) || !Array.isArray(obj.oneOf)) {
+      return;
+    }
+    const oneOf = obj.oneOf;
+    const mapping = {};
+    for (const item of oneOf) {
+      if ("$ref" in item) {
+        const value = item.$ref.split("/").pop();
+        if (value) {
+          if (!mapping[item.$ref]) {
+            mapping[item.$ref] = { inferred: value };
+          } else {
+            mapping[item.$ref].inferred = value;
+          }
+        }
+      }
+    }
+    if (discriminator.mapping) {
+      for (const mappedValue in discriminator.mapping) {
+        const mappedRef = discriminator.mapping[mappedValue];
+        if (!mappedRef) {
+          continue;
+        }
+        if (!((_a = mapping[mappedRef]) == null ? void 0 : _a.defined)) {
+          mapping[mappedRef] = { defined: [] };
+        }
+        (_b = mapping[mappedRef].defined) == null ? void 0 : _b.push(mappedValue);
+      }
+    }
+    for (const [mappedRef, { inferred, defined }] of Object.entries(mapping)) {
+      if (refsHandled.includes(mappedRef)) {
+        continue;
+      }
+      if (!inferred && !defined) {
+        continue;
+      }
+      const mappedValues = defined != null ? defined : [inferred];
+      if (patchDiscriminatorEnum(schema, mappedRef, mappedValues, discriminator, ref, options)) {
+        refsHandled.push(mappedRef);
+      }
+    }
+  });
+  walk(schema, (obj, path) => {
+    var _a;
+    if (!obj || !Array.isArray(obj.allOf)) {
+      return;
+    }
+    for (const item of obj.allOf) {
+      if ("$ref" in item) {
+        if (!objects[item.$ref]) {
+          return;
+        }
+        const ref = createRef(path);
+        const discriminator = objects[item.$ref];
+        const mappedValues = [];
+        if (discriminator.mapping) {
+          for (const mappedValue in discriminator.mapping) {
+            if (discriminator.mapping[mappedValue] === ref) {
+              mappedValues.push(mappedValue);
+            }
+          }
+          if (mappedValues.length > 0) {
+            if (patchDiscriminatorEnum(
+              schema,
+              ref,
+              mappedValues,
+              discriminator,
+              item.$ref,
+              options
+            )) {
+              refsHandled.push(ref);
+            }
+          }
+        }
+        objects[ref] = {
+          ...objects[item.$ref]
+        };
+      } else if ((_a = item.discriminator) == null ? void 0 : _a.propertyName) {
+        objects[createRef(path)] = { ...item.discriminator };
+      }
+    }
+  });
+  return { objects, refsHandled };
+}
+function walk(obj, cb, path = []) {
+  if (!obj || typeof obj !== "object") {
+    return;
+  }
+  if (Array.isArray(obj)) {
+    for (let i = 0; i < obj.length; i++) {
+      walk(obj[i], cb, path.concat(i));
+    }
+    return;
+  }
+  cb(obj, path);
+  for (const k of Object.keys(obj)) {
+    walk(obj[k], cb, path.concat(k));
+  }
+}
+function warn(msg, silent = false) {
+  if (!silent) {
+    console.warn(import_ansi_colors.default.yellow(` \u26A0  ${msg}`));
+  }
+}
+
+// src/lib/redoc.ts
+async function parseSchema(schema, { absoluteRef, resolver }) {
+  if (!schema) {
+    throw new Error("Can\u2019t parse empty schema");
+  }
+  if (schema instanceof URL) {
+    const result = await resolver.resolveDocument(null, absoluteRef, true);
+    if ("parsed" in result) {
+      return result;
+    }
+    throw result.originalError;
+  }
+  if (schema instanceof import_node_stream.Readable) {
+    const contents = await new Promise((resolve) => {
+      schema.resume();
+      schema.setEncoding("utf8");
+      let content = "";
+      schema.on("data", (chunk) => {
+        content += chunk;
+      });
+      schema.on("end", () => {
+        resolve(content.trim());
+      });
+    });
+    return parseSchema(contents, { absoluteRef, resolver });
+  }
+  if (schema instanceof Buffer) {
+    return parseSchema(schema.toString("utf8"), { absoluteRef, resolver });
+  }
+  if (typeof schema === "string") {
+    if (schema.startsWith("http://") || schema.startsWith("https://") || schema.startsWith("file://")) {
+      const url = new URL(schema);
+      return parseSchema(url, {
+        absoluteRef: url.protocol === "file:" ? (0, import_node_url.fileURLToPath)(url) : url.href,
+        resolver
+      });
+    }
+    if (schema[0] === "{") {
+      return {
+        source: new import_openapi_core.Source(absoluteRef, schema, "application/json"),
+        parsed: parseJson(schema)
+      };
+    }
+    return (0, import_openapi_core.makeDocumentFromString)(schema, absoluteRef);
+  }
+  if (typeof schema === "object" && !Array.isArray(schema)) {
+    return {
+      source: new import_openapi_core.Source(absoluteRef, JSON.stringify(schema), "application/json"),
+      parsed: schema
+    };
+  }
+  throw new Error(`Expected string, object, or Buffer. Got ${Array.isArray(schema) ? "Array" : typeof schema}`);
+}
+function _processProblems(problems, options) {
+  var _a;
+  if (problems.length) {
+    let errorMessage = void 0;
+    for (const problem of problems) {
+      const problemLocation = (_a = problem.location) == null ? void 0 : _a[0].pointer;
+      const problemMessage = problemLocation ? `${problem.message} at ${problemLocation}` : problem.message;
+      if (problem.severity === "error") {
+        errorMessage = problemMessage;
+        error(problemMessage);
+      } else {
+        warn(problemMessage, options.silent);
+      }
+    }
+    if (errorMessage) {
+      throw new Error(errorMessage);
+    }
+  }
+}
+async function validateAndBundle(source, options) {
+  var _a;
+  const redocConfigT = import_node_perf_hooks.performance.now();
+  debug("Loaded Redoc config", "redoc", import_node_perf_hooks.performance.now() - redocConfigT);
+  const redocParseT = import_node_perf_hooks.performance.now();
+  let absoluteRef = (0, import_node_url.fileURLToPath)(new URL((_a = options == null ? void 0 : options.cwd) != null ? _a : `file://${process.cwd()}/`));
+  if (source instanceof URL) {
+    absoluteRef = source.protocol === "file:" ? (0, import_node_url.fileURLToPath)(source) : source.href;
+  }
+  const resolver = new import_openapi_core.BaseResolver(options.redoc.resolve);
+  const document = await parseSchema(source, {
+    absoluteRef,
+    resolver
+  });
+  debug("Parsed schema", "redoc", import_node_perf_hooks.performance.now() - redocParseT);
+  const openapiVersion = Number.parseFloat(document.parsed.openapi);
+  if (document.parsed.swagger || !document.parsed.openapi || Number.isNaN(openapiVersion) || openapiVersion < 3 || openapiVersion >= 4) {
+    if (document.parsed.swagger) {
+      throw new Error("Unsupported Swagger version: 2.x. Use OpenAPI 3.x instead.");
+    }
+    if (document.parsed.openapi || openapiVersion < 3 || openapiVersion >= 4) {
+      throw new Error(`Unsupported OpenAPI version: ${document.parsed.openapi}`);
+    }
+    throw new Error("Unsupported schema format, expected `openapi: 3.x`");
+  }
+  const redocLintT = import_node_perf_hooks.performance.now();
+  const problems = await (0, import_openapi_core.lintDocument)({
+    document,
+    config: options.redoc.styleguide,
+    externalRefResolver: resolver
+  });
+  _processProblems(problems, options);
+  debug("Linted schema", "lint", import_node_perf_hooks.performance.now() - redocLintT);
+  const redocBundleT = import_node_perf_hooks.performance.now();
+  const bundled = await (0, import_openapi_core.bundle)({
+    config: options.redoc,
+    dereference: false,
+    doc: document
+  });
+  _processProblems(bundled.problems, options);
+  debug("Bundled schema", "bundle", import_node_perf_hooks.performance.now() - redocBundleT);
+  return bundled.bundle.parsed;
+}
+
+// src/transform/index.ts
+var import_typescript14 = __toESM(require("typescript"), 1);
+var import_node_perf_hooks4 = require("node:perf_hooks");
+
+// src/transform/components-object.ts
+var import_typescript11 = __toESM(require("typescript"), 1);
+
+// ../../node_modules/.pnpm/change-case@5.4.4/node_modules/change-case/dist/index.js
+var SPLIT_LOWER_UPPER_RE = /([\p{Ll}\d])(\p{Lu})/gu;
+var SPLIT_UPPER_UPPER_RE = /(\p{Lu})([\p{Lu}][\p{Ll}])/gu;
+var SPLIT_SEPARATE_NUMBER_RE = /(\d)\p{Ll}|(\p{L})\d/u;
+var DEFAULT_STRIP_REGEXP = /[^\p{L}\d]+/giu;
+var SPLIT_REPLACE_VALUE = "$1\0$2";
+var DEFAULT_PREFIX_SUFFIX_CHARACTERS = "";
+function split(value) {
+  let result = value.trim();
+  result = result.replace(SPLIT_LOWER_UPPER_RE, SPLIT_REPLACE_VALUE).replace(SPLIT_UPPER_UPPER_RE, SPLIT_REPLACE_VALUE);
+  result = result.replace(DEFAULT_STRIP_REGEXP, "\0");
+  let start = 0;
+  let end = result.length;
+  while (result.charAt(start) === "\0")
+    start++;
+  if (start === end)
+    return [];
+  while (result.charAt(end - 1) === "\0")
+    end--;
+  return result.slice(start, end).split(/\0/g);
+}
+function splitSeparateNumbers(value) {
+  var _a;
+  const words = split(value);
+  for (let i = 0; i < words.length; i++) {
+    const word = words[i];
+    const match = SPLIT_SEPARATE_NUMBER_RE.exec(word);
+    if (match) {
+      const offset = match.index + ((_a = match[1]) != null ? _a : match[2]).length;
+      words.splice(i, 1, word.slice(0, offset), word.slice(offset));
+    }
+  }
+  return words;
+}
+function pascalCase(input, options) {
+  var _a;
+  const [prefix, words, suffix] = splitPrefixSuffix(input, options);
+  const lower = lowerFactory(options == null ? void 0 : options.locale);
+  const upper = upperFactory(options == null ? void 0 : options.locale);
+  const transform = (options == null ? void 0 : options.mergeAmbiguousCharacters) ? capitalCaseTransformFactory(lower, upper) : pascalCaseTransformFactory(lower, upper);
+  return prefix + words.map(transform).join((_a = options == null ? void 0 : options.delimiter) != null ? _a : "") + suffix;
+}
+function lowerFactory(locale) {
+  return locale === false ? (input) => input.toLowerCase() : (input) => input.toLocaleLowerCase(locale);
+}
+function upperFactory(locale) {
+  return locale === false ? (input) => input.toUpperCase() : (input) => input.toLocaleUpperCase(locale);
+}
+function capitalCaseTransformFactory(lower, upper) {
+  return (word) => `${upper(word[0])}${lower(word.slice(1))}`;
+}
+function pascalCaseTransformFactory(lower, upper) {
+  return (word, index) => {
+    const char0 = word[0];
+    const initial = index > 0 && char0 >= "0" && char0 <= "9" ? "_" + char0 : upper(char0);
+    return initial + lower(word.slice(1));
+  };
+}
+function splitPrefixSuffix(input, options = {}) {
+  var _a, _b, _c;
+  const splitFn = (_a = options.split) != null ? _a : options.separateNumbers ? splitSeparateNumbers : split;
+  const prefixCharacters = (_b = options.prefixCharacters) != null ? _b : DEFAULT_PREFIX_SUFFIX_CHARACTERS;
+  const suffixCharacters = (_c = options.suffixCharacters) != null ? _c : DEFAULT_PREFIX_SUFFIX_CHARACTERS;
+  let prefixIndex = 0;
+  let suffixIndex = input.length;
+  while (prefixIndex < input.length) {
+    const char = input.charAt(prefixIndex);
+    if (!prefixCharacters.includes(char))
+      break;
+    prefixIndex++;
+  }
+  while (suffixIndex > prefixIndex) {
+    const index = suffixIndex - 1;
+    const char = input.charAt(index);
+    if (!suffixCharacters.includes(char))
+      break;
+    suffixIndex = index;
+  }
+  return [
+    input.slice(0, prefixIndex),
+    splitFn(input.slice(prefixIndex, suffixIndex)),
+    input.slice(suffixIndex)
+  ];
+}
+
+// src/transform/components-object.ts
+var import_node_perf_hooks2 = require("node:perf_hooks");
+
+// src/transform/header-object.ts
+var import_ref_utils4 = require("@redocly/openapi-core/lib/ref-utils.js");
+var import_typescript4 = __toESM(require("typescript"), 1);
+
+// src/transform/schema-object.ts
+var import_ref_utils3 = require("@redocly/openapi-core/lib/ref-utils.js");
+var import_typescript3 = __toESM(require("typescript"), 1);
+function transformSchemaObject(schemaObject, options) {
+  const type = transformSchemaObjectWithComposition(schemaObject, options);
+  if (typeof options.ctx.postTransform === "function") {
+    const postTransformResult = options.ctx.postTransform(type, options);
+    if (postTransformResult) {
+      return postTransformResult;
+    }
+  }
+  return type;
+}
+function transformSchemaObjectWithComposition(schemaObject, options) {
+  var _a, _b, _c, _d, _e;
+  if (!schemaObject) {
+    return NEVER;
+  }
+  if (schemaObject === true) {
+    return UNKNOWN;
+  }
+  if (Array.isArray(schemaObject) || typeof schemaObject !== "object") {
+    throw new Error(
+      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? "Array" : typeof schemaObject} at ${options.path}`
+    );
+  }
+  if ("$ref" in schemaObject) {
+    return oapiRef(schemaObject.$ref);
+  }
+  if (schemaObject.const !== null && schemaObject.const !== void 0) {
+    return tsLiteral(schemaObject.const);
+  }
+  if (Array.isArray(schemaObject.enum) && (!("type" in schemaObject) || schemaObject.type !== "object") && !("properties" in schemaObject) && !("additionalProperties" in schemaObject)) {
+    if (options.ctx.enum && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number" || v === null)) {
+      let enumName = (0, import_ref_utils3.parseRef)((_a = options.path) != null ? _a : "").pointer.join("/");
+      enumName = enumName.replace("components/schemas", "");
+      const metadata = schemaObject.enum.map((_, i) => {
+        var _a2, _b2, _c2, _d2, _e2, _f;
+        return {
+          name: (_c2 = (_a2 = schemaObject["x-enum-varnames"]) == null ? void 0 : _a2[i]) != null ? _c2 : (_b2 = schemaObject["x-enumNames"]) == null ? void 0 : _b2[i],
+          description: (_f = (_d2 = schemaObject["x-enum-descriptions"]) == null ? void 0 : _d2[i]) != null ? _f : (_e2 = schemaObject["x-enumDescriptions"]) == null ? void 0 : _e2[i]
+        };
+      });
+      let hasNull = false;
+      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {
+        if (enumValue === null) {
+          hasNull = true;
+          return false;
+        }
+        return true;
+      });
+      const enumType2 = tsEnum(enumName, validSchemaEnums, metadata, {
+        shouldCache: options.ctx.dedupeEnums,
+        export: true
+        // readonly: TS enum do not support the readonly modifier
+      });
+      if (!options.ctx.injectFooter.includes(enumType2)) {
+        options.ctx.injectFooter.push(enumType2);
+      }
+      const ref = import_typescript3.default.factory.createTypeReferenceNode(enumType2.name);
+      return hasNull ? tsUnion([ref, NULL]) : ref;
+    }
+    const enumType = schemaObject.enum.map(tsLiteral);
+    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes("null") || schemaObject.nullable) && !schemaObject.default) {
+      enumType.push(NULL);
+    }
+    const unionType = tsUnion(enumType);
+    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number")) {
+      let enumValuesVariableName = (0, import_ref_utils3.parseRef)((_b = options.path) != null ? _b : "").pointer.join("/");
+      enumValuesVariableName = enumValuesVariableName.replace("components/schemas", "");
+      enumValuesVariableName = `${enumValuesVariableName}Values`;
+      const enumValuesArray = tsArrayLiteralExpression(
+        enumValuesVariableName,
+        oapiRef((_c = options.path) != null ? _c : ""),
+        schemaObject.enum,
+        {
+          export: true,
+          readonly: true,
+          injectFooter: options.ctx.injectFooter
+        }
+      );
+      options.ctx.injectFooter.push(enumValuesArray);
+    }
+    return unionType;
+  }
+  function collectUnionCompositions(items) {
+    const output = [];
+    for (const item of items) {
+      output.push(transformSchemaObject(item, options));
+    }
+    return output;
+  }
+  function collectAllOfCompositions(items, required) {
+    const output = [];
+    for (const item of items) {
+      let itemType;
+      if ("$ref" in item) {
+        itemType = transformSchemaObject(item, options);
+        const resolved = options.ctx.resolve(item.$ref);
+        if (resolved && typeof resolved === "object" && "properties" in resolved && // we have already handled this item (discriminator property was already added as required)
+        !options.ctx.discriminators.refsHandled.includes(item.$ref)) {
+          const validRequired = (required != null ? required : []).filter((key) => {
+            var _a2;
+            return !!((_a2 = resolved.properties) == null ? void 0 : _a2[key]);
+          });
+          if (validRequired.length) {
+            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);
+          }
+        }
+      } else {
+        const itemRequired = [...required != null ? required : []];
+        if (typeof item === "object" && Array.isArray(item.required)) {
+          itemRequired.push(...item.required);
+        }
+        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);
+      }
+      output.push(itemType);
+    }
+    return output;
+  }
+  let finalType = void 0;
+  const coreObjectType = transformSchemaObjectCore(schemaObject, options);
+  const allOfType = collectAllOfCompositions((_d = schemaObject.allOf) != null ? _d : [], schemaObject.required);
+  if (coreObjectType || allOfType.length) {
+    const allOf = allOfType.length ? tsIntersection(allOfType) : void 0;
+    finalType = tsIntersection([...coreObjectType ? [coreObjectType] : [], ...allOf ? [allOf] : []]);
+  }
+  const anyOfType = collectUnionCompositions((_e = schemaObject.anyOf) != null ? _e : []);
+  if (anyOfType.length) {
+    finalType = tsUnion([...finalType ? [finalType] : [], ...anyOfType]);
+  }
+  const oneOfType = collectUnionCompositions(
+    schemaObject.oneOf || "type" in schemaObject && schemaObject.type === "object" && schemaObject.enum || []
+  );
+  if (oneOfType.length) {
+    if (oneOfType.every(tsIsPrimitive)) {
+      finalType = tsUnion([...finalType ? [finalType] : [], ...oneOfType]);
+    } else {
+      finalType = tsIntersection([...finalType ? [finalType] : [], tsUnion(oneOfType)]);
+    }
+  }
+  if (!finalType) {
+    if ("type" in schemaObject) {
+      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);
+    } else {
+      finalType = UNKNOWN;
+    }
+  }
+  if (finalType !== UNKNOWN && schemaObject.nullable && !schemaObject.default) {
+    finalType = tsNullable([finalType]);
+  }
+  return finalType;
+}
+function transformSchemaObjectCore(schemaObject, options) {
+  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
+  if ("type" in schemaObject && schemaObject.type) {
+    if (typeof options.ctx.transform === "function") {
+      const result = options.ctx.transform(schemaObject, options);
+      if (result && typeof result === "object") {
+        if ("schema" in result) {
+          if (result.questionToken) {
+            return import_typescript3.default.factory.createUnionTypeNode([result.schema, UNDEFINED]);
+          } else {
+            return result.schema;
+          }
+        } else {
+          return result;
+        }
+      }
+    }
+    if (schemaObject.type === "null") {
+      return NULL;
+    }
+    if (schemaObject.type === "string") {
+      return STRING;
+    }
+    if (schemaObject.type === "number" || schemaObject.type === "integer") {
+      return NUMBER;
+    }
+    if (schemaObject.type === "boolean") {
+      return BOOLEAN;
+    }
+    if (schemaObject.type === "array") {
+      let itemType = UNKNOWN;
+      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {
+        const prefixItems = (_a = schemaObject.prefixItems) != null ? _a : schemaObject.items;
+        itemType = import_typescript3.default.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));
+      } else if (schemaObject.items) {
+        if ("type" in schemaObject.items && schemaObject.items.type === "array") {
+          itemType = import_typescript3.default.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));
+        } else {
+          itemType = transformSchemaObject(schemaObject.items, options);
+        }
+      }
+      const min = typeof schemaObject.minItems === "number" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;
+      const max = typeof schemaObject.maxItems === "number" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems ? schemaObject.maxItems : void 0;
+      const estimateCodeSize = typeof max !== "number" ? min : (max * (max + 1) - min * (min - 1)) / 2;
+      if (options.ctx.arrayLength && (min !== 0 || max !== void 0) && estimateCodeSize < 30) {
+        if (min === max) {
+          const elements = [];
+          for (let i = 0; i < min; i++) {
+            elements.push(itemType);
+          }
+          return tsUnion([import_typescript3.default.factory.createTupleTypeNode(elements)]);
+        } else if (schemaObject.maxItems > 0) {
+          const members = [];
+          for (let i = 0; i <= (max != null ? max : 0) - min; i++) {
+            const elements = [];
+            for (let j = min; j < i + min; j++) {
+              elements.push(itemType);
+            }
+            members.push(import_typescript3.default.factory.createTupleTypeNode(elements));
+          }
+          return tsUnion(members);
+        } else {
+          const elements = [];
+          for (let i = 0; i < min; i++) {
+            elements.push(itemType);
+          }
+          elements.push(import_typescript3.default.factory.createRestTypeNode(import_typescript3.default.factory.createArrayTypeNode(itemType)));
+          return import_typescript3.default.factory.createTupleTypeNode(elements);
+        }
+      }
+      const finalType = import_typescript3.default.isTupleTypeNode(itemType) || import_typescript3.default.isArrayTypeNode(itemType) ? itemType : import_typescript3.default.factory.createArrayTypeNode(itemType);
+      return options.ctx.immutable ? import_typescript3.default.factory.createTypeOperatorNode(import_typescript3.default.SyntaxKind.ReadonlyKeyword, finalType) : finalType;
+    }
+    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {
+      const uniqueTypes = [];
+      if (Array.isArray(schemaObject.oneOf)) {
+        for (const t of schemaObject.type) {
+          if ((t === "boolean" || t === "string" || t === "number" || t === "integer" || t === "null") && schemaObject.oneOf.find((o) => typeof o === "object" && "type" in o && o.type === t)) {
+            continue;
+          }
+          uniqueTypes.push(
+            t === "null" || t === null ? NULL : transformSchemaObject(
+              { ...schemaObject, type: t, oneOf: void 0 },
+              // don’t stack oneOf transforms
+              options
+            )
+          );
+        }
+      } else {
+        for (const t of schemaObject.type) {
+          if (t === "null" || t === null) {
+            if (!schemaObject.default) {
+              uniqueTypes.push(NULL);
+            }
+          } else {
+            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t }, options));
+          }
+        }
+      }
+      return tsUnion(uniqueTypes);
+    }
+  }
+  const coreObjectType = [];
+  for (const k of ["allOf", "anyOf"]) {
+    if (!schemaObject[k]) {
+      continue;
+    }
+    const discriminator = !schemaObject.discriminator && !options.ctx.discriminators.refsHandled.includes((_b = options.path) != null ? _b : "") && options.ctx.discriminators.objects[(_c = options.path) != null ? _c : ""];
+    if (discriminator) {
+      coreObjectType.unshift(
+        createDiscriminatorProperty(discriminator, {
+          path: (_d = options.path) != null ? _d : "",
+          readonly: options.ctx.immutable
+        })
+      );
+      break;
+    }
+  }
+  if ("properties" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length || "additionalProperties" in schemaObject && schemaObject.additionalProperties || "$defs" in schemaObject && schemaObject.$defs) {
+    if (Object.keys((_e = schemaObject.properties) != null ? _e : {}).length) {
+      for (const [k, v] of getEntries((_f = schemaObject.properties) != null ? _f : {}, options.ctx)) {
+        if (typeof v !== "object" || Array.isArray(v)) {
+          throw new Error(
+            `${options.path}: invalid property ${k}. Expected Schema Object, got ${Array.isArray(v) ? "Array" : typeof v}`
+          );
+        }
+        if (options.ctx.excludeDeprecated) {
+          const resolved = "$ref" in v ? options.ctx.resolve(v.$ref) : v;
+          if (resolved == null ? void 0 : resolved.deprecated) {
+            continue;
+          }
+        }
+        let optional = ((_g = schemaObject.required) == null ? void 0 : _g.includes(k)) || schemaObject.required === void 0 && options.ctx.propertiesRequiredByDefault || "default" in v && options.ctx.defaultNonNullable && !((_h = options.path) == null ? void 0 : _h.includes("parameters")) && !((_i = options.path) == null ? void 0 : _i.includes("requestBody")) && !((_j = options.path) == null ? void 0 : _j.includes("requestBodies")) ? void 0 : QUESTION_TOKEN;
+        let type = "$ref" in v ? oapiRef(v.$ref) : transformSchemaObject(v, {
+          ...options,
+          path: createRef([options.path, k])
+        });
+        if (typeof options.ctx.transform === "function") {
+          const result = options.ctx.transform(v, options);
+          if (result && typeof result === "object") {
+            if ("schema" in result) {
+              type = result.schema;
+              optional = result.questionToken ? QUESTION_TOKEN : optional;
+            } else {
+              type = result;
+            }
+          }
+        }
+        const property = import_typescript3.default.factory.createPropertySignature(
+          /* modifiers     */
+          tsModifiers({
+            readonly: options.ctx.immutable || "readOnly" in v && !!v.readOnly
+          }),
+          /* name          */
+          tsPropertyIndex(k),
+          /* questionToken */
+          optional,
+          /* type          */
+          type
+        );
+        addJSDocComment(v, property);
+        coreObjectType.push(property);
+      }
+    }
+    if (schemaObject.$defs && typeof schemaObject.$defs === "object" && Object.keys(schemaObject.$defs).length) {
+      const defKeys = [];
+      for (const [k, v] of Object.entries(schemaObject.$defs)) {
+        const property = import_typescript3.default.factory.createPropertySignature(
+          /* modifiers    */
+          tsModifiers({
+            readonly: options.ctx.immutable || "readonly" in v && !!v.readOnly
+          }),
+          /* name          */
+          tsPropertyIndex(k),
+          /* questionToken */
+          void 0,
+          /* type          */
+          transformSchemaObject(v, {
+            ...options,
+            path: createRef([options.path, "$defs", k])
+          })
+        );
+        addJSDocComment(v, property);
+        defKeys.push(property);
+      }
+      coreObjectType.push(
+        import_typescript3.default.factory.createPropertySignature(
+          /* modifiers     */
+          void 0,
+          /* name          */
+          tsPropertyIndex("$defs"),
+          /* questionToken */
+          void 0,
+          /* type          */
+          import_typescript3.default.factory.createTypeLiteralNode(defKeys)
+        )
+      );
+    }
+    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {
+      const hasExplicitAdditionalProperties = typeof schemaObject.additionalProperties === "object" && Object.keys(schemaObject.additionalProperties).length;
+      const addlType = hasExplicitAdditionalProperties ? transformSchemaObject(schemaObject.additionalProperties, options) : UNKNOWN;
+      return tsIntersection([
+        ...coreObjectType.length ? [import_typescript3.default.factory.createTypeLiteralNode(coreObjectType)] : [],
+        import_typescript3.default.factory.createTypeLiteralNode([
+          import_typescript3.default.factory.createIndexSignature(
+            /* modifiers  */
+            tsModifiers({
+              readonly: options.ctx.immutable
+            }),
+            /* parameters */
+            [
+              import_typescript3.default.factory.createParameterDeclaration(
+                /* modifiers      */
+                void 0,
+                /* dotDotDotToken */
+                void 0,
+                /* name           */
+                import_typescript3.default.factory.createIdentifier("key"),
+                /* questionToken  */
+                void 0,
+                /* type           */
+                STRING
+              )
+            ],
+            /* type       */
+            addlType
+          )
+        ])
+      ]);
+    }
+  }
+  return coreObjectType.length ? import_typescript3.default.factory.createTypeLiteralNode(coreObjectType) : void 0;
+}
+
+// src/transform/media-type-object.ts
+function transformMediaTypeObject(mediaTypeObject, options) {
+  if (!mediaTypeObject.schema) {
+    return UNKNOWN;
+  }
+  return transformSchemaObject(mediaTypeObject.schema, options);
+}
+
+// src/transform/header-object.ts
+function transformHeaderObject(headerObject, options) {
+  var _a, _b;
+  if (headerObject.schema) {
+    return transformSchemaObject(headerObject.schema, options);
+  }
+  if (headerObject.content) {
+    const type = [];
+    for (const [contentType, mediaTypeObject] of getEntries((_a = headerObject.content) != null ? _a : {}, options.ctx)) {
+      const nextPath = `${(_b = options.path) != null ? _b : "#"}/${(0, import_ref_utils4.escapePointer)(contentType)}`;
+      const mediaType = "$ref" in mediaTypeObject ? transformSchemaObject(mediaTypeObject, {
+        ...options,
+        path: nextPath
+      }) : transformMediaTypeObject(mediaTypeObject, {
+        ...options,
+        path: nextPath
+      });
+      const property = import_typescript4.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(contentType),
+        /* questionToken */
+        void 0,
+        /* type          */
+        mediaType
+      );
+      addJSDocComment(mediaTypeObject, property);
+      type.push(property);
+    }
+    return import_typescript4.default.factory.createTypeLiteralNode(type);
+  }
+  return UNKNOWN;
+}
+
+// src/transform/parameter-object.ts
+function transformParameterObject(parameterObject, options) {
+  return parameterObject.schema ? transformSchemaObject(parameterObject.schema, options) : STRING;
+}
+
+// src/transform/path-item-object.ts
+var import_typescript10 = __toESM(require("typescript"), 1);
+
+// src/transform/operation-object.ts
+var import_typescript9 = __toESM(require("typescript"), 1);
+
+// src/transform/parameters-array.ts
+var import_typescript5 = __toESM(require("typescript"), 1);
+var PATH_PARAM_RE = /\{([^}]+)\}/g;
+function createPathParameter(paramName) {
+  return {
+    name: paramName,
+    in: "path",
+    required: true,
+    schema: { type: "string" }
+  };
+}
+function extractPathParamsFromUrl(path) {
+  const params = [];
+  const matches = path.match(PATH_PARAM_RE);
+  if (matches) {
+    for (const match of matches) {
+      const paramName = match.slice(1, -1);
+      params.push(createPathParameter(paramName));
+    }
+  }
+  return params;
+}
+function transformParametersArray(parametersArray, options) {
+  const type = [];
+  const workingParameters = [...parametersArray];
+  if (options.ctx.generatePathParams && options.path) {
+    const pathString = Array.isArray(options.path) ? options.path[0] : options.path;
+    if (typeof pathString === "string") {
+      const pathParams = extractPathParamsFromUrl(pathString);
+      for (const param of pathParams) {
+        const exists = workingParameters.some((p) => {
+          const resolved = "$ref" in p ? options.ctx.resolve(p.$ref) : p;
+          return (resolved == null ? void 0 : resolved.in) === "path" && (resolved == null ? void 0 : resolved.name) === param.name;
+        });
+        if (!exists) {
+          workingParameters.push(param);
+        }
+      }
+    }
+  }
+  const paramType = [];
+  for (const paramIn of ["query", "header", "path", "cookie"]) {
+    const paramLocType = [];
+    let operationParameters = workingParameters.map((param) => ({
+      original: param,
+      resolved: "$ref" in param ? options.ctx.resolve(param.$ref) : param
+    }));
+    if (options.ctx.alphabetize) {
+      operationParameters.sort((a, b) => {
+        var _a, _b, _c, _d;
+        return ((_b = (_a = a.resolved) == null ? void 0 : _a.name) != null ? _b : "").localeCompare((_d = (_c = b.resolved) == null ? void 0 : _c.name) != null ? _d : "");
+      });
+    }
+    if (options.ctx.excludeDeprecated) {
+      operationParameters = operationParameters.filter(
+        ({ resolved }) => {
+          var _a;
+          return !(resolved == null ? void 0 : resolved.deprecated) && !((_a = resolved == null ? void 0 : resolved.schema) == null ? void 0 : _a.deprecated);
+        }
+      );
+    }
+    for (const { original, resolved } of operationParameters) {
+      if ((resolved == null ? void 0 : resolved.in) !== paramIn) {
+        continue;
+      }
+      let optional = void 0;
+      if (paramIn !== "path" && !resolved.required) {
+        optional = QUESTION_TOKEN;
+      }
+      const subType = "$ref" in original ? oapiRef(original.$ref) : transformParameterObject(resolved, {
+        ...options,
+        path: createRef([options.path, "parameters", resolved.in, resolved.name])
+      });
+      const property = import_typescript5.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(resolved == null ? void 0 : resolved.name),
+        /* questionToken */
+        optional,
+        /* type          */
+        subType
+      );
+      addJSDocComment(resolved, property);
+      paramLocType.push(property);
+    }
+    const allOptional = paramLocType.every((node) => !!node.questionToken);
+    paramType.push(
+      import_typescript5.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(paramIn),
+        /* questionToken */
+        allOptional || !paramLocType.length ? QUESTION_TOKEN : void 0,
+        /* type          */
+        paramLocType.length ? import_typescript5.default.factory.createTypeLiteralNode(paramLocType) : NEVER
+      )
+    );
+  }
+  type.push(
+    import_typescript5.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex("parameters"),
+      /* questionToken */
+      !paramType.length ? QUESTION_TOKEN : void 0,
+      /* type          */
+      paramType.length ? import_typescript5.default.factory.createTypeLiteralNode(paramType) : NEVER
+    )
+  );
+  return type;
+}
+
+// src/transform/request-body-object.ts
+var import_typescript6 = __toESM(require("typescript"), 1);
+function transformRequestBodyObject(requestBodyObject, options) {
+  var _a;
+  const type = [];
+  for (const [contentType, mediaTypeObject] of getEntries((_a = requestBodyObject.content) != null ? _a : {}, options.ctx)) {
+    const nextPath = createRef([options.path, contentType]);
+    const mediaType = "$ref" in mediaTypeObject ? transformSchemaObject(mediaTypeObject, {
+      ...options,
+      path: nextPath
+    }) : transformMediaTypeObject(mediaTypeObject, {
+      ...options,
+      path: nextPath
+    });
+    const property = import_typescript6.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex(contentType),
+      /* questionToken */
+      void 0,
+      /* type          */
+      mediaType
+    );
+    addJSDocComment(mediaTypeObject, property);
+    type.push(property);
+  }
+  return import_typescript6.default.factory.createTypeLiteralNode([
+    import_typescript6.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex("content"),
+      /* questionToken */
+      void 0,
+      /* type          */
+      import_typescript6.default.factory.createTypeLiteralNode(
+        type.length ? type : (
+          // add `"*/*": never` if no media types are defined
+          [
+            import_typescript6.default.factory.createPropertySignature(
+              /* modifiers     */
+              void 0,
+              /* name          */
+              tsPropertyIndex("*/*"),
+              /* questionToken */
+              QUESTION_TOKEN,
+              /* type          */
+              NEVER
+            )
+          ]
+        )
+      )
+    )
+  ]);
+}
+
+// src/transform/responses-object.ts
+var import_typescript8 = __toESM(require("typescript"), 1);
+
+// src/transform/response-object.ts
+var import_typescript7 = __toESM(require("typescript"), 1);
+function transformResponseObject(responseObject, options) {
+  var _a;
+  const type = [];
+  const headersObject = [];
+  if (responseObject.headers) {
+    for (const [name, headerObject] of getEntries(responseObject.headers, options.ctx)) {
+      const optional = "$ref" in headerObject || headerObject.required ? void 0 : QUESTION_TOKEN;
+      const subType = "$ref" in headerObject ? oapiRef(headerObject.$ref) : transformHeaderObject(headerObject, {
+        ...options,
+        path: createRef([options.path, "headers", name])
+      });
+      const property = import_typescript7.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(name),
+        /* questionToken */
+        optional,
+        /* type          */
+        subType
+      );
+      addJSDocComment(headerObject, property);
+      headersObject.push(property);
+    }
+  }
+  headersObject.push(
+    import_typescript7.default.factory.createIndexSignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* parameters */
+      [
+        import_typescript7.default.factory.createParameterDeclaration(
+          /* modifiers      */
+          void 0,
+          /* dotDotDotToken */
+          void 0,
+          /* name           */
+          import_typescript7.default.factory.createIdentifier("name"),
+          /* questionToken  */
+          void 0,
+          /* type           */
+          STRING
+        )
+      ],
+      /* type          */
+      UNKNOWN
+    )
+  );
+  type.push(
+    import_typescript7.default.factory.createPropertySignature(
+      /* modifiers     */
+      void 0,
+      /* name          */
+      tsPropertyIndex("headers"),
+      /* questionToken */
+      void 0,
+      /* type          */
+      import_typescript7.default.factory.createTypeLiteralNode(headersObject)
+    )
+  );
+  const contentObject = [];
+  if (responseObject.content) {
+    for (const [contentType, mediaTypeObject] of getEntries((_a = responseObject.content) != null ? _a : {}, options.ctx)) {
+      const property = import_typescript7.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(contentType),
+        /* questionToken */
+        void 0,
+        /* type          */
+        transformMediaTypeObject(mediaTypeObject, {
+          ...options,
+          path: createRef([options.path, "content", contentType])
+        })
+      );
+      contentObject.push(property);
+    }
+  }
+  if (contentObject.length) {
+    type.push(
+      import_typescript7.default.factory.createPropertySignature(
+        /* modifiers     */
+        void 0,
+        /* name          */
+        tsPropertyIndex("content"),
+        /* questionToken */
+        void 0,
+        /* type          */
+        import_typescript7.default.factory.createTypeLiteralNode(contentObject)
+      )
+    );
+  } else {
+    type.push(
+      import_typescript7.default.factory.createPropertySignature(
+        /* modifiers     */
+        void 0,
+        /* name          */
+        tsPropertyIndex("content"),
+        /* questionToken */
+        QUESTION_TOKEN,
+        /* type          */
+        NEVER
+      )
+    );
+  }
+  return import_typescript7.default.factory.createTypeLiteralNode(type);
+}
+
+// src/transform/responses-object.ts
+function transformResponsesObject(responsesObject, options) {
+  const type = [];
+  for (const [responseCode, responseObject] of getEntries(responsesObject, options.ctx)) {
+    const responseType = "$ref" in responseObject ? oapiRef(responseObject.$ref) : transformResponseObject(responseObject, {
+      ...options,
+      path: createRef([options.path, "responses", responseCode])
+    });
+    const property = import_typescript8.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex(responseCode),
+      /* questionToken */
+      void 0,
+      /* type          */
+      responseType
+    );
+    addJSDocComment(responseObject, property);
+    type.push(property);
+  }
+  return type.length ? import_typescript8.default.factory.createTypeLiteralNode(type) : NEVER;
+}
+
+// src/transform/operation-object.ts
+function transformOperationObject(operationObject, options) {
+  var _a, _b, _c;
+  const type = [];
+  type.push(...transformParametersArray((_a = operationObject.parameters) != null ? _a : [], options));
+  if (operationObject.requestBody) {
+    const requestBodyType = "$ref" in operationObject.requestBody ? oapiRef(operationObject.requestBody.$ref) : transformRequestBodyObject(operationObject.requestBody, {
+      ...options,
+      path: createRef([options.path, "requestBody"])
+    });
+    const required = !!((_b = "$ref" in operationObject.requestBody ? options.ctx.resolve(operationObject.requestBody.$ref) : operationObject.requestBody) == null ? void 0 : _b.required);
+    const property = import_typescript9.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex("requestBody"),
+      /* questionToken */
+      required ? void 0 : QUESTION_TOKEN,
+      /* type          */
+      requestBodyType
+    );
+    addJSDocComment(operationObject.requestBody, property);
+    type.push(property);
+  } else {
+    type.push(
+      import_typescript9.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: options.ctx.immutable }),
+        /* name          */
+        tsPropertyIndex("requestBody"),
+        /* questionToken */
+        QUESTION_TOKEN,
+        /* type          */
+        NEVER
+      )
+    );
+  }
+  type.push(
+    import_typescript9.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex("responses"),
+      /* questionToken */
+      void 0,
+      /* type          */
+      transformResponsesObject((_c = operationObject.responses) != null ? _c : {}, options)
+    )
+  );
+  return type;
+}
+function injectOperationObject(operationId, operationObject, options) {
+  let operations = options.ctx.injectFooter.find(
+    (node) => import_typescript9.default.isInterfaceDeclaration(node) && node.name.text === "operations"
+  );
+  if (!operations) {
+    operations = import_typescript9.default.factory.createInterfaceDeclaration(
+      /* modifiers       */
+      tsModifiers({
+        export: true
+        // important: do NOT make this immutable
+      }),
+      /* name            */
+      import_typescript9.default.factory.createIdentifier("operations"),
+      /* typeParameters  */
+      void 0,
+      /* heritageClauses */
+      void 0,
+      /* members         */
+      []
+    );
+    options.ctx.injectFooter.push(operations);
+  }
+  const type = transformOperationObject(operationObject, options);
+  operations.members = import_typescript9.default.factory.createNodeArray([
+    ...operations.members,
+    import_typescript9.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex(operationId),
+      /* questionToken */
+      void 0,
+      /* type          */
+      import_typescript9.default.factory.createTypeLiteralNode(type)
+    )
+  ]);
+}
+
+// src/transform/path-item-object.ts
+function transformPathItemObject(pathItem, options) {
+  var _a, _b, _c, _d, _e, _f;
+  const type = [];
+  type.push(
+    ...transformParametersArray((_a = pathItem.parameters) != null ? _a : [], {
+      ...options,
+      path: createRef([options.path, "parameters"])
+    })
+  );
+  for (const method of ["get", "put", "post", "delete", "options", "head", "patch", "trace"]) {
+    const operationObject = pathItem[method];
+    if (!operationObject || options.ctx.excludeDeprecated && ((_b = "$ref" in operationObject ? options.ctx.resolve(operationObject.$ref) : operationObject) == null ? void 0 : _b.deprecated)) {
+      type.push(
+        import_typescript10.default.factory.createPropertySignature(
+          /* modifiers     */
+          tsModifiers({ readonly: options.ctx.immutable }),
+          /* name          */
+          tsPropertyIndex(method),
+          /* questionToken */
+          QUESTION_TOKEN,
+          /* type          */
+          NEVER
+        )
+      );
+      continue;
+    }
+    const keyedParameters = {};
+    if (!("$ref" in operationObject)) {
+      for (const parameter of [...(_c = pathItem.parameters) != null ? _c : [], ...(_d = operationObject.parameters) != null ? _d : []]) {
+        const name = "$ref" in parameter ? `${(_e = options.ctx.resolve(parameter.$ref)) == null ? void 0 : _e.in}-${(_f = options.ctx.resolve(parameter.$ref)) == null ? void 0 : _f.name}` : `${parameter.in}-${parameter.name}`;
+        if (name) {
+          keyedParameters[name] = parameter;
+        }
+      }
+    }
+    let operationType;
+    if ("$ref" in operationObject) {
+      operationType = oapiRef(operationObject.$ref);
+    } else if (operationObject.operationId) {
+      const operationId = operationObject.operationId.replace(HASH_RE, "/");
+      operationType = oapiRef(createRef(["operations", operationId]));
+      injectOperationObject(
+        operationId,
+        { ...operationObject, parameters: Object.values(keyedParameters) },
+        { ...options, path: createRef([options.path, method]) }
+      );
+    } else {
+      operationType = import_typescript10.default.factory.createTypeLiteralNode(
+        transformOperationObject(
+          { ...operationObject, parameters: Object.values(keyedParameters) },
+          { ...options, path: createRef([options.path, method]) }
+        )
+      );
+    }
+    const property = import_typescript10.default.factory.createPropertySignature(
+      /* modifiers     */
+      tsModifiers({ readonly: options.ctx.immutable }),
+      /* name          */
+      tsPropertyIndex(method),
+      /* questionToken */
+      void 0,
+      /* type          */
+      operationType
+    );
+    addJSDocComment(operationObject, property);
+    type.push(property);
+  }
+  return import_typescript10.default.factory.createTypeLiteralNode(type);
+}
+var HASH_RE = /#/g;
+
+// src/transform/components-object.ts
+var transformers = {
+  schemas: transformSchemaObject,
+  responses: transformResponseObject,
+  parameters: transformParameterObject,
+  requestBodies: transformRequestBodyObject,
+  headers: transformHeaderObject,
+  pathItems: transformPathItemObject
+};
+function transformComponentsObject(componentsObject, ctx) {
+  const type = [];
+  const rootTypeAliases = {};
+  for (const key of Object.keys(transformers)) {
+    const componentT = import_node_perf_hooks2.performance.now();
+    const items = [];
+    if (componentsObject[key]) {
+      for (const [name, item] of getEntries(componentsObject[key], ctx)) {
+        let subType = transformers[key](item, {
+          path: createRef(["components", key, name]),
+          schema: item,
+          ctx
+        });
+        let hasQuestionToken = false;
+        if (ctx.transform) {
+          const result = ctx.transform(item, {
+            path: createRef(["components", key, name]),
+            schema: item,
+            ctx
+          });
+          if (result) {
+            if ("schema" in result) {
+              subType = result.schema;
+              hasQuestionToken = result.questionToken;
+            } else {
+              subType = result;
+            }
+          }
+        }
+        const property = import_typescript11.default.factory.createPropertySignature(
+          /* modifiers     */
+          tsModifiers({ readonly: ctx.immutable }),
+          /* name          */
+          tsPropertyIndex(name),
+          /* questionToken */
+          hasQuestionToken ? QUESTION_TOKEN : void 0,
+          /* type          */
+          subType
+        );
+        addJSDocComment(item, property);
+        items.push(property);
+        if (ctx.rootTypes) {
+          const componentKey = pascalCase(singularizeComponentKey(key));
+          let aliasName = `${componentKey}${pascalCase(name)}`;
+          let conflictCounter = 1;
+          while (rootTypeAliases[aliasName] !== void 0) {
+            conflictCounter++;
+            aliasName = `${componentKey}${pascalCase(name)}_${conflictCounter}`;
+          }
+          const ref = import_typescript11.default.factory.createTypeReferenceNode(`components['${key}']['${name}']`);
+          if (ctx.rootTypesNoSchemaPrefix && key === "schemas") {
+            aliasName = aliasName.replace(componentKey, "");
+          }
+          const typeAlias = import_typescript11.default.factory.createTypeAliasDeclaration(
+            /* modifiers      */
+            tsModifiers({ export: true }),
+            /* name           */
+            aliasName,
+            /* typeParameters */
+            void 0,
+            /* type           */
+            ref
+          );
+          rootTypeAliases[aliasName] = typeAlias;
+        }
+      }
+    }
+    type.push(
+      import_typescript11.default.factory.createPropertySignature(
+        /* modifiers     */
+        void 0,
+        /* name          */
+        tsPropertyIndex(key),
+        /* questionToken */
+        void 0,
+        /* type          */
+        items.length ? import_typescript11.default.factory.createTypeLiteralNode(items) : NEVER
+      )
+    );
+    debug(`Transformed components \u2192 ${key}`, "ts", import_node_perf_hooks2.performance.now() - componentT);
+  }
+  let rootTypes = [];
+  if (ctx.rootTypes) {
+    rootTypes = Object.keys(rootTypeAliases).map((k) => rootTypeAliases[k]);
+  }
+  return [import_typescript11.default.factory.createTypeLiteralNode(type), ...rootTypes];
+}
+function singularizeComponentKey(key) {
+  switch (key) {
+    // Handle special singular case
+    case "requestBodies":
+      return "requestBody";
+    // Default to removing the "s"
+    default:
+      return key.slice(0, -1);
+  }
+}
+
+// src/transform/paths-object.ts
+var import_typescript12 = __toESM(require("typescript"), 1);
+var import_node_perf_hooks3 = require("node:perf_hooks");
+var PATH_PARAM_RE2 = /\{[^}]+\}/g;
+function transformPathsObject(pathsObject, ctx) {
+  var _a, _b;
+  const type = [];
+  for (const [url, pathItemObject] of getEntries(pathsObject, ctx)) {
+    if (!pathItemObject || typeof pathItemObject !== "object") {
+      continue;
+    }
+    const pathT = import_node_perf_hooks3.performance.now();
+    if ("$ref" in pathItemObject) {
+      const property = import_typescript12.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({ readonly: ctx.immutable }),
+        /* name          */
+        tsPropertyIndex(url),
+        /* questionToken */
+        void 0,
+        /* type          */
+        oapiRef(pathItemObject.$ref)
+      );
+      addJSDocComment(pathItemObject, property);
+      type.push(property);
+    } else {
+      const pathItemType = transformPathItemObject(pathItemObject, {
+        path: createRef(["paths", url]),
+        ctx
+      });
+      if (ctx.pathParamsAsTypes && url.includes("{")) {
+        const pathParams = extractPathParams(pathItemObject, ctx);
+        const matches = url.match(PATH_PARAM_RE2);
+        let rawPath = `\`${url}\``;
+        if (matches) {
+          for (const match of matches) {
+            const paramName = match.slice(1, -1);
+            const param = pathParams[paramName];
+            switch ((_a = param == null ? void 0 : param.schema) == null ? void 0 : _a.type) {
+              case "number":
+              case "integer":
+                rawPath = rawPath.replace(match, "${number}");
+                break;
+              case "boolean":
+                rawPath = rawPath.replace(match, "${boolean}");
+                break;
+              default:
+                rawPath = rawPath.replace(match, "${string}");
+                break;
+            }
+          }
+          const pathType = (_b = stringToAST(rawPath)[0]) == null ? void 0 : _b.expression;
+          if (pathType) {
+            type.push(
+              import_typescript12.default.factory.createIndexSignature(
+                /* modifiers     */
+                tsModifiers({ readonly: ctx.immutable }),
+                /* parameters    */
+                [
+                  import_typescript12.default.factory.createParameterDeclaration(
+                    /* modifiers      */
+                    void 0,
+                    /* dotDotDotToken */
+                    void 0,
+                    /* name           */
+                    "path",
+                    /* questionToken  */
+                    void 0,
+                    /* type           */
+                    pathType,
+                    /* initializer    */
+                    void 0
+                  )
+                ],
+                /* type          */
+                pathItemType
+              )
+            );
+            continue;
+          }
+        }
+      }
+      type.push(
+        import_typescript12.default.factory.createPropertySignature(
+          /* modifiers     */
+          tsModifiers({ readonly: ctx.immutable }),
+          /* name          */
+          tsPropertyIndex(url),
+          /* questionToken */
+          void 0,
+          /* type          */
+          pathItemType
+        )
+      );
+      debug(`Transformed path "${url}"`, "ts", import_node_perf_hooks3.performance.now() - pathT);
+    }
+  }
+  return import_typescript12.default.factory.createTypeLiteralNode(type);
+}
+function extractPathParams(pathItemObject, ctx) {
+  var _a;
+  const params = {};
+  for (const p of (_a = pathItemObject.parameters) != null ? _a : []) {
+    const resolved = "$ref" in p && p.$ref ? ctx.resolve(p.$ref) : p;
+    if (resolved && resolved.in === "path") {
+      params[resolved.name] = resolved;
+    }
+  }
+  for (const method of ["get", "put", "post", "delete", "options", "head", "patch", "trace"]) {
+    if (!(method in pathItemObject)) {
+      continue;
+    }
+    const resolvedMethod = pathItemObject[method].$ref ? ctx.resolve(pathItemObject[method].$ref) : pathItemObject[method];
+    if (resolvedMethod == null ? void 0 : resolvedMethod.parameters) {
+      for (const p of resolvedMethod.parameters) {
+        const resolvedParam = "$ref" in p && p.$ref ? ctx.resolve(p.$ref) : p;
+        if (resolvedParam && resolvedParam.in === "path") {
+          params[resolvedParam.name] = resolvedParam;
+        }
+      }
+    }
+  }
+  return params;
+}
+
+// src/transform/webhooks-object.ts
+var import_typescript13 = __toESM(require("typescript"), 1);
+function transformWebhooksObject(webhooksObject, options) {
+  const type = [];
+  for (const [name, pathItemObject] of getEntries(webhooksObject, options)) {
+    type.push(
+      import_typescript13.default.factory.createPropertySignature(
+        /* modifiers     */
+        tsModifiers({
+          readonly: options.immutable
+        }),
+        /* name          */
+        tsPropertyIndex(name),
+        /* questionToken */
+        void 0,
+        /* type          */
+        transformPathItemObject(pathItemObject, {
+          path: createRef(["webhooks", name]),
+          ctx: options
+        })
+      )
+    );
+  }
+  return import_typescript13.default.factory.createTypeLiteralNode(type);
+}
+
+// src/transform/paths-enum.ts
+function makeApiPathsEnum(pathsObject) {
+  const enumKeys = [];
+  const enumMetaData = [];
+  for (const [url, pathItemObject] of getEntries(pathsObject)) {
+    for (const [method, operation] of Object.entries(pathItemObject)) {
+      if (!["get", "put", "post", "delete", "options", "head", "patch", "trace"].includes(method)) {
+        continue;
+      }
+      let pathName;
+      if (operation.operationId) {
+        pathName = operation.operationId;
+      } else {
+        pathName = (method + url).split("/").map((part) => {
+          const capitalised = part.charAt(0).toUpperCase() + part.slice(1);
+          return capitalised.replace(/{.*}|:.*|[^a-zA-Z\d_]+/, "");
+        }).join("");
+      }
+      const adaptedUrl = url.replace(/{(\w+)}/g, ":$1");
+      enumKeys.push(adaptedUrl);
+      enumMetaData.push({
+        name: pathName
+      });
+    }
+  }
+  return tsEnum("ApiPaths", enumKeys, enumMetaData, {
+    export: true
+  });
+}
+
+// src/transform/index.ts
+var transformers2 = {
+  paths: transformPathsObject,
+  webhooks: transformWebhooksObject,
+  components: transformComponentsObject,
+  $defs: (node, options) => transformSchemaObject(node, { path: createRef(["$defs"]), ctx: options, schema: node })
+};
+function transformSchema(schema, ctx) {
+  var _a, _b;
+  const type = [];
+  if (ctx.inject) {
+    const injectNodes = stringToAST(ctx.inject);
+    type.push(...injectNodes);
+  }
+  for (const root of Object.keys(transformers2)) {
+    const emptyObj = import_typescript14.default.factory.createTypeAliasDeclaration(
+      /* modifiers      */
+      tsModifiers({ export: true }),
+      /* name           */
+      root,
+      /* typeParameters */
+      void 0,
+      /* type           */
+      tsRecord(STRING, NEVER)
+    );
+    if (schema[root] && typeof schema[root] === "object") {
+      const rootT = import_node_perf_hooks4.performance.now();
+      const subTypes = [].concat(transformers2[root](schema[root], ctx));
+      for (const subType of subTypes) {
+        if (import_typescript14.default.isTypeNode(subType)) {
+          if ((_a = subType.members) == null ? void 0 : _a.length) {
+            type.push(
+              ctx.exportType ? import_typescript14.default.factory.createTypeAliasDeclaration(
+                /* modifiers      */
+                tsModifiers({ export: true }),
+                /* name           */
+                root,
+                /* typeParameters */
+                void 0,
+                /* type           */
+                subType
+              ) : import_typescript14.default.factory.createInterfaceDeclaration(
+                /* modifiers       */
+                tsModifiers({ export: true }),
+                /* name            */
+                root,
+                /* typeParameters  */
+                void 0,
+                /* heritageClauses */
+                void 0,
+                /* members         */
+                subType.members
+              )
+            );
+            debug(`${root} done`, "ts", import_node_perf_hooks4.performance.now() - rootT);
+          } else {
+            type.push(emptyObj);
+            debug(`${root} done (skipped)`, "ts", 0);
+          }
+        } else if (import_typescript14.default.isTypeAliasDeclaration(subType)) {
+          type.push(subType);
+        } else {
+          type.push(emptyObj);
+          debug(`${root} done (skipped)`, "ts", 0);
+        }
+      }
+    } else {
+      type.push(emptyObj);
+      debug(`${root} done (skipped)`, "ts", 0);
+    }
+  }
+  let hasOperations = false;
+  for (const injectedType of ctx.injectFooter) {
+    if (!hasOperations && ((_b = injectedType == null ? void 0 : injectedType.name) == null ? void 0 : _b.escapedText) === "operations") {
+      hasOperations = true;
+    }
+    type.push(injectedType);
+  }
+  if (!hasOperations) {
+    type.push(
+      import_typescript14.default.factory.createTypeAliasDeclaration(
+        /* modifiers      */
+        tsModifiers({ export: true }),
+        /* name           */
+        "operations",
+        /* typeParameters */
+        void 0,
+        /* type           */
+        tsRecord(STRING, NEVER)
+      )
+    );
+  }
+  if (ctx.makePathsEnum && schema.paths) {
+    type.push(makeApiPathsEnum(schema.paths));
+  }
+  return type;
+}
+
+// src/index.ts
+var COMMENT_HEADER = `/**
+ * This file was auto-generated by openapi-typescript.
+ * Do not make direct changes to the file.
+ */
+
+`;
+async function openapiTS(source, options = {}) {
+  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
+  if (!source) {
+    throw new Error("Empty schema. Please specify a URL, file path, or Redocly Config");
+  }
+  const redoc = (_a = options.redocly) != null ? _a : await (0, import_openapi_core2.createConfig)(
+    {
+      rules: {
+        "operation-operationId-unique": { severity: "error" }
+        // throw error on duplicate operationIDs
+      }
+    },
+    { extends: ["minimal"] }
+  );
+  const schema = await validateAndBundle(source, {
+    redoc,
+    cwd: options.cwd instanceof URL ? options.cwd : new URL(`file://${(_b = options.cwd) != null ? _b : process.cwd()}/`),
+    silent: (_c = options.silent) != null ? _c : false
+  });
+  const ctx = {
+    additionalProperties: (_d = options.additionalProperties) != null ? _d : false,
+    alphabetize: (_e = options.alphabetize) != null ? _e : false,
+    arrayLength: (_f = options.arrayLength) != null ? _f : false,
+    defaultNonNullable: (_g = options.defaultNonNullable) != null ? _g : true,
+    discriminators: scanDiscriminators(schema, options),
+    emptyObjectsUnknown: (_h = options.emptyObjectsUnknown) != null ? _h : false,
+    enum: (_i = options.enum) != null ? _i : false,
+    enumValues: (_j = options.enumValues) != null ? _j : false,
+    dedupeEnums: (_k = options.dedupeEnums) != null ? _k : false,
+    excludeDeprecated: (_l = options.excludeDeprecated) != null ? _l : false,
+    exportType: (_m = options.exportType) != null ? _m : false,
+    immutable: (_n = options.immutable) != null ? _n : false,
+    rootTypes: (_o = options.rootTypes) != null ? _o : false,
+    rootTypesNoSchemaPrefix: (_p = options.rootTypesNoSchemaPrefix) != null ? _p : false,
+    injectFooter: [],
+    pathParamsAsTypes: (_q = options.pathParamsAsTypes) != null ? _q : false,
+    postTransform: typeof options.postTransform === "function" ? options.postTransform : void 0,
+    propertiesRequiredByDefault: (_r = options.propertiesRequiredByDefault) != null ? _r : false,
+    redoc,
+    silent: (_s = options.silent) != null ? _s : false,
+    inject: (_t = options.inject) != null ? _t : void 0,
+    transform: typeof options.transform === "function" ? options.transform : void 0,
+    makePathsEnum: (_u = options.makePathsEnum) != null ? _u : false,
+    generatePathParams: (_v = options.generatePathParams) != null ? _v : false,
+    resolve($ref) {
+      var _a2;
+      return resolveRef(schema, $ref, { silent: (_a2 = options.silent) != null ? _a2 : false });
+    }
+  };
+  const transformT = import_node_perf_hooks5.performance.now();
+  const result = transformSchema(schema, ctx);
+  debug("Completed AST transformation for entire document", "ts", import_node_perf_hooks5.performance.now() - transformT);
+  return result;
+}
+// Annotate the CommonJS export names for ESM import in node:
+0 && (module.exports = {
+  BOOLEAN,
+  COMMENT_HEADER,
+  FALSE,
+  JS_ENUM_INVALID_CHARS_RE,
+  JS_PROPERTY_INDEX_INVALID_CHARS_RE,
+  JS_PROPERTY_INDEX_RE,
+  NEVER,
+  NULL,
+  NUMBER,
+  QUESTION_TOKEN,
+  SPECIAL_CHARACTER_MAP,
+  STRING,
+  TRUE,
+  UNDEFINED,
+  UNKNOWN,
+  addJSDocComment,
+  astToString,
+  c,
+  createDiscriminatorProperty,
+  createRef,
+  debug,
+  enumCache,
+  error,
+  formatTime,
+  getEntries,
+  injectOperationObject,
+  oapiRef,
+  resolveRef,
+  scanDiscriminators,
+  stringToAST,
+  transformComponentsObject,
+  transformHeaderObject,
+  transformMediaTypeObject,
+  transformOperationObject,
+  transformParameterObject,
+  transformPathItemObject,
+  transformPathsObject,
+  transformRequestBodyObject,
+  transformResponseObject,
+  transformResponsesObject,
+  transformSchema,
+  transformSchemaObject,
+  transformSchemaObjectWithComposition,
+  tsArrayLiteralExpression,
+  tsDedupe,
+  tsEnum,
+  tsEnumMember,
+  tsIntersection,
+  tsIsPrimitive,
+  tsLiteral,
+  tsModifiers,
+  tsNullable,
+  tsOmit,
+  tsPropertyIndex,
+  tsReadonlyArray,
+  tsRecord,
+  tsUnion,
+  tsWithRequired,
+  walk,
+  warn
+});
diff --git a/package/dist/index.d.ts b/package/dist/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..000a7e05edfe9b4d794e28c01c7de1a569772d2e
--- /dev/null
+++ b/package/dist/index.d.ts
@@ -0,0 +1,23 @@
+import type { Readable } from "node:stream";
+import type ts from "typescript";
+import type { OpenAPI3, OpenAPITSOptions } from "./types.js";
+export * from "./lib/ts.js";
+export * from "./lib/utils.js";
+export { default as transformSchema } from "./transform/index.js";
+export { default as transformComponentsObject } from "./transform/components-object.js";
+export { default as transformHeaderObject } from "./transform/header-object.js";
+export { default as transformMediaTypeObject } from "./transform/media-type-object.js";
+export * from "./transform/operation-object.js";
+export { default as transformOperationObject } from "./transform/operation-object.js";
+export { default as transformParameterObject } from "./transform/parameter-object.js";
+export * from "./transform/path-item-object.js";
+export { default as transformPathItemObject } from "./transform/path-item-object.js";
+export { default as transformPathsObject } from "./transform/paths-object.js";
+export { default as transformRequestBodyObject } from "./transform/request-body-object.js";
+export { default as transformResponseObject } from "./transform/response-object.js";
+export { default as transformResponsesObject } from "./transform/responses-object.js";
+export * from "./transform/schema-object.js";
+export { default as transformSchemaObject } from "./transform/schema-object.js";
+export * from "./types.js";
+export declare const COMMENT_HEADER = "/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n";
+export default function openapiTS(source: string | URL | OpenAPI3 | Buffer | Readable, options?: OpenAPITSOptions): Promise<ts.Node[]>;
diff --git a/package/dist/index.js b/package/dist/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..874c6af113bb443a15f3adba77367db46019f88f
--- /dev/null
+++ b/package/dist/index.js
@@ -0,0 +1,79 @@
+import { createConfig } from "@redocly/openapi-core";
+import { performance } from "node:perf_hooks";
+import { validateAndBundle } from "./lib/redoc.js";
+import { debug, resolveRef, scanDiscriminators } from "./lib/utils.js";
+import transformSchema from "./transform/index.js";
+export * from "./lib/ts.js";
+export * from "./lib/utils.js";
+export { default as transformSchema } from "./transform/index.js";
+export { default as transformComponentsObject } from "./transform/components-object.js";
+export { default as transformHeaderObject } from "./transform/header-object.js";
+export { default as transformMediaTypeObject } from "./transform/media-type-object.js";
+export * from "./transform/operation-object.js";
+export { default as transformOperationObject } from "./transform/operation-object.js";
+export { default as transformParameterObject } from "./transform/parameter-object.js";
+export * from "./transform/path-item-object.js";
+export { default as transformPathItemObject } from "./transform/path-item-object.js";
+export { default as transformPathsObject } from "./transform/paths-object.js";
+export { default as transformRequestBodyObject } from "./transform/request-body-object.js";
+export { default as transformResponseObject } from "./transform/response-object.js";
+export { default as transformResponsesObject } from "./transform/responses-object.js";
+export * from "./transform/schema-object.js";
+export { default as transformSchemaObject } from "./transform/schema-object.js";
+export * from "./types.js";
+export const COMMENT_HEADER = `/**
+ * This file was auto-generated by openapi-typescript.
+ * Do not make direct changes to the file.
+ */
+
+`;
+export default async function openapiTS(source, options = {}) {
+    if (!source) {
+        throw new Error("Empty schema. Please specify a URL, file path, or Redocly Config");
+    }
+    const redoc = options.redocly ??
+        (await createConfig({
+            rules: {
+                "operation-operationId-unique": { severity: "error" },
+            },
+        }, { extends: ["minimal"] }));
+    const schema = await validateAndBundle(source, {
+        redoc,
+        cwd: options.cwd instanceof URL ? options.cwd : new URL(`file://${options.cwd ?? process.cwd()}/`),
+        silent: options.silent ?? false,
+    });
+    const ctx = {
+        additionalProperties: options.additionalProperties ?? false,
+        alphabetize: options.alphabetize ?? false,
+        arrayLength: options.arrayLength ?? false,
+        defaultNonNullable: options.defaultNonNullable ?? true,
+        discriminators: scanDiscriminators(schema, options),
+        emptyObjectsUnknown: options.emptyObjectsUnknown ?? false,
+        enum: options.enum ?? false,
+        enumValues: options.enumValues ?? false,
+        dedupeEnums: options.dedupeEnums ?? false,
+        excludeDeprecated: options.excludeDeprecated ?? false,
+        exportType: options.exportType ?? false,
+        immutable: options.immutable ?? false,
+        rootTypes: options.rootTypes ?? false,
+        rootTypesNoSchemaPrefix: options.rootTypesNoSchemaPrefix ?? false,
+        injectFooter: [],
+        pathParamsAsTypes: options.pathParamsAsTypes ?? false,
+        postTransform: typeof options.postTransform === "function" ? options.postTransform : undefined,
+        propertiesRequiredByDefault: options.propertiesRequiredByDefault ?? false,
+        redoc,
+        silent: options.silent ?? false,
+        inject: options.inject ?? undefined,
+        transform: typeof options.transform === "function" ? options.transform : undefined,
+        makePathsEnum: options.makePathsEnum ?? false,
+        generatePathParams: options.generatePathParams ?? false,
+        resolve($ref) {
+            return resolveRef(schema, $ref, { silent: options.silent ?? false });
+        },
+    };
+    const transformT = performance.now();
+    const result = transformSchema(schema, ctx);
+    debug("Completed AST transformation for entire document", "ts", performance.now() - transformT);
+    return result;
+}
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/package/dist/index.js.map b/package/dist/index.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..9361e8525760b511525673ac2d7103d807b5d2dc
--- /dev/null
+++ b/package/dist/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/lib/redoc.d.ts b/package/dist/lib/redoc.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9be3f02330d78a14c36dd338e1ef3955c7b6bf97
--- /dev/null
+++ b/package/dist/lib/redoc.d.ts
@@ -0,0 +1,15 @@
+import { BaseResolver, type Config as RedoclyConfig, type Document } from "@redocly/openapi-core";
+import { Readable } from "node:stream";
+import type { OpenAPI3 } from "../types.js";
+export interface ValidateAndBundleOptions {
+    redoc: RedoclyConfig;
+    silent: boolean;
+    cwd?: URL;
+}
+interface ParseSchemaOptions {
+    absoluteRef: string;
+    resolver: BaseResolver;
+}
+export declare function parseSchema(schema: unknown, { absoluteRef, resolver }: ParseSchemaOptions): Promise<Document>;
+export declare function validateAndBundle(source: string | URL | OpenAPI3 | Readable | Buffer, options: ValidateAndBundleOptions): Promise<any>;
+export {};
diff --git a/package/dist/lib/redoc.js b/package/dist/lib/redoc.js
new file mode 100644
index 0000000000000000000000000000000000000000..65b6a32871426d5bb3461c2c98c4cc76b4cd1098
--- /dev/null
+++ b/package/dist/lib/redoc.js
@@ -0,0 +1,124 @@
+import { BaseResolver, bundle, makeDocumentFromString, Source, lintDocument, } from "@redocly/openapi-core";
+import { performance } from "node:perf_hooks";
+import { Readable } from "node:stream";
+import { fileURLToPath } from "node:url";
+import parseJson from "parse-json";
+import { debug, error, warn } from "./utils.js";
+export async function parseSchema(schema, { absoluteRef, resolver }) {
+    if (!schema) {
+        throw new Error("Can’t parse empty schema");
+    }
+    if (schema instanceof URL) {
+        const result = await resolver.resolveDocument(null, absoluteRef, true);
+        if ("parsed" in result) {
+            return result;
+        }
+        throw result.originalError;
+    }
+    if (schema instanceof Readable) {
+        const contents = await new Promise((resolve) => {
+            schema.resume();
+            schema.setEncoding("utf8");
+            let content = "";
+            schema.on("data", (chunk) => {
+                content += chunk;
+            });
+            schema.on("end", () => {
+                resolve(content.trim());
+            });
+        });
+        return parseSchema(contents, { absoluteRef, resolver });
+    }
+    if (schema instanceof Buffer) {
+        return parseSchema(schema.toString("utf8"), { absoluteRef, resolver });
+    }
+    if (typeof schema === "string") {
+        if (schema.startsWith("http://") || schema.startsWith("https://") || schema.startsWith("file://")) {
+            const url = new URL(schema);
+            return parseSchema(url, {
+                absoluteRef: url.protocol === "file:" ? fileURLToPath(url) : url.href,
+                resolver,
+            });
+        }
+        if (schema[0] === "{") {
+            return {
+                source: new Source(absoluteRef, schema, "application/json"),
+                parsed: parseJson(schema),
+            };
+        }
+        return makeDocumentFromString(schema, absoluteRef);
+    }
+    if (typeof schema === "object" && !Array.isArray(schema)) {
+        return {
+            source: new Source(absoluteRef, JSON.stringify(schema), "application/json"),
+            parsed: schema,
+        };
+    }
+    throw new Error(`Expected string, object, or Buffer. Got ${Array.isArray(schema) ? "Array" : typeof schema}`);
+}
+function _processProblems(problems, options) {
+    if (problems.length) {
+        let errorMessage = undefined;
+        for (const problem of problems) {
+            const problemLocation = problem.location?.[0].pointer;
+            const problemMessage = problemLocation ? `${problem.message} at ${problemLocation}` : problem.message;
+            if (problem.severity === "error") {
+                errorMessage = problemMessage;
+                error(problemMessage);
+            }
+            else {
+                warn(problemMessage, options.silent);
+            }
+        }
+        if (errorMessage) {
+            throw new Error(errorMessage);
+        }
+    }
+}
+export async function validateAndBundle(source, options) {
+    const redocConfigT = performance.now();
+    debug("Loaded Redoc config", "redoc", performance.now() - redocConfigT);
+    const redocParseT = performance.now();
+    let absoluteRef = fileURLToPath(new URL(options?.cwd ?? `file://${process.cwd()}/`));
+    if (source instanceof URL) {
+        absoluteRef = source.protocol === "file:" ? fileURLToPath(source) : source.href;
+    }
+    const resolver = new BaseResolver(options.redoc.resolve);
+    const document = await parseSchema(source, {
+        absoluteRef,
+        resolver,
+    });
+    debug("Parsed schema", "redoc", performance.now() - redocParseT);
+    const openapiVersion = Number.parseFloat(document.parsed.openapi);
+    if (document.parsed.swagger ||
+        !document.parsed.openapi ||
+        Number.isNaN(openapiVersion) ||
+        openapiVersion < 3 ||
+        openapiVersion >= 4) {
+        if (document.parsed.swagger) {
+            throw new Error("Unsupported Swagger version: 2.x. Use OpenAPI 3.x instead.");
+        }
+        if (document.parsed.openapi || openapiVersion < 3 || openapiVersion >= 4) {
+            throw new Error(`Unsupported OpenAPI version: ${document.parsed.openapi}`);
+        }
+        throw new Error("Unsupported schema format, expected `openapi: 3.x`");
+    }
+    const redocLintT = performance.now();
+    const problems = await lintDocument({
+        document,
+        config: options.redoc.styleguide,
+        externalRefResolver: resolver,
+    });
+    _processProblems(problems, options);
+    debug("Linted schema", "lint", performance.now() - redocLintT);
+    const redocBundleT = performance.now();
+    const bundled = await bundle({
+        config: options.redoc,
+        dereference: false,
+        doc: document,
+    });
+    _processProblems(bundled.problems, options);
+    debug("Bundled schema", "bundle", performance.now() - redocBundleT);
+    return bundled.bundle.parsed;
+}
+//# sourceMappingURL=redoc.js.map
\ No newline at end of file
diff --git a/package/dist/lib/redoc.js.map b/package/dist/lib/redoc.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..fe7a3c1a32ece9ba29d30496fb63ebb8747533d2
--- /dev/null
+++ b/package/dist/lib/redoc.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"redoc.js","sourceRoot":"","sources":["../../src/lib/redoc.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/lib/ts.d.ts b/package/dist/lib/ts.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6e31e0ec46ae870dc987766511a52ab26663cf8d
--- /dev/null
+++ b/package/dist/lib/ts.d.ts
@@ -0,0 +1,69 @@
+import ts from "typescript";
+export declare const JS_PROPERTY_INDEX_RE: RegExp;
+export declare const JS_ENUM_INVALID_CHARS_RE: RegExp;
+export declare const JS_PROPERTY_INDEX_INVALID_CHARS_RE: RegExp;
+export declare const SPECIAL_CHARACTER_MAP: Record<string, string>;
+export declare const BOOLEAN: ts.KeywordTypeNode<ts.SyntaxKind.BooleanKeyword>;
+export declare const FALSE: ts.LiteralTypeNode;
+export declare const NEVER: ts.KeywordTypeNode<ts.SyntaxKind.NeverKeyword>;
+export declare const NULL: ts.LiteralTypeNode;
+export declare const NUMBER: ts.KeywordTypeNode<ts.SyntaxKind.NumberKeyword>;
+export declare const QUESTION_TOKEN: ts.PunctuationToken<ts.SyntaxKind.QuestionToken>;
+export declare const STRING: ts.KeywordTypeNode<ts.SyntaxKind.StringKeyword>;
+export declare const TRUE: ts.LiteralTypeNode;
+export declare const UNDEFINED: ts.KeywordTypeNode<ts.SyntaxKind.UndefinedKeyword>;
+export declare const UNKNOWN: ts.KeywordTypeNode<ts.SyntaxKind.UnknownKeyword>;
+export interface AnnotatedSchemaObject {
+    const?: unknown;
+    default?: unknown;
+    deprecated?: boolean;
+    description?: string;
+    enum?: unknown[];
+    example?: string;
+    format?: string;
+    nullable?: boolean;
+    summary?: string;
+    title?: string;
+    type?: string | string[];
+}
+export declare function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void;
+export declare function oapiRef(path: string): ts.TypeNode;
+export interface AstToStringOptions {
+    fileName?: string;
+    sourceText?: string;
+    formatOptions?: ts.PrinterOptions;
+}
+export declare function astToString(ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[], options?: AstToStringOptions): string;
+export declare function stringToAST(source: string): unknown[];
+export declare function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[];
+export declare const enumCache: Map<string, ts.EnumDeclaration>;
+export declare function tsEnum(name: string, members: (string | number)[], metadata?: {
+    name?: string;
+    description?: string;
+}[], options?: {
+    export?: boolean;
+    shouldCache?: boolean;
+}): ts.EnumDeclaration;
+export declare function tsArrayLiteralExpression(name: string, elementType: ts.TypeNode, values: (string | number)[], options?: {
+    export?: boolean;
+    readonly?: boolean;
+    injectFooter?: ts.Node[];
+}): ts.VariableStatement;
+export declare function tsEnumMember(value: string | number, metadata?: {
+    name?: string;
+    description?: string;
+}): ts.EnumMember;
+export declare function tsIntersection(types: ts.TypeNode[]): ts.TypeNode;
+export declare function tsIsPrimitive(type: ts.TypeNode): boolean;
+export declare function tsLiteral(value: unknown): ts.TypeNode;
+export declare function tsModifiers(modifiers: {
+    readonly?: boolean;
+    export?: boolean;
+}): ts.Modifier[];
+export declare function tsNullable(types: ts.TypeNode[]): ts.TypeNode;
+export declare function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode;
+export declare function tsRecord(key: ts.TypeNode, value: ts.TypeNode): ts.TypeReferenceNode;
+export declare function tsPropertyIndex(index: string | number): ts.Identifier | ts.NumericLiteral | ts.StringLiteral;
+export declare function tsUnion(types: ts.TypeNode[]): ts.TypeNode;
+export declare function tsWithRequired(type: ts.TypeNode, keys: string[], injectFooter: ts.Node[]): ts.TypeNode;
+export declare function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode;
diff --git a/package/dist/lib/ts.js b/package/dist/lib/ts.js
new file mode 100644
index 0000000000000000000000000000000000000000..7f46f68fe5a4b6fab4b5cba34602cf1268903d5c
--- /dev/null
+++ b/package/dist/lib/ts.js
@@ -0,0 +1,322 @@
+import { parseRef } from "@redocly/openapi-core/lib/ref-utils.js";
+import ts from "typescript";
+export const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;
+export const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;
+export const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;
+export const SPECIAL_CHARACTER_MAP = {
+    "+": "Plus",
+};
+export const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
+export const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());
+export const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);
+export const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());
+export const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
+export const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);
+export const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
+export const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());
+export const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);
+export const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
+const LB_RE = /\r?\n/g;
+const COMMENT_RE = /\*\//g;
+export function addJSDocComment(schemaObject, node) {
+    if (!schemaObject || typeof schemaObject !== "object" || Array.isArray(schemaObject)) {
+        return;
+    }
+    const output = [];
+    if (schemaObject.title) {
+        output.push(schemaObject.title.replace(LB_RE, "\n *     "));
+    }
+    if (schemaObject.summary) {
+        output.push(schemaObject.summary.replace(LB_RE, "\n *     "));
+    }
+    if (schemaObject.format) {
+        output.push(`Format: ${schemaObject.format}`);
+    }
+    if (schemaObject.deprecated) {
+        output.push("@deprecated");
+    }
+    const supportedJsDocTags = ["description", "default", "example"];
+    for (const field of supportedJsDocTags) {
+        const allowEmptyString = field === "default" || field === "example";
+        if (schemaObject[field] === undefined) {
+            continue;
+        }
+        if (schemaObject[field] === "" && !allowEmptyString) {
+            continue;
+        }
+        const serialized = typeof schemaObject[field] === "object" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];
+        output.push(`@${field} ${String(serialized).replace(LB_RE, "\n *     ")}`);
+    }
+    if ("const" in schemaObject) {
+        output.push("@constant");
+    }
+    if (schemaObject.enum) {
+        let type = "unknown";
+        if (Array.isArray(schemaObject.type)) {
+            type = schemaObject.type.join("|");
+        }
+        else if (typeof schemaObject.type === "string") {
+            type = schemaObject.type;
+        }
+        output.push(`@enum {${type}${schemaObject.nullable ? "|null" : ""}}`);
+    }
+    if (output.length) {
+        let text = output.length === 1
+            ? `* ${output.join("\n")} `
+            : `*
+ * ${output.join("\n * ")}\n `;
+        text = text.replace(COMMENT_RE, "*\\/");
+        ts.addSyntheticLeadingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, text, true);
+    }
+}
+export function oapiRef(path) {
+    const { pointer } = parseRef(path);
+    if (pointer.length === 0) {
+        throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);
+    }
+    let t = ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(pointer[0])));
+    if (pointer.length > 1) {
+        for (let i = 1; i < pointer.length; i++) {
+            if (i > 2 && i < pointer.length - 1 && pointer[i] === "properties") {
+                continue;
+            }
+            t = ts.factory.createIndexedAccessTypeNode(t, ts.factory.createLiteralTypeNode(typeof pointer[i] === "number"
+                ? ts.factory.createNumericLiteral(pointer[i])
+                : ts.factory.createStringLiteral(pointer[i])));
+        }
+    }
+    return t;
+}
+export function astToString(ast, options) {
+    const sourceFile = ts.createSourceFile(options?.fileName ?? "openapi-ts.ts", options?.sourceText ?? "", ts.ScriptTarget.ESNext, false, ts.ScriptKind.TS);
+    sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);
+    const printer = ts.createPrinter({
+        newLine: ts.NewLineKind.LineFeed,
+        removeComments: false,
+        ...options?.formatOptions,
+    });
+    return printer.printFile(sourceFile);
+}
+export function stringToAST(source) {
+    return ts.createSourceFile("stringInput", source, ts.ScriptTarget.ESNext, undefined, undefined).statements;
+}
+export function tsDedupe(types) {
+    const encounteredTypes = new Set();
+    const filteredTypes = [];
+    for (const t of types) {
+        if (!("text" in (t.literal ?? t))) {
+            const { kind } = t.literal ?? t;
+            if (encounteredTypes.has(kind)) {
+                continue;
+            }
+            if (tsIsPrimitive(t)) {
+                encounteredTypes.add(kind);
+            }
+        }
+        filteredTypes.push(t);
+    }
+    return filteredTypes;
+}
+export const enumCache = new Map();
+export function tsEnum(name, members, metadata, options) {
+    let enumName = sanitizeMemberName(name);
+    enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;
+    let key = "";
+    if (options?.shouldCache) {
+        key = `${members
+            .slice(0)
+            .sort()
+            .map((v, i) => {
+            return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || ""}`;
+        })
+            .join(",")}`;
+        if (enumCache.has(key)) {
+            return enumCache.get(key);
+        }
+    }
+    const enumDeclaration = ts.factory.createEnumDeclaration(options ? tsModifiers({ export: options.export ?? false }) : undefined, enumName, members.map((value, i) => tsEnumMember(value, metadata?.[i])));
+    options?.shouldCache && enumCache.set(key, enumDeclaration);
+    return enumDeclaration;
+}
+export function tsArrayLiteralExpression(name, elementType, values, options) {
+    let variableName = sanitizeMemberName(name);
+    variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;
+    const arrayType = options?.readonly
+        ? tsReadonlyArray(elementType, options.injectFooter)
+        : ts.factory.createArrayTypeNode(elementType);
+    return ts.factory.createVariableStatement(options ? tsModifiers({ export: options.export ?? false }) : undefined, ts.factory.createVariableDeclarationList([
+        ts.factory.createVariableDeclaration(variableName, undefined, arrayType, ts.factory.createArrayLiteralExpression(values.map((value) => {
+            if (typeof value === "number") {
+                if (value < 0) {
+                    return ts.factory.createPrefixUnaryExpression(ts.SyntaxKind.MinusToken, ts.factory.createNumericLiteral(Math.abs(value)));
+                }
+                else {
+                    return ts.factory.createNumericLiteral(value);
+                }
+            }
+            else {
+                return ts.factory.createStringLiteral(value);
+            }
+        }))),
+    ], ts.NodeFlags.Const));
+}
+function sanitizeMemberName(name) {
+    let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {
+        const last = c[c.length - 1];
+        return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? "" : last.toUpperCase();
+    });
+    if (Number(name[0]) >= 0) {
+        sanitizedName = `Value${name}`;
+    }
+    return sanitizedName;
+}
+export function tsEnumMember(value, metadata = {}) {
+    let name = metadata.name ?? String(value);
+    if (!JS_PROPERTY_INDEX_RE.test(name)) {
+        if (Number(name[0]) >= 0) {
+            name = `Value${name}`.replace(".", "_");
+        }
+        else if (name[0] === "-") {
+            name = `ValueMinus${name.slice(1)}`;
+        }
+        const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);
+        if (invalidCharMatch) {
+            if (invalidCharMatch[0] === name) {
+                name = `"${name}"`;
+            }
+            else {
+                name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {
+                    return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : "_";
+                });
+            }
+        }
+    }
+    let member;
+    if (typeof value === "number") {
+        const literal = value < 0
+            ? ts.factory.createPrefixUnaryExpression(ts.SyntaxKind.MinusToken, ts.factory.createNumericLiteral(Math.abs(value)))
+            : ts.factory.createNumericLiteral(value);
+        member = ts.factory.createEnumMember(name, literal);
+    }
+    else {
+        member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));
+    }
+    if (metadata.description === undefined) {
+        return member;
+    }
+    return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, " ".concat(metadata.description.trim()), true);
+}
+export function tsIntersection(types) {
+    if (types.length === 0) {
+        return NEVER;
+    }
+    if (types.length === 1) {
+        return types[0];
+    }
+    return ts.factory.createIntersectionTypeNode(tsDedupe(types));
+}
+export function tsIsPrimitive(type) {
+    if (!type) {
+        return true;
+    }
+    return (ts.SyntaxKind[type.kind] === "BooleanKeyword" ||
+        ts.SyntaxKind[type.kind] === "NeverKeyword" ||
+        ts.SyntaxKind[type.kind] === "NullKeyword" ||
+        ts.SyntaxKind[type.kind] === "NumberKeyword" ||
+        ts.SyntaxKind[type.kind] === "StringKeyword" ||
+        ts.SyntaxKind[type.kind] === "UndefinedKeyword" ||
+        ("literal" in type && tsIsPrimitive(type.literal)));
+}
+export function tsLiteral(value) {
+    if (typeof value === "string") {
+        return ts.factory.createIdentifier(JSON.stringify(value));
+    }
+    if (typeof value === "number") {
+        const literal = value < 0
+            ? ts.factory.createPrefixUnaryExpression(ts.SyntaxKind.MinusToken, ts.factory.createNumericLiteral(Math.abs(value)))
+            : ts.factory.createNumericLiteral(value);
+        return ts.factory.createLiteralTypeNode(literal);
+    }
+    if (typeof value === "boolean") {
+        return value === true ? TRUE : FALSE;
+    }
+    if (value === null) {
+        return NULL;
+    }
+    if (Array.isArray(value)) {
+        if (value.length === 0) {
+            return ts.factory.createArrayTypeNode(NEVER);
+        }
+        return ts.factory.createTupleTypeNode(value.map((v) => tsLiteral(v)));
+    }
+    if (typeof value === "object") {
+        const keys = [];
+        for (const [k, v] of Object.entries(value)) {
+            keys.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex(k), undefined, tsLiteral(v)));
+        }
+        return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);
+    }
+    return UNKNOWN;
+}
+export function tsModifiers(modifiers) {
+    const typeMods = [];
+    if (modifiers.export) {
+        typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));
+    }
+    if (modifiers.readonly) {
+        typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));
+    }
+    return typeMods;
+}
+export function tsNullable(types) {
+    return ts.factory.createUnionTypeNode([...types, NULL]);
+}
+export function tsOmit(type, keys) {
+    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("Omit"), [
+        type,
+        ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),
+    ]);
+}
+export function tsRecord(key, value) {
+    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("Record"), [key, value]);
+}
+export function tsPropertyIndex(index) {
+    if ((typeof index === "number" && !(index < 0)) ||
+        (typeof index === "string" && String(Number(index)) === index && index[0] !== "-")) {
+        return ts.factory.createNumericLiteral(index);
+    }
+    return typeof index === "string" && JS_PROPERTY_INDEX_RE.test(index)
+        ? ts.factory.createIdentifier(index)
+        : ts.factory.createStringLiteral(String(index));
+}
+export function tsUnion(types) {
+    if (types.length === 0) {
+        return NEVER;
+    }
+    if (types.length === 1) {
+        return types[0];
+    }
+    return ts.factory.createUnionTypeNode(tsDedupe(types));
+}
+export function tsWithRequired(type, keys, injectFooter) {
+    if (keys.length === 0) {
+        return type;
+    }
+    if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === "WithRequired")) {
+        const helper = stringToAST("type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };")[0];
+        injectFooter.push(helper);
+    }
+    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("WithRequired"), [
+        type,
+        tsUnion(keys.map((k) => tsLiteral(k))),
+    ]);
+}
+export function tsReadonlyArray(type, injectFooter) {
+    if (injectFooter &&
+        !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === "ReadonlyArray")) {
+        const helper = stringToAST("type ReadonlyArray<T> = [Exclude<T, undefined>] extends [any[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;")[0];
+        injectFooter.push(helper);
+    }
+    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("ReadonlyArray"), [type]);
+}
+//# sourceMappingURL=ts.js.map
\ No newline at end of file
diff --git a/package/dist/lib/ts.js.map b/package/dist/lib/ts.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..c61104cffa627a398cf6a54a381e5c521d6b8772
--- /dev/null
+++ b/package/dist/lib/ts.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ts.js","sourceRoot":"","sources":["../../src/lib/ts.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,wCAAwC,CAAC;AAClE,OAAO,EAAkD,MAAM,YAAY,CAAC;AAE5E,MAAM,CAAC,MAAM,oBAAoB,GAAG,4BAA4B,CAAC;AACjE,MAAM,CAAC,MAAM,wBAAwB,GAAG,sBAAsB,CAAC;AAC/D,MAAM,CAAC,MAAM,kCAAkC,GAAG,kBAAkB,CAAC;AACrE,MAAM,CAAC,MAAM,qBAAqB,GAA2B;IAC3D,GAAG,EAAE,MAAM;CAEZ,CAAC;AAEF,MAAM,CAAC,MAAM,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;AACtF,MAAM,CAAC,MAAM,KAAK,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;AAChF,MAAM,CAAC,MAAM,KAAK,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;AAClF,MAAM,CAAC,MAAM,IAAI,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC;AAC9E,MAAM,CAAC,MAAM,MAAM,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AACpF,MAAM,CAAC,MAAM,cAAc,GAAG,EAAE,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AAClF,MAAM,CAAC,MAAM,MAAM,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AACpF,MAAM,CAAC,MAAM,IAAI,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC;AAC9E,MAAM,CAAC,MAAM,SAAS,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC;AAC1F,MAAM,CAAC,MAAM,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;AAEtF,MAAM,KAAK,GAAG,QAAQ,CAAC;AACvB,MAAM,UAAU,GAAG,OAAO,CAAC;AAqB3B,MAAM,UAAU,eAAe,CAAC,YAAmC,EAAE,IAA0B;IAC7F,IAAI,CAAC,YAAY,IAAI,OAAO,YAAY,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE,CAAC;QACrF,OAAO;IACT,CAAC;IACD,MAAM,MAAM,GAAa,EAAE,CAAC;IAG5B,IAAI,YAAY,CAAC,KAAK,EAAE,CAAC;QACvB,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAC;IAC9D,CAAC;IACD,IAAI,YAAY,CAAC,OAAO,EAAE,CAAC;QACzB,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAC;IAChE,CAAC;IACD,IAAI,YAAY,CAAC,MAAM,EAAE,CAAC;QACxB,MAAM,CAAC,IAAI,CAAC,WAAW,YAAY,CAAC,MAAM,EAAE,CAAC,CAAC;IAChD,CAAC;IAID,IAAI,YAAY,CAAC,UAAU,EAAE,CAAC;QAC5B,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IAC7B,CAAC;IAGD,MAAM,kBAAkB,GAAG,CAAC,aAAa,EAAE,SAAS,EAAE,SAAS,CAAU,CAAC;IAC1E,KAAK,MAAM,KAAK,IAAI,kBAAkB,EAAE,CAAC;QACvC,MAAM,gBAAgB,GAAG,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,SAAS,CAAC;QACpE,IAAI,YAAY,CAAC,KAAK,CAAC,KAAK,SAAS,EAAE,CAAC;YACtC,SAAS;QACX,CAAC;QACD,IAAI,YAAY,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACpD,SAAS;QACX,CAAC;QACD,MAAM,UAAU,GACd,OAAO,YAAY,CAAC,KAAK,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;QAC/G,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,MAAM,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,WAAW,CAAC,EAAE,CAAC,CAAC;IAC7E,CAAC;IAGD,IAAI,OAAO,IAAI,YAAY,EAAE,CAAC;QAC5B,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IAC3B,CAAC;IAGD,IAAI,YAAY,CAAC,IAAI,EAAE,CAAC;QACtB,IAAI,IAAI,GAAG,SAAS,CAAC;QACrB,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC;YACrC,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACrC,CAAC;aAAM,IAAI,OAAO,YAAY,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;YACjD,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC;QAC3B,CAAC;QACD,MAAM,CAAC,IAAI,CAAC,UAAU,IAAI,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;IACxE,CAAC;IAID,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC;QAClB,IAAI,IAAI,GACN,MAAM,CAAC,MAAM,KAAK,CAAC;YACjB,CAAC,CAAC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;YAC3B,CAAC,CAAC;KACL,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC;QAC3B,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;QAExC,EAAE,CAAC,0BAA0B,CACF,IAAI,EACJ,EAAE,CAAC,UAAU,CAAC,sBAAsB,EACpC,IAAI,EACJ,IAAI,CAC9B,CAAC;IACJ,CAAC;AACH,CAAC;AAGD,MAAM,UAAU,OAAO,CAAC,IAAY;IAClC,MAAM,EAAE,OAAO,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;IACnC,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACzB,MAAM,IAAI,KAAK,CAAC,uBAAuB,IAAI,yBAAyB,CAAC,CAAC;IACxE,CAAC;IACD,IAAI,CAAC,GAAoD,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACzF,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAChD,CAAC;IACF,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAGxC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,YAAY,EAAE,CAAC;gBACnE,SAAS;YACX,CAAC;YACD,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,2BAA2B,CACxC,CAAC,EACD,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAC9B,OAAO,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ;gBAC5B,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBAC7C,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC,CAAW,CAAC,CACzD,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IACD,OAAO,CAAC,CAAC;AACX,CAAC;AASD,MAAM,UAAU,WAAW,CACzB,GAA4D,EAC5D,OAA4B;IAE5B,MAAM,UAAU,GAAG,EAAE,CAAC,gBAAgB,CACpC,OAAO,EAAE,QAAQ,IAAI,eAAe,EACpC,OAAO,EAAE,UAAU,IAAI,EAAE,EACzB,EAAE,CAAC,YAAY,CAAC,MAAM,EACtB,KAAK,EACL,EAAE,CAAC,UAAU,CAAC,EAAE,CACjB,CAAC;IAGF,UAAU,CAAC,UAAU,GAAG,EAAE,CAAC,OAAO,CAAC,eAAe,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAErF,MAAM,OAAO,GAAG,EAAE,CAAC,aAAa,CAAC;QAC/B,OAAO,EAAE,EAAE,CAAC,WAAW,CAAC,QAAQ;QAChC,cAAc,EAAE,KAAK;QACrB,GAAG,OAAO,EAAE,aAAa;KAC1B,CAAC,CAAC;IACH,OAAO,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;AACvC,CAAC;AAGD,MAAM,UAAU,WAAW,CAAC,MAAc;IACxC,OAAO,EAAE,CAAC,gBAAgB,CACF,aAAa,EACb,MAAM,EACN,EAAE,CAAC,YAAY,CAAC,MAAM,EACtB,SAAS,EACT,SAAS,CAChC,CAAC,UAAiB,CAAC;AACtB,CAAC;AAMD,MAAM,UAAU,QAAQ,CAAC,KAAoB;IAC3C,MAAM,gBAAgB,GAAG,IAAI,GAAG,EAAU,CAAC;IAC3C,MAAM,aAAa,GAAkB,EAAE,CAAC;IACxC,KAAK,MAAM,CAAC,IAAI,KAAK,EAAE,CAAC;QAEtB,IAAI,CAAC,CAAC,MAAM,IAAI,CAAE,CAAqB,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;YACvD,MAAM,EAAE,IAAI,EAAE,GAAI,CAAqB,CAAC,OAAO,IAAI,CAAC,CAAC;YACrD,IAAI,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC/B,SAAS;YACX,CAAC;YACD,IAAI,aAAa,CAAC,CAAC,CAAC,EAAE,CAAC;gBACrB,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAC7B,CAAC;QACH,CAAC;QACD,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACxB,CAAC;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;AAED,MAAM,CAAC,MAAM,SAAS,GAAG,IAAI,GAAG,EAA8B,CAAC;AAG/D,MAAM,UAAU,MAAM,CACpB,IAAY,EACZ,OAA4B,EAC5B,QAAoD,EACpD,OAAqD;IAErD,IAAI,QAAQ,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;IACxC,QAAQ,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC;IAClE,IAAI,GAAG,GAAG,EAAE,CAAC;IACb,IAAI,OAAO,EAAE,WAAW,EAAE,CAAC;QACzB,GAAG,GAAG,GAAG,OAAO;aACb,KAAK,CAAC,CAAC,CAAC;aACR,IAAI,EAAE;aACN,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;YACZ,OAAO,GAAG,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,IAAI,MAAM,CAAC,CAAC,CAAC,IAAI,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,WAAW,IAAI,EAAE,EAAE,CAAC;QACnF,CAAC,CAAC;aACD,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACf,IAAI,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACvB,OAAO,SAAS,CAAC,GAAG,CAAC,GAAG,CAAuB,CAAC;QAClD,CAAC;IACH,CAAC;IACD,MAAM,eAAe,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CACtC,OAAO,CAAC,CAAC,CAAC,WAAW,CAAC,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,IAAI,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,EACtE,QAAQ,EACR,OAAO,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC,YAAY,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAC9E,CAAC;IACF,OAAO,EAAE,WAAW,IAAI,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,eAAe,CAAC,CAAC;IAC5D,OAAO,eAAe,CAAC;AACzB,CAAC;AAGD,MAAM,UAAU,wBAAwB,CACtC,IAAY,EACZ,WAAwB,EACxB,MAA2B,EAC3B,OAA4E;IAE5E,IAAI,YAAY,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;IAC5C,YAAY,GAAG,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC;IAE9E,MAAM,SAAS,GAAG,OAAO,EAAE,QAAQ;QACjC,CAAC,CAAC,eAAe,CAAC,WAAW,EAAE,OAAO,CAAC,YAAY,CAAC;QACpD,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;IAEhD,OAAO,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACvC,OAAO,CAAC,CAAC,CAAC,WAAW,CAAC,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,IAAI,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,EACtE,EAAE,CAAC,OAAO,CAAC,6BAA6B,CACtC;QACE,EAAE,CAAC,OAAO,CAAC,yBAAyB,CAClC,YAAY,EACZ,SAAS,EACT,SAAS,EACT,EAAE,CAAC,OAAO,CAAC,4BAA4B,CACrC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;YACnB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;gBAC9B,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC;oBACd,OAAO,EAAE,CAAC,OAAO,CAAC,2BAA2B,CAC3C,EAAE,CAAC,UAAU,CAAC,UAAU,EACxB,EAAE,CAAC,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CACjD,CAAC;gBACJ,CAAC;qBAAM,CAAC;oBACN,OAAO,EAAE,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;gBAChD,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,OAAO,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;YAC/C,CAAC;QACH,CAAC,CAAC,CACH,CACF;KACF,EACD,EAAE,CAAC,SAAS,CAAC,KAAK,CACnB,CACF,CAAC;AACJ,CAAC;AAED,SAAS,kBAAkB,CAAC,IAAY;IACtC,IAAI,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,wBAAwB,EAAE,CAAC,CAAC,EAAE,EAAE;QAC/D,MAAM,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC7B,OAAO,kCAAkC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;IACjF,CAAC,CAAC,CAAC;IACH,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC;QACzB,aAAa,GAAG,QAAQ,IAAI,EAAE,CAAC;IACjC,CAAC;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;AAGD,MAAM,UAAU,YAAY,CAAC,KAAsB,EAAE,WAAoD,EAAE;IACzG,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC;IAC1C,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;QACrC,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC;YACzB,IAAI,GAAG,QAAQ,IAAI,EAAE,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QAC1C,CAAC;aAAM,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;YAC3B,IAAI,GAAG,aAAa,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;QACtC,CAAC;QAED,MAAM,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAAC,kCAAkC,CAAC,CAAC;QACxE,IAAI,gBAAgB,EAAE,CAAC;YACrB,IAAI,gBAAgB,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;gBACjC,IAAI,GAAG,IAAI,IAAI,GAAG,CAAC;YACrB,CAAC;iBAAM,CAAC;gBACN,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,kCAAkC,EAAE,CAAC,CAAC,EAAE,EAAE;oBAC5D,OAAO,CAAC,IAAI,qBAAqB,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;gBACrE,CAAC,CAAC,CAAC;YACL,CAAC;QACH,CAAC;IACH,CAAC;IAED,IAAI,MAAqB,CAAC;IAC1B,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,MAAM,OAAO,GACX,KAAK,GAAG,CAAC;YACP,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,2BAA2B,CACpC,EAAE,CAAC,UAAU,CAAC,UAAU,EACxB,EAAE,CAAC,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CACjD;YACH,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;QAE7C,MAAM,GAAG,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACtD,CAAC;SAAM,CAAC;QACN,MAAM,GAAG,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,IAAI,EAAE,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC;IACpF,CAAC;IAED,IAAI,QAAQ,CAAC,WAAW,KAAK,SAAS,EAAE,CAAC;QACvC,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,OAAO,EAAE,CAAC,0BAA0B,CAClC,MAAM,EACN,EAAE,CAAC,UAAU,CAAC,uBAAuB,EACrC,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,EACvC,IAAI,CACL,CAAC;AACJ,CAAC;AAGD,MAAM,UAAU,cAAc,CAAC,KAAoB;IACjD,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACvB,OAAO,KAAK,CAAC;IACf,CAAC;IACD,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACvB,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;IAClB,CAAC;IACD,OAAO,EAAE,CAAC,OAAO,CAAC,0BAA0B,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;AAChE,CAAC;AAGD,MAAM,UAAU,aAAa,CAAC,IAAiB;IAC7C,IAAI,CAAC,IAAI,EAAE,CAAC;QACV,OAAO,IAAI,CAAC;IACd,CAAC;IACD,OAAO,CACL,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,gBAAgB;QAC7C,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,cAAc;QAC3C,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,aAAa;QAC1C,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,eAAe;QAC5C,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,eAAe;QAC5C,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,kBAAkB;QAC/C,CAAC,SAAS,IAAI,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,OAA0B,CAAC,CAAC,CACtE,CAAC;AACJ,CAAC;AAGD,MAAM,UAAU,SAAS,CAAC,KAAc;IACtC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAE9B,OAAO,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAA2B,CAAC;IACtF,CAAC;IACD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,MAAM,OAAO,GACX,KAAK,GAAG,CAAC;YACP,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,2BAA2B,CACpC,EAAE,CAAC,UAAU,CAAC,UAAU,EACxB,EAAE,CAAC,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CACjD;YACH,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;QAC7C,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC;IACnD,CAAC;IACD,IAAI,OAAO,KAAK,KAAK,SAAS,EAAE,CAAC;QAC/B,OAAO,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;IACvC,CAAC;IACD,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;QACnB,OAAO,IAAI,CAAC;IACd,CAAC;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QACzB,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACvB,OAAO,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAC/C,CAAC;QACD,OAAO,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAU,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACjF,CAAC;IACD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,MAAM,IAAI,GAAqB,EAAE,CAAC;QAClC,KAAK,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;YAC3C,IAAI,CAAC,IAAI,CACP,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACZ,SAAS,EACT,eAAe,CAAC,CAAC,CAAC,EAClB,SAAS,EACT,SAAS,CAAC,CAAC,CAAC,CACjC,CACF,CAAC;QACJ,CAAC;QACD,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IACxF,CAAC;IACD,OAAO,OAAO,CAAC;AACjB,CAAC;AAGD,MAAM,UAAU,WAAW,CAAC,SAG3B;IACC,MAAM,QAAQ,GAAkB,EAAE,CAAC;IACnC,IAAI,SAAS,CAAC,MAAM,EAAE,CAAC;QACrB,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;IACxE,CAAC;IACD,IAAI,SAAS,CAAC,QAAQ,EAAE,CAAC;QACvB,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC;IAC1E,CAAC;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAGD,MAAM,UAAU,UAAU,CAAC,KAAoB;IAC7C,OAAO,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC,GAAG,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;AAC1D,CAAC;AAGD,MAAM,UAAU,MAAM,CAAC,IAAiB,EAAE,IAAc;IACtD,OAAO,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAAC,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE;QAC7E,IAAI;QACJ,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;KAC9D,CAAC,CAAC;AACL,CAAC;AAGD,MAAM,UAAU,QAAQ,CAAC,GAAgB,EAAE,KAAkB;IAC3D,OAAO,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAAC,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;AACjG,CAAC;AAGD,MAAM,UAAU,eAAe,CAAC,KAAsB;IACpD,IACE,CAAC,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QAC3C,CAAC,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,KAAK,KAAK,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,EAClF,CAAC;QACD,OAAO,EAAE,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;IAChD,CAAC;IACD,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,oBAAoB,CAAC,IAAI,CAAC,KAAK,CAAC;QAClE,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,KAAK,CAAC;QACpC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;AACpD,CAAC;AAGD,MAAM,UAAU,OAAO,CAAC,KAAoB;IAC1C,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACvB,OAAO,KAAK,CAAC;IACf,CAAC;IACD,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACvB,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;IAClB,CAAC;IACD,OAAO,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;AACzD,CAAC;AAGD,MAAM,UAAU,cAAc,CAC5B,IAAiB,EACjB,IAAc,EACd,YAAuB;IAEvB,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACtB,OAAO,IAAI,CAAC;IACd,CAAC;IAGD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE,IAAI,EAAE,WAAW,KAAK,cAAc,CAAC,EAAE,CAAC;QAChH,MAAM,MAAM,GAAG,WAAW,CAAC,qEAAqE,CAAC,CAAC,CAAC,CAAQ,CAAC;QAC5G,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC5B,CAAC;IAED,OAAO,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAAC,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,cAAc,CAAC,EAAE;QACrF,IAAI;QACJ,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;KACvC,CAAC,CAAC;AACL,CAAC;AAOD,MAAM,UAAU,eAAe,CAAC,IAAiB,EAAE,YAAwB;IACzE,IACE,YAAY;QACZ,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE,IAAI,EAAE,WAAW,KAAK,eAAe,CAAC,EAC5G,CAAC;QACD,MAAM,MAAM,GAAG,WAAW,CACxB,wIAAwI,CACzI,CAAC,CAAC,CAAQ,CAAC;QACZ,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC5B,CAAC;IACD,OAAO,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAAC,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,eAAe,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;AAClG,CAAC"}
\ No newline at end of file
diff --git a/package/dist/lib/utils.d.ts b/package/dist/lib/utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ef06148a9586058d0779e17e74013a850bb3eb85
--- /dev/null
+++ b/package/dist/lib/utils.d.ts
@@ -0,0 +1,26 @@
+import c from "ansi-colors";
+import ts from "typescript";
+import type { DiscriminatorObject, OpenAPI3, OpenAPITSOptions } from "../types.js";
+export { c };
+export declare function createDiscriminatorProperty(discriminator: DiscriminatorObject, { path, readonly }: {
+    path: string;
+    readonly?: boolean;
+}): ts.TypeElement;
+export declare function createRef(parts: (number | string | undefined | null)[]): string;
+export declare function debug(msg: string, group?: string, time?: number): void;
+export declare function error(msg: string): void;
+export declare function formatTime(t: number): string;
+export declare function getEntries<T>(obj: ArrayLike<T> | Record<string, T>, options?: {
+    alphabetize?: boolean;
+    excludeDeprecated?: boolean;
+}): [string, T][];
+export declare function resolveRef<T>(schema: any, $ref: string, { silent, visited }: {
+    silent: boolean;
+    visited?: string[];
+}): T | undefined;
+export declare function scanDiscriminators(schema: OpenAPI3, options: OpenAPITSOptions): {
+    objects: Record<string, DiscriminatorObject>;
+    refsHandled: string[];
+};
+export declare function walk(obj: unknown, cb: (value: Record<string, unknown>, path: (string | number)[]) => void, path?: (string | number)[]): void;
+export declare function warn(msg: string, silent?: boolean): void;
diff --git a/package/dist/lib/utils.js b/package/dist/lib/utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..bede54e75eee62b7ecadc33fd9f502ab101a8498
--- /dev/null
+++ b/package/dist/lib/utils.js
@@ -0,0 +1,260 @@
+import { escapePointer, parseRef } from "@redocly/openapi-core/lib/ref-utils.js";
+import c from "ansi-colors";
+import supportsColor from "supports-color";
+import ts from "typescript";
+import { tsLiteral, tsModifiers, tsPropertyIndex } from "./ts.js";
+if (!supportsColor.stdout || supportsColor.stdout.hasBasic === false) {
+    c.enabled = false;
+}
+const DEBUG_GROUPS = {
+    redoc: c.cyanBright,
+    lint: c.yellowBright,
+    bundle: c.magentaBright,
+    ts: c.blueBright,
+};
+export { c };
+export function createDiscriminatorProperty(discriminator, { path, readonly = false }) {
+    let value = parseRef(path).pointer.pop();
+    if (discriminator.mapping) {
+        const matchedValue = Object.entries(discriminator.mapping).find(([, v]) => (!v.startsWith("#") && v === value) || (v.startsWith("#") && parseRef(v).pointer.pop() === value));
+        if (matchedValue) {
+            value = matchedValue[0];
+        }
+    }
+    return ts.factory.createPropertySignature(tsModifiers({
+        readonly,
+    }), tsPropertyIndex(discriminator.propertyName), undefined, tsLiteral(value));
+}
+export function createRef(parts) {
+    let pointer = "#";
+    for (const part of parts) {
+        if (part === undefined || part === null || part === "") {
+            continue;
+        }
+        const maybeRef = parseRef(String(part)).pointer;
+        if (maybeRef.length) {
+            for (const refPart of maybeRef) {
+                pointer += `/${escapePointer(refPart)}`;
+            }
+        }
+        else {
+            pointer += `/${escapePointer(part)}`;
+        }
+    }
+    return pointer;
+}
+export function debug(msg, group, time) {
+    if (process.env.DEBUG &&
+        (!group ||
+            process.env.DEBUG === "*" ||
+            process.env.DEBUG === "openapi-ts:*" ||
+            process.env.DEBUG.toLocaleLowerCase() === `openapi-ts:${group.toLocaleLowerCase()}`)) {
+        const groupColor = (group && DEBUG_GROUPS[group]) || c.whiteBright;
+        const groupName = groupColor(`openapi-ts:${group ?? "info"}`);
+        let timeFormatted = "";
+        if (typeof time === "number") {
+            timeFormatted = c.green(` ${formatTime(time)} `);
+        }
+        console.debug(`  ${c.bold(groupName)}${timeFormatted}${msg}`);
+    }
+}
+export function error(msg) {
+    console.error(c.red(` ✘  ${msg}`));
+}
+export function formatTime(t) {
+    if (typeof t === "number") {
+        if (t < 1000) {
+            return `${Math.round(10 * t) / 10}ms`;
+        }
+        if (t < 60000) {
+            return `${Math.round(t / 100) / 10}s`;
+        }
+        return `${Math.round(t / 6000) / 10}m`;
+    }
+    return t;
+}
+export function getEntries(obj, options) {
+    let entries = Object.entries(obj);
+    if (options?.alphabetize) {
+        entries.sort(([a], [b]) => a.localeCompare(b, "en-us", { numeric: true }));
+    }
+    if (options?.excludeDeprecated) {
+        entries = entries.filter(([, v]) => !(v && typeof v === "object" && "deprecated" in v && v.deprecated));
+    }
+    return entries;
+}
+export function resolveRef(schema, $ref, { silent = false, visited = [] }) {
+    const { pointer } = parseRef($ref);
+    if (!pointer.length) {
+        return undefined;
+    }
+    let node = schema;
+    for (const key of pointer) {
+        if (node && typeof node === "object" && node[key]) {
+            node = node[key];
+        }
+        else {
+            warn(`Could not resolve $ref "${$ref}"`, silent);
+            return undefined;
+        }
+    }
+    if (node && typeof node === "object" && node.$ref) {
+        if (visited.includes(node.$ref)) {
+            warn(`Could not resolve circular $ref "${$ref}"`, silent);
+            return undefined;
+        }
+        return resolveRef(schema, node.$ref, {
+            silent,
+            visited: [...visited, node.$ref],
+        });
+    }
+    return node;
+}
+function createDiscriminatorEnum(values, prevSchema) {
+    return {
+        type: "string",
+        enum: values,
+        description: prevSchema?.description
+            ? `${prevSchema.description} (enum property replaced by openapi-typescript)`
+            : "discriminator enum property added by openapi-typescript",
+    };
+}
+function patchDiscriminatorEnum(schema, ref, values, discriminator, discriminatorRef, options) {
+    const resolvedSchema = resolveRef(schema, ref, {
+        silent: options.silent ?? false,
+    });
+    if (resolvedSchema?.allOf) {
+        resolvedSchema.allOf.push({
+            type: "object",
+            required: [discriminator.propertyName],
+            properties: {
+                [discriminator.propertyName]: createDiscriminatorEnum(values),
+            },
+        });
+        return true;
+    }
+    else if (typeof resolvedSchema === "object" && "type" in resolvedSchema && resolvedSchema.type === "object") {
+        if (!resolvedSchema.properties) {
+            resolvedSchema.properties = {};
+        }
+        if (!resolvedSchema.required) {
+            resolvedSchema.required = [discriminator.propertyName];
+        }
+        else if (!resolvedSchema.required.includes(discriminator.propertyName)) {
+            resolvedSchema.required.push(discriminator.propertyName);
+        }
+        resolvedSchema.properties[discriminator.propertyName] = createDiscriminatorEnum(values, resolvedSchema.properties[discriminator.propertyName]);
+        return true;
+    }
+    warn(`Discriminator mapping has an invalid schema (neither an object schema nor an allOf array): ${ref} => ${values.join(", ")} (Discriminator: ${discriminatorRef})`, options.silent);
+    return false;
+}
+export function scanDiscriminators(schema, options) {
+    const objects = {};
+    const refsHandled = [];
+    walk(schema, (obj, path) => {
+        const discriminator = obj?.discriminator;
+        if (!discriminator?.propertyName) {
+            return;
+        }
+        const ref = createRef(path);
+        objects[ref] = discriminator;
+        if (!obj?.oneOf || !Array.isArray(obj.oneOf)) {
+            return;
+        }
+        const oneOf = obj.oneOf;
+        const mapping = {};
+        for (const item of oneOf) {
+            if ("$ref" in item) {
+                const value = item.$ref.split("/").pop();
+                if (value) {
+                    if (!mapping[item.$ref]) {
+                        mapping[item.$ref] = { inferred: value };
+                    }
+                    else {
+                        mapping[item.$ref].inferred = value;
+                    }
+                }
+            }
+        }
+        if (discriminator.mapping) {
+            for (const mappedValue in discriminator.mapping) {
+                const mappedRef = discriminator.mapping[mappedValue];
+                if (!mappedRef) {
+                    continue;
+                }
+                if (!mapping[mappedRef]?.defined) {
+                    mapping[mappedRef] = { defined: [] };
+                }
+                mapping[mappedRef].defined?.push(mappedValue);
+            }
+        }
+        for (const [mappedRef, { inferred, defined }] of Object.entries(mapping)) {
+            if (refsHandled.includes(mappedRef)) {
+                continue;
+            }
+            if (!inferred && !defined) {
+                continue;
+            }
+            const mappedValues = defined ?? [inferred];
+            if (patchDiscriminatorEnum(schema, mappedRef, mappedValues, discriminator, ref, options)) {
+                refsHandled.push(mappedRef);
+            }
+        }
+    });
+    walk(schema, (obj, path) => {
+        if (!obj || !Array.isArray(obj.allOf)) {
+            return;
+        }
+        for (const item of obj.allOf) {
+            if ("$ref" in item) {
+                if (!objects[item.$ref]) {
+                    return;
+                }
+                const ref = createRef(path);
+                const discriminator = objects[item.$ref];
+                const mappedValues = [];
+                if (discriminator.mapping) {
+                    for (const mappedValue in discriminator.mapping) {
+                        if (discriminator.mapping[mappedValue] === ref) {
+                            mappedValues.push(mappedValue);
+                        }
+                    }
+                    if (mappedValues.length > 0) {
+                        if (patchDiscriminatorEnum(schema, ref, mappedValues, discriminator, item.$ref, options)) {
+                            refsHandled.push(ref);
+                        }
+                    }
+                }
+                objects[ref] = {
+                    ...objects[item.$ref],
+                };
+            }
+            else if (item.discriminator?.propertyName) {
+                objects[createRef(path)] = { ...item.discriminator };
+            }
+        }
+    });
+    return { objects, refsHandled };
+}
+export function walk(obj, cb, path = []) {
+    if (!obj || typeof obj !== "object") {
+        return;
+    }
+    if (Array.isArray(obj)) {
+        for (let i = 0; i < obj.length; i++) {
+            walk(obj[i], cb, path.concat(i));
+        }
+        return;
+    }
+    cb(obj, path);
+    for (const k of Object.keys(obj)) {
+        walk(obj[k], cb, path.concat(k));
+    }
+}
+export function warn(msg, silent = false) {
+    if (!silent) {
+        console.warn(c.yellow(` ⚠  ${msg}`));
+    }
+}
+//# sourceMappingURL=utils.js.map
\ No newline at end of file
diff --git a/package/dist/lib/utils.js.map b/package/dist/lib/utils.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..96db2780c2c0d15386fb7d94e6a268cf9340d96b
--- /dev/null
+++ b/package/dist/lib/utils.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/lib/utils.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/components-object.d.ts b/package/dist/transform/components-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7eeae8a73e573f1d51ce8cd199e26d82b9dd79bf
--- /dev/null
+++ b/package/dist/transform/components-object.d.ts
@@ -0,0 +1,4 @@
+import ts from "typescript";
+import type { ComponentsObject, GlobalContext } from "../types.js";
+export default function transformComponentsObject(componentsObject: ComponentsObject, ctx: GlobalContext): ts.Node[];
+export declare function singularizeComponentKey(key: `x-${string}` | "schemas" | "responses" | "parameters" | "requestBodies" | "headers" | "pathItems"): string;
diff --git a/package/dist/transform/components-object.js b/package/dist/transform/components-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..04e66ecb5918e3dba848e73061cdb4f601611bed
--- /dev/null
+++ b/package/dist/transform/components-object.js
@@ -0,0 +1,87 @@
+import ts from "typescript";
+import * as changeCase from "change-case";
+import { performance } from "node:perf_hooks";
+import { NEVER, QUESTION_TOKEN, addJSDocComment, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef, debug, getEntries } from "../lib/utils.js";
+import transformHeaderObject from "./header-object.js";
+import transformParameterObject from "./parameter-object.js";
+import transformPathItemObject from "./path-item-object.js";
+import transformRequestBodyObject from "./request-body-object.js";
+import transformResponseObject from "./response-object.js";
+import transformSchemaObject from "./schema-object.js";
+const transformers = {
+    schemas: transformSchemaObject,
+    responses: transformResponseObject,
+    parameters: transformParameterObject,
+    requestBodies: transformRequestBodyObject,
+    headers: transformHeaderObject,
+    pathItems: transformPathItemObject,
+};
+export default function transformComponentsObject(componentsObject, ctx) {
+    const type = [];
+    const rootTypeAliases = {};
+    for (const key of Object.keys(transformers)) {
+        const componentT = performance.now();
+        const items = [];
+        if (componentsObject[key]) {
+            for (const [name, item] of getEntries(componentsObject[key], ctx)) {
+                let subType = transformers[key](item, {
+                    path: createRef(["components", key, name]),
+                    schema: item,
+                    ctx,
+                });
+                let hasQuestionToken = false;
+                if (ctx.transform) {
+                    const result = ctx.transform(item, {
+                        path: createRef(["components", key, name]),
+                        schema: item,
+                        ctx,
+                    });
+                    if (result) {
+                        if ("schema" in result) {
+                            subType = result.schema;
+                            hasQuestionToken = result.questionToken;
+                        }
+                        else {
+                            subType = result;
+                        }
+                    }
+                }
+                const property = ts.factory.createPropertySignature(tsModifiers({ readonly: ctx.immutable }), tsPropertyIndex(name), hasQuestionToken ? QUESTION_TOKEN : undefined, subType);
+                addJSDocComment(item, property);
+                items.push(property);
+                if (ctx.rootTypes) {
+                    const componentKey = changeCase.pascalCase(singularizeComponentKey(key));
+                    let aliasName = `${componentKey}${changeCase.pascalCase(name)}`;
+                    let conflictCounter = 1;
+                    while (rootTypeAliases[aliasName] !== undefined) {
+                        conflictCounter++;
+                        aliasName = `${componentKey}${changeCase.pascalCase(name)}_${conflictCounter}`;
+                    }
+                    const ref = ts.factory.createTypeReferenceNode(`components['${key}']['${name}']`);
+                    if (ctx.rootTypesNoSchemaPrefix && key === "schemas") {
+                        aliasName = aliasName.replace(componentKey, "");
+                    }
+                    const typeAlias = ts.factory.createTypeAliasDeclaration(tsModifiers({ export: true }), aliasName, undefined, ref);
+                    rootTypeAliases[aliasName] = typeAlias;
+                }
+            }
+        }
+        type.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex(key), undefined, items.length ? ts.factory.createTypeLiteralNode(items) : NEVER));
+        debug(`Transformed components → ${key}`, "ts", performance.now() - componentT);
+    }
+    let rootTypes = [];
+    if (ctx.rootTypes) {
+        rootTypes = Object.keys(rootTypeAliases).map((k) => rootTypeAliases[k]);
+    }
+    return [ts.factory.createTypeLiteralNode(type), ...rootTypes];
+}
+export function singularizeComponentKey(key) {
+    switch (key) {
+        case "requestBodies":
+            return "requestBody";
+        default:
+            return key.slice(0, -1);
+    }
+}
+//# sourceMappingURL=components-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/components-object.js.map b/package/dist/transform/components-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..abcb4f3dc37b3df73a738e988e6104a07f0d74c6
--- /dev/null
+++ b/package/dist/transform/components-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"components-object.js","sourceRoot":"","sources":["../../src/transform/components-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/header-object.d.ts b/package/dist/transform/header-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4a7b606cffec8e127812d30cde2640e6dc8a469f
--- /dev/null
+++ b/package/dist/transform/header-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { HeaderObject, TransformNodeOptions } from "../types.js";
+export default function transformHeaderObject(headerObject: HeaderObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/header-object.js b/package/dist/transform/header-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..c74c1eb5922fceb4f93936510aa8c7c681e252b1
--- /dev/null
+++ b/package/dist/transform/header-object.js
@@ -0,0 +1,32 @@
+import { escapePointer } from "@redocly/openapi-core/lib/ref-utils.js";
+import ts from "typescript";
+import { addJSDocComment, tsModifiers, tsPropertyIndex, UNKNOWN } from "../lib/ts.js";
+import { getEntries } from "../lib/utils.js";
+import transformMediaTypeObject from "./media-type-object.js";
+import transformSchemaObject from "./schema-object.js";
+export default function transformHeaderObject(headerObject, options) {
+    if (headerObject.schema) {
+        return transformSchemaObject(headerObject.schema, options);
+    }
+    if (headerObject.content) {
+        const type = [];
+        for (const [contentType, mediaTypeObject] of getEntries(headerObject.content ?? {}, options.ctx)) {
+            const nextPath = `${options.path ?? "#"}/${escapePointer(contentType)}`;
+            const mediaType = "$ref" in mediaTypeObject
+                ? transformSchemaObject(mediaTypeObject, {
+                    ...options,
+                    path: nextPath,
+                })
+                : transformMediaTypeObject(mediaTypeObject, {
+                    ...options,
+                    path: nextPath,
+                });
+            const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(contentType), undefined, mediaType);
+            addJSDocComment(mediaTypeObject, property);
+            type.push(property);
+        }
+        return ts.factory.createTypeLiteralNode(type);
+    }
+    return UNKNOWN;
+}
+//# sourceMappingURL=header-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/header-object.js.map b/package/dist/transform/header-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..eda3d1b9001db80a6c45ef27ebb629b825b0b88c
--- /dev/null
+++ b/package/dist/transform/header-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"header-object.js","sourceRoot":"","sources":["../../src/transform/header-object.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,wCAAwC,CAAC;AACvE,OAAO,EAAE,MAAM,YAAY,CAAC;AAC5B,OAAO,EAAE,eAAe,EAAE,WAAW,EAAE,eAAe,EAAE,OAAO,EAAE,MAAM,cAAc,CAAC;AACtF,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAE7C,OAAO,wBAAwB,MAAM,wBAAwB,CAAC;AAC9D,OAAO,qBAAqB,MAAM,oBAAoB,CAAC;AAMvD,MAAM,CAAC,OAAO,UAAU,qBAAqB,CAAC,YAA0B,EAAE,OAA6B;IACrG,IAAI,YAAY,CAAC,MAAM,EAAE,CAAC;QACxB,OAAO,qBAAqB,CAAC,YAAY,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAC7D,CAAC;IAED,IAAI,YAAY,CAAC,OAAO,EAAE,CAAC;QACzB,MAAM,IAAI,GAAqB,EAAE,CAAC;QAClC,KAAK,MAAM,CAAC,WAAW,EAAE,eAAe,CAAC,IAAI,UAAU,CAAC,YAAY,CAAC,OAAO,IAAI,EAAE,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;YACjG,MAAM,QAAQ,GAAG,GAAG,OAAO,CAAC,IAAI,IAAI,GAAG,IAAI,aAAa,CAAC,WAAW,CAAC,EAAE,CAAC;YACxE,MAAM,SAAS,GACb,MAAM,IAAI,eAAe;gBACvB,CAAC,CAAC,qBAAqB,CAAC,eAAe,EAAE;oBACrC,GAAG,OAAO;oBACV,IAAI,EAAE,QAAQ;iBACf,CAAC;gBACJ,CAAC,CAAC,wBAAwB,CAAC,eAAe,EAAE;oBACxC,GAAG,OAAO;oBACV,IAAI,EAAE,QAAQ;iBACf,CAAC,CAAC;YACT,MAAM,QAAQ,GAAG,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAC7B,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,WAAW,CAAC,EAC5B,SAAS,EACT,SAAS,CAC9B,CAAC;YACF,eAAe,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;YAC3C,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC;QACD,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;IAChD,CAAC;IAED,OAAO,OAAO,CAAC;AACjB,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/index.d.ts b/package/dist/transform/index.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..818da4cad15a26059d44d6b36680623ebe90abd0
--- /dev/null
+++ b/package/dist/transform/index.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { GlobalContext, OpenAPI3 } from "../types.js";
+export default function transformSchema(schema: OpenAPI3, ctx: GlobalContext): ts.Node[];
diff --git a/package/dist/transform/index.js b/package/dist/transform/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..2fb6e8d80aee60b2b921f0e7d08d66a8cb27679f
--- /dev/null
+++ b/package/dist/transform/index.js
@@ -0,0 +1,69 @@
+import ts from "typescript";
+import { performance } from "node:perf_hooks";
+import { NEVER, STRING, stringToAST, tsModifiers, tsRecord } from "../lib/ts.js";
+import { createRef, debug } from "../lib/utils.js";
+import transformComponentsObject from "./components-object.js";
+import transformPathsObject from "./paths-object.js";
+import transformSchemaObject from "./schema-object.js";
+import transformWebhooksObject from "./webhooks-object.js";
+import makeApiPathsEnum from "./paths-enum.js";
+const transformers = {
+    paths: transformPathsObject,
+    webhooks: transformWebhooksObject,
+    components: transformComponentsObject,
+    $defs: (node, options) => transformSchemaObject(node, { path: createRef(["$defs"]), ctx: options, schema: node }),
+};
+export default function transformSchema(schema, ctx) {
+    const type = [];
+    if (ctx.inject) {
+        const injectNodes = stringToAST(ctx.inject);
+        type.push(...injectNodes);
+    }
+    for (const root of Object.keys(transformers)) {
+        const emptyObj = ts.factory.createTypeAliasDeclaration(tsModifiers({ export: true }), root, undefined, tsRecord(STRING, NEVER));
+        if (schema[root] && typeof schema[root] === "object") {
+            const rootT = performance.now();
+            const subTypes = [].concat(transformers[root](schema[root], ctx));
+            for (const subType of subTypes) {
+                if (ts.isTypeNode(subType)) {
+                    if (subType.members?.length) {
+                        type.push(ctx.exportType
+                            ? ts.factory.createTypeAliasDeclaration(tsModifiers({ export: true }), root, undefined, subType)
+                            : ts.factory.createInterfaceDeclaration(tsModifiers({ export: true }), root, undefined, undefined, subType.members));
+                        debug(`${root} done`, "ts", performance.now() - rootT);
+                    }
+                    else {
+                        type.push(emptyObj);
+                        debug(`${root} done (skipped)`, "ts", 0);
+                    }
+                }
+                else if (ts.isTypeAliasDeclaration(subType)) {
+                    type.push(subType);
+                }
+                else {
+                    type.push(emptyObj);
+                    debug(`${root} done (skipped)`, "ts", 0);
+                }
+            }
+        }
+        else {
+            type.push(emptyObj);
+            debug(`${root} done (skipped)`, "ts", 0);
+        }
+    }
+    let hasOperations = false;
+    for (const injectedType of ctx.injectFooter) {
+        if (!hasOperations && injectedType?.name?.escapedText === "operations") {
+            hasOperations = true;
+        }
+        type.push(injectedType);
+    }
+    if (!hasOperations) {
+        type.push(ts.factory.createTypeAliasDeclaration(tsModifiers({ export: true }), "operations", undefined, tsRecord(STRING, NEVER)));
+    }
+    if (ctx.makePathsEnum && schema.paths) {
+        type.push(makeApiPathsEnum(schema.paths));
+    }
+    return type;
+}
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/package/dist/transform/index.js.map b/package/dist/transform/index.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..997cbe79a2f99383f848bf1b41b291ddd1669d12
--- /dev/null
+++ b/package/dist/transform/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/transform/index.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/media-type-object.d.ts b/package/dist/transform/media-type-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6d1cd36633da88911320975d8bf3e2655bdd4c7e
--- /dev/null
+++ b/package/dist/transform/media-type-object.d.ts
@@ -0,0 +1,3 @@
+import type ts from "typescript";
+import type { MediaTypeObject, TransformNodeOptions } from "../types.js";
+export default function transformMediaTypeObject(mediaTypeObject: MediaTypeObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/media-type-object.js b/package/dist/transform/media-type-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..8e983d83f07206fdaaf69e8aa38e1f5181b15fb8
--- /dev/null
+++ b/package/dist/transform/media-type-object.js
@@ -0,0 +1,9 @@
+import { UNKNOWN } from "../lib/ts.js";
+import transformSchemaObject from "./schema-object.js";
+export default function transformMediaTypeObject(mediaTypeObject, options) {
+    if (!mediaTypeObject.schema) {
+        return UNKNOWN;
+    }
+    return transformSchemaObject(mediaTypeObject.schema, options);
+}
+//# sourceMappingURL=media-type-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/media-type-object.js.map b/package/dist/transform/media-type-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f4f95f7c44f8e94b4f99afcc2908caf6ba66d407
--- /dev/null
+++ b/package/dist/transform/media-type-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"media-type-object.js","sourceRoot":"","sources":["../../src/transform/media-type-object.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,OAAO,EAAE,MAAM,cAAc,CAAC;AAEvC,OAAO,qBAAqB,MAAM,oBAAoB,CAAC;AAMvD,MAAM,CAAC,OAAO,UAAU,wBAAwB,CAC9C,eAAgC,EAChC,OAA6B;IAE7B,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;QAC5B,OAAO,OAAO,CAAC;IACjB,CAAC;IACD,OAAO,qBAAqB,CAAC,eAAe,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAChE,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/operation-object.d.ts b/package/dist/transform/operation-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..49953102780c120f77165776ddfaacc71716b386
--- /dev/null
+++ b/package/dist/transform/operation-object.d.ts
@@ -0,0 +1,4 @@
+import ts from "typescript";
+import type { OperationObject, TransformNodeOptions } from "../types.js";
+export default function transformOperationObject(operationObject: OperationObject, options: TransformNodeOptions): ts.TypeElement[];
+export declare function injectOperationObject(operationId: string, operationObject: OperationObject, options: TransformNodeOptions): void;
diff --git a/package/dist/transform/operation-object.js b/package/dist/transform/operation-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..d4203a0792594fbea2ae9a6edd30989e9d696819
--- /dev/null
+++ b/package/dist/transform/operation-object.js
@@ -0,0 +1,44 @@
+import ts from "typescript";
+import { NEVER, QUESTION_TOKEN, addJSDocComment, oapiRef, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef } from "../lib/utils.js";
+import { transformParametersArray } from "./parameters-array.js";
+import transformRequestBodyObject from "./request-body-object.js";
+import transformResponsesObject from "./responses-object.js";
+export default function transformOperationObject(operationObject, options) {
+    const type = [];
+    type.push(...transformParametersArray(operationObject.parameters ?? [], options));
+    if (operationObject.requestBody) {
+        const requestBodyType = "$ref" in operationObject.requestBody
+            ? oapiRef(operationObject.requestBody.$ref)
+            : transformRequestBodyObject(operationObject.requestBody, {
+                ...options,
+                path: createRef([options.path, "requestBody"]),
+            });
+        const required = !!("$ref" in operationObject.requestBody
+            ? options.ctx.resolve(operationObject.requestBody.$ref)
+            : operationObject.requestBody)?.required;
+        const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex("requestBody"), required ? undefined : QUESTION_TOKEN, requestBodyType);
+        addJSDocComment(operationObject.requestBody, property);
+        type.push(property);
+    }
+    else {
+        type.push(ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex("requestBody"), QUESTION_TOKEN, NEVER));
+    }
+    type.push(ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex("responses"), undefined, transformResponsesObject(operationObject.responses ?? {}, options)));
+    return type;
+}
+export function injectOperationObject(operationId, operationObject, options) {
+    let operations = options.ctx.injectFooter.find((node) => ts.isInterfaceDeclaration(node) && node.name.text === "operations");
+    if (!operations) {
+        operations = ts.factory.createInterfaceDeclaration(tsModifiers({
+            export: true,
+        }), ts.factory.createIdentifier("operations"), undefined, undefined, []);
+        options.ctx.injectFooter.push(operations);
+    }
+    const type = transformOperationObject(operationObject, options);
+    operations.members = ts.factory.createNodeArray([
+        ...operations.members,
+        ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(operationId), undefined, ts.factory.createTypeLiteralNode(type)),
+    ]);
+}
+//# sourceMappingURL=operation-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/operation-object.js.map b/package/dist/transform/operation-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..e347d2d374dc4a308bd1d74a3f3b9b5c242bb9bf
--- /dev/null
+++ b/package/dist/transform/operation-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"operation-object.js","sourceRoot":"","sources":["../../src/transform/operation-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/parameter-object.d.ts b/package/dist/transform/parameter-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bf6ee2436c3886b5decf5d321689eedb393877c2
--- /dev/null
+++ b/package/dist/transform/parameter-object.d.ts
@@ -0,0 +1,3 @@
+import type ts from "typescript";
+import type { ParameterObject, TransformNodeOptions } from "../types.js";
+export default function transformParameterObject(parameterObject: ParameterObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/parameter-object.js b/package/dist/transform/parameter-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..112fb125abd03c0d7d2b5cda42bf0db5a49f8389
--- /dev/null
+++ b/package/dist/transform/parameter-object.js
@@ -0,0 +1,6 @@
+import { STRING } from "../lib/ts.js";
+import transformSchemaObject from "./schema-object.js";
+export default function transformParameterObject(parameterObject, options) {
+    return parameterObject.schema ? transformSchemaObject(parameterObject.schema, options) : STRING;
+}
+//# sourceMappingURL=parameter-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/parameter-object.js.map b/package/dist/transform/parameter-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..21b286390ff2a6f81b4306e79278b8d874ab64ca
--- /dev/null
+++ b/package/dist/transform/parameter-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"parameter-object.js","sourceRoot":"","sources":["../../src/transform/parameter-object.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;AAEtC,OAAO,qBAAqB,MAAM,oBAAoB,CAAC;AAMvD,MAAM,CAAC,OAAO,UAAU,wBAAwB,CAC9C,eAAgC,EAChC,OAA6B;IAE7B,OAAO,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,qBAAqB,CAAC,eAAe,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;AAClG,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/parameters-array.d.ts b/package/dist/transform/parameters-array.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a6d3d1d26639986155678becb40899e753312ba7
--- /dev/null
+++ b/package/dist/transform/parameters-array.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { ParameterObject, ReferenceObject, TransformNodeOptions } from "../types.js";
+export declare function transformParametersArray(parametersArray: (ParameterObject | ReferenceObject)[], options: TransformNodeOptions): ts.TypeElement[];
diff --git a/package/dist/transform/parameters-array.js b/package/dist/transform/parameters-array.js
new file mode 100644
index 0000000000000000000000000000000000000000..ed51d2f32c7fb3ae1bf48edb534beeac22526574
--- /dev/null
+++ b/package/dist/transform/parameters-array.js
@@ -0,0 +1,80 @@
+import ts from "typescript";
+import { NEVER, QUESTION_TOKEN, addJSDocComment, oapiRef, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef } from "../lib/utils.js";
+import transformParameterObject from "./parameter-object.js";
+const PATH_PARAM_RE = /\{([^}]+)\}/g;
+function createPathParameter(paramName) {
+    return {
+        name: paramName,
+        in: "path",
+        required: true,
+        schema: { type: "string" },
+    };
+}
+function extractPathParamsFromUrl(path) {
+    const params = [];
+    const matches = path.match(PATH_PARAM_RE);
+    if (matches) {
+        for (const match of matches) {
+            const paramName = match.slice(1, -1);
+            params.push(createPathParameter(paramName));
+        }
+    }
+    return params;
+}
+export function transformParametersArray(parametersArray, options) {
+    const type = [];
+    const workingParameters = [...parametersArray];
+    if (options.ctx.generatePathParams && options.path) {
+        const pathString = Array.isArray(options.path) ? options.path[0] : options.path;
+        if (typeof pathString === "string") {
+            const pathParams = extractPathParamsFromUrl(pathString);
+            for (const param of pathParams) {
+                const exists = workingParameters.some((p) => {
+                    const resolved = "$ref" in p ? options.ctx.resolve(p.$ref) : p;
+                    return resolved?.in === "path" && resolved?.name === param.name;
+                });
+                if (!exists) {
+                    workingParameters.push(param);
+                }
+            }
+        }
+    }
+    const paramType = [];
+    for (const paramIn of ["query", "header", "path", "cookie"]) {
+        const paramLocType = [];
+        let operationParameters = workingParameters.map((param) => ({
+            original: param,
+            resolved: "$ref" in param ? options.ctx.resolve(param.$ref) : param,
+        }));
+        if (options.ctx.alphabetize) {
+            operationParameters.sort((a, b) => (a.resolved?.name ?? "").localeCompare(b.resolved?.name ?? ""));
+        }
+        if (options.ctx.excludeDeprecated) {
+            operationParameters = operationParameters.filter(({ resolved }) => !resolved?.deprecated && !resolved?.schema?.deprecated);
+        }
+        for (const { original, resolved } of operationParameters) {
+            if (resolved?.in !== paramIn) {
+                continue;
+            }
+            let optional = undefined;
+            if (paramIn !== "path" && !resolved.required) {
+                optional = QUESTION_TOKEN;
+            }
+            const subType = "$ref" in original
+                ? oapiRef(original.$ref)
+                : transformParameterObject(resolved, {
+                    ...options,
+                    path: createRef([options.path, "parameters", resolved.in, resolved.name]),
+                });
+            const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(resolved?.name), optional, subType);
+            addJSDocComment(resolved, property);
+            paramLocType.push(property);
+        }
+        const allOptional = paramLocType.every((node) => !!node.questionToken);
+        paramType.push(ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(paramIn), allOptional || !paramLocType.length ? QUESTION_TOKEN : undefined, paramLocType.length ? ts.factory.createTypeLiteralNode(paramLocType) : NEVER));
+    }
+    type.push(ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex("parameters"), !paramType.length ? QUESTION_TOKEN : undefined, paramType.length ? ts.factory.createTypeLiteralNode(paramType) : NEVER));
+    return type;
+}
+//# sourceMappingURL=parameters-array.js.map
\ No newline at end of file
diff --git a/package/dist/transform/parameters-array.js.map b/package/dist/transform/parameters-array.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..2defd352db5e597a9354aab71896037d1df89627
--- /dev/null
+++ b/package/dist/transform/parameters-array.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"parameters-array.js","sourceRoot":"","sources":["../../src/transform/parameters-array.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,YAAY,CAAC;AAC5B,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,eAAe,EAAE,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAC7G,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAC;AAE5C,OAAO,wBAAwB,MAAM,uBAAuB,CAAC;AAG7D,MAAM,aAAa,GAAG,cAAc,CAAC;AAKrC,SAAS,mBAAmB,CAAC,SAAiB;IAC5C,OAAO;QACL,IAAI,EAAE,SAAS;QACf,EAAE,EAAE,MAAM;QACV,QAAQ,EAAE,IAAI;QACd,MAAM,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE;KAC3B,CAAC;AACJ,CAAC;AAKD,SAAS,wBAAwB,CAAC,IAAY;IAC5C,MAAM,MAAM,GAAsB,EAAE,CAAC;IACrC,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;IAC1C,IAAI,OAAO,EAAE,CAAC;QACZ,KAAK,MAAM,KAAK,IAAI,OAAO,EAAE,CAAC;YAC5B,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACrC,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9C,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAKD,MAAM,UAAU,wBAAwB,CACtC,eAAsD,EACtD,OAA6B;IAE7B,MAAM,IAAI,GAAqB,EAAE,CAAC;IAGlC,MAAM,iBAAiB,GAAG,CAAC,GAAG,eAAe,CAAC,CAAC;IAG/C,IAAI,OAAO,CAAC,GAAG,CAAC,kBAAkB,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;QACnD,MAAM,UAAU,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC;QAChF,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE,CAAC;YACnC,MAAM,UAAU,GAAG,wBAAwB,CAAC,UAAU,CAAC,CAAC;YAExD,KAAK,MAAM,KAAK,IAAI,UAAU,EAAE,CAAC;gBAC/B,MAAM,MAAM,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE;oBAC1C,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAkB,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAChF,OAAO,QAAQ,EAAE,EAAE,KAAK,MAAM,IAAI,QAAQ,EAAE,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC;gBAClE,CAAC,CAAC,CAAC;gBACH,IAAI,CAAC,MAAM,EAAE,CAAC;oBACZ,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAChC,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAGD,MAAM,SAAS,GAAqB,EAAE,CAAC;IACvC,KAAK,MAAM,OAAO,IAAI,CAAC,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,QAAQ,CAA4B,EAAE,CAAC;QACvF,MAAM,YAAY,GAAqB,EAAE,CAAC;QAC1C,IAAI,mBAAmB,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YAC1D,QAAQ,EAAE,KAAK;YACf,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAkB,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK;SACrF,CAAC,CAAC,CAAC;QAGJ,IAAI,OAAO,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC;YAC5B,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,IAAI,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,EAAE,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC;QACrG,CAAC;QACD,IAAI,OAAO,CAAC,GAAG,CAAC,iBAAiB,EAAE,CAAC;YAClC,mBAAmB,GAAG,mBAAmB,CAAC,MAAM,CAC9C,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC,QAAQ,EAAE,UAAU,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CACzE,CAAC;QACJ,CAAC;QACD,KAAK,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,mBAAmB,EAAE,CAAC;YACzD,IAAI,QAAQ,EAAE,EAAE,KAAK,OAAO,EAAE,CAAC;gBAC7B,SAAS;YACX,CAAC;YACD,IAAI,QAAQ,GAAiC,SAAS,CAAC;YACvD,IAAI,OAAO,KAAK,MAAM,IAAI,CAAE,QAA4B,CAAC,QAAQ,EAAE,CAAC;gBAClE,QAAQ,GAAG,cAAc,CAAC;YAC5B,CAAC;YACD,MAAM,OAAO,GACX,MAAM,IAAI,QAAQ;gBAChB,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC;gBACxB,CAAC,CAAC,wBAAwB,CAAC,QAA2B,EAAE;oBACpD,GAAG,OAAO;oBACV,IAAI,EAAE,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,YAAY,EAAE,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC;iBAC1E,CAAC,CAAC;YACT,MAAM,QAAQ,GAAG,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAC7B,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC,EAC/B,QAAQ,EACR,OAAO,CAC5B,CAAC;YACF,eAAe,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YACpC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC9B,CAAC;QACD,MAAM,WAAW,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACvE,SAAS,CAAC,IAAI,CACZ,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACZ,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,OAAO,CAAC,EACxB,WAAW,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,SAAS,EAChE,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,CACjG,CACF,CAAC;IACJ,CAAC;IACD,IAAI,CAAC,IAAI,CACP,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACZ,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,YAAY,CAAC,EAC7B,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,SAAS,EAC9C,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAC3F,CACF,CAAC;IAEF,OAAO,IAAI,CAAC;AACd,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/path-item-object.d.ts b/package/dist/transform/path-item-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e330caebe2df3f6120883d9ce78d14eb16ccfb06
--- /dev/null
+++ b/package/dist/transform/path-item-object.d.ts
@@ -0,0 +1,4 @@
+import ts from "typescript";
+import type { PathItemObject, TransformNodeOptions } from "../types.js";
+export type Method = "get" | "put" | "post" | "delete" | "options" | "head" | "patch" | "trace";
+export default function transformPathItemObject(pathItem: PathItemObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/path-item-object.js b/package/dist/transform/path-item-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..b51258b816192f3c357de5dcf5e4aeb401516f98
--- /dev/null
+++ b/package/dist/transform/path-item-object.js
@@ -0,0 +1,51 @@
+import ts from "typescript";
+import { NEVER, QUESTION_TOKEN, addJSDocComment, oapiRef, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef } from "../lib/utils.js";
+import transformOperationObject, { injectOperationObject } from "./operation-object.js";
+import { transformParametersArray } from "./parameters-array.js";
+export default function transformPathItemObject(pathItem, options) {
+    const type = [];
+    type.push(...transformParametersArray(pathItem.parameters ?? [], {
+        ...options,
+        path: createRef([options.path, "parameters"]),
+    }));
+    for (const method of ["get", "put", "post", "delete", "options", "head", "patch", "trace"]) {
+        const operationObject = pathItem[method];
+        if (!operationObject ||
+            (options.ctx.excludeDeprecated &&
+                ("$ref" in operationObject ? options.ctx.resolve(operationObject.$ref) : operationObject)
+                    ?.deprecated)) {
+            type.push(ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(method), QUESTION_TOKEN, NEVER));
+            continue;
+        }
+        const keyedParameters = {};
+        if (!("$ref" in operationObject)) {
+            for (const parameter of [...(pathItem.parameters ?? []), ...(operationObject.parameters ?? [])]) {
+                const name = "$ref" in parameter
+                    ? `${options.ctx.resolve(parameter.$ref)?.in}-${options.ctx.resolve(parameter.$ref)?.name}`
+                    : `${parameter.in}-${parameter.name}`;
+                if (name) {
+                    keyedParameters[name] = parameter;
+                }
+            }
+        }
+        let operationType;
+        if ("$ref" in operationObject) {
+            operationType = oapiRef(operationObject.$ref);
+        }
+        else if (operationObject.operationId) {
+            const operationId = operationObject.operationId.replace(HASH_RE, "/");
+            operationType = oapiRef(createRef(["operations", operationId]));
+            injectOperationObject(operationId, { ...operationObject, parameters: Object.values(keyedParameters) }, { ...options, path: createRef([options.path, method]) });
+        }
+        else {
+            operationType = ts.factory.createTypeLiteralNode(transformOperationObject({ ...operationObject, parameters: Object.values(keyedParameters) }, { ...options, path: createRef([options.path, method]) }));
+        }
+        const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(method), undefined, operationType);
+        addJSDocComment(operationObject, property);
+        type.push(property);
+    }
+    return ts.factory.createTypeLiteralNode(type);
+}
+const HASH_RE = /#/g;
+//# sourceMappingURL=path-item-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/path-item-object.js.map b/package/dist/transform/path-item-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..157372e89af06f4867b30e0b4be12849b155aebc
--- /dev/null
+++ b/package/dist/transform/path-item-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"path-item-object.js","sourceRoot":"","sources":["../../src/transform/path-item-object.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,YAAY,CAAC;AAC5B,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,eAAe,EAAE,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAC7G,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAC;AAQ5C,OAAO,wBAAwB,EAAE,EAAE,qBAAqB,EAAE,MAAM,uBAAuB,CAAC;AACxF,OAAO,EAAE,wBAAwB,EAAE,MAAM,uBAAuB,CAAC;AAQjE,MAAM,CAAC,OAAO,UAAU,uBAAuB,CAAC,QAAwB,EAAE,OAA6B;IACrG,MAAM,IAAI,GAAqB,EAAE,CAAC;IAGlC,IAAI,CAAC,IAAI,CACP,GAAG,wBAAwB,CAAC,QAAQ,CAAC,UAAU,IAAI,EAAE,EAAE;QACrD,GAAG,OAAO;QACV,IAAI,EAAE,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;KAC9C,CAAC,CACH,CAAC;IAGF,KAAK,MAAM,MAAM,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAa,EAAE,CAAC;QACvG,MAAM,eAAe,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;QACzC,IACE,CAAC,eAAe;YAChB,CAAC,OAAO,CAAC,GAAG,CAAC,iBAAiB;gBAC5B,CAAC,MAAM,IAAI,eAAe,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAkB,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC;oBACxG,EAAE,UAAU,CAAC,EACjB,CAAC;YACD,IAAI,CAAC,IAAI,CACP,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACZ,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,MAAM,CAAC,EACvB,cAAc,EACd,KAAK,CAC1B,CACF,CAAC;YACF,SAAS;QACX,CAAC;QAGD,MAAM,eAAe,GAAsD,EAAE,CAAC;QAC9E,IAAI,CAAC,CAAC,MAAM,IAAI,eAAe,CAAC,EAAE,CAAC;YAEjC,KAAK,MAAM,SAAS,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,UAAU,IAAI,EAAE,CAAC,EAAE,GAAG,CAAC,eAAe,CAAC,UAAU,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC;gBAEhG,MAAM,IAAI,GACR,MAAM,IAAI,SAAS;oBACjB,CAAC,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,OAAO,CAAkB,SAAS,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,OAAO,CAAC,GAAG,CAAC,OAAO,CAAkB,SAAS,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE;oBAC7H,CAAC,CAAC,GAAG,SAAS,CAAC,EAAE,IAAI,SAAS,CAAC,IAAI,EAAE,CAAC;gBAC1C,IAAI,IAAI,EAAE,CAAC;oBACT,eAAe,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC;gBACpC,CAAC;YACH,CAAC;QACH,CAAC;QAED,IAAI,aAA0B,CAAC;QAC/B,IAAI,MAAM,IAAI,eAAe,EAAE,CAAC;YAC9B,aAAa,GAAG,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAChD,CAAC;aAEI,IAAI,eAAe,CAAC,WAAW,EAAE,CAAC;YAErC,MAAM,WAAW,GAAG,eAAe,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;YACtE,aAAa,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC;YAChE,qBAAqB,CACnB,WAAW,EACX,EAAE,GAAG,eAAe,EAAE,UAAU,EAAE,MAAM,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE,EAClE,EAAE,GAAG,OAAO,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,EAAE,CACxD,CAAC;QACJ,CAAC;aAAM,CAAC;YACN,aAAa,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAC9C,wBAAwB,CACtB,EAAE,GAAG,eAAe,EAAE,UAAU,EAAE,MAAM,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE,EAClE,EAAE,GAAG,OAAO,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,EAAE,CACxD,CACF,CAAC;QACJ,CAAC;QACD,MAAM,QAAQ,GAAG,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAC7B,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,MAAM,CAAC,EACvB,SAAS,EACT,aAAa,CAClC,CAAC;QACF,eAAe,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;QAC3C,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtB,CAAC;IAED,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;AAChD,CAAC;AAED,MAAM,OAAO,GAAG,IAAI,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/paths-enum.d.ts b/package/dist/transform/paths-enum.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..700e7bb6076fc7a0b94980adc003fd2e25109611
--- /dev/null
+++ b/package/dist/transform/paths-enum.d.ts
@@ -0,0 +1,3 @@
+import type ts from "typescript";
+import type { PathsObject } from "../types.js";
+export default function makeApiPathsEnum(pathsObject: PathsObject): ts.EnumDeclaration;
diff --git a/package/dist/transform/paths-enum.js b/package/dist/transform/paths-enum.js
new file mode 100644
index 0000000000000000000000000000000000000000..d4a3362d33bd35430a062245bff721703b65f81f
--- /dev/null
+++ b/package/dist/transform/paths-enum.js
@@ -0,0 +1,35 @@
+import { tsEnum } from "../lib/ts.js";
+import { getEntries } from "../lib/utils.js";
+export default function makeApiPathsEnum(pathsObject) {
+    const enumKeys = [];
+    const enumMetaData = [];
+    for (const [url, pathItemObject] of getEntries(pathsObject)) {
+        for (const [method, operation] of Object.entries(pathItemObject)) {
+            if (!["get", "put", "post", "delete", "options", "head", "patch", "trace"].includes(method)) {
+                continue;
+            }
+            let pathName;
+            if (operation.operationId) {
+                pathName = operation.operationId;
+            }
+            else {
+                pathName = (method + url)
+                    .split("/")
+                    .map((part) => {
+                    const capitalised = part.charAt(0).toUpperCase() + part.slice(1);
+                    return capitalised.replace(/{.*}|:.*|[^a-zA-Z\d_]+/, "");
+                })
+                    .join("");
+            }
+            const adaptedUrl = url.replace(/{(\w+)}/g, ":$1");
+            enumKeys.push(adaptedUrl);
+            enumMetaData.push({
+                name: pathName,
+            });
+        }
+    }
+    return tsEnum("ApiPaths", enumKeys, enumMetaData, {
+        export: true,
+    });
+}
+//# sourceMappingURL=paths-enum.js.map
\ No newline at end of file
diff --git a/package/dist/transform/paths-enum.js.map b/package/dist/transform/paths-enum.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..507e308ddc3d0e11ba544a125e938a34596ea48e
--- /dev/null
+++ b/package/dist/transform/paths-enum.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"paths-enum.js","sourceRoot":"","sources":["../../src/transform/paths-enum.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;AACtC,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAG7C,MAAM,CAAC,OAAO,UAAU,gBAAgB,CAAC,WAAwB;IAC/D,MAAM,QAAQ,GAAG,EAAE,CAAC;IACpB,MAAM,YAAY,GAAG,EAAE,CAAC;IAExB,KAAK,MAAM,CAAC,GAAG,EAAE,cAAc,CAAC,IAAI,UAAU,CAAC,WAAW,CAAC,EAAE,CAAC;QAC5D,KAAK,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC;YACjE,IAAI,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;gBAC5F,SAAS;YACX,CAAC;YAGD,IAAI,QAAgB,CAAC;YACrB,IAAI,SAAS,CAAC,WAAW,EAAE,CAAC;gBAC1B,QAAQ,GAAG,SAAS,CAAC,WAAW,CAAC;YACnC,CAAC;iBAAM,CAAC;gBAEN,QAAQ,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC;qBACtB,KAAK,CAAC,GAAG,CAAC;qBACV,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;oBACZ,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBAIjE,OAAO,WAAW,CAAC,OAAO,CAAC,wBAAwB,EAAE,EAAE,CAAC,CAAC;gBAC3D,CAAC,CAAC;qBACD,IAAI,CAAC,EAAE,CAAC,CAAC;YACd,CAAC;YAGD,MAAM,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YAElD,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC1B,YAAY,CAAC,IAAI,CAAC;gBAChB,IAAI,EAAE,QAAQ;aACf,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED,OAAO,MAAM,CAAC,UAAU,EAAE,QAAQ,EAAE,YAAY,EAAE;QAChD,MAAM,EAAE,IAAI;KACb,CAAC,CAAC;AACL,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/paths-object.d.ts b/package/dist/transform/paths-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b623adf4d5c7da9b46f4371e7072ba85802724ad
--- /dev/null
+++ b/package/dist/transform/paths-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { GlobalContext, PathsObject } from "../types.js";
+export default function transformPathsObject(pathsObject: PathsObject, ctx: GlobalContext): ts.TypeNode;
diff --git a/package/dist/transform/paths-object.js b/package/dist/transform/paths-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..32afe59ed21f0794b10599979872e037f5e5c063
--- /dev/null
+++ b/package/dist/transform/paths-object.js
@@ -0,0 +1,86 @@
+import ts from "typescript";
+import { performance } from "node:perf_hooks";
+import { addJSDocComment, oapiRef, stringToAST, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef, debug, getEntries } from "../lib/utils.js";
+import transformPathItemObject from "./path-item-object.js";
+const PATH_PARAM_RE = /\{[^}]+\}/g;
+export default function transformPathsObject(pathsObject, ctx) {
+    const type = [];
+    for (const [url, pathItemObject] of getEntries(pathsObject, ctx)) {
+        if (!pathItemObject || typeof pathItemObject !== "object") {
+            continue;
+        }
+        const pathT = performance.now();
+        if ("$ref" in pathItemObject) {
+            const property = ts.factory.createPropertySignature(tsModifiers({ readonly: ctx.immutable }), tsPropertyIndex(url), undefined, oapiRef(pathItemObject.$ref));
+            addJSDocComment(pathItemObject, property);
+            type.push(property);
+        }
+        else {
+            const pathItemType = transformPathItemObject(pathItemObject, {
+                path: createRef(["paths", url]),
+                ctx,
+            });
+            if (ctx.pathParamsAsTypes && url.includes("{")) {
+                const pathParams = extractPathParams(pathItemObject, ctx);
+                const matches = url.match(PATH_PARAM_RE);
+                let rawPath = `\`${url}\``;
+                if (matches) {
+                    for (const match of matches) {
+                        const paramName = match.slice(1, -1);
+                        const param = pathParams[paramName];
+                        switch (param?.schema?.type) {
+                            case "number":
+                            case "integer":
+                                rawPath = rawPath.replace(match, "${number}");
+                                break;
+                            case "boolean":
+                                rawPath = rawPath.replace(match, "${boolean}");
+                                break;
+                            default:
+                                rawPath = rawPath.replace(match, "${string}");
+                                break;
+                        }
+                    }
+                    const pathType = stringToAST(rawPath)[0]?.expression;
+                    if (pathType) {
+                        type.push(ts.factory.createIndexSignature(tsModifiers({ readonly: ctx.immutable }), [
+                            ts.factory.createParameterDeclaration(undefined, undefined, "path", undefined, pathType, undefined),
+                        ], pathItemType));
+                        continue;
+                    }
+                }
+            }
+            type.push(ts.factory.createPropertySignature(tsModifiers({ readonly: ctx.immutable }), tsPropertyIndex(url), undefined, pathItemType));
+            debug(`Transformed path "${url}"`, "ts", performance.now() - pathT);
+        }
+    }
+    return ts.factory.createTypeLiteralNode(type);
+}
+function extractPathParams(pathItemObject, ctx) {
+    const params = {};
+    for (const p of pathItemObject.parameters ?? []) {
+        const resolved = "$ref" in p && p.$ref ? ctx.resolve(p.$ref) : p;
+        if (resolved && resolved.in === "path") {
+            params[resolved.name] = resolved;
+        }
+    }
+    for (const method of ["get", "put", "post", "delete", "options", "head", "patch", "trace"]) {
+        if (!(method in pathItemObject)) {
+            continue;
+        }
+        const resolvedMethod = pathItemObject[method].$ref
+            ? ctx.resolve(pathItemObject[method].$ref)
+            : pathItemObject[method];
+        if (resolvedMethod?.parameters) {
+            for (const p of resolvedMethod.parameters) {
+                const resolvedParam = "$ref" in p && p.$ref ? ctx.resolve(p.$ref) : p;
+                if (resolvedParam && resolvedParam.in === "path") {
+                    params[resolvedParam.name] = resolvedParam;
+                }
+            }
+        }
+    }
+    return params;
+}
+//# sourceMappingURL=paths-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/paths-object.js.map b/package/dist/transform/paths-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..9cc98a29a66c074ea496518bbe22404ce1d71068
--- /dev/null
+++ b/package/dist/transform/paths-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"paths-object.js","sourceRoot":"","sources":["../../src/transform/paths-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/request-body-object.d.ts b/package/dist/transform/request-body-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..78ba3e87926b34a1f9f32c3184cccd7924b3c257
--- /dev/null
+++ b/package/dist/transform/request-body-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { RequestBodyObject, TransformNodeOptions } from "../types.js";
+export default function transformRequestBodyObject(requestBodyObject: RequestBodyObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/request-body-object.js b/package/dist/transform/request-body-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..71b18fe99525aec345cf8b47842466d498944f95
--- /dev/null
+++ b/package/dist/transform/request-body-object.js
@@ -0,0 +1,32 @@
+import ts from "typescript";
+import { NEVER, QUESTION_TOKEN, addJSDocComment, tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef, getEntries } from "../lib/utils.js";
+import transformMediaTypeObject from "./media-type-object.js";
+import transformSchemaObject from "./schema-object.js";
+export default function transformRequestBodyObject(requestBodyObject, options) {
+    const type = [];
+    for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {
+        const nextPath = createRef([options.path, contentType]);
+        const mediaType = "$ref" in mediaTypeObject
+            ? transformSchemaObject(mediaTypeObject, {
+                ...options,
+                path: nextPath,
+            })
+            : transformMediaTypeObject(mediaTypeObject, {
+                ...options,
+                path: nextPath,
+            });
+        const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(contentType), undefined, mediaType);
+        addJSDocComment(mediaTypeObject, property);
+        type.push(property);
+    }
+    return ts.factory.createTypeLiteralNode([
+        ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex("content"), undefined, ts.factory.createTypeLiteralNode(type.length
+            ? type
+            :
+                [
+                    ts.factory.createPropertySignature(undefined, tsPropertyIndex("*/*"), QUESTION_TOKEN, NEVER),
+                ])),
+    ]);
+}
+//# sourceMappingURL=request-body-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/request-body-object.js.map b/package/dist/transform/request-body-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..d258b8f890fa6bfc7c04c14402069809df8b9839
--- /dev/null
+++ b/package/dist/transform/request-body-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"request-body-object.js","sourceRoot":"","sources":["../../src/transform/request-body-object.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,YAAY,CAAC;AAC5B,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,eAAe,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AACpG,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAExD,OAAO,wBAAwB,MAAM,wBAAwB,CAAC;AAC9D,OAAO,qBAAqB,MAAM,oBAAoB,CAAC;AAMvD,MAAM,CAAC,OAAO,UAAU,0BAA0B,CAChD,iBAAoC,EACpC,OAA6B;IAE7B,MAAM,IAAI,GAAqB,EAAE,CAAC;IAClC,KAAK,MAAM,CAAC,WAAW,EAAE,eAAe,CAAC,IAAI,UAAU,CAAC,iBAAiB,CAAC,OAAO,IAAI,EAAE,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;QACtG,MAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC,CAAC;QACxD,MAAM,SAAS,GACb,MAAM,IAAI,eAAe;YACvB,CAAC,CAAC,qBAAqB,CAAC,eAAe,EAAE;gBACrC,GAAG,OAAO;gBACV,IAAI,EAAE,QAAQ;aACf,CAAC;YACJ,CAAC,CAAC,wBAAwB,CAAC,eAAe,EAAE;gBACxC,GAAG,OAAO;gBACV,IAAI,EAAE,QAAQ;aACf,CAAC,CAAC;QACT,MAAM,QAAQ,GAAG,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAC7B,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,WAAW,CAAC,EAC5B,SAAS,EACT,SAAS,CAC9B,CAAC;QACF,eAAe,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;QAC3C,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtB,CAAC;IAED,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC;QACtC,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACZ,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,SAAS,CAAC,EAC1B,SAAS,EACT,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAClD,IAAI,CAAC,MAAM;YACT,CAAC,CAAC,IAAI;YACN,CAAC;gBACC;oBACE,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACZ,SAAS,EACT,eAAe,CAAC,KAAK,CAAC,EACtB,cAAc,EACd,KAAK,CAC1B;iBACF,CACN,CACF;KACF,CAAC,CAAC;AACL,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/response-object.d.ts b/package/dist/transform/response-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a285ccf966cfabe6a3a2c5e26bdc29dd004803b5
--- /dev/null
+++ b/package/dist/transform/response-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { ResponseObject, TransformNodeOptions } from "../types.js";
+export default function transformResponseObject(responseObject: ResponseObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/response-object.js b/package/dist/transform/response-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..d16bb7ad730656f4d632c286aec7a830ed6eedf4
--- /dev/null
+++ b/package/dist/transform/response-object.js
@@ -0,0 +1,45 @@
+import ts from "typescript";
+import { NEVER, QUESTION_TOKEN, STRING, UNKNOWN, addJSDocComment, oapiRef, tsModifiers, tsPropertyIndex, } from "../lib/ts.js";
+import { createRef, getEntries } from "../lib/utils.js";
+import transformHeaderObject from "./header-object.js";
+import transformMediaTypeObject from "./media-type-object.js";
+export default function transformResponseObject(responseObject, options) {
+    const type = [];
+    const headersObject = [];
+    if (responseObject.headers) {
+        for (const [name, headerObject] of getEntries(responseObject.headers, options.ctx)) {
+            const optional = "$ref" in headerObject || headerObject.required ? undefined : QUESTION_TOKEN;
+            const subType = "$ref" in headerObject
+                ? oapiRef(headerObject.$ref)
+                : transformHeaderObject(headerObject, {
+                    ...options,
+                    path: createRef([options.path, "headers", name]),
+                });
+            const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(name), optional, subType);
+            addJSDocComment(headerObject, property);
+            headersObject.push(property);
+        }
+    }
+    headersObject.push(ts.factory.createIndexSignature(tsModifiers({ readonly: options.ctx.immutable }), [
+        ts.factory.createParameterDeclaration(undefined, undefined, ts.factory.createIdentifier("name"), undefined, STRING),
+    ], UNKNOWN));
+    type.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex("headers"), undefined, ts.factory.createTypeLiteralNode(headersObject)));
+    const contentObject = [];
+    if (responseObject.content) {
+        for (const [contentType, mediaTypeObject] of getEntries(responseObject.content ?? {}, options.ctx)) {
+            const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(contentType), undefined, transformMediaTypeObject(mediaTypeObject, {
+                ...options,
+                path: createRef([options.path, "content", contentType]),
+            }));
+            contentObject.push(property);
+        }
+    }
+    if (contentObject.length) {
+        type.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex("content"), undefined, ts.factory.createTypeLiteralNode(contentObject)));
+    }
+    else {
+        type.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex("content"), QUESTION_TOKEN, NEVER));
+    }
+    return ts.factory.createTypeLiteralNode(type);
+}
+//# sourceMappingURL=response-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/response-object.js.map b/package/dist/transform/response-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..c097c23d02649a25b59a7a261670e55dbc3e0811
--- /dev/null
+++ b/package/dist/transform/response-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"response-object.js","sourceRoot":"","sources":["../../src/transform/response-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/responses-object.d.ts b/package/dist/transform/responses-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..858eb915359176fcfacbfa143d594301e3fefe75
--- /dev/null
+++ b/package/dist/transform/responses-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { ResponsesObject, TransformNodeOptions } from "../types.js";
+export default function transformResponsesObject(responsesObject: ResponsesObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/responses-object.js b/package/dist/transform/responses-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..750b9d4b7e219096fea6b19a6f9ab1a6e1384d41
--- /dev/null
+++ b/package/dist/transform/responses-object.js
@@ -0,0 +1,20 @@
+import ts from "typescript";
+import { NEVER, addJSDocComment, tsModifiers, oapiRef, tsPropertyIndex } from "../lib/ts.js";
+import { createRef, getEntries } from "../lib/utils.js";
+import transformResponseObject from "./response-object.js";
+export default function transformResponsesObject(responsesObject, options) {
+    const type = [];
+    for (const [responseCode, responseObject] of getEntries(responsesObject, options.ctx)) {
+        const responseType = "$ref" in responseObject
+            ? oapiRef(responseObject.$ref)
+            : transformResponseObject(responseObject, {
+                ...options,
+                path: createRef([options.path, "responses", responseCode]),
+            });
+        const property = ts.factory.createPropertySignature(tsModifiers({ readonly: options.ctx.immutable }), tsPropertyIndex(responseCode), undefined, responseType);
+        addJSDocComment(responseObject, property);
+        type.push(property);
+    }
+    return type.length ? ts.factory.createTypeLiteralNode(type) : NEVER;
+}
+//# sourceMappingURL=responses-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/responses-object.js.map b/package/dist/transform/responses-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..9b7ebcec5ebbf4f420ac57c8010e9d0989f21b56
--- /dev/null
+++ b/package/dist/transform/responses-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"responses-object.js","sourceRoot":"","sources":["../../src/transform/responses-object.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,YAAY,CAAC;AAC5B,OAAO,EAAE,KAAK,EAAE,eAAe,EAAE,WAAW,EAAE,OAAO,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAC7F,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAExD,OAAO,uBAAuB,MAAM,sBAAsB,CAAC;AAM3D,MAAM,CAAC,OAAO,UAAU,wBAAwB,CAC9C,eAAgC,EAChC,OAA6B;IAE7B,MAAM,IAAI,GAAqB,EAAE,CAAC;IAElC,KAAK,MAAM,CAAC,YAAY,EAAE,cAAc,CAAC,IAAI,UAAU,CAAC,eAAe,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;QACtF,MAAM,YAAY,GAChB,MAAM,IAAI,cAAc;YACtB,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC;YAC9B,CAAC,CAAC,uBAAuB,CAAC,cAAc,EAAE;gBACtC,GAAG,OAAO;gBACV,IAAI,EAAE,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC;aAC3D,CAAC,CAAC;QACT,MAAM,QAAQ,GAAG,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAC7B,WAAW,CAAC,EAAE,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,EAChD,eAAe,CAAC,YAAY,CAAC,EAC7B,SAAS,EACT,YAAY,CACjC,CAAC;QACF,eAAe,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;QAC1C,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtB,CAAC;IAED,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;AACtE,CAAC"}
\ No newline at end of file
diff --git a/package/dist/transform/schema-object.d.ts b/package/dist/transform/schema-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3ed4d3e2191184a9c5338f8163a894b91dc4a5a6
--- /dev/null
+++ b/package/dist/transform/schema-object.d.ts
@@ -0,0 +1,4 @@
+import ts from "typescript";
+import type { ReferenceObject, SchemaObject, TransformNodeOptions } from "../types.js";
+export default function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
+export declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
diff --git a/package/dist/transform/schema-object.js b/package/dist/transform/schema-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..10d3271239348b81ea21763c56af076dd9077076
--- /dev/null
+++ b/package/dist/transform/schema-object.js
@@ -0,0 +1,363 @@
+import { parseRef } from "@redocly/openapi-core/lib/ref-utils.js";
+import ts from "typescript";
+import { BOOLEAN, NEVER, NULL, NUMBER, QUESTION_TOKEN, STRING, UNDEFINED, UNKNOWN, addJSDocComment, oapiRef, tsArrayLiteralExpression, tsEnum, tsIntersection, tsIsPrimitive, tsLiteral, tsModifiers, tsNullable, tsPropertyIndex, tsRecord, tsUnion, tsWithRequired, } from "../lib/ts.js";
+import { createDiscriminatorProperty, createRef, getEntries } from "../lib/utils.js";
+export default function transformSchemaObject(schemaObject, options) {
+    const type = transformSchemaObjectWithComposition(schemaObject, options);
+    if (typeof options.ctx.postTransform === "function") {
+        const postTransformResult = options.ctx.postTransform(type, options);
+        if (postTransformResult) {
+            return postTransformResult;
+        }
+    }
+    return type;
+}
+export function transformSchemaObjectWithComposition(schemaObject, options) {
+    if (!schemaObject) {
+        return NEVER;
+    }
+    if (schemaObject === true) {
+        return UNKNOWN;
+    }
+    if (Array.isArray(schemaObject) || typeof schemaObject !== "object") {
+        throw new Error(`Expected SchemaObject, received ${Array.isArray(schemaObject) ? "Array" : typeof schemaObject} at ${options.path}`);
+    }
+    if ("$ref" in schemaObject) {
+        return oapiRef(schemaObject.$ref);
+    }
+    if (schemaObject.const !== null && schemaObject.const !== undefined) {
+        return tsLiteral(schemaObject.const);
+    }
+    if (Array.isArray(schemaObject.enum) &&
+        (!("type" in schemaObject) || schemaObject.type !== "object") &&
+        !("properties" in schemaObject) &&
+        !("additionalProperties" in schemaObject)) {
+        if (options.ctx.enum &&
+            schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number" || v === null)) {
+            let enumName = parseRef(options.path ?? "").pointer.join("/");
+            enumName = enumName.replace("components/schemas", "");
+            const metadata = schemaObject.enum.map((_, i) => ({
+                name: schemaObject["x-enum-varnames"]?.[i] ?? schemaObject["x-enumNames"]?.[i],
+                description: schemaObject["x-enum-descriptions"]?.[i] ?? schemaObject["x-enumDescriptions"]?.[i],
+            }));
+            let hasNull = false;
+            const validSchemaEnums = schemaObject.enum.filter((enumValue) => {
+                if (enumValue === null) {
+                    hasNull = true;
+                    return false;
+                }
+                return true;
+            });
+            const enumType = tsEnum(enumName, validSchemaEnums, metadata, {
+                shouldCache: options.ctx.dedupeEnums,
+                export: true,
+            });
+            if (!options.ctx.injectFooter.includes(enumType)) {
+                options.ctx.injectFooter.push(enumType);
+            }
+            const ref = ts.factory.createTypeReferenceNode(enumType.name);
+            return hasNull ? tsUnion([ref, NULL]) : ref;
+        }
+        const enumType = schemaObject.enum.map(tsLiteral);
+        if (((Array.isArray(schemaObject.type) && schemaObject.type.includes("null")) || schemaObject.nullable) &&
+            !schemaObject.default) {
+            enumType.push(NULL);
+        }
+        const unionType = tsUnion(enumType);
+        if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number")) {
+            let enumValuesVariableName = parseRef(options.path ?? "").pointer.join("/");
+            enumValuesVariableName = enumValuesVariableName.replace("components/schemas", "");
+            enumValuesVariableName = `${enumValuesVariableName}Values`;
+            const enumValuesArray = tsArrayLiteralExpression(enumValuesVariableName, oapiRef(options.path ?? ""), schemaObject.enum, {
+                export: true,
+                readonly: true,
+                injectFooter: options.ctx.injectFooter,
+            });
+            options.ctx.injectFooter.push(enumValuesArray);
+        }
+        return unionType;
+    }
+    function collectUnionCompositions(items) {
+        const output = [];
+        for (const item of items) {
+            output.push(transformSchemaObject(item, options));
+        }
+        return output;
+    }
+    function collectAllOfCompositions(items, required) {
+        const output = [];
+        for (const item of items) {
+            let itemType;
+            if ("$ref" in item) {
+                itemType = transformSchemaObject(item, options);
+                const resolved = options.ctx.resolve(item.$ref);
+                if (resolved &&
+                    typeof resolved === "object" &&
+                    "properties" in resolved &&
+                    !options.ctx.discriminators.refsHandled.includes(item.$ref)) {
+                    const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);
+                    if (validRequired.length) {
+                        itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);
+                    }
+                }
+            }
+            else {
+                const itemRequired = [...(required ?? [])];
+                if (typeof item === "object" && Array.isArray(item.required)) {
+                    itemRequired.push(...item.required);
+                }
+                itemType = transformSchemaObject({ ...item, required: itemRequired }, options);
+            }
+            output.push(itemType);
+        }
+        return output;
+    }
+    let finalType = undefined;
+    const coreObjectType = transformSchemaObjectCore(schemaObject, options);
+    const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);
+    if (coreObjectType || allOfType.length) {
+        const allOf = allOfType.length ? tsIntersection(allOfType) : undefined;
+        finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);
+    }
+    const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);
+    if (anyOfType.length) {
+        finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);
+    }
+    const oneOfType = collectUnionCompositions(schemaObject.oneOf ||
+        ("type" in schemaObject &&
+            schemaObject.type === "object" &&
+            schemaObject.enum) ||
+        []);
+    if (oneOfType.length) {
+        if (oneOfType.every(tsIsPrimitive)) {
+            finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);
+        }
+        else {
+            finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);
+        }
+    }
+    if (!finalType) {
+        if ("type" in schemaObject) {
+            finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);
+        }
+        else {
+            finalType = UNKNOWN;
+        }
+    }
+    if (finalType !== UNKNOWN && schemaObject.nullable && !schemaObject.default) {
+        finalType = tsNullable([finalType]);
+    }
+    return finalType;
+}
+function transformSchemaObjectCore(schemaObject, options) {
+    if ("type" in schemaObject && schemaObject.type) {
+        if (typeof options.ctx.transform === "function") {
+            const result = options.ctx.transform(schemaObject, options);
+            if (result && typeof result === "object") {
+                if ("schema" in result) {
+                    if (result.questionToken) {
+                        return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);
+                    }
+                    else {
+                        return result.schema;
+                    }
+                }
+                else {
+                    return result;
+                }
+            }
+        }
+        if (schemaObject.type === "null") {
+            return NULL;
+        }
+        if (schemaObject.type === "string") {
+            return STRING;
+        }
+        if (schemaObject.type === "number" || schemaObject.type === "integer") {
+            return NUMBER;
+        }
+        if (schemaObject.type === "boolean") {
+            return BOOLEAN;
+        }
+        if (schemaObject.type === "array") {
+            let itemType = UNKNOWN;
+            if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {
+                const prefixItems = schemaObject.prefixItems ?? schemaObject.items;
+                itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));
+            }
+            else if (schemaObject.items) {
+                if ("type" in schemaObject.items && schemaObject.items.type === "array") {
+                    itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));
+                }
+                else {
+                    itemType = transformSchemaObject(schemaObject.items, options);
+                }
+            }
+            const min = typeof schemaObject.minItems === "number" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;
+            const max = typeof schemaObject.maxItems === "number" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems
+                ? schemaObject.maxItems
+                : undefined;
+            const estimateCodeSize = typeof max !== "number" ? min : (max * (max + 1) - min * (min - 1)) / 2;
+            if (options.ctx.arrayLength &&
+                (min !== 0 || max !== undefined) &&
+                estimateCodeSize < 30) {
+                if (min === max) {
+                    const elements = [];
+                    for (let i = 0; i < min; i++) {
+                        elements.push(itemType);
+                    }
+                    return tsUnion([ts.factory.createTupleTypeNode(elements)]);
+                }
+                else if (schemaObject.maxItems > 0) {
+                    const members = [];
+                    for (let i = 0; i <= (max ?? 0) - min; i++) {
+                        const elements = [];
+                        for (let j = min; j < i + min; j++) {
+                            elements.push(itemType);
+                        }
+                        members.push(ts.factory.createTupleTypeNode(elements));
+                    }
+                    return tsUnion(members);
+                }
+                else {
+                    const elements = [];
+                    for (let i = 0; i < min; i++) {
+                        elements.push(itemType);
+                    }
+                    elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));
+                    return ts.factory.createTupleTypeNode(elements);
+                }
+            }
+            const finalType = ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)
+                ? itemType
+                : ts.factory.createArrayTypeNode(itemType);
+            return options.ctx.immutable
+                ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)
+                : finalType;
+        }
+        if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {
+            const uniqueTypes = [];
+            if (Array.isArray(schemaObject.oneOf)) {
+                for (const t of schemaObject.type) {
+                    if ((t === "boolean" || t === "string" || t === "number" || t === "integer" || t === "null") &&
+                        schemaObject.oneOf.find((o) => typeof o === "object" && "type" in o && o.type === t)) {
+                        continue;
+                    }
+                    uniqueTypes.push(t === "null" || t === null
+                        ? NULL
+                        : transformSchemaObject({ ...schemaObject, type: t, oneOf: undefined }, options));
+                }
+            }
+            else {
+                for (const t of schemaObject.type) {
+                    if (t === "null" || t === null) {
+                        if (!schemaObject.default) {
+                            uniqueTypes.push(NULL);
+                        }
+                    }
+                    else {
+                        uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t }, options));
+                    }
+                }
+            }
+            return tsUnion(uniqueTypes);
+        }
+    }
+    const coreObjectType = [];
+    for (const k of ["allOf", "anyOf"]) {
+        if (!schemaObject[k]) {
+            continue;
+        }
+        const discriminator = !schemaObject.discriminator &&
+            !options.ctx.discriminators.refsHandled.includes(options.path ?? "") &&
+            options.ctx.discriminators.objects[options.path ?? ""];
+        if (discriminator) {
+            coreObjectType.unshift(createDiscriminatorProperty(discriminator, {
+                path: options.path ?? "",
+                readonly: options.ctx.immutable,
+            }));
+            break;
+        }
+    }
+    if (("properties" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||
+        ("additionalProperties" in schemaObject && schemaObject.additionalProperties) ||
+        ("$defs" in schemaObject && schemaObject.$defs)) {
+        if (Object.keys(schemaObject.properties ?? {}).length) {
+            for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {
+                if (typeof v !== "object" || Array.isArray(v)) {
+                    throw new Error(`${options.path}: invalid property ${k}. Expected Schema Object, got ${Array.isArray(v) ? "Array" : typeof v}`);
+                }
+                if (options.ctx.excludeDeprecated) {
+                    const resolved = "$ref" in v ? options.ctx.resolve(v.$ref) : v;
+                    if (resolved?.deprecated) {
+                        continue;
+                    }
+                }
+                let optional = schemaObject.required?.includes(k) ||
+                    (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||
+                    ("default" in v &&
+                        options.ctx.defaultNonNullable &&
+                        !options.path?.includes("parameters") &&
+                        !options.path?.includes("requestBody") &&
+                        !options.path?.includes("requestBodies"))
+                    ? undefined
+                    : QUESTION_TOKEN;
+                let type = "$ref" in v
+                    ? oapiRef(v.$ref)
+                    : transformSchemaObject(v, {
+                        ...options,
+                        path: createRef([options.path, k]),
+                    });
+                if (typeof options.ctx.transform === "function") {
+                    const result = options.ctx.transform(v, options);
+                    if (result && typeof result === "object") {
+                        if ("schema" in result) {
+                            type = result.schema;
+                            optional = result.questionToken ? QUESTION_TOKEN : optional;
+                        }
+                        else {
+                            type = result;
+                        }
+                    }
+                }
+                const property = ts.factory.createPropertySignature(tsModifiers({
+                    readonly: options.ctx.immutable || ("readOnly" in v && !!v.readOnly),
+                }), tsPropertyIndex(k), optional, type);
+                addJSDocComment(v, property);
+                coreObjectType.push(property);
+            }
+        }
+        if (schemaObject.$defs && typeof schemaObject.$defs === "object" && Object.keys(schemaObject.$defs).length) {
+            const defKeys = [];
+            for (const [k, v] of Object.entries(schemaObject.$defs)) {
+                const property = ts.factory.createPropertySignature(tsModifiers({
+                    readonly: options.ctx.immutable || ("readonly" in v && !!v.readOnly),
+                }), tsPropertyIndex(k), undefined, transformSchemaObject(v, {
+                    ...options,
+                    path: createRef([options.path, "$defs", k]),
+                }));
+                addJSDocComment(v, property);
+                defKeys.push(property);
+            }
+            coreObjectType.push(ts.factory.createPropertySignature(undefined, tsPropertyIndex("$defs"), undefined, ts.factory.createTypeLiteralNode(defKeys)));
+        }
+        if (schemaObject.additionalProperties || options.ctx.additionalProperties) {
+            const hasExplicitAdditionalProperties = typeof schemaObject.additionalProperties === "object" && Object.keys(schemaObject.additionalProperties).length;
+            const addlType = hasExplicitAdditionalProperties
+                ? transformSchemaObject(schemaObject.additionalProperties, options)
+                : UNKNOWN;
+            return tsIntersection([
+                ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),
+                ts.factory.createTypeLiteralNode([
+                    ts.factory.createIndexSignature(tsModifiers({
+                        readonly: options.ctx.immutable,
+                    }), [
+                        ts.factory.createParameterDeclaration(undefined, undefined, ts.factory.createIdentifier("key"), undefined, STRING),
+                    ], addlType),
+                ]),
+            ]);
+        }
+    }
+    return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;
+}
+//# sourceMappingURL=schema-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/schema-object.js.map b/package/dist/transform/schema-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..fbe11e11385076d2f4f0cf2e54fc616eec061420
--- /dev/null
+++ b/package/dist/transform/schema-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"schema-object.js","sourceRoot":"","sources":["../../src/transform/schema-object.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/package/dist/transform/webhooks-object.d.ts b/package/dist/transform/webhooks-object.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..12cd2a4868227e4c4ab4dae316ef193e00d52568
--- /dev/null
+++ b/package/dist/transform/webhooks-object.d.ts
@@ -0,0 +1,3 @@
+import ts from "typescript";
+import type { GlobalContext, WebhooksObject } from "../types.js";
+export default function transformWebhooksObject(webhooksObject: WebhooksObject, options: GlobalContext): ts.TypeNode;
diff --git a/package/dist/transform/webhooks-object.js b/package/dist/transform/webhooks-object.js
new file mode 100644
index 0000000000000000000000000000000000000000..3f2848200b31d4858e1cc0b391511536b070cd8d
--- /dev/null
+++ b/package/dist/transform/webhooks-object.js
@@ -0,0 +1,17 @@
+import ts from "typescript";
+import { tsModifiers, tsPropertyIndex } from "../lib/ts.js";
+import { createRef, getEntries } from "../lib/utils.js";
+import transformPathItemObject from "./path-item-object.js";
+export default function transformWebhooksObject(webhooksObject, options) {
+    const type = [];
+    for (const [name, pathItemObject] of getEntries(webhooksObject, options)) {
+        type.push(ts.factory.createPropertySignature(tsModifiers({
+            readonly: options.immutable,
+        }), tsPropertyIndex(name), undefined, transformPathItemObject(pathItemObject, {
+            path: createRef(["webhooks", name]),
+            ctx: options,
+        })));
+    }
+    return ts.factory.createTypeLiteralNode(type);
+}
+//# sourceMappingURL=webhooks-object.js.map
\ No newline at end of file
diff --git a/package/dist/transform/webhooks-object.js.map b/package/dist/transform/webhooks-object.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..e3c7c4f9663e5b14cbdf0072c8cd928f2d3b969f
--- /dev/null
+++ b/package/dist/transform/webhooks-object.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"webhooks-object.js","sourceRoot":"","sources":["../../src/transform/webhooks-object.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,YAAY,CAAC;AAC5B,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAC5D,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAExD,OAAO,uBAAuB,MAAM,uBAAuB,CAAC;AAE5D,MAAM,CAAC,OAAO,UAAU,uBAAuB,CAAC,cAA8B,EAAE,OAAsB;IACpG,MAAM,IAAI,GAAqB,EAAE,CAAC;IAElC,KAAK,MAAM,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,UAAU,CAAC,cAAc,EAAE,OAAO,CAAC,EAAE,CAAC;QACzE,IAAI,CAAC,IAAI,CACP,EAAE,CAAC,OAAO,CAAC,uBAAuB,CACZ,WAAW,CAAC;YAC9B,QAAQ,EAAE,OAAO,CAAC,SAAS;SAC5B,CAAC,EACkB,eAAe,CAAC,IAAI,CAAC,EACrB,SAAS,EACT,uBAAuB,CAAC,cAAc,EAAE;YAC1D,IAAI,EAAE,SAAS,CAAC,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;YACnC,GAAG,EAAE,OAAO;SACb,CAAC,CACH,CACF,CAAC;IACJ,CAAC;IAED,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;AAChD,CAAC"}
\ No newline at end of file
diff --git a/package/dist/types.d.ts b/package/dist/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c08afb1fda3b04cca96e9ff887a7f5336fa6b087
--- /dev/null
+++ b/package/dist/types.d.ts
@@ -0,0 +1,372 @@
+import type { Config as RedoclyConfig } from "@redocly/openapi-core";
+import type { PathLike } from "node:fs";
+import type ts from "typescript";
+export interface Extensable {
+    [key: `x-${string}`]: any;
+}
+export interface OpenAPI3 extends Extensable {
+    openapi: string;
+    info: InfoObject;
+    jsonSchemaDialect?: string;
+    servers?: ServerObject[];
+    paths?: PathsObject;
+    webhooks?: {
+        [id: string]: PathItemObject | ReferenceObject;
+    };
+    components?: ComponentsObject;
+    security?: SecurityRequirementObject[];
+    tags?: TagObject[];
+    externalDocs?: ExternalDocumentationObject;
+    $defs?: $defs;
+}
+export interface InfoObject extends Extensable {
+    title: string;
+    summary?: string;
+    description?: string;
+    termsOfService?: string;
+    contact?: ContactObject;
+    license?: LicenseObject;
+    version: string;
+}
+export interface ContactObject extends Extensable {
+    name?: string;
+    url?: string;
+    email?: string;
+}
+export interface LicenseObject extends Extensable {
+    name: string;
+    identifier: string;
+    url: string;
+}
+export interface ServerObject extends Extensable {
+    url: string;
+    description: string;
+    variables: {
+        [name: string]: ServerVariableObject;
+    };
+}
+export interface ServerVariableObject extends Extensable {
+    enum?: string[];
+    default: string;
+    description?: string;
+}
+export interface ComponentsObject extends Extensable {
+    schemas?: Record<string, SchemaObject>;
+    responses?: Record<string, ResponseObject | ReferenceObject>;
+    parameters?: Record<string, ParameterObject | ReferenceObject>;
+    examples?: Record<string, ExampleObject | ReferenceObject>;
+    requestBodies?: Record<string, RequestBodyObject | ReferenceObject>;
+    headers?: Record<string, HeaderObject | ReferenceObject>;
+    securitySchemes?: Record<string, SecuritySchemeObject | ReferenceObject>;
+    links?: Record<string, LinkObject | ReferenceObject>;
+    callbacks?: Record<string, CallbackObject | ReferenceObject>;
+    pathItems?: Record<string, PathItemObject | ReferenceObject>;
+}
+export interface PathsObject {
+    [pathname: string]: PathItemObject | ReferenceObject;
+}
+export interface WebhooksObject {
+    [name: string]: PathItemObject;
+}
+export interface PathItemObject extends Extensable {
+    get?: OperationObject | ReferenceObject;
+    put?: OperationObject | ReferenceObject;
+    post?: OperationObject | ReferenceObject;
+    delete?: OperationObject | ReferenceObject;
+    options?: OperationObject | ReferenceObject;
+    head?: OperationObject | ReferenceObject;
+    patch?: OperationObject | ReferenceObject;
+    trace?: OperationObject | ReferenceObject;
+    servers?: ServerObject[];
+    parameters?: (ParameterObject | ReferenceObject)[];
+}
+export interface OperationObject extends Extensable {
+    tags?: string[];
+    summary?: string;
+    description?: string;
+    externalDocs?: ExternalDocumentationObject;
+    operationId?: string;
+    parameters?: (ParameterObject | ReferenceObject)[];
+    requestBody?: RequestBodyObject | ReferenceObject;
+    responses?: ResponsesObject;
+    callbacks?: Record<string, CallbackObject | ReferenceObject>;
+    deprecated?: boolean;
+    security?: SecurityRequirementObject[];
+    servers?: ServerObject[];
+}
+export interface ExternalDocumentationObject extends Extensable {
+    description?: string;
+    url: string;
+}
+export interface ParameterObject extends Extensable {
+    name: string;
+    in: "query" | "header" | "path" | "cookie";
+    description?: string;
+    required?: boolean;
+    deprecated?: boolean;
+    allowEmptyValue?: boolean;
+    style?: string;
+    explode?: boolean;
+    allowReserved?: boolean;
+    schema?: SchemaObject;
+    example?: any;
+    examples?: {
+        [name: string]: ExampleObject | ReferenceObject;
+    };
+    content?: {
+        [contentType: string]: MediaTypeObject | ReferenceObject;
+    };
+}
+export interface RequestBodyObject extends Extensable {
+    description?: string;
+    content: {
+        [contentType: string]: MediaTypeObject | ReferenceObject;
+    };
+    required?: boolean;
+}
+export interface MediaTypeObject extends Extensable {
+    schema?: SchemaObject | ReferenceObject;
+    example?: any;
+    examples?: {
+        [name: string]: ExampleObject | ReferenceObject;
+    };
+    encoding?: {
+        [propertyName: string]: EncodingObject;
+    };
+}
+export interface EncodingObject extends Extensable {
+    contentType?: string;
+    headers?: {
+        [name: string]: HeaderObject | ReferenceObject;
+    };
+    style?: string;
+    explode?: string;
+    allowReserved?: string;
+}
+export type ResponsesObject = {
+    [responseCode: string]: ResponseObject | ReferenceObject;
+} & {
+    default?: ResponseObject | ReferenceObject;
+};
+export interface ResponseObject extends Extensable {
+    description: string;
+    headers?: {
+        [name: string]: HeaderObject | ReferenceObject;
+    };
+    content?: {
+        [contentType: string]: MediaTypeObject;
+    };
+    links?: {
+        [name: string]: LinkObject | ReferenceObject;
+    };
+}
+export type CallbackObject = Record<string, PathItemObject>;
+export interface ExampleObject extends Extensable {
+    summary?: string;
+    description?: string;
+    value?: any;
+    externalValue?: string;
+}
+export interface LinkObject extends Extensable {
+    operationRef?: string;
+    operationId?: string;
+    parameters?: {
+        [name: string]: `$${string}`;
+    };
+    requestBody?: `$${string}`;
+    description?: string;
+    server?: ServerObject;
+}
+export type HeaderObject = Omit<ParameterObject, "name" | "in">;
+export interface TagObject extends Extensable {
+    name: string;
+    description?: string;
+    externalDocs?: ExternalDocumentationObject;
+}
+export interface ReferenceObject extends Extensable {
+    $ref: string;
+    summary?: string;
+    description?: string;
+}
+export type SchemaObject = {
+    discriminator?: DiscriminatorObject;
+    xml?: XMLObject;
+    externalDocs?: ExternalDocumentationObject;
+    example?: any;
+    title?: string;
+    description?: string;
+    $comment?: string;
+    deprecated?: boolean;
+    readOnly?: boolean;
+    writeOnly?: boolean;
+    enum?: unknown[];
+    const?: unknown;
+    default?: unknown;
+    format?: string;
+    nullable?: boolean;
+    oneOf?: (SchemaObject | ReferenceObject)[];
+    allOf?: (SchemaObject | ReferenceObject)[];
+    anyOf?: (SchemaObject | ReferenceObject)[];
+    required?: string[];
+    [key: `x-${string}`]: any;
+} & (StringSubtype | NumberSubtype | IntegerSubtype | ArraySubtype | BooleanSubtype | NullSubtype | ObjectSubtype | {
+    type: ("string" | "number" | "integer" | "array" | "boolean" | "null" | "object")[];
+});
+export interface TransformObject {
+    schema: ts.TypeNode;
+    questionToken: boolean;
+}
+export interface StringSubtype {
+    type: "string" | ["string", "null"];
+    enum?: (string | ReferenceObject)[];
+}
+export interface NumberSubtype {
+    type: "number" | ["number", "null"];
+    minimum?: number;
+    maximum?: number;
+    enum?: (number | ReferenceObject)[];
+}
+export interface IntegerSubtype {
+    type: "integer" | ["integer", "null"];
+    minimum?: number;
+    maximum?: number;
+    enum?: (number | ReferenceObject)[];
+}
+export interface ArraySubtype {
+    type: "array" | ["array", "null"];
+    prefixItems?: (SchemaObject | ReferenceObject)[];
+    items?: SchemaObject | ReferenceObject | (SchemaObject | ReferenceObject)[];
+    minItems?: number;
+    maxItems?: number;
+    enum?: (SchemaObject | ReferenceObject)[];
+}
+export interface BooleanSubtype {
+    type: "boolean" | ["boolean", "null"];
+    enum?: (boolean | ReferenceObject)[];
+}
+export interface NullSubtype {
+    type: "null";
+}
+export interface ObjectSubtype {
+    type: "object" | ["object", "null"];
+    properties?: {
+        [name: string]: SchemaObject | ReferenceObject;
+    };
+    additionalProperties?: boolean | Record<string, never> | SchemaObject | ReferenceObject;
+    required?: string[];
+    allOf?: (SchemaObject | ReferenceObject)[];
+    anyOf?: (SchemaObject | ReferenceObject)[];
+    enum?: (SchemaObject | ReferenceObject)[];
+    $defs?: $defs;
+}
+export interface DiscriminatorObject {
+    propertyName: string;
+    mapping?: Record<string, string>;
+    oneOf?: string[];
+}
+export interface XMLObject extends Extensable {
+    name?: string;
+    namespace?: string;
+    prefix?: string;
+    attribute?: boolean;
+    wrapped?: boolean;
+}
+export type SecuritySchemeObject = {
+    description?: string;
+    [key: `x-${string}`]: any;
+} & ({
+    type: "apiKey";
+    name: string;
+    in: "query" | "header" | "cookie";
+} | {
+    type: "http";
+    scheme: string;
+    bearer?: string;
+} | {
+    type: "mutualTLS";
+} | {
+    type: "oauth2";
+    flows: OAuthFlowsObject;
+} | {
+    type: "openIdConnect";
+    openIdConnectUrl: string;
+});
+export interface OAuthFlowsObject extends Extensable {
+    implicit?: OAuthFlowObject;
+    password?: OAuthFlowObject;
+    clientCredentials?: OAuthFlowObject;
+    authorizationCode?: OAuthFlowObject;
+}
+export interface OAuthFlowObject extends Extensable {
+    authorizationUrl: string;
+    tokenUrl: string;
+    refreshUrl: string;
+    scopes: {
+        [name: string]: string;
+    };
+}
+export type SecurityRequirementObject = {
+    [P in keyof ComponentsObject["securitySchemes"]]?: string[];
+};
+export interface OpenAPITSOptions {
+    additionalProperties?: boolean;
+    alphabetize?: boolean;
+    arrayLength?: boolean;
+    emptyObjectsUnknown?: boolean;
+    cwd?: PathLike;
+    defaultNonNullable?: boolean;
+    excludeDeprecated?: boolean;
+    transform?: (schemaObject: SchemaObject, options: TransformNodeOptions) => ts.TypeNode | TransformObject | undefined;
+    postTransform?: (type: ts.TypeNode, options: TransformNodeOptions) => ts.TypeNode | undefined;
+    immutable?: boolean;
+    silent?: boolean;
+    version?: number;
+    exportType?: boolean;
+    enum?: boolean;
+    enumValues?: boolean;
+    dedupeEnums?: boolean;
+    pathParamsAsTypes?: boolean;
+    propertiesRequiredByDefault?: boolean;
+    rootTypes?: boolean;
+    rootTypesNoSchemaPrefix?: boolean;
+    redocly?: RedoclyConfig;
+    inject?: string;
+    makePathsEnum?: boolean;
+    generatePathParams?: boolean;
+}
+export interface GlobalContext {
+    additionalProperties: boolean;
+    alphabetize: boolean;
+    arrayLength: boolean;
+    defaultNonNullable: boolean;
+    discriminators: {
+        objects: Record<string, DiscriminatorObject>;
+        refsHandled: string[];
+    };
+    emptyObjectsUnknown: boolean;
+    enum: boolean;
+    enumValues: boolean;
+    dedupeEnums: boolean;
+    excludeDeprecated: boolean;
+    exportType: boolean;
+    immutable: boolean;
+    injectFooter: ts.Node[];
+    pathParamsAsTypes: boolean;
+    postTransform: OpenAPITSOptions["postTransform"];
+    propertiesRequiredByDefault: boolean;
+    rootTypes: boolean;
+    rootTypesNoSchemaPrefix: boolean;
+    redoc: RedoclyConfig;
+    silent: boolean;
+    transform: OpenAPITSOptions["transform"];
+    resolve<T>($ref: string): T | undefined;
+    inject?: string;
+    makePathsEnum: boolean;
+    generatePathParams: boolean;
+}
+export type $defs = Record<string, SchemaObject>;
+export interface TransformNodeOptions {
+    path?: string;
+    schema?: SchemaObject | ReferenceObject;
+    ctx: GlobalContext;
+}
diff --git a/package/dist/types.js b/package/dist/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..718fd38ae40c67ea23b242517cf9919f602c5a3e
--- /dev/null
+++ b/package/dist/types.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/package/dist/types.js.map b/package/dist/types.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..c768b79002615c0e69cc6efdcad6a509c1abaaec
--- /dev/null
+++ b/package/dist/types.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/src/lib/ts.ts b/src/lib/ts.ts
index 534c0f84a8c7341271bc8af9fb3231178b930944..c2b8013b6189721c064ce51ac41ae0dac6179c4a 100644
--- a/src/lib/ts.ts
+++ b/src/lib/ts.ts
@@ -164,7 +164,7 @@ function addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode,
  *       must check the parameter definition to determine the how to index into
  *       the openapi-typescript type.
  **/
-export function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode {
+export function oapiRef(path: string, resolved?: OapiRefResolved, deep = false): ts.TypeNode {
   const { pointer } = parseRef(path);
   if (pointer.length === 0) {
     throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);
@@ -179,7 +179,9 @@ export function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode {
   const restSegments = pointer.slice(3);
 
   const leadingType = addIndexedAccess(
-    ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(initialSegment))),
+    ts.factory.createTypeReferenceNode(
+      ts.factory.createIdentifier(deep ? `FlattenedDeepRequired<${String(initialSegment)}>` : String(initialSegment)),
+    ),
     ...leadingSegments,
   );
 
@@ -305,6 +307,18 @@ export function tsArrayLiteralExpression(
   let variableName = sanitizeMemberName(name);
   variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;
 
+  if (
+    options?.injectFooter &&
+    !options.injectFooter.some(
+      (node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === "FlattenedDeepRequired",
+    )
+  ) {
+    const helper = stringToAST(
+      "type FlattenedDeepRequired<T> = { [K in keyof T]-?: FlattenedDeepRequired<T[K] extends unknown[] | undefined | null ? Extract<T[K], unknown[]>[number] : T[K]>; };",
+    )[0] as any;
+    options.injectFooter.push(helper);
+  }
+
   const arrayType = options?.readonly
     ? tsReadonlyArray(elementType, options.injectFooter)
     : ts.factory.createArrayTypeNode(elementType);
diff --git a/src/transform/request-body-object.ts b/src/transform/request-body-object.ts
index 1c26664044c1ee4a40c48ef5bcf31f5efb48325e..3c641c4757f635dfa745c8484917afd67365748f 100644
--- a/src/transform/request-body-object.ts
+++ b/src/transform/request-body-object.ts
@@ -15,7 +15,7 @@ export default function transformRequestBodyObject(
 ): ts.TypeNode {
   const type: ts.TypeElement[] = [];
   for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {
-    const nextPath = createRef([options.path, contentType]);
+    const nextPath = createRef([options.path, "content", contentType]);
     const mediaType =
       "$ref" in mediaTypeObject
         ? transformSchemaObject(mediaTypeObject, {
diff --git a/src/transform/schema-object.ts b/src/transform/schema-object.ts
index 9e3af3dbfc81b93b53da1190a6e4a882b7d443ad..89684b0e5cc368903670bc939307c92b1335572a 100644
--- a/src/transform/schema-object.ts
+++ b/src/transform/schema-object.ts
@@ -16,7 +16,6 @@ import {
   tsLiteral,
   tsModifiers,
   tsNullable,
-  tsOmit,
   tsPropertyIndex,
   tsRecord,
   tsUnion,
@@ -34,8 +33,9 @@ import type { ReferenceObject, SchemaObject, TransformNodeOptions } from "../typ
 export default function transformSchemaObject(
   schemaObject: SchemaObject | ReferenceObject,
   options: TransformNodeOptions,
+  fromAdditionalProperties = false,
 ): ts.TypeNode {
-  const type = transformSchemaObjectWithComposition(schemaObject, options);
+  const type = transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties);
   if (typeof options.ctx.postTransform === "function") {
     const postTransformResult = options.ctx.postTransform(type, options);
     if (postTransformResult) {
@@ -51,6 +51,7 @@ export default function transformSchemaObject(
 export function transformSchemaObjectWithComposition(
   schemaObject: SchemaObject | ReferenceObject,
   options: TransformNodeOptions,
+  fromAdditionalProperties = false,
 ): ts.TypeNode {
   /**
    * Unexpected types & edge cases
@@ -138,14 +139,39 @@ export function transformSchemaObjectWithComposition(
 
     // hoist array with valid enum values to top level if string/number enum and option is enabled
     if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number")) {
-      let enumValuesVariableName = parseRef(options.path ?? "").pointer.join("/");
+      const parsed = parseRef(options.path ?? "");
+      let enumValuesVariableName = parsed.pointer.join("/");
       // allow #/components/schemas to have simpler names
       enumValuesVariableName = enumValuesVariableName.replace("components/schemas", "");
       enumValuesVariableName = `${enumValuesVariableName}Values`;
 
+      // build a ref path for the type that ignores union indices (anyOf/oneOf) so
+      // type references remain stable even when names include union positions
+      const cleanedPointer: string[] = [];
+      for (let i = 0; i < parsed.pointer.length; i++) {
+        // Example: #/paths/analytics/data/get/responses/400/content/application/json/anyOf/0/message
+        const segment = parsed.pointer[i];
+        if ((segment === "anyOf" || segment === "oneOf") && i < parsed.pointer.length - 1) {
+          const next = parsed.pointer[i + 1];
+          if (/^\d+$/.test(next)) {
+            // If we encounter something like "anyOf/0", we want to skip that part of the path
+            i++;
+            continue;
+          }
+        }
+        cleanedPointer.push(segment);
+      }
+      const cleanedRefPath = createRef(cleanedPointer);
+
       const enumValuesArray = tsArrayLiteralExpression(
         enumValuesVariableName,
-        oapiRef(options.path ?? ""),
+        // If fromAdditionalProperties is true we are dealing with a record type and we should append [string] to the generated type
+        fromAdditionalProperties
+          ? ts.factory.createIndexedAccessTypeNode(
+              oapiRef(cleanedRefPath, undefined, true),
+              ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("string")),
+            )
+          : oapiRef(cleanedRefPath, undefined, true),
         schemaObject.enum as (string | number)[],
         {
           export: true,
@@ -165,10 +191,16 @@ export function transformSchemaObjectWithComposition(
    */
 
   /** Collect oneOf/anyOf */
-  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {
+  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[], unionKey: "anyOf" | "oneOf") {
     const output: ts.TypeNode[] = [];
-    for (const item of items) {
-      output.push(transformSchemaObject(item, options));
+    for (const [index, item] of items.entries()) {
+      output.push(
+        transformSchemaObject(item, {
+          ...options,
+          // include index in path so generated names from nested enums/enumValues are unique
+          path: createRef([options.path, unionKey, String(index)]),
+        }),
+      );
     }
 
     return output;
@@ -210,13 +242,7 @@ export function transformSchemaObjectWithComposition(
         itemType = transformSchemaObject({ ...item, required: itemRequired }, options);
       }
 
-      const discriminator =
-        ("$ref" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;
-      if (discriminator) {
-        output.push(tsOmit(itemType, [discriminator.propertyName]));
-      } else {
-        output.push(itemType);
-      }
+      output.push(itemType);
     }
     return output;
   }
@@ -233,7 +259,7 @@ export function transformSchemaObjectWithComposition(
   }
   // anyOf: union
   // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)
-  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);
+  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? [], "anyOf");
   if (anyOfType.length) {
     finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);
   }
@@ -244,6 +270,7 @@ export function transformSchemaObjectWithComposition(
         schemaObject.type === "object" &&
         (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||
       [],
+    "oneOf",
   );
   if (oneOfType.length) {
     // note: oneOf is the only type that may include primitives
@@ -578,7 +605,7 @@ function transformSchemaObjectCore(schemaObject: SchemaObject, options: Transfor
       typeof schemaObject.patternProperties === "object" && Object.keys(schemaObject.patternProperties).length;
     const stringIndexTypes = [];
     if (hasExplicitAdditionalProperties) {
-      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options));
+      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options, true));
     }
     if (hasImplicitAdditionalProperties || (!schemaObject.additionalProperties && options.ctx.additionalProperties)) {
       stringIndexTypes.push(UNKNOWN);
