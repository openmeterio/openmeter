/**
 * Generated by orval v8.0.2 üç∫
 * Do not edit manually.
 * OpenMeter Cloud API
 * OpenMeter is a cloud native usage metering service.
The OpenMeter API allows you to ingest events, query meter usage, and manage resources.
 * OpenAPI spec version: 1.0.0
 */
import * as zod from 'zod'

/**
 * List all add-ons.
 * @summary List add-ons
 */
export const listAddonsQueryIncludeDeletedDefault = false as const
export const listAddonsQueryIdItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listAddonsQueryKeyItemMax = 64 as const

export const listAddonsQueryKeyItemRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const listAddonsQueryCurrencyItemMin = 3 as const
export const listAddonsQueryCurrencyItemMax = 3 as const

export const listAddonsQueryCurrencyItemRegExp = /^[A-Z]{3}$/
export const listAddonsQueryPageDefault = 1 as const

export const listAddonsQueryPageSizeDefault = 100 as const
export const listAddonsQueryPageSizeMax = 1000 as const

export const ListAddonsQueryParams = zod.object({
  currency: zod
    .array(
      zod.coerce
        .string()
        .min(listAddonsQueryCurrencyItemMin)
        .max(listAddonsQueryCurrencyItemMax)
        .regex(listAddonsQueryCurrencyItemRegExp)
        .describe(
          'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
        ),
    )
    .optional()
    .describe('Filter by addon.currency attribute'),
  id: zod
    .array(
      zod.coerce
        .string()
        .regex(listAddonsQueryIdItemRegExp)
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier).',
        ),
    )
    .optional()
    .describe('Filter by addon.id attribute'),
  includeDeleted: zod.coerce
    .boolean()
    .default(listAddonsQueryIncludeDeletedDefault)
    .describe(
      'Include deleted add-ons in response.\n\nUsage: `?includeDeleted=true`',
    ),
  key: zod
    .array(
      zod.coerce
        .string()
        .min(1)
        .max(listAddonsQueryKeyItemMax)
        .regex(listAddonsQueryKeyItemRegExp)
        .describe(
          'A key is a unique string that is used to identify a resource.',
        ),
    )
    .optional()
    .describe('Filter by addon.key attribute'),
  keyVersion: zod
    .record(zod.string(), zod.array(zod.coerce.number()))
    .optional()
    .describe('Filter by addon.key and addon.version attributes'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'key', 'version', 'created_at', 'updated_at'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listAddonsQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listAddonsQueryPageSizeMax)
    .default(listAddonsQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
  status: zod
    .array(
      zod
        .enum(['draft', 'active', 'archived'])
        .describe(
          'The status of the add-on defined by the effectiveFrom and effectiveTo properties.',
        ),
    )
    .optional()
    .describe(
      'Only return add-ons with the given status.\n\nUsage:\n- `?status=active`: return only the currently active add-ons\n- `?status=draft`: return only the draft add-ons\n- `?status=archived`: return only the archived add-ons',
    ),
})

/**
 * Create a new add-on.
 * @summary Create an add-on
 */
export const createAddonBodyNameMax = 256 as const

export const createAddonBodyDescriptionMax = 1024 as const

export const createAddonBodyKeyMax = 64 as const

export const createAddonBodyKeyRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createAddonBodyCurrencyOneMin = 3 as const
export const createAddonBodyCurrencyOneMax = 3 as const

export const createAddonBodyCurrencyOneRegExp = /^[A-Z]{3}$/
export const createAddonBodyCurrencyDefault = 'USD' as const
export const createAddonBodyRateCardsItemOneKeyMax = 64 as const

export const createAddonBodyRateCardsItemOneKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createAddonBodyRateCardsItemOneNameMax = 256 as const

export const createAddonBodyRateCardsItemOneDescriptionMax = 1024 as const

export const createAddonBodyRateCardsItemOneFeatureKeyMax = 64 as const

export const createAddonBodyRateCardsItemOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const createAddonBodyRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const createAddonBodyRateCardsItemOneTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const createAddonBodyRateCardsItemOnePriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemOnePriceOnePaymentTermDefault =
  'in_advance' as const
export const createAddonBodyRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoKeyMax = 64 as const

export const createAddonBodyRateCardsItemTwoKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createAddonBodyRateCardsItemTwoNameMax = 256 as const

export const createAddonBodyRateCardsItemTwoDescriptionMax = 1024 as const

export const createAddonBodyRateCardsItemTwoFeatureKeyMax = 64 as const

export const createAddonBodyRateCardsItemTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const createAddonBodyRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const createAddonBodyRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const createAddonBodyRateCardsItemTwoPriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneOnePaymentTermDefault =
  'in_advance' as const
export const createAddonBodyRateCardsItemTwoPriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const createAddonBodyRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneFourMultiplierDefault =
  '1' as const
export const createAddonBodyRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createAddonBodyRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const CreateAddonBody = zod
  .object({
    currency: zod.coerce
      .string()
      .min(createAddonBodyCurrencyOneMin)
      .max(createAddonBodyCurrencyOneMax)
      .regex(createAddonBodyCurrencyOneRegExp)
      .describe(
        'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
      )
      .describe('The currency code of the add-on.'),
    description: zod.coerce
      .string()
      .max(createAddonBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    instanceType: zod
      .enum(['single', 'multiple'])
      .describe(
        'The instanceType of the add-on.\nSingle instance add-ons can be added to subscription only once while add-ons with multiple type can be added more then once.',
      )
      .describe(
        'The instanceType of the add-ons. Can be "single" or "multiple".',
      ),
    key: zod.coerce
      .string()
      .min(1)
      .max(createAddonBodyKeyMax)
      .regex(createAddonBodyKeyRegExp)
      .describe('A semi-unique identifier for the resource.'),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(createAddonBodyNameMax)
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.',
      ),
    rateCards: zod
      .array(
        zod
          .union([
            zod
              .object({
                billingCadence: zod.coerce
                  .string()
                  .nullable()
                  .describe(
                    'The billing cadence of the rate card.\nWhen null it means it is a one time fee.',
                  ),
                description: zod.coerce
                  .string()
                  .max(createAddonBodyRateCardsItemOneDescriptionMax)
                  .optional()
                  .describe(
                    'Optional description of the resource. Maximum 1024 characters.',
                  ),
                discounts: zod
                  .object({
                    percentage: zod
                      .object({
                        percentage: zod.coerce
                          .number()
                          .describe(
                            'Numeric representation of a percentage\n\n50% is represented as 50',
                          )
                          .describe('The percentage of the discount.'),
                      })
                      .describe('Percentage discount.')
                      .optional()
                      .describe('The percentage discount.'),
                    usage: zod
                      .object({
                        quantity: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe(
                            'The quantity of the usage discount.\n\nMust be positive.',
                          ),
                      })
                      .describe(
                        'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                      )
                      .optional()
                      .describe('The usage discount.'),
                  })
                  .describe('Discount by type on a price')
                  .optional()
                  .describe(
                    'The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.',
                  ),
                entitlementTemplate: zod
                  .union([
                    zod
                      .object({
                        isSoftLimit: zod.coerce
                          .boolean()
                          .default(
                            createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault,
                          )
                          .describe(
                            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                          ),
                        issueAfterReset: zod.coerce
                          .number()
                          .min(
                            createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin,
                          )
                          .optional()
                          .describe(
                            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                          ),
                        issueAfterResetPriority: zod.coerce
                          .number()
                          .min(1)
                          .max(
                            createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                          )
                          .default(
                            createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                          )
                          .describe(
                            'Defines the grant priority for the default grant.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        preserveOverageAtReset: zod.coerce
                          .boolean()
                          .default(
                            createAddonBodyRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                          )
                          .describe(
                            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                          ),
                        type: zod.enum(['metered']),
                        usagePeriod: zod.coerce
                          .string()
                          .optional()
                          .describe(
                            'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                          ),
                      })
                      .describe(
                        'The entitlement template with a metered entitlement.',
                      ),
                    zod
                      .object({
                        config: zod.coerce
                          .string()
                          .describe(
                            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        type: zod.enum(['static']),
                      })
                      .describe(
                        'Entitlement template of a static entitlement.',
                      ),
                    zod
                      .object({
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        type: zod.enum(['boolean']),
                      })
                      .describe(
                        'Entitlement template of a boolean entitlement.',
                      ),
                  ])
                  .describe(
                    'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                  )
                  .optional()
                  .describe(
                    'The entitlement of the rate card.\nOnly available when featureKey is set.',
                  ),
                featureKey: zod.coerce
                  .string()
                  .min(1)
                  .max(createAddonBodyRateCardsItemOneFeatureKeyMax)
                  .regex(createAddonBodyRateCardsItemOneFeatureKeyRegExp)
                  .optional()
                  .describe('The feature the customer is entitled to use.'),
                key: zod.coerce
                  .string()
                  .min(1)
                  .max(createAddonBodyRateCardsItemOneKeyMax)
                  .regex(createAddonBodyRateCardsItemOneKeyRegExp)
                  .describe('A semi-unique identifier for the resource.'),
                metadata: zod
                  .record(zod.string(), zod.coerce.string())
                  .describe(
                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                  )
                  .nullish()
                  .describe('Additional metadata for the resource.'),
                name: zod.coerce
                  .string()
                  .min(1)
                  .max(createAddonBodyRateCardsItemOneNameMax)
                  .describe(
                    'Human-readable name for the resource. Between 1 and 256 characters.',
                  ),
                price: zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        createAddonBodyRateCardsItemOnePriceOneAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The amount of the flat price.'),
                    paymentTerm: zod
                      .enum(['in_advance', 'in_arrears'])
                      .describe(
                        'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                      )
                      .default(
                        createAddonBodyRateCardsItemOnePriceOnePaymentTermDefault,
                      )
                      .describe(
                        'The payment term of the flat price.\nDefaults to in advance.',
                      ),
                    type: zod.enum(['flat']),
                  })
                  .describe('Flat price with payment term.')
                  .nullable()
                  .describe(
                    'The price of the rate card.\nWhen null, the feature or service is free.',
                  ),
                taxConfig: zod
                  .object({
                    behavior: zod
                      .enum(['inclusive', 'exclusive'])
                      .describe(
                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                      )
                      .optional()
                      .describe(
                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                      ),
                    customInvoicing: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .describe(
                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                          ),
                      })
                      .describe('Custom invoicing tax config.')
                      .optional()
                      .describe('Custom invoicing tax config.'),
                    stripe: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemOneTaxConfigOneStripeOneCodeRegExp,
                          )
                          .describe(
                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                          ),
                      })
                      .describe('The tax config for Stripe.')
                      .optional()
                      .describe('Stripe tax config.'),
                  })
                  .describe('Set of provider specific tax configs.')
                  .optional()
                  .describe(
                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                  ),
                type: zod.enum(['flat_fee']),
              })
              .describe(
                'A flat fee rate card defines a one-time purchase or a recurring fee.',
              ),
            zod
              .object({
                billingCadence: zod.coerce
                  .string()
                  .describe('The billing cadence of the rate card.'),
                description: zod.coerce
                  .string()
                  .max(createAddonBodyRateCardsItemTwoDescriptionMax)
                  .optional()
                  .describe(
                    'Optional description of the resource. Maximum 1024 characters.',
                  ),
                discounts: zod
                  .object({
                    percentage: zod
                      .object({
                        percentage: zod.coerce
                          .number()
                          .describe(
                            'Numeric representation of a percentage\n\n50% is represented as 50',
                          )
                          .describe('The percentage of the discount.'),
                      })
                      .describe('Percentage discount.')
                      .optional()
                      .describe('The percentage discount.'),
                    usage: zod
                      .object({
                        quantity: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe(
                            'The quantity of the usage discount.\n\nMust be positive.',
                          ),
                      })
                      .describe(
                        'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                      )
                      .optional()
                      .describe('The usage discount.'),
                  })
                  .describe('Discount by type on a price')
                  .optional()
                  .describe(
                    'The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.',
                  ),
                entitlementTemplate: zod
                  .union([
                    zod
                      .object({
                        isSoftLimit: zod.coerce
                          .boolean()
                          .default(
                            createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault,
                          )
                          .describe(
                            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                          ),
                        issueAfterReset: zod.coerce
                          .number()
                          .min(
                            createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin,
                          )
                          .optional()
                          .describe(
                            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                          ),
                        issueAfterResetPriority: zod.coerce
                          .number()
                          .min(1)
                          .max(
                            createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                          )
                          .default(
                            createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                          )
                          .describe(
                            'Defines the grant priority for the default grant.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        preserveOverageAtReset: zod.coerce
                          .boolean()
                          .default(
                            createAddonBodyRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                          )
                          .describe(
                            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                          ),
                        type: zod.enum(['metered']),
                        usagePeriod: zod.coerce
                          .string()
                          .optional()
                          .describe(
                            'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                          ),
                      })
                      .describe(
                        'The entitlement template with a metered entitlement.',
                      ),
                    zod
                      .object({
                        config: zod.coerce
                          .string()
                          .describe(
                            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        type: zod.enum(['static']),
                      })
                      .describe(
                        'Entitlement template of a static entitlement.',
                      ),
                    zod
                      .object({
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        type: zod.enum(['boolean']),
                      })
                      .describe(
                        'Entitlement template of a boolean entitlement.',
                      ),
                  ])
                  .describe(
                    'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                  )
                  .optional()
                  .describe(
                    'The entitlement of the rate card.\nOnly available when featureKey is set.',
                  ),
                featureKey: zod.coerce
                  .string()
                  .min(1)
                  .max(createAddonBodyRateCardsItemTwoFeatureKeyMax)
                  .regex(createAddonBodyRateCardsItemTwoFeatureKeyRegExp)
                  .optional()
                  .describe('The feature the customer is entitled to use.'),
                key: zod.coerce
                  .string()
                  .min(1)
                  .max(createAddonBodyRateCardsItemTwoKeyMax)
                  .regex(createAddonBodyRateCardsItemTwoKeyRegExp)
                  .describe('A semi-unique identifier for the resource.'),
                metadata: zod
                  .record(zod.string(), zod.coerce.string())
                  .describe(
                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                  )
                  .nullish()
                  .describe('Additional metadata for the resource.'),
                name: zod.coerce
                  .string()
                  .min(1)
                  .max(createAddonBodyRateCardsItemTwoNameMax)
                  .describe(
                    'Human-readable name for the resource. Between 1 and 256 characters.',
                  ),
                price: zod
                  .union([
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneOneAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The amount of the flat price.'),
                        paymentTerm: zod
                          .enum(['in_advance', 'in_arrears'])
                          .describe(
                            'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                          )
                          .default(
                            createAddonBodyRateCardsItemTwoPriceOneOnePaymentTermDefault,
                          )
                          .describe(
                            'The payment term of the flat price.\nDefaults to in advance.',
                          ),
                        type: zod.enum(['flat']),
                      })
                      .describe('Flat price with payment term.'),
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneTwoAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The amount of the unit price.'),
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        type: zod.enum(['unit']),
                      })
                      .describe('Unit price with spend commitments.'),
                    zod
                      .object({
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        mode: zod
                          .enum(['volume', 'graduated'])
                          .describe('The mode of the tiered price.')
                          .describe(
                            'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                          ),
                        tiers: zod
                          .array(
                            zod
                              .object({
                                flatPrice: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the flat price.',
                                      ),
                                    type: zod
                                      .enum(['flat'])
                                      .describe('The type of the price.'),
                                  })
                                  .describe('Flat price.')
                                  .nullable()
                                  .describe(
                                    'The flat price component of the tier.',
                                  ),
                                unitPrice: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the unit price.',
                                      ),
                                    type: zod
                                      .enum(['unit'])
                                      .describe('The type of the price.'),
                                  })
                                  .describe('Unit price.')
                                  .nullable()
                                  .describe(
                                    'The unit price component of the tier.',
                                  ),
                                upToAmount: zod.coerce
                                  .string()
                                  .regex(
                                    createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                                  ),
                              })
                              .describe(
                                'A price tier.\nAt least one price component is required in each tier.',
                              ),
                          )
                          .min(1)
                          .describe(
                            'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                          ),
                        type: zod.enum(['tiered']),
                      })
                      .describe('Tiered price with spend commitments.'),
                    zod
                      .object({
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        multiplier: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneFourMultiplierOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .default(
                            createAddonBodyRateCardsItemTwoPriceOneFourMultiplierDefault,
                          )
                          .describe(
                            'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                          ),
                        type: zod.enum(['dynamic']),
                      })
                      .describe('Dynamic price with spend commitments.'),
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneFiveAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The price of one package.'),
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        quantityPerPackage: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The quantity per package.'),
                        type: zod.enum(['package']),
                      })
                      .describe('Package price with spend commitments.'),
                  ])
                  .describe('The price of the usage based rate card.')
                  .nullable()
                  .describe(
                    'The price of the rate card.\nWhen null, the feature or service is free.',
                  ),
                taxConfig: zod
                  .object({
                    behavior: zod
                      .enum(['inclusive', 'exclusive'])
                      .describe(
                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                      )
                      .optional()
                      .describe(
                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                      ),
                    customInvoicing: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .describe(
                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                          ),
                      })
                      .describe('Custom invoicing tax config.')
                      .optional()
                      .describe('Custom invoicing tax config.'),
                    stripe: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .regex(
                            createAddonBodyRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp,
                          )
                          .describe(
                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                          ),
                      })
                      .describe('The tax config for Stripe.')
                      .optional()
                      .describe('Stripe tax config.'),
                  })
                  .describe('Set of provider specific tax configs.')
                  .optional()
                  .describe(
                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                  ),
                type: zod.enum(['usage_based']),
              })
              .describe(
                'A usage-based rate card defines a price based on usage.',
              ),
          ])
          .describe(
            'A rate card defines the pricing and entitlement of a feature or service.',
          ),
      )
      .describe('The rate cards of the add-on.'),
  })
  .describe('Resource create operation model.')

/**
 * Update add-on by id.
 * @summary Update add-on
 */
export const updateAddonPathAddonIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdateAddonParams = zod.object({
  addonId: zod.coerce.string().regex(updateAddonPathAddonIdRegExp),
})

export const updateAddonBodyNameMax = 256 as const

export const updateAddonBodyDescriptionMax = 1024 as const

export const updateAddonBodyRateCardsItemOneKeyMax = 64 as const

export const updateAddonBodyRateCardsItemOneKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updateAddonBodyRateCardsItemOneNameMax = 256 as const

export const updateAddonBodyRateCardsItemOneDescriptionMax = 1024 as const

export const updateAddonBodyRateCardsItemOneFeatureKeyMax = 64 as const

export const updateAddonBodyRateCardsItemOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const updateAddonBodyRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const updateAddonBodyRateCardsItemOneTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const updateAddonBodyRateCardsItemOnePriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemOnePriceOnePaymentTermDefault =
  'in_advance' as const
export const updateAddonBodyRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoKeyMax = 64 as const

export const updateAddonBodyRateCardsItemTwoKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updateAddonBodyRateCardsItemTwoNameMax = 256 as const

export const updateAddonBodyRateCardsItemTwoDescriptionMax = 1024 as const

export const updateAddonBodyRateCardsItemTwoFeatureKeyMax = 64 as const

export const updateAddonBodyRateCardsItemTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const updateAddonBodyRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const updateAddonBodyRateCardsItemTwoPriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneOnePaymentTermDefault =
  'in_advance' as const
export const updateAddonBodyRateCardsItemTwoPriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const updateAddonBodyRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneFourMultiplierDefault =
  '1' as const
export const updateAddonBodyRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateAddonBodyRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const UpdateAddonBody = zod
  .object({
    description: zod.coerce
      .string()
      .max(updateAddonBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    instanceType: zod
      .enum(['single', 'multiple'])
      .describe(
        'The instanceType of the add-on.\nSingle instance add-ons can be added to subscription only once while add-ons with multiple type can be added more then once.',
      )
      .describe(
        'The instanceType of the add-ons. Can be "single" or "multiple".',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(updateAddonBodyNameMax)
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.',
      ),
    rateCards: zod
      .array(
        zod
          .union([
            zod
              .object({
                billingCadence: zod.coerce
                  .string()
                  .nullable()
                  .describe(
                    'The billing cadence of the rate card.\nWhen null it means it is a one time fee.',
                  ),
                description: zod.coerce
                  .string()
                  .max(updateAddonBodyRateCardsItemOneDescriptionMax)
                  .optional()
                  .describe(
                    'Optional description of the resource. Maximum 1024 characters.',
                  ),
                discounts: zod
                  .object({
                    percentage: zod
                      .object({
                        percentage: zod.coerce
                          .number()
                          .describe(
                            'Numeric representation of a percentage\n\n50% is represented as 50',
                          )
                          .describe('The percentage of the discount.'),
                      })
                      .describe('Percentage discount.')
                      .optional()
                      .describe('The percentage discount.'),
                    usage: zod
                      .object({
                        quantity: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe(
                            'The quantity of the usage discount.\n\nMust be positive.',
                          ),
                      })
                      .describe(
                        'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                      )
                      .optional()
                      .describe('The usage discount.'),
                  })
                  .describe('Discount by type on a price')
                  .optional()
                  .describe(
                    'The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.',
                  ),
                entitlementTemplate: zod
                  .union([
                    zod
                      .object({
                        isSoftLimit: zod.coerce
                          .boolean()
                          .default(
                            updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault,
                          )
                          .describe(
                            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                          ),
                        issueAfterReset: zod.coerce
                          .number()
                          .min(
                            updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin,
                          )
                          .optional()
                          .describe(
                            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                          ),
                        issueAfterResetPriority: zod.coerce
                          .number()
                          .min(1)
                          .max(
                            updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                          )
                          .default(
                            updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                          )
                          .describe(
                            'Defines the grant priority for the default grant.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        preserveOverageAtReset: zod.coerce
                          .boolean()
                          .default(
                            updateAddonBodyRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                          )
                          .describe(
                            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                          ),
                        type: zod.enum(['metered']),
                        usagePeriod: zod.coerce
                          .string()
                          .optional()
                          .describe(
                            'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                          ),
                      })
                      .describe(
                        'The entitlement template with a metered entitlement.',
                      ),
                    zod
                      .object({
                        config: zod.coerce
                          .string()
                          .describe(
                            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        type: zod.enum(['static']),
                      })
                      .describe(
                        'Entitlement template of a static entitlement.',
                      ),
                    zod
                      .object({
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        type: zod.enum(['boolean']),
                      })
                      .describe(
                        'Entitlement template of a boolean entitlement.',
                      ),
                  ])
                  .describe(
                    'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                  )
                  .optional()
                  .describe(
                    'The entitlement of the rate card.\nOnly available when featureKey is set.',
                  ),
                featureKey: zod.coerce
                  .string()
                  .min(1)
                  .max(updateAddonBodyRateCardsItemOneFeatureKeyMax)
                  .regex(updateAddonBodyRateCardsItemOneFeatureKeyRegExp)
                  .optional()
                  .describe('The feature the customer is entitled to use.'),
                key: zod.coerce
                  .string()
                  .min(1)
                  .max(updateAddonBodyRateCardsItemOneKeyMax)
                  .regex(updateAddonBodyRateCardsItemOneKeyRegExp)
                  .describe('A semi-unique identifier for the resource.'),
                metadata: zod
                  .record(zod.string(), zod.coerce.string())
                  .describe(
                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                  )
                  .nullish()
                  .describe('Additional metadata for the resource.'),
                name: zod.coerce
                  .string()
                  .min(1)
                  .max(updateAddonBodyRateCardsItemOneNameMax)
                  .describe(
                    'Human-readable name for the resource. Between 1 and 256 characters.',
                  ),
                price: zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        updateAddonBodyRateCardsItemOnePriceOneAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The amount of the flat price.'),
                    paymentTerm: zod
                      .enum(['in_advance', 'in_arrears'])
                      .describe(
                        'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                      )
                      .default(
                        updateAddonBodyRateCardsItemOnePriceOnePaymentTermDefault,
                      )
                      .describe(
                        'The payment term of the flat price.\nDefaults to in advance.',
                      ),
                    type: zod.enum(['flat']),
                  })
                  .describe('Flat price with payment term.')
                  .nullable()
                  .describe(
                    'The price of the rate card.\nWhen null, the feature or service is free.',
                  ),
                taxConfig: zod
                  .object({
                    behavior: zod
                      .enum(['inclusive', 'exclusive'])
                      .describe(
                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                      )
                      .optional()
                      .describe(
                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                      ),
                    customInvoicing: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .describe(
                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                          ),
                      })
                      .describe('Custom invoicing tax config.')
                      .optional()
                      .describe('Custom invoicing tax config.'),
                    stripe: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemOneTaxConfigOneStripeOneCodeRegExp,
                          )
                          .describe(
                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                          ),
                      })
                      .describe('The tax config for Stripe.')
                      .optional()
                      .describe('Stripe tax config.'),
                  })
                  .describe('Set of provider specific tax configs.')
                  .optional()
                  .describe(
                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                  ),
                type: zod.enum(['flat_fee']),
              })
              .describe(
                'A flat fee rate card defines a one-time purchase or a recurring fee.',
              ),
            zod
              .object({
                billingCadence: zod.coerce
                  .string()
                  .describe('The billing cadence of the rate card.'),
                description: zod.coerce
                  .string()
                  .max(updateAddonBodyRateCardsItemTwoDescriptionMax)
                  .optional()
                  .describe(
                    'Optional description of the resource. Maximum 1024 characters.',
                  ),
                discounts: zod
                  .object({
                    percentage: zod
                      .object({
                        percentage: zod.coerce
                          .number()
                          .describe(
                            'Numeric representation of a percentage\n\n50% is represented as 50',
                          )
                          .describe('The percentage of the discount.'),
                      })
                      .describe('Percentage discount.')
                      .optional()
                      .describe('The percentage discount.'),
                    usage: zod
                      .object({
                        quantity: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe(
                            'The quantity of the usage discount.\n\nMust be positive.',
                          ),
                      })
                      .describe(
                        'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                      )
                      .optional()
                      .describe('The usage discount.'),
                  })
                  .describe('Discount by type on a price')
                  .optional()
                  .describe(
                    'The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.',
                  ),
                entitlementTemplate: zod
                  .union([
                    zod
                      .object({
                        isSoftLimit: zod.coerce
                          .boolean()
                          .default(
                            updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault,
                          )
                          .describe(
                            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                          ),
                        issueAfterReset: zod.coerce
                          .number()
                          .min(
                            updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin,
                          )
                          .optional()
                          .describe(
                            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                          ),
                        issueAfterResetPriority: zod.coerce
                          .number()
                          .min(1)
                          .max(
                            updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                          )
                          .default(
                            updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                          )
                          .describe(
                            'Defines the grant priority for the default grant.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        preserveOverageAtReset: zod.coerce
                          .boolean()
                          .default(
                            updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                          )
                          .describe(
                            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                          ),
                        type: zod.enum(['metered']),
                        usagePeriod: zod.coerce
                          .string()
                          .optional()
                          .describe(
                            'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                          ),
                      })
                      .describe(
                        'The entitlement template with a metered entitlement.',
                      ),
                    zod
                      .object({
                        config: zod.coerce
                          .string()
                          .describe(
                            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        type: zod.enum(['static']),
                      })
                      .describe(
                        'Entitlement template of a static entitlement.',
                      ),
                    zod
                      .object({
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .optional()
                          .describe('Additional metadata for the feature.'),
                        type: zod.enum(['boolean']),
                      })
                      .describe(
                        'Entitlement template of a boolean entitlement.',
                      ),
                  ])
                  .describe(
                    'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                  )
                  .optional()
                  .describe(
                    'The entitlement of the rate card.\nOnly available when featureKey is set.',
                  ),
                featureKey: zod.coerce
                  .string()
                  .min(1)
                  .max(updateAddonBodyRateCardsItemTwoFeatureKeyMax)
                  .regex(updateAddonBodyRateCardsItemTwoFeatureKeyRegExp)
                  .optional()
                  .describe('The feature the customer is entitled to use.'),
                key: zod.coerce
                  .string()
                  .min(1)
                  .max(updateAddonBodyRateCardsItemTwoKeyMax)
                  .regex(updateAddonBodyRateCardsItemTwoKeyRegExp)
                  .describe('A semi-unique identifier for the resource.'),
                metadata: zod
                  .record(zod.string(), zod.coerce.string())
                  .describe(
                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                  )
                  .nullish()
                  .describe('Additional metadata for the resource.'),
                name: zod.coerce
                  .string()
                  .min(1)
                  .max(updateAddonBodyRateCardsItemTwoNameMax)
                  .describe(
                    'Human-readable name for the resource. Between 1 and 256 characters.',
                  ),
                price: zod
                  .union([
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneOneAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The amount of the flat price.'),
                        paymentTerm: zod
                          .enum(['in_advance', 'in_arrears'])
                          .describe(
                            'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                          )
                          .default(
                            updateAddonBodyRateCardsItemTwoPriceOneOnePaymentTermDefault,
                          )
                          .describe(
                            'The payment term of the flat price.\nDefaults to in advance.',
                          ),
                        type: zod.enum(['flat']),
                      })
                      .describe('Flat price with payment term.'),
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneTwoAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The amount of the unit price.'),
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        type: zod.enum(['unit']),
                      })
                      .describe('Unit price with spend commitments.'),
                    zod
                      .object({
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        mode: zod
                          .enum(['volume', 'graduated'])
                          .describe('The mode of the tiered price.')
                          .describe(
                            'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                          ),
                        tiers: zod
                          .array(
                            zod
                              .object({
                                flatPrice: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the flat price.',
                                      ),
                                    type: zod
                                      .enum(['flat'])
                                      .describe('The type of the price.'),
                                  })
                                  .describe('Flat price.')
                                  .nullable()
                                  .describe(
                                    'The flat price component of the tier.',
                                  ),
                                unitPrice: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the unit price.',
                                      ),
                                    type: zod
                                      .enum(['unit'])
                                      .describe('The type of the price.'),
                                  })
                                  .describe('Unit price.')
                                  .nullable()
                                  .describe(
                                    'The unit price component of the tier.',
                                  ),
                                upToAmount: zod.coerce
                                  .string()
                                  .regex(
                                    updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                                  ),
                              })
                              .describe(
                                'A price tier.\nAt least one price component is required in each tier.',
                              ),
                          )
                          .min(1)
                          .describe(
                            'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                          ),
                        type: zod.enum(['tiered']),
                      })
                      .describe('Tiered price with spend commitments.'),
                    zod
                      .object({
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        multiplier: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneFourMultiplierOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .default(
                            updateAddonBodyRateCardsItemTwoPriceOneFourMultiplierDefault,
                          )
                          .describe(
                            'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                          ),
                        type: zod.enum(['dynamic']),
                      })
                      .describe('Dynamic price with spend commitments.'),
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneFiveAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The price of one package.'),
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        quantityPerPackage: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The quantity per package.'),
                        type: zod.enum(['package']),
                      })
                      .describe('Package price with spend commitments.'),
                  ])
                  .describe('The price of the usage based rate card.')
                  .nullable()
                  .describe(
                    'The price of the rate card.\nWhen null, the feature or service is free.',
                  ),
                taxConfig: zod
                  .object({
                    behavior: zod
                      .enum(['inclusive', 'exclusive'])
                      .describe(
                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                      )
                      .optional()
                      .describe(
                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                      ),
                    customInvoicing: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .describe(
                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                          ),
                      })
                      .describe('Custom invoicing tax config.')
                      .optional()
                      .describe('Custom invoicing tax config.'),
                    stripe: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .regex(
                            updateAddonBodyRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp,
                          )
                          .describe(
                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                          ),
                      })
                      .describe('The tax config for Stripe.')
                      .optional()
                      .describe('Stripe tax config.'),
                  })
                  .describe('Set of provider specific tax configs.')
                  .optional()
                  .describe(
                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                  ),
                type: zod.enum(['usage_based']),
              })
              .describe(
                'A usage-based rate card defines a price based on usage.',
              ),
          ])
          .describe(
            'A rate card defines the pricing and entitlement of a feature or service.',
          ),
      )
      .describe('The rate cards of the add-on.'),
  })
  .describe('Resource update operation model.')

/**
 * Get add-on by id or key. The latest published version is returned if latter is used.
 * @summary Get add-on
 */
export const getAddonPathAddonIdMax = 64 as const

export const getAddonPathAddonIdRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetAddonParams = zod.object({
  addonId: zod.coerce
    .string()
    .min(1)
    .max(getAddonPathAddonIdMax)
    .regex(getAddonPathAddonIdRegExp),
})

export const getAddonQueryIncludeLatestDefault = false as const

export const GetAddonQueryParams = zod.object({
  includeLatest: zod.coerce
    .boolean()
    .default(getAddonQueryIncludeLatestDefault)
    .describe(
      'Include latest version of the add-on instead of the version in active state.\n\nUsage: `?includeLatest=true`',
    ),
})

/**
 * Soft delete add-on by id.

Once a add-on is deleted it cannot be undeleted.
 * @summary Delete add-on
 */
export const deleteAddonPathAddonIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeleteAddonParams = zod.object({
  addonId: zod.coerce.string().regex(deleteAddonPathAddonIdRegExp),
})

/**
 * Archive a add-on version.
 * @summary Archive add-on version
 */
export const archiveAddonPathAddonIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ArchiveAddonParams = zod.object({
  addonId: zod.coerce.string().regex(archiveAddonPathAddonIdRegExp),
})

/**
 * Publish a add-on version.
 * @summary Publish add-on
 */
export const publishAddonPathAddonIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const PublishAddonParams = zod.object({
  addonId: zod.coerce.string().regex(publishAddonPathAddonIdRegExp),
})

/**
 * List apps.
 * @summary List apps
 */
export const listAppsQueryPageDefault = 1 as const

export const listAppsQueryPageSizeDefault = 100 as const
export const listAppsQueryPageSizeMax = 1000 as const

export const ListAppsQueryParams = zod.object({
  page: zod.coerce
    .number()
    .min(1)
    .default(listAppsQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listAppsQueryPageSizeMax)
    .default(listAppsQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * @summary Submit draft synchronization results
 */
export const appCustomInvoicingDraftSynchronizedPathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const AppCustomInvoicingDraftSynchronizedParams = zod.object({
  invoiceId: zod.coerce
    .string()
    .regex(appCustomInvoicingDraftSynchronizedPathInvoiceIdRegExp),
})

export const appCustomInvoicingDraftSynchronizedBodyInvoicingOneInvoiceNumberOneMax =
  256 as const

export const appCustomInvoicingDraftSynchronizedBodyInvoicingOneLineExternalIdsItemLineIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const appCustomInvoicingDraftSynchronizedBodyInvoicingOneLineDiscountExternalIdsItemLineDiscountIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const AppCustomInvoicingDraftSynchronizedBody = zod
  .object({
    invoicing: zod
      .object({
        externalId: zod.coerce
          .string()
          .optional()
          .describe(
            "If set the invoice's invoicing external ID will be set to this value.",
          ),
        invoiceNumber: zod.coerce
          .string()
          .min(1)
          .max(
            appCustomInvoicingDraftSynchronizedBodyInvoicingOneInvoiceNumberOneMax,
          )
          .describe(
            'InvoiceNumber is a unique identifier for the invoice, generated by the\ninvoicing app.\n\nThe uniqueness depends on a lot of factors:\n- app setting (unique per app or unique per customer)\n- multiple app scenarios (multiple apps generating invoices with the same prefix)',
          )
          .optional()
          .describe("If set the invoice's number will be set to this value."),
        lineDiscountExternalIds: zod
          .array(
            zod
              .object({
                externalId: zod.coerce
                  .string()
                  .describe(
                    "The external ID (e.g. custom invoicing system's ID).",
                  ),
                lineDiscountId: zod.coerce
                  .string()
                  .regex(
                    appCustomInvoicingDraftSynchronizedBodyInvoicingOneLineDiscountExternalIdsItemLineDiscountIdRegExp,
                  )
                  .describe('The line discount ID.'),
              })
              .describe('Mapping between line discounts and external IDs.'),
          )
          .optional()
          .describe(
            "If set the invoice's line discount external IDs will be set to this value.\n\nThis can be used to reference the external system's entities in the\ninvoice.",
          ),
        lineExternalIds: zod
          .array(
            zod
              .object({
                externalId: zod.coerce
                  .string()
                  .describe(
                    "The external ID (e.g. custom invoicing system's ID).",
                  ),
                lineId: zod.coerce
                  .string()
                  .regex(
                    appCustomInvoicingDraftSynchronizedBodyInvoicingOneLineExternalIdsItemLineIdRegExp,
                  )
                  .describe('The line ID.'),
              })
              .describe('Mapping between lines and external IDs.'),
          )
          .optional()
          .describe(
            "If set the invoice's line external IDs will be set to this value.\n\nThis can be used to reference the external system's entities in the\ninvoice.",
          ),
      })
      .describe(
        "Information to synchronize the invoice.\n\nCan be used to store external app's IDs on the invoice or lines.",
      )
      .optional()
      .describe('The result of the synchronization.'),
  })
  .describe('Information to finalize the draft details of an invoice.')

/**
 * @summary Submit issuing synchronization results
 */
export const appCustomInvoicingIssuingSynchronizedPathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const AppCustomInvoicingIssuingSynchronizedParams = zod.object({
  invoiceId: zod.coerce
    .string()
    .regex(appCustomInvoicingIssuingSynchronizedPathInvoiceIdRegExp),
})

export const appCustomInvoicingIssuingSynchronizedBodyInvoicingOneInvoiceNumberOneMax =
  256 as const

export const AppCustomInvoicingIssuingSynchronizedBody = zod
  .object({
    invoicing: zod
      .object({
        invoiceNumber: zod.coerce
          .string()
          .min(1)
          .max(
            appCustomInvoicingIssuingSynchronizedBodyInvoicingOneInvoiceNumberOneMax,
          )
          .describe(
            'InvoiceNumber is a unique identifier for the invoice, generated by the\ninvoicing app.\n\nThe uniqueness depends on a lot of factors:\n- app setting (unique per app or unique per customer)\n- multiple app scenarios (multiple apps generating invoices with the same prefix)',
          )
          .optional()
          .describe("If set the invoice's number will be set to this value."),
        sentToCustomerAt: zod.coerce
          .date()
          .optional()
          .describe(
            "If set the invoice's sent to customer at will be set to this value.",
          ),
      })
      .describe('Information to finalize the invoicing details of an invoice.')
      .optional()
      .describe('The result of the synchronization.'),
    payment: zod
      .object({
        externalId: zod.coerce
          .string()
          .optional()
          .describe(
            "If set the invoice's payment external ID will be set to this value.",
          ),
      })
      .describe('Information to finalize the payment details of an invoice.')
      .optional()
      .describe('The result of the payment synchronization.'),
  })
  .describe(
    'Information to finalize the invoice.\n\nIf invoicing.invoiceNumber is not set, then a new invoice number will be generated (INV- prefix).',
  )

/**
 * @summary Update payment status
 */
export const appCustomInvoicingUpdatePaymentStatusPathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const AppCustomInvoicingUpdatePaymentStatusParams = zod.object({
  invoiceId: zod.coerce
    .string()
    .regex(appCustomInvoicingUpdatePaymentStatusPathInvoiceIdRegExp),
})

export const AppCustomInvoicingUpdatePaymentStatusBody = zod
  .object({
    trigger: zod
      .enum([
        'paid',
        'payment_failed',
        'payment_uncollectible',
        'payment_overdue',
        'action_required',
        'void',
      ])
      .describe('Payment trigger to execute on a finalized invoice.')
      .describe('The trigger to be executed on the invoice.'),
  })
  .describe(
    "Update payment status request.\n\nCan be used to manipulate invoice's payment status (when custominvoicing app is being used).",
  )

/**
 * Get the app.
 * @summary Get app
 */
export const getAppPathIdRegExp = /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetAppParams = zod.object({
  id: zod.coerce.string().regex(getAppPathIdRegExp),
})

/**
 * Update an app.
 * @summary Update app
 */
export const updateAppPathIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdateAppParams = zod.object({
  id: zod.coerce.string().regex(updateAppPathIdRegExp),
})

export const updateAppBodyOneNameMax = 256 as const

export const updateAppBodyOneDescriptionMax = 1024 as const

export const updateAppBodyTwoNameMax = 256 as const

export const updateAppBodyTwoDescriptionMax = 1024 as const

export const updateAppBodyThreeNameMax = 256 as const

export const updateAppBodyThreeDescriptionMax = 1024 as const

export const UpdateAppBody = zod
  .union([
    zod
      .object({
        description: zod.coerce
          .string()
          .max(updateAppBodyOneDescriptionMax)
          .optional()
          .describe(
            'Optional description of the resource. Maximum 1024 characters.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(updateAppBodyOneNameMax)
          .describe(
            'Human-readable name for the resource. Between 1 and 256 characters.',
          ),
        secretAPIKey: zod.coerce
          .string()
          .optional()
          .describe('The Stripe API key.'),
        type: zod.enum(['stripe']),
      })
      .describe('Resource update operation model.'),
    zod
      .object({
        description: zod.coerce
          .string()
          .max(updateAppBodyTwoDescriptionMax)
          .optional()
          .describe(
            'Optional description of the resource. Maximum 1024 characters.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(updateAppBodyTwoNameMax)
          .describe(
            'Human-readable name for the resource. Between 1 and 256 characters.',
          ),
        type: zod.enum(['sandbox']),
      })
      .describe('Resource update operation model.'),
    zod
      .object({
        description: zod.coerce
          .string()
          .max(updateAppBodyThreeDescriptionMax)
          .optional()
          .describe(
            'Optional description of the resource. Maximum 1024 characters.',
          ),
        enableDraftSyncHook: zod.coerce
          .boolean()
          .describe(
            'Enable draft.sync hook.\n\nIf the hook is not enabled, the invoice will be progressed to the next state automatically.',
          ),
        enableIssuingSyncHook: zod.coerce
          .boolean()
          .describe(
            'Enable issuing.sync hook.\n\nIf the hook is not enabled, the invoice will be progressed to the next state automatically.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(updateAppBodyThreeNameMax)
          .describe(
            'Human-readable name for the resource. Between 1 and 256 characters.',
          ),
        type: zod.enum(['custom_invoicing']),
      })
      .describe('Resource update operation model.'),
  ])
  .describe('App ReplaceUpdate Model')

/**
 * Uninstall an app.
 * @summary Uninstall app
 */
export const uninstallAppPathIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UninstallAppParams = zod.object({
  id: zod.coerce.string().regex(uninstallAppPathIdRegExp),
})

/**
 * Update the Stripe API key.

‚ö†Ô∏è __Deprecated__: Use [`PUT /api/v1/apps/{id}`](#tag/apps/put/api/v1/apps/{id}) instead.
 * @deprecated
 * @summary Update Stripe API key
 */
export const updateStripeAPIKeyPathIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdateStripeAPIKeyParams = zod.object({
  id: zod.coerce.string().regex(updateStripeAPIKeyPathIdRegExp),
})

export const UpdateStripeAPIKeyBody = zod
  .object({
    secretAPIKey: zod.coerce.string(),
  })
  .describe(
    'The Stripe API key input.\nUsed to authenticate with the Stripe API.',
  )

/**
 * Handle stripe webhooks for apps.
 * @summary Stripe webhook
 */
export const appStripeWebhookPathIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const AppStripeWebhookParams = zod.object({
  id: zod.coerce.string().regex(appStripeWebhookPathIdRegExp),
})

export const AppStripeWebhookBody = zod
  .object({
    created: zod.coerce.number().describe('The event created timestamp.'),
    data: zod
      .object({
        object: zod.unknown(),
      })
      .describe('The event data.'),
    id: zod.coerce.string().describe('The event ID.'),
    livemode: zod.coerce.boolean().describe('Live mode.'),
    type: zod.coerce.string().describe('The event type.'),
  })
  .describe('Stripe webhook event.')

/**
 * List customer overrides using the specified filters.

The response will include the customer override values and the merged billing profile values.

If the includeAllCustomers is set to true, the list contains all customers. This mode is
useful for getting the current effective billing workflow settings for all users regardless
if they have customer orverrides or not.
 * @summary List customer overrides
 */
export const listBillingProfileCustomerOverridesQueryBillingProfileItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listBillingProfileCustomerOverridesQueryIncludeAllCustomersDefault =
  true as const
export const listBillingProfileCustomerOverridesQueryCustomerIdItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listBillingProfileCustomerOverridesQueryPageDefault = 1 as const

export const listBillingProfileCustomerOverridesQueryPageSizeDefault =
  100 as const
export const listBillingProfileCustomerOverridesQueryPageSizeMax = 1000 as const

export const ListBillingProfileCustomerOverridesQueryParams = zod.object({
  billingProfile: zod
    .array(
      zod.coerce
        .string()
        .regex(listBillingProfileCustomerOverridesQueryBillingProfileItemRegExp)
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier).',
        ),
    )
    .optional()
    .describe('Filter by billing profile.'),
  customerId: zod
    .array(
      zod.coerce
        .string()
        .regex(listBillingProfileCustomerOverridesQueryCustomerIdItemRegExp)
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier).',
        ),
    )
    .optional()
    .describe('Filter by customer id.'),
  customerKey: zod.coerce
    .string()
    .optional()
    .describe('Filter by customer key'),
  customerName: zod.coerce
    .string()
    .optional()
    .describe('Filter by customer name.'),
  customerPrimaryEmail: zod.coerce
    .string()
    .optional()
    .describe('Filter by customer primary email'),
  customersWithoutPinnedProfile: zod.coerce
    .boolean()
    .optional()
    .describe(
      'Only return customers without pinned billing profiles. This implicitly sets includeAllCustomers to true.',
    ),
  expand: zod
    .array(
      zod
        .enum(['apps', 'customer'])
        .describe(
          'CustomerOverrideExpand specifies the parts of the profile to expand.',
        ),
    )
    .optional()
    .describe('Expand the response with additional details.'),
  includeAllCustomers: zod.coerce
    .boolean()
    .default(listBillingProfileCustomerOverridesQueryIncludeAllCustomersDefault)
    .describe(
      'Include customers without customer overrides.\n\nIf set to false only the customers specifically associated with a billing profile will be returned.\n\nIf set to true, in case of the default billing profile, all customers will be returned.',
    ),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum([
      'customerId',
      'customerName',
      'customerKey',
      'customerPrimaryEmail',
      'customerCreatedAt',
    ])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listBillingProfileCustomerOverridesQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listBillingProfileCustomerOverridesQueryPageSizeMax)
    .default(listBillingProfileCustomerOverridesQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * The customer override can be used to pin a given customer to a billing profile
different from the default one.

This can be used to test the effect of different billing profiles before making them
the default ones or have different workflow settings for example for enterprise customers.
 * @summary Create a new or update a customer override
 */
export const upsertBillingProfileCustomerOverridePathCustomerIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpsertBillingProfileCustomerOverrideParams = zod.object({
  customerId: zod.coerce
    .string()
    .regex(upsertBillingProfileCustomerOverridePathCustomerIdRegExp),
})

export const upsertBillingProfileCustomerOverrideBodyBillingProfileIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpsertBillingProfileCustomerOverrideBody = zod
  .object({
    billingProfileId: zod.coerce
      .string()
      .regex(upsertBillingProfileCustomerOverrideBodyBillingProfileIdRegExp)
      .optional()
      .describe(
        'The billing profile this override is associated with.\n\nIf not provided, the default billing profile is chosen if available.',
      ),
  })
  .describe(
    'Payload for creating a new or updating an existing customer override.',
  )

/**
 * Get a customer override by customer id.

The response will include the customer override values and the merged billing profile values.

If the customer override is not found, the default billing profile's values are returned. This behavior
allows for getting a merged profile regardless of the customer override existence.
 * @summary Get a customer override
 */
export const getBillingProfileCustomerOverridePathCustomerIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetBillingProfileCustomerOverrideParams = zod.object({
  customerId: zod.coerce
    .string()
    .regex(getBillingProfileCustomerOverridePathCustomerIdRegExp),
})

export const GetBillingProfileCustomerOverrideQueryParams = zod.object({
  expand: zod
    .array(
      zod
        .enum(['apps', 'customer'])
        .describe(
          'CustomerOverrideExpand specifies the parts of the profile to expand.',
        ),
    )
    .optional(),
})

/**
 * Delete a customer override by customer id.

This will remove the customer override and the customer will be subject to the default
billing profile's settings again.
 * @summary Delete a customer override
 */
export const deleteBillingProfileCustomerOverridePathCustomerIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeleteBillingProfileCustomerOverrideParams = zod.object({
  customerId: zod.coerce
    .string()
    .regex(deleteBillingProfileCustomerOverridePathCustomerIdRegExp),
})

/**
 * Create a new pending line item (charge).

This call is used to create a new pending line item for the customer if required a new
gathering invoice will be created.

A new invoice will be created if:
- there is no invoice in gathering state
- the currency of the line item doesn't match the currency of any invoices in gathering state
 * @summary Create pending line items
 */
export const createPendingInvoiceLinePathCustomerIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const CreatePendingInvoiceLineParams = zod.object({
  customerId: zod.coerce
    .string()
    .regex(createPendingInvoiceLinePathCustomerIdRegExp),
})

export const createPendingInvoiceLineBodyCurrencyOneMin = 3 as const
export const createPendingInvoiceLineBodyCurrencyOneMax = 3 as const

export const createPendingInvoiceLineBodyCurrencyOneRegExp = /^[A-Z]{3}$/
export const createPendingInvoiceLineBodyLinesItemNameMax = 256 as const

export const createPendingInvoiceLineBodyLinesItemDescriptionMax = 1024 as const

export const createPendingInvoiceLineBodyLinesItemTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const createPendingInvoiceLineBodyLinesItemPriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneOnePaymentTermDefault =
  'in_advance' as const
export const createPendingInvoiceLineBodyLinesItemPriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const createPendingInvoiceLineBodyLinesItemPriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneFourMultiplierDefault =
  '1' as const
export const createPendingInvoiceLineBodyLinesItemPriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemPriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemFeatureKeyMax = 64 as const

export const createPendingInvoiceLineBodyLinesItemFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createPendingInvoiceLineBodyLinesItemRateCardOneFeatureKeyMax =
  64 as const

export const createPendingInvoiceLineBodyLinesItemRateCardOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createPendingInvoiceLineBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault =
  'in_advance' as const
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMultiplierDefault =
  '1' as const
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const CreatePendingInvoiceLineBody = zod
  .object({
    currency: zod.coerce
      .string()
      .min(createPendingInvoiceLineBodyCurrencyOneMin)
      .max(createPendingInvoiceLineBodyCurrencyOneMax)
      .regex(createPendingInvoiceLineBodyCurrencyOneRegExp)
      .describe(
        'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
      )
      .describe('The currency of the lines to be created.'),
    lines: zod
      .array(
        zod
          .object({
            description: zod.coerce
              .string()
              .max(createPendingInvoiceLineBodyLinesItemDescriptionMax)
              .optional()
              .describe(
                'Optional description of the resource. Maximum 1024 characters.',
              ),
            featureKey: zod.coerce
              .string()
              .min(1)
              .max(createPendingInvoiceLineBodyLinesItemFeatureKeyMax)
              .regex(createPendingInvoiceLineBodyLinesItemFeatureKeyRegExp)
              .optional()
              .describe('The feature that the usage is based on.'),
            invoiceAt: zod.coerce
              .date()
              .describe('The time this line item should be invoiced.'),
            metadata: zod
              .record(zod.string(), zod.coerce.string())
              .describe(
                'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
              )
              .nullish()
              .describe('Additional metadata for the resource.'),
            name: zod.coerce
              .string()
              .min(1)
              .max(createPendingInvoiceLineBodyLinesItemNameMax)
              .describe(
                'Human-readable name for the resource. Between 1 and 256 characters.',
              ),
            period: zod
              .object({
                from: zod.coerce.date().describe('Period start time.'),
                to: zod.coerce.date().describe('Period end time.'),
              })
              .describe('A period with a start and end time.')
              .describe(
                'Period of the line item applies to for revenue recognition pruposes.\n\nBilling always treats periods as start being inclusive and end being exclusive.',
              ),
            price: zod
              .union([
                zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneOneAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The amount of the flat price.'),
                    paymentTerm: zod
                      .enum(['in_advance', 'in_arrears'])
                      .describe(
                        'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                      )
                      .default(
                        createPendingInvoiceLineBodyLinesItemPriceOneOnePaymentTermDefault,
                      )
                      .describe(
                        'The payment term of the flat price.\nDefaults to in advance.',
                      ),
                    type: zod.enum(['flat']),
                  })
                  .describe('Flat price with payment term.'),
                zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneTwoAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The amount of the unit price.'),
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneTwoMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneTwoMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    type: zod.enum(['unit']),
                  })
                  .describe('Unit price with spend commitments.'),
                zod
                  .object({
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneThreeMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneThreeMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    mode: zod
                      .enum(['volume', 'graduated'])
                      .describe('The mode of the tiered price.')
                      .describe(
                        'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                      ),
                    tiers: zod
                      .array(
                        zod
                          .object({
                            flatPrice: zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the flat price.'),
                                type: zod
                                  .enum(['flat'])
                                  .describe('The type of the price.'),
                              })
                              .describe('Flat price.')
                              .nullable()
                              .describe(
                                'The flat price component of the tier.',
                              ),
                            unitPrice: zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the unit price.'),
                                type: zod
                                  .enum(['unit'])
                                  .describe('The type of the price.'),
                              })
                              .describe('Unit price.')
                              .nullable()
                              .describe(
                                'The unit price component of the tier.',
                              ),
                            upToAmount: zod.coerce
                              .string()
                              .regex(
                                createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp,
                              )
                              .describe(
                                'Numeric represents an arbitrary precision number.',
                              )
                              .optional()
                              .describe(
                                'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                              ),
                          })
                          .describe(
                            'A price tier.\nAt least one price component is required in each tier.',
                          ),
                      )
                      .min(1)
                      .describe(
                        'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                      ),
                    type: zod.enum(['tiered']),
                  })
                  .describe('Tiered price with spend commitments.'),
                zod
                  .object({
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneFourMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneFourMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    multiplier: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneFourMultiplierOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .default(
                        createPendingInvoiceLineBodyLinesItemPriceOneFourMultiplierDefault,
                      )
                      .describe(
                        'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                      ),
                    type: zod.enum(['dynamic']),
                  })
                  .describe('Dynamic price with spend commitments.'),
                zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneFiveAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The price of one package.'),
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneFiveMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneFiveMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    quantityPerPackage: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The quantity per package.'),
                    type: zod.enum(['package']),
                  })
                  .describe('Package price with spend commitments.'),
              ])
              .describe('The price of the usage based rate card.')
              .optional()
              .describe('Price of the usage-based item being sold.'),
            rateCard: zod
              .object({
                discounts: zod
                  .object({
                    percentage: zod
                      .object({
                        correlationId: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp,
                          )
                          .optional()
                          .describe(
                            'Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.',
                          ),
                        percentage: zod.coerce
                          .number()
                          .describe(
                            'Numeric representation of a percentage\n\n50% is represented as 50',
                          )
                          .describe('The percentage of the discount.'),
                      })
                      .describe('A percentage discount.')
                      .optional()
                      .describe('The percentage discount.'),
                    usage: zod
                      .object({
                        correlationId: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp,
                          )
                          .optional()
                          .describe(
                            'Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.',
                          ),
                        quantity: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe(
                            'The quantity of the usage discount.\n\nMust be positive.',
                          ),
                      })
                      .describe('A usage discount.')
                      .optional()
                      .describe('The usage discount.'),
                  })
                  .describe('A discount by type.')
                  .optional()
                  .describe('The discounts that are applied to the line.'),
                featureKey: zod.coerce
                  .string()
                  .min(1)
                  .max(
                    createPendingInvoiceLineBodyLinesItemRateCardOneFeatureKeyMax,
                  )
                  .regex(
                    createPendingInvoiceLineBodyLinesItemRateCardOneFeatureKeyRegExp,
                  )
                  .optional()
                  .describe('The feature the customer is entitled to use.'),
                price: zod
                  .union([
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The amount of the flat price.'),
                        paymentTerm: zod
                          .enum(['in_advance', 'in_arrears'])
                          .describe(
                            'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                          )
                          .default(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault,
                          )
                          .describe(
                            'The payment term of the flat price.\nDefaults to in advance.',
                          ),
                        type: zod.enum(['flat']),
                      })
                      .describe('Flat price with payment term.'),
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The amount of the unit price.'),
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        type: zod.enum(['unit']),
                      })
                      .describe('Unit price with spend commitments.'),
                    zod
                      .object({
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        mode: zod
                          .enum(['volume', 'graduated'])
                          .describe('The mode of the tiered price.')
                          .describe(
                            'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                          ),
                        tiers: zod
                          .array(
                            zod
                              .object({
                                flatPrice: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the flat price.',
                                      ),
                                    type: zod
                                      .enum(['flat'])
                                      .describe('The type of the price.'),
                                  })
                                  .describe('Flat price.')
                                  .nullable()
                                  .describe(
                                    'The flat price component of the tier.',
                                  ),
                                unitPrice: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the unit price.',
                                      ),
                                    type: zod
                                      .enum(['unit'])
                                      .describe('The type of the price.'),
                                  })
                                  .describe('Unit price.')
                                  .nullable()
                                  .describe(
                                    'The unit price component of the tier.',
                                  ),
                                upToAmount: zod.coerce
                                  .string()
                                  .regex(
                                    createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                                  ),
                              })
                              .describe(
                                'A price tier.\nAt least one price component is required in each tier.',
                              ),
                          )
                          .min(1)
                          .describe(
                            'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                          ),
                        type: zod.enum(['tiered']),
                      })
                      .describe('Tiered price with spend commitments.'),
                    zod
                      .object({
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        multiplier: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .default(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMultiplierDefault,
                          )
                          .describe(
                            'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                          ),
                        type: zod.enum(['dynamic']),
                      })
                      .describe('Dynamic price with spend commitments.'),
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The price of one package.'),
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        quantityPerPackage: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The quantity per package.'),
                        type: zod.enum(['package']),
                      })
                      .describe('Package price with spend commitments.'),
                  ])
                  .describe('The price of the usage based rate card.')
                  .nullable()
                  .describe(
                    'The price of the rate card.\nWhen null, the feature or service is free.',
                  ),
                taxConfig: zod
                  .object({
                    behavior: zod
                      .enum(['inclusive', 'exclusive'])
                      .describe(
                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                      )
                      .optional()
                      .describe(
                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                      ),
                    customInvoicing: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .describe(
                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                          ),
                      })
                      .describe('Custom invoicing tax config.')
                      .optional()
                      .describe('Custom invoicing tax config.'),
                    stripe: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .regex(
                            createPendingInvoiceLineBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp,
                          )
                          .describe(
                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                          ),
                      })
                      .describe('The tax config for Stripe.')
                      .optional()
                      .describe('Stripe tax config.'),
                  })
                  .describe('Set of provider specific tax configs.')
                  .optional()
                  .describe(
                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                  ),
              })
              .describe(
                'InvoiceUsageBasedRateCard represents the rate card (intent) for an usage-based line.',
              )
              .optional()
              .describe(
                'The rate card that is used for this line.\n\nThe rate card captures the intent of the price and discounts for the usage-based item.',
              ),
            taxConfig: zod
              .object({
                behavior: zod
                  .enum(['inclusive', 'exclusive'])
                  .describe(
                    'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                  )
                  .optional()
                  .describe(
                    "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                  ),
                customInvoicing: zod
                  .object({
                    code: zod.coerce
                      .string()
                      .describe(
                        'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                      ),
                  })
                  .describe('Custom invoicing tax config.')
                  .optional()
                  .describe('Custom invoicing tax config.'),
                stripe: zod
                  .object({
                    code: zod.coerce
                      .string()
                      .regex(
                        createPendingInvoiceLineBodyLinesItemTaxConfigOneStripeOneCodeRegExp,
                      )
                      .describe(
                        'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                      ),
                  })
                  .describe('The tax config for Stripe.')
                  .optional()
                  .describe('Stripe tax config.'),
              })
              .describe('Set of provider specific tax configs.')
              .optional()
              .describe(
                'Tax config specify the tax configuration for this line.',
              ),
          })
          .describe(
            'InvoicePendingLineCreate represents the create model for an invoice line that is sold to the customer based on usage.',
          ),
      )
      .min(1)
      .describe('The lines to be created.'),
  })
  .describe(
    'InvoicePendingLineCreate represents the create model for a pending invoice line.',
  )

/**
 * Simulate an invoice for a customer.

This call will simulate an invoice for a customer based on the pending line items.

The call will return the total amount of the invoice and the line items that will be included in the invoice.
 * @summary Simulate an invoice for a customer
 */
export const simulateInvoicePathCustomerIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const SimulateInvoiceParams = zod.object({
  customerId: zod.coerce.string().regex(simulateInvoicePathCustomerIdRegExp),
})

export const simulateInvoiceBodyNumberOneMax = 256 as const

export const simulateInvoiceBodyCurrencyOneMin = 3 as const
export const simulateInvoiceBodyCurrencyOneMax = 3 as const

export const simulateInvoiceBodyCurrencyOneRegExp = /^[A-Z]{3}$/
export const simulateInvoiceBodyLinesItemNameMax = 256 as const

export const simulateInvoiceBodyLinesItemDescriptionMax = 1024 as const

export const simulateInvoiceBodyLinesItemTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const simulateInvoiceBodyLinesItemPriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneOnePaymentTermDefault =
  'in_advance' as const
export const simulateInvoiceBodyLinesItemPriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const simulateInvoiceBodyLinesItemPriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneFourMultiplierDefault =
  '1' as const
export const simulateInvoiceBodyLinesItemPriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemFeatureKeyMax = 64 as const

export const simulateInvoiceBodyLinesItemFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const simulateInvoiceBodyLinesItemRateCardOneFeatureKeyMax = 64 as const

export const simulateInvoiceBodyLinesItemRateCardOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const simulateInvoiceBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault =
  'in_advance' as const
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierDefault =
  '1' as const
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const simulateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const simulateInvoiceBodyLinesItemQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemPreLinePeriodQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const simulateInvoiceBodyLinesItemIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const SimulateInvoiceBody = zod
  .object({
    currency: zod.coerce
      .string()
      .min(simulateInvoiceBodyCurrencyOneMin)
      .max(simulateInvoiceBodyCurrencyOneMax)
      .regex(simulateInvoiceBodyCurrencyOneRegExp)
      .describe(
        'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
      )
      .describe(
        'Currency for all invoice line items.\n\nMulti currency invoices are not supported yet.',
      ),
    lines: zod
      .array(
        zod
          .object({
            description: zod.coerce
              .string()
              .max(simulateInvoiceBodyLinesItemDescriptionMax)
              .optional()
              .describe(
                'Optional description of the resource. Maximum 1024 characters.',
              ),
            featureKey: zod.coerce
              .string()
              .min(1)
              .max(simulateInvoiceBodyLinesItemFeatureKeyMax)
              .regex(simulateInvoiceBodyLinesItemFeatureKeyRegExp)
              .optional()
              .describe('The feature that the usage is based on.'),
            id: zod.coerce
              .string()
              .regex(simulateInvoiceBodyLinesItemIdRegExp)
              .optional()
              .describe(
                'ID of the line. If not specified it will be auto-generated.\n\nWhen discounts are specified, this must be provided, so that the discount can reference it.',
              ),
            invoiceAt: zod.coerce
              .date()
              .describe('The time this line item should be invoiced.'),
            metadata: zod
              .record(zod.string(), zod.coerce.string())
              .describe(
                'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
              )
              .nullish()
              .describe('Additional metadata for the resource.'),
            name: zod.coerce
              .string()
              .min(1)
              .max(simulateInvoiceBodyLinesItemNameMax)
              .describe(
                'Human-readable name for the resource. Between 1 and 256 characters.',
              ),
            period: zod
              .object({
                from: zod.coerce.date().describe('Period start time.'),
                to: zod.coerce.date().describe('Period end time.'),
              })
              .describe('A period with a start and end time.')
              .describe(
                'Period of the line item applies to for revenue recognition pruposes.\n\nBilling always treats periods as start being inclusive and end being exclusive.',
              ),
            preLinePeriodQuantity: zod.coerce
              .string()
              .regex(simulateInvoiceBodyLinesItemPreLinePeriodQuantityOneRegExp)
              .describe('Numeric represents an arbitrary precision number.')
              .optional()
              .describe(
                "The quantity of the item used before this line's period, if the line is billed progressively.",
              ),
            price: zod
              .union([
                zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneOneAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The amount of the flat price.'),
                    paymentTerm: zod
                      .enum(['in_advance', 'in_arrears'])
                      .describe(
                        'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                      )
                      .default(
                        simulateInvoiceBodyLinesItemPriceOneOnePaymentTermDefault,
                      )
                      .describe(
                        'The payment term of the flat price.\nDefaults to in advance.',
                      ),
                    type: zod.enum(['flat']),
                  })
                  .describe('Flat price with payment term.'),
                zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneTwoAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The amount of the unit price.'),
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneTwoMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneTwoMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    type: zod.enum(['unit']),
                  })
                  .describe('Unit price with spend commitments.'),
                zod
                  .object({
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneThreeMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneThreeMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    mode: zod
                      .enum(['volume', 'graduated'])
                      .describe('The mode of the tiered price.')
                      .describe(
                        'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                      ),
                    tiers: zod
                      .array(
                        zod
                          .object({
                            flatPrice: zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    simulateInvoiceBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the flat price.'),
                                type: zod
                                  .enum(['flat'])
                                  .describe('The type of the price.'),
                              })
                              .describe('Flat price.')
                              .nullable()
                              .describe(
                                'The flat price component of the tier.',
                              ),
                            unitPrice: zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    simulateInvoiceBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the unit price.'),
                                type: zod
                                  .enum(['unit'])
                                  .describe('The type of the price.'),
                              })
                              .describe('Unit price.')
                              .nullable()
                              .describe(
                                'The unit price component of the tier.',
                              ),
                            upToAmount: zod.coerce
                              .string()
                              .regex(
                                simulateInvoiceBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp,
                              )
                              .describe(
                                'Numeric represents an arbitrary precision number.',
                              )
                              .optional()
                              .describe(
                                'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                              ),
                          })
                          .describe(
                            'A price tier.\nAt least one price component is required in each tier.',
                          ),
                      )
                      .min(1)
                      .describe(
                        'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                      ),
                    type: zod.enum(['tiered']),
                  })
                  .describe('Tiered price with spend commitments.'),
                zod
                  .object({
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneFourMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneFourMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    multiplier: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneFourMultiplierOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .default(
                        simulateInvoiceBodyLinesItemPriceOneFourMultiplierDefault,
                      )
                      .describe(
                        'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                      ),
                    type: zod.enum(['dynamic']),
                  })
                  .describe('Dynamic price with spend commitments.'),
                zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneFiveAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The price of one package.'),
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneFiveMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneFiveMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    quantityPerPackage: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The quantity per package.'),
                    type: zod.enum(['package']),
                  })
                  .describe('Package price with spend commitments.'),
              ])
              .describe('The price of the usage based rate card.')
              .optional()
              .describe('Price of the usage-based item being sold.'),
            quantity: zod.coerce
              .string()
              .regex(simulateInvoiceBodyLinesItemQuantityOneRegExp)
              .describe('Numeric represents an arbitrary precision number.')
              .describe('The quantity of the item being sold.'),
            rateCard: zod
              .object({
                discounts: zod
                  .object({
                    percentage: zod
                      .object({
                        correlationId: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp,
                          )
                          .optional()
                          .describe(
                            'Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.',
                          ),
                        percentage: zod.coerce
                          .number()
                          .describe(
                            'Numeric representation of a percentage\n\n50% is represented as 50',
                          )
                          .describe('The percentage of the discount.'),
                      })
                      .describe('A percentage discount.')
                      .optional()
                      .describe('The percentage discount.'),
                    usage: zod
                      .object({
                        correlationId: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp,
                          )
                          .optional()
                          .describe(
                            'Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.',
                          ),
                        quantity: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe(
                            'The quantity of the usage discount.\n\nMust be positive.',
                          ),
                      })
                      .describe('A usage discount.')
                      .optional()
                      .describe('The usage discount.'),
                  })
                  .describe('A discount by type.')
                  .optional()
                  .describe('The discounts that are applied to the line.'),
                featureKey: zod.coerce
                  .string()
                  .min(1)
                  .max(simulateInvoiceBodyLinesItemRateCardOneFeatureKeyMax)
                  .regex(
                    simulateInvoiceBodyLinesItemRateCardOneFeatureKeyRegExp,
                  )
                  .optional()
                  .describe('The feature the customer is entitled to use.'),
                price: zod
                  .union([
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The amount of the flat price.'),
                        paymentTerm: zod
                          .enum(['in_advance', 'in_arrears'])
                          .describe(
                            'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                          )
                          .default(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault,
                          )
                          .describe(
                            'The payment term of the flat price.\nDefaults to in advance.',
                          ),
                        type: zod.enum(['flat']),
                      })
                      .describe('Flat price with payment term.'),
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The amount of the unit price.'),
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        type: zod.enum(['unit']),
                      })
                      .describe('Unit price with spend commitments.'),
                    zod
                      .object({
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        mode: zod
                          .enum(['volume', 'graduated'])
                          .describe('The mode of the tiered price.')
                          .describe(
                            'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                          ),
                        tiers: zod
                          .array(
                            zod
                              .object({
                                flatPrice: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the flat price.',
                                      ),
                                    type: zod
                                      .enum(['flat'])
                                      .describe('The type of the price.'),
                                  })
                                  .describe('Flat price.')
                                  .nullable()
                                  .describe(
                                    'The flat price component of the tier.',
                                  ),
                                unitPrice: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the unit price.',
                                      ),
                                    type: zod
                                      .enum(['unit'])
                                      .describe('The type of the price.'),
                                  })
                                  .describe('Unit price.')
                                  .nullable()
                                  .describe(
                                    'The unit price component of the tier.',
                                  ),
                                upToAmount: zod.coerce
                                  .string()
                                  .regex(
                                    simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                                  ),
                              })
                              .describe(
                                'A price tier.\nAt least one price component is required in each tier.',
                              ),
                          )
                          .min(1)
                          .describe(
                            'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                          ),
                        type: zod.enum(['tiered']),
                      })
                      .describe('Tiered price with spend commitments.'),
                    zod
                      .object({
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        multiplier: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .default(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierDefault,
                          )
                          .describe(
                            'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                          ),
                        type: zod.enum(['dynamic']),
                      })
                      .describe('Dynamic price with spend commitments.'),
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The price of one package.'),
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        quantityPerPackage: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The quantity per package.'),
                        type: zod.enum(['package']),
                      })
                      .describe('Package price with spend commitments.'),
                  ])
                  .describe('The price of the usage based rate card.')
                  .nullable()
                  .describe(
                    'The price of the rate card.\nWhen null, the feature or service is free.',
                  ),
                taxConfig: zod
                  .object({
                    behavior: zod
                      .enum(['inclusive', 'exclusive'])
                      .describe(
                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                      )
                      .optional()
                      .describe(
                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                      ),
                    customInvoicing: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .describe(
                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                          ),
                      })
                      .describe('Custom invoicing tax config.')
                      .optional()
                      .describe('Custom invoicing tax config.'),
                    stripe: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .regex(
                            simulateInvoiceBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp,
                          )
                          .describe(
                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                          ),
                      })
                      .describe('The tax config for Stripe.')
                      .optional()
                      .describe('Stripe tax config.'),
                  })
                  .describe('Set of provider specific tax configs.')
                  .optional()
                  .describe(
                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                  ),
              })
              .describe(
                'InvoiceUsageBasedRateCard represents the rate card (intent) for an usage-based line.',
              )
              .optional()
              .describe(
                'The rate card that is used for this line.\n\nThe rate card captures the intent of the price and discounts for the usage-based item.',
              ),
            taxConfig: zod
              .object({
                behavior: zod
                  .enum(['inclusive', 'exclusive'])
                  .describe(
                    'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                  )
                  .optional()
                  .describe(
                    "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                  ),
                customInvoicing: zod
                  .object({
                    code: zod.coerce
                      .string()
                      .describe(
                        'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                      ),
                  })
                  .describe('Custom invoicing tax config.')
                  .optional()
                  .describe('Custom invoicing tax config.'),
                stripe: zod
                  .object({
                    code: zod.coerce
                      .string()
                      .regex(
                        simulateInvoiceBodyLinesItemTaxConfigOneStripeOneCodeRegExp,
                      )
                      .describe(
                        'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                      ),
                  })
                  .describe('The tax config for Stripe.')
                  .optional()
                  .describe('Stripe tax config.'),
              })
              .describe('Set of provider specific tax configs.')
              .optional()
              .describe(
                'Tax config specify the tax configuration for this line.',
              ),
          })
          .describe(
            'InvoiceSimulationLine represents a usage-based line item that can be input to the simulation endpoint.',
          ),
      )
      .describe('Lines to be included in the generated invoice.'),
    number: zod.coerce
      .string()
      .min(1)
      .max(simulateInvoiceBodyNumberOneMax)
      .describe(
        'InvoiceNumber is a unique identifier for the invoice, generated by the\ninvoicing app.\n\nThe uniqueness depends on a lot of factors:\n- app setting (unique per app or unique per customer)\n- multiple app scenarios (multiple apps generating invoices with the same prefix)',
      )
      .optional()
      .describe('The number of the invoice.'),
  })
  .describe('InvoiceSimulationInput is the input for simulating an invoice.')

/**
 * List invoices based on the specified filters.

The expand option can be used to include additional information (besides the invoice header and totals)
in the response. For example by adding the expand=lines option the invoice lines will be included in the response.

Gathering invoices will always show the current usage calculated on the fly.
 * @summary List invoices
 */
export const listInvoicesQueryCustomersItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listInvoicesQueryPageDefault = 1 as const

export const listInvoicesQueryPageSizeDefault = 100 as const
export const listInvoicesQueryPageSizeMax = 1000 as const

export const ListInvoicesQueryParams = zod.object({
  createdAfter: zod.coerce
    .date()
    .optional()
    .describe('Filter by invoice created time.\nInclusive.'),
  createdBefore: zod.coerce
    .date()
    .optional()
    .describe('Filter by invoice created time.\nInclusive.'),
  customers: zod
    .array(
      zod.coerce
        .string()
        .regex(listInvoicesQueryCustomersItemRegExp)
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier).',
        ),
    )
    .optional()
    .describe('Filter by customer ID'),
  expand: zod
    .array(
      zod
        .enum(['lines', 'preceding', 'workflow.apps'])
        .describe(
          'InvoiceExpand specifies the parts of the invoice to expand in the list output.',
        ),
    )
    .optional()
    .describe('What parts of the list output to expand in listings'),
  extendedStatuses: zod
    .array(zod.coerce.string())
    .optional()
    .describe('Filter by invoice extended statuses'),
  includeDeleted: zod.coerce
    .boolean()
    .optional()
    .describe('Include deleted invoices'),
  issuedAfter: zod.coerce
    .date()
    .optional()
    .describe('Filter by invoice issued time.\nInclusive.'),
  issuedBefore: zod.coerce
    .date()
    .optional()
    .describe('Filter by invoice issued time.\nInclusive.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum([
      'customer.name',
      'issuedAt',
      'status',
      'createdAt',
      'updatedAt',
      'periodStart',
    ])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listInvoicesQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listInvoicesQueryPageSizeMax)
    .default(listInvoicesQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
  periodStartAfter: zod.coerce
    .date()
    .optional()
    .describe('Filter by period start time.\nInclusive.'),
  periodStartBefore: zod.coerce
    .date()
    .optional()
    .describe('Filter by period start time.\nInclusive.'),
  statuses: zod
    .array(
      zod
        .enum([
          'gathering',
          'draft',
          'issuing',
          'issued',
          'payment_processing',
          'overdue',
          'paid',
          'uncollectible',
          'voided',
        ])
        .describe('InvoiceStatus describes the status of an invoice.'),
    )
    .optional()
    .describe('Filter by the invoice status.'),
})

/**
 * Create a new invoice from the pending line items.

This should be only called if for some reason we need to invoice a customer outside of the normal billing cycle.

When creating an invoice, the pending line items will be marked as invoiced and the invoice will be created with the total amount of the pending items.

New pending line items will be created for the period between now() and the next billing cycle's begining date for any metered item.

The call can return multiple invoices if the pending line items are in different currencies.
 * @summary Invoice a customer based on the pending line items
 */
export const invoicePendingLinesActionBodyFiltersOneLineIdsItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const invoicePendingLinesActionBodyCustomerIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const InvoicePendingLinesActionBody = zod
  .object({
    asOf: zod.coerce
      .date()
      .optional()
      .describe(
        'The time as of which the invoice is created.\n\nIf not provided, the current time is used.',
      ),
    customerId: zod.coerce
      .string()
      .regex(invoicePendingLinesActionBodyCustomerIdRegExp)
      .describe('The customer ID for which to create the invoice.'),
    filters: zod
      .object({
        lineIds: zod
          .array(
            zod.coerce
              .string()
              .regex(invoicePendingLinesActionBodyFiltersOneLineIdsItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).',
              ),
          )
          .optional()
          .describe(
            'The pending line items to include in the invoice, if not provided:\n- all line items that have invoice_at < asOf will be included\n- [progressive billing only] all usage based line items will be included up to asOf, new\nusage-based line items will be staged for the rest of the billing cycle\n\nAll lineIDs present in the list, must exists and must be invoicable as of asOf, or the action will fail.',
          ),
      })
      .describe(
        'InvoicePendingLinesActionFiltersInput specifies which lines to include in the invoice.',
      )
      .optional()
      .describe('Filters to apply when creating the invoice.'),
    progressiveBillingOverride: zod.coerce
      .boolean()
      .optional()
      .describe(
        "Override the progressive billing setting of the customer.\n\nCan be used to disable/enable progressive billing in case the business logic\nrequires it, if not provided the billing profile's progressive billing setting will be used.",
      ),
  })
  .describe(
    'BillingInvoiceActionInput is the input for creating an invoice.\n\nInvoice creation is always based on already pending line items created by the billingCreateLineByCustomer\noperation. Empty invoices are not allowed.',
  )

/**
 * Get an invoice by ID.

Gathering invoices will always show the current usage calculated on the fly.
 * @summary Get an invoice
 */
export const getInvoicePathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetInvoiceParams = zod.object({
  invoiceId: zod.coerce.string().regex(getInvoicePathInvoiceIdRegExp),
})

export const getInvoiceQueryIncludeDeletedLinesDefault = false as const

export const GetInvoiceQueryParams = zod.object({
  expand: zod
    .array(
      zod
        .enum(['lines', 'preceding', 'workflow.apps'])
        .describe(
          'InvoiceExpand specifies the parts of the invoice to expand in the list output.',
        ),
    )
    .default(['lines']),
  includeDeletedLines: zod.coerce
    .boolean()
    .default(getInvoiceQueryIncludeDeletedLinesDefault),
})

/**
 * Delete an invoice

Only invoices that are in the draft (or earlier) status can be deleted.

Invoices that are post finalization can only be voided.
 * @summary Delete an invoice
 */
export const deleteInvoicePathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeleteInvoiceParams = zod.object({
  invoiceId: zod.coerce.string().regex(deleteInvoicePathInvoiceIdRegExp),
})

/**
 * Update an invoice

Only invoices in draft or earlier status can be updated.
 * @summary Update an invoice
 */
export const updateInvoicePathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdateInvoiceParams = zod.object({
  invoiceId: zod.coerce.string().regex(updateInvoicePathInvoiceIdRegExp),
})

export const updateInvoiceBodyDescriptionMax = 1024 as const

export const updateInvoiceBodySupplierOneKeyMax = 256 as const

export const updateInvoiceBodySupplierOneTaxIdOneCodeOneMax = 32 as const

export const updateInvoiceBodySupplierOneAddressesItemCountryOneMin = 2 as const
export const updateInvoiceBodySupplierOneAddressesItemCountryOneMax = 2 as const

export const updateInvoiceBodySupplierOneAddressesItemCountryOneRegExp =
  /^[A-Z]{2}$/
export const updateInvoiceBodySupplierOneAddressesMax = 1 as const

export const updateInvoiceBodyCustomerOneKeyMax = 256 as const

export const updateInvoiceBodyCustomerOneTaxIdOneCodeOneMax = 32 as const

export const updateInvoiceBodyCustomerOneAddressesItemCountryOneMin = 2 as const
export const updateInvoiceBodyCustomerOneAddressesItemCountryOneMax = 2 as const

export const updateInvoiceBodyCustomerOneAddressesItemCountryOneRegExp =
  /^[A-Z]{2}$/
export const updateInvoiceBodyCustomerOneAddressesMax = 1 as const

export const updateInvoiceBodyLinesItemNameMax = 256 as const

export const updateInvoiceBodyLinesItemDescriptionMax = 1024 as const

export const updateInvoiceBodyLinesItemTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const updateInvoiceBodyLinesItemPriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneOnePaymentTermDefault =
  'in_advance' as const
export const updateInvoiceBodyLinesItemPriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const updateInvoiceBodyLinesItemPriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneFourMultiplierDefault =
  '1' as const
export const updateInvoiceBodyLinesItemPriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemPriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemFeatureKeyMax = 64 as const

export const updateInvoiceBodyLinesItemFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updateInvoiceBodyLinesItemRateCardOneFeatureKeyMax = 64 as const

export const updateInvoiceBodyLinesItemRateCardOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updateInvoiceBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault =
  'in_advance' as const
export const updateInvoiceBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const updateInvoiceBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierDefault =
  '1' as const
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const updateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const updateInvoiceBodyLinesItemIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneAutoAdvanceDefault =
  true as const
export const updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDraftPeriodDefault =
  'P0D' as const
export const updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDueAfterDefault =
  'P30D' as const
export const updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const updateInvoiceBodyWorkflowOneWorkflowOnePaymentOneCollectionMethodDefault =
  'charge_automatically' as const

export const UpdateInvoiceBody = zod
  .object({
    customer: zod
      .object({
        addresses: zod
          .array(
            zod
              .object({
                city: zod.coerce.string().optional().describe('City.'),
                country: zod.coerce
                  .string()
                  .min(updateInvoiceBodyCustomerOneAddressesItemCountryOneMin)
                  .max(updateInvoiceBodyCustomerOneAddressesItemCountryOneMax)
                  .regex(
                    updateInvoiceBodyCustomerOneAddressesItemCountryOneRegExp,
                  )
                  .describe(
                    '[ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.',
                  )
                  .optional()
                  .describe(
                    'Country code in [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 format.',
                  ),
                line1: zod.coerce
                  .string()
                  .optional()
                  .describe('First line of the address.'),
                line2: zod.coerce
                  .string()
                  .optional()
                  .describe('Second line of the address.'),
                phoneNumber: zod.coerce
                  .string()
                  .optional()
                  .describe('Phone number.'),
                postalCode: zod.coerce
                  .string()
                  .optional()
                  .describe('Postal code.'),
                state: zod.coerce
                  .string()
                  .optional()
                  .describe('State or province.'),
              })
              .describe('Address'),
          )
          .max(updateInvoiceBodyCustomerOneAddressesMax)
          .optional()
          .describe(
            'Regular post addresses for where information should be sent if needed.',
          ),
        key: zod.coerce
          .string()
          .min(1)
          .max(updateInvoiceBodyCustomerOneKeyMax)
          .optional()
          .describe('An optional unique key of the party (if available)'),
        name: zod.coerce
          .string()
          .optional()
          .describe('Legal name or representation of the organization.'),
        taxId: zod
          .object({
            code: zod.coerce
              .string()
              .min(1)
              .max(updateInvoiceBodyCustomerOneTaxIdOneCodeOneMax)
              .describe(
                'TaxIdentificationCode is a normalized tax code shown on the original identity document.',
              )
              .optional()
              .describe(
                'Normalized tax code shown on the original identity document.',
              ),
          })
          .describe(
            'Identity stores the details required to identify an entity for tax purposes in a specific country.',
          )
          .optional()
          .describe(
            "The entity's legal ID code used for tax purposes. They may have\nother numbers, but we're only interested in those valid for tax purposes.",
          ),
      })
      .describe('Resource update operation model.')
      .describe('The customer the invoice is sent to.'),
    description: zod.coerce
      .string()
      .max(updateInvoiceBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    lines: zod
      .array(
        zod
          .object({
            description: zod.coerce
              .string()
              .max(updateInvoiceBodyLinesItemDescriptionMax)
              .optional()
              .describe(
                'Optional description of the resource. Maximum 1024 characters.',
              ),
            featureKey: zod.coerce
              .string()
              .min(1)
              .max(updateInvoiceBodyLinesItemFeatureKeyMax)
              .regex(updateInvoiceBodyLinesItemFeatureKeyRegExp)
              .optional()
              .describe('The feature that the usage is based on.'),
            id: zod.coerce
              .string()
              .regex(updateInvoiceBodyLinesItemIdRegExp)
              .optional()
              .describe('The ID of the line.'),
            invoiceAt: zod.coerce
              .date()
              .describe('The time this line item should be invoiced.'),
            metadata: zod
              .record(zod.string(), zod.coerce.string())
              .describe(
                'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
              )
              .nullish()
              .describe('Additional metadata for the resource.'),
            name: zod.coerce
              .string()
              .min(1)
              .max(updateInvoiceBodyLinesItemNameMax)
              .describe(
                'Human-readable name for the resource. Between 1 and 256 characters.',
              ),
            period: zod
              .object({
                from: zod.coerce.date().describe('Period start time.'),
                to: zod.coerce.date().describe('Period end time.'),
              })
              .describe('A period with a start and end time.')
              .describe(
                'Period of the line item applies to for revenue recognition pruposes.\n\nBilling always treats periods as start being inclusive and end being exclusive.',
              ),
            price: zod
              .union([
                zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneOneAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The amount of the flat price.'),
                    paymentTerm: zod
                      .enum(['in_advance', 'in_arrears'])
                      .describe(
                        'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                      )
                      .default(
                        updateInvoiceBodyLinesItemPriceOneOnePaymentTermDefault,
                      )
                      .describe(
                        'The payment term of the flat price.\nDefaults to in advance.',
                      ),
                    type: zod.enum(['flat']),
                  })
                  .describe('Flat price with payment term.'),
                zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneTwoAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The amount of the unit price.'),
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneTwoMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneTwoMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    type: zod.enum(['unit']),
                  })
                  .describe('Unit price with spend commitments.'),
                zod
                  .object({
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneThreeMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneThreeMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    mode: zod
                      .enum(['volume', 'graduated'])
                      .describe('The mode of the tiered price.')
                      .describe(
                        'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                      ),
                    tiers: zod
                      .array(
                        zod
                          .object({
                            flatPrice: zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    updateInvoiceBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the flat price.'),
                                type: zod
                                  .enum(['flat'])
                                  .describe('The type of the price.'),
                              })
                              .describe('Flat price.')
                              .nullable()
                              .describe(
                                'The flat price component of the tier.',
                              ),
                            unitPrice: zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    updateInvoiceBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the unit price.'),
                                type: zod
                                  .enum(['unit'])
                                  .describe('The type of the price.'),
                              })
                              .describe('Unit price.')
                              .nullable()
                              .describe(
                                'The unit price component of the tier.',
                              ),
                            upToAmount: zod.coerce
                              .string()
                              .regex(
                                updateInvoiceBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp,
                              )
                              .describe(
                                'Numeric represents an arbitrary precision number.',
                              )
                              .optional()
                              .describe(
                                'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                              ),
                          })
                          .describe(
                            'A price tier.\nAt least one price component is required in each tier.',
                          ),
                      )
                      .min(1)
                      .describe(
                        'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                      ),
                    type: zod.enum(['tiered']),
                  })
                  .describe('Tiered price with spend commitments.'),
                zod
                  .object({
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneFourMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneFourMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    multiplier: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneFourMultiplierOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .default(
                        updateInvoiceBodyLinesItemPriceOneFourMultiplierDefault,
                      )
                      .describe(
                        'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                      ),
                    type: zod.enum(['dynamic']),
                  })
                  .describe('Dynamic price with spend commitments.'),
                zod
                  .object({
                    amount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneFiveAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The price of one package.'),
                    maximumAmount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneFiveMaximumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is limited to spend at most the amount.',
                      ),
                    minimumAmount: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneFiveMinimumAmountOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .optional()
                      .describe(
                        'The customer is committed to spend at least the amount.',
                      ),
                    quantityPerPackage: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp,
                      )
                      .describe(
                        'Numeric represents an arbitrary precision number.',
                      )
                      .describe('The quantity per package.'),
                    type: zod.enum(['package']),
                  })
                  .describe('Package price with spend commitments.'),
              ])
              .describe('The price of the usage based rate card.')
              .optional()
              .describe('Price of the usage-based item being sold.'),
            rateCard: zod
              .object({
                discounts: zod
                  .object({
                    percentage: zod
                      .object({
                        correlationId: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp,
                          )
                          .optional()
                          .describe(
                            'Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.',
                          ),
                        percentage: zod.coerce
                          .number()
                          .describe(
                            'Numeric representation of a percentage\n\n50% is represented as 50',
                          )
                          .describe('The percentage of the discount.'),
                      })
                      .describe('A percentage discount.')
                      .optional()
                      .describe('The percentage discount.'),
                    usage: zod
                      .object({
                        correlationId: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp,
                          )
                          .optional()
                          .describe(
                            'Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.',
                          ),
                        quantity: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe(
                            'The quantity of the usage discount.\n\nMust be positive.',
                          ),
                      })
                      .describe('A usage discount.')
                      .optional()
                      .describe('The usage discount.'),
                  })
                  .describe('A discount by type.')
                  .optional()
                  .describe('The discounts that are applied to the line.'),
                featureKey: zod.coerce
                  .string()
                  .min(1)
                  .max(updateInvoiceBodyLinesItemRateCardOneFeatureKeyMax)
                  .regex(updateInvoiceBodyLinesItemRateCardOneFeatureKeyRegExp)
                  .optional()
                  .describe('The feature the customer is entitled to use.'),
                price: zod
                  .union([
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The amount of the flat price.'),
                        paymentTerm: zod
                          .enum(['in_advance', 'in_arrears'])
                          .describe(
                            'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                          )
                          .default(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault,
                          )
                          .describe(
                            'The payment term of the flat price.\nDefaults to in advance.',
                          ),
                        type: zod.enum(['flat']),
                      })
                      .describe('Flat price with payment term.'),
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The amount of the unit price.'),
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        type: zod.enum(['unit']),
                      })
                      .describe('Unit price with spend commitments.'),
                    zod
                      .object({
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        mode: zod
                          .enum(['volume', 'graduated'])
                          .describe('The mode of the tiered price.')
                          .describe(
                            'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                          ),
                        tiers: zod
                          .array(
                            zod
                              .object({
                                flatPrice: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the flat price.',
                                      ),
                                    type: zod
                                      .enum(['flat'])
                                      .describe('The type of the price.'),
                                  })
                                  .describe('Flat price.')
                                  .nullable()
                                  .describe(
                                    'The flat price component of the tier.',
                                  ),
                                unitPrice: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the unit price.',
                                      ),
                                    type: zod
                                      .enum(['unit'])
                                      .describe('The type of the price.'),
                                  })
                                  .describe('Unit price.')
                                  .nullable()
                                  .describe(
                                    'The unit price component of the tier.',
                                  ),
                                upToAmount: zod.coerce
                                  .string()
                                  .regex(
                                    updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                                  ),
                              })
                              .describe(
                                'A price tier.\nAt least one price component is required in each tier.',
                              ),
                          )
                          .min(1)
                          .describe(
                            'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                          ),
                        type: zod.enum(['tiered']),
                      })
                      .describe('Tiered price with spend commitments.'),
                    zod
                      .object({
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        multiplier: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .default(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierDefault,
                          )
                          .describe(
                            'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                          ),
                        type: zod.enum(['dynamic']),
                      })
                      .describe('Dynamic price with spend commitments.'),
                    zod
                      .object({
                        amount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The price of one package.'),
                        maximumAmount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is limited to spend at most the amount.',
                          ),
                        minimumAmount: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .optional()
                          .describe(
                            'The customer is committed to spend at least the amount.',
                          ),
                        quantityPerPackage: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp,
                          )
                          .describe(
                            'Numeric represents an arbitrary precision number.',
                          )
                          .describe('The quantity per package.'),
                        type: zod.enum(['package']),
                      })
                      .describe('Package price with spend commitments.'),
                  ])
                  .describe('The price of the usage based rate card.')
                  .nullable()
                  .describe(
                    'The price of the rate card.\nWhen null, the feature or service is free.',
                  ),
                taxConfig: zod
                  .object({
                    behavior: zod
                      .enum(['inclusive', 'exclusive'])
                      .describe(
                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                      )
                      .optional()
                      .describe(
                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                      ),
                    customInvoicing: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .describe(
                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                          ),
                      })
                      .describe('Custom invoicing tax config.')
                      .optional()
                      .describe('Custom invoicing tax config.'),
                    stripe: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp,
                          )
                          .describe(
                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                          ),
                      })
                      .describe('The tax config for Stripe.')
                      .optional()
                      .describe('Stripe tax config.'),
                  })
                  .describe('Set of provider specific tax configs.')
                  .optional()
                  .describe(
                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                  ),
              })
              .describe(
                'InvoiceUsageBasedRateCard represents the rate card (intent) for an usage-based line.',
              )
              .optional()
              .describe(
                'The rate card that is used for this line.\n\nThe rate card captures the intent of the price and discounts for the usage-based item.',
              ),
            taxConfig: zod
              .object({
                behavior: zod
                  .enum(['inclusive', 'exclusive'])
                  .describe(
                    'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                  )
                  .optional()
                  .describe(
                    "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                  ),
                customInvoicing: zod
                  .object({
                    code: zod.coerce
                      .string()
                      .describe(
                        'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                      ),
                  })
                  .describe('Custom invoicing tax config.')
                  .optional()
                  .describe('Custom invoicing tax config.'),
                stripe: zod
                  .object({
                    code: zod.coerce
                      .string()
                      .regex(
                        updateInvoiceBodyLinesItemTaxConfigOneStripeOneCodeRegExp,
                      )
                      .describe(
                        'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                      ),
                  })
                  .describe('The tax config for Stripe.')
                  .optional()
                  .describe('Stripe tax config.'),
              })
              .describe('Set of provider specific tax configs.')
              .optional()
              .describe(
                'Tax config specify the tax configuration for this line.',
              ),
          })
          .describe(
            'InvoiceLineReplaceUpdate represents the update model for an UBP invoice line.\n\nThis type makes ID optional to allow for creating new lines as part of the update.',
          ),
      )
      .describe('The lines included in the invoice.'),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    supplier: zod
      .object({
        addresses: zod
          .array(
            zod
              .object({
                city: zod.coerce.string().optional().describe('City.'),
                country: zod.coerce
                  .string()
                  .min(updateInvoiceBodySupplierOneAddressesItemCountryOneMin)
                  .max(updateInvoiceBodySupplierOneAddressesItemCountryOneMax)
                  .regex(
                    updateInvoiceBodySupplierOneAddressesItemCountryOneRegExp,
                  )
                  .describe(
                    '[ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.',
                  )
                  .optional()
                  .describe(
                    'Country code in [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 format.',
                  ),
                line1: zod.coerce
                  .string()
                  .optional()
                  .describe('First line of the address.'),
                line2: zod.coerce
                  .string()
                  .optional()
                  .describe('Second line of the address.'),
                phoneNumber: zod.coerce
                  .string()
                  .optional()
                  .describe('Phone number.'),
                postalCode: zod.coerce
                  .string()
                  .optional()
                  .describe('Postal code.'),
                state: zod.coerce
                  .string()
                  .optional()
                  .describe('State or province.'),
              })
              .describe('Address'),
          )
          .max(updateInvoiceBodySupplierOneAddressesMax)
          .optional()
          .describe(
            'Regular post addresses for where information should be sent if needed.',
          ),
        key: zod.coerce
          .string()
          .min(1)
          .max(updateInvoiceBodySupplierOneKeyMax)
          .optional()
          .describe('An optional unique key of the party (if available)'),
        name: zod.coerce
          .string()
          .optional()
          .describe('Legal name or representation of the organization.'),
        taxId: zod
          .object({
            code: zod.coerce
              .string()
              .min(1)
              .max(updateInvoiceBodySupplierOneTaxIdOneCodeOneMax)
              .describe(
                'TaxIdentificationCode is a normalized tax code shown on the original identity document.',
              )
              .optional()
              .describe(
                'Normalized tax code shown on the original identity document.',
              ),
          })
          .describe(
            'Identity stores the details required to identify an entity for tax purposes in a specific country.',
          )
          .optional()
          .describe(
            "The entity's legal ID code used for tax purposes. They may have\nother numbers, but we're only interested in those valid for tax purposes.",
          ),
      })
      .describe('Resource update operation model.')
      .describe('The supplier of the lines included in the invoice.'),
    workflow: zod
      .object({
        workflow: zod
          .object({
            invoicing: zod
              .object({
                autoAdvance: zod.coerce
                  .boolean()
                  .default(
                    updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneAutoAdvanceDefault,
                  )
                  .describe(
                    'Whether to automatically issue the invoice after the draftPeriod has passed.',
                  ),
                defaultTaxConfig: zod
                  .object({
                    behavior: zod
                      .enum(['inclusive', 'exclusive'])
                      .describe(
                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                      )
                      .optional()
                      .describe(
                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                      ),
                    customInvoicing: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .describe(
                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                          ),
                      })
                      .describe('Custom invoicing tax config.')
                      .optional()
                      .describe('Custom invoicing tax config.'),
                    stripe: zod
                      .object({
                        code: zod.coerce
                          .string()
                          .regex(
                            updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp,
                          )
                          .describe(
                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                          ),
                      })
                      .describe('The tax config for Stripe.')
                      .optional()
                      .describe('Stripe tax config.'),
                  })
                  .describe('Set of provider specific tax configs.')
                  .optional()
                  .describe(
                    'Default tax configuration to apply to the invoices.',
                  ),
                draftPeriod: zod.coerce
                  .string()
                  .default(
                    updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDraftPeriodDefault,
                  )
                  .describe(
                    'The period for the invoice to be kept in draft status for manual reviews.',
                  ),
                dueAfter: zod.coerce
                  .string()
                  .default(
                    updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDueAfterDefault,
                  )
                  .describe(
                    "The period after which the invoice is due.\nWith some payment solutions it's only applicable for manual collection method.",
                  ),
              })
              .describe(
                'InvoiceWorkflowInvoicingSettingsReplaceUpdate represents the update model for the invoicing settings of an invoice workflow.',
              )
              .describe('The invoicing settings for this workflow'),
            payment: zod
              .object({
                collectionMethod: zod
                  .enum(['charge_automatically', 'send_invoice'])
                  .describe(
                    'CollectionMethod specifies how the invoice should be collected (automatic vs manual)',
                  )
                  .default(
                    updateInvoiceBodyWorkflowOneWorkflowOnePaymentOneCollectionMethodDefault,
                  )
                  .describe('The payment method for the invoice.'),
              })
              .describe(
                'BillingWorkflowPaymentSettings represents the payment settings for a billing workflow',
              )
              .describe('The payment settings for this workflow'),
          })
          .describe(
            "Mutable workflow settings for an invoice.\n\nOther fields on the invoice's workflow are not mutable, they serve as a history of the invoice's workflow\nat creation time.",
          )
          .describe('The workflow used for this invoice.'),
      })
      .describe(
        'InvoiceWorkflowReplaceUpdate represents the update model for an invoice workflow.\n\nFields that are immutable a re removed from the model. This is based on InvoiceWorkflowSettings.',
      )
      .describe('The workflow settings for the invoice.'),
  })
  .describe('InvoiceReplaceUpdate represents the update model for an invoice.')

/**
 * Advance the invoice's state to the next status.

The call doesn't "approve the invoice", it only advances the invoice to the next status if the transition would be automatic.

The action can be called when the invoice's statusDetails' actions field contain the "advance" action.
 * @summary Advance the invoice's state to the next status
 */
export const advanceInvoiceActionPathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const AdvanceInvoiceActionParams = zod.object({
  invoiceId: zod.coerce.string().regex(advanceInvoiceActionPathInvoiceIdRegExp),
})

/**
 * Approve an invoice and start executing the payment workflow.

This call instantly sends the invoice to the customer using the configured billing profile app.

This call is valid in two invoice statuses:
- `draft`: the invoice will be sent to the customer, the invluce state becomes issued
- `manual_approval_needed`: the invoice will be sent to the customer, the invoice state becomes issued
 * @summary Send the invoice to the customer
 */
export const approveInvoiceActionPathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ApproveInvoiceActionParams = zod.object({
  invoiceId: zod.coerce.string().regex(approveInvoiceActionPathInvoiceIdRegExp),
})

/**
 * Retry advancing the invoice after a failed attempt.

The action can be called when the invoice's statusDetails' actions field contain the "retry" action.
 * @summary Retry advancing the invoice after a failed attempt.
 */
export const retryInvoiceActionPathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const RetryInvoiceActionParams = zod.object({
  invoiceId: zod.coerce.string().regex(retryInvoiceActionPathInvoiceIdRegExp),
})

/**
 * Snapshot quantities for usage based line items.

This call will snapshot the quantities for all usage based line items in the invoice.

This call is only valid in `draft.waiting_for_collection` status, where the collection period
can be skipped using this action.
 * @summary Snapshot quantities for usage based line items
 */
export const snapshotQuantitiesInvoiceActionPathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const SnapshotQuantitiesInvoiceActionParams = zod.object({
  invoiceId: zod.coerce
    .string()
    .regex(snapshotQuantitiesInvoiceActionPathInvoiceIdRegExp),
})

/**
 * Recalculate an invoice's tax amounts (using the app set in the customer's billing profile)

Note: charges might apply, depending on the tax provider.
 * @summary Recalculate an invoice's tax amounts
 */
export const recalculateInvoiceTaxActionPathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const RecalculateInvoiceTaxActionParams = zod.object({
  invoiceId: zod.coerce
    .string()
    .regex(recalculateInvoiceTaxActionPathInvoiceIdRegExp),
})

/**
 * Void an invoice

Only invoices that have been alread issued can be voided.

Voiding an invoice will mark it as voided, the user can specify how to handle the voided line items.
 * @summary Void an invoice
 */
export const voidInvoiceActionPathInvoiceIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const VoidInvoiceActionParams = zod.object({
  invoiceId: zod.coerce.string().regex(voidInvoiceActionPathInvoiceIdRegExp),
})

export const voidInvoiceActionBodyOverridesItemLineIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const VoidInvoiceActionBody = zod
  .object({
    action: zod
      .object({
        action: zod
          .union([
            zod
              .object({
                type: zod.enum(['discard']),
              })
              .describe(
                'VoidInvoiceLineDiscardAction describes how to handle the voidied line item in the invoice.',
              ),
            zod
              .object({
                nextInvoiceAt: zod.coerce
                  .date()
                  .optional()
                  .describe(
                    'The time at which the line item should be invoiced again.\n\nIf not provided, the line item will be re-invoiced now.',
                  ),
                type: zod.enum(['pending']),
              })
              .describe(
                'VoidInvoiceLinePendingAction describes how to handle the voidied line item in the invoice.',
              ),
          ])
          .describe(
            'VoidInvoiceLineAction describes how to handle a specific line item in the invoice when voiding.',
          )
          .describe('The action to take on the line items.'),
        percentage: zod.coerce
          .number()
          .describe(
            'Numeric representation of a percentage\n\n50% is represented as 50',
          )
          .describe(
            'How much of the total line items to be voided? (e.g. 100% means all charges are voided)',
          ),
      })
      .describe(
        'InvoiceVoidAction describes how to handle the voided line items.',
      )
      .describe('The action to take on the voided line items.'),
    overrides: zod
      .array(
        zod
          .object({
            action: zod
              .object({
                action: zod
                  .union([
                    zod
                      .object({
                        type: zod.enum(['discard']),
                      })
                      .describe(
                        'VoidInvoiceLineDiscardAction describes how to handle the voidied line item in the invoice.',
                      ),
                    zod
                      .object({
                        nextInvoiceAt: zod.coerce
                          .date()
                          .optional()
                          .describe(
                            'The time at which the line item should be invoiced again.\n\nIf not provided, the line item will be re-invoiced now.',
                          ),
                        type: zod.enum(['pending']),
                      })
                      .describe(
                        'VoidInvoiceLinePendingAction describes how to handle the voidied line item in the invoice.',
                      ),
                  ])
                  .describe(
                    'VoidInvoiceLineAction describes how to handle a specific line item in the invoice when voiding.',
                  )
                  .describe('The action to take on the line items.'),
                percentage: zod.coerce
                  .number()
                  .describe(
                    'Numeric representation of a percentage\n\n50% is represented as 50',
                  )
                  .describe(
                    'How much of the total line items to be voided? (e.g. 100% means all charges are voided)',
                  ),
              })
              .describe(
                'InvoiceVoidAction describes how to handle the voided line items.',
              )
              .describe('The action to take on the line item.'),
            lineId: zod.coerce
              .string()
              .regex(voidInvoiceActionBodyOverridesItemLineIdRegExp)
              .describe('The line item ID to override.'),
          })
          .describe(
            'VoidInvoiceLineOverride describes how to handle a specific line item in the invoice when voiding.',
          ),
      )
      .nullish()
      .describe(
        'Per line item overrides for the action.\n\nIf not specified, the `action` will be applied to all line items.',
      ),
    reason: zod.coerce.string().describe('The reason for voiding the invoice.'),
  })
  .describe('Request to void an invoice')

/**
 * List all billing profiles matching the specified filters.

The expand option can be used to include additional information (besides the billing profile)
in the response. For example by adding the expand=apps option the apps used by the billing profile
will be included in the response.
 * @summary List billing profiles
 */
export const listBillingProfilesQueryIncludeArchivedDefault = false as const
export const listBillingProfilesQueryPageDefault = 1 as const

export const listBillingProfilesQueryPageSizeDefault = 100 as const
export const listBillingProfilesQueryPageSizeMax = 1000 as const

export const ListBillingProfilesQueryParams = zod.object({
  expand: zod
    .array(
      zod
        .enum(['apps'])
        .describe('BillingProfileExpand details what profile fields to expand'),
    )
    .optional(),
  includeArchived: zod.coerce
    .boolean()
    .default(listBillingProfilesQueryIncludeArchivedDefault),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['createdAt', 'updatedAt', 'default', 'name'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listBillingProfilesQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listBillingProfilesQueryPageSizeMax)
    .default(listBillingProfilesQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * Create a new billing profile

Billing profiles are representations of a customer's billing information. Customer overrides
can be applied to a billing profile to customize the billing behavior for a specific customer.
 * @summary Create a new billing profile
 */
export const createBillingProfileBodyNameMax = 256 as const

export const createBillingProfileBodyDescriptionMax = 1024 as const

export const createBillingProfileBodySupplierOneKeyMax = 256 as const

export const createBillingProfileBodySupplierOneTaxIdOneCodeOneMax = 32 as const

export const createBillingProfileBodySupplierOneAddressesItemCountryOneMin =
  2 as const
export const createBillingProfileBodySupplierOneAddressesItemCountryOneMax =
  2 as const

export const createBillingProfileBodySupplierOneAddressesItemCountryOneRegExp =
  /^[A-Z]{2}$/
export const createBillingProfileBodySupplierOneAddressesMax = 1 as const

export const createBillingProfileBodyWorkflowOneCollectionOneAlignmentOneTwoRecurringPeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const createBillingProfileBodyWorkflowOneCollectionOneAlignmentDefault =
  { type: 'subscription' } as const
export const createBillingProfileBodyWorkflowOneCollectionOneIntervalDefault =
  'PT1H' as const
export const createBillingProfileBodyWorkflowOneInvoicingOneAutoAdvanceDefault =
  true as const
export const createBillingProfileBodyWorkflowOneInvoicingOneDraftPeriodDefault =
  'P0D' as const
export const createBillingProfileBodyWorkflowOneInvoicingOneDueAfterDefault =
  'P30D' as const
export const createBillingProfileBodyWorkflowOneInvoicingOneProgressiveBillingDefault =
  true as const
export const createBillingProfileBodyWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const createBillingProfileBodyWorkflowOnePaymentOneCollectionMethodDefault =
  'charge_automatically' as const
export const createBillingProfileBodyWorkflowOneTaxOneEnabledDefault =
  true as const
export const createBillingProfileBodyWorkflowOneTaxOneEnforcedDefault =
  false as const
export const createBillingProfileBodyAppsOneTaxRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createBillingProfileBodyAppsOneInvoicingRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createBillingProfileBodyAppsOnePaymentRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const CreateBillingProfileBody = zod
  .object({
    apps: zod
      .object({
        invoicing: zod.coerce
          .string()
          .regex(createBillingProfileBodyAppsOneInvoicingRegExp)
          .describe('The invoicing app used for this workflow'),
        payment: zod.coerce
          .string()
          .regex(createBillingProfileBodyAppsOnePaymentRegExp)
          .describe('The payment app used for this workflow'),
        tax: zod.coerce
          .string()
          .regex(createBillingProfileBodyAppsOneTaxRegExp)
          .describe('The tax app used for this workflow'),
      })
      .describe(
        "BillingProfileAppsCreate represents the input for creating a billing profile's apps",
      )
      .describe('The apps used by this billing profile.'),
    default: zod.coerce.boolean().describe('Is this the default profile?'),
    description: zod.coerce
      .string()
      .max(createBillingProfileBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(createBillingProfileBodyNameMax)
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.',
      ),
    supplier: zod
      .object({
        addresses: zod
          .array(
            zod
              .object({
                city: zod.coerce.string().optional().describe('City.'),
                country: zod.coerce
                  .string()
                  .min(
                    createBillingProfileBodySupplierOneAddressesItemCountryOneMin,
                  )
                  .max(
                    createBillingProfileBodySupplierOneAddressesItemCountryOneMax,
                  )
                  .regex(
                    createBillingProfileBodySupplierOneAddressesItemCountryOneRegExp,
                  )
                  .describe(
                    '[ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.',
                  )
                  .optional()
                  .describe(
                    'Country code in [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 format.',
                  ),
                line1: zod.coerce
                  .string()
                  .optional()
                  .describe('First line of the address.'),
                line2: zod.coerce
                  .string()
                  .optional()
                  .describe('Second line of the address.'),
                phoneNumber: zod.coerce
                  .string()
                  .optional()
                  .describe('Phone number.'),
                postalCode: zod.coerce
                  .string()
                  .optional()
                  .describe('Postal code.'),
                state: zod.coerce
                  .string()
                  .optional()
                  .describe('State or province.'),
              })
              .describe('Address'),
          )
          .max(createBillingProfileBodySupplierOneAddressesMax)
          .optional()
          .describe(
            'Regular post addresses for where information should be sent if needed.',
          ),
        id: zod.coerce
          .string()
          .optional()
          .describe('Unique identifier for the party (if available)'),
        key: zod.coerce
          .string()
          .min(1)
          .max(createBillingProfileBodySupplierOneKeyMax)
          .optional()
          .describe('An optional unique key of the party (if available)'),
        name: zod.coerce
          .string()
          .optional()
          .describe('Legal name or representation of the organization.'),
        taxId: zod
          .object({
            code: zod.coerce
              .string()
              .min(1)
              .max(createBillingProfileBodySupplierOneTaxIdOneCodeOneMax)
              .describe(
                'TaxIdentificationCode is a normalized tax code shown on the original identity document.',
              )
              .optional()
              .describe(
                'Normalized tax code shown on the original identity document.',
              ),
          })
          .describe(
            'Identity stores the details required to identify an entity for tax purposes in a specific country.',
          )
          .optional()
          .describe(
            "The entity's legal ID code used for tax purposes. They may have\nother numbers, but we're only interested in those valid for tax purposes.",
          ),
      })
      .describe('Party represents a person or business entity.')
      .describe(
        'The name and contact information for the supplier this billing profile represents',
      ),
    workflow: zod
      .object({
        collection: zod
          .object({
            alignment: zod
              .union([
                zod
                  .object({
                    type: zod.enum(['subscription']),
                  })
                  .describe(
                    'BillingWorkflowCollectionAlignmentSubscription specifies the alignment for collecting the pending line items\ninto an invoice.',
                  ),
                zod
                  .object({
                    recurringPeriod: zod
                      .object({
                        anchor: zod.coerce
                          .date()
                          .describe(
                            'A date-time anchor to base the recurring period on.',
                          ),
                        interval: zod
                          .union([
                            zod.coerce
                              .string()
                              .regex(
                                createBillingProfileBodyWorkflowOneCollectionOneAlignmentOneTwoRecurringPeriodOneIntervalOneOneRegExp,
                              ),
                            zod
                              .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                              .describe(
                                'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                              ),
                          ])
                          .describe('Period duration for the recurrence')
                          .describe(
                            'The unit of time for the interval. Heuristically maps ISO duraitons to enum values or returns the ISO duration.',
                          ),
                      })
                      .describe(
                        'Recurring period with an interval and an anchor.',
                      )
                      .describe('The recurring period for the alignment.'),
                    type: zod.enum(['anchored']),
                  })
                  .describe(
                    'BillingWorkflowCollectionAlignmentAnchored specifies the alignment for collecting the pending line items\ninto an invoice.',
                  ),
              ])
              .describe(
                'The alignment for collecting the pending line items into an invoice.\n\nDefaults to subscription, which means that we are to create a new invoice every time the\na subscription period starts (for in advance items) or ends (for in arrears items).',
              )
              .default(
                createBillingProfileBodyWorkflowOneCollectionOneAlignmentDefault,
              )
              .describe(
                'The alignment for collecting the pending line items into an invoice.',
              ),
            interval: zod.coerce
              .string()
              .default(
                createBillingProfileBodyWorkflowOneCollectionOneIntervalDefault,
              )
              .describe(
                'This grace period can be used to delay the collection of the pending line items specified in\nalignment.\n\nThis is useful, in case of multiple subscriptions having slightly different billing periods.',
              ),
          })
          .describe(
            'Workflow collection specifies how to collect the pending line items for an invoice',
          )
          .optional()
          .describe('The collection settings for this workflow'),
        invoicing: zod
          .object({
            autoAdvance: zod.coerce
              .boolean()
              .default(
                createBillingProfileBodyWorkflowOneInvoicingOneAutoAdvanceDefault,
              )
              .describe(
                'Whether to automatically issue the invoice after the draftPeriod has passed.',
              ),
            defaultTaxConfig: zod
              .object({
                behavior: zod
                  .enum(['inclusive', 'exclusive'])
                  .describe(
                    'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                  )
                  .optional()
                  .describe(
                    "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                  ),
                customInvoicing: zod
                  .object({
                    code: zod.coerce
                      .string()
                      .describe(
                        'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                      ),
                  })
                  .describe('Custom invoicing tax config.')
                  .optional()
                  .describe('Custom invoicing tax config.'),
                stripe: zod
                  .object({
                    code: zod.coerce
                      .string()
                      .regex(
                        createBillingProfileBodyWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp,
                      )
                      .describe(
                        'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                      ),
                  })
                  .describe('The tax config for Stripe.')
                  .optional()
                  .describe('Stripe tax config.'),
              })
              .describe('Set of provider specific tax configs.')
              .optional()
              .describe('Default tax configuration to apply to the invoices.'),
            draftPeriod: zod.coerce
              .string()
              .default(
                createBillingProfileBodyWorkflowOneInvoicingOneDraftPeriodDefault,
              )
              .describe(
                'The period for the invoice to be kept in draft status for manual reviews.',
              ),
            dueAfter: zod.coerce
              .string()
              .default(
                createBillingProfileBodyWorkflowOneInvoicingOneDueAfterDefault,
              )
              .describe(
                "The period after which the invoice is due.\nWith some payment solutions it's only applicable for manual collection method.",
              ),
            progressiveBilling: zod.coerce
              .boolean()
              .default(
                createBillingProfileBodyWorkflowOneInvoicingOneProgressiveBillingDefault,
              )
              .describe(
                'Should progressive billing be allowed for this workflow?',
              ),
          })
          .describe(
            'BillingWorkflowInvoicingSettings represents the invoice settings for a billing workflow',
          )
          .optional()
          .describe('The invoicing settings for this workflow'),
        payment: zod
          .object({
            collectionMethod: zod
              .enum(['charge_automatically', 'send_invoice'])
              .describe(
                'CollectionMethod specifies how the invoice should be collected (automatic vs manual)',
              )
              .default(
                createBillingProfileBodyWorkflowOnePaymentOneCollectionMethodDefault,
              )
              .describe('The payment method for the invoice.'),
          })
          .describe(
            'BillingWorkflowPaymentSettings represents the payment settings for a billing workflow',
          )
          .optional()
          .describe('The payment settings for this workflow'),
        tax: zod
          .object({
            enabled: zod.coerce
              .boolean()
              .default(createBillingProfileBodyWorkflowOneTaxOneEnabledDefault)
              .describe(
                'Enable automatic tax calculation when tax is supported by the app.\nFor example, with Stripe Invoicing when enabled, tax is calculated via Stripe Tax.',
              ),
            enforced: zod.coerce
              .boolean()
              .default(createBillingProfileBodyWorkflowOneTaxOneEnforcedDefault)
              .describe(
                'Enforce tax calculation when tax is supported by the app.\nWhen enabled, OpenMeter will not allow to create an invoice without tax calculation.\nEnforcement is different per apps, for example, Stripe app requires customer\nto have a tax location when starting a paid subscription.',
              ),
          })
          .describe(
            'BillingWorkflowTaxSettings represents the tax settings for a billing workflow',
          )
          .optional()
          .describe('The tax settings for this workflow'),
      })
      .describe('Resource create operation model.')
      .describe('The billing workflow settings for this profile.'),
  })
  .describe(
    'BillingProfileCreate represents the input for creating a billing profile',
  )

/**
 * Delete a billing profile by id.

Only such billing profiles can be deleted that are:
- not the default one
- not pinned to any customer using customer overrides
- only have finalized invoices
 * @summary Delete a billing profile
 */
export const deleteBillingProfilePathIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeleteBillingProfileParams = zod.object({
  id: zod.coerce.string().regex(deleteBillingProfilePathIdRegExp),
})

/**
 * Get a billing profile by id.

The expand option can be used to include additional information (besides the billing profile)
in the response. For example by adding the expand=apps option the apps used by the billing profile
will be included in the response.
 * @summary Get a billing profile
 */
export const getBillingProfilePathIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetBillingProfileParams = zod.object({
  id: zod.coerce.string().regex(getBillingProfilePathIdRegExp),
})

export const GetBillingProfileQueryParams = zod.object({
  expand: zod
    .array(
      zod
        .enum(['apps'])
        .describe('BillingProfileExpand details what profile fields to expand'),
    )
    .optional(),
})

/**
 * Update a billing profile by id.

The apps field cannot be updated directly, if an app change is desired a new
profile should be created.
 * @summary Update a billing profile
 */
export const updateBillingProfilePathIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdateBillingProfileParams = zod.object({
  id: zod.coerce.string().regex(updateBillingProfilePathIdRegExp),
})

export const updateBillingProfileBodyNameMax = 256 as const

export const updateBillingProfileBodyDescriptionMax = 1024 as const

export const updateBillingProfileBodySupplierOneKeyMax = 256 as const

export const updateBillingProfileBodySupplierOneTaxIdOneCodeOneMax = 32 as const

export const updateBillingProfileBodySupplierOneAddressesItemCountryOneMin =
  2 as const
export const updateBillingProfileBodySupplierOneAddressesItemCountryOneMax =
  2 as const

export const updateBillingProfileBodySupplierOneAddressesItemCountryOneRegExp =
  /^[A-Z]{2}$/
export const updateBillingProfileBodySupplierOneAddressesMax = 1 as const

export const updateBillingProfileBodyWorkflowOneCollectionOneAlignmentOneTwoRecurringPeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const updateBillingProfileBodyWorkflowOneCollectionOneAlignmentDefault =
  { type: 'subscription' } as const
export const updateBillingProfileBodyWorkflowOneCollectionOneIntervalDefault =
  'PT1H' as const
export const updateBillingProfileBodyWorkflowOneInvoicingOneAutoAdvanceDefault =
  true as const
export const updateBillingProfileBodyWorkflowOneInvoicingOneDraftPeriodDefault =
  'P0D' as const
export const updateBillingProfileBodyWorkflowOneInvoicingOneDueAfterDefault =
  'P30D' as const
export const updateBillingProfileBodyWorkflowOneInvoicingOneProgressiveBillingDefault =
  true as const
export const updateBillingProfileBodyWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const updateBillingProfileBodyWorkflowOnePaymentOneCollectionMethodDefault =
  'charge_automatically' as const
export const updateBillingProfileBodyWorkflowOneTaxOneEnabledDefault =
  true as const
export const updateBillingProfileBodyWorkflowOneTaxOneEnforcedDefault =
  false as const

export const UpdateBillingProfileBody = zod
  .object({
    default: zod.coerce.boolean().describe('Is this the default profile?'),
    description: zod.coerce
      .string()
      .max(updateBillingProfileBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(updateBillingProfileBodyNameMax)
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.',
      ),
    supplier: zod
      .object({
        addresses: zod
          .array(
            zod
              .object({
                city: zod.coerce.string().optional().describe('City.'),
                country: zod.coerce
                  .string()
                  .min(
                    updateBillingProfileBodySupplierOneAddressesItemCountryOneMin,
                  )
                  .max(
                    updateBillingProfileBodySupplierOneAddressesItemCountryOneMax,
                  )
                  .regex(
                    updateBillingProfileBodySupplierOneAddressesItemCountryOneRegExp,
                  )
                  .describe(
                    '[ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.',
                  )
                  .optional()
                  .describe(
                    'Country code in [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 format.',
                  ),
                line1: zod.coerce
                  .string()
                  .optional()
                  .describe('First line of the address.'),
                line2: zod.coerce
                  .string()
                  .optional()
                  .describe('Second line of the address.'),
                phoneNumber: zod.coerce
                  .string()
                  .optional()
                  .describe('Phone number.'),
                postalCode: zod.coerce
                  .string()
                  .optional()
                  .describe('Postal code.'),
                state: zod.coerce
                  .string()
                  .optional()
                  .describe('State or province.'),
              })
              .describe('Address'),
          )
          .max(updateBillingProfileBodySupplierOneAddressesMax)
          .optional()
          .describe(
            'Regular post addresses for where information should be sent if needed.',
          ),
        id: zod.coerce
          .string()
          .optional()
          .describe('Unique identifier for the party (if available)'),
        key: zod.coerce
          .string()
          .min(1)
          .max(updateBillingProfileBodySupplierOneKeyMax)
          .optional()
          .describe('An optional unique key of the party (if available)'),
        name: zod.coerce
          .string()
          .optional()
          .describe('Legal name or representation of the organization.'),
        taxId: zod
          .object({
            code: zod.coerce
              .string()
              .min(1)
              .max(updateBillingProfileBodySupplierOneTaxIdOneCodeOneMax)
              .describe(
                'TaxIdentificationCode is a normalized tax code shown on the original identity document.',
              )
              .optional()
              .describe(
                'Normalized tax code shown on the original identity document.',
              ),
          })
          .describe(
            'Identity stores the details required to identify an entity for tax purposes in a specific country.',
          )
          .optional()
          .describe(
            "The entity's legal ID code used for tax purposes. They may have\nother numbers, but we're only interested in those valid for tax purposes.",
          ),
      })
      .describe('Party represents a person or business entity.')
      .describe(
        'The name and contact information for the supplier this billing profile represents',
      ),
    workflow: zod
      .object({
        collection: zod
          .object({
            alignment: zod
              .union([
                zod
                  .object({
                    type: zod.enum(['subscription']),
                  })
                  .describe(
                    'BillingWorkflowCollectionAlignmentSubscription specifies the alignment for collecting the pending line items\ninto an invoice.',
                  ),
                zod
                  .object({
                    recurringPeriod: zod
                      .object({
                        anchor: zod.coerce
                          .date()
                          .describe(
                            'A date-time anchor to base the recurring period on.',
                          ),
                        interval: zod
                          .union([
                            zod.coerce
                              .string()
                              .regex(
                                updateBillingProfileBodyWorkflowOneCollectionOneAlignmentOneTwoRecurringPeriodOneIntervalOneOneRegExp,
                              ),
                            zod
                              .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                              .describe(
                                'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                              ),
                          ])
                          .describe('Period duration for the recurrence')
                          .describe(
                            'The unit of time for the interval. Heuristically maps ISO duraitons to enum values or returns the ISO duration.',
                          ),
                      })
                      .describe(
                        'Recurring period with an interval and an anchor.',
                      )
                      .describe('The recurring period for the alignment.'),
                    type: zod.enum(['anchored']),
                  })
                  .describe(
                    'BillingWorkflowCollectionAlignmentAnchored specifies the alignment for collecting the pending line items\ninto an invoice.',
                  ),
              ])
              .describe(
                'The alignment for collecting the pending line items into an invoice.\n\nDefaults to subscription, which means that we are to create a new invoice every time the\na subscription period starts (for in advance items) or ends (for in arrears items).',
              )
              .default(
                updateBillingProfileBodyWorkflowOneCollectionOneAlignmentDefault,
              )
              .describe(
                'The alignment for collecting the pending line items into an invoice.',
              ),
            interval: zod.coerce
              .string()
              .default(
                updateBillingProfileBodyWorkflowOneCollectionOneIntervalDefault,
              )
              .describe(
                'This grace period can be used to delay the collection of the pending line items specified in\nalignment.\n\nThis is useful, in case of multiple subscriptions having slightly different billing periods.',
              ),
          })
          .describe(
            'Workflow collection specifies how to collect the pending line items for an invoice',
          )
          .optional()
          .describe('The collection settings for this workflow'),
        invoicing: zod
          .object({
            autoAdvance: zod.coerce
              .boolean()
              .default(
                updateBillingProfileBodyWorkflowOneInvoicingOneAutoAdvanceDefault,
              )
              .describe(
                'Whether to automatically issue the invoice after the draftPeriod has passed.',
              ),
            defaultTaxConfig: zod
              .object({
                behavior: zod
                  .enum(['inclusive', 'exclusive'])
                  .describe(
                    'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                  )
                  .optional()
                  .describe(
                    "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                  ),
                customInvoicing: zod
                  .object({
                    code: zod.coerce
                      .string()
                      .describe(
                        'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                      ),
                  })
                  .describe('Custom invoicing tax config.')
                  .optional()
                  .describe('Custom invoicing tax config.'),
                stripe: zod
                  .object({
                    code: zod.coerce
                      .string()
                      .regex(
                        updateBillingProfileBodyWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp,
                      )
                      .describe(
                        'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                      ),
                  })
                  .describe('The tax config for Stripe.')
                  .optional()
                  .describe('Stripe tax config.'),
              })
              .describe('Set of provider specific tax configs.')
              .optional()
              .describe('Default tax configuration to apply to the invoices.'),
            draftPeriod: zod.coerce
              .string()
              .default(
                updateBillingProfileBodyWorkflowOneInvoicingOneDraftPeriodDefault,
              )
              .describe(
                'The period for the invoice to be kept in draft status for manual reviews.',
              ),
            dueAfter: zod.coerce
              .string()
              .default(
                updateBillingProfileBodyWorkflowOneInvoicingOneDueAfterDefault,
              )
              .describe(
                "The period after which the invoice is due.\nWith some payment solutions it's only applicable for manual collection method.",
              ),
            progressiveBilling: zod.coerce
              .boolean()
              .default(
                updateBillingProfileBodyWorkflowOneInvoicingOneProgressiveBillingDefault,
              )
              .describe(
                'Should progressive billing be allowed for this workflow?',
              ),
          })
          .describe(
            'BillingWorkflowInvoicingSettings represents the invoice settings for a billing workflow',
          )
          .optional()
          .describe('The invoicing settings for this workflow'),
        payment: zod
          .object({
            collectionMethod: zod
              .enum(['charge_automatically', 'send_invoice'])
              .describe(
                'CollectionMethod specifies how the invoice should be collected (automatic vs manual)',
              )
              .default(
                updateBillingProfileBodyWorkflowOnePaymentOneCollectionMethodDefault,
              )
              .describe('The payment method for the invoice.'),
          })
          .describe(
            'BillingWorkflowPaymentSettings represents the payment settings for a billing workflow',
          )
          .optional()
          .describe('The payment settings for this workflow'),
        tax: zod
          .object({
            enabled: zod.coerce
              .boolean()
              .default(updateBillingProfileBodyWorkflowOneTaxOneEnabledDefault)
              .describe(
                'Enable automatic tax calculation when tax is supported by the app.\nFor example, with Stripe Invoicing when enabled, tax is calculated via Stripe Tax.',
              ),
            enforced: zod.coerce
              .boolean()
              .default(updateBillingProfileBodyWorkflowOneTaxOneEnforcedDefault)
              .describe(
                'Enforce tax calculation when tax is supported by the app.\nWhen enabled, OpenMeter will not allow to create an invoice without tax calculation.\nEnforcement is different per apps, for example, Stripe app requires customer\nto have a tax location when starting a paid subscription.',
              ),
          })
          .describe(
            'BillingWorkflowTaxSettings represents the tax settings for a billing workflow',
          )
          .optional()
          .describe('The tax settings for this workflow'),
      })
      .describe(
        'BillingWorkflow represents the settings for a billing workflow.',
      )
      .describe('The billing workflow settings for this profile.'),
  })
  .describe(
    'BillingProfileReplaceUpdate represents the input for updating a billing profile\n\nThe apps field cannot be updated directly, if an app change is desired a new\nprofile should be created.',
  )

/**
 * Create a new customer.
 * @summary Create customer
 */
export const createCustomerBodyNameMax = 256 as const

export const createCustomerBodyDescriptionMax = 1024 as const

export const createCustomerBodyKeyMax = 256 as const

export const createCustomerBodyUsageAttributionOneSubjectKeysMin = 0 as const

export const createCustomerBodyCurrencyOneMin = 3 as const
export const createCustomerBodyCurrencyOneMax = 3 as const

export const createCustomerBodyCurrencyOneRegExp = /^[A-Z]{3}$/
export const createCustomerBodyBillingAddressOneCountryOneMin = 2 as const
export const createCustomerBodyBillingAddressOneCountryOneMax = 2 as const

export const createCustomerBodyBillingAddressOneCountryOneRegExp = /^[A-Z]{2}$/

export const CreateCustomerBody = zod
  .object({
    billingAddress: zod
      .object({
        city: zod.coerce.string().optional().describe('City.'),
        country: zod.coerce
          .string()
          .min(createCustomerBodyBillingAddressOneCountryOneMin)
          .max(createCustomerBodyBillingAddressOneCountryOneMax)
          .regex(createCustomerBodyBillingAddressOneCountryOneRegExp)
          .describe(
            '[ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.',
          )
          .optional()
          .describe(
            'Country code in [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 format.',
          ),
        line1: zod.coerce
          .string()
          .optional()
          .describe('First line of the address.'),
        line2: zod.coerce
          .string()
          .optional()
          .describe('Second line of the address.'),
        phoneNumber: zod.coerce.string().optional().describe('Phone number.'),
        postalCode: zod.coerce.string().optional().describe('Postal code.'),
        state: zod.coerce.string().optional().describe('State or province.'),
      })
      .describe('Address')
      .optional()
      .describe(
        'The billing address of the customer.\nUsed for tax and invoicing.',
      ),
    currency: zod.coerce
      .string()
      .min(createCustomerBodyCurrencyOneMin)
      .max(createCustomerBodyCurrencyOneMax)
      .regex(createCustomerBodyCurrencyOneRegExp)
      .describe(
        'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
      )
      .optional()
      .describe(
        'Currency of the customer.\nUsed for billing, tax and invoicing.',
      ),
    description: zod.coerce
      .string()
      .max(createCustomerBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    key: zod.coerce
      .string()
      .min(1)
      .max(createCustomerBodyKeyMax)
      .optional()
      .describe(
        'An optional unique key of the customer.\nEither key or usageAttribution.subjectKeys must be provided.\nUseful to reference the customer in external systems.\nFor example, your database ID.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(createCustomerBodyNameMax)
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.',
      ),
    primaryEmail: zod.coerce
      .string()
      .optional()
      .describe('The primary email address of the customer.'),
    usageAttribution: zod
      .object({
        subjectKeys: zod
          .array(
            zod.coerce
              .string()
              .min(1)
              .describe(
                'SubjectKey is a key that is used to identify a subject.',
              ),
          )
          .min(createCustomerBodyUsageAttributionOneSubjectKeysMin)
          .describe(
            'The subjects that are attributed to the customer.\nCan be empty when no subjects are associated with the customer.',
          ),
      })
      .describe(
        'Mapping to attribute metered usage to the customer.\nOne customer can have zero or more subjects,\nbut one subject can only belong to one customer.',
      )
      .optional()
      .describe(
        'Mapping to attribute metered usage to the customer\nEither key or usageAttribution.subjectKeys must be provided.',
      ),
  })
  .describe('Resource create operation model.')

/**
 * List customers.
 * @summary List customers
 */
export const listCustomersQueryPageDefault = 1 as const

export const listCustomersQueryPageSizeDefault = 100 as const
export const listCustomersQueryPageSizeMax = 1000 as const

export const listCustomersQueryIncludeDeletedDefault = false as const

export const ListCustomersQueryParams = zod.object({
  expand: zod
    .array(
      zod
        .enum(['subscriptions'])
        .describe(
          'CustomerExpand specifies the parts of the customer to expand in the list output.',
        ),
    )
    .optional()
    .describe('What parts of the list output to expand in listings'),
  includeDeleted: zod.coerce
    .boolean()
    .default(listCustomersQueryIncludeDeletedDefault)
    .describe('Include deleted customers.'),
  key: zod.coerce
    .string()
    .optional()
    .describe('Filter customers by key.\nCase-insensitive partial match.'),
  name: zod.coerce
    .string()
    .optional()
    .describe('Filter customers by name.\nCase-insensitive partial match.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'name', 'createdAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listCustomersQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listCustomersQueryPageSizeMax)
    .default(listCustomersQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
  planKey: zod.coerce
    .string()
    .optional()
    .describe('Filter customers by the plan key of their susbcription.'),
  primaryEmail: zod.coerce
    .string()
    .optional()
    .describe(
      'Filter customers by primary email.\nCase-insensitive partial match.',
    ),
  subject: zod.coerce
    .string()
    .optional()
    .describe(
      'Filter customers by usage attribution subject.\nCase-insensitive partial match.',
    ),
})

/**
 * Get a customer by ID or key.
 * @summary Get customer
 */
export const getCustomerPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const getCustomerPathCustomerIdOrKeyTwoMax = 256 as const

export const GetCustomerParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(getCustomerPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(getCustomerPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

export const GetCustomerQueryParams = zod.object({
  expand: zod
    .array(
      zod
        .enum(['subscriptions'])
        .describe(
          'CustomerExpand specifies the parts of the customer to expand in the list output.',
        ),
    )
    .optional()
    .describe('What parts of the customer output to expand'),
})

/**
 * Update a customer by ID.
 * @summary Update customer
 */
export const updateCustomerPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const updateCustomerPathCustomerIdOrKeyTwoMax = 256 as const

export const UpdateCustomerParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(updateCustomerPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(updateCustomerPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

export const updateCustomerBodyNameMax = 256 as const

export const updateCustomerBodyDescriptionMax = 1024 as const

export const updateCustomerBodyKeyMax = 256 as const

export const updateCustomerBodyUsageAttributionOneSubjectKeysMin = 0 as const

export const updateCustomerBodyCurrencyOneMin = 3 as const
export const updateCustomerBodyCurrencyOneMax = 3 as const

export const updateCustomerBodyCurrencyOneRegExp = /^[A-Z]{3}$/
export const updateCustomerBodyBillingAddressOneCountryOneMin = 2 as const
export const updateCustomerBodyBillingAddressOneCountryOneMax = 2 as const

export const updateCustomerBodyBillingAddressOneCountryOneRegExp = /^[A-Z]{2}$/

export const UpdateCustomerBody = zod
  .object({
    billingAddress: zod
      .object({
        city: zod.coerce.string().optional().describe('City.'),
        country: zod.coerce
          .string()
          .min(updateCustomerBodyBillingAddressOneCountryOneMin)
          .max(updateCustomerBodyBillingAddressOneCountryOneMax)
          .regex(updateCustomerBodyBillingAddressOneCountryOneRegExp)
          .describe(
            '[ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.',
          )
          .optional()
          .describe(
            'Country code in [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 format.',
          ),
        line1: zod.coerce
          .string()
          .optional()
          .describe('First line of the address.'),
        line2: zod.coerce
          .string()
          .optional()
          .describe('Second line of the address.'),
        phoneNumber: zod.coerce.string().optional().describe('Phone number.'),
        postalCode: zod.coerce.string().optional().describe('Postal code.'),
        state: zod.coerce.string().optional().describe('State or province.'),
      })
      .describe('Address')
      .optional()
      .describe(
        'The billing address of the customer.\nUsed for tax and invoicing.',
      ),
    currency: zod.coerce
      .string()
      .min(updateCustomerBodyCurrencyOneMin)
      .max(updateCustomerBodyCurrencyOneMax)
      .regex(updateCustomerBodyCurrencyOneRegExp)
      .describe(
        'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
      )
      .optional()
      .describe(
        'Currency of the customer.\nUsed for billing, tax and invoicing.',
      ),
    description: zod.coerce
      .string()
      .max(updateCustomerBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    key: zod.coerce
      .string()
      .min(1)
      .max(updateCustomerBodyKeyMax)
      .optional()
      .describe(
        'An optional unique key of the customer.\nEither key or usageAttribution.subjectKeys must be provided.\nUseful to reference the customer in external systems.\nFor example, your database ID.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(updateCustomerBodyNameMax)
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.',
      ),
    primaryEmail: zod.coerce
      .string()
      .optional()
      .describe('The primary email address of the customer.'),
    usageAttribution: zod
      .object({
        subjectKeys: zod
          .array(
            zod.coerce
              .string()
              .min(1)
              .describe(
                'SubjectKey is a key that is used to identify a subject.',
              ),
          )
          .min(updateCustomerBodyUsageAttributionOneSubjectKeysMin)
          .describe(
            'The subjects that are attributed to the customer.\nCan be empty when no subjects are associated with the customer.',
          ),
      })
      .describe(
        'Mapping to attribute metered usage to the customer.\nOne customer can have zero or more subjects,\nbut one subject can only belong to one customer.',
      )
      .optional()
      .describe(
        'Mapping to attribute metered usage to the customer\nEither key or usageAttribution.subjectKeys must be provided.',
      ),
  })
  .describe('Resource update operation model.')

/**
 * Delete a customer by ID.
 * @summary Delete customer
 */
export const deleteCustomerPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const deleteCustomerPathCustomerIdOrKeyTwoMax = 256 as const

export const DeleteCustomerParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(deleteCustomerPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(deleteCustomerPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

/**
 * Get the overall access of a customer.
 * @summary Get customer access
 */
export const getCustomerAccessPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const getCustomerAccessPathCustomerIdOrKeyTwoMax = 256 as const

export const GetCustomerAccessParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(getCustomerAccessPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(getCustomerAccessPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

/**
 * List customers app data.
 * @summary List customer app data
 */
export const listCustomerAppDataPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listCustomerAppDataPathCustomerIdOrKeyTwoMax = 256 as const

export const ListCustomerAppDataParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(listCustomerAppDataPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(listCustomerAppDataPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

export const listCustomerAppDataQueryPageDefault = 1 as const

export const listCustomerAppDataQueryPageSizeDefault = 100 as const
export const listCustomerAppDataQueryPageSizeMax = 1000 as const

export const ListCustomerAppDataQueryParams = zod.object({
  page: zod.coerce
    .number()
    .min(1)
    .default(listCustomerAppDataQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listCustomerAppDataQueryPageSizeMax)
    .default(listCustomerAppDataQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
  type: zod
    .enum(['stripe', 'sandbox', 'custom_invoicing'])
    .optional()
    .describe('Filter customer data by app type.'),
})

/**
 * Upsert customer app data.
 * @summary Upsert customer app data
 */
export const upsertCustomerAppDataPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const upsertCustomerAppDataPathCustomerIdOrKeyTwoMax = 256 as const

export const UpsertCustomerAppDataParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(upsertCustomerAppDataPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(upsertCustomerAppDataPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

export const upsertCustomerAppDataBodyOneIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const upsertCustomerAppDataBodyTwoAppOneIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const upsertCustomerAppDataBodyTwoAppOneNameMax = 256 as const

export const upsertCustomerAppDataBodyTwoAppOneDescriptionMax = 1024 as const

export const upsertCustomerAppDataBodyTwoAppOneListingOneCapabilitiesItemKeyMax =
  64 as const

export const upsertCustomerAppDataBodyTwoAppOneListingOneCapabilitiesItemKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const upsertCustomerAppDataBodyTwoIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const upsertCustomerAppDataBodyThreeAppOneIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const upsertCustomerAppDataBodyThreeAppOneNameMax = 256 as const

export const upsertCustomerAppDataBodyThreeAppOneDescriptionMax = 1024 as const

export const upsertCustomerAppDataBodyThreeAppOneListingOneCapabilitiesItemKeyMax =
  64 as const

export const upsertCustomerAppDataBodyThreeAppOneListingOneCapabilitiesItemKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const upsertCustomerAppDataBodyThreeIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpsertCustomerAppDataBodyItem = zod
  .union([
    zod
      .object({
        id: zod.coerce
          .string()
          .regex(upsertCustomerAppDataBodyOneIdRegExp)
          .optional()
          .describe(
            'The app ID.\nIf not provided, it will use the global default for the app type.',
          ),
        stripeCustomerId: zod.coerce
          .string()
          .describe('The Stripe customer ID.'),
        stripeDefaultPaymentMethodId: zod.coerce
          .string()
          .optional()
          .describe('The Stripe default payment method ID.'),
        type: zod.enum(['stripe']),
      })
      .describe('Stripe Customer App Data.'),
    zod
      .object({
        app: zod
          .object({
            createdAt: zod.coerce
              .date()
              .describe('Timestamp of when the resource was created.'),
            deletedAt: zod.coerce
              .date()
              .optional()
              .describe(
                'Timestamp of when the resource was permanently deleted.',
              ),
            description: zod.coerce
              .string()
              .max(upsertCustomerAppDataBodyTwoAppOneDescriptionMax)
              .optional()
              .describe(
                'Optional description of the resource. Maximum 1024 characters.',
              ),
            id: zod.coerce
              .string()
              .regex(upsertCustomerAppDataBodyTwoAppOneIdRegExp)
              .describe('A unique identifier for the resource.'),
            listing: zod
              .object({
                capabilities: zod
                  .array(
                    zod
                      .object({
                        description: zod.coerce
                          .string()
                          .describe('The capability description.'),
                        key: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            upsertCustomerAppDataBodyTwoAppOneListingOneCapabilitiesItemKeyMax,
                          )
                          .regex(
                            upsertCustomerAppDataBodyTwoAppOneListingOneCapabilitiesItemKeyRegExp,
                          )
                          .describe('Key'),
                        name: zod.coerce
                          .string()
                          .describe('The capability name.'),
                        type: zod
                          .enum([
                            'reportUsage',
                            'reportEvents',
                            'calculateTax',
                            'invoiceCustomers',
                            'collectPayments',
                          ])
                          .describe('App capability type.')
                          .describe('The capability type.'),
                      })
                      .describe(
                        "App capability.\n\nCapabilities only exist in config so they don't extend the Resource model.",
                      ),
                  )
                  .describe("The app's capabilities."),
                description: zod.coerce
                  .string()
                  .describe("The app's description."),
                installMethods: zod
                  .array(
                    zod
                      .enum([
                        'with_oauth2',
                        'with_api_key',
                        'no_credentials_required',
                      ])
                      .describe('Install method of the application.'),
                  )
                  .describe(
                    'Install methods.\n\nList of methods to install the app.',
                  ),
                name: zod.coerce.string().describe("The app's name."),
                type: zod
                  .enum(['stripe', 'sandbox', 'custom_invoicing'])
                  .describe('Type of the app.')
                  .describe("The app's type"),
              })
              .describe(
                "A marketplace listing.\nRepresent an available app in the app marketplace that can be installed to the organization.\n\nMarketplace apps only exist in config so they don't extend the Resource model.",
              )
              .describe(
                'The marketplace listing that this installed app is based on.',
              ),
            metadata: zod
              .record(zod.string(), zod.coerce.string())
              .describe(
                'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
              )
              .nullish()
              .describe('Additional metadata for the resource.'),
            name: zod.coerce
              .string()
              .min(1)
              .max(upsertCustomerAppDataBodyTwoAppOneNameMax)
              .describe(
                'Human-readable name for the resource. Between 1 and 256 characters.',
              ),
            status: zod
              .enum(['ready', 'unauthorized'])
              .describe('App installed status.')
              .describe('Status of the app connection.'),
            type: zod.enum(['sandbox']),
            updatedAt: zod.coerce
              .date()
              .describe('Timestamp of when the resource was last updated.'),
          })
          .describe(
            'Sandbox app can be used for testing OpenMeter features.\n\nThe app is not creating anything in external systems, thus it is safe to use for\nverifying OpenMeter features.',
          )
          .optional()
          .describe('The installed sandbox app this data belongs to.'),
        id: zod.coerce
          .string()
          .regex(upsertCustomerAppDataBodyTwoIdRegExp)
          .optional()
          .describe(
            'The app ID.\nIf not provided, it will use the global default for the app type.',
          ),
        type: zod.enum(['sandbox']),
      })
      .describe('Sandbox Customer App Data.'),
    zod
      .object({
        app: zod
          .object({
            createdAt: zod.coerce
              .date()
              .describe('Timestamp of when the resource was created.'),
            deletedAt: zod.coerce
              .date()
              .optional()
              .describe(
                'Timestamp of when the resource was permanently deleted.',
              ),
            description: zod.coerce
              .string()
              .max(upsertCustomerAppDataBodyThreeAppOneDescriptionMax)
              .optional()
              .describe(
                'Optional description of the resource. Maximum 1024 characters.',
              ),
            enableDraftSyncHook: zod.coerce
              .boolean()
              .describe(
                'Enable draft.sync hook.\n\nIf the hook is not enabled, the invoice will be progressed to the next state automatically.',
              ),
            enableIssuingSyncHook: zod.coerce
              .boolean()
              .describe(
                'Enable issuing.sync hook.\n\nIf the hook is not enabled, the invoice will be progressed to the next state automatically.',
              ),
            id: zod.coerce
              .string()
              .regex(upsertCustomerAppDataBodyThreeAppOneIdRegExp)
              .describe('A unique identifier for the resource.'),
            listing: zod
              .object({
                capabilities: zod
                  .array(
                    zod
                      .object({
                        description: zod.coerce
                          .string()
                          .describe('The capability description.'),
                        key: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            upsertCustomerAppDataBodyThreeAppOneListingOneCapabilitiesItemKeyMax,
                          )
                          .regex(
                            upsertCustomerAppDataBodyThreeAppOneListingOneCapabilitiesItemKeyRegExp,
                          )
                          .describe('Key'),
                        name: zod.coerce
                          .string()
                          .describe('The capability name.'),
                        type: zod
                          .enum([
                            'reportUsage',
                            'reportEvents',
                            'calculateTax',
                            'invoiceCustomers',
                            'collectPayments',
                          ])
                          .describe('App capability type.')
                          .describe('The capability type.'),
                      })
                      .describe(
                        "App capability.\n\nCapabilities only exist in config so they don't extend the Resource model.",
                      ),
                  )
                  .describe("The app's capabilities."),
                description: zod.coerce
                  .string()
                  .describe("The app's description."),
                installMethods: zod
                  .array(
                    zod
                      .enum([
                        'with_oauth2',
                        'with_api_key',
                        'no_credentials_required',
                      ])
                      .describe('Install method of the application.'),
                  )
                  .describe(
                    'Install methods.\n\nList of methods to install the app.',
                  ),
                name: zod.coerce.string().describe("The app's name."),
                type: zod
                  .enum(['stripe', 'sandbox', 'custom_invoicing'])
                  .describe('Type of the app.')
                  .describe("The app's type"),
              })
              .describe(
                "A marketplace listing.\nRepresent an available app in the app marketplace that can be installed to the organization.\n\nMarketplace apps only exist in config so they don't extend the Resource model.",
              )
              .describe(
                'The marketplace listing that this installed app is based on.',
              ),
            metadata: zod
              .record(zod.string(), zod.coerce.string())
              .describe(
                'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
              )
              .nullish()
              .describe('Additional metadata for the resource.'),
            name: zod.coerce
              .string()
              .min(1)
              .max(upsertCustomerAppDataBodyThreeAppOneNameMax)
              .describe(
                'Human-readable name for the resource. Between 1 and 256 characters.',
              ),
            status: zod
              .enum(['ready', 'unauthorized'])
              .describe('App installed status.')
              .describe('Status of the app connection.'),
            type: zod.enum(['custom_invoicing']),
            updatedAt: zod.coerce
              .date()
              .describe('Timestamp of when the resource was last updated.'),
          })
          .describe(
            'Custom Invoicing app can be used for interface with any invoicing or payment system.\n\nThis app provides ways to manipulate invoices and payments, however the integration\nmust rely on Notifications API to get notified about invoice changes.',
          )
          .optional()
          .describe('The installed custom invoicing app this data belongs to.'),
        id: zod.coerce
          .string()
          .regex(upsertCustomerAppDataBodyThreeIdRegExp)
          .optional()
          .describe(
            'The app ID.\nIf not provided, it will use the global default for the app type.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Metadata to be used by the custom invoicing provider.'),
        type: zod.enum(['custom_invoicing']),
      })
      .describe('Custom Invoicing Customer App Data.'),
  ])
  .describe(
    'CustomerAppData\nStores the app specific data for the customer.\nOne of: stripe, sandbox, custom_invoicing',
  )
export const UpsertCustomerAppDataBody = zod.array(
  UpsertCustomerAppDataBodyItem,
)

/**
 * Delete customer app data.
 * @summary Delete customer app data
 */
export const deleteCustomerAppDataPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const deleteCustomerAppDataPathCustomerIdOrKeyTwoMax = 256 as const

export const deleteCustomerAppDataPathAppIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeleteCustomerAppDataParams = zod.object({
  appId: zod.coerce.string().regex(deleteCustomerAppDataPathAppIdRegExp),
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(deleteCustomerAppDataPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(deleteCustomerAppDataPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

/**
 * Checks customer access to a given feature (by key). All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
 * @summary Get customer entitlement value
 */
export const getCustomerEntitlementValuePathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const getCustomerEntitlementValuePathCustomerIdOrKeyTwoMax = 256 as const

export const getCustomerEntitlementValuePathFeatureKeyMax = 64 as const

export const getCustomerEntitlementValuePathFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/

export const GetCustomerEntitlementValueParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(getCustomerEntitlementValuePathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(getCustomerEntitlementValuePathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
  featureKey: zod.coerce
    .string()
    .min(1)
    .max(getCustomerEntitlementValuePathFeatureKeyMax)
    .regex(getCustomerEntitlementValuePathFeatureKeyRegExp),
})

export const GetCustomerEntitlementValueQueryParams = zod.object({
  time: zod.coerce.date().optional(),
})

/**
 * Get stripe app data for a customer.
Only returns data if the customer billing profile is linked to a stripe app.
 * @summary Get customer stripe app data
 */
export const getCustomerStripeAppDataPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const getCustomerStripeAppDataPathCustomerIdOrKeyTwoMax = 256 as const

export const GetCustomerStripeAppDataParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(getCustomerStripeAppDataPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(getCustomerStripeAppDataPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

/**
 * Upsert stripe app data for a customer.
Only updates data if the customer billing profile is linked to a stripe app.
 * @summary Upsert customer stripe app data
 */
export const upsertCustomerStripeAppDataPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const upsertCustomerStripeAppDataPathCustomerIdOrKeyTwoMax = 256 as const

export const UpsertCustomerStripeAppDataParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(upsertCustomerStripeAppDataPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(upsertCustomerStripeAppDataPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

export const UpsertCustomerStripeAppDataBody = zod
  .object({
    stripeCustomerId: zod.coerce.string().describe('The Stripe customer ID.'),
    stripeDefaultPaymentMethodId: zod.coerce
      .string()
      .optional()
      .describe('The Stripe default payment method ID.'),
  })
  .describe('Stripe Customer App Data Base.')

/**
 * Create Stripe customer portal session.
Only returns URL if the customer billing profile is linked to a stripe app and customer.

Useful to redirect the customer to the Stripe customer portal to manage their payment methods,
change their billing address and access their invoice history.
 * @summary Create Stripe customer portal session
 */
export const createCustomerStripePortalSessionPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createCustomerStripePortalSessionPathCustomerIdOrKeyTwoMax =
  256 as const

export const CreateCustomerStripePortalSessionParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(createCustomerStripePortalSessionPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(createCustomerStripePortalSessionPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

export const CreateCustomerStripePortalSessionBody = zod
  .object({
    configurationId: zod.coerce
      .string()
      .optional()
      .describe(
        'The ID of an existing configuration to use for this session,\ndescribing its functionality and features.\nIf not specified, the session uses the default configuration.\n\nSee https://docs.stripe.com/api/customer_portal/sessions/create#create_portal_session-configuration',
      ),
    locale: zod.coerce
      .string()
      .optional()
      .describe(
        'The IETF language tag of the locale customer portal is displayed in.\nIf blank or auto, the customer‚Äôs preferred_locales or browser‚Äôs locale is used.\n\nSee: https://docs.stripe.com/api/customer_portal/sessions/create#create_portal_session-locale',
      ),
    returnUrl: zod.coerce
      .string()
      .optional()
      .describe(
        'The URL to redirect the customer to after they have completed\ntheir requested actions.\n\nSee: https://docs.stripe.com/api/customer_portal/sessions/create#create_portal_session-return_url',
      ),
  })
  .describe('Stripe customer portal request params.')

/**
 * Lists all subscriptions for a customer.
 * @summary List customer subscriptions
 */
export const listCustomerSubscriptionsPathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listCustomerSubscriptionsPathCustomerIdOrKeyTwoMax = 256 as const

export const ListCustomerSubscriptionsParams = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(listCustomerSubscriptionsPathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(listCustomerSubscriptionsPathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

export const listCustomerSubscriptionsQueryPageDefault = 1 as const

export const listCustomerSubscriptionsQueryPageSizeDefault = 100 as const
export const listCustomerSubscriptionsQueryPageSizeMax = 1000 as const

export const ListCustomerSubscriptionsQueryParams = zod.object({
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['activeFrom', 'activeTo'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listCustomerSubscriptionsQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listCustomerSubscriptionsQueryPageSizeMax)
    .default(listCustomerSubscriptionsQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
  status: zod
    .array(
      zod
        .enum(['active', 'inactive', 'canceled', 'scheduled'])
        .describe('Subscription status.'),
    )
    .optional(),
})

/**
 * List all entitlements for all the subjects and features. This endpoint is intended for administrative purposes only.
To fetch the entitlements of a specific subject please use the /api/v1/subjects/{subjectKeyOrID}/entitlements endpoint.
If page is provided that takes precedence and the paginated response is returned.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/entitlements`](#tag/entitlements/get/api/v2/entitlements) instead.
 * @deprecated
 * @summary List all entitlements
 */
export const listEntitlementsQueryExcludeInactiveDefault = false as const
export const listEntitlementsQueryPageDefault = 1 as const

export const listEntitlementsQueryPageSizeDefault = 100 as const
export const listEntitlementsQueryPageSizeMax = 1000 as const

export const listEntitlementsQueryOffsetDefault = 0 as const
export const listEntitlementsQueryOffsetMin = 0 as const

export const listEntitlementsQueryLimitDefault = 100 as const
export const listEntitlementsQueryLimitMax = 1000 as const

export const ListEntitlementsQueryParams = zod.object({
  entitlementType: zod
    .array(
      zod
        .enum(['metered', 'boolean', 'static'])
        .describe('Type of the entitlement.'),
    )
    .optional()
    .describe(
      'Filtering by multiple entitlement types.\n\nUsage: `?entitlementType=metered&entitlementType=boolean`',
    ),
  excludeInactive: zod.coerce
    .boolean()
    .default(listEntitlementsQueryExcludeInactiveDefault)
    .describe(
      'Exclude inactive entitlements in the response (those scheduled for later or earlier)',
    ),
  feature: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple features.\n\nUsage: `?feature=feature-1&feature=feature-2`',
    ),
  limit: zod.coerce
    .number()
    .min(1)
    .max(listEntitlementsQueryLimitMax)
    .default(listEntitlementsQueryLimitDefault)
    .describe('Number of items to return.\n\nDefault is 100.'),
  offset: zod.coerce
    .number()
    .min(listEntitlementsQueryOffsetMin)
    .default(listEntitlementsQueryOffsetDefault)
    .describe('Number of items to skip.\n\nDefault is 0.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['createdAt', 'updatedAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listEntitlementsQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listEntitlementsQueryPageSizeMax)
    .default(listEntitlementsQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
  subject: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple subjects.\n\nUsage: `?subject=customer-1&subject=customer-2`',
    ),
})

/**
 * Get entitlement by ID.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/entitlements/{entitlementId}`](#tag/entitlements/get/api/v2/entitlements/{entitlementId}) instead.
 * @deprecated
 * @summary Get entitlement by ID
 */
export const getEntitlementByIdPathEntitlementIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetEntitlementByIdParams = zod.object({
  entitlementId: zod.coerce
    .string()
    .regex(getEntitlementByIdPathEntitlementIdRegExp),
})

/**
 * List ingested events within a time range.

If the from query param is not provided it defaults to last 72 hours.
 * @summary List ingested events
 */
export const listEventsQueryClientIdMax = 36 as const

export const listEventsQueryCustomerIdItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listEventsQueryLimitDefault = 100 as const
export const listEventsQueryLimitMax = 100 as const

export const ListEventsQueryParams = zod.object({
  clientId: zod.coerce
    .string()
    .min(1)
    .max(listEventsQueryClientIdMax)
    .optional()
    .describe('Client ID\nUseful to track progress of a query.'),
  customerId: zod
    .array(
      zod.coerce
        .string()
        .regex(listEventsQueryCustomerIdItemRegExp)
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier).',
        ),
    )
    .optional()
    .describe('The event customer ID.'),
  from: zod.coerce
    .date()
    .optional()
    .describe('Start date-time in RFC 3339 format.\n\nInclusive.'),
  id: zod.coerce
    .string()
    .optional()
    .describe('The event ID.\n\nAccepts partial ID.'),
  ingestedAtFrom: zod.coerce
    .date()
    .optional()
    .describe('Start date-time in RFC 3339 format.\n\nInclusive.'),
  ingestedAtTo: zod.coerce
    .date()
    .optional()
    .describe('End date-time in RFC 3339 format.\n\nInclusive.'),
  limit: zod.coerce
    .number()
    .min(1)
    .max(listEventsQueryLimitMax)
    .default(listEventsQueryLimitDefault)
    .describe('Number of events to return.'),
  subject: zod.coerce
    .string()
    .optional()
    .describe('The event subject.\n\nAccepts partial subject.'),
  to: zod.coerce
    .date()
    .optional()
    .describe('End date-time in RFC 3339 format.\n\nInclusive.'),
})

/**
 * Ingests an event or batch of events following the CloudEvents specification.
 * @summary Ingest events
 */

export const ingestEventsBodyOneSpecversionDefault = '1.0' as const

export const ingestEventsBodyTwoItemSpecversionDefault = '1.0' as const

export const IngestEventsBody = zod
  .union([
    zod
      .object({
        data: zod
          .record(zod.string(), zod.unknown())
          .nullish()
          .describe(
            'The event payload.\nOptional, if present it must be a JSON object.',
          ),
        datacontenttype: zod
          .enum(['application/json'])
          .nullish()
          .describe(
            'Content type of the CloudEvents data value. Only the value "application/json" is allowed over HTTP.',
          ),
        dataschema: zod
          .url()
          .min(1)
          .nullish()
          .describe('Identifies the schema that data adheres to.'),
        id: zod.coerce.string().min(1).describe('Identifies the event.'),
        source: zod.coerce
          .string()
          .min(1)
          .describe('Identifies the context in which an event happened.'),
        specversion: zod.coerce
          .string()
          .min(1)
          .describe(
            'The version of the CloudEvents specification which the event uses.',
          ),
        subject: zod.coerce
          .string()
          .min(1)
          .describe(
            'Describes the subject of the event in the context of the event producer (identified by source).',
          ),
        time: zod.coerce
          .date()
          .nullish()
          .describe(
            'Timestamp of when the occurrence happened. Must adhere to RFC 3339.',
          ),
        type: zod.coerce
          .string()
          .min(1)
          .describe(
            'Contains a value describing the type of event related to the originating occurrence.',
          ),
      })
      .describe(
        'CloudEvents Specification JSON Schema\n\nOptional properties are nullable according to the CloudEvents specification:\nOPTIONAL not omitted attributes MAY be represented as a null JSON value.',
      ),
    zod.array(
      zod
        .object({
          data: zod
            .record(zod.string(), zod.unknown())
            .nullish()
            .describe(
              'The event payload.\nOptional, if present it must be a JSON object.',
            ),
          datacontenttype: zod
            .enum(['application/json'])
            .nullish()
            .describe(
              'Content type of the CloudEvents data value. Only the value "application/json" is allowed over HTTP.',
            ),
          dataschema: zod
            .url()
            .min(1)
            .nullish()
            .describe('Identifies the schema that data adheres to.'),
          id: zod.coerce.string().min(1).describe('Identifies the event.'),
          source: zod.coerce
            .string()
            .min(1)
            .describe('Identifies the context in which an event happened.'),
          specversion: zod.coerce
            .string()
            .min(1)
            .describe(
              'The version of the CloudEvents specification which the event uses.',
            ),
          subject: zod.coerce
            .string()
            .min(1)
            .describe(
              'Describes the subject of the event in the context of the event producer (identified by source).',
            ),
          time: zod.coerce
            .date()
            .nullish()
            .describe(
              'Timestamp of when the occurrence happened. Must adhere to RFC 3339.',
            ),
          type: zod.coerce
            .string()
            .min(1)
            .describe(
              'Contains a value describing the type of event related to the originating occurrence.',
            ),
        })
        .describe(
          'CloudEvents Specification JSON Schema\n\nOptional properties are nullable according to the CloudEvents specification:\nOPTIONAL not omitted attributes MAY be represented as a null JSON value.',
        ),
    ),
  ])
  .describe(
    'The body of the events request.\nEither a single event or a batch of events.',
  )

/**
 * List features.
 * @summary List features
 */
export const listFeaturesQueryIncludeArchivedDefault = false as const
export const listFeaturesQueryPageDefault = 1 as const

export const listFeaturesQueryPageSizeDefault = 100 as const
export const listFeaturesQueryPageSizeMax = 1000 as const

export const listFeaturesQueryOffsetDefault = 0 as const
export const listFeaturesQueryOffsetMin = 0 as const

export const listFeaturesQueryLimitDefault = 100 as const
export const listFeaturesQueryLimitMax = 1000 as const

export const ListFeaturesQueryParams = zod.object({
  includeArchived: zod.coerce
    .boolean()
    .default(listFeaturesQueryIncludeArchivedDefault)
    .describe('Include archived features in response.'),
  limit: zod.coerce
    .number()
    .min(1)
    .max(listFeaturesQueryLimitMax)
    .default(listFeaturesQueryLimitDefault)
    .describe('Number of items to return.\n\nDefault is 100.'),
  meterSlug: zod
    .array(zod.coerce.string())
    .optional()
    .describe('Filter by meterSlug'),
  offset: zod.coerce
    .number()
    .min(listFeaturesQueryOffsetMin)
    .default(listFeaturesQueryOffsetDefault)
    .describe('Number of items to skip.\n\nDefault is 0.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'key', 'name', 'createdAt', 'updatedAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listFeaturesQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listFeaturesQueryPageSizeMax)
    .default(listFeaturesQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * Features are either metered or static. A feature is metered if meterSlug is provided at creation.
For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter's groupBy fields.
Meters with SUM, COUNT, UNIQUE_COUNT and LATEST aggregations are supported for features.
Features cannot be updated later, only archived.
 * @summary Create feature
 */
export const createFeatureBodyKeyMax = 64 as const

export const createFeatureBodyKeyRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createFeatureBodyMeterSlugMax = 64 as const

export const createFeatureBodyMeterSlugRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/

export const CreateFeatureBody = zod
  .object({
    advancedMeterGroupByFilters: zod
      .record(
        zod.string(),
        zod
          .object({
            $and: zod
              .array(zod.unknown())
              .nullish()
              .describe(
                'Provide a list of filters to be combined with a logical AND.',
              ),
            $eq: zod.coerce
              .string()
              .nullish()
              .describe('The field must be equal to the provided value.'),
            $gt: zod.coerce
              .string()
              .nullish()
              .describe('The field must be greater than the provided value.'),
            $gte: zod.coerce
              .string()
              .nullish()
              .describe(
                'The field must be greater than or equal to the provided value.',
              ),
            $ilike: zod.coerce
              .string()
              .nullish()
              .describe(
                'The field must match the provided value, ignoring case.',
              ),
            $in: zod
              .array(zod.coerce.string())
              .nullish()
              .describe('The field must be in the provided list of values.'),
            $like: zod.coerce
              .string()
              .nullish()
              .describe('The field must match the provided value.'),
            $lt: zod.coerce
              .string()
              .nullish()
              .describe('The field must be less than the provided value.'),
            $lte: zod.coerce
              .string()
              .nullish()
              .describe(
                'The field must be less than or equal to the provided value.',
              ),
            $ne: zod.coerce
              .string()
              .nullish()
              .describe('The field must not be equal to the provided value.'),
            $nilike: zod.coerce
              .string()
              .nullish()
              .describe(
                'The field must not match the provided value, ignoring case.',
              ),
            $nin: zod
              .array(zod.coerce.string())
              .nullish()
              .describe(
                'The field must not be in the provided list of values.',
              ),
            $nlike: zod.coerce
              .string()
              .nullish()
              .describe('The field must not match the provided value.'),
            $or: zod
              .array(zod.unknown())
              .nullish()
              .describe(
                'Provide a list of filters to be combined with a logical OR.',
              ),
          })
          .describe('A filter for a string field.'),
      )
      .optional()
      .describe(
        'Optional advanced meter group by filters.\nYou can use this to filter for values of the meter groupBy fields.',
      ),
    key: zod.coerce
      .string()
      .min(1)
      .max(createFeatureBodyKeyMax)
      .regex(createFeatureBodyKeyRegExp)
      .describe(
        'A key is a unique string that is used to identify a resource.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .optional(),
    meterGroupByFilters: zod
      .record(zod.string(), zod.coerce.string())
      .optional()
      .describe(
        'Optional meter group by filters.\nUseful if the meter scope is broader than what feature tracks.\nExample scenario would be a meter tracking all token use with groupBy fields for the model,\nthen the feature could filter for model=gpt-4.\n\n‚ö†Ô∏è __Deprecated__: Use advancedMeterGroupByFilters instead',
      ),
    meterSlug: zod.coerce
      .string()
      .min(1)
      .max(createFeatureBodyMeterSlugMax)
      .regex(createFeatureBodyMeterSlugRegExp)
      .optional()
      .describe(
        'A key is a unique string that is used to identify a resource.',
      ),
    name: zod.coerce.string(),
  })
  .describe(
    'Represents a feature that can be enabled or disabled for a plan.\nUsed both for product catalog and entitlements.',
  )

/**
 * Get a feature by ID.
 * @summary Get feature
 */
export const GetFeatureParams = zod.object({
  featureId: zod.coerce.string(),
})

/**
 * Archive a feature by ID.

Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements.
This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis.
 * @summary Delete feature
 */
export const DeleteFeatureParams = zod.object({
  featureId: zod.coerce.string(),
})

/**
 * List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only.
To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.
If page is provided that takes precedence and the paginated response is returned.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/grants`](#tag/entitlements/get/api/v2/grants) instead.
 * @deprecated
 * @summary List grants
 */
export const listGrantsQueryIncludeDeletedDefault = false as const
export const listGrantsQueryPageDefault = 1 as const

export const listGrantsQueryPageSizeDefault = 100 as const
export const listGrantsQueryPageSizeMax = 1000 as const

export const listGrantsQueryOffsetDefault = 0 as const
export const listGrantsQueryOffsetMin = 0 as const

export const listGrantsQueryLimitDefault = 100 as const
export const listGrantsQueryLimitMax = 1000 as const

export const ListGrantsQueryParams = zod.object({
  feature: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple features.\n\nUsage: `?feature=feature-1&feature=feature-2`',
    ),
  includeDeleted: zod.coerce
    .boolean()
    .default(listGrantsQueryIncludeDeletedDefault)
    .describe('Include deleted'),
  limit: zod.coerce
    .number()
    .min(1)
    .max(listGrantsQueryLimitMax)
    .default(listGrantsQueryLimitDefault)
    .describe('Number of items to return.\n\nDefault is 100.'),
  offset: zod.coerce
    .number()
    .min(listGrantsQueryOffsetMin)
    .default(listGrantsQueryOffsetDefault)
    .describe('Number of items to skip.\n\nDefault is 0.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'createdAt', 'updatedAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listGrantsQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listGrantsQueryPageSizeMax)
    .default(listGrantsQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
  subject: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple subjects.\n\nUsage: `?subject=customer-1&subject=customer-2`',
    ),
})

/**
 * Voiding a grant means it is no longer valid, it doesn't take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.
For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected.
 * @summary Void grant
 */
export const VoidGrantParams = zod.object({
  grantId: zod.coerce.string(),
})

/**
 * Get progress
 * @summary Get progress
 */
export const GetProgressParams = zod.object({
  id: zod.coerce.string(),
})

/**
 * List available apps of the app marketplace.
 * @summary List available apps
 */
export const listMarketplaceListingsQueryPageDefault = 1 as const

export const listMarketplaceListingsQueryPageSizeDefault = 100 as const
export const listMarketplaceListingsQueryPageSizeMax = 1000 as const

export const ListMarketplaceListingsQueryParams = zod.object({
  page: zod.coerce
    .number()
    .min(1)
    .default(listMarketplaceListingsQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listMarketplaceListingsQueryPageSizeMax)
    .default(listMarketplaceListingsQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * Get a marketplace listing by type.
 * @summary Get app details by type
 */
export const GetMarketplaceListingParams = zod.object({
  type: zod.enum(['stripe', 'sandbox', 'custom_invoicing']),
})

/**
 * Install an app from the marketplace.
 * @summary Install app
 */
export const MarketplaceAppInstallParams = zod.object({
  type: zod
    .enum(['stripe', 'sandbox', 'custom_invoicing'])
    .describe('The type of the app to install.'),
})

export const marketplaceAppInstallBodyCreateBillingProfileDefault =
  true as const

export const MarketplaceAppInstallBody = zod
  .object({
    createBillingProfile: zod.coerce
      .boolean()
      .default(marketplaceAppInstallBodyCreateBillingProfileDefault)
      .describe(
        'If true, a billing profile will be created for the app.\nThe Stripe app will be also set as the default billing profile if the current default is a Sandbox app.',
      ),
    name: zod.coerce
      .string()
      .optional()
      .describe(
        "Name of the application to install.\n\nIf name is not provided defaults to the marketplace listing's name.",
      ),
  })
  .describe('Marketplace install request payload.')

/**
 * Install an marketplace app via API Key.
 * @summary Install app via API key
 */
export const MarketplaceAppAPIKeyInstallParams = zod.object({
  type: zod
    .enum(['stripe', 'sandbox', 'custom_invoicing'])
    .describe('The type of the app to install.'),
})

export const marketplaceAppAPIKeyInstallBodyCreateBillingProfileDefault =
  true as const

export const MarketplaceAppAPIKeyInstallBody = zod.object({
  apiKey: zod.coerce
    .string()
    .describe(
      'The API key for the provider.\nFor example, the Stripe API key.',
    ),
  createBillingProfile: zod.coerce
    .boolean()
    .default(marketplaceAppAPIKeyInstallBodyCreateBillingProfileDefault)
    .describe(
      'If true, a billing profile will be created for the app.\nThe Stripe app will be also set as the default billing profile if the current default is a Sandbox app.',
    ),
  name: zod.coerce
    .string()
    .optional()
    .describe(
      "Name of the application to install.\n\nIf name is not provided defaults to the marketplace listing's name.",
    ),
})

/**
 * Install an app via OAuth.
Returns a URL to start the OAuth 2.0 flow.
 * @summary Get OAuth2 install URL
 */
export const MarketplaceOAuth2InstallGetURLParams = zod.object({
  type: zod.enum(['stripe', 'sandbox', 'custom_invoicing']),
})

/**
 * Authorize OAuth2 code.
Verifies the OAuth code and exchanges it for a token and refresh token
 * @summary Install app via OAuth2
 */
export const MarketplaceOAuth2InstallAuthorizeParams = zod.object({
  type: zod
    .enum(['stripe', 'sandbox', 'custom_invoicing'])
    .describe('The type of the app to install.'),
})

export const MarketplaceOAuth2InstallAuthorizeQueryParams = zod.object({
  code: zod.coerce
    .string()
    .optional()
    .describe(
      'Authorization code which the client will later exchange for an access token.\nRequired with the success response.',
    ),
  error: zod
    .enum([
      'invalid_request',
      'unauthorized_client',
      'access_denied',
      'unsupported_response_type',
      'invalid_scope',
      'server_error',
      'temporarily_unavailable',
    ])
    .optional()
    .describe('Error code.\nRequired with the error response.'),
  error_description: zod.coerce
    .string()
    .optional()
    .describe(
      'Optional human-readable text providing additional information,\nused to assist the client developer in understanding the error that occurred.',
    ),
  error_uri: zod.coerce
    .string()
    .optional()
    .describe(
      'Optional uri identifying a human-readable web page with\ninformation about the error, used to provide the client\ndeveloper with additional information about the error',
    ),
  state: zod.coerce
    .string()
    .optional()
    .describe(
      'Required if the "state" parameter was present in the client authorization request.\nThe exact value received from the client:\n\nUnique, randomly generated, opaque, and non-guessable string that is sent\nwhen starting an authentication request and validated when processing the response.',
    ),
})

/**
 * List meters.
 * @summary List meters
 */
export const listMetersQueryPageDefault = 1 as const

export const listMetersQueryPageSizeDefault = 100 as const
export const listMetersQueryPageSizeMax = 1000 as const

export const listMetersQueryIncludeDeletedDefault = false as const

export const ListMetersQueryParams = zod.object({
  includeDeleted: zod.coerce
    .boolean()
    .default(listMetersQueryIncludeDeletedDefault)
    .describe('Include deleted meters.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['key', 'name', 'aggregation', 'createdAt', 'updatedAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listMetersQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listMetersQueryPageSizeMax)
    .default(listMetersQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * Create a meter.
 * @summary Create meter
 */
export const createMeterBodyDescriptionMax = 1024 as const

export const createMeterBodyNameMax = 256 as const

export const createMeterBodySlugMax = 64 as const

export const createMeterBodySlugRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/

export const CreateMeterBody = zod
  .object({
    aggregation: zod
      .enum(['SUM', 'COUNT', 'UNIQUE_COUNT', 'AVG', 'MIN', 'MAX', 'LATEST'])
      .describe('The aggregation type to use for the meter.')
      .describe('The aggregation type to use for the meter.'),
    description: zod.coerce
      .string()
      .max(createMeterBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    eventFrom: zod.coerce
      .date()
      .optional()
      .describe(
        'The date since the meter should include events.\nUseful to skip old events.\nIf not specified, all historical events are included.',
      ),
    eventType: zod.coerce
      .string()
      .min(1)
      .describe('The event type to aggregate.'),
    groupBy: zod
      .record(zod.string(), zod.coerce.string())
      .optional()
      .describe(
        'Named JSONPath expressions to extract the group by values from the event data.\n\nKeys must be unique and consist only alphanumeric and underscore characters.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(createMeterBodyNameMax)
      .optional()
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.\nDefaults to the slug if not specified.',
      ),
    slug: zod.coerce
      .string()
      .min(1)
      .max(createMeterBodySlugMax)
      .regex(createMeterBodySlugRegExp)
      .describe(
        'A unique, human-readable identifier for the meter.\nMust consist only alphanumeric and underscore characters.',
      ),
    valueProperty: zod.coerce
      .string()
      .min(1)
      .optional()
      .describe(
        "JSONPath expression to extract the value from the ingested event's data property.\n\nThe ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.\n\nFor UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.",
      ),
  })
  .describe('A meter create model.')

/**
 * Get a meter by ID or slug.
 * @summary Get meter
 */
export const getMeterPathMeterIdOrSlugMax = 64 as const

export const getMeterPathMeterIdOrSlugRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetMeterParams = zod.object({
  meterIdOrSlug: zod.coerce
    .string()
    .min(1)
    .max(getMeterPathMeterIdOrSlugMax)
    .regex(getMeterPathMeterIdOrSlugRegExp),
})

/**
 * Update a meter.
 * @summary Update meter
 */
export const updateMeterPathMeterIdOrSlugMax = 64 as const

export const updateMeterPathMeterIdOrSlugRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdateMeterParams = zod.object({
  meterIdOrSlug: zod.coerce
    .string()
    .min(1)
    .max(updateMeterPathMeterIdOrSlugMax)
    .regex(updateMeterPathMeterIdOrSlugRegExp),
})

export const updateMeterBodyDescriptionMax = 1024 as const

export const updateMeterBodyNameMax = 256 as const

export const UpdateMeterBody = zod
  .object({
    description: zod.coerce
      .string()
      .max(updateMeterBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    groupBy: zod
      .record(zod.string(), zod.coerce.string())
      .optional()
      .describe(
        'Named JSONPath expressions to extract the group by values from the event data.\n\nKeys must be unique and consist only alphanumeric and underscore characters.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(updateMeterBodyNameMax)
      .optional()
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.\nDefaults to the slug if not specified.',
      ),
  })
  .describe(
    'A meter update model.\n\nOnly the properties that can be updated are included.\nFor example, the slug and aggregation cannot be updated.',
  )

/**
 * Delete a meter.
 * @summary Delete meter
 */
export const deleteMeterPathMeterIdOrSlugMax = 64 as const

export const deleteMeterPathMeterIdOrSlugRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeleteMeterParams = zod.object({
  meterIdOrSlug: zod.coerce
    .string()
    .min(1)
    .max(deleteMeterPathMeterIdOrSlugMax)
    .regex(deleteMeterPathMeterIdOrSlugRegExp),
})

/**
 * List meter group by values.
 * @summary List meter group by values
 */
export const listMeterGroupByValuesPathMeterIdOrSlugMax = 64 as const

export const listMeterGroupByValuesPathMeterIdOrSlugRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ListMeterGroupByValuesParams = zod.object({
  groupByKey: zod.coerce.string(),
  meterIdOrSlug: zod.coerce
    .string()
    .min(1)
    .max(listMeterGroupByValuesPathMeterIdOrSlugMax)
    .regex(listMeterGroupByValuesPathMeterIdOrSlugRegExp),
})

export const ListMeterGroupByValuesQueryParams = zod.object({
  from: zod.coerce
    .date()
    .optional()
    .describe(
      'Start date-time in RFC 3339 format.\n\nInclusive. Defaults to 24 hours ago.\n\nFor example: ?from=2025-01-01T00%3A00%3A00.000Z',
    ),
  to: zod.coerce
    .date()
    .optional()
    .describe(
      'End date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?to=2025-02-01T00%3A00%3A00.000Z',
    ),
})

/**
 * Query meter for usage.
 * @summary Query meter
 */
export const queryMeterPathMeterIdOrSlugMax = 64 as const

export const queryMeterPathMeterIdOrSlugRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const QueryMeterParams = zod.object({
  meterIdOrSlug: zod.coerce
    .string()
    .min(1)
    .max(queryMeterPathMeterIdOrSlugMax)
    .regex(queryMeterPathMeterIdOrSlugRegExp),
})

export const queryMeterQueryClientIdMax = 36 as const

export const queryMeterQueryWindowTimeZoneDefault = 'UTC' as const
export const queryMeterQueryFilterCustomerIdMax = 100 as const

export const QueryMeterQueryParams = zod.object({
  clientId: zod.coerce
    .string()
    .min(1)
    .max(queryMeterQueryClientIdMax)
    .optional()
    .describe('Client ID\nUseful to track progress of a query.'),
  filterCustomerId: zod
    .array(zod.coerce.string())
    .max(queryMeterQueryFilterCustomerIdMax)
    .optional()
    .describe(
      'Filtering by multiple customers.\n\nFor example: ?filterCustomerId=customer-1&filterCustomerId=customer-2',
    ),
  filterGroupBy: zod
    .record(zod.string(), zod.coerce.string())
    .optional()
    .describe(
      'Simple filter for group bys with exact match.\n\nFor example: ?filterGroupBy[vendor]=openai&filterGroupBy[model]=gpt-4-turbo\n\n‚ö†Ô∏è __Deprecated__: Use `advancedMeterGroupByFilters` instead',
    ),
  from: zod.coerce
    .date()
    .optional()
    .describe(
      'Start date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?from=2025-01-01T00%3A00%3A00.000Z',
    ),
  groupBy: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'If not specified a single aggregate will be returned for each subject and time window.\n`subject` is a reserved group by value.\n\nFor example: ?groupBy=subject&groupBy=model',
    ),
  subject: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple subjects.\n\nFor example: ?subject=subject-1&subject=subject-2',
    ),
  to: zod.coerce
    .date()
    .optional()
    .describe(
      'End date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?to=2025-02-01T00%3A00%3A00.000Z',
    ),
  windowSize: zod
    .enum(['MINUTE', 'HOUR', 'DAY', 'MONTH'])
    .optional()
    .describe(
      'If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.\n\nFor example: ?windowSize=DAY',
    ),
  windowTimeZone: zod.coerce
    .string()
    .default(queryMeterQueryWindowTimeZoneDefault)
    .describe(
      'The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).\nIf not specified, the UTC timezone will be used.\n\nFor example: ?windowTimeZone=UTC',
    ),
})

/**
 * @summary Query meter
 */
export const queryMeterPostPathMeterIdOrSlugMax = 64 as const

export const queryMeterPostPathMeterIdOrSlugRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const QueryMeterPostParams = zod.object({
  meterIdOrSlug: zod.coerce
    .string()
    .min(1)
    .max(queryMeterPostPathMeterIdOrSlugMax)
    .regex(queryMeterPostPathMeterIdOrSlugRegExp),
})

export const queryMeterPostBodyClientIdMax = 36 as const

export const queryMeterPostBodyWindowTimeZoneDefault = 'UTC' as const
export const queryMeterPostBodySubjectMax = 100 as const

export const queryMeterPostBodyFilterCustomerIdMax = 100 as const

export const queryMeterPostBodyGroupByMax = 100 as const

export const QueryMeterPostBody = zod
  .object({
    advancedMeterGroupByFilters: zod
      .record(
        zod.string(),
        zod
          .object({
            $and: zod
              .array(zod.unknown())
              .nullish()
              .describe(
                'Provide a list of filters to be combined with a logical AND.',
              ),
            $eq: zod.coerce
              .string()
              .nullish()
              .describe('The field must be equal to the provided value.'),
            $gt: zod.coerce
              .string()
              .nullish()
              .describe('The field must be greater than the provided value.'),
            $gte: zod.coerce
              .string()
              .nullish()
              .describe(
                'The field must be greater than or equal to the provided value.',
              ),
            $ilike: zod.coerce
              .string()
              .nullish()
              .describe(
                'The field must match the provided value, ignoring case.',
              ),
            $in: zod
              .array(zod.coerce.string())
              .nullish()
              .describe('The field must be in the provided list of values.'),
            $like: zod.coerce
              .string()
              .nullish()
              .describe('The field must match the provided value.'),
            $lt: zod.coerce
              .string()
              .nullish()
              .describe('The field must be less than the provided value.'),
            $lte: zod.coerce
              .string()
              .nullish()
              .describe(
                'The field must be less than or equal to the provided value.',
              ),
            $ne: zod.coerce
              .string()
              .nullish()
              .describe('The field must not be equal to the provided value.'),
            $nilike: zod.coerce
              .string()
              .nullish()
              .describe(
                'The field must not match the provided value, ignoring case.',
              ),
            $nin: zod
              .array(zod.coerce.string())
              .nullish()
              .describe(
                'The field must not be in the provided list of values.',
              ),
            $nlike: zod.coerce
              .string()
              .nullish()
              .describe('The field must not match the provided value.'),
            $or: zod
              .array(zod.unknown())
              .nullish()
              .describe(
                'Provide a list of filters to be combined with a logical OR.',
              ),
          })
          .describe('A filter for a string field.'),
      )
      .optional()
      .describe(
        'Optional advanced meter group by filters.\nYou can use this to filter for values of the meter groupBy fields.',
      ),
    clientId: zod.coerce
      .string()
      .min(1)
      .max(queryMeterPostBodyClientIdMax)
      .optional()
      .describe('Client ID\nUseful to track progress of a query.'),
    filterCustomerId: zod
      .array(zod.coerce.string())
      .max(queryMeterPostBodyFilterCustomerIdMax)
      .optional()
      .describe('Filtering by multiple customers.'),
    filterGroupBy: zod
      .record(zod.string(), zod.array(zod.coerce.string()))
      .optional()
      .describe('Simple filter for group bys with exact match.'),
    from: zod.coerce
      .date()
      .optional()
      .describe('Start date-time in RFC 3339 format.\n\nInclusive.'),
    groupBy: zod
      .array(zod.coerce.string())
      .max(queryMeterPostBodyGroupByMax)
      .optional()
      .describe(
        'If not specified a single aggregate will be returned for each subject and time window.\n`subject` is a reserved group by value.',
      ),
    subject: zod
      .array(zod.coerce.string())
      .max(queryMeterPostBodySubjectMax)
      .optional()
      .describe('Filtering by multiple subjects.'),
    to: zod.coerce
      .date()
      .optional()
      .describe('End date-time in RFC 3339 format.\n\nInclusive.'),
    windowSize: zod
      .enum(['MINUTE', 'HOUR', 'DAY', 'MONTH'])
      .describe('Aggregation window size.')
      .optional()
      .describe(
        'If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.',
      ),
    windowTimeZone: zod.coerce
      .string()
      .default(queryMeterPostBodyWindowTimeZoneDefault)
      .describe(
        'The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).\nIf not specified, the UTC timezone will be used.',
      ),
  })
  .describe('A meter query request.')

/**
 * List subjects for a meter.
 * @summary List meter subjects
 */
export const listMeterSubjectsPathMeterIdOrSlugMax = 64 as const

export const listMeterSubjectsPathMeterIdOrSlugRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ListMeterSubjectsParams = zod.object({
  meterIdOrSlug: zod.coerce
    .string()
    .min(1)
    .max(listMeterSubjectsPathMeterIdOrSlugMax)
    .regex(listMeterSubjectsPathMeterIdOrSlugRegExp),
})

export const ListMeterSubjectsQueryParams = zod.object({
  from: zod.coerce
    .date()
    .optional()
    .describe(
      'Start date-time in RFC 3339 format.\n\nInclusive. Defaults to the beginning of time.\n\nFor example: ?from=2025-01-01T00%3A00%3A00.000Z',
    ),
  to: zod.coerce
    .date()
    .optional()
    .describe(
      'End date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?to=2025-02-01T00%3A00%3A00.000Z',
    ),
})

/**
 * List all notification channels.
 * @summary List notification channels
 */
export const listNotificationChannelsQueryIncludeDeletedDefault = false as const
export const listNotificationChannelsQueryIncludeDisabledDefault =
  false as const
export const listNotificationChannelsQueryPageDefault = 1 as const

export const listNotificationChannelsQueryPageSizeDefault = 100 as const
export const listNotificationChannelsQueryPageSizeMax = 1000 as const

export const ListNotificationChannelsQueryParams = zod.object({
  includeDeleted: zod.coerce
    .boolean()
    .default(listNotificationChannelsQueryIncludeDeletedDefault)
    .describe(
      'Include deleted notification channels in response.\n\nUsage: `?includeDeleted=true`',
    ),
  includeDisabled: zod.coerce
    .boolean()
    .default(listNotificationChannelsQueryIncludeDisabledDefault)
    .describe(
      'Include disabled notification channels in response.\n\nUsage: `?includeDisabled=false`',
    ),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'type', 'createdAt', 'updatedAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listNotificationChannelsQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listNotificationChannelsQueryPageSizeMax)
    .default(listNotificationChannelsQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * Create a new notification channel.
 * @summary Create a notification channel
 */
export const createNotificationChannelBodyOneNameMax = 256 as const

export const createNotificationChannelBodyOneDisabledDefault = false as const
export const createNotificationChannelBodyOneSigningSecretRegExp =
  /^(whsec_)?[a-zA-Z0-9+/=]{32,100}$/

export const CreateNotificationChannelBody = zod
  .object({
    customHeaders: zod
      .record(zod.string(), zod.coerce.string())
      .optional()
      .describe('Custom HTTP headers sent as part of the webhook request.'),
    disabled: zod.coerce
      .boolean()
      .default(createNotificationChannelBodyOneDisabledDefault)
      .describe('Whether the channel is disabled or not.'),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(createNotificationChannelBodyOneNameMax)
      .describe('User friendly name of the channel.'),
    signingSecret: zod.coerce
      .string()
      .regex(createNotificationChannelBodyOneSigningSecretRegExp)
      .optional()
      .describe(
        'Signing secret used for webhook request validation on the receiving end.\n\nFormat: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24',
      ),
    type: zod.enum(['WEBHOOK']).describe('Notification channel type.'),
    url: zod.coerce
      .string()
      .describe('Webhook URL where the notification is sent.'),
  })
  .describe(
    'Request with input parameters for creating new notification channel with webhook type.',
  )
  .describe(
    'Union type for requests creating new notification channel with certain type.',
  )

/**
 * Update notification channel.
 * @summary Update a notification channel
 */
export const updateNotificationChannelPathChannelIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdateNotificationChannelParams = zod.object({
  channelId: zod.coerce
    .string()
    .regex(updateNotificationChannelPathChannelIdRegExp),
})

export const updateNotificationChannelBodyOneNameMax = 256 as const

export const updateNotificationChannelBodyOneDisabledDefault = false as const
export const updateNotificationChannelBodyOneSigningSecretRegExp =
  /^(whsec_)?[a-zA-Z0-9+/=]{32,100}$/

export const UpdateNotificationChannelBody = zod
  .object({
    customHeaders: zod
      .record(zod.string(), zod.coerce.string())
      .optional()
      .describe('Custom HTTP headers sent as part of the webhook request.'),
    disabled: zod.coerce
      .boolean()
      .default(updateNotificationChannelBodyOneDisabledDefault)
      .describe('Whether the channel is disabled or not.'),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(updateNotificationChannelBodyOneNameMax)
      .describe('User friendly name of the channel.'),
    signingSecret: zod.coerce
      .string()
      .regex(updateNotificationChannelBodyOneSigningSecretRegExp)
      .optional()
      .describe(
        'Signing secret used for webhook request validation on the receiving end.\n\nFormat: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24',
      ),
    type: zod.enum(['WEBHOOK']).describe('Notification channel type.'),
    url: zod.coerce
      .string()
      .describe('Webhook URL where the notification is sent.'),
  })
  .describe(
    'Request with input parameters for creating new notification channel with webhook type.',
  )
  .describe(
    'Union type for requests creating new notification channel with certain type.',
  )

/**
 * Get a notification channel by id.
 * @summary Get notification channel
 */
export const getNotificationChannelPathChannelIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetNotificationChannelParams = zod.object({
  channelId: zod.coerce
    .string()
    .regex(getNotificationChannelPathChannelIdRegExp),
})

/**
 * Soft delete notification channel by id.

Once a notification channel is deleted it cannot be undeleted.
 * @summary Delete a notification channel
 */
export const deleteNotificationChannelPathChannelIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeleteNotificationChannelParams = zod.object({
  channelId: zod.coerce
    .string()
    .regex(deleteNotificationChannelPathChannelIdRegExp),
})

/**
 * List all notification events.
 * @summary List notification events
 */
export const listNotificationEventsQueryRuleItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listNotificationEventsQueryChannelItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listNotificationEventsQueryPageDefault = 1 as const

export const listNotificationEventsQueryPageSizeDefault = 100 as const
export const listNotificationEventsQueryPageSizeMax = 1000 as const

export const ListNotificationEventsQueryParams = zod.object({
  channel: zod
    .array(
      zod.coerce
        .string()
        .regex(listNotificationEventsQueryChannelItemRegExp)
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier).',
        ),
    )
    .optional()
    .describe(
      'Filtering by multiple channel ids.\n\nUsage: `?channel=01J8J4RXH778XB056JS088PCYT&channel=01J8J4S1R1G9EVN62RG23A9M6J`',
    ),
  feature: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple feature ids or keys.\n\nUsage: `?feature=feature-1&feature=feature-2`',
    ),
  from: zod.coerce
    .date()
    .optional()
    .describe('Start date-time in RFC 3339 format.\nInclusive.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'createdAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listNotificationEventsQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listNotificationEventsQueryPageSizeMax)
    .default(listNotificationEventsQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
  rule: zod
    .array(
      zod.coerce
        .string()
        .regex(listNotificationEventsQueryRuleItemRegExp)
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier).',
        ),
    )
    .optional()
    .describe(
      'Filtering by multiple rule ids.\n\nUsage: `?rule=01J8J2XYZ2N5WBYK09EDZFBSZM&rule=01J8J4R4VZH180KRKQ63NB2VA5`',
    ),
  subject: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple subject ids or keys.\n\nUsage: `?subject=subject-1&subject=subject-2`',
    ),
  to: zod.coerce
    .date()
    .optional()
    .describe('End date-time in RFC 3339 format.\nInclusive.'),
})

/**
 * Get a notification event by id.
 * @summary Get notification event
 */
export const GetNotificationEventParams = zod.object({
  eventId: zod.coerce.string(),
})

/**
 * @summary Re-send notification event
 */
export const resendNotificationEventPathEventIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ResendNotificationEventParams = zod.object({
  eventId: zod.coerce.string().regex(resendNotificationEventPathEventIdRegExp),
})

export const resendNotificationEventBodyChannelsItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ResendNotificationEventBody = zod
  .object({
    channels: zod
      .array(
        zod.coerce
          .string()
          .regex(resendNotificationEventBodyChannelsItemRegExp)
          .describe(
            'ULID (Universally Unique Lexicographically Sortable Identifier).',
          ),
      )
      .optional()
      .describe('Notification channels to which the event should be re-sent.'),
  })
  .describe('A notification event that will be re-sent.')

/**
 * List all notification rules.
 * @summary List notification rules
 */
export const listNotificationRulesQueryIncludeDeletedDefault = false as const
export const listNotificationRulesQueryIncludeDisabledDefault = false as const
export const listNotificationRulesQueryFeatureItemMax = 64 as const

export const listNotificationRulesQueryFeatureItemRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listNotificationRulesQueryPageDefault = 1 as const

export const listNotificationRulesQueryPageSizeDefault = 100 as const
export const listNotificationRulesQueryPageSizeMax = 1000 as const

export const ListNotificationRulesQueryParams = zod.object({
  channel: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple notifiaction channel ids.\n\nUsage: `?channel=01ARZ3NDEKTSV4RRFFQ69G5FAV&channel=01J8J2Y5X4NNGQS32CF81W95E3`',
    ),
  feature: zod
    .array(
      zod.coerce
        .string()
        .min(1)
        .max(listNotificationRulesQueryFeatureItemMax)
        .regex(listNotificationRulesQueryFeatureItemRegExp)
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier).\nA key is a unique string that is used to identify a resource.\n\nTODO: this is a temporary solution to support both ULID and Key in the same spec for codegen.',
        ),
    )
    .optional()
    .describe(
      'Filtering by multiple feature ids/keys.\n\nUsage: `?feature=feature-1&feature=feature-2`',
    ),
  includeDeleted: zod.coerce
    .boolean()
    .default(listNotificationRulesQueryIncludeDeletedDefault)
    .describe(
      'Include deleted notification rules in response.\n\nUsage: `?includeDeleted=true`',
    ),
  includeDisabled: zod.coerce
    .boolean()
    .default(listNotificationRulesQueryIncludeDisabledDefault)
    .describe(
      'Include disabled notification rules in response.\n\nUsage: `?includeDisabled=false`',
    ),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'type', 'createdAt', 'updatedAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listNotificationRulesQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listNotificationRulesQueryPageSizeMax)
    .default(listNotificationRulesQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * Create a new notification rule.
 * @summary Create a notification rule
 */
export const createNotificationRuleBodyOneNameMax = 256 as const

export const createNotificationRuleBodyOneDisabledDefault = false as const
export const createNotificationRuleBodyOneThresholdsMax = 10 as const

export const createNotificationRuleBodyOneChannelsItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const createNotificationRuleBodyOneFeaturesItemMax = 64 as const

export const createNotificationRuleBodyOneFeaturesItemRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const createNotificationRuleBodyTwoNameMax = 256 as const

export const createNotificationRuleBodyTwoDisabledDefault = false as const
export const createNotificationRuleBodyTwoChannelsItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const createNotificationRuleBodyTwoFeaturesItemMax = 64 as const

export const createNotificationRuleBodyTwoFeaturesItemRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const createNotificationRuleBodyThreeNameMax = 256 as const

export const createNotificationRuleBodyThreeDisabledDefault = false as const
export const createNotificationRuleBodyThreeChannelsItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const createNotificationRuleBodyFourNameMax = 256 as const

export const createNotificationRuleBodyFourDisabledDefault = false as const
export const createNotificationRuleBodyFourChannelsItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const CreateNotificationRuleBody = zod
  .union([
    zod
      .object({
        channels: zod
          .array(
            zod.coerce
              .string()
              .regex(createNotificationRuleBodyOneChannelsItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).',
              ),
          )
          .min(1)
          .describe('List of notification channels the rule is applied to.'),
        disabled: zod.coerce
          .boolean()
          .default(createNotificationRuleBodyOneDisabledDefault)
          .describe('Whether the rule is disabled or not.'),
        features: zod
          .array(
            zod.coerce
              .string()
              .min(1)
              .max(createNotificationRuleBodyOneFeaturesItemMax)
              .regex(createNotificationRuleBodyOneFeaturesItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).\nA key is a unique string that is used to identify a resource.\n\nTODO: this is a temporary solution to support both ULID and Key in the same spec for codegen.',
              ),
          )
          .min(1)
          .optional()
          .describe(
            'Optional field for defining the scope of notification by feature. It may contain features by id or key.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(createNotificationRuleBodyOneNameMax)
          .describe('The user friendly name of the notification rule.'),
        thresholds: zod
          .array(
            zod
              .object({
                type: zod
                  .enum([
                    'PERCENT',
                    'NUMBER',
                    'balance_value',
                    'usage_percentage',
                    'usage_value',
                  ])
                  .describe(
                    'Type of the rule in the balance threshold specification:\n* `balance_value`: threshold defined by the remaining balance value based on usage and the total of grants in the current usage period\n* `usage_percentage`: threshold defined by the usage percentage compared to the total of grants in the current usage period\n* `usage_value`: threshold defined by the usage value in the current usage period\n* `NUMBER` (**deprecated**): see `usage_value`\n* `PERCENT` (**deprecated**): see `usage_percentage`',
                  )
                  .describe('Type of the threshold.'),
                value: zod.coerce.number().describe('Value of the threshold.'),
              })
              .describe('Threshold value with multiple supported types.'),
          )
          .min(1)
          .max(createNotificationRuleBodyOneThresholdsMax)
          .describe('List of thresholds the rule suppose to be triggered.'),
        type: zod.enum(['entitlements.balance.threshold']),
      })
      .describe(
        'Request with input parameters for creating new notification rule with entitlements.balance.threshold type.',
      ),
    zod
      .object({
        channels: zod
          .array(
            zod.coerce
              .string()
              .regex(createNotificationRuleBodyTwoChannelsItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).',
              ),
          )
          .min(1)
          .describe('List of notification channels the rule is applied to.'),
        disabled: zod.coerce
          .boolean()
          .default(createNotificationRuleBodyTwoDisabledDefault)
          .describe('Whether the rule is disabled or not.'),
        features: zod
          .array(
            zod.coerce
              .string()
              .min(1)
              .max(createNotificationRuleBodyTwoFeaturesItemMax)
              .regex(createNotificationRuleBodyTwoFeaturesItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).\nA key is a unique string that is used to identify a resource.\n\nTODO: this is a temporary solution to support both ULID and Key in the same spec for codegen.',
              ),
          )
          .min(1)
          .optional()
          .describe(
            'Optional field for defining the scope of notification by feature. It may contain features by id or key.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(createNotificationRuleBodyTwoNameMax)
          .describe('The user friendly name of the notification rule.'),
        type: zod.enum(['entitlements.reset']),
      })
      .describe(
        'Request with input parameters for creating new notification rule with entitlements.reset type.',
      ),
    zod
      .object({
        channels: zod
          .array(
            zod.coerce
              .string()
              .regex(createNotificationRuleBodyThreeChannelsItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).',
              ),
          )
          .min(1)
          .describe('List of notification channels the rule is applied to.'),
        disabled: zod.coerce
          .boolean()
          .default(createNotificationRuleBodyThreeDisabledDefault)
          .describe('Whether the rule is disabled or not.'),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(createNotificationRuleBodyThreeNameMax)
          .describe('The user friendly name of the notification rule.'),
        type: zod.enum(['invoice.created']),
      })
      .describe(
        'Request with input parameters for creating new notification rule with invoice.created type.',
      ),
    zod
      .object({
        channels: zod
          .array(
            zod.coerce
              .string()
              .regex(createNotificationRuleBodyFourChannelsItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).',
              ),
          )
          .min(1)
          .describe('List of notification channels the rule is applied to.'),
        disabled: zod.coerce
          .boolean()
          .default(createNotificationRuleBodyFourDisabledDefault)
          .describe('Whether the rule is disabled or not.'),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(createNotificationRuleBodyFourNameMax)
          .describe('The user friendly name of the notification rule.'),
        type: zod.enum(['invoice.updated']),
      })
      .describe(
        'Request with input parameters for creating new notification rule with invoice.updated  type.',
      ),
  ])
  .describe(
    'Union type for requests creating new notification rule with certain type.',
  )

/**
 * Update notification rule.
 * @summary Update a notification rule
 */
export const updateNotificationRulePathRuleIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdateNotificationRuleParams = zod.object({
  ruleId: zod.coerce.string().regex(updateNotificationRulePathRuleIdRegExp),
})

export const updateNotificationRuleBodyOneNameMax = 256 as const

export const updateNotificationRuleBodyOneDisabledDefault = false as const
export const updateNotificationRuleBodyOneThresholdsMax = 10 as const

export const updateNotificationRuleBodyOneChannelsItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const updateNotificationRuleBodyOneFeaturesItemMax = 64 as const

export const updateNotificationRuleBodyOneFeaturesItemRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const updateNotificationRuleBodyTwoNameMax = 256 as const

export const updateNotificationRuleBodyTwoDisabledDefault = false as const
export const updateNotificationRuleBodyTwoChannelsItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const updateNotificationRuleBodyTwoFeaturesItemMax = 64 as const

export const updateNotificationRuleBodyTwoFeaturesItemRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const updateNotificationRuleBodyThreeNameMax = 256 as const

export const updateNotificationRuleBodyThreeDisabledDefault = false as const
export const updateNotificationRuleBodyThreeChannelsItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const updateNotificationRuleBodyFourNameMax = 256 as const

export const updateNotificationRuleBodyFourDisabledDefault = false as const
export const updateNotificationRuleBodyFourChannelsItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdateNotificationRuleBody = zod
  .union([
    zod
      .object({
        channels: zod
          .array(
            zod.coerce
              .string()
              .regex(updateNotificationRuleBodyOneChannelsItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).',
              ),
          )
          .min(1)
          .describe('List of notification channels the rule is applied to.'),
        disabled: zod.coerce
          .boolean()
          .default(updateNotificationRuleBodyOneDisabledDefault)
          .describe('Whether the rule is disabled or not.'),
        features: zod
          .array(
            zod.coerce
              .string()
              .min(1)
              .max(updateNotificationRuleBodyOneFeaturesItemMax)
              .regex(updateNotificationRuleBodyOneFeaturesItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).\nA key is a unique string that is used to identify a resource.\n\nTODO: this is a temporary solution to support both ULID and Key in the same spec for codegen.',
              ),
          )
          .min(1)
          .optional()
          .describe(
            'Optional field for defining the scope of notification by feature. It may contain features by id or key.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(updateNotificationRuleBodyOneNameMax)
          .describe('The user friendly name of the notification rule.'),
        thresholds: zod
          .array(
            zod
              .object({
                type: zod
                  .enum([
                    'PERCENT',
                    'NUMBER',
                    'balance_value',
                    'usage_percentage',
                    'usage_value',
                  ])
                  .describe(
                    'Type of the rule in the balance threshold specification:\n* `balance_value`: threshold defined by the remaining balance value based on usage and the total of grants in the current usage period\n* `usage_percentage`: threshold defined by the usage percentage compared to the total of grants in the current usage period\n* `usage_value`: threshold defined by the usage value in the current usage period\n* `NUMBER` (**deprecated**): see `usage_value`\n* `PERCENT` (**deprecated**): see `usage_percentage`',
                  )
                  .describe('Type of the threshold.'),
                value: zod.coerce.number().describe('Value of the threshold.'),
              })
              .describe('Threshold value with multiple supported types.'),
          )
          .min(1)
          .max(updateNotificationRuleBodyOneThresholdsMax)
          .describe('List of thresholds the rule suppose to be triggered.'),
        type: zod.enum(['entitlements.balance.threshold']),
      })
      .describe(
        'Request with input parameters for creating new notification rule with entitlements.balance.threshold type.',
      ),
    zod
      .object({
        channels: zod
          .array(
            zod.coerce
              .string()
              .regex(updateNotificationRuleBodyTwoChannelsItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).',
              ),
          )
          .min(1)
          .describe('List of notification channels the rule is applied to.'),
        disabled: zod.coerce
          .boolean()
          .default(updateNotificationRuleBodyTwoDisabledDefault)
          .describe('Whether the rule is disabled or not.'),
        features: zod
          .array(
            zod.coerce
              .string()
              .min(1)
              .max(updateNotificationRuleBodyTwoFeaturesItemMax)
              .regex(updateNotificationRuleBodyTwoFeaturesItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).\nA key is a unique string that is used to identify a resource.\n\nTODO: this is a temporary solution to support both ULID and Key in the same spec for codegen.',
              ),
          )
          .min(1)
          .optional()
          .describe(
            'Optional field for defining the scope of notification by feature. It may contain features by id or key.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(updateNotificationRuleBodyTwoNameMax)
          .describe('The user friendly name of the notification rule.'),
        type: zod.enum(['entitlements.reset']),
      })
      .describe(
        'Request with input parameters for creating new notification rule with entitlements.reset type.',
      ),
    zod
      .object({
        channels: zod
          .array(
            zod.coerce
              .string()
              .regex(updateNotificationRuleBodyThreeChannelsItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).',
              ),
          )
          .min(1)
          .describe('List of notification channels the rule is applied to.'),
        disabled: zod.coerce
          .boolean()
          .default(updateNotificationRuleBodyThreeDisabledDefault)
          .describe('Whether the rule is disabled or not.'),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(updateNotificationRuleBodyThreeNameMax)
          .describe('The user friendly name of the notification rule.'),
        type: zod.enum(['invoice.created']),
      })
      .describe(
        'Request with input parameters for creating new notification rule with invoice.created type.',
      ),
    zod
      .object({
        channels: zod
          .array(
            zod.coerce
              .string()
              .regex(updateNotificationRuleBodyFourChannelsItemRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).',
              ),
          )
          .min(1)
          .describe('List of notification channels the rule is applied to.'),
        disabled: zod.coerce
          .boolean()
          .default(updateNotificationRuleBodyFourDisabledDefault)
          .describe('Whether the rule is disabled or not.'),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .nullish()
          .describe('Additional metadata for the resource.'),
        name: zod.coerce
          .string()
          .min(1)
          .max(updateNotificationRuleBodyFourNameMax)
          .describe('The user friendly name of the notification rule.'),
        type: zod.enum(['invoice.updated']),
      })
      .describe(
        'Request with input parameters for creating new notification rule with invoice.updated  type.',
      ),
  ])
  .describe(
    'Union type for requests creating new notification rule with certain type.',
  )

/**
 * Get a notification rule by id.
 * @summary Get notification rule
 */
export const getNotificationRulePathRuleIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetNotificationRuleParams = zod.object({
  ruleId: zod.coerce.string().regex(getNotificationRulePathRuleIdRegExp),
})

/**
 * Soft delete notification rule by id.

Once a notification rule is deleted it cannot be undeleted.
 * @summary Delete a notification rule
 */
export const deleteNotificationRulePathRuleIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeleteNotificationRuleParams = zod.object({
  ruleId: zod.coerce.string().regex(deleteNotificationRulePathRuleIdRegExp),
})

/**
 * Test a notification rule by sending a test event with random data.
 * @summary Test notification rule
 */
export const testNotificationRulePathRuleIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const TestNotificationRuleParams = zod.object({
  ruleId: zod.coerce.string().regex(testNotificationRulePathRuleIdRegExp),
})

/**
 * List all plans.
 * @summary List plans
 */
export const listPlansQueryIncludeDeletedDefault = false as const
export const listPlansQueryIdItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listPlansQueryKeyItemMax = 64 as const

export const listPlansQueryKeyItemRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const listPlansQueryCurrencyItemMin = 3 as const
export const listPlansQueryCurrencyItemMax = 3 as const

export const listPlansQueryCurrencyItemRegExp = /^[A-Z]{3}$/
export const listPlansQueryPageDefault = 1 as const

export const listPlansQueryPageSizeDefault = 100 as const
export const listPlansQueryPageSizeMax = 1000 as const

export const ListPlansQueryParams = zod.object({
  currency: zod
    .array(
      zod.coerce
        .string()
        .min(listPlansQueryCurrencyItemMin)
        .max(listPlansQueryCurrencyItemMax)
        .regex(listPlansQueryCurrencyItemRegExp)
        .describe(
          'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
        ),
    )
    .optional()
    .describe('Filter by plan.currency attribute'),
  id: zod
    .array(
      zod.coerce
        .string()
        .regex(listPlansQueryIdItemRegExp)
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier).',
        ),
    )
    .optional()
    .describe('Filter by plan.id attribute'),
  includeDeleted: zod.coerce
    .boolean()
    .default(listPlansQueryIncludeDeletedDefault)
    .describe(
      'Include deleted plans in response.\n\nUsage: `?includeDeleted=true`',
    ),
  key: zod
    .array(
      zod.coerce
        .string()
        .min(1)
        .max(listPlansQueryKeyItemMax)
        .regex(listPlansQueryKeyItemRegExp)
        .describe(
          'A key is a unique string that is used to identify a resource.',
        ),
    )
    .optional()
    .describe('Filter by plan.key attribute'),
  keyVersion: zod
    .record(zod.string(), zod.array(zod.coerce.number()))
    .optional()
    .describe('Filter by plan.key and plan.version attributes'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'key', 'version', 'created_at', 'updated_at'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listPlansQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listPlansQueryPageSizeMax)
    .default(listPlansQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
  status: zod
    .array(
      zod
        .enum(['draft', 'active', 'archived', 'scheduled'])
        .describe('The status of a plan.'),
    )
    .optional()
    .describe(
      'Only return plans with the given status.\n\nUsage:\n- `?status=active`: return only the currently active plan\n- `?status=draft`: return only the draft plan\n- `?status=archived`: return only the archived plans',
    ),
})

/**
 * Create a new plan.
 * @summary Create a plan
 */
export const createPlanBodyNameMax = 256 as const

export const createPlanBodyDescriptionMax = 1024 as const

export const createPlanBodyKeyMax = 64 as const

export const createPlanBodyKeyRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createPlanBodyCurrencyOneMin = 3 as const
export const createPlanBodyCurrencyOneMax = 3 as const

export const createPlanBodyCurrencyOneRegExp = /^[A-Z]{3}$/
export const createPlanBodyCurrencyDefault = 'USD' as const
export const createPlanBodyProRatingConfigOneEnabledDefault = true as const
export const createPlanBodyProRatingConfigOneModeDefault =
  'prorate_prices' as const
export const createPlanBodyProRatingConfigDefault = {
  enabled: true,
  mode: 'prorate_prices',
} as const
export const createPlanBodyPhasesItemKeyMax = 64 as const

export const createPlanBodyPhasesItemKeyRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createPlanBodyPhasesItemNameMax = 256 as const

export const createPlanBodyPhasesItemDescriptionMax = 1024 as const

export const createPlanBodyPhasesItemRateCardsItemOneKeyMax = 64 as const

export const createPlanBodyPhasesItemRateCardsItemOneKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createPlanBodyPhasesItemRateCardsItemOneNameMax = 256 as const

export const createPlanBodyPhasesItemRateCardsItemOneDescriptionMax =
  1024 as const

export const createPlanBodyPhasesItemRateCardsItemOneFeatureKeyMax = 64 as const

export const createPlanBodyPhasesItemRateCardsItemOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const createPlanBodyPhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const createPlanBodyPhasesItemRateCardsItemOnePriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemOnePriceOnePaymentTermDefault =
  'in_advance' as const
export const createPlanBodyPhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoKeyMax = 64 as const

export const createPlanBodyPhasesItemRateCardsItemTwoKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createPlanBodyPhasesItemRateCardsItemTwoNameMax = 256 as const

export const createPlanBodyPhasesItemRateCardsItemTwoDescriptionMax =
  1024 as const

export const createPlanBodyPhasesItemRateCardsItemTwoFeatureKeyMax = 64 as const

export const createPlanBodyPhasesItemRateCardsItemTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const createPlanBodyPhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault =
  'in_advance' as const
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault =
  '1' as const
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createPlanBodyPhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const CreatePlanBody = zod
  .object({
    alignment: zod
      .object({
        billablesMustAlign: zod.coerce
          .boolean()
          .optional()
          .describe(
            "Whether all Billable items and RateCards must align.\nAlignment means the Price's BillingCadence must align for both duration and anchor time.",
          ),
      })
      .describe('Alignment configuration for a plan or subscription.')
      .optional()
      .describe('Alignment configuration for the plan.'),
    billingCadence: zod.coerce
      .string()
      .describe(
        'The default billing cadence for subscriptions using this plan.\nDefines how often customers are billed using ISO8601 duration format.\nExamples: "P1M" (monthly), "P3M" (quarterly), "P1Y" (annually).',
      ),
    currency: zod.coerce
      .string()
      .min(createPlanBodyCurrencyOneMin)
      .max(createPlanBodyCurrencyOneMax)
      .regex(createPlanBodyCurrencyOneRegExp)
      .describe(
        'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
      )
      .describe('The currency code of the plan.'),
    description: zod.coerce
      .string()
      .max(createPlanBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    key: zod.coerce
      .string()
      .min(1)
      .max(createPlanBodyKeyMax)
      .regex(createPlanBodyKeyRegExp)
      .describe('A semi-unique identifier for the resource.'),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(createPlanBodyNameMax)
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.',
      ),
    phases: zod
      .array(
        zod
          .object({
            description: zod.coerce
              .string()
              .max(createPlanBodyPhasesItemDescriptionMax)
              .optional()
              .describe(
                'Optional description of the resource. Maximum 1024 characters.',
              ),
            duration: zod.coerce
              .string()
              .nullable()
              .describe('The duration of the phase.'),
            key: zod.coerce
              .string()
              .min(1)
              .max(createPlanBodyPhasesItemKeyMax)
              .regex(createPlanBodyPhasesItemKeyRegExp)
              .describe('A semi-unique identifier for the resource.'),
            metadata: zod
              .record(zod.string(), zod.coerce.string())
              .describe(
                'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
              )
              .nullish()
              .describe('Additional metadata for the resource.'),
            name: zod.coerce
              .string()
              .min(1)
              .max(createPlanBodyPhasesItemNameMax)
              .describe(
                'Human-readable name for the resource. Between 1 and 256 characters.',
              ),
            rateCards: zod
              .array(
                zod
                  .union([
                    zod
                      .object({
                        billingCadence: zod.coerce
                          .string()
                          .nullable()
                          .describe(
                            'The billing cadence of the rate card.\nWhen null it means it is a one time fee.',
                          ),
                        description: zod.coerce
                          .string()
                          .max(
                            createPlanBodyPhasesItemRateCardsItemOneDescriptionMax,
                          )
                          .optional()
                          .describe(
                            'Optional description of the resource. Maximum 1024 characters.',
                          ),
                        discounts: zod
                          .object({
                            percentage: zod
                              .object({
                                percentage: zod.coerce
                                  .number()
                                  .describe(
                                    'Numeric representation of a percentage\n\n50% is represented as 50',
                                  )
                                  .describe('The percentage of the discount.'),
                              })
                              .describe('Percentage discount.')
                              .optional()
                              .describe('The percentage discount.'),
                            usage: zod
                              .object({
                                quantity: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe(
                                    'The quantity of the usage discount.\n\nMust be positive.',
                                  ),
                              })
                              .describe(
                                'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                              )
                              .optional()
                              .describe('The usage discount.'),
                          })
                          .describe('Discount by type on a price')
                          .optional()
                          .describe(
                            'The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.',
                          ),
                        entitlementTemplate: zod
                          .union([
                            zod
                              .object({
                                isSoftLimit: zod.coerce
                                  .boolean()
                                  .default(
                                    createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault,
                                  )
                                  .describe(
                                    'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                                  ),
                                issueAfterReset: zod.coerce
                                  .number()
                                  .min(
                                    createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin,
                                  )
                                  .optional()
                                  .describe(
                                    'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                                  ),
                                issueAfterResetPriority: zod.coerce
                                  .number()
                                  .min(1)
                                  .max(
                                    createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                                  )
                                  .default(
                                    createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                                  )
                                  .describe(
                                    'Defines the grant priority for the default grant.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                preserveOverageAtReset: zod.coerce
                                  .boolean()
                                  .default(
                                    createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                                  )
                                  .describe(
                                    'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                                  ),
                                type: zod.enum(['metered']),
                                usagePeriod: zod.coerce
                                  .string()
                                  .optional()
                                  .describe(
                                    'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                                  ),
                              })
                              .describe(
                                'The entitlement template with a metered entitlement.',
                              ),
                            zod
                              .object({
                                config: zod.coerce
                                  .string()
                                  .describe(
                                    'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['static']),
                              })
                              .describe(
                                'Entitlement template of a static entitlement.',
                              ),
                            zod
                              .object({
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['boolean']),
                              })
                              .describe(
                                'Entitlement template of a boolean entitlement.',
                              ),
                          ])
                          .describe(
                            'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                          )
                          .optional()
                          .describe(
                            'The entitlement of the rate card.\nOnly available when featureKey is set.',
                          ),
                        featureKey: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            createPlanBodyPhasesItemRateCardsItemOneFeatureKeyMax,
                          )
                          .regex(
                            createPlanBodyPhasesItemRateCardsItemOneFeatureKeyRegExp,
                          )
                          .optional()
                          .describe(
                            'The feature the customer is entitled to use.',
                          ),
                        key: zod.coerce
                          .string()
                          .min(1)
                          .max(createPlanBodyPhasesItemRateCardsItemOneKeyMax)
                          .regex(
                            createPlanBodyPhasesItemRateCardsItemOneKeyRegExp,
                          )
                          .describe(
                            'A semi-unique identifier for the resource.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .nullish()
                          .describe('Additional metadata for the resource.'),
                        name: zod.coerce
                          .string()
                          .min(1)
                          .max(createPlanBodyPhasesItemRateCardsItemOneNameMax)
                          .describe(
                            'Human-readable name for the resource. Between 1 and 256 characters.',
                          ),
                        price: zod
                          .object({
                            amount: zod.coerce
                              .string()
                              .regex(
                                createPlanBodyPhasesItemRateCardsItemOnePriceOneAmountOneRegExp,
                              )
                              .describe(
                                'Numeric represents an arbitrary precision number.',
                              )
                              .describe('The amount of the flat price.'),
                            paymentTerm: zod
                              .enum(['in_advance', 'in_arrears'])
                              .describe(
                                'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                              )
                              .default(
                                createPlanBodyPhasesItemRateCardsItemOnePriceOnePaymentTermDefault,
                              )
                              .describe(
                                'The payment term of the flat price.\nDefaults to in advance.',
                              ),
                            type: zod.enum(['flat']),
                          })
                          .describe('Flat price with payment term.')
                          .nullable()
                          .describe(
                            'The price of the rate card.\nWhen null, the feature or service is free.',
                          ),
                        taxConfig: zod
                          .object({
                            behavior: zod
                              .enum(['inclusive', 'exclusive'])
                              .describe(
                                'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                              )
                              .optional()
                              .describe(
                                "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                              ),
                            customInvoicing: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .describe(
                                    'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                                  ),
                              })
                              .describe('Custom invoicing tax config.')
                              .optional()
                              .describe('Custom invoicing tax config.'),
                            stripe: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp,
                                  )
                                  .describe(
                                    'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                                  ),
                              })
                              .describe('The tax config for Stripe.')
                              .optional()
                              .describe('Stripe tax config.'),
                          })
                          .describe('Set of provider specific tax configs.')
                          .optional()
                          .describe(
                            'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                          ),
                        type: zod.enum(['flat_fee']),
                      })
                      .describe(
                        'A flat fee rate card defines a one-time purchase or a recurring fee.',
                      ),
                    zod
                      .object({
                        billingCadence: zod.coerce
                          .string()
                          .describe('The billing cadence of the rate card.'),
                        description: zod.coerce
                          .string()
                          .max(
                            createPlanBodyPhasesItemRateCardsItemTwoDescriptionMax,
                          )
                          .optional()
                          .describe(
                            'Optional description of the resource. Maximum 1024 characters.',
                          ),
                        discounts: zod
                          .object({
                            percentage: zod
                              .object({
                                percentage: zod.coerce
                                  .number()
                                  .describe(
                                    'Numeric representation of a percentage\n\n50% is represented as 50',
                                  )
                                  .describe('The percentage of the discount.'),
                              })
                              .describe('Percentage discount.')
                              .optional()
                              .describe('The percentage discount.'),
                            usage: zod
                              .object({
                                quantity: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe(
                                    'The quantity of the usage discount.\n\nMust be positive.',
                                  ),
                              })
                              .describe(
                                'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                              )
                              .optional()
                              .describe('The usage discount.'),
                          })
                          .describe('Discount by type on a price')
                          .optional()
                          .describe(
                            'The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.',
                          ),
                        entitlementTemplate: zod
                          .union([
                            zod
                              .object({
                                isSoftLimit: zod.coerce
                                  .boolean()
                                  .default(
                                    createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault,
                                  )
                                  .describe(
                                    'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                                  ),
                                issueAfterReset: zod.coerce
                                  .number()
                                  .min(
                                    createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin,
                                  )
                                  .optional()
                                  .describe(
                                    'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                                  ),
                                issueAfterResetPriority: zod.coerce
                                  .number()
                                  .min(1)
                                  .max(
                                    createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                                  )
                                  .default(
                                    createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                                  )
                                  .describe(
                                    'Defines the grant priority for the default grant.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                preserveOverageAtReset: zod.coerce
                                  .boolean()
                                  .default(
                                    createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                                  )
                                  .describe(
                                    'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                                  ),
                                type: zod.enum(['metered']),
                                usagePeriod: zod.coerce
                                  .string()
                                  .optional()
                                  .describe(
                                    'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                                  ),
                              })
                              .describe(
                                'The entitlement template with a metered entitlement.',
                              ),
                            zod
                              .object({
                                config: zod.coerce
                                  .string()
                                  .describe(
                                    'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['static']),
                              })
                              .describe(
                                'Entitlement template of a static entitlement.',
                              ),
                            zod
                              .object({
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['boolean']),
                              })
                              .describe(
                                'Entitlement template of a boolean entitlement.',
                              ),
                          ])
                          .describe(
                            'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                          )
                          .optional()
                          .describe(
                            'The entitlement of the rate card.\nOnly available when featureKey is set.',
                          ),
                        featureKey: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            createPlanBodyPhasesItemRateCardsItemTwoFeatureKeyMax,
                          )
                          .regex(
                            createPlanBodyPhasesItemRateCardsItemTwoFeatureKeyRegExp,
                          )
                          .optional()
                          .describe(
                            'The feature the customer is entitled to use.',
                          ),
                        key: zod.coerce
                          .string()
                          .min(1)
                          .max(createPlanBodyPhasesItemRateCardsItemTwoKeyMax)
                          .regex(
                            createPlanBodyPhasesItemRateCardsItemTwoKeyRegExp,
                          )
                          .describe(
                            'A semi-unique identifier for the resource.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .nullish()
                          .describe('Additional metadata for the resource.'),
                        name: zod.coerce
                          .string()
                          .min(1)
                          .max(createPlanBodyPhasesItemRateCardsItemTwoNameMax)
                          .describe(
                            'Human-readable name for the resource. Between 1 and 256 characters.',
                          ),
                        price: zod
                          .union([
                            zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the flat price.'),
                                paymentTerm: zod
                                  .enum(['in_advance', 'in_arrears'])
                                  .describe(
                                    'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                                  )
                                  .default(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault,
                                  )
                                  .describe(
                                    'The payment term of the flat price.\nDefaults to in advance.',
                                  ),
                                type: zod.enum(['flat']),
                              })
                              .describe('Flat price with payment term.'),
                            zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the unit price.'),
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                type: zod.enum(['unit']),
                              })
                              .describe('Unit price with spend commitments.'),
                            zod
                              .object({
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                mode: zod
                                  .enum(['volume', 'graduated'])
                                  .describe('The mode of the tiered price.')
                                  .describe(
                                    'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                                  ),
                                tiers: zod
                                  .array(
                                    zod
                                      .object({
                                        flatPrice: zod
                                          .object({
                                            amount: zod.coerce
                                              .string()
                                              .regex(
                                                createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                              )
                                              .describe(
                                                'Numeric represents an arbitrary precision number.',
                                              )
                                              .describe(
                                                'The amount of the flat price.',
                                              ),
                                            type: zod
                                              .enum(['flat'])
                                              .describe(
                                                'The type of the price.',
                                              ),
                                          })
                                          .describe('Flat price.')
                                          .nullable()
                                          .describe(
                                            'The flat price component of the tier.',
                                          ),
                                        unitPrice: zod
                                          .object({
                                            amount: zod.coerce
                                              .string()
                                              .regex(
                                                createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                              )
                                              .describe(
                                                'Numeric represents an arbitrary precision number.',
                                              )
                                              .describe(
                                                'The amount of the unit price.',
                                              ),
                                            type: zod
                                              .enum(['unit'])
                                              .describe(
                                                'The type of the price.',
                                              ),
                                          })
                                          .describe('Unit price.')
                                          .nullable()
                                          .describe(
                                            'The unit price component of the tier.',
                                          ),
                                        upToAmount: zod.coerce
                                          .string()
                                          .regex(
                                            createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                                          ),
                                      })
                                      .describe(
                                        'A price tier.\nAt least one price component is required in each tier.',
                                      ),
                                  )
                                  .min(1)
                                  .describe(
                                    'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                                  ),
                                type: zod.enum(['tiered']),
                              })
                              .describe('Tiered price with spend commitments.'),
                            zod
                              .object({
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                multiplier: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .default(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault,
                                  )
                                  .describe(
                                    'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                                  ),
                                type: zod.enum(['dynamic']),
                              })
                              .describe(
                                'Dynamic price with spend commitments.',
                              ),
                            zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The price of one package.'),
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                quantityPerPackage: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The quantity per package.'),
                                type: zod.enum(['package']),
                              })
                              .describe(
                                'Package price with spend commitments.',
                              ),
                          ])
                          .describe('The price of the usage based rate card.')
                          .nullable()
                          .describe(
                            'The price of the rate card.\nWhen null, the feature or service is free.',
                          ),
                        taxConfig: zod
                          .object({
                            behavior: zod
                              .enum(['inclusive', 'exclusive'])
                              .describe(
                                'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                              )
                              .optional()
                              .describe(
                                "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                              ),
                            customInvoicing: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .describe(
                                    'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                                  ),
                              })
                              .describe('Custom invoicing tax config.')
                              .optional()
                              .describe('Custom invoicing tax config.'),
                            stripe: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .regex(
                                    createPlanBodyPhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp,
                                  )
                                  .describe(
                                    'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                                  ),
                              })
                              .describe('The tax config for Stripe.')
                              .optional()
                              .describe('Stripe tax config.'),
                          })
                          .describe('Set of provider specific tax configs.')
                          .optional()
                          .describe(
                            'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                          ),
                        type: zod.enum(['usage_based']),
                      })
                      .describe(
                        'A usage-based rate card defines a price based on usage.',
                      ),
                  ])
                  .describe(
                    'A rate card defines the pricing and entitlement of a feature or service.',
                  ),
              )
              .describe('The rate cards of the plan.'),
          })
          .describe(
            "The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.",
          ),
      )
      .min(1)
      .describe(
        "The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.\nA phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.",
      ),
    proRatingConfig: zod
      .object({
        enabled: zod.coerce
          .boolean()
          .describe('Whether pro-rating is enabled for this plan.'),
        mode: zod
          .enum(['prorate_prices'])
          .describe(
            'Pro-rating mode options for handling billing period changes.',
          )
          .describe('How to handle pro-rating for billing period changes.'),
      })
      .describe('Configuration for pro-rating behavior.')
      .default(createPlanBodyProRatingConfigDefault)
      .describe(
        'Default pro-rating configuration for subscriptions using this plan.',
      ),
  })
  .describe('Resource create operation model.')

/**
 * Create a new draft version from plan.
It returns error if there is already a plan in draft or planId does not reference the latest published version.
 * @deprecated
 * @summary New draft plan
 */
export const nextPlanPathPlanIdOrKeyMax = 64 as const

export const nextPlanPathPlanIdOrKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const NextPlanParams = zod.object({
  planIdOrKey: zod.coerce
    .string()
    .min(1)
    .max(nextPlanPathPlanIdOrKeyMax)
    .regex(nextPlanPathPlanIdOrKeyRegExp),
})

/**
 * Update plan by id.
 * @summary Update a plan
 */
export const updatePlanPathPlanIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdatePlanParams = zod.object({
  planId: zod.coerce.string().regex(updatePlanPathPlanIdRegExp),
})

export const updatePlanBodyNameMax = 256 as const

export const updatePlanBodyDescriptionMax = 1024 as const

export const updatePlanBodyProRatingConfigOneEnabledDefault = true as const
export const updatePlanBodyProRatingConfigOneModeDefault =
  'prorate_prices' as const
export const updatePlanBodyProRatingConfigDefault = {
  enabled: true,
  mode: 'prorate_prices',
} as const
export const updatePlanBodyPhasesItemKeyMax = 64 as const

export const updatePlanBodyPhasesItemKeyRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updatePlanBodyPhasesItemNameMax = 256 as const

export const updatePlanBodyPhasesItemDescriptionMax = 1024 as const

export const updatePlanBodyPhasesItemRateCardsItemOneKeyMax = 64 as const

export const updatePlanBodyPhasesItemRateCardsItemOneKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updatePlanBodyPhasesItemRateCardsItemOneNameMax = 256 as const

export const updatePlanBodyPhasesItemRateCardsItemOneDescriptionMax =
  1024 as const

export const updatePlanBodyPhasesItemRateCardsItemOneFeatureKeyMax = 64 as const

export const updatePlanBodyPhasesItemRateCardsItemOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const updatePlanBodyPhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const updatePlanBodyPhasesItemRateCardsItemOnePriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemOnePriceOnePaymentTermDefault =
  'in_advance' as const
export const updatePlanBodyPhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoKeyMax = 64 as const

export const updatePlanBodyPhasesItemRateCardsItemTwoKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updatePlanBodyPhasesItemRateCardsItemTwoNameMax = 256 as const

export const updatePlanBodyPhasesItemRateCardsItemTwoDescriptionMax =
  1024 as const

export const updatePlanBodyPhasesItemRateCardsItemTwoFeatureKeyMax = 64 as const

export const updatePlanBodyPhasesItemRateCardsItemTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const updatePlanBodyPhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault =
  'in_advance' as const
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault =
  '1' as const
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const updatePlanBodyPhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const UpdatePlanBody = zod
  .object({
    alignment: zod
      .object({
        billablesMustAlign: zod.coerce
          .boolean()
          .optional()
          .describe(
            "Whether all Billable items and RateCards must align.\nAlignment means the Price's BillingCadence must align for both duration and anchor time.",
          ),
      })
      .describe('Alignment configuration for a plan or subscription.')
      .optional()
      .describe('Alignment configuration for the plan.'),
    billingCadence: zod.coerce
      .string()
      .describe(
        'The default billing cadence for subscriptions using this plan.\nDefines how often customers are billed using ISO8601 duration format.\nExamples: "P1M" (monthly), "P3M" (quarterly), "P1Y" (annually).',
      ),
    description: zod.coerce
      .string()
      .max(updatePlanBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(updatePlanBodyNameMax)
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.',
      ),
    phases: zod
      .array(
        zod
          .object({
            description: zod.coerce
              .string()
              .max(updatePlanBodyPhasesItemDescriptionMax)
              .optional()
              .describe(
                'Optional description of the resource. Maximum 1024 characters.',
              ),
            duration: zod.coerce
              .string()
              .nullable()
              .describe('The duration of the phase.'),
            key: zod.coerce
              .string()
              .min(1)
              .max(updatePlanBodyPhasesItemKeyMax)
              .regex(updatePlanBodyPhasesItemKeyRegExp)
              .describe('A semi-unique identifier for the resource.'),
            metadata: zod
              .record(zod.string(), zod.coerce.string())
              .describe(
                'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
              )
              .nullish()
              .describe('Additional metadata for the resource.'),
            name: zod.coerce
              .string()
              .min(1)
              .max(updatePlanBodyPhasesItemNameMax)
              .describe(
                'Human-readable name for the resource. Between 1 and 256 characters.',
              ),
            rateCards: zod
              .array(
                zod
                  .union([
                    zod
                      .object({
                        billingCadence: zod.coerce
                          .string()
                          .nullable()
                          .describe(
                            'The billing cadence of the rate card.\nWhen null it means it is a one time fee.',
                          ),
                        description: zod.coerce
                          .string()
                          .max(
                            updatePlanBodyPhasesItemRateCardsItemOneDescriptionMax,
                          )
                          .optional()
                          .describe(
                            'Optional description of the resource. Maximum 1024 characters.',
                          ),
                        discounts: zod
                          .object({
                            percentage: zod
                              .object({
                                percentage: zod.coerce
                                  .number()
                                  .describe(
                                    'Numeric representation of a percentage\n\n50% is represented as 50',
                                  )
                                  .describe('The percentage of the discount.'),
                              })
                              .describe('Percentage discount.')
                              .optional()
                              .describe('The percentage discount.'),
                            usage: zod
                              .object({
                                quantity: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe(
                                    'The quantity of the usage discount.\n\nMust be positive.',
                                  ),
                              })
                              .describe(
                                'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                              )
                              .optional()
                              .describe('The usage discount.'),
                          })
                          .describe('Discount by type on a price')
                          .optional()
                          .describe(
                            'The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.',
                          ),
                        entitlementTemplate: zod
                          .union([
                            zod
                              .object({
                                isSoftLimit: zod.coerce
                                  .boolean()
                                  .default(
                                    updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault,
                                  )
                                  .describe(
                                    'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                                  ),
                                issueAfterReset: zod.coerce
                                  .number()
                                  .min(
                                    updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin,
                                  )
                                  .optional()
                                  .describe(
                                    'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                                  ),
                                issueAfterResetPriority: zod.coerce
                                  .number()
                                  .min(1)
                                  .max(
                                    updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                                  )
                                  .default(
                                    updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                                  )
                                  .describe(
                                    'Defines the grant priority for the default grant.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                preserveOverageAtReset: zod.coerce
                                  .boolean()
                                  .default(
                                    updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                                  )
                                  .describe(
                                    'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                                  ),
                                type: zod.enum(['metered']),
                                usagePeriod: zod.coerce
                                  .string()
                                  .optional()
                                  .describe(
                                    'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                                  ),
                              })
                              .describe(
                                'The entitlement template with a metered entitlement.',
                              ),
                            zod
                              .object({
                                config: zod.coerce
                                  .string()
                                  .describe(
                                    'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['static']),
                              })
                              .describe(
                                'Entitlement template of a static entitlement.',
                              ),
                            zod
                              .object({
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['boolean']),
                              })
                              .describe(
                                'Entitlement template of a boolean entitlement.',
                              ),
                          ])
                          .describe(
                            'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                          )
                          .optional()
                          .describe(
                            'The entitlement of the rate card.\nOnly available when featureKey is set.',
                          ),
                        featureKey: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            updatePlanBodyPhasesItemRateCardsItemOneFeatureKeyMax,
                          )
                          .regex(
                            updatePlanBodyPhasesItemRateCardsItemOneFeatureKeyRegExp,
                          )
                          .optional()
                          .describe(
                            'The feature the customer is entitled to use.',
                          ),
                        key: zod.coerce
                          .string()
                          .min(1)
                          .max(updatePlanBodyPhasesItemRateCardsItemOneKeyMax)
                          .regex(
                            updatePlanBodyPhasesItemRateCardsItemOneKeyRegExp,
                          )
                          .describe(
                            'A semi-unique identifier for the resource.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .nullish()
                          .describe('Additional metadata for the resource.'),
                        name: zod.coerce
                          .string()
                          .min(1)
                          .max(updatePlanBodyPhasesItemRateCardsItemOneNameMax)
                          .describe(
                            'Human-readable name for the resource. Between 1 and 256 characters.',
                          ),
                        price: zod
                          .object({
                            amount: zod.coerce
                              .string()
                              .regex(
                                updatePlanBodyPhasesItemRateCardsItemOnePriceOneAmountOneRegExp,
                              )
                              .describe(
                                'Numeric represents an arbitrary precision number.',
                              )
                              .describe('The amount of the flat price.'),
                            paymentTerm: zod
                              .enum(['in_advance', 'in_arrears'])
                              .describe(
                                'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                              )
                              .default(
                                updatePlanBodyPhasesItemRateCardsItemOnePriceOnePaymentTermDefault,
                              )
                              .describe(
                                'The payment term of the flat price.\nDefaults to in advance.',
                              ),
                            type: zod.enum(['flat']),
                          })
                          .describe('Flat price with payment term.')
                          .nullable()
                          .describe(
                            'The price of the rate card.\nWhen null, the feature or service is free.',
                          ),
                        taxConfig: zod
                          .object({
                            behavior: zod
                              .enum(['inclusive', 'exclusive'])
                              .describe(
                                'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                              )
                              .optional()
                              .describe(
                                "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                              ),
                            customInvoicing: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .describe(
                                    'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                                  ),
                              })
                              .describe('Custom invoicing tax config.')
                              .optional()
                              .describe('Custom invoicing tax config.'),
                            stripe: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp,
                                  )
                                  .describe(
                                    'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                                  ),
                              })
                              .describe('The tax config for Stripe.')
                              .optional()
                              .describe('Stripe tax config.'),
                          })
                          .describe('Set of provider specific tax configs.')
                          .optional()
                          .describe(
                            'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                          ),
                        type: zod.enum(['flat_fee']),
                      })
                      .describe(
                        'A flat fee rate card defines a one-time purchase or a recurring fee.',
                      ),
                    zod
                      .object({
                        billingCadence: zod.coerce
                          .string()
                          .describe('The billing cadence of the rate card.'),
                        description: zod.coerce
                          .string()
                          .max(
                            updatePlanBodyPhasesItemRateCardsItemTwoDescriptionMax,
                          )
                          .optional()
                          .describe(
                            'Optional description of the resource. Maximum 1024 characters.',
                          ),
                        discounts: zod
                          .object({
                            percentage: zod
                              .object({
                                percentage: zod.coerce
                                  .number()
                                  .describe(
                                    'Numeric representation of a percentage\n\n50% is represented as 50',
                                  )
                                  .describe('The percentage of the discount.'),
                              })
                              .describe('Percentage discount.')
                              .optional()
                              .describe('The percentage discount.'),
                            usage: zod
                              .object({
                                quantity: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe(
                                    'The quantity of the usage discount.\n\nMust be positive.',
                                  ),
                              })
                              .describe(
                                'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                              )
                              .optional()
                              .describe('The usage discount.'),
                          })
                          .describe('Discount by type on a price')
                          .optional()
                          .describe(
                            'The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.',
                          ),
                        entitlementTemplate: zod
                          .union([
                            zod
                              .object({
                                isSoftLimit: zod.coerce
                                  .boolean()
                                  .default(
                                    updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault,
                                  )
                                  .describe(
                                    'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                                  ),
                                issueAfterReset: zod.coerce
                                  .number()
                                  .min(
                                    updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin,
                                  )
                                  .optional()
                                  .describe(
                                    'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                                  ),
                                issueAfterResetPriority: zod.coerce
                                  .number()
                                  .min(1)
                                  .max(
                                    updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                                  )
                                  .default(
                                    updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                                  )
                                  .describe(
                                    'Defines the grant priority for the default grant.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                preserveOverageAtReset: zod.coerce
                                  .boolean()
                                  .default(
                                    updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                                  )
                                  .describe(
                                    'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                                  ),
                                type: zod.enum(['metered']),
                                usagePeriod: zod.coerce
                                  .string()
                                  .optional()
                                  .describe(
                                    'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                                  ),
                              })
                              .describe(
                                'The entitlement template with a metered entitlement.',
                              ),
                            zod
                              .object({
                                config: zod.coerce
                                  .string()
                                  .describe(
                                    'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['static']),
                              })
                              .describe(
                                'Entitlement template of a static entitlement.',
                              ),
                            zod
                              .object({
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['boolean']),
                              })
                              .describe(
                                'Entitlement template of a boolean entitlement.',
                              ),
                          ])
                          .describe(
                            'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                          )
                          .optional()
                          .describe(
                            'The entitlement of the rate card.\nOnly available when featureKey is set.',
                          ),
                        featureKey: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            updatePlanBodyPhasesItemRateCardsItemTwoFeatureKeyMax,
                          )
                          .regex(
                            updatePlanBodyPhasesItemRateCardsItemTwoFeatureKeyRegExp,
                          )
                          .optional()
                          .describe(
                            'The feature the customer is entitled to use.',
                          ),
                        key: zod.coerce
                          .string()
                          .min(1)
                          .max(updatePlanBodyPhasesItemRateCardsItemTwoKeyMax)
                          .regex(
                            updatePlanBodyPhasesItemRateCardsItemTwoKeyRegExp,
                          )
                          .describe(
                            'A semi-unique identifier for the resource.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .nullish()
                          .describe('Additional metadata for the resource.'),
                        name: zod.coerce
                          .string()
                          .min(1)
                          .max(updatePlanBodyPhasesItemRateCardsItemTwoNameMax)
                          .describe(
                            'Human-readable name for the resource. Between 1 and 256 characters.',
                          ),
                        price: zod
                          .union([
                            zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the flat price.'),
                                paymentTerm: zod
                                  .enum(['in_advance', 'in_arrears'])
                                  .describe(
                                    'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                                  )
                                  .default(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault,
                                  )
                                  .describe(
                                    'The payment term of the flat price.\nDefaults to in advance.',
                                  ),
                                type: zod.enum(['flat']),
                              })
                              .describe('Flat price with payment term.'),
                            zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the unit price.'),
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                type: zod.enum(['unit']),
                              })
                              .describe('Unit price with spend commitments.'),
                            zod
                              .object({
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                mode: zod
                                  .enum(['volume', 'graduated'])
                                  .describe('The mode of the tiered price.')
                                  .describe(
                                    'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                                  ),
                                tiers: zod
                                  .array(
                                    zod
                                      .object({
                                        flatPrice: zod
                                          .object({
                                            amount: zod.coerce
                                              .string()
                                              .regex(
                                                updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                              )
                                              .describe(
                                                'Numeric represents an arbitrary precision number.',
                                              )
                                              .describe(
                                                'The amount of the flat price.',
                                              ),
                                            type: zod
                                              .enum(['flat'])
                                              .describe(
                                                'The type of the price.',
                                              ),
                                          })
                                          .describe('Flat price.')
                                          .nullable()
                                          .describe(
                                            'The flat price component of the tier.',
                                          ),
                                        unitPrice: zod
                                          .object({
                                            amount: zod.coerce
                                              .string()
                                              .regex(
                                                updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                              )
                                              .describe(
                                                'Numeric represents an arbitrary precision number.',
                                              )
                                              .describe(
                                                'The amount of the unit price.',
                                              ),
                                            type: zod
                                              .enum(['unit'])
                                              .describe(
                                                'The type of the price.',
                                              ),
                                          })
                                          .describe('Unit price.')
                                          .nullable()
                                          .describe(
                                            'The unit price component of the tier.',
                                          ),
                                        upToAmount: zod.coerce
                                          .string()
                                          .regex(
                                            updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                                          ),
                                      })
                                      .describe(
                                        'A price tier.\nAt least one price component is required in each tier.',
                                      ),
                                  )
                                  .min(1)
                                  .describe(
                                    'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                                  ),
                                type: zod.enum(['tiered']),
                              })
                              .describe('Tiered price with spend commitments.'),
                            zod
                              .object({
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                multiplier: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .default(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault,
                                  )
                                  .describe(
                                    'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                                  ),
                                type: zod.enum(['dynamic']),
                              })
                              .describe(
                                'Dynamic price with spend commitments.',
                              ),
                            zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The price of one package.'),
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                quantityPerPackage: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The quantity per package.'),
                                type: zod.enum(['package']),
                              })
                              .describe(
                                'Package price with spend commitments.',
                              ),
                          ])
                          .describe('The price of the usage based rate card.')
                          .nullable()
                          .describe(
                            'The price of the rate card.\nWhen null, the feature or service is free.',
                          ),
                        taxConfig: zod
                          .object({
                            behavior: zod
                              .enum(['inclusive', 'exclusive'])
                              .describe(
                                'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                              )
                              .optional()
                              .describe(
                                "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                              ),
                            customInvoicing: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .describe(
                                    'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                                  ),
                              })
                              .describe('Custom invoicing tax config.')
                              .optional()
                              .describe('Custom invoicing tax config.'),
                            stripe: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .regex(
                                    updatePlanBodyPhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp,
                                  )
                                  .describe(
                                    'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                                  ),
                              })
                              .describe('The tax config for Stripe.')
                              .optional()
                              .describe('Stripe tax config.'),
                          })
                          .describe('Set of provider specific tax configs.')
                          .optional()
                          .describe(
                            'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                          ),
                        type: zod.enum(['usage_based']),
                      })
                      .describe(
                        'A usage-based rate card defines a price based on usage.',
                      ),
                  ])
                  .describe(
                    'A rate card defines the pricing and entitlement of a feature or service.',
                  ),
              )
              .describe('The rate cards of the plan.'),
          })
          .describe(
            "The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.",
          ),
      )
      .min(1)
      .describe(
        "The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.\nA phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.",
      ),
    proRatingConfig: zod
      .object({
        enabled: zod.coerce
          .boolean()
          .describe('Whether pro-rating is enabled for this plan.'),
        mode: zod
          .enum(['prorate_prices'])
          .describe(
            'Pro-rating mode options for handling billing period changes.',
          )
          .describe('How to handle pro-rating for billing period changes.'),
      })
      .describe('Configuration for pro-rating behavior.')
      .default(updatePlanBodyProRatingConfigDefault)
      .describe(
        'Default pro-rating configuration for subscriptions using this plan.',
      ),
  })
  .describe('Resource update operation model.')

/**
 * Get a plan by id or key. The latest published version is returned if latter is used.
 * @summary Get plan
 */
export const getPlanPathPlanIdMax = 64 as const

export const getPlanPathPlanIdRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetPlanParams = zod.object({
  planId: zod.coerce
    .string()
    .min(1)
    .max(getPlanPathPlanIdMax)
    .regex(getPlanPathPlanIdRegExp),
})

export const getPlanQueryIncludeLatestDefault = false as const

export const GetPlanQueryParams = zod.object({
  includeLatest: zod.coerce
    .boolean()
    .default(getPlanQueryIncludeLatestDefault)
    .describe(
      'Include latest version of the Plan instead of the version in active state.\n\nUsage: `?includeLatest=true`',
    ),
})

/**
 * Soft delete plan by plan.id.

Once a plan is deleted it cannot be undeleted.
 * @summary Delete plan
 */
export const deletePlanPathPlanIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeletePlanParams = zod.object({
  planId: zod.coerce.string().regex(deletePlanPathPlanIdRegExp),
})

/**
 * List all available add-ons for plan.
 * @summary List all available add-ons for plan
 */
export const listPlanAddonsPathPlanIdMax = 64 as const

export const listPlanAddonsPathPlanIdRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ListPlanAddonsParams = zod.object({
  planId: zod.coerce
    .string()
    .min(1)
    .max(listPlanAddonsPathPlanIdMax)
    .regex(listPlanAddonsPathPlanIdRegExp),
})

export const listPlanAddonsQueryIncludeDeletedDefault = false as const
export const listPlanAddonsQueryIdItemRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listPlanAddonsQueryKeyItemMax = 64 as const

export const listPlanAddonsQueryKeyItemRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const listPlanAddonsQueryPageDefault = 1 as const

export const listPlanAddonsQueryPageSizeDefault = 100 as const
export const listPlanAddonsQueryPageSizeMax = 1000 as const

export const ListPlanAddonsQueryParams = zod.object({
  id: zod
    .array(
      zod.coerce
        .string()
        .regex(listPlanAddonsQueryIdItemRegExp)
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier).',
        ),
    )
    .optional()
    .describe('Filter by addon.id attribute.'),
  includeDeleted: zod.coerce
    .boolean()
    .default(listPlanAddonsQueryIncludeDeletedDefault)
    .describe(
      'Include deleted plan add-on assignments.\n\nUsage: `?includeDeleted=true`',
    ),
  key: zod
    .array(
      zod.coerce
        .string()
        .min(1)
        .max(listPlanAddonsQueryKeyItemMax)
        .regex(listPlanAddonsQueryKeyItemRegExp)
        .describe(
          'A key is a unique string that is used to identify a resource.',
        ),
    )
    .optional()
    .describe('Filter by addon.key attribute.'),
  keyVersion: zod
    .record(zod.string(), zod.array(zod.coerce.number()))
    .optional()
    .describe('Filter by addon.key and addon.version attributes.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'key', 'version', 'created_at', 'updated_at'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listPlanAddonsQueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listPlanAddonsQueryPageSizeMax)
    .default(listPlanAddonsQueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * Create new add-on assignment for plan.
 * @summary Create new add-on assignment for plan
 */
export const createPlanAddonPathPlanIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const CreatePlanAddonParams = zod.object({
  planId: zod.coerce.string().regex(createPlanAddonPathPlanIdRegExp),
})

export const createPlanAddonBodyAddonIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const CreatePlanAddonBody = zod
  .object({
    addonId: zod.coerce
      .string()
      .regex(createPlanAddonBodyAddonIdRegExp)
      .describe('The add-on unique identifier in ULID format.'),
    fromPlanPhase: zod.coerce
      .string()
      .describe(
        'The key of the plan phase from the add-on becomes available for purchase.',
      ),
    maxQuantity: zod.coerce
      .number()
      .optional()
      .describe(
        'The maximum number of times the add-on can be purchased for the plan.\nIt is not applicable for add-ons with single instance type.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .optional()
      .describe('Additional metadata for the resource.'),
  })
  .describe('A plan add-on assignment create request.')

/**
 * Update add-on assignment for plan.
 * @summary Update add-on assignment for plan
 */
export const updatePlanAddonPathPlanIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const updatePlanAddonPathPlanAddonIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdatePlanAddonParams = zod.object({
  planAddonId: zod.coerce.string().regex(updatePlanAddonPathPlanAddonIdRegExp),
  planId: zod.coerce.string().regex(updatePlanAddonPathPlanIdRegExp),
})

export const UpdatePlanAddonBody = zod
  .object({
    fromPlanPhase: zod.coerce
      .string()
      .describe(
        'The key of the plan phase from the add-on becomes available for purchase.',
      ),
    maxQuantity: zod.coerce
      .number()
      .optional()
      .describe(
        'The maximum number of times the add-on can be purchased for the plan.\nIt is not applicable for add-ons with single instance type.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .optional()
      .describe('Additional metadata for the resource.'),
  })
  .describe('Resource update operation model.')

/**
 * Get add-on assignment for plan by id.
 * @summary Get add-on assignment for plan
 */
export const getPlanAddonPathPlanIdMax = 64 as const

export const getPlanAddonPathPlanIdRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const getPlanAddonPathPlanAddonIdMax = 64 as const

export const getPlanAddonPathPlanAddonIdRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetPlanAddonParams = zod.object({
  planAddonId: zod.coerce
    .string()
    .min(1)
    .max(getPlanAddonPathPlanAddonIdMax)
    .regex(getPlanAddonPathPlanAddonIdRegExp),
  planId: zod.coerce
    .string()
    .min(1)
    .max(getPlanAddonPathPlanIdMax)
    .regex(getPlanAddonPathPlanIdRegExp),
})

/**
 * Delete add-on assignment for plan.

Once a plan is deleted it cannot be undeleted.
 * @summary Delete add-on assignment for plan
 */
export const deletePlanAddonPathPlanIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const deletePlanAddonPathPlanAddonIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeletePlanAddonParams = zod.object({
  planAddonId: zod.coerce.string().regex(deletePlanAddonPathPlanAddonIdRegExp),
  planId: zod.coerce.string().regex(deletePlanAddonPathPlanIdRegExp),
})

/**
 * Archive a plan version.
 * @summary Archive plan version
 */
export const archivePlanPathPlanIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ArchivePlanParams = zod.object({
  planId: zod.coerce.string().regex(archivePlanPathPlanIdRegExp),
})

/**
 * Publish a plan version.
 * @summary Publish plan
 */
export const publishPlanPathPlanIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const PublishPlanParams = zod.object({
  planId: zod.coerce.string().regex(publishPlanPathPlanIdRegExp),
})

/**
 * Query meter for consumer portal. This endpoint is publicly exposable to consumers. Query meter for consumer portal. This endpoint is publicly exposable to consumers.
 * @summary Query meter Query meter
 */
export const queryPortalMeterPathMeterSlugMax = 64 as const

export const queryPortalMeterPathMeterSlugRegExp = /^[a-z0-9]+(?:_[a-z0-9]+)*$/

export const QueryPortalMeterParams = zod.object({
  meterSlug: zod.coerce
    .string()
    .min(1)
    .max(queryPortalMeterPathMeterSlugMax)
    .regex(queryPortalMeterPathMeterSlugRegExp),
})

export const queryPortalMeterQueryClientIdMax = 36 as const

export const queryPortalMeterQueryWindowTimeZoneDefault = 'UTC' as const
export const queryPortalMeterQueryFilterCustomerIdMax = 100 as const

export const QueryPortalMeterQueryParams = zod.object({
  clientId: zod.coerce
    .string()
    .min(1)
    .max(queryPortalMeterQueryClientIdMax)
    .optional()
    .describe('Client ID\nUseful to track progress of a query.'),
  filterCustomerId: zod
    .array(zod.coerce.string())
    .max(queryPortalMeterQueryFilterCustomerIdMax)
    .optional()
    .describe(
      'Filtering by multiple customers.\n\nFor example: ?filterCustomerId=customer-1&filterCustomerId=customer-2',
    ),
  filterGroupBy: zod
    .record(zod.string(), zod.coerce.string())
    .optional()
    .describe(
      'Simple filter for group bys with exact match.\n\nFor example: ?filterGroupBy[vendor]=openai&filterGroupBy[model]=gpt-4-turbo\n\n‚ö†Ô∏è __Deprecated__: Use `advancedMeterGroupByFilters` instead',
    ),
  from: zod.coerce
    .date()
    .optional()
    .describe(
      'Start date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?from=2025-01-01T00%3A00%3A00.000Z',
    ),
  groupBy: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'If not specified a single aggregate will be returned for each subject and time window.\n`subject` is a reserved group by value.\n\nFor example: ?groupBy=subject&groupBy=model',
    ),
  to: zod.coerce
    .date()
    .optional()
    .describe(
      'End date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?to=2025-02-01T00%3A00%3A00.000Z',
    ),
  windowSize: zod
    .enum(['MINUTE', 'HOUR', 'DAY', 'MONTH'])
    .optional()
    .describe(
      'If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.\n\nFor example: ?windowSize=DAY',
    ),
  windowTimeZone: zod.coerce
    .string()
    .default(queryPortalMeterQueryWindowTimeZoneDefault)
    .describe(
      'The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).\nIf not specified, the UTC timezone will be used.\n\nFor example: ?windowTimeZone=UTC',
    ),
})

/**
 * Create a consumer portal token.
 * @summary Create consumer portal token
 */
export const CreatePortalTokenBody = zod
  .object({
    allowedMeterSlugs: zod
      .array(zod.coerce.string())
      .optional()
      .describe(
        'Optional, if defined only the specified meters will be allowed.',
      ),
    subject: zod.coerce.string(),
  })
  .describe(
    "A consumer portal token.\n\nValidator doesn't obey required for readOnly properties\nSee: https://github.com/stoplightio/spectral/issues/1274",
  )

/**
 * List tokens.
 * @summary List consumer portal tokens
 */
export const listPortalTokensQueryLimitDefault = 25 as const
export const listPortalTokensQueryLimitMax = 100 as const

export const ListPortalTokensQueryParams = zod.object({
  limit: zod.coerce
    .number()
    .min(1)
    .max(listPortalTokensQueryLimitMax)
    .default(listPortalTokensQueryLimitDefault),
})

/**
 * Invalidates consumer portal tokens by ID or subject.
 * @summary Invalidate portal tokens
 */
export const InvalidatePortalTokensBody = zod.object({
  id: zod.coerce
    .string()
    .optional()
    .describe('Invalidate a portal token by ID.'),
  subject: zod.coerce
    .string()
    .optional()
    .describe('Invalidate all portal tokens for a subject.'),
})

/**
 * Create checkout session.
 * @summary Create checkout session
 */
export const createStripeCheckoutSessionBodyAppIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createStripeCheckoutSessionBodyCustomerOneIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createStripeCheckoutSessionBodyCustomerThreeNameMax = 256 as const

export const createStripeCheckoutSessionBodyCustomerThreeDescriptionMax =
  1024 as const

export const createStripeCheckoutSessionBodyCustomerThreeKeyMax = 256 as const

export const createStripeCheckoutSessionBodyCustomerThreeUsageAttributionOneSubjectKeysMin =
  0 as const

export const createStripeCheckoutSessionBodyCustomerThreeCurrencyOneMin =
  3 as const
export const createStripeCheckoutSessionBodyCustomerThreeCurrencyOneMax =
  3 as const

export const createStripeCheckoutSessionBodyCustomerThreeCurrencyOneRegExp =
  /^[A-Z]{3}$/
export const createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneMin =
  2 as const
export const createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneMax =
  2 as const

export const createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneRegExp =
  /^[A-Z]{2}$/
export const createStripeCheckoutSessionBodyOptionsOneCurrencyOneMin =
  3 as const
export const createStripeCheckoutSessionBodyOptionsOneCurrencyOneMax =
  3 as const

export const createStripeCheckoutSessionBodyOptionsOneCurrencyOneRegExp =
  /^[A-Z]{3}$/
export const createStripeCheckoutSessionBodyOptionsOneCustomTextOneAfterSubmitMessageMax =
  1200 as const

export const createStripeCheckoutSessionBodyOptionsOneCustomTextOneShippingAddressMessageMax =
  1200 as const

export const createStripeCheckoutSessionBodyOptionsOneCustomTextOneSubmitMessageMax =
  1200 as const

export const createStripeCheckoutSessionBodyOptionsOneCustomTextOneTermsOfServiceAcceptanceMessageMax =
  1200 as const

export const CreateStripeCheckoutSessionBody = zod
  .object({
    appId: zod.coerce
      .string()
      .regex(createStripeCheckoutSessionBodyAppIdRegExp)
      .optional()
      .describe('If not provided, the default Stripe app is used if any.'),
    customer: zod
      .union([
        zod
          .object({
            id: zod.coerce
              .string()
              .regex(createStripeCheckoutSessionBodyCustomerOneIdRegExp)
              .describe(
                'ULID (Universally Unique Lexicographically Sortable Identifier).',
              ),
          })
          .describe('Create Stripe checkout session with customer ID.'),
        zod
          .object({
            key: zod.coerce.string(),
          })
          .describe('Create Stripe checkout session with customer key.'),
        zod
          .object({
            billingAddress: zod
              .object({
                city: zod.coerce.string().optional().describe('City.'),
                country: zod.coerce
                  .string()
                  .min(
                    createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneMin,
                  )
                  .max(
                    createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneMax,
                  )
                  .regex(
                    createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneRegExp,
                  )
                  .describe(
                    '[ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.',
                  )
                  .optional()
                  .describe(
                    'Country code in [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 format.',
                  ),
                line1: zod.coerce
                  .string()
                  .optional()
                  .describe('First line of the address.'),
                line2: zod.coerce
                  .string()
                  .optional()
                  .describe('Second line of the address.'),
                phoneNumber: zod.coerce
                  .string()
                  .optional()
                  .describe('Phone number.'),
                postalCode: zod.coerce
                  .string()
                  .optional()
                  .describe('Postal code.'),
                state: zod.coerce
                  .string()
                  .optional()
                  .describe('State or province.'),
              })
              .describe('Address')
              .optional()
              .describe(
                'The billing address of the customer.\nUsed for tax and invoicing.',
              ),
            currency: zod.coerce
              .string()
              .min(createStripeCheckoutSessionBodyCustomerThreeCurrencyOneMin)
              .max(createStripeCheckoutSessionBodyCustomerThreeCurrencyOneMax)
              .regex(
                createStripeCheckoutSessionBodyCustomerThreeCurrencyOneRegExp,
              )
              .describe(
                'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
              )
              .optional()
              .describe(
                'Currency of the customer.\nUsed for billing, tax and invoicing.',
              ),
            description: zod.coerce
              .string()
              .max(createStripeCheckoutSessionBodyCustomerThreeDescriptionMax)
              .optional()
              .describe(
                'Optional description of the resource. Maximum 1024 characters.',
              ),
            key: zod.coerce
              .string()
              .min(1)
              .max(createStripeCheckoutSessionBodyCustomerThreeKeyMax)
              .optional()
              .describe(
                'An optional unique key of the customer.\nEither key or usageAttribution.subjectKeys must be provided.\nUseful to reference the customer in external systems.\nFor example, your database ID.',
              ),
            metadata: zod
              .record(zod.string(), zod.coerce.string())
              .describe(
                'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
              )
              .nullish()
              .describe('Additional metadata for the resource.'),
            name: zod.coerce
              .string()
              .min(1)
              .max(createStripeCheckoutSessionBodyCustomerThreeNameMax)
              .describe(
                'Human-readable name for the resource. Between 1 and 256 characters.',
              ),
            primaryEmail: zod.coerce
              .string()
              .optional()
              .describe('The primary email address of the customer.'),
            usageAttribution: zod
              .object({
                subjectKeys: zod
                  .array(
                    zod.coerce
                      .string()
                      .min(1)
                      .describe(
                        'SubjectKey is a key that is used to identify a subject.',
                      ),
                  )
                  .min(
                    createStripeCheckoutSessionBodyCustomerThreeUsageAttributionOneSubjectKeysMin,
                  )
                  .describe(
                    'The subjects that are attributed to the customer.\nCan be empty when no subjects are associated with the customer.',
                  ),
              })
              .describe(
                'Mapping to attribute metered usage to the customer.\nOne customer can have zero or more subjects,\nbut one subject can only belong to one customer.',
              )
              .optional()
              .describe(
                'Mapping to attribute metered usage to the customer\nEither key or usageAttribution.subjectKeys must be provided.',
              ),
          })
          .describe('Resource create operation model.'),
      ])
      .describe(
        'Provide a customer ID or key to use an existing OpenMeter customer.\nor provide a customer object to create a new customer.',
      ),
    options: zod
      .object({
        billingAddressCollection: zod
          .enum(['auto', 'required'])
          .describe(
            'Specify whether Checkout should collect the customer‚Äôs billing address.',
          )
          .optional()
          .describe(
            'Specify whether Checkout should collect the customer‚Äôs billing address. Defaults to auto.',
          ),
        cancelURL: zod.coerce
          .string()
          .optional()
          .describe(
            'If set, Checkout displays a back button and customers will be directed to this URL if they decide to cancel payment and return to your website.\nThis parameter is not allowed if ui_mode is embedded.',
          ),
        clientReferenceID: zod.coerce
          .string()
          .optional()
          .describe(
            'A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the session with your internal systems.',
          ),
        consentCollection: zod
          .object({
            paymentMethodReuseAgreement: zod
              .object({
                position: zod
                  .enum(['auto', 'hidden'])
                  .optional()
                  .describe(
                    'Create Stripe checkout session consent collection agreement position.',
                  ),
              })
              .describe(
                'Create Stripe checkout session payment method reuse agreement.',
              )
              .optional()
              .describe(
                'Determines the position and visibility of the payment method reuse agreement in the UI.\nWhen set to auto, Stripe‚Äôs defaults will be used. When set to hidden, the payment method reuse agreement text will always be hidden in the UI.',
              ),
            promotions: zod
              .enum(['auto', 'none'])
              .describe(
                'Create Stripe checkout session consent collection promotions.',
              )
              .optional()
              .describe(
                'If set to auto, enables the collection of customer consent for promotional communications.\nThe Checkout Session will determine whether to display an option to opt into promotional\ncommunication from the merchant depending on the customer‚Äôs locale. Only available to US merchants.',
              ),
            termsOfService: zod
              .enum(['none', 'required'])
              .describe(
                'Create Stripe checkout session consent collection terms of service.',
              )
              .optional()
              .describe(
                'If set to required, it requires customers to check a terms of service checkbox before being able to pay.\nThere must be a valid terms of service URL set in your Stripe Dashboard settings.\nhttps://dashboard.stripe.com/settings/public',
              ),
          })
          .describe(
            'Configure fields for the Checkout Session to gather active consent from customers.',
          )
          .optional()
          .describe(
            'Configure fields for the Checkout Session to gather active consent from customers.',
          ),
        currency: zod.coerce
          .string()
          .min(createStripeCheckoutSessionBodyOptionsOneCurrencyOneMin)
          .max(createStripeCheckoutSessionBodyOptionsOneCurrencyOneMax)
          .regex(createStripeCheckoutSessionBodyOptionsOneCurrencyOneRegExp)
          .describe(
            'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
          )
          .optional()
          .describe('Three-letter ISO currency code, in lowercase.'),
        customerUpdate: zod
          .object({
            address: zod
              .enum(['auto', 'never'])
              .describe(
                'Create Stripe checkout session customer update behavior.',
              )
              .optional()
              .describe(
                'Describes whether Checkout saves the billing address onto customer.address.\nTo always collect a full billing address, use billing_address_collection.\nDefaults to never.',
              ),
            name: zod
              .enum(['auto', 'never'])
              .describe(
                'Create Stripe checkout session customer update behavior.',
              )
              .optional()
              .describe(
                'Describes whether Checkout saves the name onto customer.name.\nDefaults to never.',
              ),
            shipping: zod
              .enum(['auto', 'never'])
              .describe(
                'Create Stripe checkout session customer update behavior.',
              )
              .optional()
              .describe(
                'Describes whether Checkout saves shipping information onto customer.shipping.\nTo collect shipping information, use shipping_address_collection.\nDefaults to never.',
              ),
          })
          .describe(
            'Controls what fields on Customer can be updated by the Checkout Session.',
          )
          .optional()
          .describe(
            'Controls what fields on Customer can be updated by the Checkout Session.',
          ),
        customText: zod
          .object({
            afterSubmit: zod
              .object({
                message: zod.coerce
                  .string()
                  .max(
                    createStripeCheckoutSessionBodyOptionsOneCustomTextOneAfterSubmitMessageMax,
                  )
                  .optional(),
              })
              .optional()
              .describe(
                'Custom text that should be displayed after the payment confirmation button.',
              ),
            shippingAddress: zod
              .object({
                message: zod.coerce
                  .string()
                  .max(
                    createStripeCheckoutSessionBodyOptionsOneCustomTextOneShippingAddressMessageMax,
                  )
                  .optional(),
              })
              .optional()
              .describe(
                'Custom text that should be displayed alongside shipping address collection.',
              ),
            submit: zod
              .object({
                message: zod.coerce
                  .string()
                  .max(
                    createStripeCheckoutSessionBodyOptionsOneCustomTextOneSubmitMessageMax,
                  )
                  .optional(),
              })
              .optional()
              .describe(
                'Custom text that should be displayed alongside the payment confirmation button.',
              ),
            termsOfServiceAcceptance: zod
              .object({
                message: zod.coerce
                  .string()
                  .max(
                    createStripeCheckoutSessionBodyOptionsOneCustomTextOneTermsOfServiceAcceptanceMessageMax,
                  )
                  .optional(),
              })
              .optional()
              .describe(
                'Custom text that should be displayed in place of the default terms of service agreement text.',
              ),
          })
          .describe('Stripe CheckoutSession.custom_text')
          .optional()
          .describe(
            'Display additional text for your customers using custom text.',
          ),
        expiresAt: zod.coerce
          .number()
          .optional()
          .describe(
            'The Epoch time in seconds at which the Checkout Session will expire.\nIt can be anywhere from 30 minutes to 24 hours after Checkout Session creation. By default, this value is 24 hours from creation.',
          ),
        locale: zod.coerce.string().optional(),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .optional()
          .describe(
            'Set of key-value pairs that you can attach to an object.\nThis can be useful for storing additional information about the object in a structured format.\nIndividual keys can be unset by posting an empty value to them.\nAll keys can be unset by posting an empty value to metadata.',
          ),
        paymentMethodTypes: zod
          .array(zod.coerce.string())
          .optional()
          .describe(
            'A list of the types of payment methods (e.g., card) this Checkout Session can accept.',
          ),
        redirectOnCompletion: zod
          .enum(['always', 'if_required', 'never'])
          .describe('Create Stripe checkout session redirect on completion.')
          .optional()
          .describe(
            'This parameter applies to ui_mode: embedded. Defaults to always.\nLearn more about the redirect behavior of embedded sessions at\nhttps://docs.stripe.com/payments/checkout/custom-success-page?payment-ui=embedded-form',
          ),
        returnURL: zod.coerce
          .string()
          .optional()
          .describe(
            'The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method‚Äôs app or site.\nThis parameter is required if ui_mode is embedded and redirect-based payment methods are enabled on the session.',
          ),
        successURL: zod.coerce
          .string()
          .optional()
          .describe(
            'The URL to which Stripe should send customers when payment or setup is complete.\nThis parameter is not allowed if ui_mode is embedded.\nIf you‚Äôd like to use information from the successful Checkout Session on your page, read the guide on customizing your success page:\nhttps://docs.stripe.com/payments/checkout/custom-success-page',
          ),
        taxIdCollection: zod
          .object({
            enabled: zod.coerce
              .boolean()
              .describe(
                'Enable tax ID collection during checkout. Defaults to false.',
              ),
            required: zod
              .enum(['if_supported', 'never'])
              .describe(
                'Create Stripe checkout session tax ID collection required.',
              )
              .optional()
              .describe(
                'Describes whether a tax ID is required during checkout. Defaults to never.',
              ),
          })
          .describe('Create Stripe checkout session tax ID collection.')
          .optional()
          .describe('Controls tax ID collection during checkout.'),
        uiMode: zod
          .enum(['embedded', 'hosted'])
          .describe('Stripe CheckoutSession.ui_mode')
          .optional()
          .describe('The UI mode of the Session. Defaults to hosted.'),
      })
      .describe(
        'Create Stripe checkout session options\nSee https://docs.stripe.com/api/checkout/sessions/create',
      )
      .describe('Options passed to Stripe when creating the checkout session.'),
    stripeCustomerId: zod.coerce
      .string()
      .optional()
      .describe(
        "Stripe customer ID.\nIf not provided OpenMeter creates a new Stripe customer or\nuses the OpenMeter customer's default Stripe customer ID.",
      ),
  })
  .describe('Create Stripe checkout session request.')

/**
 * Upserts a subject. Creates or updates subject.

If the subject doesn't exist, it will be created.
If the subject exists, it will be partially updated with the provided fields.

‚ö†Ô∏è __Deprecated__: Subjects as managable entities are being depracated, use customers with subject key usage attribution instead.
 * @deprecated
 * @summary Upsert subject
 */
export const UpsertSubjectBodyItem = zod
  .object({
    currentPeriodEnd: zod.coerce
      .date()
      .optional()
      .describe('The end of the current period for the subject.'),
    currentPeriodStart: zod.coerce
      .date()
      .optional()
      .describe('The start of the current period for the subject.'),
    displayName: zod.coerce
      .string()
      .nullish()
      .describe('A human-readable display name for the subject.'),
    key: zod.coerce
      .string()
      .describe(
        'A unique, human-readable identifier for the subject.\nThis is typically a database ID or a customer key.',
      ),
    metadata: zod
      .record(zod.string(), zod.unknown())
      .nullish()
      .describe('Metadata for the subject.'),
    stripeCustomerId: zod.coerce
      .string()
      .nullish()
      .describe('The Stripe customer ID for the subject.'),
  })
  .describe(
    'A subject is a unique identifier for a user or entity.\n\n‚ö†Ô∏è __Deprecated__: Subjects as managable entities are being depracated, use customers with subject key usage attribution instead.',
  )
export const UpsertSubjectBody = zod.array(UpsertSubjectBodyItem)

/**
 * Get subject by ID or key.

‚ö†Ô∏è __Deprecated__: Subjects as managable entities are being depracated, use customers with subject key usage attribution instead.
 * @deprecated
 * @summary Get subject
 */
export const GetSubjectParams = zod.object({
  subjectIdOrKey: zod.coerce.string(),
})

/**
 * Delete subject by ID or key.

‚ö†Ô∏è __Deprecated__: Subjects as managable entities are being depracated, use customers with subject key usage attribution instead.
 * @deprecated
 * @summary Delete subject
 */
export const DeleteSubjectParams = zod.object({
  subjectIdOrKey: zod.coerce.string(),
})

/**
 * OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).

- Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
- Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
- Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.

A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.

Once an entitlement is created you cannot modify it, only delete it.

‚ö†Ô∏è __Deprecated__: Use [`POST /api/v2/customers/{customerIdOrKey}/entitlements`](#tag/entitlements/post/api/v2/customers/{customerIdOrKey}/entitlements) instead.
 * @deprecated
 * @summary Create a subject entitlement
 */
export const CreateEntitlementParams = zod.object({
  subjectIdOrKey: zod.coerce.string(),
})

export const createEntitlementBodyOneFeatureKeyMax = 64 as const

export const createEntitlementBodyOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createEntitlementBodyOneFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createEntitlementBodyOneIsSoftLimitDefault = false as const
export const createEntitlementBodyOneIsUnlimitedDefault = false as const
export const createEntitlementBodyOneUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const createEntitlementBodyOneIssueAfterResetMin = 0 as const

export const createEntitlementBodyOneIssueAfterResetPriorityDefault = 1 as const
export const createEntitlementBodyOneIssueAfterResetPriorityMax = 255 as const

export const createEntitlementBodyOnePreserveOverageAtResetDefault =
  false as const
export const createEntitlementBodyTwoFeatureKeyMax = 64 as const

export const createEntitlementBodyTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createEntitlementBodyTwoFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createEntitlementBodyTwoUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const createEntitlementBodyThreeFeatureKeyMax = 64 as const

export const createEntitlementBodyThreeFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createEntitlementBodyThreeFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createEntitlementBodyThreeUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/

export const CreateEntitlementBody = zod
  .union([
    zod
      .object({
        featureId: zod.coerce
          .string()
          .regex(createEntitlementBodyOneFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(createEntitlementBodyOneFeatureKeyMax)
          .regex(createEntitlementBodyOneFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        isSoftLimit: zod.coerce
          .boolean()
          .default(createEntitlementBodyOneIsSoftLimitDefault)
          .describe(
            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
          ),
        issueAfterReset: zod.coerce
          .number()
          .min(createEntitlementBodyOneIssueAfterResetMin)
          .optional()
          .describe(
            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
          ),
        issueAfterResetPriority: zod.coerce
          .number()
          .min(1)
          .max(createEntitlementBodyOneIssueAfterResetPriorityMax)
          .default(createEntitlementBodyOneIssueAfterResetPriorityDefault)
          .describe('Defines the grant priority for the default grant.'),
        isUnlimited: zod.coerce
          .boolean()
          .default(createEntitlementBodyOneIsUnlimitedDefault)
          .describe(
            'Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.',
          ),
        measureUsageFrom: zod
          .union([
            zod
              .enum(['CURRENT_PERIOD_START', 'NOW'])
              .describe('Start of measurement options'),
            zod.coerce
              .date()
              .describe(
                '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
              ),
          ])
          .describe('Measure usage from')
          .optional()
          .describe(
            'Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        preserveOverageAtReset: zod.coerce
          .boolean()
          .default(createEntitlementBodyOnePreserveOverageAtResetDefault)
          .describe(
            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
          ),
        type: zod.enum(['metered']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    createEntitlementBodyOneUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inpurs for metered entitlement'),
    zod
      .object({
        config: zod.coerce
          .string()
          .describe(
            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
          ),
        featureId: zod.coerce
          .string()
          .regex(createEntitlementBodyTwoFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(createEntitlementBodyTwoFeatureKeyMax)
          .regex(createEntitlementBodyTwoFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        type: zod.enum(['static']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    createEntitlementBodyTwoUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .optional()
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inputs for static entitlement'),
    zod
      .object({
        featureId: zod.coerce
          .string()
          .regex(createEntitlementBodyThreeFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(createEntitlementBodyThreeFeatureKeyMax)
          .regex(createEntitlementBodyThreeFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        type: zod.enum(['boolean']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    createEntitlementBodyThreeUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .optional()
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inputs for boolean entitlement'),
  ])
  .describe('Create inputs for entitlement')

/**
 * List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/customers/{customerIdOrKey}/entitlements`](#tag/entitlements/get/api/v2/customers/{customerIdOrKey}/entitlements) instead.
 * @deprecated
 * @summary List subject entitlements
 */
export const ListSubjectEntitlementsParams = zod.object({
  subjectIdOrKey: zod.coerce.string(),
})

export const listSubjectEntitlementsQueryIncludeDeletedDefault = false as const

export const ListSubjectEntitlementsQueryParams = zod.object({
  includeDeleted: zod.coerce
    .boolean()
    .default(listSubjectEntitlementsQueryIncludeDeletedDefault),
})

/**
 * List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants`](#tag/entitlements/get/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants) instead.
 * @deprecated
 * @summary List subject entitlement grants
 */
export const ListEntitlementGrantsParams = zod.object({
  entitlementIdOrFeatureKey: zod.coerce.string(),
  subjectIdOrKey: zod.coerce.string(),
})

export const listEntitlementGrantsQueryIncludeDeletedDefault = false as const

export const ListEntitlementGrantsQueryParams = zod.object({
  includeDeleted: zod.coerce
    .boolean()
    .default(listEntitlementGrantsQueryIncludeDeletedDefault),
  orderBy: zod.enum(['id', 'createdAt', 'updatedAt']).optional(),
})

/**
 * Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.

A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.

Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.

Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).

Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))

Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.

‚ö†Ô∏è __Deprecated__: Use [`POST /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants`](#tag/entitlements/post/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants) instead.
 * @deprecated
 * @summary Create subject entitlement grant
 */
export const CreateGrantParams = zod.object({
  entitlementIdOrFeatureKey: zod.coerce.string(),
  subjectIdOrKey: zod.coerce.string(),
})

export const createGrantBodyAmountMin = 0 as const

export const createGrantBodyPriorityMax = 255 as const

export const createGrantBodyExpirationOneCountMax = 1000 as const

export const createGrantBodyMaxRolloverAmountDefault = 0 as const
export const createGrantBodyMinRolloverAmountDefault = 0 as const
export const createGrantBodyRecurrenceOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/

export const CreateGrantBody = zod
  .object({
    amount: zod.coerce
      .number()
      .min(createGrantBodyAmountMin)
      .describe('The amount to grant. Should be a positive number.'),
    effectiveAt: zod.coerce
      .date()
      .describe(
        'Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).',
      ),
    expiration: zod
      .object({
        count: zod.coerce
          .number()
          .min(1)
          .max(createGrantBodyExpirationOneCountMax)
          .describe('The number of time units in the expiration period.'),
        duration: zod
          .enum(['HOUR', 'DAY', 'WEEK', 'MONTH', 'YEAR'])
          .describe('The expiration duration enum')
          .describe('The unit of time for the expiration period.'),
      })
      .describe('The grant expiration definition')
      .describe('The grant expiration definition'),
    maxRolloverAmount: zod.coerce
      .number()
      .default(createGrantBodyMaxRolloverAmountDefault)
      .describe(
        'Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .optional()
      .describe('The grant metadata.'),
    minRolloverAmount: zod.coerce
      .number()
      .default(createGrantBodyMinRolloverAmountDefault)
      .describe(
        'Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))',
      ),
    priority: zod.coerce
      .number()
      .min(1)
      .max(createGrantBodyPriorityMax)
      .optional()
      .describe(
        'The priority of the grant. Grants with higher priority are applied first.\nPriority is a positive decimal numbers. With lower numbers indicating higher importance.\nFor example, a priority of 1 is more urgent than a priority of 2.\nWhen there are several grants available for the same subject, the system selects the grant with the highest priority.\nIn cases where grants share the same priority level, the grant closest to its expiration will be used first.\nIn the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.',
      ),
    recurrence: zod
      .object({
        anchor: zod.coerce
          .date()
          .optional()
          .describe('A date-time anchor to base the recurring period on.'),
        interval: zod
          .union([
            zod.coerce
              .string()
              .regex(createGrantBodyRecurrenceOneIntervalOneOneRegExp),
            zod
              .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
              .describe(
                'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
              ),
          ])
          .describe('Period duration for the recurrence')
          .describe('The unit of time for the interval.'),
      })
      .describe('Recurring period with an interval and an anchor.')
      .optional()
      .describe('The subject of the grant.'),
  })
  .describe('The grant creation input.')

/**
 * Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided subject-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.

This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime.

‚ö†Ô∏è __Deprecated__: Use [`PUT /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override`](#tag/entitlements/put/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override) instead.
 * @deprecated
 * @summary Override subject entitlement
 */
export const OverrideEntitlementParams = zod.object({
  entitlementIdOrFeatureKey: zod.coerce.string(),
  subjectIdOrKey: zod.coerce.string(),
})

export const overrideEntitlementBodyOneFeatureKeyMax = 64 as const

export const overrideEntitlementBodyOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const overrideEntitlementBodyOneFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const overrideEntitlementBodyOneIsSoftLimitDefault = false as const
export const overrideEntitlementBodyOneIsUnlimitedDefault = false as const
export const overrideEntitlementBodyOneUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const overrideEntitlementBodyOneIssueAfterResetMin = 0 as const

export const overrideEntitlementBodyOneIssueAfterResetPriorityDefault =
  1 as const
export const overrideEntitlementBodyOneIssueAfterResetPriorityMax = 255 as const

export const overrideEntitlementBodyOnePreserveOverageAtResetDefault =
  false as const
export const overrideEntitlementBodyTwoFeatureKeyMax = 64 as const

export const overrideEntitlementBodyTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const overrideEntitlementBodyTwoFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const overrideEntitlementBodyTwoUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const overrideEntitlementBodyThreeFeatureKeyMax = 64 as const

export const overrideEntitlementBodyThreeFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const overrideEntitlementBodyThreeFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const overrideEntitlementBodyThreeUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/

export const OverrideEntitlementBody = zod
  .union([
    zod
      .object({
        featureId: zod.coerce
          .string()
          .regex(overrideEntitlementBodyOneFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(overrideEntitlementBodyOneFeatureKeyMax)
          .regex(overrideEntitlementBodyOneFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        isSoftLimit: zod.coerce
          .boolean()
          .default(overrideEntitlementBodyOneIsSoftLimitDefault)
          .describe(
            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
          ),
        issueAfterReset: zod.coerce
          .number()
          .min(overrideEntitlementBodyOneIssueAfterResetMin)
          .optional()
          .describe(
            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
          ),
        issueAfterResetPriority: zod.coerce
          .number()
          .min(1)
          .max(overrideEntitlementBodyOneIssueAfterResetPriorityMax)
          .default(overrideEntitlementBodyOneIssueAfterResetPriorityDefault)
          .describe('Defines the grant priority for the default grant.'),
        isUnlimited: zod.coerce
          .boolean()
          .default(overrideEntitlementBodyOneIsUnlimitedDefault)
          .describe(
            'Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.',
          ),
        measureUsageFrom: zod
          .union([
            zod
              .enum(['CURRENT_PERIOD_START', 'NOW'])
              .describe('Start of measurement options'),
            zod.coerce
              .date()
              .describe(
                '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
              ),
          ])
          .describe('Measure usage from')
          .optional()
          .describe(
            'Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        preserveOverageAtReset: zod.coerce
          .boolean()
          .default(overrideEntitlementBodyOnePreserveOverageAtResetDefault)
          .describe(
            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
          ),
        type: zod.enum(['metered']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    overrideEntitlementBodyOneUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inpurs for metered entitlement'),
    zod
      .object({
        config: zod.coerce
          .string()
          .describe(
            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
          ),
        featureId: zod.coerce
          .string()
          .regex(overrideEntitlementBodyTwoFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(overrideEntitlementBodyTwoFeatureKeyMax)
          .regex(overrideEntitlementBodyTwoFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        type: zod.enum(['static']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    overrideEntitlementBodyTwoUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .optional()
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inputs for static entitlement'),
    zod
      .object({
        featureId: zod.coerce
          .string()
          .regex(overrideEntitlementBodyThreeFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(overrideEntitlementBodyThreeFeatureKeyMax)
          .regex(overrideEntitlementBodyThreeFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        type: zod.enum(['boolean']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    overrideEntitlementBodyThreeUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .optional()
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inputs for boolean entitlement'),
  ])
  .describe('Create inputs for entitlement')

/**
 * This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.

For convenience reasons, /value works with both entitlementId and featureKey.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value`](#tag/entitlements/get/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value) instead.
 * @deprecated
 * @summary Get subject entitlement value
 */
export const GetEntitlementValueParams = zod.object({
  entitlementIdOrFeatureKey: zod.coerce.string(),
  subjectIdOrKey: zod.coerce.string(),
})

export const GetEntitlementValueQueryParams = zod.object({
  time: zod.coerce.date().optional(),
})

/**
 * Get entitlement by id. For checking entitlement access, use the /value endpoint instead.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}`](#tag/entitlements/get/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}) instead.
 * @deprecated
 * @summary Get subject entitlement
 */
export const GetEntitlementParams = zod.object({
  entitlementId: zod.coerce.string(),
  subjectIdOrKey: zod.coerce.string(),
})

/**
 * Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.

‚ö†Ô∏è __Deprecated__: Use [`DELETE /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}`](#tag/entitlements/delete/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}) instead.
 * @deprecated
 * @summary Delete subject entitlement
 */
export const DeleteEntitlementParams = zod.object({
  entitlementId: zod.coerce.string(),
  subjectIdOrKey: zod.coerce.string(),
})

/**
 * Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.

BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.

WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/history`](#tag/entitlements/get/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/history) instead.
 * @deprecated
 * @summary Get subject entitlement history
 */
export const GetEntitlementHistoryParams = zod.object({
  entitlementId: zod.coerce.string(),
  subjectIdOrKey: zod.coerce.string(),
})

export const getEntitlementHistoryQueryWindowTimeZoneDefault = 'UTC' as const

export const GetEntitlementHistoryQueryParams = zod.object({
  from: zod.coerce
    .date()
    .optional()
    .describe(
      'Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to the last reset. Gets truncated to the granularity of the underlying meter.',
    ),
  to: zod.coerce
    .date()
    .optional()
    .describe(
      'End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.\nIf not now then gets truncated to the granularity of the underlying meter.',
    ),
  windowSize: zod
    .enum(['MINUTE', 'HOUR', 'DAY', 'MONTH'])
    .describe('Windowsize'),
  windowTimeZone: zod.coerce
    .string()
    .default(getEntitlementHistoryQueryWindowTimeZoneDefault)
    .describe('The timezone used when calculating the windows.'),
})

/**
 * Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.

Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.

‚ö†Ô∏è __Deprecated__: Use [`POST /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/reset`](#tag/entitlements/post/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/reset) instead.
 * @deprecated
 * @summary Reset subject entitlement
 */
export const ResetEntitlementUsageParams = zod.object({
  entitlementId: zod.coerce.string(),
  subjectIdOrKey: zod.coerce.string(),
})

export const ResetEntitlementUsageBody = zod
  .object({
    effectiveAt: zod.coerce
      .date()
      .optional()
      .describe(
        'The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.',
      ),
    preserveOverage: zod.coerce
      .boolean()
      .optional()
      .describe(
        "Determines whether the overage is preserved or forgiven, overriding the entitlement's default behavior.\n- If true, the overage is preserved.\n- If false, the overage is forgiven.",
      ),
    retainAnchor: zod.coerce
      .boolean()
      .optional()
      .describe(
        'Determines whether the usage period anchor is retained or reset to the effectiveAt time.\n- If true, the usage period anchor is retained.\n- If false, the usage period anchor is reset to the effectiveAt time.',
      ),
  })
  .describe('Reset parameters')

/**
 * @summary Create subscription
 */
export const createSubscriptionBodyOnePlanOneKeyMax = 64 as const

export const createSubscriptionBodyOnePlanOneKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/

export const createSubscriptionBodyOneTimingDefault = 'immediate' as const
export const createSubscriptionBodyOneCustomerIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createSubscriptionBodyOneCustomerKeyMax = 256 as const

export const createSubscriptionBodyTwoCustomPlanOneOneNameMax = 256 as const

export const createSubscriptionBodyTwoCustomPlanOneOneDescriptionMax =
  1024 as const

export const createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMin =
  3 as const
export const createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMax =
  3 as const

export const createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneRegExp =
  /^[A-Z]{3}$/
export const createSubscriptionBodyTwoCustomPlanOneOneCurrencyDefault =
  'USD' as const
export const createSubscriptionBodyTwoCustomPlanOneOneProRatingConfigOneEnabledDefault =
  true as const
export const createSubscriptionBodyTwoCustomPlanOneOneProRatingConfigOneModeDefault =
  'prorate_prices' as const
export const createSubscriptionBodyTwoCustomPlanOneOneProRatingConfigDefault = {
  enabled: true,
  mode: 'prorate_prices',
} as const
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyMax =
  64 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemNameMax =
  256 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemDescriptionMax =
  1024 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyMax =
  64 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneNameMax =
  256 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDescriptionMax =
  1024 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyMax =
  64 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOnePaymentTermDefault =
  'in_advance' as const
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyMax =
  64 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoNameMax =
  256 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDescriptionMax =
  1024 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyMax =
  64 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault =
  'in_advance' as const
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault =
  '1' as const
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const createSubscriptionBodyTwoTimingDefault = 'immediate' as const
export const createSubscriptionBodyTwoCustomerIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createSubscriptionBodyTwoCustomerKeyMax = 256 as const

export const CreateSubscriptionBody = zod
  .union([
    zod
      .object({
        alignment: zod
          .object({
            billablesMustAlign: zod.coerce
              .boolean()
              .optional()
              .describe(
                "Whether all Billable items and RateCards must align.\nAlignment means the Price's BillingCadence must align for both duration and anchor time.",
              ),
          })
          .describe('Alignment configuration for a plan or subscription.')
          .optional()
          .describe('What alignment settings the subscription should have.'),
        billingAnchor: zod.coerce
          .date()
          .optional()
          .describe(
            'The billing anchor of the subscription. The provided date will be normalized according to the billing cadence to the nearest recurrence before start time. If not provided, the subscription start time will be used.',
          ),
        customerId: zod.coerce
          .string()
          .regex(createSubscriptionBodyOneCustomerIdRegExp)
          .optional()
          .describe(
            'The ID of the customer. Provide either the key or ID. Has presedence over the key.',
          ),
        customerKey: zod.coerce
          .string()
          .min(1)
          .max(createSubscriptionBodyOneCustomerKeyMax)
          .optional()
          .describe('The key of the customer. Provide either the key or ID.'),
        description: zod.coerce
          .string()
          .optional()
          .describe('Description for the Subscription.'),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Arbitrary metadata associated with the subscription.'),
        name: zod.coerce
          .string()
          .optional()
          .describe(
            'The name of the Subscription. If not provided the plan name is used.',
          ),
        plan: zod
          .object({
            key: zod.coerce
              .string()
              .min(1)
              .max(createSubscriptionBodyOnePlanOneKeyMax)
              .regex(createSubscriptionBodyOnePlanOneKeyRegExp)
              .describe('The plan key.'),
            version: zod.coerce
              .number()
              .optional()
              .describe('The plan version.'),
          })
          .describe(
            'References an exact plan defaulting to the current active version.',
          )
          .describe('The plan reference to change to.'),
        startingPhase: zod.coerce
          .string()
          .min(1)
          .optional()
          .describe(
            'The key of the phase to start the subscription in.\nIf not provided, the subscription will start in the first phase of the plan.',
          ),
        timing: zod
          .union([
            zod
              .enum(['immediate', 'next_billing_cycle'])
              .describe(
                'Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.',
              ),
            zod.coerce
              .date()
              .describe(
                '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
              ),
          ])
          .describe(
            'Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.',
          )
          .default(createSubscriptionBodyOneTimingDefault)
          .describe(
            'Timing configuration for the change, when the change should take effect.\nThe default is immediate.',
          ),
      })
      .describe('Create subscription based on plan.'),
    zod
      .object({
        billingAnchor: zod.coerce
          .date()
          .optional()
          .describe(
            'The billing anchor of the subscription. The provided date will be normalized according to the billing cadence to the nearest recurrence before start time. If not provided, the subscription start time will be used.',
          ),
        customerId: zod.coerce
          .string()
          .regex(createSubscriptionBodyTwoCustomerIdRegExp)
          .optional()
          .describe(
            'The ID of the customer. Provide either the key or ID. Has presedence over the key.',
          ),
        customerKey: zod.coerce
          .string()
          .min(1)
          .max(createSubscriptionBodyTwoCustomerKeyMax)
          .optional()
          .describe('The key of the customer. Provide either the key or ID.'),
        customPlan: zod
          .object({
            alignment: zod
              .object({
                billablesMustAlign: zod.coerce
                  .boolean()
                  .optional()
                  .describe(
                    "Whether all Billable items and RateCards must align.\nAlignment means the Price's BillingCadence must align for both duration and anchor time.",
                  ),
              })
              .describe('Alignment configuration for a plan or subscription.')
              .optional()
              .describe('Alignment configuration for the plan.'),
            billingCadence: zod.coerce
              .string()
              .describe(
                'The default billing cadence for subscriptions using this plan.\nDefines how often customers are billed using ISO8601 duration format.\nExamples: "P1M" (monthly), "P3M" (quarterly), "P1Y" (annually).',
              ),
            currency: zod.coerce
              .string()
              .min(createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMin)
              .max(createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMax)
              .regex(createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneRegExp)
              .describe(
                'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
              )
              .describe('The currency code of the plan.'),
            description: zod.coerce
              .string()
              .max(createSubscriptionBodyTwoCustomPlanOneOneDescriptionMax)
              .optional()
              .describe(
                'Optional description of the resource. Maximum 1024 characters.',
              ),
            metadata: zod
              .record(zod.string(), zod.coerce.string())
              .describe(
                'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
              )
              .nullish()
              .describe('Additional metadata for the resource.'),
            name: zod.coerce
              .string()
              .min(1)
              .max(createSubscriptionBodyTwoCustomPlanOneOneNameMax)
              .describe(
                'Human-readable name for the resource. Between 1 and 256 characters.',
              ),
            phases: zod
              .array(
                zod
                  .object({
                    description: zod.coerce
                      .string()
                      .max(
                        createSubscriptionBodyTwoCustomPlanOneOnePhasesItemDescriptionMax,
                      )
                      .optional()
                      .describe(
                        'Optional description of the resource. Maximum 1024 characters.',
                      ),
                    duration: zod.coerce
                      .string()
                      .nullable()
                      .describe('The duration of the phase.'),
                    key: zod.coerce
                      .string()
                      .min(1)
                      .max(
                        createSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyMax,
                      )
                      .regex(
                        createSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyRegExp,
                      )
                      .describe('A semi-unique identifier for the resource.'),
                    metadata: zod
                      .record(zod.string(), zod.coerce.string())
                      .describe(
                        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                      )
                      .nullish()
                      .describe('Additional metadata for the resource.'),
                    name: zod.coerce
                      .string()
                      .min(1)
                      .max(
                        createSubscriptionBodyTwoCustomPlanOneOnePhasesItemNameMax,
                      )
                      .describe(
                        'Human-readable name for the resource. Between 1 and 256 characters.',
                      ),
                    rateCards: zod
                      .array(
                        zod
                          .union([
                            zod
                              .object({
                                billingCadence: zod.coerce
                                  .string()
                                  .nullable()
                                  .describe(
                                    'The billing cadence of the rate card.\nWhen null it means it is a one time fee.',
                                  ),
                                description: zod.coerce
                                  .string()
                                  .max(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDescriptionMax,
                                  )
                                  .optional()
                                  .describe(
                                    'Optional description of the resource. Maximum 1024 characters.',
                                  ),
                                discounts: zod
                                  .object({
                                    percentage: zod
                                      .object({
                                        percentage: zod.coerce
                                          .number()
                                          .describe(
                                            'Numeric representation of a percentage\n\n50% is represented as 50',
                                          )
                                          .describe(
                                            'The percentage of the discount.',
                                          ),
                                      })
                                      .describe('Percentage discount.')
                                      .optional()
                                      .describe('The percentage discount.'),
                                    usage: zod
                                      .object({
                                        quantity: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The quantity of the usage discount.\n\nMust be positive.',
                                          ),
                                      })
                                      .describe(
                                        'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                                      )
                                      .optional()
                                      .describe('The usage discount.'),
                                  })
                                  .describe('Discount by type on a price')
                                  .optional()
                                  .describe(
                                    'The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.',
                                  ),
                                entitlementTemplate: zod
                                  .union([
                                    zod
                                      .object({
                                        isSoftLimit: zod.coerce
                                          .boolean()
                                          .default(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault,
                                          )
                                          .describe(
                                            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                                          ),
                                        issueAfterReset: zod.coerce
                                          .number()
                                          .min(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin,
                                          )
                                          .optional()
                                          .describe(
                                            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                                          ),
                                        issueAfterResetPriority: zod.coerce
                                          .number()
                                          .min(1)
                                          .max(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                                          )
                                          .default(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                                          )
                                          .describe(
                                            'Defines the grant priority for the default grant.',
                                          ),
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        preserveOverageAtReset: zod.coerce
                                          .boolean()
                                          .default(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                                          )
                                          .describe(
                                            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                                          ),
                                        type: zod.enum(['metered']),
                                        usagePeriod: zod.coerce
                                          .string()
                                          .optional()
                                          .describe(
                                            'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                                          ),
                                      })
                                      .describe(
                                        'The entitlement template with a metered entitlement.',
                                      ),
                                    zod
                                      .object({
                                        config: zod.coerce
                                          .string()
                                          .describe(
                                            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                                          ),
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        type: zod.enum(['static']),
                                      })
                                      .describe(
                                        'Entitlement template of a static entitlement.',
                                      ),
                                    zod
                                      .object({
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        type: zod.enum(['boolean']),
                                      })
                                      .describe(
                                        'Entitlement template of a boolean entitlement.',
                                      ),
                                  ])
                                  .describe(
                                    'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                                  )
                                  .optional()
                                  .describe(
                                    'The entitlement of the rate card.\nOnly available when featureKey is set.',
                                  ),
                                featureKey: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyMax,
                                  )
                                  .regex(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyRegExp,
                                  )
                                  .optional()
                                  .describe(
                                    'The feature the customer is entitled to use.',
                                  ),
                                key: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyMax,
                                  )
                                  .regex(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyRegExp,
                                  )
                                  .describe(
                                    'A semi-unique identifier for the resource.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .nullish()
                                  .describe(
                                    'Additional metadata for the resource.',
                                  ),
                                name: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneNameMax,
                                  )
                                  .describe(
                                    'Human-readable name for the resource. Between 1 and 256 characters.',
                                  ),
                                price: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the flat price.',
                                      ),
                                    paymentTerm: zod
                                      .enum(['in_advance', 'in_arrears'])
                                      .describe(
                                        'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                                      )
                                      .default(
                                        createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOnePaymentTermDefault,
                                      )
                                      .describe(
                                        'The payment term of the flat price.\nDefaults to in advance.',
                                      ),
                                    type: zod.enum(['flat']),
                                  })
                                  .describe('Flat price with payment term.')
                                  .nullable()
                                  .describe(
                                    'The price of the rate card.\nWhen null, the feature or service is free.',
                                  ),
                                taxConfig: zod
                                  .object({
                                    behavior: zod
                                      .enum(['inclusive', 'exclusive'])
                                      .describe(
                                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                                      )
                                      .optional()
                                      .describe(
                                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                                      ),
                                    customInvoicing: zod
                                      .object({
                                        code: zod.coerce
                                          .string()
                                          .describe(
                                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                                          ),
                                      })
                                      .describe('Custom invoicing tax config.')
                                      .optional()
                                      .describe('Custom invoicing tax config.'),
                                    stripe: zod
                                      .object({
                                        code: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp,
                                          )
                                          .describe(
                                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                                          ),
                                      })
                                      .describe('The tax config for Stripe.')
                                      .optional()
                                      .describe('Stripe tax config.'),
                                  })
                                  .describe(
                                    'Set of provider specific tax configs.',
                                  )
                                  .optional()
                                  .describe(
                                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                                  ),
                                type: zod.enum(['flat_fee']),
                              })
                              .describe(
                                'A flat fee rate card defines a one-time purchase or a recurring fee.',
                              ),
                            zod
                              .object({
                                billingCadence: zod.coerce
                                  .string()
                                  .describe(
                                    'The billing cadence of the rate card.',
                                  ),
                                description: zod.coerce
                                  .string()
                                  .max(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDescriptionMax,
                                  )
                                  .optional()
                                  .describe(
                                    'Optional description of the resource. Maximum 1024 characters.',
                                  ),
                                discounts: zod
                                  .object({
                                    percentage: zod
                                      .object({
                                        percentage: zod.coerce
                                          .number()
                                          .describe(
                                            'Numeric representation of a percentage\n\n50% is represented as 50',
                                          )
                                          .describe(
                                            'The percentage of the discount.',
                                          ),
                                      })
                                      .describe('Percentage discount.')
                                      .optional()
                                      .describe('The percentage discount.'),
                                    usage: zod
                                      .object({
                                        quantity: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The quantity of the usage discount.\n\nMust be positive.',
                                          ),
                                      })
                                      .describe(
                                        'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                                      )
                                      .optional()
                                      .describe('The usage discount.'),
                                  })
                                  .describe('Discount by type on a price')
                                  .optional()
                                  .describe(
                                    'The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.',
                                  ),
                                entitlementTemplate: zod
                                  .union([
                                    zod
                                      .object({
                                        isSoftLimit: zod.coerce
                                          .boolean()
                                          .default(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault,
                                          )
                                          .describe(
                                            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                                          ),
                                        issueAfterReset: zod.coerce
                                          .number()
                                          .min(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin,
                                          )
                                          .optional()
                                          .describe(
                                            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                                          ),
                                        issueAfterResetPriority: zod.coerce
                                          .number()
                                          .min(1)
                                          .max(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                                          )
                                          .default(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                                          )
                                          .describe(
                                            'Defines the grant priority for the default grant.',
                                          ),
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        preserveOverageAtReset: zod.coerce
                                          .boolean()
                                          .default(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                                          )
                                          .describe(
                                            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                                          ),
                                        type: zod.enum(['metered']),
                                        usagePeriod: zod.coerce
                                          .string()
                                          .optional()
                                          .describe(
                                            'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                                          ),
                                      })
                                      .describe(
                                        'The entitlement template with a metered entitlement.',
                                      ),
                                    zod
                                      .object({
                                        config: zod.coerce
                                          .string()
                                          .describe(
                                            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                                          ),
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        type: zod.enum(['static']),
                                      })
                                      .describe(
                                        'Entitlement template of a static entitlement.',
                                      ),
                                    zod
                                      .object({
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        type: zod.enum(['boolean']),
                                      })
                                      .describe(
                                        'Entitlement template of a boolean entitlement.',
                                      ),
                                  ])
                                  .describe(
                                    'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                                  )
                                  .optional()
                                  .describe(
                                    'The entitlement of the rate card.\nOnly available when featureKey is set.',
                                  ),
                                featureKey: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyMax,
                                  )
                                  .regex(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyRegExp,
                                  )
                                  .optional()
                                  .describe(
                                    'The feature the customer is entitled to use.',
                                  ),
                                key: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyMax,
                                  )
                                  .regex(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyRegExp,
                                  )
                                  .describe(
                                    'A semi-unique identifier for the resource.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .nullish()
                                  .describe(
                                    'Additional metadata for the resource.',
                                  ),
                                name: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoNameMax,
                                  )
                                  .describe(
                                    'Human-readable name for the resource. Between 1 and 256 characters.',
                                  ),
                                price: zod
                                  .union([
                                    zod
                                      .object({
                                        amount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The amount of the flat price.',
                                          ),
                                        paymentTerm: zod
                                          .enum(['in_advance', 'in_arrears'])
                                          .describe(
                                            'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                                          )
                                          .default(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault,
                                          )
                                          .describe(
                                            'The payment term of the flat price.\nDefaults to in advance.',
                                          ),
                                        type: zod.enum(['flat']),
                                      })
                                      .describe(
                                        'Flat price with payment term.',
                                      ),
                                    zod
                                      .object({
                                        amount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The amount of the unit price.',
                                          ),
                                        maximumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is limited to spend at most the amount.',
                                          ),
                                        minimumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is committed to spend at least the amount.',
                                          ),
                                        type: zod.enum(['unit']),
                                      })
                                      .describe(
                                        'Unit price with spend commitments.',
                                      ),
                                    zod
                                      .object({
                                        maximumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is limited to spend at most the amount.',
                                          ),
                                        minimumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is committed to spend at least the amount.',
                                          ),
                                        mode: zod
                                          .enum(['volume', 'graduated'])
                                          .describe(
                                            'The mode of the tiered price.',
                                          )
                                          .describe(
                                            'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                                          ),
                                        tiers: zod
                                          .array(
                                            zod
                                              .object({
                                                flatPrice: zod
                                                  .object({
                                                    amount: zod.coerce
                                                      .string()
                                                      .regex(
                                                        createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                                      )
                                                      .describe(
                                                        'Numeric represents an arbitrary precision number.',
                                                      )
                                                      .describe(
                                                        'The amount of the flat price.',
                                                      ),
                                                    type: zod
                                                      .enum(['flat'])
                                                      .describe(
                                                        'The type of the price.',
                                                      ),
                                                  })
                                                  .describe('Flat price.')
                                                  .nullable()
                                                  .describe(
                                                    'The flat price component of the tier.',
                                                  ),
                                                unitPrice: zod
                                                  .object({
                                                    amount: zod.coerce
                                                      .string()
                                                      .regex(
                                                        createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                                      )
                                                      .describe(
                                                        'Numeric represents an arbitrary precision number.',
                                                      )
                                                      .describe(
                                                        'The amount of the unit price.',
                                                      ),
                                                    type: zod
                                                      .enum(['unit'])
                                                      .describe(
                                                        'The type of the price.',
                                                      ),
                                                  })
                                                  .describe('Unit price.')
                                                  .nullable()
                                                  .describe(
                                                    'The unit price component of the tier.',
                                                  ),
                                                upToAmount: zod.coerce
                                                  .string()
                                                  .regex(
                                                    createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp,
                                                  )
                                                  .describe(
                                                    'Numeric represents an arbitrary precision number.',
                                                  )
                                                  .optional()
                                                  .describe(
                                                    'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                                                  ),
                                              })
                                              .describe(
                                                'A price tier.\nAt least one price component is required in each tier.',
                                              ),
                                          )
                                          .min(1)
                                          .describe(
                                            'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                                          ),
                                        type: zod.enum(['tiered']),
                                      })
                                      .describe(
                                        'Tiered price with spend commitments.',
                                      ),
                                    zod
                                      .object({
                                        maximumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is limited to spend at most the amount.',
                                          ),
                                        minimumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is committed to spend at least the amount.',
                                          ),
                                        multiplier: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .default(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault,
                                          )
                                          .describe(
                                            'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                                          ),
                                        type: zod.enum(['dynamic']),
                                      })
                                      .describe(
                                        'Dynamic price with spend commitments.',
                                      ),
                                    zod
                                      .object({
                                        amount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The price of one package.',
                                          ),
                                        maximumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is limited to spend at most the amount.',
                                          ),
                                        minimumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is committed to spend at least the amount.',
                                          ),
                                        quantityPerPackage: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The quantity per package.',
                                          ),
                                        type: zod.enum(['package']),
                                      })
                                      .describe(
                                        'Package price with spend commitments.',
                                      ),
                                  ])
                                  .describe(
                                    'The price of the usage based rate card.',
                                  )
                                  .nullable()
                                  .describe(
                                    'The price of the rate card.\nWhen null, the feature or service is free.',
                                  ),
                                taxConfig: zod
                                  .object({
                                    behavior: zod
                                      .enum(['inclusive', 'exclusive'])
                                      .describe(
                                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                                      )
                                      .optional()
                                      .describe(
                                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                                      ),
                                    customInvoicing: zod
                                      .object({
                                        code: zod.coerce
                                          .string()
                                          .describe(
                                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                                          ),
                                      })
                                      .describe('Custom invoicing tax config.')
                                      .optional()
                                      .describe('Custom invoicing tax config.'),
                                    stripe: zod
                                      .object({
                                        code: zod.coerce
                                          .string()
                                          .regex(
                                            createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp,
                                          )
                                          .describe(
                                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                                          ),
                                      })
                                      .describe('The tax config for Stripe.')
                                      .optional()
                                      .describe('Stripe tax config.'),
                                  })
                                  .describe(
                                    'Set of provider specific tax configs.',
                                  )
                                  .optional()
                                  .describe(
                                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                                  ),
                                type: zod.enum(['usage_based']),
                              })
                              .describe(
                                'A usage-based rate card defines a price based on usage.',
                              ),
                          ])
                          .describe(
                            'A rate card defines the pricing and entitlement of a feature or service.',
                          ),
                      )
                      .describe('The rate cards of the plan.'),
                  })
                  .describe(
                    "The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.",
                  ),
              )
              .min(1)
              .describe(
                "The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.\nA phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.",
              ),
            proRatingConfig: zod
              .object({
                enabled: zod.coerce
                  .boolean()
                  .describe('Whether pro-rating is enabled for this plan.'),
                mode: zod
                  .enum(['prorate_prices'])
                  .describe(
                    'Pro-rating mode options for handling billing period changes.',
                  )
                  .describe(
                    'How to handle pro-rating for billing period changes.',
                  ),
              })
              .describe('Configuration for pro-rating behavior.')
              .default(
                createSubscriptionBodyTwoCustomPlanOneOneProRatingConfigDefault,
              )
              .describe(
                'Default pro-rating configuration for subscriptions using this plan.',
              ),
          })
          .describe('The template for omitting properties.')
          .describe(
            'Plan input for custom subscription creation (without key and version).',
          )
          .describe(
            'The custom plan description which defines the Subscription.',
          ),
        timing: zod
          .union([
            zod
              .enum(['immediate', 'next_billing_cycle'])
              .describe(
                'Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.',
              ),
            zod.coerce
              .date()
              .describe(
                '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
              ),
          ])
          .describe(
            'Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.',
          )
          .default(createSubscriptionBodyTwoTimingDefault)
          .describe(
            'Timing configuration for the change, when the change should take effect.\nThe default is immediate.',
          ),
      })
      .describe('Create a custom subscription.'),
  ])
  .describe('Create a subscription.')

/**
 * @summary Get subscription
 */
export const getSubscriptionPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetSubscriptionParams = zod.object({
  subscriptionId: zod.coerce
    .string()
    .regex(getSubscriptionPathSubscriptionIdRegExp),
})

export const GetSubscriptionQueryParams = zod.object({
  at: zod.coerce
    .date()
    .optional()
    .describe(
      'The time at which the subscription should be queried. If not provided the current time is used.',
    ),
})

/**
 * Batch processing commands for manipulating running subscriptions.
The key format is `/phases/{phaseKey}` or `/phases/{phaseKey}/items/{itemKey}`.
 * @summary Edit subscription
 */
export const editSubscriptionPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const EditSubscriptionParams = zod.object({
  subscriptionId: zod.coerce
    .string()
    .regex(editSubscriptionPathSubscriptionIdRegExp),
})

export const editSubscriptionBodyCustomizationsItemOneRateCardOneKeyMax =
  64 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardOneKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const editSubscriptionBodyCustomizationsItemOneRateCardOneNameMax =
  256 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardOneDescriptionMax =
  1024 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardOneFeatureKeyMax =
  64 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const editSubscriptionBodyCustomizationsItemOneRateCardOneTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const editSubscriptionBodyCustomizationsItemOneRateCardOnePriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardOnePriceOnePaymentTermDefault =
  'in_advance' as const
export const editSubscriptionBodyCustomizationsItemOneRateCardOneDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoKeyMax =
  64 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoNameMax =
  256 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoDescriptionMax =
  1024 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoFeatureKeyMax =
  64 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneOnePaymentTermDefault =
  'in_advance' as const
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMultiplierDefault =
  '1' as const
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemThreePhaseDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const editSubscriptionBodyCustomizationsItemThreePhaseKeyMax =
  64 as const

export const editSubscriptionBodyCustomizationsItemThreePhaseKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const editSubscriptionBodyCustomizationsMax = 100 as const

export const EditSubscriptionBody = zod
  .object({
    customizations: zod
      .array(
        zod
          .union([
            zod
              .object({
                op: zod.enum(['add_item']),
                phaseKey: zod.coerce.string(),
                rateCard: zod
                  .union([
                    zod
                      .object({
                        billingCadence: zod.coerce
                          .string()
                          .nullable()
                          .describe(
                            'The billing cadence of the rate card.\nWhen null it means it is a one time fee.',
                          ),
                        description: zod.coerce
                          .string()
                          .max(
                            editSubscriptionBodyCustomizationsItemOneRateCardOneDescriptionMax,
                          )
                          .optional()
                          .describe(
                            'Optional description of the resource. Maximum 1024 characters.',
                          ),
                        discounts: zod
                          .object({
                            percentage: zod
                              .object({
                                percentage: zod.coerce
                                  .number()
                                  .describe(
                                    'Numeric representation of a percentage\n\n50% is represented as 50',
                                  )
                                  .describe('The percentage of the discount.'),
                              })
                              .describe('Percentage discount.')
                              .optional()
                              .describe('The percentage discount.'),
                            usage: zod
                              .object({
                                quantity: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardOneDiscountsOneUsageOneQuantityOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe(
                                    'The quantity of the usage discount.\n\nMust be positive.',
                                  ),
                              })
                              .describe(
                                'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                              )
                              .optional()
                              .describe('The usage discount.'),
                          })
                          .describe('Discount by type on a price')
                          .optional()
                          .describe(
                            'The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.',
                          ),
                        entitlementTemplate: zod
                          .union([
                            zod
                              .object({
                                isSoftLimit: zod.coerce
                                  .boolean()
                                  .default(
                                    editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIsSoftLimitDefault,
                                  )
                                  .describe(
                                    'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                                  ),
                                issueAfterReset: zod.coerce
                                  .number()
                                  .min(
                                    editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetMin,
                                  )
                                  .optional()
                                  .describe(
                                    'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                                  ),
                                issueAfterResetPriority: zod.coerce
                                  .number()
                                  .min(1)
                                  .max(
                                    editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                                  )
                                  .default(
                                    editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                                  )
                                  .describe(
                                    'Defines the grant priority for the default grant.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                preserveOverageAtReset: zod.coerce
                                  .boolean()
                                  .default(
                                    editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                                  )
                                  .describe(
                                    'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                                  ),
                                type: zod.enum(['metered']),
                                usagePeriod: zod.coerce
                                  .string()
                                  .optional()
                                  .describe(
                                    'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                                  ),
                              })
                              .describe(
                                'The entitlement template with a metered entitlement.',
                              ),
                            zod
                              .object({
                                config: zod.coerce
                                  .string()
                                  .describe(
                                    'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['static']),
                              })
                              .describe(
                                'Entitlement template of a static entitlement.',
                              ),
                            zod
                              .object({
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['boolean']),
                              })
                              .describe(
                                'Entitlement template of a boolean entitlement.',
                              ),
                          ])
                          .describe(
                            'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                          )
                          .optional()
                          .describe(
                            'The entitlement of the rate card.\nOnly available when featureKey is set.',
                          ),
                        featureKey: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            editSubscriptionBodyCustomizationsItemOneRateCardOneFeatureKeyMax,
                          )
                          .regex(
                            editSubscriptionBodyCustomizationsItemOneRateCardOneFeatureKeyRegExp,
                          )
                          .optional()
                          .describe(
                            'The feature the customer is entitled to use.',
                          ),
                        key: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            editSubscriptionBodyCustomizationsItemOneRateCardOneKeyMax,
                          )
                          .regex(
                            editSubscriptionBodyCustomizationsItemOneRateCardOneKeyRegExp,
                          )
                          .describe(
                            'A semi-unique identifier for the resource.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .nullish()
                          .describe('Additional metadata for the resource.'),
                        name: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            editSubscriptionBodyCustomizationsItemOneRateCardOneNameMax,
                          )
                          .describe(
                            'Human-readable name for the resource. Between 1 and 256 characters.',
                          ),
                        price: zod
                          .object({
                            amount: zod.coerce
                              .string()
                              .regex(
                                editSubscriptionBodyCustomizationsItemOneRateCardOnePriceOneAmountOneRegExp,
                              )
                              .describe(
                                'Numeric represents an arbitrary precision number.',
                              )
                              .describe('The amount of the flat price.'),
                            paymentTerm: zod
                              .enum(['in_advance', 'in_arrears'])
                              .describe(
                                'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                              )
                              .default(
                                editSubscriptionBodyCustomizationsItemOneRateCardOnePriceOnePaymentTermDefault,
                              )
                              .describe(
                                'The payment term of the flat price.\nDefaults to in advance.',
                              ),
                            type: zod.enum(['flat']),
                          })
                          .describe('Flat price with payment term.')
                          .nullable()
                          .describe(
                            'The price of the rate card.\nWhen null, the feature or service is free.',
                          ),
                        taxConfig: zod
                          .object({
                            behavior: zod
                              .enum(['inclusive', 'exclusive'])
                              .describe(
                                'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                              )
                              .optional()
                              .describe(
                                "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                              ),
                            customInvoicing: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .describe(
                                    'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                                  ),
                              })
                              .describe('Custom invoicing tax config.')
                              .optional()
                              .describe('Custom invoicing tax config.'),
                            stripe: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardOneTaxConfigOneStripeOneCodeRegExp,
                                  )
                                  .describe(
                                    'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                                  ),
                              })
                              .describe('The tax config for Stripe.')
                              .optional()
                              .describe('Stripe tax config.'),
                          })
                          .describe('Set of provider specific tax configs.')
                          .optional()
                          .describe(
                            'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                          ),
                        type: zod.enum(['flat_fee']),
                      })
                      .describe(
                        'A flat fee rate card defines a one-time purchase or a recurring fee.',
                      ),
                    zod
                      .object({
                        billingCadence: zod.coerce
                          .string()
                          .describe('The billing cadence of the rate card.'),
                        description: zod.coerce
                          .string()
                          .max(
                            editSubscriptionBodyCustomizationsItemOneRateCardTwoDescriptionMax,
                          )
                          .optional()
                          .describe(
                            'Optional description of the resource. Maximum 1024 characters.',
                          ),
                        discounts: zod
                          .object({
                            percentage: zod
                              .object({
                                percentage: zod.coerce
                                  .number()
                                  .describe(
                                    'Numeric representation of a percentage\n\n50% is represented as 50',
                                  )
                                  .describe('The percentage of the discount.'),
                              })
                              .describe('Percentage discount.')
                              .optional()
                              .describe('The percentage discount.'),
                            usage: zod
                              .object({
                                quantity: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoDiscountsOneUsageOneQuantityOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe(
                                    'The quantity of the usage discount.\n\nMust be positive.',
                                  ),
                              })
                              .describe(
                                'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                              )
                              .optional()
                              .describe('The usage discount.'),
                          })
                          .describe('Discount by type on a price')
                          .optional()
                          .describe(
                            'The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.',
                          ),
                        entitlementTemplate: zod
                          .union([
                            zod
                              .object({
                                isSoftLimit: zod.coerce
                                  .boolean()
                                  .default(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIsSoftLimitDefault,
                                  )
                                  .describe(
                                    'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                                  ),
                                issueAfterReset: zod.coerce
                                  .number()
                                  .min(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetMin,
                                  )
                                  .optional()
                                  .describe(
                                    'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                                  ),
                                issueAfterResetPriority: zod.coerce
                                  .number()
                                  .min(1)
                                  .max(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                                  )
                                  .default(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                                  )
                                  .describe(
                                    'Defines the grant priority for the default grant.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                preserveOverageAtReset: zod.coerce
                                  .boolean()
                                  .default(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                                  )
                                  .describe(
                                    'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                                  ),
                                type: zod.enum(['metered']),
                                usagePeriod: zod.coerce
                                  .string()
                                  .optional()
                                  .describe(
                                    'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                                  ),
                              })
                              .describe(
                                'The entitlement template with a metered entitlement.',
                              ),
                            zod
                              .object({
                                config: zod.coerce
                                  .string()
                                  .describe(
                                    'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['static']),
                              })
                              .describe(
                                'Entitlement template of a static entitlement.',
                              ),
                            zod
                              .object({
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .optional()
                                  .describe(
                                    'Additional metadata for the feature.',
                                  ),
                                type: zod.enum(['boolean']),
                              })
                              .describe(
                                'Entitlement template of a boolean entitlement.',
                              ),
                          ])
                          .describe(
                            'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                          )
                          .optional()
                          .describe(
                            'The entitlement of the rate card.\nOnly available when featureKey is set.',
                          ),
                        featureKey: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            editSubscriptionBodyCustomizationsItemOneRateCardTwoFeatureKeyMax,
                          )
                          .regex(
                            editSubscriptionBodyCustomizationsItemOneRateCardTwoFeatureKeyRegExp,
                          )
                          .optional()
                          .describe(
                            'The feature the customer is entitled to use.',
                          ),
                        key: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            editSubscriptionBodyCustomizationsItemOneRateCardTwoKeyMax,
                          )
                          .regex(
                            editSubscriptionBodyCustomizationsItemOneRateCardTwoKeyRegExp,
                          )
                          .describe(
                            'A semi-unique identifier for the resource.',
                          ),
                        metadata: zod
                          .record(zod.string(), zod.coerce.string())
                          .describe(
                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                          )
                          .nullish()
                          .describe('Additional metadata for the resource.'),
                        name: zod.coerce
                          .string()
                          .min(1)
                          .max(
                            editSubscriptionBodyCustomizationsItemOneRateCardTwoNameMax,
                          )
                          .describe(
                            'Human-readable name for the resource. Between 1 and 256 characters.',
                          ),
                        price: zod
                          .union([
                            zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneOneAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the flat price.'),
                                paymentTerm: zod
                                  .enum(['in_advance', 'in_arrears'])
                                  .describe(
                                    'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                                  )
                                  .default(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneOnePaymentTermDefault,
                                  )
                                  .describe(
                                    'The payment term of the flat price.\nDefaults to in advance.',
                                  ),
                                type: zod.enum(['flat']),
                              })
                              .describe('Flat price with payment term.'),
                            zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The amount of the unit price.'),
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                type: zod.enum(['unit']),
                              })
                              .describe('Unit price with spend commitments.'),
                            zod
                              .object({
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                mode: zod
                                  .enum(['volume', 'graduated'])
                                  .describe('The mode of the tiered price.')
                                  .describe(
                                    'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                                  ),
                                tiers: zod
                                  .array(
                                    zod
                                      .object({
                                        flatPrice: zod
                                          .object({
                                            amount: zod.coerce
                                              .string()
                                              .regex(
                                                editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                              )
                                              .describe(
                                                'Numeric represents an arbitrary precision number.',
                                              )
                                              .describe(
                                                'The amount of the flat price.',
                                              ),
                                            type: zod
                                              .enum(['flat'])
                                              .describe(
                                                'The type of the price.',
                                              ),
                                          })
                                          .describe('Flat price.')
                                          .nullable()
                                          .describe(
                                            'The flat price component of the tier.',
                                          ),
                                        unitPrice: zod
                                          .object({
                                            amount: zod.coerce
                                              .string()
                                              .regex(
                                                editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                              )
                                              .describe(
                                                'Numeric represents an arbitrary precision number.',
                                              )
                                              .describe(
                                                'The amount of the unit price.',
                                              ),
                                            type: zod
                                              .enum(['unit'])
                                              .describe(
                                                'The type of the price.',
                                              ),
                                          })
                                          .describe('Unit price.')
                                          .nullable()
                                          .describe(
                                            'The unit price component of the tier.',
                                          ),
                                        upToAmount: zod.coerce
                                          .string()
                                          .regex(
                                            editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemUpToAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                                          ),
                                      })
                                      .describe(
                                        'A price tier.\nAt least one price component is required in each tier.',
                                      ),
                                  )
                                  .min(1)
                                  .describe(
                                    'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                                  ),
                                type: zod.enum(['tiered']),
                              })
                              .describe('Tiered price with spend commitments.'),
                            zod
                              .object({
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                multiplier: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMultiplierOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .default(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMultiplierDefault,
                                  )
                                  .describe(
                                    'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                                  ),
                                type: zod.enum(['dynamic']),
                              })
                              .describe(
                                'Dynamic price with spend commitments.',
                              ),
                            zod
                              .object({
                                amount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The price of one package.'),
                                maximumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveMaximumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is limited to spend at most the amount.',
                                  ),
                                minimumAmount: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveMinimumAmountOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .optional()
                                  .describe(
                                    'The customer is committed to spend at least the amount.',
                                  ),
                                quantityPerPackage: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveQuantityPerPackageOneRegExp,
                                  )
                                  .describe(
                                    'Numeric represents an arbitrary precision number.',
                                  )
                                  .describe('The quantity per package.'),
                                type: zod.enum(['package']),
                              })
                              .describe(
                                'Package price with spend commitments.',
                              ),
                          ])
                          .describe('The price of the usage based rate card.')
                          .nullable()
                          .describe(
                            'The price of the rate card.\nWhen null, the feature or service is free.',
                          ),
                        taxConfig: zod
                          .object({
                            behavior: zod
                              .enum(['inclusive', 'exclusive'])
                              .describe(
                                'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                              )
                              .optional()
                              .describe(
                                "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                              ),
                            customInvoicing: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .describe(
                                    'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                                  ),
                              })
                              .describe('Custom invoicing tax config.')
                              .optional()
                              .describe('Custom invoicing tax config.'),
                            stripe: zod
                              .object({
                                code: zod.coerce
                                  .string()
                                  .regex(
                                    editSubscriptionBodyCustomizationsItemOneRateCardTwoTaxConfigOneStripeOneCodeRegExp,
                                  )
                                  .describe(
                                    'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                                  ),
                              })
                              .describe('The tax config for Stripe.')
                              .optional()
                              .describe('Stripe tax config.'),
                          })
                          .describe('Set of provider specific tax configs.')
                          .optional()
                          .describe(
                            'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                          ),
                        type: zod.enum(['usage_based']),
                      })
                      .describe(
                        'A usage-based rate card defines a price based on usage.',
                      ),
                  ])
                  .describe(
                    'A rate card defines the pricing and entitlement of a feature or service.',
                  ),
              })
              .describe('Add a new item to a phase.'),
            zod
              .object({
                itemKey: zod.coerce.string(),
                op: zod.enum(['remove_item']),
                phaseKey: zod.coerce.string(),
              })
              .describe('Remove an item from a phase.'),
            zod
              .object({
                op: zod.enum(['add_phase']),
                phase: zod
                  .object({
                    description: zod.coerce
                      .string()
                      .optional()
                      .describe('The description of the phase.'),
                    discounts: zod
                      .object({
                        percentage: zod
                          .object({
                            percentage: zod.coerce
                              .number()
                              .describe(
                                'Numeric representation of a percentage\n\n50% is represented as 50',
                              )
                              .describe('The percentage of the discount.'),
                          })
                          .describe('Percentage discount.')
                          .optional()
                          .describe('The percentage discount.'),
                        usage: zod
                          .object({
                            quantity: zod.coerce
                              .string()
                              .regex(
                                editSubscriptionBodyCustomizationsItemThreePhaseDiscountsOneUsageOneQuantityOneRegExp,
                              )
                              .describe(
                                'Numeric represents an arbitrary precision number.',
                              )
                              .describe(
                                'The quantity of the usage discount.\n\nMust be positive.',
                              ),
                          })
                          .describe(
                            'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                          )
                          .optional()
                          .describe('The usage discount.'),
                      })
                      .describe('Discount by type on a price')
                      .optional()
                      .describe('The discounts on the plan.'),
                    duration: zod.coerce
                      .string()
                      .optional()
                      .describe(
                        'The intended duration of the new phase.\nDuration is required when the phase will not be the last phase.',
                      ),
                    key: zod.coerce
                      .string()
                      .min(1)
                      .max(
                        editSubscriptionBodyCustomizationsItemThreePhaseKeyMax,
                      )
                      .regex(
                        editSubscriptionBodyCustomizationsItemThreePhaseKeyRegExp,
                      )
                      .describe('A locally unique identifier for the phase.'),
                    name: zod.coerce
                      .string()
                      .describe('The name of the phase.'),
                    startAfter: zod.coerce
                      .string()
                      .nullable()
                      .describe(
                        'Interval after the subscription starts to transition to the phase.\nWhen null, the phase starts immediately after the subscription starts.',
                      ),
                  })
                  .describe('Subscription phase create input.'),
              })
              .describe('Add a new phase'),
            zod
              .object({
                op: zod.enum(['remove_phase']),
                phaseKey: zod.coerce.string(),
                shift: zod
                  .enum(['next', 'prev'])
                  .describe(
                    'The direction of the phase shift when a phase is removed.',
                  ),
              })
              .describe('Remove a phase'),
            zod
              .object({
                extendBy: zod.coerce.string(),
                op: zod.enum(['stretch_phase']),
                phaseKey: zod.coerce.string(),
              })
              .describe('Stretch a phase'),
            zod
              .object({
                op: zod.enum(['unschedule_edit']),
              })
              .describe('Unschedules any edits from the current phase.'),
          ])
          .describe('The operation to be performed on the subscription.'),
      )
      .max(editSubscriptionBodyCustomizationsMax)
      .describe(
        'Batch processing commands for manipulating running subscriptions.\nThe key format is `/phases/{phaseKey}` or `/phases/{phaseKey}/items/{itemKey}`.',
      ),
    timing: zod
      .union([
        zod
          .enum(['immediate', 'next_billing_cycle'])
          .describe(
            'Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.',
          ),
        zod.coerce
          .date()
          .describe(
            '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
          ),
      ])
      .describe(
        'Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.',
      )
      .optional()
      .describe(
        'Whether the billing period should be restarted.Timing configuration to allow for the changes to take effect at different times.',
      ),
  })
  .describe('Subscription edit input.')

/**
 * Deletes a subscription. Only scheduled subscriptions can be deleted.
 * @summary Delete subscription
 */
export const deleteSubscriptionPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeleteSubscriptionParams = zod.object({
  subscriptionId: zod.coerce
    .string()
    .regex(deleteSubscriptionPathSubscriptionIdRegExp),
})

/**
 * Create a new subscription addon, either providing the key or the id of the addon.
 * @summary Create subscription addon
 */
export const createSubscriptionAddonPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const CreateSubscriptionAddonParams = zod.object({
  subscriptionId: zod.coerce
    .string()
    .regex(createSubscriptionAddonPathSubscriptionIdRegExp),
})

export const createSubscriptionAddonBodyNameMax = 256 as const

export const createSubscriptionAddonBodyDescriptionMax = 1024 as const

export const createSubscriptionAddonBodyQuantityMin = 0 as const

export const createSubscriptionAddonBodyAddonIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const CreateSubscriptionAddonBody = zod
  .object({
    addon: zod
      .object({
        id: zod.coerce
          .string()
          .regex(createSubscriptionAddonBodyAddonIdRegExp)
          .describe('The ID of the add-on.'),
      })
      .describe('The add-on to create.'),
    description: zod.coerce
      .string()
      .max(createSubscriptionAddonBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(createSubscriptionAddonBodyNameMax)
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.',
      ),
    quantity: zod.coerce
      .number()
      .min(createSubscriptionAddonBodyQuantityMin)
      .describe(
        'The quantity of the add-on. Always 1 for single instance add-ons.',
      ),
    timing: zod
      .union([
        zod
          .enum(['immediate', 'next_billing_cycle'])
          .describe(
            'Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.',
          ),
        zod.coerce
          .date()
          .describe(
            '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
          ),
      ])
      .describe(
        'Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.',
      )
      .describe(
        'The timing of the operation. After the create or update, a new entry will be created in the timeline.',
      ),
  })
  .describe('A subscription add-on create body.')

/**
 * List all addons of a subscription. In the returned list will match to a set unique by addonId.
 * @summary List subscription addons
 */
export const listSubscriptionAddonsPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ListSubscriptionAddonsParams = zod.object({
  subscriptionId: zod.coerce
    .string()
    .regex(listSubscriptionAddonsPathSubscriptionIdRegExp),
})

/**
 * Get a subscription addon by id.
 * @summary Get subscription addon
 */
export const getSubscriptionAddonPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const getSubscriptionAddonPathSubscriptionAddonIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetSubscriptionAddonParams = zod.object({
  subscriptionAddonId: zod.coerce
    .string()
    .regex(getSubscriptionAddonPathSubscriptionAddonIdRegExp),
  subscriptionId: zod.coerce
    .string()
    .regex(getSubscriptionAddonPathSubscriptionIdRegExp),
})

/**
 * Updates a subscription addon (allows changing the quantity: purchasing more instances or cancelling the current instances)
 * @summary Update subscription addon
 */
export const updateSubscriptionAddonPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const updateSubscriptionAddonPathSubscriptionAddonIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UpdateSubscriptionAddonParams = zod.object({
  subscriptionAddonId: zod.coerce
    .string()
    .regex(updateSubscriptionAddonPathSubscriptionAddonIdRegExp),
  subscriptionId: zod.coerce
    .string()
    .regex(updateSubscriptionAddonPathSubscriptionIdRegExp),
})

export const updateSubscriptionAddonBodyNameMax = 256 as const

export const updateSubscriptionAddonBodyDescriptionMax = 1024 as const

export const updateSubscriptionAddonBodyQuantityMin = 0 as const

export const UpdateSubscriptionAddonBody = zod
  .object({
    description: zod.coerce
      .string()
      .max(updateSubscriptionAddonBodyDescriptionMax)
      .optional()
      .describe(
        'Optional description of the resource. Maximum 1024 characters.',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .nullish()
      .describe('Additional metadata for the resource.'),
    name: zod.coerce
      .string()
      .min(1)
      .max(updateSubscriptionAddonBodyNameMax)
      .optional()
      .describe(
        'Human-readable name for the resource. Between 1 and 256 characters.',
      ),
    quantity: zod.coerce
      .number()
      .min(updateSubscriptionAddonBodyQuantityMin)
      .optional()
      .describe(
        'The quantity of the add-on. Always 1 for single instance add-ons.',
      ),
    timing: zod
      .union([
        zod
          .enum(['immediate', 'next_billing_cycle'])
          .describe(
            'Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.',
          ),
        zod.coerce
          .date()
          .describe(
            '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
          ),
      ])
      .describe(
        'Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.',
      )
      .optional()
      .describe(
        'The timing of the operation. After the create or update, a new entry will be created in the timeline.',
      ),
  })
  .describe('Resource create or update operation model.')

/**
 * Cancels the subscription.
Will result in a scheduling conflict if there are other subscriptions scheduled to start after the cancellation time.
 * @summary Cancel subscription
 */
export const cancelSubscriptionPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const CancelSubscriptionParams = zod.object({
  subscriptionId: zod.coerce
    .string()
    .regex(cancelSubscriptionPathSubscriptionIdRegExp),
})

export const CancelSubscriptionBody = zod.object({
  timing: zod
    .union([
      zod
        .enum(['immediate', 'next_billing_cycle'])
        .describe(
          'Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.',
        ),
      zod.coerce
        .date()
        .describe(
          '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
        ),
    ])
    .describe(
      'Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.',
    )
    .optional()
    .describe('If not provided the subscription is canceled immediately.'),
})

/**
 * Closes a running subscription and starts a new one according to the specification.
Can be used for upgrades, downgrades, and plan changes.
 * @summary Change subscription
 */
export const changeSubscriptionPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ChangeSubscriptionParams = zod.object({
  subscriptionId: zod.coerce
    .string()
    .regex(changeSubscriptionPathSubscriptionIdRegExp),
})

export const changeSubscriptionBodyOnePlanOneKeyMax = 64 as const

export const changeSubscriptionBodyOnePlanOneKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/

export const changeSubscriptionBodyTwoCustomPlanOneOneNameMax = 256 as const

export const changeSubscriptionBodyTwoCustomPlanOneOneDescriptionMax =
  1024 as const

export const changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMin =
  3 as const
export const changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMax =
  3 as const

export const changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneRegExp =
  /^[A-Z]{3}$/
export const changeSubscriptionBodyTwoCustomPlanOneOneCurrencyDefault =
  'USD' as const
export const changeSubscriptionBodyTwoCustomPlanOneOneProRatingConfigOneEnabledDefault =
  true as const
export const changeSubscriptionBodyTwoCustomPlanOneOneProRatingConfigOneModeDefault =
  'prorate_prices' as const
export const changeSubscriptionBodyTwoCustomPlanOneOneProRatingConfigDefault = {
  enabled: true,
  mode: 'prorate_prices',
} as const
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyMax =
  64 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemNameMax =
  256 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemDescriptionMax =
  1024 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyMax =
  64 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneNameMax =
  256 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDescriptionMax =
  1024 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyMax =
  64 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOnePaymentTermDefault =
  'in_advance' as const
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyMax =
  64 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoNameMax =
  256 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDescriptionMax =
  1024 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyMax =
  64 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault =
  false as const
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin =
  0 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault =
  1 as const
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax =
  255 as const

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault =
  false as const
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp =
  /^txcd_\d{8}$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault =
  'in_advance' as const
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault =
  '1' as const
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp =
  /^-?[0-9]+(\.[0-9]+)?$/

export const ChangeSubscriptionBody = zod
  .union([
    zod
      .object({
        alignment: zod
          .object({
            billablesMustAlign: zod.coerce
              .boolean()
              .optional()
              .describe(
                "Whether all Billable items and RateCards must align.\nAlignment means the Price's BillingCadence must align for both duration and anchor time.",
              ),
          })
          .describe('Alignment configuration for a plan or subscription.')
          .optional()
          .describe('What alignment settings the subscription should have.'),
        billingAnchor: zod.coerce
          .date()
          .optional()
          .describe(
            'The billing anchor of the subscription. The provided date will be normalized according to the billing cadence to the nearest recurrence before start time. If not provided, the previous subscription billing anchor will be used.',
          ),
        description: zod.coerce
          .string()
          .optional()
          .describe('Description for the Subscription.'),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Arbitrary metadata associated with the subscription.'),
        name: zod.coerce
          .string()
          .optional()
          .describe(
            'The name of the Subscription. If not provided the plan name is used.',
          ),
        plan: zod
          .object({
            key: zod.coerce
              .string()
              .min(1)
              .max(changeSubscriptionBodyOnePlanOneKeyMax)
              .regex(changeSubscriptionBodyOnePlanOneKeyRegExp)
              .describe('The plan key.'),
            version: zod.coerce
              .number()
              .optional()
              .describe('The plan version.'),
          })
          .describe(
            'References an exact plan defaulting to the current active version.',
          )
          .describe('The plan reference to change to.'),
        startingPhase: zod.coerce
          .string()
          .min(1)
          .optional()
          .describe(
            'The key of the phase to start the subscription in.\nIf not provided, the subscription will start in the first phase of the plan.',
          ),
        timing: zod
          .union([
            zod
              .enum(['immediate', 'next_billing_cycle'])
              .describe(
                'Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.',
              ),
            zod.coerce
              .date()
              .describe(
                '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
              ),
          ])
          .describe(
            'Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.',
          )
          .describe(
            'Timing configuration for the change, when the change should take effect.\nFor changing a subscription, the accepted values depend on the subscription configuration.',
          ),
      })
      .describe('Change subscription based on plan.'),
    zod
      .object({
        billingAnchor: zod.coerce
          .date()
          .optional()
          .describe(
            'The billing anchor of the subscription. The provided date will be normalized according to the billing cadence to the nearest recurrence before start time. If not provided, the previous subscription billing anchor will be used.',
          ),
        customPlan: zod
          .object({
            alignment: zod
              .object({
                billablesMustAlign: zod.coerce
                  .boolean()
                  .optional()
                  .describe(
                    "Whether all Billable items and RateCards must align.\nAlignment means the Price's BillingCadence must align for both duration and anchor time.",
                  ),
              })
              .describe('Alignment configuration for a plan or subscription.')
              .optional()
              .describe('Alignment configuration for the plan.'),
            billingCadence: zod.coerce
              .string()
              .describe(
                'The default billing cadence for subscriptions using this plan.\nDefines how often customers are billed using ISO8601 duration format.\nExamples: "P1M" (monthly), "P3M" (quarterly), "P1Y" (annually).',
              ),
            currency: zod.coerce
              .string()
              .min(changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMin)
              .max(changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMax)
              .regex(changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneRegExp)
              .describe(
                'Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.',
              )
              .describe('The currency code of the plan.'),
            description: zod.coerce
              .string()
              .max(changeSubscriptionBodyTwoCustomPlanOneOneDescriptionMax)
              .optional()
              .describe(
                'Optional description of the resource. Maximum 1024 characters.',
              ),
            metadata: zod
              .record(zod.string(), zod.coerce.string())
              .describe(
                'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
              )
              .nullish()
              .describe('Additional metadata for the resource.'),
            name: zod.coerce
              .string()
              .min(1)
              .max(changeSubscriptionBodyTwoCustomPlanOneOneNameMax)
              .describe(
                'Human-readable name for the resource. Between 1 and 256 characters.',
              ),
            phases: zod
              .array(
                zod
                  .object({
                    description: zod.coerce
                      .string()
                      .max(
                        changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemDescriptionMax,
                      )
                      .optional()
                      .describe(
                        'Optional description of the resource. Maximum 1024 characters.',
                      ),
                    duration: zod.coerce
                      .string()
                      .nullable()
                      .describe('The duration of the phase.'),
                    key: zod.coerce
                      .string()
                      .min(1)
                      .max(
                        changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyMax,
                      )
                      .regex(
                        changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyRegExp,
                      )
                      .describe('A semi-unique identifier for the resource.'),
                    metadata: zod
                      .record(zod.string(), zod.coerce.string())
                      .describe(
                        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                      )
                      .nullish()
                      .describe('Additional metadata for the resource.'),
                    name: zod.coerce
                      .string()
                      .min(1)
                      .max(
                        changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemNameMax,
                      )
                      .describe(
                        'Human-readable name for the resource. Between 1 and 256 characters.',
                      ),
                    rateCards: zod
                      .array(
                        zod
                          .union([
                            zod
                              .object({
                                billingCadence: zod.coerce
                                  .string()
                                  .nullable()
                                  .describe(
                                    'The billing cadence of the rate card.\nWhen null it means it is a one time fee.',
                                  ),
                                description: zod.coerce
                                  .string()
                                  .max(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDescriptionMax,
                                  )
                                  .optional()
                                  .describe(
                                    'Optional description of the resource. Maximum 1024 characters.',
                                  ),
                                discounts: zod
                                  .object({
                                    percentage: zod
                                      .object({
                                        percentage: zod.coerce
                                          .number()
                                          .describe(
                                            'Numeric representation of a percentage\n\n50% is represented as 50',
                                          )
                                          .describe(
                                            'The percentage of the discount.',
                                          ),
                                      })
                                      .describe('Percentage discount.')
                                      .optional()
                                      .describe('The percentage discount.'),
                                    usage: zod
                                      .object({
                                        quantity: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The quantity of the usage discount.\n\nMust be positive.',
                                          ),
                                      })
                                      .describe(
                                        'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                                      )
                                      .optional()
                                      .describe('The usage discount.'),
                                  })
                                  .describe('Discount by type on a price')
                                  .optional()
                                  .describe(
                                    'The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.',
                                  ),
                                entitlementTemplate: zod
                                  .union([
                                    zod
                                      .object({
                                        isSoftLimit: zod.coerce
                                          .boolean()
                                          .default(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault,
                                          )
                                          .describe(
                                            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                                          ),
                                        issueAfterReset: zod.coerce
                                          .number()
                                          .min(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin,
                                          )
                                          .optional()
                                          .describe(
                                            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                                          ),
                                        issueAfterResetPriority: zod.coerce
                                          .number()
                                          .min(1)
                                          .max(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                                          )
                                          .default(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                                          )
                                          .describe(
                                            'Defines the grant priority for the default grant.',
                                          ),
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        preserveOverageAtReset: zod.coerce
                                          .boolean()
                                          .default(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                                          )
                                          .describe(
                                            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                                          ),
                                        type: zod.enum(['metered']),
                                        usagePeriod: zod.coerce
                                          .string()
                                          .optional()
                                          .describe(
                                            'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                                          ),
                                      })
                                      .describe(
                                        'The entitlement template with a metered entitlement.',
                                      ),
                                    zod
                                      .object({
                                        config: zod.coerce
                                          .string()
                                          .describe(
                                            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                                          ),
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        type: zod.enum(['static']),
                                      })
                                      .describe(
                                        'Entitlement template of a static entitlement.',
                                      ),
                                    zod
                                      .object({
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        type: zod.enum(['boolean']),
                                      })
                                      .describe(
                                        'Entitlement template of a boolean entitlement.',
                                      ),
                                  ])
                                  .describe(
                                    'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                                  )
                                  .optional()
                                  .describe(
                                    'The entitlement of the rate card.\nOnly available when featureKey is set.',
                                  ),
                                featureKey: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyMax,
                                  )
                                  .regex(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyRegExp,
                                  )
                                  .optional()
                                  .describe(
                                    'The feature the customer is entitled to use.',
                                  ),
                                key: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyMax,
                                  )
                                  .regex(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyRegExp,
                                  )
                                  .describe(
                                    'A semi-unique identifier for the resource.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .nullish()
                                  .describe(
                                    'Additional metadata for the resource.',
                                  ),
                                name: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneNameMax,
                                  )
                                  .describe(
                                    'Human-readable name for the resource. Between 1 and 256 characters.',
                                  ),
                                price: zod
                                  .object({
                                    amount: zod.coerce
                                      .string()
                                      .regex(
                                        changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOneAmountOneRegExp,
                                      )
                                      .describe(
                                        'Numeric represents an arbitrary precision number.',
                                      )
                                      .describe(
                                        'The amount of the flat price.',
                                      ),
                                    paymentTerm: zod
                                      .enum(['in_advance', 'in_arrears'])
                                      .describe(
                                        'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                                      )
                                      .default(
                                        changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOnePaymentTermDefault,
                                      )
                                      .describe(
                                        'The payment term of the flat price.\nDefaults to in advance.',
                                      ),
                                    type: zod.enum(['flat']),
                                  })
                                  .describe('Flat price with payment term.')
                                  .nullable()
                                  .describe(
                                    'The price of the rate card.\nWhen null, the feature or service is free.',
                                  ),
                                taxConfig: zod
                                  .object({
                                    behavior: zod
                                      .enum(['inclusive', 'exclusive'])
                                      .describe(
                                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                                      )
                                      .optional()
                                      .describe(
                                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                                      ),
                                    customInvoicing: zod
                                      .object({
                                        code: zod.coerce
                                          .string()
                                          .describe(
                                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                                          ),
                                      })
                                      .describe('Custom invoicing tax config.')
                                      .optional()
                                      .describe('Custom invoicing tax config.'),
                                    stripe: zod
                                      .object({
                                        code: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp,
                                          )
                                          .describe(
                                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                                          ),
                                      })
                                      .describe('The tax config for Stripe.')
                                      .optional()
                                      .describe('Stripe tax config.'),
                                  })
                                  .describe(
                                    'Set of provider specific tax configs.',
                                  )
                                  .optional()
                                  .describe(
                                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                                  ),
                                type: zod.enum(['flat_fee']),
                              })
                              .describe(
                                'A flat fee rate card defines a one-time purchase or a recurring fee.',
                              ),
                            zod
                              .object({
                                billingCadence: zod.coerce
                                  .string()
                                  .describe(
                                    'The billing cadence of the rate card.',
                                  ),
                                description: zod.coerce
                                  .string()
                                  .max(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDescriptionMax,
                                  )
                                  .optional()
                                  .describe(
                                    'Optional description of the resource. Maximum 1024 characters.',
                                  ),
                                discounts: zod
                                  .object({
                                    percentage: zod
                                      .object({
                                        percentage: zod.coerce
                                          .number()
                                          .describe(
                                            'Numeric representation of a percentage\n\n50% is represented as 50',
                                          )
                                          .describe(
                                            'The percentage of the discount.',
                                          ),
                                      })
                                      .describe('Percentage discount.')
                                      .optional()
                                      .describe('The percentage discount.'),
                                    usage: zod
                                      .object({
                                        quantity: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The quantity of the usage discount.\n\nMust be positive.',
                                          ),
                                      })
                                      .describe(
                                        'Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.',
                                      )
                                      .optional()
                                      .describe('The usage discount.'),
                                  })
                                  .describe('Discount by type on a price')
                                  .optional()
                                  .describe(
                                    'The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.',
                                  ),
                                entitlementTemplate: zod
                                  .union([
                                    zod
                                      .object({
                                        isSoftLimit: zod.coerce
                                          .boolean()
                                          .default(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault,
                                          )
                                          .describe(
                                            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
                                          ),
                                        issueAfterReset: zod.coerce
                                          .number()
                                          .min(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin,
                                          )
                                          .optional()
                                          .describe(
                                            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
                                          ),
                                        issueAfterResetPriority: zod.coerce
                                          .number()
                                          .min(1)
                                          .max(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax,
                                          )
                                          .default(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault,
                                          )
                                          .describe(
                                            'Defines the grant priority for the default grant.',
                                          ),
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        preserveOverageAtReset: zod.coerce
                                          .boolean()
                                          .default(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault,
                                          )
                                          .describe(
                                            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
                                          ),
                                        type: zod.enum(['metered']),
                                        usagePeriod: zod.coerce
                                          .string()
                                          .optional()
                                          .describe(
                                            'The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.',
                                          ),
                                      })
                                      .describe(
                                        'The entitlement template with a metered entitlement.',
                                      ),
                                    zod
                                      .object({
                                        config: zod.coerce
                                          .string()
                                          .describe(
                                            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
                                          ),
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        type: zod.enum(['static']),
                                      })
                                      .describe(
                                        'Entitlement template of a static entitlement.',
                                      ),
                                    zod
                                      .object({
                                        metadata: zod
                                          .record(
                                            zod.string(),
                                            zod.coerce.string(),
                                          )
                                          .describe(
                                            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                          )
                                          .optional()
                                          .describe(
                                            'Additional metadata for the feature.',
                                          ),
                                        type: zod.enum(['boolean']),
                                      })
                                      .describe(
                                        'Entitlement template of a boolean entitlement.',
                                      ),
                                  ])
                                  .describe(
                                    'Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.',
                                  )
                                  .optional()
                                  .describe(
                                    'The entitlement of the rate card.\nOnly available when featureKey is set.',
                                  ),
                                featureKey: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyMax,
                                  )
                                  .regex(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyRegExp,
                                  )
                                  .optional()
                                  .describe(
                                    'The feature the customer is entitled to use.',
                                  ),
                                key: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyMax,
                                  )
                                  .regex(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyRegExp,
                                  )
                                  .describe(
                                    'A semi-unique identifier for the resource.',
                                  ),
                                metadata: zod
                                  .record(zod.string(), zod.coerce.string())
                                  .describe(
                                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                                  )
                                  .nullish()
                                  .describe(
                                    'Additional metadata for the resource.',
                                  ),
                                name: zod.coerce
                                  .string()
                                  .min(1)
                                  .max(
                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoNameMax,
                                  )
                                  .describe(
                                    'Human-readable name for the resource. Between 1 and 256 characters.',
                                  ),
                                price: zod
                                  .union([
                                    zod
                                      .object({
                                        amount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The amount of the flat price.',
                                          ),
                                        paymentTerm: zod
                                          .enum(['in_advance', 'in_arrears'])
                                          .describe(
                                            'The payment term of a flat price.\nOne of: in_advance or in_arrears.',
                                          )
                                          .default(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault,
                                          )
                                          .describe(
                                            'The payment term of the flat price.\nDefaults to in advance.',
                                          ),
                                        type: zod.enum(['flat']),
                                      })
                                      .describe(
                                        'Flat price with payment term.',
                                      ),
                                    zod
                                      .object({
                                        amount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The amount of the unit price.',
                                          ),
                                        maximumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is limited to spend at most the amount.',
                                          ),
                                        minimumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is committed to spend at least the amount.',
                                          ),
                                        type: zod.enum(['unit']),
                                      })
                                      .describe(
                                        'Unit price with spend commitments.',
                                      ),
                                    zod
                                      .object({
                                        maximumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is limited to spend at most the amount.',
                                          ),
                                        minimumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is committed to spend at least the amount.',
                                          ),
                                        mode: zod
                                          .enum(['volume', 'graduated'])
                                          .describe(
                                            'The mode of the tiered price.',
                                          )
                                          .describe(
                                            'Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.',
                                          ),
                                        tiers: zod
                                          .array(
                                            zod
                                              .object({
                                                flatPrice: zod
                                                  .object({
                                                    amount: zod.coerce
                                                      .string()
                                                      .regex(
                                                        changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp,
                                                      )
                                                      .describe(
                                                        'Numeric represents an arbitrary precision number.',
                                                      )
                                                      .describe(
                                                        'The amount of the flat price.',
                                                      ),
                                                    type: zod
                                                      .enum(['flat'])
                                                      .describe(
                                                        'The type of the price.',
                                                      ),
                                                  })
                                                  .describe('Flat price.')
                                                  .nullable()
                                                  .describe(
                                                    'The flat price component of the tier.',
                                                  ),
                                                unitPrice: zod
                                                  .object({
                                                    amount: zod.coerce
                                                      .string()
                                                      .regex(
                                                        changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp,
                                                      )
                                                      .describe(
                                                        'Numeric represents an arbitrary precision number.',
                                                      )
                                                      .describe(
                                                        'The amount of the unit price.',
                                                      ),
                                                    type: zod
                                                      .enum(['unit'])
                                                      .describe(
                                                        'The type of the price.',
                                                      ),
                                                  })
                                                  .describe('Unit price.')
                                                  .nullable()
                                                  .describe(
                                                    'The unit price component of the tier.',
                                                  ),
                                                upToAmount: zod.coerce
                                                  .string()
                                                  .regex(
                                                    changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp,
                                                  )
                                                  .describe(
                                                    'Numeric represents an arbitrary precision number.',
                                                  )
                                                  .optional()
                                                  .describe(
                                                    'Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.',
                                                  ),
                                              })
                                              .describe(
                                                'A price tier.\nAt least one price component is required in each tier.',
                                              ),
                                          )
                                          .min(1)
                                          .describe(
                                            'The tiers of the tiered price.\nAt least one price component is required in each tier.',
                                          ),
                                        type: zod.enum(['tiered']),
                                      })
                                      .describe(
                                        'Tiered price with spend commitments.',
                                      ),
                                    zod
                                      .object({
                                        maximumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is limited to spend at most the amount.',
                                          ),
                                        minimumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is committed to spend at least the amount.',
                                          ),
                                        multiplier: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .default(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault,
                                          )
                                          .describe(
                                            'The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price',
                                          ),
                                        type: zod.enum(['dynamic']),
                                      })
                                      .describe(
                                        'Dynamic price with spend commitments.',
                                      ),
                                    zod
                                      .object({
                                        amount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The price of one package.',
                                          ),
                                        maximumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is limited to spend at most the amount.',
                                          ),
                                        minimumAmount: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .optional()
                                          .describe(
                                            'The customer is committed to spend at least the amount.',
                                          ),
                                        quantityPerPackage: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp,
                                          )
                                          .describe(
                                            'Numeric represents an arbitrary precision number.',
                                          )
                                          .describe(
                                            'The quantity per package.',
                                          ),
                                        type: zod.enum(['package']),
                                      })
                                      .describe(
                                        'Package price with spend commitments.',
                                      ),
                                  ])
                                  .describe(
                                    'The price of the usage based rate card.',
                                  )
                                  .nullable()
                                  .describe(
                                    'The price of the rate card.\nWhen null, the feature or service is free.',
                                  ),
                                taxConfig: zod
                                  .object({
                                    behavior: zod
                                      .enum(['inclusive', 'exclusive'])
                                      .describe(
                                        'Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.',
                                      )
                                      .optional()
                                      .describe(
                                        "Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider's default behavior is used.",
                                      ),
                                    customInvoicing: zod
                                      .object({
                                        code: zod.coerce
                                          .string()
                                          .describe(
                                            'Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.',
                                          ),
                                      })
                                      .describe('Custom invoicing tax config.')
                                      .optional()
                                      .describe('Custom invoicing tax config.'),
                                    stripe: zod
                                      .object({
                                        code: zod.coerce
                                          .string()
                                          .regex(
                                            changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp,
                                          )
                                          .describe(
                                            'Product tax code.\n\nSee: https://docs.stripe.com/tax/tax-codes',
                                          ),
                                      })
                                      .describe('The tax config for Stripe.')
                                      .optional()
                                      .describe('Stripe tax config.'),
                                  })
                                  .describe(
                                    'Set of provider specific tax configs.',
                                  )
                                  .optional()
                                  .describe(
                                    'The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.',
                                  ),
                                type: zod.enum(['usage_based']),
                              })
                              .describe(
                                'A usage-based rate card defines a price based on usage.',
                              ),
                          ])
                          .describe(
                            'A rate card defines the pricing and entitlement of a feature or service.',
                          ),
                      )
                      .describe('The rate cards of the plan.'),
                  })
                  .describe(
                    "The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.",
                  ),
              )
              .min(1)
              .describe(
                "The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.\nA phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.",
              ),
            proRatingConfig: zod
              .object({
                enabled: zod.coerce
                  .boolean()
                  .describe('Whether pro-rating is enabled for this plan.'),
                mode: zod
                  .enum(['prorate_prices'])
                  .describe(
                    'Pro-rating mode options for handling billing period changes.',
                  )
                  .describe(
                    'How to handle pro-rating for billing period changes.',
                  ),
              })
              .describe('Configuration for pro-rating behavior.')
              .default(
                changeSubscriptionBodyTwoCustomPlanOneOneProRatingConfigDefault,
              )
              .describe(
                'Default pro-rating configuration for subscriptions using this plan.',
              ),
          })
          .describe('The template for omitting properties.')
          .describe(
            'Plan input for custom subscription creation (without key and version).',
          )
          .describe(
            'The custom plan description which defines the Subscription.',
          ),
        timing: zod
          .union([
            zod
              .enum(['immediate', 'next_billing_cycle'])
              .describe(
                'Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.',
              ),
            zod.coerce
              .date()
              .describe(
                '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
              ),
          ])
          .describe(
            'Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.',
          )
          .describe(
            'Timing configuration for the change, when the change should take effect.\nFor changing a subscription, the accepted values depend on the subscription configuration.',
          ),
      })
      .describe('Change a custom subscription.'),
  ])
  .describe('Change a subscription.')

/**
 * Migrates the subscripiton to the provided version of the current plan.
If possible, the migration will be done immediately.
If not, the migration will be scheduled to the end of the current billing period.
 * @summary Migrate subscription
 */
export const migrateSubscriptionPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const MigrateSubscriptionParams = zod.object({
  subscriptionId: zod.coerce
    .string()
    .regex(migrateSubscriptionPathSubscriptionIdRegExp),
})

export const migrateSubscriptionBodyTimingDefault = 'immediate' as const

export const MigrateSubscriptionBody = zod.object({
  billingAnchor: zod.coerce
    .date()
    .optional()
    .describe(
      'The billing anchor of the subscription. The provided date will be normalized according to the billing cadence to the nearest recurrence before start time. If not provided, the previous subscription billing anchor will be used.',
    ),
  startingPhase: zod.coerce
    .string()
    .min(1)
    .optional()
    .describe(
      'The key of the phase to start the subscription in.\nIf not provided, the subscription will start in the first phase of the plan.',
    ),
  targetVersion: zod.coerce
    .number()
    .min(1)
    .optional()
    .describe(
      'The version of the plan to migrate to.\nIf not provided, the subscription will migrate to the latest version of the current plan.',
    ),
  timing: zod
    .union([
      zod
        .enum(['immediate', 'next_billing_cycle'])
        .describe(
          'Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.',
        ),
      zod.coerce
        .date()
        .describe(
          '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
        ),
    ])
    .describe(
      'Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.',
    )
    .default(migrateSubscriptionBodyTimingDefault)
    .describe(
      'Timing configuration for the migration, when the migration should take effect.\nIf not supported by the subscription, 400 will be returned.',
    ),
})

/**
 * Restores a canceled subscription.
Any subscription scheduled to start later will be deleted and this subscription will be continued indefinitely.
 * @deprecated
 * @summary Restore subscription
 */
export const restoreSubscriptionPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const RestoreSubscriptionParams = zod.object({
  subscriptionId: zod.coerce
    .string()
    .regex(restoreSubscriptionPathSubscriptionIdRegExp),
})

/**
 * Cancels the scheduled cancelation.
 * @summary Unschedule cancelation
 */
export const unscheduleCancelationPathSubscriptionIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const UnscheduleCancelationParams = zod.object({
  subscriptionId: zod.coerce
    .string()
    .regex(unscheduleCancelationPathSubscriptionIdRegExp),
})

/**
 * OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).

- Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
- Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
- Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.

A given customer can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.

Once an entitlement is created you cannot modify it, only delete it.
 * @summary Create a customer entitlement
 */
export const createCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createCustomerEntitlementV2PathCustomerIdOrKeyTwoMax = 256 as const

export const CreateCustomerEntitlementV2Params = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(createCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(createCustomerEntitlementV2PathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

export const createCustomerEntitlementV2BodyOneFeatureKeyMax = 64 as const

export const createCustomerEntitlementV2BodyOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createCustomerEntitlementV2BodyOneFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createCustomerEntitlementV2BodyOneIsSoftLimitDefault =
  false as const
export const createCustomerEntitlementV2BodyOneUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const createCustomerEntitlementV2BodyOnePreserveOverageAtResetDefault =
  false as const
export const createCustomerEntitlementV2BodyOneIssueAfterResetMin = 0 as const

export const createCustomerEntitlementV2BodyOneIssueAfterResetPriorityDefault =
  1 as const
export const createCustomerEntitlementV2BodyOneIssueAfterResetPriorityMax =
  255 as const

export const createCustomerEntitlementV2BodyOneIssueOneAmountMin = 0 as const

export const createCustomerEntitlementV2BodyOneIssueOnePriorityDefault =
  1 as const
export const createCustomerEntitlementV2BodyOneIssueOnePriorityMax =
  255 as const

export const createCustomerEntitlementV2BodyOneGrantsItemAmountMin = 0 as const

export const createCustomerEntitlementV2BodyOneGrantsItemPriorityMax =
  255 as const

export const createCustomerEntitlementV2BodyOneGrantsItemMinRolloverAmountDefault =
  0 as const
export const createCustomerEntitlementV2BodyOneGrantsItemRecurrenceOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const createCustomerEntitlementV2BodyOneGrantsItemExpirationOneCountMax =
  1000 as const

export const createCustomerEntitlementV2BodyTwoFeatureKeyMax = 64 as const

export const createCustomerEntitlementV2BodyTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createCustomerEntitlementV2BodyTwoFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createCustomerEntitlementV2BodyTwoUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const createCustomerEntitlementV2BodyThreeFeatureKeyMax = 64 as const

export const createCustomerEntitlementV2BodyThreeFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const createCustomerEntitlementV2BodyThreeFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createCustomerEntitlementV2BodyThreeUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/

export const CreateCustomerEntitlementV2Body = zod
  .union([
    zod
      .object({
        featureId: zod.coerce
          .string()
          .regex(createCustomerEntitlementV2BodyOneFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(createCustomerEntitlementV2BodyOneFeatureKeyMax)
          .regex(createCustomerEntitlementV2BodyOneFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        grants: zod
          .array(
            zod
              .object({
                amount: zod.coerce
                  .number()
                  .min(createCustomerEntitlementV2BodyOneGrantsItemAmountMin)
                  .describe(
                    'The amount to grant. Should be a positive number.',
                  ),
                annotations: zod
                  .record(zod.string(), zod.unknown())
                  .describe(
                    'Set of key-value pairs managed by the system. Cannot be modified by user.',
                  )
                  .optional()
                  .describe('Grant annotations'),
                effectiveAt: zod.coerce
                  .date()
                  .describe(
                    'Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).',
                  ),
                expiration: zod
                  .object({
                    count: zod.coerce
                      .number()
                      .min(1)
                      .max(
                        createCustomerEntitlementV2BodyOneGrantsItemExpirationOneCountMax,
                      )
                      .describe(
                        'The number of time units in the expiration period.',
                      ),
                    duration: zod
                      .enum(['HOUR', 'DAY', 'WEEK', 'MONTH', 'YEAR'])
                      .describe('The expiration duration enum')
                      .describe('The unit of time for the expiration period.'),
                  })
                  .describe('The grant expiration definition')
                  .optional()
                  .describe(
                    'The grant expiration definition. If no expiration is provided, the grant can be active indefinitely.',
                  ),
                maxRolloverAmount: zod.coerce
                  .number()
                  .optional()
                  .describe(
                    'Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset. The default value equals grant amount.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))',
                  ),
                metadata: zod
                  .record(zod.string(), zod.coerce.string())
                  .describe(
                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                  )
                  .optional()
                  .describe('The grant metadata.'),
                minRolloverAmount: zod.coerce
                  .number()
                  .default(
                    createCustomerEntitlementV2BodyOneGrantsItemMinRolloverAmountDefault,
                  )
                  .describe(
                    'Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))',
                  ),
                priority: zod.coerce
                  .number()
                  .min(1)
                  .max(createCustomerEntitlementV2BodyOneGrantsItemPriorityMax)
                  .optional()
                  .describe(
                    'The priority of the grant. Grants with higher priority are applied first.\nPriority is a positive decimal numbers. With lower numbers indicating higher importance.\nFor example, a priority of 1 is more urgent than a priority of 2.\nWhen there are several grants available for the same subject, the system selects the grant with the highest priority.\nIn cases where grants share the same priority level, the grant closest to its expiration will be used first.\nIn the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.',
                  ),
                recurrence: zod
                  .object({
                    anchor: zod.coerce
                      .date()
                      .optional()
                      .describe(
                        'A date-time anchor to base the recurring period on.',
                      ),
                    interval: zod
                      .union([
                        zod.coerce
                          .string()
                          .regex(
                            createCustomerEntitlementV2BodyOneGrantsItemRecurrenceOneIntervalOneOneRegExp,
                          ),
                        zod
                          .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                          .describe(
                            'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                          ),
                      ])
                      .describe('Period duration for the recurrence')
                      .describe('The unit of time for the interval.'),
                  })
                  .describe('Recurring period with an interval and an anchor.')
                  .optional()
                  .describe('The subject of the grant.'),
              })
              .describe('The grant creation input.'),
          )
          .optional()
          .describe('Grants'),
        isSoftLimit: zod.coerce
          .boolean()
          .default(createCustomerEntitlementV2BodyOneIsSoftLimitDefault)
          .describe(
            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
          ),
        issue: zod
          .object({
            amount: zod.coerce
              .number()
              .min(createCustomerEntitlementV2BodyOneIssueOneAmountMin)
              .describe('The initial grant amount'),
            priority: zod.coerce
              .number()
              .min(1)
              .max(createCustomerEntitlementV2BodyOneIssueOnePriorityMax)
              .default(
                createCustomerEntitlementV2BodyOneIssueOnePriorityDefault,
              )
              .describe('The priority of the issue after reset'),
          })
          .describe('Issue after reset')
          .optional()
          .describe('Issue after reset'),
        issueAfterReset: zod.coerce
          .number()
          .min(createCustomerEntitlementV2BodyOneIssueAfterResetMin)
          .optional()
          .describe(
            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
          ),
        issueAfterResetPriority: zod.coerce
          .number()
          .min(1)
          .max(createCustomerEntitlementV2BodyOneIssueAfterResetPriorityMax)
          .default(
            createCustomerEntitlementV2BodyOneIssueAfterResetPriorityDefault,
          )
          .describe('Defines the grant priority for the default grant.'),
        measureUsageFrom: zod
          .union([
            zod
              .enum(['CURRENT_PERIOD_START', 'NOW'])
              .describe('Start of measurement options'),
            zod.coerce
              .date()
              .describe(
                '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
              ),
          ])
          .describe('Measure usage from')
          .optional()
          .describe(
            'Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        preserveOverageAtReset: zod.coerce
          .boolean()
          .default(
            createCustomerEntitlementV2BodyOnePreserveOverageAtResetDefault,
          )
          .describe(
            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
          ),
        type: zod.enum(['metered']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    createCustomerEntitlementV2BodyOneUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inputs for metered entitlement'),
    zod
      .object({
        config: zod.coerce
          .string()
          .describe(
            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
          ),
        featureId: zod.coerce
          .string()
          .regex(createCustomerEntitlementV2BodyTwoFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(createCustomerEntitlementV2BodyTwoFeatureKeyMax)
          .regex(createCustomerEntitlementV2BodyTwoFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        type: zod.enum(['static']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    createCustomerEntitlementV2BodyTwoUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .optional()
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inputs for static entitlement'),
    zod
      .object({
        featureId: zod.coerce
          .string()
          .regex(createCustomerEntitlementV2BodyThreeFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(createCustomerEntitlementV2BodyThreeFeatureKeyMax)
          .regex(createCustomerEntitlementV2BodyThreeFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        type: zod.enum(['boolean']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    createCustomerEntitlementV2BodyThreeUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .optional()
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inputs for boolean entitlement'),
  ])
  .describe('Create inputs for entitlement')

/**
 * List all entitlements for a customer. For checking entitlement access, use the /value endpoint instead.
 * @summary List customer entitlements
 */
export const listCustomerEntitlementsV2PathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listCustomerEntitlementsV2PathCustomerIdOrKeyTwoMax = 256 as const

export const ListCustomerEntitlementsV2Params = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(listCustomerEntitlementsV2PathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(listCustomerEntitlementsV2PathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

export const listCustomerEntitlementsV2QueryIncludeDeletedDefault =
  false as const
export const listCustomerEntitlementsV2QueryPageDefault = 1 as const

export const listCustomerEntitlementsV2QueryPageSizeDefault = 100 as const
export const listCustomerEntitlementsV2QueryPageSizeMax = 1000 as const

export const ListCustomerEntitlementsV2QueryParams = zod.object({
  includeDeleted: zod.coerce
    .boolean()
    .default(listCustomerEntitlementsV2QueryIncludeDeletedDefault),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['createdAt', 'updatedAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listCustomerEntitlementsV2QueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listCustomerEntitlementsV2QueryPageSizeMax)
    .default(listCustomerEntitlementsV2QueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * Get entitlement by feature key. For checking entitlement access, use the /value endpoint instead.
If featureKey is used, the entitlement is resolved for the current timestamp.
 * @summary Get customer entitlement
 */
export const getCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const getCustomerEntitlementV2PathCustomerIdOrKeyTwoMax = 256 as const

export const getCustomerEntitlementV2PathEntitlementIdOrFeatureKeyMax =
  64 as const

export const getCustomerEntitlementV2PathEntitlementIdOrFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetCustomerEntitlementV2Params = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(getCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(getCustomerEntitlementV2PathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
  entitlementIdOrFeatureKey: zod.coerce
    .string()
    .min(1)
    .max(getCustomerEntitlementV2PathEntitlementIdOrFeatureKeyMax)
    .regex(getCustomerEntitlementV2PathEntitlementIdOrFeatureKeyRegExp),
})

/**
 * Deleting an entitlement revokes access to the associated feature. As a single customer can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.
 * @summary Delete customer entitlement
 */
export const deleteCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const deleteCustomerEntitlementV2PathCustomerIdOrKeyTwoMax = 256 as const

export const deleteCustomerEntitlementV2PathEntitlementIdOrFeatureKeyMax =
  64 as const

export const deleteCustomerEntitlementV2PathEntitlementIdOrFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const DeleteCustomerEntitlementV2Params = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(deleteCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(deleteCustomerEntitlementV2PathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
  entitlementIdOrFeatureKey: zod.coerce
    .string()
    .min(1)
    .max(deleteCustomerEntitlementV2PathEntitlementIdOrFeatureKeyMax)
    .regex(deleteCustomerEntitlementV2PathEntitlementIdOrFeatureKeyRegExp),
})

/**
 * List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey.
 * @summary List customer entitlement grants
 */
export const listCustomerEntitlementGrantsV2PathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listCustomerEntitlementGrantsV2PathCustomerIdOrKeyTwoMax =
  256 as const

export const listCustomerEntitlementGrantsV2PathEntitlementIdOrFeatureKeyMax =
  64 as const

export const listCustomerEntitlementGrantsV2PathEntitlementIdOrFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ListCustomerEntitlementGrantsV2Params = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(listCustomerEntitlementGrantsV2PathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(listCustomerEntitlementGrantsV2PathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
  entitlementIdOrFeatureKey: zod.coerce
    .string()
    .min(1)
    .max(listCustomerEntitlementGrantsV2PathEntitlementIdOrFeatureKeyMax)
    .regex(listCustomerEntitlementGrantsV2PathEntitlementIdOrFeatureKeyRegExp),
})

export const listCustomerEntitlementGrantsV2QueryIncludeDeletedDefault =
  false as const
export const listCustomerEntitlementGrantsV2QueryPageDefault = 1 as const

export const listCustomerEntitlementGrantsV2QueryPageSizeDefault = 100 as const
export const listCustomerEntitlementGrantsV2QueryPageSizeMax = 1000 as const

export const listCustomerEntitlementGrantsV2QueryOffsetDefault = 0 as const
export const listCustomerEntitlementGrantsV2QueryOffsetMin = 0 as const

export const listCustomerEntitlementGrantsV2QueryLimitDefault = 100 as const
export const listCustomerEntitlementGrantsV2QueryLimitMax = 1000 as const

export const ListCustomerEntitlementGrantsV2QueryParams = zod.object({
  includeDeleted: zod.coerce
    .boolean()
    .default(listCustomerEntitlementGrantsV2QueryIncludeDeletedDefault),
  limit: zod.coerce
    .number()
    .min(1)
    .max(listCustomerEntitlementGrantsV2QueryLimitMax)
    .default(listCustomerEntitlementGrantsV2QueryLimitDefault)
    .describe('Number of items to return.\n\nDefault is 100.'),
  offset: zod.coerce
    .number()
    .min(listCustomerEntitlementGrantsV2QueryOffsetMin)
    .default(listCustomerEntitlementGrantsV2QueryOffsetDefault)
    .describe('Number of items to skip.\n\nDefault is 0.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'createdAt', 'updatedAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listCustomerEntitlementGrantsV2QueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listCustomerEntitlementGrantsV2QueryPageSizeMax)
    .default(listCustomerEntitlementGrantsV2QueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.

A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.

Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.

Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).

Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))

Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.
 * @summary Create customer entitlement grant
 */
export const createCustomerEntitlementGrantV2PathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const createCustomerEntitlementGrantV2PathCustomerIdOrKeyTwoMax =
  256 as const

export const createCustomerEntitlementGrantV2PathEntitlementIdOrFeatureKeyMax =
  64 as const

export const createCustomerEntitlementGrantV2PathEntitlementIdOrFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const CreateCustomerEntitlementGrantV2Params = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(createCustomerEntitlementGrantV2PathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(createCustomerEntitlementGrantV2PathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
  entitlementIdOrFeatureKey: zod.coerce
    .string()
    .min(1)
    .max(createCustomerEntitlementGrantV2PathEntitlementIdOrFeatureKeyMax)
    .regex(createCustomerEntitlementGrantV2PathEntitlementIdOrFeatureKeyRegExp),
})

export const createCustomerEntitlementGrantV2BodyAmountMin = 0 as const

export const createCustomerEntitlementGrantV2BodyPriorityMax = 255 as const

export const createCustomerEntitlementGrantV2BodyMinRolloverAmountDefault =
  0 as const
export const createCustomerEntitlementGrantV2BodyRecurrenceOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const createCustomerEntitlementGrantV2BodyExpirationOneCountMax =
  1000 as const

export const CreateCustomerEntitlementGrantV2Body = zod
  .object({
    amount: zod.coerce
      .number()
      .min(createCustomerEntitlementGrantV2BodyAmountMin)
      .describe('The amount to grant. Should be a positive number.'),
    annotations: zod
      .record(zod.string(), zod.unknown())
      .describe(
        'Set of key-value pairs managed by the system. Cannot be modified by user.',
      )
      .optional()
      .describe('Grant annotations'),
    effectiveAt: zod.coerce
      .date()
      .describe(
        'Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).',
      ),
    expiration: zod
      .object({
        count: zod.coerce
          .number()
          .min(1)
          .max(createCustomerEntitlementGrantV2BodyExpirationOneCountMax)
          .describe('The number of time units in the expiration period.'),
        duration: zod
          .enum(['HOUR', 'DAY', 'WEEK', 'MONTH', 'YEAR'])
          .describe('The expiration duration enum')
          .describe('The unit of time for the expiration period.'),
      })
      .describe('The grant expiration definition')
      .optional()
      .describe(
        'The grant expiration definition. If no expiration is provided, the grant can be active indefinitely.',
      ),
    maxRolloverAmount: zod.coerce
      .number()
      .optional()
      .describe(
        'Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset. The default value equals grant amount.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))',
      ),
    metadata: zod
      .record(zod.string(), zod.coerce.string())
      .describe(
        'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
      )
      .optional()
      .describe('The grant metadata.'),
    minRolloverAmount: zod.coerce
      .number()
      .default(createCustomerEntitlementGrantV2BodyMinRolloverAmountDefault)
      .describe(
        'Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))',
      ),
    priority: zod.coerce
      .number()
      .min(1)
      .max(createCustomerEntitlementGrantV2BodyPriorityMax)
      .optional()
      .describe(
        'The priority of the grant. Grants with higher priority are applied first.\nPriority is a positive decimal numbers. With lower numbers indicating higher importance.\nFor example, a priority of 1 is more urgent than a priority of 2.\nWhen there are several grants available for the same subject, the system selects the grant with the highest priority.\nIn cases where grants share the same priority level, the grant closest to its expiration will be used first.\nIn the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.',
      ),
    recurrence: zod
      .object({
        anchor: zod.coerce
          .date()
          .optional()
          .describe('A date-time anchor to base the recurring period on.'),
        interval: zod
          .union([
            zod.coerce
              .string()
              .regex(
                createCustomerEntitlementGrantV2BodyRecurrenceOneIntervalOneOneRegExp,
              ),
            zod
              .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
              .describe(
                'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
              ),
          ])
          .describe('Period duration for the recurrence')
          .describe('The unit of time for the interval.'),
      })
      .describe('Recurring period with an interval and an anchor.')
      .optional()
      .describe('The subject of the grant.'),
  })
  .describe('The grant creation input.')

/**
 * Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.

BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.

WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.
 * @summary Get customer entitlement history
 */
export const getCustomerEntitlementHistoryV2PathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const getCustomerEntitlementHistoryV2PathCustomerIdOrKeyTwoMax =
  256 as const

export const getCustomerEntitlementHistoryV2PathEntitlementIdOrFeatureKeyMax =
  64 as const

export const getCustomerEntitlementHistoryV2PathEntitlementIdOrFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetCustomerEntitlementHistoryV2Params = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(getCustomerEntitlementHistoryV2PathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(getCustomerEntitlementHistoryV2PathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
  entitlementIdOrFeatureKey: zod.coerce
    .string()
    .min(1)
    .max(getCustomerEntitlementHistoryV2PathEntitlementIdOrFeatureKeyMax)
    .regex(getCustomerEntitlementHistoryV2PathEntitlementIdOrFeatureKeyRegExp),
})

export const getCustomerEntitlementHistoryV2QueryWindowTimeZoneDefault =
  'UTC' as const

export const GetCustomerEntitlementHistoryV2QueryParams = zod.object({
  from: zod.coerce
    .date()
    .optional()
    .describe(
      'Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to the last reset. Gets truncated to the granularity of the underlying meter.',
    ),
  to: zod.coerce
    .date()
    .optional()
    .describe(
      'End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.\nIf not now then gets truncated to the granularity of the underlying meter.',
    ),
  windowSize: zod
    .enum(['MINUTE', 'HOUR', 'DAY', 'MONTH'])
    .describe('Windowsize'),
  windowTimeZone: zod.coerce
    .string()
    .default(getCustomerEntitlementHistoryV2QueryWindowTimeZoneDefault)
    .describe('The timezone used when calculating the windows.'),
})

/**
 * Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided customer-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.

This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime.
 * @summary Override customer entitlement
 */
export const overrideCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const overrideCustomerEntitlementV2PathCustomerIdOrKeyTwoMax =
  256 as const

export const overrideCustomerEntitlementV2PathEntitlementIdOrFeatureKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const overrideCustomerEntitlementV2PathEntitlementIdOrFeatureKeyTwoMax =
  256 as const

export const OverrideCustomerEntitlementV2Params = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(overrideCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(overrideCustomerEntitlementV2PathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
  entitlementIdOrFeatureKey: zod.union([
    zod.coerce
      .string()
      .regex(
        overrideCustomerEntitlementV2PathEntitlementIdOrFeatureKeyOneRegExp,
      )
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(overrideCustomerEntitlementV2PathEntitlementIdOrFeatureKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
})

export const overrideCustomerEntitlementV2BodyOneFeatureKeyMax = 64 as const

export const overrideCustomerEntitlementV2BodyOneFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const overrideCustomerEntitlementV2BodyOneFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const overrideCustomerEntitlementV2BodyOneIsSoftLimitDefault =
  false as const
export const overrideCustomerEntitlementV2BodyOneUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const overrideCustomerEntitlementV2BodyOnePreserveOverageAtResetDefault =
  false as const
export const overrideCustomerEntitlementV2BodyOneIssueAfterResetMin = 0 as const

export const overrideCustomerEntitlementV2BodyOneIssueAfterResetPriorityDefault =
  1 as const
export const overrideCustomerEntitlementV2BodyOneIssueAfterResetPriorityMax =
  255 as const

export const overrideCustomerEntitlementV2BodyOneIssueOneAmountMin = 0 as const

export const overrideCustomerEntitlementV2BodyOneIssueOnePriorityDefault =
  1 as const
export const overrideCustomerEntitlementV2BodyOneIssueOnePriorityMax =
  255 as const

export const overrideCustomerEntitlementV2BodyOneGrantsItemAmountMin =
  0 as const

export const overrideCustomerEntitlementV2BodyOneGrantsItemPriorityMax =
  255 as const

export const overrideCustomerEntitlementV2BodyOneGrantsItemMinRolloverAmountDefault =
  0 as const
export const overrideCustomerEntitlementV2BodyOneGrantsItemRecurrenceOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const overrideCustomerEntitlementV2BodyOneGrantsItemExpirationOneCountMax =
  1000 as const

export const overrideCustomerEntitlementV2BodyTwoFeatureKeyMax = 64 as const

export const overrideCustomerEntitlementV2BodyTwoFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const overrideCustomerEntitlementV2BodyTwoFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const overrideCustomerEntitlementV2BodyTwoUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/
export const overrideCustomerEntitlementV2BodyThreeFeatureKeyMax = 64 as const

export const overrideCustomerEntitlementV2BodyThreeFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$/
export const overrideCustomerEntitlementV2BodyThreeFeatureIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const overrideCustomerEntitlementV2BodyThreeUsagePeriodOneIntervalOneOneRegExp =
  /^P(?:\d+(?:\.\d+)?Y)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?W)?(?:\d+(?:\.\d+)?D)?(?:T(?:\d+(?:\.\d+)?H)?(?:\d+(?:\.\d+)?M)?(?:\d+(?:\.\d+)?S)?)?$/

export const OverrideCustomerEntitlementV2Body = zod
  .union([
    zod
      .object({
        featureId: zod.coerce
          .string()
          .regex(overrideCustomerEntitlementV2BodyOneFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(overrideCustomerEntitlementV2BodyOneFeatureKeyMax)
          .regex(overrideCustomerEntitlementV2BodyOneFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        grants: zod
          .array(
            zod
              .object({
                amount: zod.coerce
                  .number()
                  .min(overrideCustomerEntitlementV2BodyOneGrantsItemAmountMin)
                  .describe(
                    'The amount to grant. Should be a positive number.',
                  ),
                annotations: zod
                  .record(zod.string(), zod.unknown())
                  .describe(
                    'Set of key-value pairs managed by the system. Cannot be modified by user.',
                  )
                  .optional()
                  .describe('Grant annotations'),
                effectiveAt: zod.coerce
                  .date()
                  .describe(
                    'Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).',
                  ),
                expiration: zod
                  .object({
                    count: zod.coerce
                      .number()
                      .min(1)
                      .max(
                        overrideCustomerEntitlementV2BodyOneGrantsItemExpirationOneCountMax,
                      )
                      .describe(
                        'The number of time units in the expiration period.',
                      ),
                    duration: zod
                      .enum(['HOUR', 'DAY', 'WEEK', 'MONTH', 'YEAR'])
                      .describe('The expiration duration enum')
                      .describe('The unit of time for the expiration period.'),
                  })
                  .describe('The grant expiration definition')
                  .optional()
                  .describe(
                    'The grant expiration definition. If no expiration is provided, the grant can be active indefinitely.',
                  ),
                maxRolloverAmount: zod.coerce
                  .number()
                  .optional()
                  .describe(
                    'Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset. The default value equals grant amount.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))',
                  ),
                metadata: zod
                  .record(zod.string(), zod.coerce.string())
                  .describe(
                    'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
                  )
                  .optional()
                  .describe('The grant metadata.'),
                minRolloverAmount: zod.coerce
                  .number()
                  .default(
                    overrideCustomerEntitlementV2BodyOneGrantsItemMinRolloverAmountDefault,
                  )
                  .describe(
                    'Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))',
                  ),
                priority: zod.coerce
                  .number()
                  .min(1)
                  .max(
                    overrideCustomerEntitlementV2BodyOneGrantsItemPriorityMax,
                  )
                  .optional()
                  .describe(
                    'The priority of the grant. Grants with higher priority are applied first.\nPriority is a positive decimal numbers. With lower numbers indicating higher importance.\nFor example, a priority of 1 is more urgent than a priority of 2.\nWhen there are several grants available for the same subject, the system selects the grant with the highest priority.\nIn cases where grants share the same priority level, the grant closest to its expiration will be used first.\nIn the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.',
                  ),
                recurrence: zod
                  .object({
                    anchor: zod.coerce
                      .date()
                      .optional()
                      .describe(
                        'A date-time anchor to base the recurring period on.',
                      ),
                    interval: zod
                      .union([
                        zod.coerce
                          .string()
                          .regex(
                            overrideCustomerEntitlementV2BodyOneGrantsItemRecurrenceOneIntervalOneOneRegExp,
                          ),
                        zod
                          .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                          .describe(
                            'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                          ),
                      ])
                      .describe('Period duration for the recurrence')
                      .describe('The unit of time for the interval.'),
                  })
                  .describe('Recurring period with an interval and an anchor.')
                  .optional()
                  .describe('The subject of the grant.'),
              })
              .describe('The grant creation input.'),
          )
          .optional()
          .describe('Grants'),
        isSoftLimit: zod.coerce
          .boolean()
          .default(overrideCustomerEntitlementV2BodyOneIsSoftLimitDefault)
          .describe(
            'If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.',
          ),
        issue: zod
          .object({
            amount: zod.coerce
              .number()
              .min(overrideCustomerEntitlementV2BodyOneIssueOneAmountMin)
              .describe('The initial grant amount'),
            priority: zod.coerce
              .number()
              .min(1)
              .max(overrideCustomerEntitlementV2BodyOneIssueOnePriorityMax)
              .default(
                overrideCustomerEntitlementV2BodyOneIssueOnePriorityDefault,
              )
              .describe('The priority of the issue after reset'),
          })
          .describe('Issue after reset')
          .optional()
          .describe('Issue after reset'),
        issueAfterReset: zod.coerce
          .number()
          .min(overrideCustomerEntitlementV2BodyOneIssueAfterResetMin)
          .optional()
          .describe(
            'You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.',
          ),
        issueAfterResetPriority: zod.coerce
          .number()
          .min(1)
          .max(overrideCustomerEntitlementV2BodyOneIssueAfterResetPriorityMax)
          .default(
            overrideCustomerEntitlementV2BodyOneIssueAfterResetPriorityDefault,
          )
          .describe('Defines the grant priority for the default grant.'),
        measureUsageFrom: zod
          .union([
            zod
              .enum(['CURRENT_PERIOD_START', 'NOW'])
              .describe('Start of measurement options'),
            zod.coerce
              .date()
              .describe(
                '[RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.',
              ),
          ])
          .describe('Measure usage from')
          .optional()
          .describe(
            'Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        preserveOverageAtReset: zod.coerce
          .boolean()
          .default(
            overrideCustomerEntitlementV2BodyOnePreserveOverageAtResetDefault,
          )
          .describe(
            'If true, the overage is preserved at reset. If false, the usage is reset to 0.',
          ),
        type: zod.enum(['metered']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    overrideCustomerEntitlementV2BodyOneUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inputs for metered entitlement'),
    zod
      .object({
        config: zod.coerce
          .string()
          .describe(
            'The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.',
          ),
        featureId: zod.coerce
          .string()
          .regex(overrideCustomerEntitlementV2BodyTwoFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(overrideCustomerEntitlementV2BodyTwoFeatureKeyMax)
          .regex(overrideCustomerEntitlementV2BodyTwoFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        type: zod.enum(['static']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    overrideCustomerEntitlementV2BodyTwoUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .optional()
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inputs for static entitlement'),
    zod
      .object({
        featureId: zod.coerce
          .string()
          .regex(overrideCustomerEntitlementV2BodyThreeFeatureIdRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        featureKey: zod.coerce
          .string()
          .min(1)
          .max(overrideCustomerEntitlementV2BodyThreeFeatureKeyMax)
          .regex(overrideCustomerEntitlementV2BodyThreeFeatureKeyRegExp)
          .optional()
          .describe(
            'The feature the subject is entitled to use.\nEither featureKey or featureId is required.',
          ),
        metadata: zod
          .record(zod.string(), zod.coerce.string())
          .describe(
            'Set of key-value pairs.\nMetadata can be used to store additional information about a resource.',
          )
          .optional()
          .describe('Additional metadata for the feature.'),
        type: zod.enum(['boolean']),
        usagePeriod: zod
          .object({
            anchor: zod.coerce
              .date()
              .optional()
              .describe('A date-time anchor to base the recurring period on.'),
            interval: zod
              .union([
                zod.coerce
                  .string()
                  .regex(
                    overrideCustomerEntitlementV2BodyThreeUsagePeriodOneIntervalOneOneRegExp,
                  ),
                zod
                  .enum(['DAY', 'WEEK', 'MONTH', 'YEAR'])
                  .describe(
                    'The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.',
                  ),
              ])
              .describe('Period duration for the recurrence')
              .describe('The unit of time for the interval.'),
          })
          .describe('Recurring period with an interval and an anchor.')
          .optional()
          .describe('The usage period associated with the entitlement.'),
      })
      .describe('Create inputs for boolean entitlement'),
  ])
  .describe('Create inputs for entitlement')

/**
 * Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the customers billing period to enforce usage based on their subscription.

Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.
 * @summary Reset customer entitlement
 */
export const resetCustomerEntitlementUsageV2PathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const resetCustomerEntitlementUsageV2PathCustomerIdOrKeyTwoMax =
  256 as const

export const resetCustomerEntitlementUsageV2PathEntitlementIdOrFeatureKeyMax =
  64 as const

export const resetCustomerEntitlementUsageV2PathEntitlementIdOrFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const ResetCustomerEntitlementUsageV2Params = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(resetCustomerEntitlementUsageV2PathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(resetCustomerEntitlementUsageV2PathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
  entitlementIdOrFeatureKey: zod.coerce
    .string()
    .min(1)
    .max(resetCustomerEntitlementUsageV2PathEntitlementIdOrFeatureKeyMax)
    .regex(resetCustomerEntitlementUsageV2PathEntitlementIdOrFeatureKeyRegExp),
})

export const ResetCustomerEntitlementUsageV2Body = zod
  .object({
    effectiveAt: zod.coerce
      .date()
      .optional()
      .describe(
        'The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.',
      ),
    preserveOverage: zod.coerce
      .boolean()
      .optional()
      .describe(
        "Determines whether the overage is preserved or forgiven, overriding the entitlement's default behavior.\n- If true, the overage is preserved.\n- If false, the overage is forgiven.",
      ),
    retainAnchor: zod.coerce
      .boolean()
      .optional()
      .describe(
        'Determines whether the usage period anchor is retained or reset to the effectiveAt time.\n- If true, the usage period anchor is retained.\n- If false, the usage period anchor is reset to the effectiveAt time.',
      ),
  })
  .describe('Reset parameters')

/**
 * Checks customer access to a given feature (by key). All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
 * @summary Get customer entitlement value
 */
export const getCustomerEntitlementValueV2PathCustomerIdOrKeyOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const getCustomerEntitlementValueV2PathCustomerIdOrKeyTwoMax =
  256 as const

export const getCustomerEntitlementValueV2PathEntitlementIdOrFeatureKeyMax =
  64 as const

export const getCustomerEntitlementValueV2PathEntitlementIdOrFeatureKeyRegExp =
  /^[a-z0-9]+(?:_[a-z0-9]+)*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetCustomerEntitlementValueV2Params = zod.object({
  customerIdOrKey: zod.union([
    zod.coerce
      .string()
      .regex(getCustomerEntitlementValueV2PathCustomerIdOrKeyOneRegExp)
      .describe(
        'ULID (Universally Unique Lexicographically Sortable Identifier).',
      ),
    zod.coerce
      .string()
      .min(1)
      .max(getCustomerEntitlementValueV2PathCustomerIdOrKeyTwoMax)
      .describe('ExternalKey is a looser version of key.'),
  ]),
  entitlementIdOrFeatureKey: zod.coerce
    .string()
    .min(1)
    .max(getCustomerEntitlementValueV2PathEntitlementIdOrFeatureKeyMax)
    .regex(getCustomerEntitlementValueV2PathEntitlementIdOrFeatureKeyRegExp),
})

export const GetCustomerEntitlementValueV2QueryParams = zod.object({
  time: zod.coerce.date().optional(),
})

/**
 * List all entitlements for all the customers and features. This endpoint is intended for administrative purposes only.
To fetch the entitlements of a specific subject please use the /api/v2/customers/{customerIdOrKey}/entitlements endpoint.
 * @summary List all entitlements
 */
export const listEntitlementsV2QueryExcludeInactiveDefault = false as const
export const listEntitlementsV2QueryPageDefault = 1 as const

export const listEntitlementsV2QueryPageSizeDefault = 100 as const
export const listEntitlementsV2QueryPageSizeMax = 1000 as const

export const listEntitlementsV2QueryOffsetDefault = 0 as const
export const listEntitlementsV2QueryOffsetMin = 0 as const

export const listEntitlementsV2QueryLimitDefault = 100 as const
export const listEntitlementsV2QueryLimitMax = 1000 as const

export const ListEntitlementsV2QueryParams = zod.object({
  customerIds: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple customers.\n\nUsage: `?customerIds=01K4WAQ0J99ZZ0MD75HXR112H8&customerIds=01K4WAQ0J99ZZ0MD75HXR112H9`',
    ),
  customerKeys: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple customers.\n\nUsage: `?customerKeys=customer-1&customerKeys=customer-3`',
    ),
  entitlementType: zod
    .array(
      zod
        .enum(['metered', 'boolean', 'static'])
        .describe('Type of the entitlement.'),
    )
    .optional()
    .describe(
      'Filtering by multiple entitlement types.\n\nUsage: `?entitlementType=metered&entitlementType=boolean`',
    ),
  excludeInactive: zod.coerce
    .boolean()
    .default(listEntitlementsV2QueryExcludeInactiveDefault)
    .describe(
      'Exclude inactive entitlements in the response (those scheduled for later or earlier)',
    ),
  feature: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple features.\n\nUsage: `?feature=feature-1&feature=feature-2`',
    ),
  limit: zod.coerce
    .number()
    .min(1)
    .max(listEntitlementsV2QueryLimitMax)
    .default(listEntitlementsV2QueryLimitDefault)
    .describe('Number of items to return.\n\nDefault is 100.'),
  offset: zod.coerce
    .number()
    .min(listEntitlementsV2QueryOffsetMin)
    .default(listEntitlementsV2QueryOffsetDefault)
    .describe('Number of items to skip.\n\nDefault is 0.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['createdAt', 'updatedAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listEntitlementsV2QueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listEntitlementsV2QueryPageSizeMax)
    .default(listEntitlementsV2QueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})

/**
 * Get entitlement by ID.
 * @summary Get entitlement by ID
 */
export const getEntitlementByIdV2PathEntitlementIdRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/

export const GetEntitlementByIdV2Params = zod.object({
  entitlementId: zod.coerce
    .string()
    .regex(getEntitlementByIdV2PathEntitlementIdRegExp),
})

/**
 * List ingested events with advanced filtering and cursor pagination.
 * @summary List ingested events
 */
export const listEventsV2QueryLimitDefault = 100 as const
export const listEventsV2QueryLimitMax = 100 as const

export const listEventsV2QueryClientIdMax = 36 as const

export const ListEventsV2QueryParams = zod.object({
  clientId: zod.coerce
    .string()
    .min(1)
    .max(listEventsV2QueryClientIdMax)
    .optional()
    .describe('Client ID\nUseful to track progress of a query.'),
  cursor: zod.coerce
    .string()
    .optional()
    .describe('The cursor after which to start the pagination.'),
  limit: zod.coerce
    .number()
    .min(1)
    .max(listEventsV2QueryLimitMax)
    .default(listEventsV2QueryLimitDefault)
    .describe('The limit of the pagination.'),
})

/**
 * List all grants for all the customers and entitlements. This endpoint is intended for administrative purposes only.
To fetch the grants of a specific entitlement please use the /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants endpoint.
If page is provided that takes precedence and the paginated response is returned.
 * @summary List grants
 */
export const listGrantsV2QueryCustomerItemOneRegExp =
  /^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$/
export const listGrantsV2QueryCustomerItemTwoMax = 256 as const

export const listGrantsV2QueryIncludeDeletedDefault = false as const
export const listGrantsV2QueryPageDefault = 1 as const

export const listGrantsV2QueryPageSizeDefault = 100 as const
export const listGrantsV2QueryPageSizeMax = 1000 as const

export const listGrantsV2QueryOffsetDefault = 0 as const
export const listGrantsV2QueryOffsetMin = 0 as const

export const listGrantsV2QueryLimitDefault = 100 as const
export const listGrantsV2QueryLimitMax = 1000 as const

export const ListGrantsV2QueryParams = zod.object({
  customer: zod
    .array(
      zod
        .union([
          zod.coerce
            .string()
            .regex(listGrantsV2QueryCustomerItemOneRegExp)
            .describe(
              'ULID (Universally Unique Lexicographically Sortable Identifier).',
            ),
          zod.coerce
            .string()
            .min(1)
            .max(listGrantsV2QueryCustomerItemTwoMax)
            .describe('ExternalKey is a looser version of key.'),
        ])
        .describe(
          'ULID (Universally Unique Lexicographically Sortable Identifier) or external unique key.',
        ),
    )
    .optional()
    .describe(
      'Filtering by multiple customers (either by ID or key).\n\nUsage: `?customer=customer-1&customer=customer-2`',
    ),
  feature: zod
    .array(zod.coerce.string())
    .optional()
    .describe(
      'Filtering by multiple features.\n\nUsage: `?feature=feature-1&feature=feature-2`',
    ),
  includeDeleted: zod.coerce
    .boolean()
    .default(listGrantsV2QueryIncludeDeletedDefault)
    .describe('Include deleted'),
  limit: zod.coerce
    .number()
    .min(1)
    .max(listGrantsV2QueryLimitMax)
    .default(listGrantsV2QueryLimitDefault)
    .describe('Number of items to return.\n\nDefault is 100.'),
  offset: zod.coerce
    .number()
    .min(listGrantsV2QueryOffsetMin)
    .default(listGrantsV2QueryOffsetDefault)
    .describe('Number of items to skip.\n\nDefault is 0.'),
  order: zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  orderBy: zod
    .enum(['id', 'createdAt', 'updatedAt'])
    .optional()
    .describe('The order by field.'),
  page: zod.coerce
    .number()
    .min(1)
    .default(listGrantsV2QueryPageDefault)
    .describe('Page index.\n\nDefault is 1.'),
  pageSize: zod.coerce
    .number()
    .min(1)
    .max(listGrantsV2QueryPageSizeMax)
    .default(listGrantsV2QueryPageSizeDefault)
    .describe('The maximum number of items per page.\n\nDefault is 100.'),
})
