/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * OpenMeter Cloud API
 * OpenMeter is a cloud native usage metering service.
The OpenMeter API allows you to ingest events, query meter usage, and manage resources.
 * OpenAPI spec version: 1.0.0
 */
import * as zod from 'zod';

/**
 * List all add-ons.
 * @summary List add-ons
 */
export const listAddonsQueryIncludeDeletedDefault = false;export const listAddonsQueryIdItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listAddonsQueryKeyItemMax = 64;


export const listAddonsQueryKeyItemRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const listAddonsQueryCurrencyItemMin = 3;
export const listAddonsQueryCurrencyItemMax = 3;


export const listAddonsQueryCurrencyItemRegExp = new RegExp('^[A-Z]{3}$');
export const listAddonsQueryPageDefault = 1;

export const listAddonsQueryPageSizeDefault = 100;
export const listAddonsQueryPageSizeMax = 1000;



export const ListAddonsQueryParams = zod.object({
  "includeDeleted": zod.coerce.boolean().default(listAddonsQueryIncludeDeletedDefault).describe('Include deleted add-ons in response.\n\nUsage: `?includeDeleted=true`'),
  "id": zod.array(zod.coerce.string().regex(listAddonsQueryIdItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('Filter by addon.id attribute'),
  "key": zod.array(zod.coerce.string().min(1).max(listAddonsQueryKeyItemMax).regex(listAddonsQueryKeyItemRegExp).describe('A key is a unique string that is used to identify a resource.')).optional().describe('Filter by addon.key attribute'),
  "keyVersion": zod.record(zod.string(), zod.array(zod.coerce.number())).optional().describe('Filter by addon.key and addon.version attributes'),
  "status": zod.array(zod.enum(['draft', 'active', 'archived']).describe('The status of the add-on defined by the effectiveFrom and effectiveTo properties.')).optional().describe('Only return add-ons with the given status.\n\nUsage:\n- `?status=active`: return only the currently active add-ons\n- `?status=draft`: return only the draft add-ons\n- `?status=archived`: return only the archived add-ons'),
  "currency": zod.array(zod.coerce.string().min(listAddonsQueryCurrencyItemMin).max(listAddonsQueryCurrencyItemMax).regex(listAddonsQueryCurrencyItemRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.')).optional().describe('Filter by addon.currency attribute'),
  "page": zod.coerce.number().min(1).default(listAddonsQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listAddonsQueryPageSizeMax).default(listAddonsQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'key', 'version', 'created_at', 'updated_at']).optional().describe('The order by field.')
})


/**
 * Create a new add-on.
 * @summary Create an add-on
 */
export const createAddonBodyNameMax = 256;

export const createAddonBodyDescriptionMax = 1024;

export const createAddonBodyKeyMax = 64;


export const createAddonBodyKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createAddonBodyCurrencyOneMin = 3;
export const createAddonBodyCurrencyOneMax = 3;


export const createAddonBodyCurrencyOneRegExp = new RegExp('^[A-Z]{3}$');
export const createAddonBodyCurrencyDefault = `USD`;export const createAddonBodyRateCardsItemOneKeyMax = 64;


export const createAddonBodyRateCardsItemOneKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createAddonBodyRateCardsItemOneNameMax = 256;

export const createAddonBodyRateCardsItemOneDescriptionMax = 1024;

export const createAddonBodyRateCardsItemOneFeatureKeyMax = 64;


export const createAddonBodyRateCardsItemOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault = false;export const createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const createAddonBodyRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const createAddonBodyRateCardsItemOneTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const createAddonBodyRateCardsItemOnePriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemOnePriceOnePaymentTermDefault = `in_advance`;export const createAddonBodyRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoKeyMax = 64;


export const createAddonBodyRateCardsItemTwoKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createAddonBodyRateCardsItemTwoNameMax = 256;

export const createAddonBodyRateCardsItemTwoDescriptionMax = 1024;

export const createAddonBodyRateCardsItemTwoFeatureKeyMax = 64;


export const createAddonBodyRateCardsItemTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault = false;export const createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const createAddonBodyRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const createAddonBodyRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const createAddonBodyRateCardsItemTwoPriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneOnePaymentTermDefault = `in_advance`;export const createAddonBodyRateCardsItemTwoPriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const createAddonBodyRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneFourMultiplierDefault = `1`;export const createAddonBodyRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createAddonBodyRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');


export const CreateAddonBody = zod.object({
  "name": zod.coerce.string().min(1).max(createAddonBodyNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createAddonBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "key": zod.coerce.string().min(1).max(createAddonBodyKeyMax).regex(createAddonBodyKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "instanceType": zod.enum(['single', 'multiple']).describe('The instanceType of the add-on.\nSingle instance add-ons can be added to subscription only once while add-ons with multiple type can be added more then once.').describe('The instanceType of the add-ons. Can be \"single\" or \"multiple\".'),
  "currency": zod.coerce.string().min(createAddonBodyCurrencyOneMin).max(createAddonBodyCurrencyOneMax).regex(createAddonBodyCurrencyOneRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.').describe('The currency code of the add-on.'),
  "rateCards": zod.array(zod.union([zod.object({
  "type": zod.enum(['flat_fee']),
  "key": zod.coerce.string().min(1).max(createAddonBodyRateCardsItemOneKeyMax).regex(createAddonBodyRateCardsItemOneKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(createAddonBodyRateCardsItemOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createAddonBodyRateCardsItemOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(createAddonBodyRateCardsItemOneFeatureKeyMax).regex(createAddonBodyRateCardsItemOneFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(createAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(createAddonBodyRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(createAddonBodyRateCardsItemOneTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().nullable().describe('The billing cadence of the rate card.\nWhen null it means it is a one time fee.'),
  "price": zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(createAddonBodyRateCardsItemOnePriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(createAddonBodyRateCardsItemOnePriceOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(createAddonBodyRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.')
}).describe('A flat fee rate card defines a one-time purchase or a recurring fee.'),zod.object({
  "type": zod.enum(['usage_based']),
  "key": zod.coerce.string().min(1).max(createAddonBodyRateCardsItemTwoKeyMax).regex(createAddonBodyRateCardsItemTwoKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(createAddonBodyRateCardsItemTwoNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createAddonBodyRateCardsItemTwoDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(createAddonBodyRateCardsItemTwoFeatureKeyMax).regex(createAddonBodyRateCardsItemTwoFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(createAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(createAddonBodyRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().describe('The billing cadence of the rate card.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(createAddonBodyRateCardsItemTwoPriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(createAddonBodyRateCardsItemTwoPriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(createAddonBodyRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.')
}).describe('A usage-based rate card defines a price based on usage.')]).describe('A rate card defines the pricing and entitlement of a feature or service.')).describe('The rate cards of the add-on.')
}).describe('Resource create operation model.')


/**
 * Update add-on by id.
 * @summary Update add-on
 */
export const updateAddonPathAddonIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdateAddonParams = zod.object({
  "addonId": zod.coerce.string().regex(updateAddonPathAddonIdRegExp)
})

export const updateAddonBodyNameMax = 256;

export const updateAddonBodyDescriptionMax = 1024;

export const updateAddonBodyRateCardsItemOneKeyMax = 64;


export const updateAddonBodyRateCardsItemOneKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updateAddonBodyRateCardsItemOneNameMax = 256;

export const updateAddonBodyRateCardsItemOneDescriptionMax = 1024;

export const updateAddonBodyRateCardsItemOneFeatureKeyMax = 64;


export const updateAddonBodyRateCardsItemOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault = false;export const updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const updateAddonBodyRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const updateAddonBodyRateCardsItemOneTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const updateAddonBodyRateCardsItemOnePriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemOnePriceOnePaymentTermDefault = `in_advance`;export const updateAddonBodyRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoKeyMax = 64;


export const updateAddonBodyRateCardsItemTwoKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updateAddonBodyRateCardsItemTwoNameMax = 256;

export const updateAddonBodyRateCardsItemTwoDescriptionMax = 1024;

export const updateAddonBodyRateCardsItemTwoFeatureKeyMax = 64;


export const updateAddonBodyRateCardsItemTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault = false;export const updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const updateAddonBodyRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const updateAddonBodyRateCardsItemTwoPriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneOnePaymentTermDefault = `in_advance`;export const updateAddonBodyRateCardsItemTwoPriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const updateAddonBodyRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneFourMultiplierDefault = `1`;export const updateAddonBodyRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateAddonBodyRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');


export const UpdateAddonBody = zod.object({
  "name": zod.coerce.string().min(1).max(updateAddonBodyNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updateAddonBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "instanceType": zod.enum(['single', 'multiple']).describe('The instanceType of the add-on.\nSingle instance add-ons can be added to subscription only once while add-ons with multiple type can be added more then once.').describe('The instanceType of the add-ons. Can be \"single\" or \"multiple\".'),
  "rateCards": zod.array(zod.union([zod.object({
  "type": zod.enum(['flat_fee']),
  "key": zod.coerce.string().min(1).max(updateAddonBodyRateCardsItemOneKeyMax).regex(updateAddonBodyRateCardsItemOneKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(updateAddonBodyRateCardsItemOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updateAddonBodyRateCardsItemOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(updateAddonBodyRateCardsItemOneFeatureKeyMax).regex(updateAddonBodyRateCardsItemOneFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(updateAddonBodyRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(updateAddonBodyRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(updateAddonBodyRateCardsItemOneTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().nullable().describe('The billing cadence of the rate card.\nWhen null it means it is a one time fee.'),
  "price": zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(updateAddonBodyRateCardsItemOnePriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(updateAddonBodyRateCardsItemOnePriceOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(updateAddonBodyRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.')
}).describe('A flat fee rate card defines a one-time purchase or a recurring fee.'),zod.object({
  "type": zod.enum(['usage_based']),
  "key": zod.coerce.string().min(1).max(updateAddonBodyRateCardsItemTwoKeyMax).regex(updateAddonBodyRateCardsItemTwoKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(updateAddonBodyRateCardsItemTwoNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updateAddonBodyRateCardsItemTwoDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(updateAddonBodyRateCardsItemTwoFeatureKeyMax).regex(updateAddonBodyRateCardsItemTwoFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(updateAddonBodyRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().describe('The billing cadence of the rate card.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(updateAddonBodyRateCardsItemTwoPriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(updateAddonBodyRateCardsItemTwoPriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(updateAddonBodyRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.')
}).describe('A usage-based rate card defines a price based on usage.')]).describe('A rate card defines the pricing and entitlement of a feature or service.')).describe('The rate cards of the add-on.')
}).describe('Resource update operation model.')


/**
 * Get add-on by id or key. The latest published version is returned if latter is used.
 * @summary Get add-on
 */
export const getAddonPathAddonIdMax = 64;


export const getAddonPathAddonIdRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetAddonParams = zod.object({
  "addonId": zod.coerce.string().min(1).max(getAddonPathAddonIdMax).regex(getAddonPathAddonIdRegExp)
})

export const getAddonQueryIncludeLatestDefault = false;

export const GetAddonQueryParams = zod.object({
  "includeLatest": zod.coerce.boolean().default(getAddonQueryIncludeLatestDefault).describe('Include latest version of the add-on instead of the version in active state.\n\nUsage: `?includeLatest=true`')
})


/**
 * Soft delete add-on by id.

Once a add-on is deleted it cannot be undeleted.
 * @summary Delete add-on
 */
export const deleteAddonPathAddonIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeleteAddonParams = zod.object({
  "addonId": zod.coerce.string().regex(deleteAddonPathAddonIdRegExp)
})


/**
 * Archive a add-on version.
 * @summary Archive add-on version
 */
export const archiveAddonPathAddonIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ArchiveAddonParams = zod.object({
  "addonId": zod.coerce.string().regex(archiveAddonPathAddonIdRegExp)
})


/**
 * Publish a add-on version.
 * @summary Publish add-on
 */
export const publishAddonPathAddonIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const PublishAddonParams = zod.object({
  "addonId": zod.coerce.string().regex(publishAddonPathAddonIdRegExp)
})


/**
 * List apps.
 * @summary List apps
 */
export const listAppsQueryPageDefault = 1;

export const listAppsQueryPageSizeDefault = 100;
export const listAppsQueryPageSizeMax = 1000;



export const ListAppsQueryParams = zod.object({
  "page": zod.coerce.number().min(1).default(listAppsQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listAppsQueryPageSizeMax).default(listAppsQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.')
})


/**
 * @summary Submit draft synchronization results
 */
export const appCustomInvoicingDraftSynchronizedPathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const AppCustomInvoicingDraftSynchronizedParams = zod.object({
  "invoiceId": zod.coerce.string().regex(appCustomInvoicingDraftSynchronizedPathInvoiceIdRegExp)
})

export const appCustomInvoicingDraftSynchronizedBodyInvoicingOneInvoiceNumberOneMax = 256;

export const appCustomInvoicingDraftSynchronizedBodyInvoicingOneLineExternalIdsItemLineIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const appCustomInvoicingDraftSynchronizedBodyInvoicingOneLineDiscountExternalIdsItemLineDiscountIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const AppCustomInvoicingDraftSynchronizedBody = zod.object({
  "invoicing": zod.object({
  "invoiceNumber": zod.coerce.string().min(1).max(appCustomInvoicingDraftSynchronizedBodyInvoicingOneInvoiceNumberOneMax).describe('InvoiceNumber is a unique identifier for the invoice, generated by the\ninvoicing app.\n\nThe uniqueness depends on a lot of factors:\n- app setting (unique per app or unique per customer)\n- multiple app scenarios (multiple apps generating invoices with the same prefix)').optional().describe('If set the invoice\'s number will be set to this value.'),
  "externalId": zod.coerce.string().optional().describe('If set the invoice\'s invoicing external ID will be set to this value.'),
  "lineExternalIds": zod.array(zod.object({
  "lineId": zod.coerce.string().regex(appCustomInvoicingDraftSynchronizedBodyInvoicingOneLineExternalIdsItemLineIdRegExp).describe('The line ID.'),
  "externalId": zod.coerce.string().describe('The external ID (e.g. custom invoicing system\'s ID).')
}).describe('Mapping between lines and external IDs.')).optional().describe('If set the invoice\'s line external IDs will be set to this value.\n\nThis can be used to reference the external system\'s entities in the\ninvoice.'),
  "lineDiscountExternalIds": zod.array(zod.object({
  "lineDiscountId": zod.coerce.string().regex(appCustomInvoicingDraftSynchronizedBodyInvoicingOneLineDiscountExternalIdsItemLineDiscountIdRegExp).describe('The line discount ID.'),
  "externalId": zod.coerce.string().describe('The external ID (e.g. custom invoicing system\'s ID).')
}).describe('Mapping between line discounts and external IDs.')).optional().describe('If set the invoice\'s line discount external IDs will be set to this value.\n\nThis can be used to reference the external system\'s entities in the\ninvoice.')
}).describe('Information to synchronize the invoice.\n\nCan be used to store external app\'s IDs on the invoice or lines.').optional().describe('The result of the synchronization.')
}).describe('Information to finalize the draft details of an invoice.')


/**
 * @summary Submit issuing synchronization results
 */
export const appCustomInvoicingIssuingSynchronizedPathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const AppCustomInvoicingIssuingSynchronizedParams = zod.object({
  "invoiceId": zod.coerce.string().regex(appCustomInvoicingIssuingSynchronizedPathInvoiceIdRegExp)
})

export const appCustomInvoicingIssuingSynchronizedBodyInvoicingOneInvoiceNumberOneMax = 256;



export const AppCustomInvoicingIssuingSynchronizedBody = zod.object({
  "invoicing": zod.object({
  "invoiceNumber": zod.coerce.string().min(1).max(appCustomInvoicingIssuingSynchronizedBodyInvoicingOneInvoiceNumberOneMax).describe('InvoiceNumber is a unique identifier for the invoice, generated by the\ninvoicing app.\n\nThe uniqueness depends on a lot of factors:\n- app setting (unique per app or unique per customer)\n- multiple app scenarios (multiple apps generating invoices with the same prefix)').optional().describe('If set the invoice\'s number will be set to this value.'),
  "sentToCustomerAt": zod.coerce.date().optional().describe('If set the invoice\'s sent to customer at will be set to this value.')
}).describe('Information to finalize the invoicing details of an invoice.').optional().describe('The result of the synchronization.'),
  "payment": zod.object({
  "externalId": zod.coerce.string().optional().describe('If set the invoice\'s payment external ID will be set to this value.')
}).describe('Information to finalize the payment details of an invoice.').optional().describe('The result of the payment synchronization.')
}).describe('Information to finalize the invoice.\n\nIf invoicing.invoiceNumber is not set, then a new invoice number will be generated (INV- prefix).')


/**
 * @summary Update payment status
 */
export const appCustomInvoicingUpdatePaymentStatusPathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const AppCustomInvoicingUpdatePaymentStatusParams = zod.object({
  "invoiceId": zod.coerce.string().regex(appCustomInvoicingUpdatePaymentStatusPathInvoiceIdRegExp)
})

export const AppCustomInvoicingUpdatePaymentStatusBody = zod.object({
  "trigger": zod.enum(['paid', 'payment_failed', 'payment_uncollectible', 'payment_overdue', 'action_required', 'void']).describe('Payment trigger to execute on a finalized invoice.').describe('The trigger to be executed on the invoice.')
}).describe('Update payment status request.\n\nCan be used to manipulate invoice\'s payment status (when custominvoicing app is being used).')


/**
 * Get the app.
 * @summary Get app
 */
export const getAppPathIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetAppParams = zod.object({
  "id": zod.coerce.string().regex(getAppPathIdRegExp)
})


/**
 * Update an app.
 * @summary Update app
 */
export const updateAppPathIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdateAppParams = zod.object({
  "id": zod.coerce.string().regex(updateAppPathIdRegExp)
})

export const updateAppBodyOneNameMax = 256;

export const updateAppBodyOneDescriptionMax = 1024;

export const updateAppBodyTwoNameMax = 256;

export const updateAppBodyTwoDescriptionMax = 1024;

export const updateAppBodyThreeNameMax = 256;

export const updateAppBodyThreeDescriptionMax = 1024;



export const UpdateAppBody = zod.union([zod.object({
  "name": zod.coerce.string().min(1).max(updateAppBodyOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updateAppBodyOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "type": zod.enum(['stripe']),
  "secretAPIKey": zod.coerce.string().optional().describe('The Stripe API key.')
}).describe('Resource update operation model.'),zod.object({
  "name": zod.coerce.string().min(1).max(updateAppBodyTwoNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updateAppBodyTwoDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "type": zod.enum(['sandbox'])
}).describe('Resource update operation model.'),zod.object({
  "name": zod.coerce.string().min(1).max(updateAppBodyThreeNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updateAppBodyThreeDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "type": zod.enum(['custom_invoicing']),
  "enableDraftSyncHook": zod.coerce.boolean().describe('Enable draft.sync hook.\n\nIf the hook is not enabled, the invoice will be progressed to the next state automatically.'),
  "enableIssuingSyncHook": zod.coerce.boolean().describe('Enable issuing.sync hook.\n\nIf the hook is not enabled, the invoice will be progressed to the next state automatically.')
}).describe('Resource update operation model.')]).describe('App ReplaceUpdate Model')


/**
 * Uninstall an app.
 * @summary Uninstall app
 */
export const uninstallAppPathIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UninstallAppParams = zod.object({
  "id": zod.coerce.string().regex(uninstallAppPathIdRegExp)
})


/**
 * Update the Stripe API key.

‚ö†Ô∏è __Deprecated__: Use [`PUT /api/v1/apps/{id}`](#tag/apps/put/api/v1/apps/{id}) instead.
 * @deprecated
 * @summary Update Stripe API key
 */
export const updateStripeAPIKeyPathIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdateStripeAPIKeyParams = zod.object({
  "id": zod.coerce.string().regex(updateStripeAPIKeyPathIdRegExp)
})

export const UpdateStripeAPIKeyBody = zod.object({
  "secretAPIKey": zod.coerce.string()
}).describe('The Stripe API key input.\nUsed to authenticate with the Stripe API.')


/**
 * Handle stripe webhooks for apps.
 * @summary Stripe webhook
 */
export const appStripeWebhookPathIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const AppStripeWebhookParams = zod.object({
  "id": zod.coerce.string().regex(appStripeWebhookPathIdRegExp)
})

export const AppStripeWebhookBody = zod.object({
  "id": zod.coerce.string().describe('The event ID.'),
  "type": zod.coerce.string().describe('The event type.'),
  "livemode": zod.coerce.boolean().describe('Live mode.'),
  "created": zod.coerce.number().describe('The event created timestamp.'),
  "data": zod.object({
  "object": zod.unknown()
}).describe('The event data.')
}).describe('Stripe webhook event.')


/**
 * List customer overrides using the specified filters.

The response will include the customer override values and the merged billing profile values.

If the includeAllCustomers is set to true, the list contains all customers. This mode is
useful for getting the current effective billing workflow settings for all users regardless
if they have customer orverrides or not.
 * @summary List customer overrides
 */
export const listBillingProfileCustomerOverridesQueryBillingProfileItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listBillingProfileCustomerOverridesQueryIncludeAllCustomersDefault = true;export const listBillingProfileCustomerOverridesQueryCustomerIdItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listBillingProfileCustomerOverridesQueryPageDefault = 1;

export const listBillingProfileCustomerOverridesQueryPageSizeDefault = 100;
export const listBillingProfileCustomerOverridesQueryPageSizeMax = 1000;



export const ListBillingProfileCustomerOverridesQueryParams = zod.object({
  "billingProfile": zod.array(zod.coerce.string().regex(listBillingProfileCustomerOverridesQueryBillingProfileItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('Filter by billing profile.'),
  "customersWithoutPinnedProfile": zod.coerce.boolean().optional().describe('Only return customers without pinned billing profiles. This implicitly sets includeAllCustomers to true.'),
  "includeAllCustomers": zod.coerce.boolean().default(listBillingProfileCustomerOverridesQueryIncludeAllCustomersDefault).describe('Include customers without customer overrides.\n\nIf set to false only the customers specifically associated with a billing profile will be returned.\n\nIf set to true, in case of the default billing profile, all customers will be returned.'),
  "customerId": zod.array(zod.coerce.string().regex(listBillingProfileCustomerOverridesQueryCustomerIdItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('Filter by customer id.'),
  "customerName": zod.coerce.string().optional().describe('Filter by customer name.'),
  "customerKey": zod.coerce.string().optional().describe('Filter by customer key'),
  "customerPrimaryEmail": zod.coerce.string().optional().describe('Filter by customer primary email'),
  "expand": zod.array(zod.enum(['apps', 'customer']).describe('CustomerOverrideExpand specifies the parts of the profile to expand.')).optional().describe('Expand the response with additional details.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['customerId', 'customerName', 'customerKey', 'customerPrimaryEmail', 'customerCreatedAt']).optional().describe('The order by field.'),
  "page": zod.coerce.number().min(1).default(listBillingProfileCustomerOverridesQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listBillingProfileCustomerOverridesQueryPageSizeMax).default(listBillingProfileCustomerOverridesQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.')
})


/**
 * The customer override can be used to pin a given customer to a billing profile
different from the default one.

This can be used to test the effect of different billing profiles before making them
the default ones or have different workflow settings for example for enterprise customers.
 * @summary Create a new or update a customer override
 */
export const upsertBillingProfileCustomerOverridePathCustomerIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpsertBillingProfileCustomerOverrideParams = zod.object({
  "customerId": zod.coerce.string().regex(upsertBillingProfileCustomerOverridePathCustomerIdRegExp)
})

export const upsertBillingProfileCustomerOverrideBodyBillingProfileIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpsertBillingProfileCustomerOverrideBody = zod.object({
  "billingProfileId": zod.coerce.string().regex(upsertBillingProfileCustomerOverrideBodyBillingProfileIdRegExp).optional().describe('The billing profile this override is associated with.\n\nIf not provided, the default billing profile is chosen if available.')
}).describe('Payload for creating a new or updating an existing customer override.')


/**
 * Get a customer override by customer id.

The response will include the customer override values and the merged billing profile values.

If the customer override is not found, the default billing profile's values are returned. This behavior
allows for getting a merged profile regardless of the customer override existence.
 * @summary Get a customer override
 */
export const getBillingProfileCustomerOverridePathCustomerIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetBillingProfileCustomerOverrideParams = zod.object({
  "customerId": zod.coerce.string().regex(getBillingProfileCustomerOverridePathCustomerIdRegExp)
})

export const GetBillingProfileCustomerOverrideQueryParams = zod.object({
  "expand": zod.array(zod.enum(['apps', 'customer']).describe('CustomerOverrideExpand specifies the parts of the profile to expand.')).optional()
})


/**
 * Delete a customer override by customer id.

This will remove the customer override and the customer will be subject to the default
billing profile's settings again.
 * @summary Delete a customer override
 */
export const deleteBillingProfileCustomerOverridePathCustomerIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeleteBillingProfileCustomerOverrideParams = zod.object({
  "customerId": zod.coerce.string().regex(deleteBillingProfileCustomerOverridePathCustomerIdRegExp)
})


/**
 * Create a new pending line item (charge).

This call is used to create a new pending line item for the customer if required a new
gathering invoice will be created.

A new invoice will be created if:
- there is no invoice in gathering state
- the currency of the line item doesn't match the currency of any invoices in gathering state
 * @summary Create pending line items
 */
export const createPendingInvoiceLinePathCustomerIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const CreatePendingInvoiceLineParams = zod.object({
  "customerId": zod.coerce.string().regex(createPendingInvoiceLinePathCustomerIdRegExp)
})

export const createPendingInvoiceLineBodyCurrencyOneMin = 3;
export const createPendingInvoiceLineBodyCurrencyOneMax = 3;


export const createPendingInvoiceLineBodyCurrencyOneRegExp = new RegExp('^[A-Z]{3}$');
export const createPendingInvoiceLineBodyLinesItemNameMax = 256;

export const createPendingInvoiceLineBodyLinesItemDescriptionMax = 1024;

export const createPendingInvoiceLineBodyLinesItemTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const createPendingInvoiceLineBodyLinesItemPriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneOnePaymentTermDefault = `in_advance`;export const createPendingInvoiceLineBodyLinesItemPriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const createPendingInvoiceLineBodyLinesItemPriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneFourMultiplierDefault = `1`;export const createPendingInvoiceLineBodyLinesItemPriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemPriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemFeatureKeyMax = 64;


export const createPendingInvoiceLineBodyLinesItemFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createPendingInvoiceLineBodyLinesItemRateCardOneFeatureKeyMax = 64;


export const createPendingInvoiceLineBodyLinesItemRateCardOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createPendingInvoiceLineBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault = `in_advance`;export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMultiplierDefault = `1`;export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');



export const CreatePendingInvoiceLineBody = zod.object({
  "currency": zod.coerce.string().min(createPendingInvoiceLineBodyCurrencyOneMin).max(createPendingInvoiceLineBodyCurrencyOneMax).regex(createPendingInvoiceLineBodyCurrencyOneRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.').describe('The currency of the lines to be created.'),
  "lines": zod.array(zod.object({
  "name": zod.coerce.string().min(1).max(createPendingInvoiceLineBodyLinesItemNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createPendingInvoiceLineBodyLinesItemDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('Tax config specify the tax configuration for this line.'),
  "period": zod.object({
  "from": zod.coerce.date().describe('Period start time.'),
  "to": zod.coerce.date().describe('Period end time.')
}).describe('A period with a start and end time.').describe('Period of the line item applies to for revenue recognition pruposes.\n\nBilling always treats periods as start being inclusive and end being exclusive.'),
  "invoiceAt": zod.coerce.date().describe('The time this line item should be invoiced.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(createPendingInvoiceLineBodyLinesItemPriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(createPendingInvoiceLineBodyLinesItemPriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemPriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').optional().describe('Price of the usage-based item being sold.'),
  "featureKey": zod.coerce.string().min(1).max(createPendingInvoiceLineBodyLinesItemFeatureKeyMax).regex(createPendingInvoiceLineBodyLinesItemFeatureKeyRegExp).optional().describe('The feature that the usage is based on.'),
  "rateCard": zod.object({
  "featureKey": zod.coerce.string().min(1).max(createPendingInvoiceLineBodyLinesItemRateCardOneFeatureKeyMax).regex(createPendingInvoiceLineBodyLinesItemRateCardOneFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.'),
  "correlationId": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp).optional().describe('Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.')
}).describe('A percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.'),
  "correlationId": zod.coerce.string().regex(createPendingInvoiceLineBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp).optional().describe('Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.')
}).describe('A usage discount.').optional().describe('The usage discount.')
}).describe('A discount by type.').optional().describe('The discounts that are applied to the line.')
}).describe('InvoiceUsageBasedRateCard represents the rate card (intent) for an usage-based line.').optional().describe('The rate card that is used for this line.\n\nThe rate card captures the intent of the price and discounts for the usage-based item.')
}).describe('InvoicePendingLineCreate represents the create model for an invoice line that is sold to the customer based on usage.')).min(1).describe('The lines to be created.')
}).describe('InvoicePendingLineCreate represents the create model for a pending invoice line.')


/**
 * Simulate an invoice for a customer.

This call will simulate an invoice for a customer based on the pending line items.

The call will return the total amount of the invoice and the line items that will be included in the invoice.
 * @summary Simulate an invoice for a customer
 */
export const simulateInvoicePathCustomerIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const SimulateInvoiceParams = zod.object({
  "customerId": zod.coerce.string().regex(simulateInvoicePathCustomerIdRegExp)
})

export const simulateInvoiceBodyNumberOneMax = 256;

export const simulateInvoiceBodyCurrencyOneMin = 3;
export const simulateInvoiceBodyCurrencyOneMax = 3;


export const simulateInvoiceBodyCurrencyOneRegExp = new RegExp('^[A-Z]{3}$');
export const simulateInvoiceBodyLinesItemNameMax = 256;

export const simulateInvoiceBodyLinesItemDescriptionMax = 1024;

export const simulateInvoiceBodyLinesItemTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const simulateInvoiceBodyLinesItemPriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneOnePaymentTermDefault = `in_advance`;export const simulateInvoiceBodyLinesItemPriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const simulateInvoiceBodyLinesItemPriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneFourMultiplierDefault = `1`;export const simulateInvoiceBodyLinesItemPriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemFeatureKeyMax = 64;


export const simulateInvoiceBodyLinesItemFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const simulateInvoiceBodyLinesItemRateCardOneFeatureKeyMax = 64;


export const simulateInvoiceBodyLinesItemRateCardOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const simulateInvoiceBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault = `in_advance`;export const simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierDefault = `1`;export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const simulateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const simulateInvoiceBodyLinesItemQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemPreLinePeriodQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const simulateInvoiceBodyLinesItemIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const SimulateInvoiceBody = zod.object({
  "number": zod.coerce.string().min(1).max(simulateInvoiceBodyNumberOneMax).describe('InvoiceNumber is a unique identifier for the invoice, generated by the\ninvoicing app.\n\nThe uniqueness depends on a lot of factors:\n- app setting (unique per app or unique per customer)\n- multiple app scenarios (multiple apps generating invoices with the same prefix)').optional().describe('The number of the invoice.'),
  "currency": zod.coerce.string().min(simulateInvoiceBodyCurrencyOneMin).max(simulateInvoiceBodyCurrencyOneMax).regex(simulateInvoiceBodyCurrencyOneRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.').describe('Currency for all invoice line items.\n\nMulti currency invoices are not supported yet.'),
  "lines": zod.array(zod.object({
  "name": zod.coerce.string().min(1).max(simulateInvoiceBodyLinesItemNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(simulateInvoiceBodyLinesItemDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(simulateInvoiceBodyLinesItemTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('Tax config specify the tax configuration for this line.'),
  "period": zod.object({
  "from": zod.coerce.date().describe('Period start time.'),
  "to": zod.coerce.date().describe('Period end time.')
}).describe('A period with a start and end time.').describe('Period of the line item applies to for revenue recognition pruposes.\n\nBilling always treats periods as start being inclusive and end being exclusive.'),
  "invoiceAt": zod.coerce.date().describe('The time this line item should be invoiced.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(simulateInvoiceBodyLinesItemPriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(simulateInvoiceBodyLinesItemPriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').optional().describe('Price of the usage-based item being sold.'),
  "featureKey": zod.coerce.string().min(1).max(simulateInvoiceBodyLinesItemFeatureKeyMax).regex(simulateInvoiceBodyLinesItemFeatureKeyRegExp).optional().describe('The feature that the usage is based on.'),
  "rateCard": zod.object({
  "featureKey": zod.coerce.string().min(1).max(simulateInvoiceBodyLinesItemRateCardOneFeatureKeyMax).regex(simulateInvoiceBodyLinesItemRateCardOneFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(simulateInvoiceBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.'),
  "correlationId": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp).optional().describe('Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.')
}).describe('A percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.'),
  "correlationId": zod.coerce.string().regex(simulateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp).optional().describe('Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.')
}).describe('A usage discount.').optional().describe('The usage discount.')
}).describe('A discount by type.').optional().describe('The discounts that are applied to the line.')
}).describe('InvoiceUsageBasedRateCard represents the rate card (intent) for an usage-based line.').optional().describe('The rate card that is used for this line.\n\nThe rate card captures the intent of the price and discounts for the usage-based item.'),
  "quantity": zod.coerce.string().regex(simulateInvoiceBodyLinesItemQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the item being sold.'),
  "preLinePeriodQuantity": zod.coerce.string().regex(simulateInvoiceBodyLinesItemPreLinePeriodQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The quantity of the item used before this line\'s period, if the line is billed progressively.'),
  "id": zod.coerce.string().regex(simulateInvoiceBodyLinesItemIdRegExp).optional().describe('ID of the line. If not specified it will be auto-generated.\n\nWhen discounts are specified, this must be provided, so that the discount can reference it.')
}).describe('InvoiceSimulationLine represents a usage-based line item that can be input to the simulation endpoint.')).describe('Lines to be included in the generated invoice.')
}).describe('InvoiceSimulationInput is the input for simulating an invoice.')


/**
 * List invoices based on the specified filters.

The expand option can be used to include additional information (besides the invoice header and totals)
in the response. For example by adding the expand=lines option the invoice lines will be included in the response.

Gathering invoices will always show the current usage calculated on the fly.
 * @summary List invoices
 */
export const listInvoicesQueryCustomersItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listInvoicesQueryPageDefault = 1;

export const listInvoicesQueryPageSizeDefault = 100;
export const listInvoicesQueryPageSizeMax = 1000;



export const ListInvoicesQueryParams = zod.object({
  "statuses": zod.array(zod.enum(['gathering', 'draft', 'issuing', 'issued', 'payment_processing', 'overdue', 'paid', 'uncollectible', 'voided']).describe('InvoiceStatus describes the status of an invoice.')).optional().describe('Filter by the invoice status.'),
  "extendedStatuses": zod.array(zod.coerce.string()).optional().describe('Filter by invoice extended statuses'),
  "issuedAfter": zod.coerce.date().optional().describe('Filter by invoice issued time.\nInclusive.'),
  "issuedBefore": zod.coerce.date().optional().describe('Filter by invoice issued time.\nInclusive.'),
  "periodStartAfter": zod.coerce.date().optional().describe('Filter by period start time.\nInclusive.'),
  "periodStartBefore": zod.coerce.date().optional().describe('Filter by period start time.\nInclusive.'),
  "createdAfter": zod.coerce.date().optional().describe('Filter by invoice created time.\nInclusive.'),
  "createdBefore": zod.coerce.date().optional().describe('Filter by invoice created time.\nInclusive.'),
  "expand": zod.array(zod.enum(['lines', 'preceding', 'workflow.apps']).describe('InvoiceExpand specifies the parts of the invoice to expand in the list output.')).optional().describe('What parts of the list output to expand in listings'),
  "customers": zod.array(zod.coerce.string().regex(listInvoicesQueryCustomersItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('Filter by customer ID'),
  "includeDeleted": zod.coerce.boolean().optional().describe('Include deleted invoices'),
  "page": zod.coerce.number().min(1).default(listInvoicesQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listInvoicesQueryPageSizeMax).default(listInvoicesQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['customer.name', 'issuedAt', 'status', 'createdAt', 'updatedAt', 'periodStart']).optional().describe('The order by field.')
})


/**
 * Create a new invoice from the pending line items.

This should be only called if for some reason we need to invoice a customer outside of the normal billing cycle.

When creating an invoice, the pending line items will be marked as invoiced and the invoice will be created with the total amount of the pending items.

New pending line items will be created for the period between now() and the next billing cycle's begining date for any metered item.

The call can return multiple invoices if the pending line items are in different currencies.
 * @summary Invoice a customer based on the pending line items
 */
export const invoicePendingLinesActionBodyFiltersOneLineIdsItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const invoicePendingLinesActionBodyCustomerIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const InvoicePendingLinesActionBody = zod.object({
  "filters": zod.object({
  "lineIds": zod.array(zod.coerce.string().regex(invoicePendingLinesActionBodyFiltersOneLineIdsItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('The pending line items to include in the invoice, if not provided:\n- all line items that have invoice_at < asOf will be included\n- [progressive billing only] all usage based line items will be included up to asOf, new\nusage-based line items will be staged for the rest of the billing cycle\n\nAll lineIDs present in the list, must exists and must be invoicable as of asOf, or the action will fail.')
}).describe('InvoicePendingLinesActionFiltersInput specifies which lines to include in the invoice.').optional().describe('Filters to apply when creating the invoice.'),
  "asOf": zod.coerce.date().optional().describe('The time as of which the invoice is created.\n\nIf not provided, the current time is used.'),
  "customerId": zod.coerce.string().regex(invoicePendingLinesActionBodyCustomerIdRegExp).describe('The customer ID for which to create the invoice.'),
  "progressiveBillingOverride": zod.coerce.boolean().optional().describe('Override the progressive billing setting of the customer.\n\nCan be used to disable\/enable progressive billing in case the business logic\nrequires it, if not provided the billing profile\'s progressive billing setting will be used.')
}).describe('BillingInvoiceActionInput is the input for creating an invoice.\n\nInvoice creation is always based on already pending line items created by the billingCreateLineByCustomer\noperation. Empty invoices are not allowed.')


/**
 * Get an invoice by ID.

Gathering invoices will always show the current usage calculated on the fly.
 * @summary Get an invoice
 */
export const getInvoicePathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetInvoiceParams = zod.object({
  "invoiceId": zod.coerce.string().regex(getInvoicePathInvoiceIdRegExp)
})

export const getInvoiceQueryIncludeDeletedLinesDefault = false;

export const GetInvoiceQueryParams = zod.object({
  "expand": zod.array(zod.enum(['lines', 'preceding', 'workflow.apps']).describe('InvoiceExpand specifies the parts of the invoice to expand in the list output.')).default([`lines`]),
  "includeDeletedLines": zod.coerce.boolean().default(getInvoiceQueryIncludeDeletedLinesDefault)
})


/**
 * Delete an invoice

Only invoices that are in the draft (or earlier) status can be deleted.

Invoices that are post finalization can only be voided.
 * @summary Delete an invoice
 */
export const deleteInvoicePathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeleteInvoiceParams = zod.object({
  "invoiceId": zod.coerce.string().regex(deleteInvoicePathInvoiceIdRegExp)
})


/**
 * Update an invoice

Only invoices in draft or earlier status can be updated.
 * @summary Update an invoice
 */
export const updateInvoicePathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdateInvoiceParams = zod.object({
  "invoiceId": zod.coerce.string().regex(updateInvoicePathInvoiceIdRegExp)
})

export const updateInvoiceBodyDescriptionMax = 1024;

export const updateInvoiceBodySupplierOneKeyMax = 256;

export const updateInvoiceBodySupplierOneTaxIdOneCodeOneMax = 32;

export const updateInvoiceBodySupplierOneAddressesItemCountryOneMin = 2;
export const updateInvoiceBodySupplierOneAddressesItemCountryOneMax = 2;


export const updateInvoiceBodySupplierOneAddressesItemCountryOneRegExp = new RegExp('^[A-Z]{2}$');
export const updateInvoiceBodySupplierOneAddressesMax = 1;

export const updateInvoiceBodyCustomerOneKeyMax = 256;

export const updateInvoiceBodyCustomerOneTaxIdOneCodeOneMax = 32;

export const updateInvoiceBodyCustomerOneAddressesItemCountryOneMin = 2;
export const updateInvoiceBodyCustomerOneAddressesItemCountryOneMax = 2;


export const updateInvoiceBodyCustomerOneAddressesItemCountryOneRegExp = new RegExp('^[A-Z]{2}$');
export const updateInvoiceBodyCustomerOneAddressesMax = 1;

export const updateInvoiceBodyLinesItemNameMax = 256;

export const updateInvoiceBodyLinesItemDescriptionMax = 1024;

export const updateInvoiceBodyLinesItemTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const updateInvoiceBodyLinesItemPriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneOnePaymentTermDefault = `in_advance`;export const updateInvoiceBodyLinesItemPriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const updateInvoiceBodyLinesItemPriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneFourMultiplierDefault = `1`;export const updateInvoiceBodyLinesItemPriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemPriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemFeatureKeyMax = 64;


export const updateInvoiceBodyLinesItemFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updateInvoiceBodyLinesItemRateCardOneFeatureKeyMax = 64;


export const updateInvoiceBodyLinesItemRateCardOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updateInvoiceBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault = `in_advance`;export const updateInvoiceBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const updateInvoiceBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierDefault = `1`;export const updateInvoiceBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const updateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const updateInvoiceBodyLinesItemIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneAutoAdvanceDefault = true;export const updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDraftPeriodDefault = `P0D`;export const updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDueAfterDefault = `P30D`;export const updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const updateInvoiceBodyWorkflowOneWorkflowOnePaymentOneCollectionMethodDefault = `charge_automatically`;

export const UpdateInvoiceBody = zod.object({
  "description": zod.coerce.string().max(updateInvoiceBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "supplier": zod.object({
  "key": zod.coerce.string().min(1).max(updateInvoiceBodySupplierOneKeyMax).optional().describe('An optional unique key of the party (if available)'),
  "name": zod.coerce.string().optional().describe('Legal name or representation of the organization.'),
  "taxId": zod.object({
  "code": zod.coerce.string().min(1).max(updateInvoiceBodySupplierOneTaxIdOneCodeOneMax).describe('TaxIdentificationCode is a normalized tax code shown on the original identity document.').optional().describe('Normalized tax code shown on the original identity document.')
}).describe('Identity stores the details required to identify an entity for tax purposes in a specific country.').optional().describe('The entity\'s legal ID code used for tax purposes. They may have\nother numbers, but we\'re only interested in those valid for tax purposes.'),
  "addresses": zod.array(zod.object({
  "country": zod.coerce.string().min(updateInvoiceBodySupplierOneAddressesItemCountryOneMin).max(updateInvoiceBodySupplierOneAddressesItemCountryOneMax).regex(updateInvoiceBodySupplierOneAddressesItemCountryOneRegExp).describe('[ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.').optional().describe('Country code in [ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 format.'),
  "postalCode": zod.coerce.string().optional().describe('Postal code.'),
  "state": zod.coerce.string().optional().describe('State or province.'),
  "city": zod.coerce.string().optional().describe('City.'),
  "line1": zod.coerce.string().optional().describe('First line of the address.'),
  "line2": zod.coerce.string().optional().describe('Second line of the address.'),
  "phoneNumber": zod.coerce.string().optional().describe('Phone number.')
}).describe('Address')).max(updateInvoiceBodySupplierOneAddressesMax).optional().describe('Regular post addresses for where information should be sent if needed.')
}).describe('Resource update operation model.').describe('The supplier of the lines included in the invoice.'),
  "customer": zod.object({
  "key": zod.coerce.string().min(1).max(updateInvoiceBodyCustomerOneKeyMax).optional().describe('An optional unique key of the party (if available)'),
  "name": zod.coerce.string().optional().describe('Legal name or representation of the organization.'),
  "taxId": zod.object({
  "code": zod.coerce.string().min(1).max(updateInvoiceBodyCustomerOneTaxIdOneCodeOneMax).describe('TaxIdentificationCode is a normalized tax code shown on the original identity document.').optional().describe('Normalized tax code shown on the original identity document.')
}).describe('Identity stores the details required to identify an entity for tax purposes in a specific country.').optional().describe('The entity\'s legal ID code used for tax purposes. They may have\nother numbers, but we\'re only interested in those valid for tax purposes.'),
  "addresses": zod.array(zod.object({
  "country": zod.coerce.string().min(updateInvoiceBodyCustomerOneAddressesItemCountryOneMin).max(updateInvoiceBodyCustomerOneAddressesItemCountryOneMax).regex(updateInvoiceBodyCustomerOneAddressesItemCountryOneRegExp).describe('[ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.').optional().describe('Country code in [ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 format.'),
  "postalCode": zod.coerce.string().optional().describe('Postal code.'),
  "state": zod.coerce.string().optional().describe('State or province.'),
  "city": zod.coerce.string().optional().describe('City.'),
  "line1": zod.coerce.string().optional().describe('First line of the address.'),
  "line2": zod.coerce.string().optional().describe('Second line of the address.'),
  "phoneNumber": zod.coerce.string().optional().describe('Phone number.')
}).describe('Address')).max(updateInvoiceBodyCustomerOneAddressesMax).optional().describe('Regular post addresses for where information should be sent if needed.')
}).describe('Resource update operation model.').describe('The customer the invoice is sent to.'),
  "lines": zod.array(zod.object({
  "name": zod.coerce.string().min(1).max(updateInvoiceBodyLinesItemNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updateInvoiceBodyLinesItemDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(updateInvoiceBodyLinesItemTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('Tax config specify the tax configuration for this line.'),
  "period": zod.object({
  "from": zod.coerce.date().describe('Period start time.'),
  "to": zod.coerce.date().describe('Period end time.')
}).describe('A period with a start and end time.').describe('Period of the line item applies to for revenue recognition pruposes.\n\nBilling always treats periods as start being inclusive and end being exclusive.'),
  "invoiceAt": zod.coerce.date().describe('The time this line item should be invoiced.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(updateInvoiceBodyLinesItemPriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(updateInvoiceBodyLinesItemPriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemPriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').optional().describe('Price of the usage-based item being sold.'),
  "featureKey": zod.coerce.string().min(1).max(updateInvoiceBodyLinesItemFeatureKeyMax).regex(updateInvoiceBodyLinesItemFeatureKeyRegExp).optional().describe('The feature that the usage is based on.'),
  "rateCard": zod.object({
  "featureKey": zod.coerce.string().min(1).max(updateInvoiceBodyLinesItemRateCardOneFeatureKeyMax).regex(updateInvoiceBodyLinesItemRateCardOneFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOneTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(updateInvoiceBodyLinesItemRateCardOnePriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(updateInvoiceBodyLinesItemRateCardOnePriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOnePriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.'),
  "correlationId": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOneDiscountsOnePercentageOneCorrelationIdRegExp).optional().describe('Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.')
}).describe('A percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.'),
  "correlationId": zod.coerce.string().regex(updateInvoiceBodyLinesItemRateCardOneDiscountsOneUsageOneCorrelationIdRegExp).optional().describe('Correlation ID for the discount.\n\nThis is used to link discounts across different invoices (progressive billing use case).\n\nIf not provided, the invoicing engine will auto-generate one. When editing an invoice line,\nplease make sure to keep the same correlation ID of the discount or in progressive billing\nsetups the discount amounts might be incorrect.')
}).describe('A usage discount.').optional().describe('The usage discount.')
}).describe('A discount by type.').optional().describe('The discounts that are applied to the line.')
}).describe('InvoiceUsageBasedRateCard represents the rate card (intent) for an usage-based line.').optional().describe('The rate card that is used for this line.\n\nThe rate card captures the intent of the price and discounts for the usage-based item.'),
  "id": zod.coerce.string().regex(updateInvoiceBodyLinesItemIdRegExp).optional().describe('The ID of the line.')
}).describe('InvoiceLineReplaceUpdate represents the update model for an UBP invoice line.\n\nThis type makes ID optional to allow for creating new lines as part of the update.')).describe('The lines included in the invoice.'),
  "workflow": zod.object({
  "workflow": zod.object({
  "invoicing": zod.object({
  "autoAdvance": zod.coerce.boolean().default(updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneAutoAdvanceDefault).describe('Whether to automatically issue the invoice after the draftPeriod has passed.'),
  "draftPeriod": zod.coerce.string().default(updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDraftPeriodDefault).describe('The period for the invoice to be kept in draft status for manual reviews.'),
  "dueAfter": zod.coerce.string().default(updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDueAfterDefault).describe('The period after which the invoice is due.\nWith some payment solutions it\'s only applicable for manual collection method.'),
  "defaultTaxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(updateInvoiceBodyWorkflowOneWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('Default tax configuration to apply to the invoices.')
}).describe('InvoiceWorkflowInvoicingSettingsReplaceUpdate represents the update model for the invoicing settings of an invoice workflow.').describe('The invoicing settings for this workflow'),
  "payment": zod.object({
  "collectionMethod": zod.enum(['charge_automatically', 'send_invoice']).describe('CollectionMethod specifies how the invoice should be collected (automatic vs manual)').default(updateInvoiceBodyWorkflowOneWorkflowOnePaymentOneCollectionMethodDefault).describe('The payment method for the invoice.')
}).describe('BillingWorkflowPaymentSettings represents the payment settings for a billing workflow').describe('The payment settings for this workflow')
}).describe('Mutable workflow settings for an invoice.\n\nOther fields on the invoice\'s workflow are not mutable, they serve as a history of the invoice\'s workflow\nat creation time.').describe('The workflow used for this invoice.')
}).describe('InvoiceWorkflowReplaceUpdate represents the update model for an invoice workflow.\n\nFields that are immutable a re removed from the model. This is based on InvoiceWorkflowSettings.').describe('The workflow settings for the invoice.')
}).describe('InvoiceReplaceUpdate represents the update model for an invoice.')


/**
 * Advance the invoice's state to the next status.

The call doesn't "approve the invoice", it only advances the invoice to the next status if the transition would be automatic.

The action can be called when the invoice's statusDetails' actions field contain the "advance" action.
 * @summary Advance the invoice's state to the next status
 */
export const advanceInvoiceActionPathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const AdvanceInvoiceActionParams = zod.object({
  "invoiceId": zod.coerce.string().regex(advanceInvoiceActionPathInvoiceIdRegExp)
})


/**
 * Approve an invoice and start executing the payment workflow.

This call instantly sends the invoice to the customer using the configured billing profile app.

This call is valid in two invoice statuses:
- `draft`: the invoice will be sent to the customer, the invluce state becomes issued
- `manual_approval_needed`: the invoice will be sent to the customer, the invoice state becomes issued
 * @summary Send the invoice to the customer
 */
export const approveInvoiceActionPathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ApproveInvoiceActionParams = zod.object({
  "invoiceId": zod.coerce.string().regex(approveInvoiceActionPathInvoiceIdRegExp)
})


/**
 * Retry advancing the invoice after a failed attempt.

The action can be called when the invoice's statusDetails' actions field contain the "retry" action.
 * @summary Retry advancing the invoice after a failed attempt.
 */
export const retryInvoiceActionPathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const RetryInvoiceActionParams = zod.object({
  "invoiceId": zod.coerce.string().regex(retryInvoiceActionPathInvoiceIdRegExp)
})


/**
 * Snapshot quantities for usage based line items.

This call will snapshot the quantities for all usage based line items in the invoice.

This call is only valid in `draft.waiting_for_collection` status, where the collection period
can be skipped using this action.
 * @summary Snapshot quantities for usage based line items
 */
export const snapshotQuantitiesInvoiceActionPathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const SnapshotQuantitiesInvoiceActionParams = zod.object({
  "invoiceId": zod.coerce.string().regex(snapshotQuantitiesInvoiceActionPathInvoiceIdRegExp)
})


/**
 * Recalculate an invoice's tax amounts (using the app set in the customer's billing profile)

Note: charges might apply, depending on the tax provider.
 * @summary Recalculate an invoice's tax amounts
 */
export const recalculateInvoiceTaxActionPathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const RecalculateInvoiceTaxActionParams = zod.object({
  "invoiceId": zod.coerce.string().regex(recalculateInvoiceTaxActionPathInvoiceIdRegExp)
})


/**
 * Void an invoice

Only invoices that have been alread issued can be voided.

Voiding an invoice will mark it as voided, the user can specify how to handle the voided line items.
 * @summary Void an invoice
 */
export const voidInvoiceActionPathInvoiceIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const VoidInvoiceActionParams = zod.object({
  "invoiceId": zod.coerce.string().regex(voidInvoiceActionPathInvoiceIdRegExp)
})

export const voidInvoiceActionBodyOverridesItemLineIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const VoidInvoiceActionBody = zod.object({
  "action": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('How much of the total line items to be voided? (e.g. 100% means all charges are voided)'),
  "action": zod.union([zod.object({
  "type": zod.enum(['discard'])
}).describe('VoidInvoiceLineDiscardAction describes how to handle the voidied line item in the invoice.'),zod.object({
  "type": zod.enum(['pending']),
  "nextInvoiceAt": zod.coerce.date().optional().describe('The time at which the line item should be invoiced again.\n\nIf not provided, the line item will be re-invoiced now.')
}).describe('VoidInvoiceLinePendingAction describes how to handle the voidied line item in the invoice.')]).describe('VoidInvoiceLineAction describes how to handle a specific line item in the invoice when voiding.').describe('The action to take on the line items.')
}).describe('InvoiceVoidAction describes how to handle the voided line items.').describe('The action to take on the voided line items.'),
  "reason": zod.coerce.string().describe('The reason for voiding the invoice.'),
  "overrides": zod.array(zod.object({
  "lineId": zod.coerce.string().regex(voidInvoiceActionBodyOverridesItemLineIdRegExp).describe('The line item ID to override.'),
  "action": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('How much of the total line items to be voided? (e.g. 100% means all charges are voided)'),
  "action": zod.union([zod.object({
  "type": zod.enum(['discard'])
}).describe('VoidInvoiceLineDiscardAction describes how to handle the voidied line item in the invoice.'),zod.object({
  "type": zod.enum(['pending']),
  "nextInvoiceAt": zod.coerce.date().optional().describe('The time at which the line item should be invoiced again.\n\nIf not provided, the line item will be re-invoiced now.')
}).describe('VoidInvoiceLinePendingAction describes how to handle the voidied line item in the invoice.')]).describe('VoidInvoiceLineAction describes how to handle a specific line item in the invoice when voiding.').describe('The action to take on the line items.')
}).describe('InvoiceVoidAction describes how to handle the voided line items.').describe('The action to take on the line item.')
}).describe('VoidInvoiceLineOverride describes how to handle a specific line item in the invoice when voiding.')).nullish().describe('Per line item overrides for the action.\n\nIf not specified, the `action` will be applied to all line items.')
}).describe('Request to void an invoice')


/**
 * List all billing profiles matching the specified filters.

The expand option can be used to include additional information (besides the billing profile)
in the response. For example by adding the expand=apps option the apps used by the billing profile
will be included in the response.
 * @summary List billing profiles
 */
export const listBillingProfilesQueryIncludeArchivedDefault = false;export const listBillingProfilesQueryPageDefault = 1;

export const listBillingProfilesQueryPageSizeDefault = 100;
export const listBillingProfilesQueryPageSizeMax = 1000;



export const ListBillingProfilesQueryParams = zod.object({
  "includeArchived": zod.coerce.boolean().default(listBillingProfilesQueryIncludeArchivedDefault),
  "expand": zod.array(zod.enum(['apps']).describe('BillingProfileExpand details what profile fields to expand')).optional(),
  "page": zod.coerce.number().min(1).default(listBillingProfilesQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listBillingProfilesQueryPageSizeMax).default(listBillingProfilesQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['createdAt', 'updatedAt', 'default', 'name']).optional().describe('The order by field.')
})


/**
 * Create a new billing profile

Billing profiles are representations of a customer's billing information. Customer overrides
can be applied to a billing profile to customize the billing behavior for a specific customer.
 * @summary Create a new billing profile
 */
export const createBillingProfileBodyNameMax = 256;

export const createBillingProfileBodyDescriptionMax = 1024;

export const createBillingProfileBodySupplierOneKeyMax = 256;

export const createBillingProfileBodySupplierOneTaxIdOneCodeOneMax = 32;

export const createBillingProfileBodySupplierOneAddressesItemCountryOneMin = 2;
export const createBillingProfileBodySupplierOneAddressesItemCountryOneMax = 2;


export const createBillingProfileBodySupplierOneAddressesItemCountryOneRegExp = new RegExp('^[A-Z]{2}$');
export const createBillingProfileBodySupplierOneAddressesMax = 1;

export const createBillingProfileBodyWorkflowOneCollectionOneAlignmentOneTwoRecurringPeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const createBillingProfileBodyWorkflowOneCollectionOneAlignmentDefault = { type: "subscription" };export const createBillingProfileBodyWorkflowOneCollectionOneIntervalDefault = `PT1H`;export const createBillingProfileBodyWorkflowOneInvoicingOneAutoAdvanceDefault = true;export const createBillingProfileBodyWorkflowOneInvoicingOneDraftPeriodDefault = `P0D`;export const createBillingProfileBodyWorkflowOneInvoicingOneDueAfterDefault = `P30D`;export const createBillingProfileBodyWorkflowOneInvoicingOneProgressiveBillingDefault = true;export const createBillingProfileBodyWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const createBillingProfileBodyWorkflowOnePaymentOneCollectionMethodDefault = `charge_automatically`;export const createBillingProfileBodyWorkflowOneTaxOneEnabledDefault = true;export const createBillingProfileBodyWorkflowOneTaxOneEnforcedDefault = false;export const createBillingProfileBodyAppsOneTaxRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createBillingProfileBodyAppsOneInvoicingRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createBillingProfileBodyAppsOnePaymentRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const CreateBillingProfileBody = zod.object({
  "name": zod.coerce.string().min(1).max(createBillingProfileBodyNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createBillingProfileBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "supplier": zod.object({
  "id": zod.coerce.string().optional().describe('Unique identifier for the party (if available)'),
  "key": zod.coerce.string().min(1).max(createBillingProfileBodySupplierOneKeyMax).optional().describe('An optional unique key of the party (if available)'),
  "name": zod.coerce.string().optional().describe('Legal name or representation of the organization.'),
  "taxId": zod.object({
  "code": zod.coerce.string().min(1).max(createBillingProfileBodySupplierOneTaxIdOneCodeOneMax).describe('TaxIdentificationCode is a normalized tax code shown on the original identity document.').optional().describe('Normalized tax code shown on the original identity document.')
}).describe('Identity stores the details required to identify an entity for tax purposes in a specific country.').optional().describe('The entity\'s legal ID code used for tax purposes. They may have\nother numbers, but we\'re only interested in those valid for tax purposes.'),
  "addresses": zod.array(zod.object({
  "country": zod.coerce.string().min(createBillingProfileBodySupplierOneAddressesItemCountryOneMin).max(createBillingProfileBodySupplierOneAddressesItemCountryOneMax).regex(createBillingProfileBodySupplierOneAddressesItemCountryOneRegExp).describe('[ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.').optional().describe('Country code in [ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 format.'),
  "postalCode": zod.coerce.string().optional().describe('Postal code.'),
  "state": zod.coerce.string().optional().describe('State or province.'),
  "city": zod.coerce.string().optional().describe('City.'),
  "line1": zod.coerce.string().optional().describe('First line of the address.'),
  "line2": zod.coerce.string().optional().describe('Second line of the address.'),
  "phoneNumber": zod.coerce.string().optional().describe('Phone number.')
}).describe('Address')).max(createBillingProfileBodySupplierOneAddressesMax).optional().describe('Regular post addresses for where information should be sent if needed.')
}).describe('Party represents a person or business entity.').describe('The name and contact information for the supplier this billing profile represents'),
  "default": zod.coerce.boolean().describe('Is this the default profile?'),
  "workflow": zod.object({
  "collection": zod.object({
  "alignment": zod.union([zod.object({
  "type": zod.enum(['subscription'])
}).describe('BillingWorkflowCollectionAlignmentSubscription specifies the alignment for collecting the pending line items\ninto an invoice.'),zod.object({
  "type": zod.enum(['anchored']),
  "recurringPeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(createBillingProfileBodyWorkflowOneCollectionOneAlignmentOneTwoRecurringPeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval. Heuristically maps ISO duraitons to enum values or returns the ISO duration.'),
  "anchor": zod.coerce.date().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').describe('The recurring period for the alignment.')
}).describe('BillingWorkflowCollectionAlignmentAnchored specifies the alignment for collecting the pending line items\ninto an invoice.')]).describe('The alignment for collecting the pending line items into an invoice.\n\nDefaults to subscription, which means that we are to create a new invoice every time the\na subscription period starts (for in advance items) or ends (for in arrears items).').default(createBillingProfileBodyWorkflowOneCollectionOneAlignmentDefault).describe('The alignment for collecting the pending line items into an invoice.'),
  "interval": zod.coerce.string().default(createBillingProfileBodyWorkflowOneCollectionOneIntervalDefault).describe('This grace period can be used to delay the collection of the pending line items specified in\nalignment.\n\nThis is useful, in case of multiple subscriptions having slightly different billing periods.')
}).describe('Workflow collection specifies how to collect the pending line items for an invoice').optional().describe('The collection settings for this workflow'),
  "invoicing": zod.object({
  "autoAdvance": zod.coerce.boolean().default(createBillingProfileBodyWorkflowOneInvoicingOneAutoAdvanceDefault).describe('Whether to automatically issue the invoice after the draftPeriod has passed.'),
  "draftPeriod": zod.coerce.string().default(createBillingProfileBodyWorkflowOneInvoicingOneDraftPeriodDefault).describe('The period for the invoice to be kept in draft status for manual reviews.'),
  "dueAfter": zod.coerce.string().default(createBillingProfileBodyWorkflowOneInvoicingOneDueAfterDefault).describe('The period after which the invoice is due.\nWith some payment solutions it\'s only applicable for manual collection method.'),
  "progressiveBilling": zod.coerce.boolean().default(createBillingProfileBodyWorkflowOneInvoicingOneProgressiveBillingDefault).describe('Should progressive billing be allowed for this workflow?'),
  "defaultTaxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(createBillingProfileBodyWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('Default tax configuration to apply to the invoices.')
}).describe('BillingWorkflowInvoicingSettings represents the invoice settings for a billing workflow').optional().describe('The invoicing settings for this workflow'),
  "payment": zod.object({
  "collectionMethod": zod.enum(['charge_automatically', 'send_invoice']).describe('CollectionMethod specifies how the invoice should be collected (automatic vs manual)').default(createBillingProfileBodyWorkflowOnePaymentOneCollectionMethodDefault).describe('The payment method for the invoice.')
}).describe('BillingWorkflowPaymentSettings represents the payment settings for a billing workflow').optional().describe('The payment settings for this workflow'),
  "tax": zod.object({
  "enabled": zod.coerce.boolean().default(createBillingProfileBodyWorkflowOneTaxOneEnabledDefault).describe('Enable automatic tax calculation when tax is supported by the app.\nFor example, with Stripe Invoicing when enabled, tax is calculated via Stripe Tax.'),
  "enforced": zod.coerce.boolean().default(createBillingProfileBodyWorkflowOneTaxOneEnforcedDefault).describe('Enforce tax calculation when tax is supported by the app.\nWhen enabled, OpenMeter will not allow to create an invoice without tax calculation.\nEnforcement is different per apps, for example, Stripe app requires customer\nto have a tax location when starting a paid subscription.')
}).describe('BillingWorkflowTaxSettings represents the tax settings for a billing workflow').optional().describe('The tax settings for this workflow')
}).describe('Resource create operation model.').describe('The billing workflow settings for this profile.'),
  "apps": zod.object({
  "tax": zod.coerce.string().regex(createBillingProfileBodyAppsOneTaxRegExp).describe('The tax app used for this workflow'),
  "invoicing": zod.coerce.string().regex(createBillingProfileBodyAppsOneInvoicingRegExp).describe('The invoicing app used for this workflow'),
  "payment": zod.coerce.string().regex(createBillingProfileBodyAppsOnePaymentRegExp).describe('The payment app used for this workflow')
}).describe('BillingProfileAppsCreate represents the input for creating a billing profile\'s apps').describe('The apps used by this billing profile.')
}).describe('BillingProfileCreate represents the input for creating a billing profile')


/**
 * Delete a billing profile by id.

Only such billing profiles can be deleted that are:
- not the default one
- not pinned to any customer using customer overrides
- only have finalized invoices
 * @summary Delete a billing profile
 */
export const deleteBillingProfilePathIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeleteBillingProfileParams = zod.object({
  "id": zod.coerce.string().regex(deleteBillingProfilePathIdRegExp)
})


/**
 * Get a billing profile by id.

The expand option can be used to include additional information (besides the billing profile)
in the response. For example by adding the expand=apps option the apps used by the billing profile
will be included in the response.
 * @summary Get a billing profile
 */
export const getBillingProfilePathIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetBillingProfileParams = zod.object({
  "id": zod.coerce.string().regex(getBillingProfilePathIdRegExp)
})

export const GetBillingProfileQueryParams = zod.object({
  "expand": zod.array(zod.enum(['apps']).describe('BillingProfileExpand details what profile fields to expand')).optional()
})


/**
 * Update a billing profile by id.

The apps field cannot be updated directly, if an app change is desired a new
profile should be created.
 * @summary Update a billing profile
 */
export const updateBillingProfilePathIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdateBillingProfileParams = zod.object({
  "id": zod.coerce.string().regex(updateBillingProfilePathIdRegExp)
})

export const updateBillingProfileBodyNameMax = 256;

export const updateBillingProfileBodyDescriptionMax = 1024;

export const updateBillingProfileBodySupplierOneKeyMax = 256;

export const updateBillingProfileBodySupplierOneTaxIdOneCodeOneMax = 32;

export const updateBillingProfileBodySupplierOneAddressesItemCountryOneMin = 2;
export const updateBillingProfileBodySupplierOneAddressesItemCountryOneMax = 2;


export const updateBillingProfileBodySupplierOneAddressesItemCountryOneRegExp = new RegExp('^[A-Z]{2}$');
export const updateBillingProfileBodySupplierOneAddressesMax = 1;

export const updateBillingProfileBodyWorkflowOneCollectionOneAlignmentOneTwoRecurringPeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const updateBillingProfileBodyWorkflowOneCollectionOneAlignmentDefault = { type: "subscription" };export const updateBillingProfileBodyWorkflowOneCollectionOneIntervalDefault = `PT1H`;export const updateBillingProfileBodyWorkflowOneInvoicingOneAutoAdvanceDefault = true;export const updateBillingProfileBodyWorkflowOneInvoicingOneDraftPeriodDefault = `P0D`;export const updateBillingProfileBodyWorkflowOneInvoicingOneDueAfterDefault = `P30D`;export const updateBillingProfileBodyWorkflowOneInvoicingOneProgressiveBillingDefault = true;export const updateBillingProfileBodyWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const updateBillingProfileBodyWorkflowOnePaymentOneCollectionMethodDefault = `charge_automatically`;export const updateBillingProfileBodyWorkflowOneTaxOneEnabledDefault = true;export const updateBillingProfileBodyWorkflowOneTaxOneEnforcedDefault = false;

export const UpdateBillingProfileBody = zod.object({
  "name": zod.coerce.string().min(1).max(updateBillingProfileBodyNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updateBillingProfileBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "supplier": zod.object({
  "id": zod.coerce.string().optional().describe('Unique identifier for the party (if available)'),
  "key": zod.coerce.string().min(1).max(updateBillingProfileBodySupplierOneKeyMax).optional().describe('An optional unique key of the party (if available)'),
  "name": zod.coerce.string().optional().describe('Legal name or representation of the organization.'),
  "taxId": zod.object({
  "code": zod.coerce.string().min(1).max(updateBillingProfileBodySupplierOneTaxIdOneCodeOneMax).describe('TaxIdentificationCode is a normalized tax code shown on the original identity document.').optional().describe('Normalized tax code shown on the original identity document.')
}).describe('Identity stores the details required to identify an entity for tax purposes in a specific country.').optional().describe('The entity\'s legal ID code used for tax purposes. They may have\nother numbers, but we\'re only interested in those valid for tax purposes.'),
  "addresses": zod.array(zod.object({
  "country": zod.coerce.string().min(updateBillingProfileBodySupplierOneAddressesItemCountryOneMin).max(updateBillingProfileBodySupplierOneAddressesItemCountryOneMax).regex(updateBillingProfileBodySupplierOneAddressesItemCountryOneRegExp).describe('[ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.').optional().describe('Country code in [ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 format.'),
  "postalCode": zod.coerce.string().optional().describe('Postal code.'),
  "state": zod.coerce.string().optional().describe('State or province.'),
  "city": zod.coerce.string().optional().describe('City.'),
  "line1": zod.coerce.string().optional().describe('First line of the address.'),
  "line2": zod.coerce.string().optional().describe('Second line of the address.'),
  "phoneNumber": zod.coerce.string().optional().describe('Phone number.')
}).describe('Address')).max(updateBillingProfileBodySupplierOneAddressesMax).optional().describe('Regular post addresses for where information should be sent if needed.')
}).describe('Party represents a person or business entity.').describe('The name and contact information for the supplier this billing profile represents'),
  "default": zod.coerce.boolean().describe('Is this the default profile?'),
  "workflow": zod.object({
  "collection": zod.object({
  "alignment": zod.union([zod.object({
  "type": zod.enum(['subscription'])
}).describe('BillingWorkflowCollectionAlignmentSubscription specifies the alignment for collecting the pending line items\ninto an invoice.'),zod.object({
  "type": zod.enum(['anchored']),
  "recurringPeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(updateBillingProfileBodyWorkflowOneCollectionOneAlignmentOneTwoRecurringPeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval. Heuristically maps ISO duraitons to enum values or returns the ISO duration.'),
  "anchor": zod.coerce.date().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').describe('The recurring period for the alignment.')
}).describe('BillingWorkflowCollectionAlignmentAnchored specifies the alignment for collecting the pending line items\ninto an invoice.')]).describe('The alignment for collecting the pending line items into an invoice.\n\nDefaults to subscription, which means that we are to create a new invoice every time the\na subscription period starts (for in advance items) or ends (for in arrears items).').default(updateBillingProfileBodyWorkflowOneCollectionOneAlignmentDefault).describe('The alignment for collecting the pending line items into an invoice.'),
  "interval": zod.coerce.string().default(updateBillingProfileBodyWorkflowOneCollectionOneIntervalDefault).describe('This grace period can be used to delay the collection of the pending line items specified in\nalignment.\n\nThis is useful, in case of multiple subscriptions having slightly different billing periods.')
}).describe('Workflow collection specifies how to collect the pending line items for an invoice').optional().describe('The collection settings for this workflow'),
  "invoicing": zod.object({
  "autoAdvance": zod.coerce.boolean().default(updateBillingProfileBodyWorkflowOneInvoicingOneAutoAdvanceDefault).describe('Whether to automatically issue the invoice after the draftPeriod has passed.'),
  "draftPeriod": zod.coerce.string().default(updateBillingProfileBodyWorkflowOneInvoicingOneDraftPeriodDefault).describe('The period for the invoice to be kept in draft status for manual reviews.'),
  "dueAfter": zod.coerce.string().default(updateBillingProfileBodyWorkflowOneInvoicingOneDueAfterDefault).describe('The period after which the invoice is due.\nWith some payment solutions it\'s only applicable for manual collection method.'),
  "progressiveBilling": zod.coerce.boolean().default(updateBillingProfileBodyWorkflowOneInvoicingOneProgressiveBillingDefault).describe('Should progressive billing be allowed for this workflow?'),
  "defaultTaxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(updateBillingProfileBodyWorkflowOneInvoicingOneDefaultTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('Default tax configuration to apply to the invoices.')
}).describe('BillingWorkflowInvoicingSettings represents the invoice settings for a billing workflow').optional().describe('The invoicing settings for this workflow'),
  "payment": zod.object({
  "collectionMethod": zod.enum(['charge_automatically', 'send_invoice']).describe('CollectionMethod specifies how the invoice should be collected (automatic vs manual)').default(updateBillingProfileBodyWorkflowOnePaymentOneCollectionMethodDefault).describe('The payment method for the invoice.')
}).describe('BillingWorkflowPaymentSettings represents the payment settings for a billing workflow').optional().describe('The payment settings for this workflow'),
  "tax": zod.object({
  "enabled": zod.coerce.boolean().default(updateBillingProfileBodyWorkflowOneTaxOneEnabledDefault).describe('Enable automatic tax calculation when tax is supported by the app.\nFor example, with Stripe Invoicing when enabled, tax is calculated via Stripe Tax.'),
  "enforced": zod.coerce.boolean().default(updateBillingProfileBodyWorkflowOneTaxOneEnforcedDefault).describe('Enforce tax calculation when tax is supported by the app.\nWhen enabled, OpenMeter will not allow to create an invoice without tax calculation.\nEnforcement is different per apps, for example, Stripe app requires customer\nto have a tax location when starting a paid subscription.')
}).describe('BillingWorkflowTaxSettings represents the tax settings for a billing workflow').optional().describe('The tax settings for this workflow')
}).describe('BillingWorkflow represents the settings for a billing workflow.').describe('The billing workflow settings for this profile.')
}).describe('BillingProfileReplaceUpdate represents the input for updating a billing profile\n\nThe apps field cannot be updated directly, if an app change is desired a new\nprofile should be created.')


/**
 * Create a new customer.
 * @summary Create customer
 */
export const createCustomerBodyNameMax = 256;

export const createCustomerBodyDescriptionMax = 1024;

export const createCustomerBodyKeyMax = 256;


export const createCustomerBodyUsageAttributionOneSubjectKeysMin = 0;

export const createCustomerBodyCurrencyOneMin = 3;
export const createCustomerBodyCurrencyOneMax = 3;


export const createCustomerBodyCurrencyOneRegExp = new RegExp('^[A-Z]{3}$');
export const createCustomerBodyBillingAddressOneCountryOneMin = 2;
export const createCustomerBodyBillingAddressOneCountryOneMax = 2;


export const createCustomerBodyBillingAddressOneCountryOneRegExp = new RegExp('^[A-Z]{2}$');


export const CreateCustomerBody = zod.object({
  "name": zod.coerce.string().min(1).max(createCustomerBodyNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createCustomerBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "key": zod.coerce.string().min(1).max(createCustomerBodyKeyMax).optional().describe('An optional unique key of the customer.\nEither key or usageAttribution.subjectKeys must be provided.\nUseful to reference the customer in external systems.\nFor example, your database ID.'),
  "usageAttribution": zod.object({
  "subjectKeys": zod.array(zod.coerce.string().min(1).describe('SubjectKey is a key that is used to identify a subject.')).min(createCustomerBodyUsageAttributionOneSubjectKeysMin).describe('The subjects that are attributed to the customer.\nCan be empty when no subjects are associated with the customer.')
}).describe('Mapping to attribute metered usage to the customer.\nOne customer can have zero or more subjects,\nbut one subject can only belong to one customer.').optional().describe('Mapping to attribute metered usage to the customer\nEither key or usageAttribution.subjectKeys must be provided.'),
  "primaryEmail": zod.coerce.string().optional().describe('The primary email address of the customer.'),
  "currency": zod.coerce.string().min(createCustomerBodyCurrencyOneMin).max(createCustomerBodyCurrencyOneMax).regex(createCustomerBodyCurrencyOneRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.').optional().describe('Currency of the customer.\nUsed for billing, tax and invoicing.'),
  "billingAddress": zod.object({
  "country": zod.coerce.string().min(createCustomerBodyBillingAddressOneCountryOneMin).max(createCustomerBodyBillingAddressOneCountryOneMax).regex(createCustomerBodyBillingAddressOneCountryOneRegExp).describe('[ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.').optional().describe('Country code in [ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 format.'),
  "postalCode": zod.coerce.string().optional().describe('Postal code.'),
  "state": zod.coerce.string().optional().describe('State or province.'),
  "city": zod.coerce.string().optional().describe('City.'),
  "line1": zod.coerce.string().optional().describe('First line of the address.'),
  "line2": zod.coerce.string().optional().describe('Second line of the address.'),
  "phoneNumber": zod.coerce.string().optional().describe('Phone number.')
}).describe('Address').optional().describe('The billing address of the customer.\nUsed for tax and invoicing.')
}).describe('Resource create operation model.')


/**
 * List customers.
 * @summary List customers
 */
export const listCustomersQueryPageDefault = 1;

export const listCustomersQueryPageSizeDefault = 100;
export const listCustomersQueryPageSizeMax = 1000;

export const listCustomersQueryIncludeDeletedDefault = false;

export const ListCustomersQueryParams = zod.object({
  "page": zod.coerce.number().min(1).default(listCustomersQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listCustomersQueryPageSizeMax).default(listCustomersQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'name', 'createdAt']).optional().describe('The order by field.'),
  "includeDeleted": zod.coerce.boolean().default(listCustomersQueryIncludeDeletedDefault).describe('Include deleted customers.'),
  "key": zod.coerce.string().optional().describe('Filter customers by key.\nCase-insensitive partial match.'),
  "name": zod.coerce.string().optional().describe('Filter customers by name.\nCase-insensitive partial match.'),
  "primaryEmail": zod.coerce.string().optional().describe('Filter customers by primary email.\nCase-insensitive partial match.'),
  "subject": zod.coerce.string().optional().describe('Filter customers by usage attribution subject.\nCase-insensitive partial match.'),
  "planKey": zod.coerce.string().optional().describe('Filter customers by the plan key of their susbcription.'),
  "expand": zod.array(zod.enum(['subscriptions']).describe('CustomerExpand specifies the parts of the customer to expand in the list output.')).optional().describe('What parts of the list output to expand in listings')
})


/**
 * Get a customer by ID or key.
 * @summary Get customer
 */
export const getCustomerPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const getCustomerPathCustomerIdOrKeyTwoMax = 256;



export const GetCustomerParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(getCustomerPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(getCustomerPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})

export const GetCustomerQueryParams = zod.object({
  "expand": zod.array(zod.enum(['subscriptions']).describe('CustomerExpand specifies the parts of the customer to expand in the list output.')).optional().describe('What parts of the customer output to expand')
})


/**
 * Update a customer by ID.
 * @summary Update customer
 */
export const updateCustomerPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const updateCustomerPathCustomerIdOrKeyTwoMax = 256;



export const UpdateCustomerParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(updateCustomerPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(updateCustomerPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})

export const updateCustomerBodyNameMax = 256;

export const updateCustomerBodyDescriptionMax = 1024;

export const updateCustomerBodyKeyMax = 256;


export const updateCustomerBodyUsageAttributionOneSubjectKeysMin = 0;

export const updateCustomerBodyCurrencyOneMin = 3;
export const updateCustomerBodyCurrencyOneMax = 3;


export const updateCustomerBodyCurrencyOneRegExp = new RegExp('^[A-Z]{3}$');
export const updateCustomerBodyBillingAddressOneCountryOneMin = 2;
export const updateCustomerBodyBillingAddressOneCountryOneMax = 2;


export const updateCustomerBodyBillingAddressOneCountryOneRegExp = new RegExp('^[A-Z]{2}$');


export const UpdateCustomerBody = zod.object({
  "name": zod.coerce.string().min(1).max(updateCustomerBodyNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updateCustomerBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "key": zod.coerce.string().min(1).max(updateCustomerBodyKeyMax).optional().describe('An optional unique key of the customer.\nEither key or usageAttribution.subjectKeys must be provided.\nUseful to reference the customer in external systems.\nFor example, your database ID.'),
  "usageAttribution": zod.object({
  "subjectKeys": zod.array(zod.coerce.string().min(1).describe('SubjectKey is a key that is used to identify a subject.')).min(updateCustomerBodyUsageAttributionOneSubjectKeysMin).describe('The subjects that are attributed to the customer.\nCan be empty when no subjects are associated with the customer.')
}).describe('Mapping to attribute metered usage to the customer.\nOne customer can have zero or more subjects,\nbut one subject can only belong to one customer.').optional().describe('Mapping to attribute metered usage to the customer\nEither key or usageAttribution.subjectKeys must be provided.'),
  "primaryEmail": zod.coerce.string().optional().describe('The primary email address of the customer.'),
  "currency": zod.coerce.string().min(updateCustomerBodyCurrencyOneMin).max(updateCustomerBodyCurrencyOneMax).regex(updateCustomerBodyCurrencyOneRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.').optional().describe('Currency of the customer.\nUsed for billing, tax and invoicing.'),
  "billingAddress": zod.object({
  "country": zod.coerce.string().min(updateCustomerBodyBillingAddressOneCountryOneMin).max(updateCustomerBodyBillingAddressOneCountryOneMax).regex(updateCustomerBodyBillingAddressOneCountryOneRegExp).describe('[ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.').optional().describe('Country code in [ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 format.'),
  "postalCode": zod.coerce.string().optional().describe('Postal code.'),
  "state": zod.coerce.string().optional().describe('State or province.'),
  "city": zod.coerce.string().optional().describe('City.'),
  "line1": zod.coerce.string().optional().describe('First line of the address.'),
  "line2": zod.coerce.string().optional().describe('Second line of the address.'),
  "phoneNumber": zod.coerce.string().optional().describe('Phone number.')
}).describe('Address').optional().describe('The billing address of the customer.\nUsed for tax and invoicing.')
}).describe('Resource update operation model.')


/**
 * Delete a customer by ID.
 * @summary Delete customer
 */
export const deleteCustomerPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const deleteCustomerPathCustomerIdOrKeyTwoMax = 256;



export const DeleteCustomerParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(deleteCustomerPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(deleteCustomerPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})


/**
 * Get the overall access of a customer.
 * @summary Get customer access
 */
export const getCustomerAccessPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const getCustomerAccessPathCustomerIdOrKeyTwoMax = 256;



export const GetCustomerAccessParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(getCustomerAccessPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(getCustomerAccessPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})


/**
 * List customers app data.
 * @summary List customer app data
 */
export const listCustomerAppDataPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listCustomerAppDataPathCustomerIdOrKeyTwoMax = 256;



export const ListCustomerAppDataParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(listCustomerAppDataPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(listCustomerAppDataPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})

export const listCustomerAppDataQueryPageDefault = 1;

export const listCustomerAppDataQueryPageSizeDefault = 100;
export const listCustomerAppDataQueryPageSizeMax = 1000;



export const ListCustomerAppDataQueryParams = zod.object({
  "page": zod.coerce.number().min(1).default(listCustomerAppDataQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listCustomerAppDataQueryPageSizeMax).default(listCustomerAppDataQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "type": zod.enum(['stripe', 'sandbox', 'custom_invoicing']).optional().describe('Filter customer data by app type.')
})


/**
 * Upsert customer app data.
 * @summary Upsert customer app data
 */
export const upsertCustomerAppDataPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const upsertCustomerAppDataPathCustomerIdOrKeyTwoMax = 256;



export const UpsertCustomerAppDataParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(upsertCustomerAppDataPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(upsertCustomerAppDataPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})

export const upsertCustomerAppDataBodyOneIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const upsertCustomerAppDataBodyTwoAppOneIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const upsertCustomerAppDataBodyTwoAppOneNameMax = 256;

export const upsertCustomerAppDataBodyTwoAppOneDescriptionMax = 1024;

export const upsertCustomerAppDataBodyTwoAppOneListingOneCapabilitiesItemKeyMax = 64;


export const upsertCustomerAppDataBodyTwoAppOneListingOneCapabilitiesItemKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const upsertCustomerAppDataBodyTwoIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const upsertCustomerAppDataBodyThreeAppOneIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const upsertCustomerAppDataBodyThreeAppOneNameMax = 256;

export const upsertCustomerAppDataBodyThreeAppOneDescriptionMax = 1024;

export const upsertCustomerAppDataBodyThreeAppOneListingOneCapabilitiesItemKeyMax = 64;


export const upsertCustomerAppDataBodyThreeAppOneListingOneCapabilitiesItemKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const upsertCustomerAppDataBodyThreeIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpsertCustomerAppDataBodyItem = zod.union([zod.object({
  "id": zod.coerce.string().regex(upsertCustomerAppDataBodyOneIdRegExp).optional().describe('The app ID.\nIf not provided, it will use the global default for the app type.'),
  "type": zod.enum(['stripe']),
  "stripeCustomerId": zod.coerce.string().describe('The Stripe customer ID.'),
  "stripeDefaultPaymentMethodId": zod.coerce.string().optional().describe('The Stripe default payment method ID.')
}).describe('Stripe Customer App Data.'),zod.object({
  "app": zod.object({
  "id": zod.coerce.string().regex(upsertCustomerAppDataBodyTwoAppOneIdRegExp).describe('A unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(upsertCustomerAppDataBodyTwoAppOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(upsertCustomerAppDataBodyTwoAppOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "createdAt": zod.coerce.date().describe('Timestamp of when the resource was created.'),
  "updatedAt": zod.coerce.date().describe('Timestamp of when the resource was last updated.'),
  "deletedAt": zod.coerce.date().optional().describe('Timestamp of when the resource was permanently deleted.'),
  "listing": zod.object({
  "type": zod.enum(['stripe', 'sandbox', 'custom_invoicing']).describe('Type of the app.').describe('The app\'s type'),
  "name": zod.coerce.string().describe('The app\'s name.'),
  "description": zod.coerce.string().describe('The app\'s description.'),
  "capabilities": zod.array(zod.object({
  "type": zod.enum(['reportUsage', 'reportEvents', 'calculateTax', 'invoiceCustomers', 'collectPayments']).describe('App capability type.').describe('The capability type.'),
  "key": zod.coerce.string().min(1).max(upsertCustomerAppDataBodyTwoAppOneListingOneCapabilitiesItemKeyMax).regex(upsertCustomerAppDataBodyTwoAppOneListingOneCapabilitiesItemKeyRegExp).describe('Key'),
  "name": zod.coerce.string().describe('The capability name.'),
  "description": zod.coerce.string().describe('The capability description.')
}).describe('App capability.\n\nCapabilities only exist in config so they don\'t extend the Resource model.')).describe('The app\'s capabilities.'),
  "installMethods": zod.array(zod.enum(['with_oauth2', 'with_api_key', 'no_credentials_required']).describe('Install method of the application.')).describe('Install methods.\n\nList of methods to install the app.')
}).describe('A marketplace listing.\nRepresent an available app in the app marketplace that can be installed to the organization.\n\nMarketplace apps only exist in config so they don\'t extend the Resource model.').describe('The marketplace listing that this installed app is based on.'),
  "status": zod.enum(['ready', 'unauthorized']).describe('App installed status.').describe('Status of the app connection.'),
  "type": zod.enum(['sandbox'])
}).describe('Sandbox app can be used for testing OpenMeter features.\n\nThe app is not creating anything in external systems, thus it is safe to use for\nverifying OpenMeter features.').optional().describe('The installed sandbox app this data belongs to.'),
  "id": zod.coerce.string().regex(upsertCustomerAppDataBodyTwoIdRegExp).optional().describe('The app ID.\nIf not provided, it will use the global default for the app type.'),
  "type": zod.enum(['sandbox'])
}).describe('Sandbox Customer App Data.'),zod.object({
  "app": zod.object({
  "id": zod.coerce.string().regex(upsertCustomerAppDataBodyThreeAppOneIdRegExp).describe('A unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(upsertCustomerAppDataBodyThreeAppOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(upsertCustomerAppDataBodyThreeAppOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "createdAt": zod.coerce.date().describe('Timestamp of when the resource was created.'),
  "updatedAt": zod.coerce.date().describe('Timestamp of when the resource was last updated.'),
  "deletedAt": zod.coerce.date().optional().describe('Timestamp of when the resource was permanently deleted.'),
  "listing": zod.object({
  "type": zod.enum(['stripe', 'sandbox', 'custom_invoicing']).describe('Type of the app.').describe('The app\'s type'),
  "name": zod.coerce.string().describe('The app\'s name.'),
  "description": zod.coerce.string().describe('The app\'s description.'),
  "capabilities": zod.array(zod.object({
  "type": zod.enum(['reportUsage', 'reportEvents', 'calculateTax', 'invoiceCustomers', 'collectPayments']).describe('App capability type.').describe('The capability type.'),
  "key": zod.coerce.string().min(1).max(upsertCustomerAppDataBodyThreeAppOneListingOneCapabilitiesItemKeyMax).regex(upsertCustomerAppDataBodyThreeAppOneListingOneCapabilitiesItemKeyRegExp).describe('Key'),
  "name": zod.coerce.string().describe('The capability name.'),
  "description": zod.coerce.string().describe('The capability description.')
}).describe('App capability.\n\nCapabilities only exist in config so they don\'t extend the Resource model.')).describe('The app\'s capabilities.'),
  "installMethods": zod.array(zod.enum(['with_oauth2', 'with_api_key', 'no_credentials_required']).describe('Install method of the application.')).describe('Install methods.\n\nList of methods to install the app.')
}).describe('A marketplace listing.\nRepresent an available app in the app marketplace that can be installed to the organization.\n\nMarketplace apps only exist in config so they don\'t extend the Resource model.').describe('The marketplace listing that this installed app is based on.'),
  "status": zod.enum(['ready', 'unauthorized']).describe('App installed status.').describe('Status of the app connection.'),
  "type": zod.enum(['custom_invoicing']),
  "enableDraftSyncHook": zod.coerce.boolean().describe('Enable draft.sync hook.\n\nIf the hook is not enabled, the invoice will be progressed to the next state automatically.'),
  "enableIssuingSyncHook": zod.coerce.boolean().describe('Enable issuing.sync hook.\n\nIf the hook is not enabled, the invoice will be progressed to the next state automatically.')
}).describe('Custom Invoicing app can be used for interface with any invoicing or payment system.\n\nThis app provides ways to manipulate invoices and payments, however the integration\nmust rely on Notifications API to get notified about invoice changes.').optional().describe('The installed custom invoicing app this data belongs to.'),
  "id": zod.coerce.string().regex(upsertCustomerAppDataBodyThreeIdRegExp).optional().describe('The app ID.\nIf not provided, it will use the global default for the app type.'),
  "type": zod.enum(['custom_invoicing']),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Metadata to be used by the custom invoicing provider.')
}).describe('Custom Invoicing Customer App Data.')]).describe('CustomerAppData\nStores the app specific data for the customer.\nOne of: stripe, sandbox, custom_invoicing')
export const UpsertCustomerAppDataBody = zod.array(UpsertCustomerAppDataBodyItem)


/**
 * Delete customer app data.
 * @summary Delete customer app data
 */
export const deleteCustomerAppDataPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const deleteCustomerAppDataPathCustomerIdOrKeyTwoMax = 256;

export const deleteCustomerAppDataPathAppIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeleteCustomerAppDataParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(deleteCustomerAppDataPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(deleteCustomerAppDataPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')]),
  "appId": zod.coerce.string().regex(deleteCustomerAppDataPathAppIdRegExp)
})


/**
 * Checks customer access to a given feature (by key). All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
 * @summary Get customer entitlement value
 */
export const getCustomerEntitlementValuePathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const getCustomerEntitlementValuePathCustomerIdOrKeyTwoMax = 256;

export const getCustomerEntitlementValuePathFeatureKeyMax = 64;


export const getCustomerEntitlementValuePathFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');


export const GetCustomerEntitlementValueParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(getCustomerEntitlementValuePathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(getCustomerEntitlementValuePathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')]),
  "featureKey": zod.coerce.string().min(1).max(getCustomerEntitlementValuePathFeatureKeyMax).regex(getCustomerEntitlementValuePathFeatureKeyRegExp)
})

export const GetCustomerEntitlementValueQueryParams = zod.object({
  "time": zod.coerce.date().optional()
})


/**
 * Get stripe app data for a customer.
Only returns data if the customer billing profile is linked to a stripe app.
 * @summary Get customer stripe app data
 */
export const getCustomerStripeAppDataPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const getCustomerStripeAppDataPathCustomerIdOrKeyTwoMax = 256;



export const GetCustomerStripeAppDataParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(getCustomerStripeAppDataPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(getCustomerStripeAppDataPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})


/**
 * Upsert stripe app data for a customer.
Only updates data if the customer billing profile is linked to a stripe app.
 * @summary Upsert customer stripe app data
 */
export const upsertCustomerStripeAppDataPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const upsertCustomerStripeAppDataPathCustomerIdOrKeyTwoMax = 256;



export const UpsertCustomerStripeAppDataParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(upsertCustomerStripeAppDataPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(upsertCustomerStripeAppDataPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})

export const UpsertCustomerStripeAppDataBody = zod.object({
  "stripeCustomerId": zod.coerce.string().describe('The Stripe customer ID.'),
  "stripeDefaultPaymentMethodId": zod.coerce.string().optional().describe('The Stripe default payment method ID.')
}).describe('Stripe Customer App Data Base.')


/**
 * Create Stripe customer portal session.
Only returns URL if the customer billing profile is linked to a stripe app and customer.

Useful to redirect the customer to the Stripe customer portal to manage their payment methods,
change their billing address and access their invoice history.
 * @summary Create Stripe customer portal session
 */
export const createCustomerStripePortalSessionPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createCustomerStripePortalSessionPathCustomerIdOrKeyTwoMax = 256;



export const CreateCustomerStripePortalSessionParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(createCustomerStripePortalSessionPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(createCustomerStripePortalSessionPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})

export const CreateCustomerStripePortalSessionBody = zod.object({
  "configurationId": zod.coerce.string().optional().describe('The ID of an existing configuration to use for this session,\ndescribing its functionality and features.\nIf not specified, the session uses the default configuration.\n\nSee https:\/\/docs.stripe.com\/api\/customer_portal\/sessions\/create#create_portal_session-configuration'),
  "locale": zod.coerce.string().optional().describe('The IETF language tag of the locale customer portal is displayed in.\nIf blank or auto, the customer‚Äôs preferred_locales or browser‚Äôs locale is used.\n\nSee: https:\/\/docs.stripe.com\/api\/customer_portal\/sessions\/create#create_portal_session-locale'),
  "returnUrl": zod.coerce.string().optional().describe('The URL to redirect the customer to after they have completed\ntheir requested actions.\n\nSee: https:\/\/docs.stripe.com\/api\/customer_portal\/sessions\/create#create_portal_session-return_url')
}).describe('Stripe customer portal request params.')


/**
 * Lists all subscriptions for a customer.
 * @summary List customer subscriptions
 */
export const listCustomerSubscriptionsPathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listCustomerSubscriptionsPathCustomerIdOrKeyTwoMax = 256;



export const ListCustomerSubscriptionsParams = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(listCustomerSubscriptionsPathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(listCustomerSubscriptionsPathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})

export const listCustomerSubscriptionsQueryPageDefault = 1;

export const listCustomerSubscriptionsQueryPageSizeDefault = 100;
export const listCustomerSubscriptionsQueryPageSizeMax = 1000;



export const ListCustomerSubscriptionsQueryParams = zod.object({
  "status": zod.array(zod.enum(['active', 'inactive', 'canceled', 'scheduled']).describe('Subscription status.')).optional(),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['activeFrom', 'activeTo']).optional().describe('The order by field.'),
  "page": zod.coerce.number().min(1).default(listCustomerSubscriptionsQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listCustomerSubscriptionsQueryPageSizeMax).default(listCustomerSubscriptionsQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.')
})


/**
 * List all entitlements for all the subjects and features. This endpoint is intended for administrative purposes only.
To fetch the entitlements of a specific subject please use the /api/v1/subjects/{subjectKeyOrID}/entitlements endpoint.
If page is provided that takes precedence and the paginated response is returned.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/entitlements`](#tag/entitlements/get/api/v2/entitlements) instead.
 * @deprecated
 * @summary List all entitlements
 */
export const listEntitlementsQueryExcludeInactiveDefault = false;export const listEntitlementsQueryPageDefault = 1;

export const listEntitlementsQueryPageSizeDefault = 100;
export const listEntitlementsQueryPageSizeMax = 1000;

export const listEntitlementsQueryOffsetDefault = 0;
export const listEntitlementsQueryOffsetMin = 0;

export const listEntitlementsQueryLimitDefault = 100;
export const listEntitlementsQueryLimitMax = 1000;



export const ListEntitlementsQueryParams = zod.object({
  "feature": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple features.\n\nUsage: `?feature=feature-1&feature=feature-2`'),
  "subject": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple subjects.\n\nUsage: `?subject=customer-1&subject=customer-2`'),
  "entitlementType": zod.array(zod.enum(['metered', 'boolean', 'static']).describe('Type of the entitlement.')).optional().describe('Filtering by multiple entitlement types.\n\nUsage: `?entitlementType=metered&entitlementType=boolean`'),
  "excludeInactive": zod.coerce.boolean().default(listEntitlementsQueryExcludeInactiveDefault).describe('Exclude inactive entitlements in the response (those scheduled for later or earlier)'),
  "page": zod.coerce.number().min(1).default(listEntitlementsQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listEntitlementsQueryPageSizeMax).default(listEntitlementsQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "offset": zod.coerce.number().min(listEntitlementsQueryOffsetMin).default(listEntitlementsQueryOffsetDefault).describe('Number of items to skip.\n\nDefault is 0.'),
  "limit": zod.coerce.number().min(1).max(listEntitlementsQueryLimitMax).default(listEntitlementsQueryLimitDefault).describe('Number of items to return.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['createdAt', 'updatedAt']).optional().describe('The order by field.')
})


/**
 * Get entitlement by ID.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/entitlements/{entitlementId}`](#tag/entitlements/get/api/v2/entitlements/{entitlementId}) instead.
 * @deprecated
 * @summary Get entitlement by ID
 */
export const getEntitlementByIdPathEntitlementIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetEntitlementByIdParams = zod.object({
  "entitlementId": zod.coerce.string().regex(getEntitlementByIdPathEntitlementIdRegExp)
})


/**
 * List ingested events within a time range.

If the from query param is not provided it defaults to last 72 hours.
 * @summary List ingested events
 */
export const listEventsQueryClientIdMax = 36;

export const listEventsQueryCustomerIdItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listEventsQueryLimitDefault = 100;
export const listEventsQueryLimitMax = 100;



export const ListEventsQueryParams = zod.object({
  "clientId": zod.coerce.string().min(1).max(listEventsQueryClientIdMax).optional().describe('Client ID\nUseful to track progress of a query.'),
  "ingestedAtFrom": zod.coerce.date().optional().describe('Start date-time in RFC 3339 format.\n\nInclusive.'),
  "ingestedAtTo": zod.coerce.date().optional().describe('End date-time in RFC 3339 format.\n\nInclusive.'),
  "id": zod.coerce.string().optional().describe('The event ID.\n\nAccepts partial ID.'),
  "subject": zod.coerce.string().optional().describe('The event subject.\n\nAccepts partial subject.'),
  "customerId": zod.array(zod.coerce.string().regex(listEventsQueryCustomerIdItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('The event customer ID.'),
  "from": zod.coerce.date().optional().describe('Start date-time in RFC 3339 format.\n\nInclusive.'),
  "to": zod.coerce.date().optional().describe('End date-time in RFC 3339 format.\n\nInclusive.'),
  "limit": zod.coerce.number().min(1).max(listEventsQueryLimitMax).default(listEventsQueryLimitDefault).describe('Number of events to return.')
})


/**
 * Ingests an event or batch of events following the CloudEvents specification.
 * @summary Ingest events
 */


export const ingestEventsBodyOneSpecversionDefault = `1.0`;






export const ingestEventsBodyTwoItemSpecversionDefault = `1.0`;






export const IngestEventsBody = zod.union([zod.object({
  "id": zod.coerce.string().min(1).describe('Identifies the event.'),
  "source": zod.coerce.string().min(1).describe('Identifies the context in which an event happened.'),
  "specversion": zod.coerce.string().min(1).describe('The version of the CloudEvents specification which the event uses.'),
  "type": zod.coerce.string().min(1).describe('Contains a value describing the type of event related to the originating occurrence.'),
  "datacontenttype": zod.enum(['application/json']).nullish().describe('Content type of the CloudEvents data value. Only the value \"application\/json\" is allowed over HTTP.'),
  "dataschema": zod.url().min(1).nullish().describe('Identifies the schema that data adheres to.'),
  "subject": zod.coerce.string().min(1).describe('Describes the subject of the event in the context of the event producer (identified by source).'),
  "time": zod.coerce.date().nullish().describe('Timestamp of when the occurrence happened. Must adhere to RFC 3339.'),
  "data": zod.record(zod.string(), zod.unknown()).nullish().describe('The event payload.\nOptional, if present it must be a JSON object.')
}).describe('CloudEvents Specification JSON Schema\n\nOptional properties are nullable according to the CloudEvents specification:\nOPTIONAL not omitted attributes MAY be represented as a null JSON value.'),zod.array(zod.object({
  "id": zod.coerce.string().min(1).describe('Identifies the event.'),
  "source": zod.coerce.string().min(1).describe('Identifies the context in which an event happened.'),
  "specversion": zod.coerce.string().min(1).describe('The version of the CloudEvents specification which the event uses.'),
  "type": zod.coerce.string().min(1).describe('Contains a value describing the type of event related to the originating occurrence.'),
  "datacontenttype": zod.enum(['application/json']).nullish().describe('Content type of the CloudEvents data value. Only the value \"application\/json\" is allowed over HTTP.'),
  "dataschema": zod.url().min(1).nullish().describe('Identifies the schema that data adheres to.'),
  "subject": zod.coerce.string().min(1).describe('Describes the subject of the event in the context of the event producer (identified by source).'),
  "time": zod.coerce.date().nullish().describe('Timestamp of when the occurrence happened. Must adhere to RFC 3339.'),
  "data": zod.record(zod.string(), zod.unknown()).nullish().describe('The event payload.\nOptional, if present it must be a JSON object.')
}).describe('CloudEvents Specification JSON Schema\n\nOptional properties are nullable according to the CloudEvents specification:\nOPTIONAL not omitted attributes MAY be represented as a null JSON value.'))]).describe('The body of the events request.\nEither a single event or a batch of events.')


/**
 * List features.
 * @summary List features
 */
export const listFeaturesQueryIncludeArchivedDefault = false;export const listFeaturesQueryPageDefault = 1;

export const listFeaturesQueryPageSizeDefault = 100;
export const listFeaturesQueryPageSizeMax = 1000;

export const listFeaturesQueryOffsetDefault = 0;
export const listFeaturesQueryOffsetMin = 0;

export const listFeaturesQueryLimitDefault = 100;
export const listFeaturesQueryLimitMax = 1000;



export const ListFeaturesQueryParams = zod.object({
  "meterSlug": zod.array(zod.coerce.string()).optional().describe('Filter by meterSlug'),
  "includeArchived": zod.coerce.boolean().default(listFeaturesQueryIncludeArchivedDefault).describe('Include archived features in response.'),
  "page": zod.coerce.number().min(1).default(listFeaturesQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listFeaturesQueryPageSizeMax).default(listFeaturesQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "offset": zod.coerce.number().min(listFeaturesQueryOffsetMin).default(listFeaturesQueryOffsetDefault).describe('Number of items to skip.\n\nDefault is 0.'),
  "limit": zod.coerce.number().min(1).max(listFeaturesQueryLimitMax).default(listFeaturesQueryLimitDefault).describe('Number of items to return.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'key', 'name', 'createdAt', 'updatedAt']).optional().describe('The order by field.')
})


/**
 * Features are either metered or static. A feature is metered if meterSlug is provided at creation.
For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter's groupBy fields.
Meters with SUM, COUNT, UNIQUE_COUNT and LATEST aggregations are supported for features.
Features cannot be updated later, only archived.
 * @summary Create feature
 */
export const createFeatureBodyKeyMax = 64;


export const createFeatureBodyKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createFeatureBodyMeterSlugMax = 64;


export const createFeatureBodyMeterSlugRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');


export const CreateFeatureBody = zod.object({
  "key": zod.coerce.string().min(1).max(createFeatureBodyKeyMax).regex(createFeatureBodyKeyRegExp).describe('A key is a unique string that is used to identify a resource.'),
  "name": zod.coerce.string(),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional(),
  "meterSlug": zod.coerce.string().min(1).max(createFeatureBodyMeterSlugMax).regex(createFeatureBodyMeterSlugRegExp).optional().describe('A key is a unique string that is used to identify a resource.'),
  "meterGroupByFilters": zod.record(zod.string(), zod.coerce.string()).optional().describe('Optional meter group by filters.\nUseful if the meter scope is broader than what feature tracks.\nExample scenario would be a meter tracking all token use with groupBy fields for the model,\nthen the feature could filter for model=gpt-4.\n\n‚ö†Ô∏è __Deprecated__: Use advancedMeterGroupByFilters instead'),
  "advancedMeterGroupByFilters": zod.record(zod.string(), zod.object({
  "$eq": zod.coerce.string().nullish().describe('The field must be equal to the provided value.'),
  "$ne": zod.coerce.string().nullish().describe('The field must not be equal to the provided value.'),
  "$in": zod.array(zod.coerce.string()).nullish().describe('The field must be in the provided list of values.'),
  "$nin": zod.array(zod.coerce.string()).nullish().describe('The field must not be in the provided list of values.'),
  "$like": zod.coerce.string().nullish().describe('The field must match the provided value.'),
  "$nlike": zod.coerce.string().nullish().describe('The field must not match the provided value.'),
  "$ilike": zod.coerce.string().nullish().describe('The field must match the provided value, ignoring case.'),
  "$nilike": zod.coerce.string().nullish().describe('The field must not match the provided value, ignoring case.'),
  "$gt": zod.coerce.string().nullish().describe('The field must be greater than the provided value.'),
  "$gte": zod.coerce.string().nullish().describe('The field must be greater than or equal to the provided value.'),
  "$lt": zod.coerce.string().nullish().describe('The field must be less than the provided value.'),
  "$lte": zod.coerce.string().nullish().describe('The field must be less than or equal to the provided value.'),
  "$and": zod.array(zod.unknown()).nullish().describe('Provide a list of filters to be combined with a logical AND.'),
  "$or": zod.array(zod.unknown()).nullish().describe('Provide a list of filters to be combined with a logical OR.')
}).describe('A filter for a string field.')).optional().describe('Optional advanced meter group by filters.\nYou can use this to filter for values of the meter groupBy fields.')
}).describe('Represents a feature that can be enabled or disabled for a plan.\nUsed both for product catalog and entitlements.')


/**
 * Get a feature by ID.
 * @summary Get feature
 */
export const GetFeatureParams = zod.object({
  "featureId": zod.coerce.string()
})


/**
 * Archive a feature by ID.

Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements.
This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis.
 * @summary Delete feature
 */
export const DeleteFeatureParams = zod.object({
  "featureId": zod.coerce.string()
})


/**
 * List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only.
To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.
If page is provided that takes precedence and the paginated response is returned.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/grants`](#tag/entitlements/get/api/v2/grants) instead.
 * @deprecated
 * @summary List grants
 */
export const listGrantsQueryIncludeDeletedDefault = false;export const listGrantsQueryPageDefault = 1;

export const listGrantsQueryPageSizeDefault = 100;
export const listGrantsQueryPageSizeMax = 1000;

export const listGrantsQueryOffsetDefault = 0;
export const listGrantsQueryOffsetMin = 0;

export const listGrantsQueryLimitDefault = 100;
export const listGrantsQueryLimitMax = 1000;



export const ListGrantsQueryParams = zod.object({
  "feature": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple features.\n\nUsage: `?feature=feature-1&feature=feature-2`'),
  "subject": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple subjects.\n\nUsage: `?subject=customer-1&subject=customer-2`'),
  "includeDeleted": zod.coerce.boolean().default(listGrantsQueryIncludeDeletedDefault).describe('Include deleted'),
  "page": zod.coerce.number().min(1).default(listGrantsQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listGrantsQueryPageSizeMax).default(listGrantsQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "offset": zod.coerce.number().min(listGrantsQueryOffsetMin).default(listGrantsQueryOffsetDefault).describe('Number of items to skip.\n\nDefault is 0.'),
  "limit": zod.coerce.number().min(1).max(listGrantsQueryLimitMax).default(listGrantsQueryLimitDefault).describe('Number of items to return.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'createdAt', 'updatedAt']).optional().describe('The order by field.')
})


/**
 * Voiding a grant means it is no longer valid, it doesn't take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.
For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected.
 * @summary Void grant
 */
export const VoidGrantParams = zod.object({
  "grantId": zod.coerce.string()
})


/**
 * Get progress
 * @summary Get progress
 */
export const GetProgressParams = zod.object({
  "id": zod.coerce.string()
})


/**
 * List available apps of the app marketplace.
 * @summary List available apps
 */
export const listMarketplaceListingsQueryPageDefault = 1;

export const listMarketplaceListingsQueryPageSizeDefault = 100;
export const listMarketplaceListingsQueryPageSizeMax = 1000;



export const ListMarketplaceListingsQueryParams = zod.object({
  "page": zod.coerce.number().min(1).default(listMarketplaceListingsQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listMarketplaceListingsQueryPageSizeMax).default(listMarketplaceListingsQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.')
})


/**
 * Get a marketplace listing by type.
 * @summary Get app details by type
 */
export const GetMarketplaceListingParams = zod.object({
  "type": zod.enum(['stripe', 'sandbox', 'custom_invoicing'])
})


/**
 * Install an app from the marketplace.
 * @summary Install app
 */
export const MarketplaceAppInstallParams = zod.object({
  "type": zod.enum(['stripe', 'sandbox', 'custom_invoicing']).describe('The type of the app to install.')
})

export const marketplaceAppInstallBodyCreateBillingProfileDefault = true;

export const MarketplaceAppInstallBody = zod.object({
  "name": zod.coerce.string().optional().describe('Name of the application to install.\n\nIf name is not provided defaults to the marketplace listing\'s name.'),
  "createBillingProfile": zod.coerce.boolean().default(marketplaceAppInstallBodyCreateBillingProfileDefault).describe('If true, a billing profile will be created for the app.\nThe Stripe app will be also set as the default billing profile if the current default is a Sandbox app.')
}).describe('Marketplace install request payload.')


/**
 * Install an marketplace app via API Key.
 * @summary Install app via API key
 */
export const MarketplaceAppAPIKeyInstallParams = zod.object({
  "type": zod.enum(['stripe', 'sandbox', 'custom_invoicing']).describe('The type of the app to install.')
})

export const marketplaceAppAPIKeyInstallBodyCreateBillingProfileDefault = true;

export const MarketplaceAppAPIKeyInstallBody = zod.object({
  "name": zod.coerce.string().optional().describe('Name of the application to install.\n\nIf name is not provided defaults to the marketplace listing\'s name.'),
  "createBillingProfile": zod.coerce.boolean().default(marketplaceAppAPIKeyInstallBodyCreateBillingProfileDefault).describe('If true, a billing profile will be created for the app.\nThe Stripe app will be also set as the default billing profile if the current default is a Sandbox app.'),
  "apiKey": zod.coerce.string().describe('The API key for the provider.\nFor example, the Stripe API key.')
})


/**
 * Install an app via OAuth.
Returns a URL to start the OAuth 2.0 flow.
 * @summary Get OAuth2 install URL
 */
export const MarketplaceOAuth2InstallGetURLParams = zod.object({
  "type": zod.enum(['stripe', 'sandbox', 'custom_invoicing'])
})


/**
 * Authorize OAuth2 code.
Verifies the OAuth code and exchanges it for a token and refresh token
 * @summary Install app via OAuth2
 */
export const MarketplaceOAuth2InstallAuthorizeParams = zod.object({
  "type": zod.enum(['stripe', 'sandbox', 'custom_invoicing']).describe('The type of the app to install.')
})

export const MarketplaceOAuth2InstallAuthorizeQueryParams = zod.object({
  "state": zod.coerce.string().optional().describe('Required if the \"state\" parameter was present in the client authorization request.\nThe exact value received from the client:\n\nUnique, randomly generated, opaque, and non-guessable string that is sent\nwhen starting an authentication request and validated when processing the response.'),
  "code": zod.coerce.string().optional().describe('Authorization code which the client will later exchange for an access token.\nRequired with the success response.'),
  "error": zod.enum(['invalid_request', 'unauthorized_client', 'access_denied', 'unsupported_response_type', 'invalid_scope', 'server_error', 'temporarily_unavailable']).optional().describe('Error code.\nRequired with the error response.'),
  "error_description": zod.coerce.string().optional().describe('Optional human-readable text providing additional information,\nused to assist the client developer in understanding the error that occurred.'),
  "error_uri": zod.coerce.string().optional().describe('Optional uri identifying a human-readable web page with\ninformation about the error, used to provide the client\ndeveloper with additional information about the error')
})


/**
 * List meters.
 * @summary List meters
 */
export const listMetersQueryPageDefault = 1;

export const listMetersQueryPageSizeDefault = 100;
export const listMetersQueryPageSizeMax = 1000;

export const listMetersQueryIncludeDeletedDefault = false;

export const ListMetersQueryParams = zod.object({
  "page": zod.coerce.number().min(1).default(listMetersQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listMetersQueryPageSizeMax).default(listMetersQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['key', 'name', 'aggregation', 'createdAt', 'updatedAt']).optional().describe('The order by field.'),
  "includeDeleted": zod.coerce.boolean().default(listMetersQueryIncludeDeletedDefault).describe('Include deleted meters.')
})


/**
 * Create a meter.
 * @summary Create meter
 */
export const createMeterBodyDescriptionMax = 1024;

export const createMeterBodyNameMax = 256;

export const createMeterBodySlugMax = 64;


export const createMeterBodySlugRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');




export const CreateMeterBody = zod.object({
  "description": zod.coerce.string().max(createMeterBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "name": zod.coerce.string().min(1).max(createMeterBodyNameMax).optional().describe('Human-readable name for the resource. Between 1 and 256 characters.\nDefaults to the slug if not specified.'),
  "slug": zod.coerce.string().min(1).max(createMeterBodySlugMax).regex(createMeterBodySlugRegExp).describe('A unique, human-readable identifier for the meter.\nMust consist only alphanumeric and underscore characters.'),
  "aggregation": zod.enum(['SUM', 'COUNT', 'UNIQUE_COUNT', 'AVG', 'MIN', 'MAX', 'LATEST']).describe('The aggregation type to use for the meter.').describe('The aggregation type to use for the meter.'),
  "eventType": zod.coerce.string().min(1).describe('The event type to aggregate.'),
  "eventFrom": zod.coerce.date().optional().describe('The date since the meter should include events.\nUseful to skip old events.\nIf not specified, all historical events are included.'),
  "valueProperty": zod.coerce.string().min(1).optional().describe('JSONPath expression to extract the value from the ingested event\'s data property.\n\nThe ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.\n\nFor UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.'),
  "groupBy": zod.record(zod.string(), zod.coerce.string()).optional().describe('Named JSONPath expressions to extract the group by values from the event data.\n\nKeys must be unique and consist only alphanumeric and underscore characters.')
}).describe('A meter create model.')


/**
 * Get a meter by ID or slug.
 * @summary Get meter
 */
export const getMeterPathMeterIdOrSlugMax = 64;


export const getMeterPathMeterIdOrSlugRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetMeterParams = zod.object({
  "meterIdOrSlug": zod.coerce.string().min(1).max(getMeterPathMeterIdOrSlugMax).regex(getMeterPathMeterIdOrSlugRegExp)
})


/**
 * Update a meter.
 * @summary Update meter
 */
export const updateMeterPathMeterIdOrSlugMax = 64;


export const updateMeterPathMeterIdOrSlugRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdateMeterParams = zod.object({
  "meterIdOrSlug": zod.coerce.string().min(1).max(updateMeterPathMeterIdOrSlugMax).regex(updateMeterPathMeterIdOrSlugRegExp)
})

export const updateMeterBodyDescriptionMax = 1024;

export const updateMeterBodyNameMax = 256;



export const UpdateMeterBody = zod.object({
  "description": zod.coerce.string().max(updateMeterBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "name": zod.coerce.string().min(1).max(updateMeterBodyNameMax).optional().describe('Human-readable name for the resource. Between 1 and 256 characters.\nDefaults to the slug if not specified.'),
  "groupBy": zod.record(zod.string(), zod.coerce.string()).optional().describe('Named JSONPath expressions to extract the group by values from the event data.\n\nKeys must be unique and consist only alphanumeric and underscore characters.')
}).describe('A meter update model.\n\nOnly the properties that can be updated are included.\nFor example, the slug and aggregation cannot be updated.')


/**
 * Delete a meter.
 * @summary Delete meter
 */
export const deleteMeterPathMeterIdOrSlugMax = 64;


export const deleteMeterPathMeterIdOrSlugRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeleteMeterParams = zod.object({
  "meterIdOrSlug": zod.coerce.string().min(1).max(deleteMeterPathMeterIdOrSlugMax).regex(deleteMeterPathMeterIdOrSlugRegExp)
})


/**
 * List meter group by values.
 * @summary List meter group by values
 */
export const listMeterGroupByValuesPathMeterIdOrSlugMax = 64;


export const listMeterGroupByValuesPathMeterIdOrSlugRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ListMeterGroupByValuesParams = zod.object({
  "meterIdOrSlug": zod.coerce.string().min(1).max(listMeterGroupByValuesPathMeterIdOrSlugMax).regex(listMeterGroupByValuesPathMeterIdOrSlugRegExp),
  "groupByKey": zod.coerce.string()
})

export const ListMeterGroupByValuesQueryParams = zod.object({
  "from": zod.coerce.date().optional().describe('Start date-time in RFC 3339 format.\n\nInclusive. Defaults to 24 hours ago.\n\nFor example: ?from=2025-01-01T00%3A00%3A00.000Z'),
  "to": zod.coerce.date().optional().describe('End date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?to=2025-02-01T00%3A00%3A00.000Z')
})


/**
 * Query meter for usage.
 * @summary Query meter
 */
export const queryMeterPathMeterIdOrSlugMax = 64;


export const queryMeterPathMeterIdOrSlugRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const QueryMeterParams = zod.object({
  "meterIdOrSlug": zod.coerce.string().min(1).max(queryMeterPathMeterIdOrSlugMax).regex(queryMeterPathMeterIdOrSlugRegExp)
})

export const queryMeterQueryClientIdMax = 36;

export const queryMeterQueryWindowTimeZoneDefault = `UTC`;export const queryMeterQueryFilterCustomerIdMax = 100;



export const QueryMeterQueryParams = zod.object({
  "clientId": zod.coerce.string().min(1).max(queryMeterQueryClientIdMax).optional().describe('Client ID\nUseful to track progress of a query.'),
  "from": zod.coerce.date().optional().describe('Start date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?from=2025-01-01T00%3A00%3A00.000Z'),
  "to": zod.coerce.date().optional().describe('End date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?to=2025-02-01T00%3A00%3A00.000Z'),
  "windowSize": zod.enum(['MINUTE', 'HOUR', 'DAY', 'MONTH']).optional().describe('If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.\n\nFor example: ?windowSize=DAY'),
  "windowTimeZone": zod.coerce.string().default(queryMeterQueryWindowTimeZoneDefault).describe('The value is the name of the time zone as defined in the IANA Time Zone Database (http:\/\/www.iana.org\/time-zones).\nIf not specified, the UTC timezone will be used.\n\nFor example: ?windowTimeZone=UTC'),
  "subject": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple subjects.\n\nFor example: ?subject=subject-1&subject=subject-2'),
  "filterCustomerId": zod.array(zod.coerce.string()).max(queryMeterQueryFilterCustomerIdMax).optional().describe('Filtering by multiple customers.\n\nFor example: ?filterCustomerId=customer-1&filterCustomerId=customer-2'),
  "filterGroupBy": zod.record(zod.string(), zod.coerce.string()).optional().describe('Simple filter for group bys with exact match.\n\nFor example: ?filterGroupBy[vendor]=openai&filterGroupBy[model]=gpt-4-turbo\n\n‚ö†Ô∏è __Deprecated__: Use `advancedMeterGroupByFilters` instead'),
  "groupBy": zod.array(zod.coerce.string()).optional().describe('If not specified a single aggregate will be returned for each subject and time window.\n`subject` is a reserved group by value.\n\nFor example: ?groupBy=subject&groupBy=model')
})


/**
 * @summary Query meter
 */
export const queryMeterPostPathMeterIdOrSlugMax = 64;


export const queryMeterPostPathMeterIdOrSlugRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const QueryMeterPostParams = zod.object({
  "meterIdOrSlug": zod.coerce.string().min(1).max(queryMeterPostPathMeterIdOrSlugMax).regex(queryMeterPostPathMeterIdOrSlugRegExp)
})

export const queryMeterPostBodyClientIdMax = 36;

export const queryMeterPostBodyWindowTimeZoneDefault = `UTC`;export const queryMeterPostBodySubjectMax = 100;

export const queryMeterPostBodyFilterCustomerIdMax = 100;

export const queryMeterPostBodyGroupByMax = 100;



export const QueryMeterPostBody = zod.object({
  "clientId": zod.coerce.string().min(1).max(queryMeterPostBodyClientIdMax).optional().describe('Client ID\nUseful to track progress of a query.'),
  "from": zod.coerce.date().optional().describe('Start date-time in RFC 3339 format.\n\nInclusive.'),
  "to": zod.coerce.date().optional().describe('End date-time in RFC 3339 format.\n\nInclusive.'),
  "windowSize": zod.enum(['MINUTE', 'HOUR', 'DAY', 'MONTH']).describe('Aggregation window size.').optional().describe('If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.'),
  "windowTimeZone": zod.coerce.string().default(queryMeterPostBodyWindowTimeZoneDefault).describe('The value is the name of the time zone as defined in the IANA Time Zone Database (http:\/\/www.iana.org\/time-zones).\nIf not specified, the UTC timezone will be used.'),
  "subject": zod.array(zod.coerce.string()).max(queryMeterPostBodySubjectMax).optional().describe('Filtering by multiple subjects.'),
  "filterCustomerId": zod.array(zod.coerce.string()).max(queryMeterPostBodyFilterCustomerIdMax).optional().describe('Filtering by multiple customers.'),
  "filterGroupBy": zod.record(zod.string(), zod.array(zod.coerce.string())).optional().describe('Simple filter for group bys with exact match.'),
  "advancedMeterGroupByFilters": zod.record(zod.string(), zod.object({
  "$eq": zod.coerce.string().nullish().describe('The field must be equal to the provided value.'),
  "$ne": zod.coerce.string().nullish().describe('The field must not be equal to the provided value.'),
  "$in": zod.array(zod.coerce.string()).nullish().describe('The field must be in the provided list of values.'),
  "$nin": zod.array(zod.coerce.string()).nullish().describe('The field must not be in the provided list of values.'),
  "$like": zod.coerce.string().nullish().describe('The field must match the provided value.'),
  "$nlike": zod.coerce.string().nullish().describe('The field must not match the provided value.'),
  "$ilike": zod.coerce.string().nullish().describe('The field must match the provided value, ignoring case.'),
  "$nilike": zod.coerce.string().nullish().describe('The field must not match the provided value, ignoring case.'),
  "$gt": zod.coerce.string().nullish().describe('The field must be greater than the provided value.'),
  "$gte": zod.coerce.string().nullish().describe('The field must be greater than or equal to the provided value.'),
  "$lt": zod.coerce.string().nullish().describe('The field must be less than the provided value.'),
  "$lte": zod.coerce.string().nullish().describe('The field must be less than or equal to the provided value.'),
  "$and": zod.array(zod.unknown()).nullish().describe('Provide a list of filters to be combined with a logical AND.'),
  "$or": zod.array(zod.unknown()).nullish().describe('Provide a list of filters to be combined with a logical OR.')
}).describe('A filter for a string field.')).optional().describe('Optional advanced meter group by filters.\nYou can use this to filter for values of the meter groupBy fields.'),
  "groupBy": zod.array(zod.coerce.string()).max(queryMeterPostBodyGroupByMax).optional().describe('If not specified a single aggregate will be returned for each subject and time window.\n`subject` is a reserved group by value.')
}).describe('A meter query request.')


/**
 * List subjects for a meter.
 * @summary List meter subjects
 */
export const listMeterSubjectsPathMeterIdOrSlugMax = 64;


export const listMeterSubjectsPathMeterIdOrSlugRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ListMeterSubjectsParams = zod.object({
  "meterIdOrSlug": zod.coerce.string().min(1).max(listMeterSubjectsPathMeterIdOrSlugMax).regex(listMeterSubjectsPathMeterIdOrSlugRegExp)
})

export const ListMeterSubjectsQueryParams = zod.object({
  "from": zod.coerce.date().optional().describe('Start date-time in RFC 3339 format.\n\nInclusive. Defaults to the beginning of time.\n\nFor example: ?from=2025-01-01T00%3A00%3A00.000Z'),
  "to": zod.coerce.date().optional().describe('End date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?to=2025-02-01T00%3A00%3A00.000Z')
})


/**
 * List all notification channels.
 * @summary List notification channels
 */
export const listNotificationChannelsQueryIncludeDeletedDefault = false;export const listNotificationChannelsQueryIncludeDisabledDefault = false;export const listNotificationChannelsQueryPageDefault = 1;

export const listNotificationChannelsQueryPageSizeDefault = 100;
export const listNotificationChannelsQueryPageSizeMax = 1000;



export const ListNotificationChannelsQueryParams = zod.object({
  "includeDeleted": zod.coerce.boolean().default(listNotificationChannelsQueryIncludeDeletedDefault).describe('Include deleted notification channels in response.\n\nUsage: `?includeDeleted=true`'),
  "includeDisabled": zod.coerce.boolean().default(listNotificationChannelsQueryIncludeDisabledDefault).describe('Include disabled notification channels in response.\n\nUsage: `?includeDisabled=false`'),
  "page": zod.coerce.number().min(1).default(listNotificationChannelsQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listNotificationChannelsQueryPageSizeMax).default(listNotificationChannelsQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'type', 'createdAt', 'updatedAt']).optional().describe('The order by field.')
})


/**
 * Create a new notification channel.
 * @summary Create a notification channel
 */
export const createNotificationChannelBodyOneNameMax = 256;

export const createNotificationChannelBodyOneDisabledDefault = false;export const createNotificationChannelBodyOneSigningSecretRegExp = new RegExp('^(whsec_)?[a-zA-Z0-9+\/=]{32,100}$');


export const CreateNotificationChannelBody = zod.object({
  "type": zod.enum(['WEBHOOK']).describe('Notification channel type.'),
  "name": zod.coerce.string().min(1).max(createNotificationChannelBodyOneNameMax).describe('User friendly name of the channel.'),
  "disabled": zod.coerce.boolean().default(createNotificationChannelBodyOneDisabledDefault).describe('Whether the channel is disabled or not.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "url": zod.coerce.string().describe('Webhook URL where the notification is sent.'),
  "customHeaders": zod.record(zod.string(), zod.coerce.string()).optional().describe('Custom HTTP headers sent as part of the webhook request.'),
  "signingSecret": zod.coerce.string().regex(createNotificationChannelBodyOneSigningSecretRegExp).optional().describe('Signing secret used for webhook request validation on the receiving end.\n\nFormat: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24')
}).describe('Request with input parameters for creating new notification channel with webhook type.').describe('Union type for requests creating new notification channel with certain type.')


/**
 * Update notification channel.
 * @summary Update a notification channel
 */
export const updateNotificationChannelPathChannelIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdateNotificationChannelParams = zod.object({
  "channelId": zod.coerce.string().regex(updateNotificationChannelPathChannelIdRegExp)
})

export const updateNotificationChannelBodyOneNameMax = 256;

export const updateNotificationChannelBodyOneDisabledDefault = false;export const updateNotificationChannelBodyOneSigningSecretRegExp = new RegExp('^(whsec_)?[a-zA-Z0-9+\/=]{32,100}$');


export const UpdateNotificationChannelBody = zod.object({
  "type": zod.enum(['WEBHOOK']).describe('Notification channel type.'),
  "name": zod.coerce.string().min(1).max(updateNotificationChannelBodyOneNameMax).describe('User friendly name of the channel.'),
  "disabled": zod.coerce.boolean().default(updateNotificationChannelBodyOneDisabledDefault).describe('Whether the channel is disabled or not.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "url": zod.coerce.string().describe('Webhook URL where the notification is sent.'),
  "customHeaders": zod.record(zod.string(), zod.coerce.string()).optional().describe('Custom HTTP headers sent as part of the webhook request.'),
  "signingSecret": zod.coerce.string().regex(updateNotificationChannelBodyOneSigningSecretRegExp).optional().describe('Signing secret used for webhook request validation on the receiving end.\n\nFormat: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24')
}).describe('Request with input parameters for creating new notification channel with webhook type.').describe('Union type for requests creating new notification channel with certain type.')


/**
 * Get a notification channel by id.
 * @summary Get notification channel
 */
export const getNotificationChannelPathChannelIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetNotificationChannelParams = zod.object({
  "channelId": zod.coerce.string().regex(getNotificationChannelPathChannelIdRegExp)
})


/**
 * Soft delete notification channel by id.

Once a notification channel is deleted it cannot be undeleted.
 * @summary Delete a notification channel
 */
export const deleteNotificationChannelPathChannelIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeleteNotificationChannelParams = zod.object({
  "channelId": zod.coerce.string().regex(deleteNotificationChannelPathChannelIdRegExp)
})


/**
 * List all notification events.
 * @summary List notification events
 */
export const listNotificationEventsQueryRuleItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listNotificationEventsQueryChannelItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listNotificationEventsQueryPageDefault = 1;

export const listNotificationEventsQueryPageSizeDefault = 100;
export const listNotificationEventsQueryPageSizeMax = 1000;



export const ListNotificationEventsQueryParams = zod.object({
  "from": zod.coerce.date().optional().describe('Start date-time in RFC 3339 format.\nInclusive.'),
  "to": zod.coerce.date().optional().describe('End date-time in RFC 3339 format.\nInclusive.'),
  "feature": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple feature ids or keys.\n\nUsage: `?feature=feature-1&feature=feature-2`'),
  "subject": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple subject ids or keys.\n\nUsage: `?subject=subject-1&subject=subject-2`'),
  "rule": zod.array(zod.coerce.string().regex(listNotificationEventsQueryRuleItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('Filtering by multiple rule ids.\n\nUsage: `?rule=01J8J2XYZ2N5WBYK09EDZFBSZM&rule=01J8J4R4VZH180KRKQ63NB2VA5`'),
  "channel": zod.array(zod.coerce.string().regex(listNotificationEventsQueryChannelItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('Filtering by multiple channel ids.\n\nUsage: `?channel=01J8J4RXH778XB056JS088PCYT&channel=01J8J4S1R1G9EVN62RG23A9M6J`'),
  "page": zod.coerce.number().min(1).default(listNotificationEventsQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listNotificationEventsQueryPageSizeMax).default(listNotificationEventsQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'createdAt']).optional().describe('The order by field.')
})


/**
 * Get a notification event by id.
 * @summary Get notification event
 */
export const GetNotificationEventParams = zod.object({
  "eventId": zod.coerce.string()
})


/**
 * @summary Re-send notification event
 */
export const resendNotificationEventPathEventIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ResendNotificationEventParams = zod.object({
  "eventId": zod.coerce.string().regex(resendNotificationEventPathEventIdRegExp)
})

export const resendNotificationEventBodyChannelsItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ResendNotificationEventBody = zod.object({
  "channels": zod.array(zod.coerce.string().regex(resendNotificationEventBodyChannelsItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('Notification channels to which the event should be re-sent.')
}).describe('A notification event that will be re-sent.')


/**
 * List all notification rules.
 * @summary List notification rules
 */
export const listNotificationRulesQueryIncludeDeletedDefault = false;export const listNotificationRulesQueryIncludeDisabledDefault = false;export const listNotificationRulesQueryFeatureItemMax = 64;


export const listNotificationRulesQueryFeatureItemRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listNotificationRulesQueryPageDefault = 1;

export const listNotificationRulesQueryPageSizeDefault = 100;
export const listNotificationRulesQueryPageSizeMax = 1000;



export const ListNotificationRulesQueryParams = zod.object({
  "includeDeleted": zod.coerce.boolean().default(listNotificationRulesQueryIncludeDeletedDefault).describe('Include deleted notification rules in response.\n\nUsage: `?includeDeleted=true`'),
  "includeDisabled": zod.coerce.boolean().default(listNotificationRulesQueryIncludeDisabledDefault).describe('Include disabled notification rules in response.\n\nUsage: `?includeDisabled=false`'),
  "feature": zod.array(zod.coerce.string().min(1).max(listNotificationRulesQueryFeatureItemMax).regex(listNotificationRulesQueryFeatureItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).\nA key is a unique string that is used to identify a resource.\n\nTODO: this is a temporary solution to support both ULID and Key in the same spec for codegen.')).optional().describe('Filtering by multiple feature ids\/keys.\n\nUsage: `?feature=feature-1&feature=feature-2`'),
  "channel": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple notifiaction channel ids.\n\nUsage: `?channel=01ARZ3NDEKTSV4RRFFQ69G5FAV&channel=01J8J2Y5X4NNGQS32CF81W95E3`'),
  "page": zod.coerce.number().min(1).default(listNotificationRulesQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listNotificationRulesQueryPageSizeMax).default(listNotificationRulesQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'type', 'createdAt', 'updatedAt']).optional().describe('The order by field.')
})


/**
 * Create a new notification rule.
 * @summary Create a notification rule
 */
export const createNotificationRuleBodyOneNameMax = 256;

export const createNotificationRuleBodyOneDisabledDefault = false;export const createNotificationRuleBodyOneThresholdsMax = 10;

export const createNotificationRuleBodyOneChannelsItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');

export const createNotificationRuleBodyOneFeaturesItemMax = 64;


export const createNotificationRuleBodyOneFeaturesItemRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');

export const createNotificationRuleBodyTwoNameMax = 256;

export const createNotificationRuleBodyTwoDisabledDefault = false;export const createNotificationRuleBodyTwoChannelsItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');

export const createNotificationRuleBodyTwoFeaturesItemMax = 64;


export const createNotificationRuleBodyTwoFeaturesItemRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');

export const createNotificationRuleBodyThreeNameMax = 256;

export const createNotificationRuleBodyThreeDisabledDefault = false;export const createNotificationRuleBodyThreeChannelsItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');

export const createNotificationRuleBodyFourNameMax = 256;

export const createNotificationRuleBodyFourDisabledDefault = false;export const createNotificationRuleBodyFourChannelsItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');



export const CreateNotificationRuleBody = zod.union([zod.object({
  "type": zod.enum(['entitlements.balance.threshold']),
  "name": zod.coerce.string().min(1).max(createNotificationRuleBodyOneNameMax).describe('The user friendly name of the notification rule.'),
  "disabled": zod.coerce.boolean().default(createNotificationRuleBodyOneDisabledDefault).describe('Whether the rule is disabled or not.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "thresholds": zod.array(zod.object({
  "value": zod.coerce.number().describe('Value of the threshold.'),
  "type": zod.enum(['PERCENT', 'NUMBER', 'balance_value', 'usage_percentage', 'usage_value']).describe('Type of the rule in the balance threshold specification:\n\* `balance_value`: threshold defined by the remaining balance value based on usage and the total of grants in the current usage period\n\* `usage_percentage`: threshold defined by the usage percentage compared to the total of grants in the current usage period\n\* `usage_value`: threshold defined by the usage value in the current usage period\n\* `NUMBER` (\*\*deprecated\*\*): see `usage_value`\n\* `PERCENT` (\*\*deprecated\*\*): see `usage_percentage`').describe('Type of the threshold.')
}).describe('Threshold value with multiple supported types.')).min(1).max(createNotificationRuleBodyOneThresholdsMax).describe('List of thresholds the rule suppose to be triggered.'),
  "channels": zod.array(zod.coerce.string().regex(createNotificationRuleBodyOneChannelsItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).min(1).describe('List of notification channels the rule is applied to.'),
  "features": zod.array(zod.coerce.string().min(1).max(createNotificationRuleBodyOneFeaturesItemMax).regex(createNotificationRuleBodyOneFeaturesItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).\nA key is a unique string that is used to identify a resource.\n\nTODO: this is a temporary solution to support both ULID and Key in the same spec for codegen.')).min(1).optional().describe('Optional field for defining the scope of notification by feature. It may contain features by id or key.')
}).describe('Request with input parameters for creating new notification rule with entitlements.balance.threshold type.'),zod.object({
  "type": zod.enum(['entitlements.reset']),
  "name": zod.coerce.string().min(1).max(createNotificationRuleBodyTwoNameMax).describe('The user friendly name of the notification rule.'),
  "disabled": zod.coerce.boolean().default(createNotificationRuleBodyTwoDisabledDefault).describe('Whether the rule is disabled or not.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "channels": zod.array(zod.coerce.string().regex(createNotificationRuleBodyTwoChannelsItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).min(1).describe('List of notification channels the rule is applied to.'),
  "features": zod.array(zod.coerce.string().min(1).max(createNotificationRuleBodyTwoFeaturesItemMax).regex(createNotificationRuleBodyTwoFeaturesItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).\nA key is a unique string that is used to identify a resource.\n\nTODO: this is a temporary solution to support both ULID and Key in the same spec for codegen.')).min(1).optional().describe('Optional field for defining the scope of notification by feature. It may contain features by id or key.')
}).describe('Request with input parameters for creating new notification rule with entitlements.reset type.'),zod.object({
  "type": zod.enum(['invoice.created']),
  "name": zod.coerce.string().min(1).max(createNotificationRuleBodyThreeNameMax).describe('The user friendly name of the notification rule.'),
  "disabled": zod.coerce.boolean().default(createNotificationRuleBodyThreeDisabledDefault).describe('Whether the rule is disabled or not.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "channels": zod.array(zod.coerce.string().regex(createNotificationRuleBodyThreeChannelsItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).min(1).describe('List of notification channels the rule is applied to.')
}).describe('Request with input parameters for creating new notification rule with invoice.created type.'),zod.object({
  "type": zod.enum(['invoice.updated']),
  "name": zod.coerce.string().min(1).max(createNotificationRuleBodyFourNameMax).describe('The user friendly name of the notification rule.'),
  "disabled": zod.coerce.boolean().default(createNotificationRuleBodyFourDisabledDefault).describe('Whether the rule is disabled or not.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "channels": zod.array(zod.coerce.string().regex(createNotificationRuleBodyFourChannelsItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).min(1).describe('List of notification channels the rule is applied to.')
}).describe('Request with input parameters for creating new notification rule with invoice.updated  type.')]).describe('Union type for requests creating new notification rule with certain type.')


/**
 * Update notification rule.
 * @summary Update a notification rule
 */
export const updateNotificationRulePathRuleIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdateNotificationRuleParams = zod.object({
  "ruleId": zod.coerce.string().regex(updateNotificationRulePathRuleIdRegExp)
})

export const updateNotificationRuleBodyOneNameMax = 256;

export const updateNotificationRuleBodyOneDisabledDefault = false;export const updateNotificationRuleBodyOneThresholdsMax = 10;

export const updateNotificationRuleBodyOneChannelsItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');

export const updateNotificationRuleBodyOneFeaturesItemMax = 64;


export const updateNotificationRuleBodyOneFeaturesItemRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');

export const updateNotificationRuleBodyTwoNameMax = 256;

export const updateNotificationRuleBodyTwoDisabledDefault = false;export const updateNotificationRuleBodyTwoChannelsItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');

export const updateNotificationRuleBodyTwoFeaturesItemMax = 64;


export const updateNotificationRuleBodyTwoFeaturesItemRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');

export const updateNotificationRuleBodyThreeNameMax = 256;

export const updateNotificationRuleBodyThreeDisabledDefault = false;export const updateNotificationRuleBodyThreeChannelsItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');

export const updateNotificationRuleBodyFourNameMax = 256;

export const updateNotificationRuleBodyFourDisabledDefault = false;export const updateNotificationRuleBodyFourChannelsItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');



export const UpdateNotificationRuleBody = zod.union([zod.object({
  "type": zod.enum(['entitlements.balance.threshold']),
  "name": zod.coerce.string().min(1).max(updateNotificationRuleBodyOneNameMax).describe('The user friendly name of the notification rule.'),
  "disabled": zod.coerce.boolean().default(updateNotificationRuleBodyOneDisabledDefault).describe('Whether the rule is disabled or not.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "thresholds": zod.array(zod.object({
  "value": zod.coerce.number().describe('Value of the threshold.'),
  "type": zod.enum(['PERCENT', 'NUMBER', 'balance_value', 'usage_percentage', 'usage_value']).describe('Type of the rule in the balance threshold specification:\n\* `balance_value`: threshold defined by the remaining balance value based on usage and the total of grants in the current usage period\n\* `usage_percentage`: threshold defined by the usage percentage compared to the total of grants in the current usage period\n\* `usage_value`: threshold defined by the usage value in the current usage period\n\* `NUMBER` (\*\*deprecated\*\*): see `usage_value`\n\* `PERCENT` (\*\*deprecated\*\*): see `usage_percentage`').describe('Type of the threshold.')
}).describe('Threshold value with multiple supported types.')).min(1).max(updateNotificationRuleBodyOneThresholdsMax).describe('List of thresholds the rule suppose to be triggered.'),
  "channels": zod.array(zod.coerce.string().regex(updateNotificationRuleBodyOneChannelsItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).min(1).describe('List of notification channels the rule is applied to.'),
  "features": zod.array(zod.coerce.string().min(1).max(updateNotificationRuleBodyOneFeaturesItemMax).regex(updateNotificationRuleBodyOneFeaturesItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).\nA key is a unique string that is used to identify a resource.\n\nTODO: this is a temporary solution to support both ULID and Key in the same spec for codegen.')).min(1).optional().describe('Optional field for defining the scope of notification by feature. It may contain features by id or key.')
}).describe('Request with input parameters for creating new notification rule with entitlements.balance.threshold type.'),zod.object({
  "type": zod.enum(['entitlements.reset']),
  "name": zod.coerce.string().min(1).max(updateNotificationRuleBodyTwoNameMax).describe('The user friendly name of the notification rule.'),
  "disabled": zod.coerce.boolean().default(updateNotificationRuleBodyTwoDisabledDefault).describe('Whether the rule is disabled or not.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "channels": zod.array(zod.coerce.string().regex(updateNotificationRuleBodyTwoChannelsItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).min(1).describe('List of notification channels the rule is applied to.'),
  "features": zod.array(zod.coerce.string().min(1).max(updateNotificationRuleBodyTwoFeaturesItemMax).regex(updateNotificationRuleBodyTwoFeaturesItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).\nA key is a unique string that is used to identify a resource.\n\nTODO: this is a temporary solution to support both ULID and Key in the same spec for codegen.')).min(1).optional().describe('Optional field for defining the scope of notification by feature. It may contain features by id or key.')
}).describe('Request with input parameters for creating new notification rule with entitlements.reset type.'),zod.object({
  "type": zod.enum(['invoice.created']),
  "name": zod.coerce.string().min(1).max(updateNotificationRuleBodyThreeNameMax).describe('The user friendly name of the notification rule.'),
  "disabled": zod.coerce.boolean().default(updateNotificationRuleBodyThreeDisabledDefault).describe('Whether the rule is disabled or not.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "channels": zod.array(zod.coerce.string().regex(updateNotificationRuleBodyThreeChannelsItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).min(1).describe('List of notification channels the rule is applied to.')
}).describe('Request with input parameters for creating new notification rule with invoice.created type.'),zod.object({
  "type": zod.enum(['invoice.updated']),
  "name": zod.coerce.string().min(1).max(updateNotificationRuleBodyFourNameMax).describe('The user friendly name of the notification rule.'),
  "disabled": zod.coerce.boolean().default(updateNotificationRuleBodyFourDisabledDefault).describe('Whether the rule is disabled or not.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "channels": zod.array(zod.coerce.string().regex(updateNotificationRuleBodyFourChannelsItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).min(1).describe('List of notification channels the rule is applied to.')
}).describe('Request with input parameters for creating new notification rule with invoice.updated  type.')]).describe('Union type for requests creating new notification rule with certain type.')


/**
 * Get a notification rule by id.
 * @summary Get notification rule
 */
export const getNotificationRulePathRuleIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetNotificationRuleParams = zod.object({
  "ruleId": zod.coerce.string().regex(getNotificationRulePathRuleIdRegExp)
})


/**
 * Soft delete notification rule by id.

Once a notification rule is deleted it cannot be undeleted.
 * @summary Delete a notification rule
 */
export const deleteNotificationRulePathRuleIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeleteNotificationRuleParams = zod.object({
  "ruleId": zod.coerce.string().regex(deleteNotificationRulePathRuleIdRegExp)
})


/**
 * Test a notification rule by sending a test event with random data.
 * @summary Test notification rule
 */
export const testNotificationRulePathRuleIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const TestNotificationRuleParams = zod.object({
  "ruleId": zod.coerce.string().regex(testNotificationRulePathRuleIdRegExp)
})


/**
 * List all plans.
 * @summary List plans
 */
export const listPlansQueryIncludeDeletedDefault = false;export const listPlansQueryIdItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listPlansQueryKeyItemMax = 64;


export const listPlansQueryKeyItemRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const listPlansQueryCurrencyItemMin = 3;
export const listPlansQueryCurrencyItemMax = 3;


export const listPlansQueryCurrencyItemRegExp = new RegExp('^[A-Z]{3}$');
export const listPlansQueryPageDefault = 1;

export const listPlansQueryPageSizeDefault = 100;
export const listPlansQueryPageSizeMax = 1000;



export const ListPlansQueryParams = zod.object({
  "includeDeleted": zod.coerce.boolean().default(listPlansQueryIncludeDeletedDefault).describe('Include deleted plans in response.\n\nUsage: `?includeDeleted=true`'),
  "id": zod.array(zod.coerce.string().regex(listPlansQueryIdItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('Filter by plan.id attribute'),
  "key": zod.array(zod.coerce.string().min(1).max(listPlansQueryKeyItemMax).regex(listPlansQueryKeyItemRegExp).describe('A key is a unique string that is used to identify a resource.')).optional().describe('Filter by plan.key attribute'),
  "keyVersion": zod.record(zod.string(), zod.array(zod.coerce.number())).optional().describe('Filter by plan.key and plan.version attributes'),
  "status": zod.array(zod.enum(['draft', 'active', 'archived', 'scheduled']).describe('The status of a plan.')).optional().describe('Only return plans with the given status.\n\nUsage:\n- `?status=active`: return only the currently active plan\n- `?status=draft`: return only the draft plan\n- `?status=archived`: return only the archived plans'),
  "currency": zod.array(zod.coerce.string().min(listPlansQueryCurrencyItemMin).max(listPlansQueryCurrencyItemMax).regex(listPlansQueryCurrencyItemRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.')).optional().describe('Filter by plan.currency attribute'),
  "page": zod.coerce.number().min(1).default(listPlansQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listPlansQueryPageSizeMax).default(listPlansQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'key', 'version', 'created_at', 'updated_at']).optional().describe('The order by field.')
})


/**
 * Create a new plan.
 * @summary Create a plan
 */
export const createPlanBodyNameMax = 256;

export const createPlanBodyDescriptionMax = 1024;

export const createPlanBodyKeyMax = 64;


export const createPlanBodyKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createPlanBodyCurrencyOneMin = 3;
export const createPlanBodyCurrencyOneMax = 3;


export const createPlanBodyCurrencyOneRegExp = new RegExp('^[A-Z]{3}$');
export const createPlanBodyCurrencyDefault = `USD`;export const createPlanBodyProRatingConfigOneEnabledDefault = true;export const createPlanBodyProRatingConfigOneModeDefault = `prorate_prices`;export const createPlanBodyProRatingConfigDefault = { enabled: true, mode: "prorate_prices" };export const createPlanBodyPhasesItemKeyMax = 64;


export const createPlanBodyPhasesItemKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createPlanBodyPhasesItemNameMax = 256;

export const createPlanBodyPhasesItemDescriptionMax = 1024;

export const createPlanBodyPhasesItemRateCardsItemOneKeyMax = 64;


export const createPlanBodyPhasesItemRateCardsItemOneKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createPlanBodyPhasesItemRateCardsItemOneNameMax = 256;

export const createPlanBodyPhasesItemRateCardsItemOneDescriptionMax = 1024;

export const createPlanBodyPhasesItemRateCardsItemOneFeatureKeyMax = 64;


export const createPlanBodyPhasesItemRateCardsItemOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault = false;export const createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const createPlanBodyPhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const createPlanBodyPhasesItemRateCardsItemOnePriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemOnePriceOnePaymentTermDefault = `in_advance`;export const createPlanBodyPhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoKeyMax = 64;


export const createPlanBodyPhasesItemRateCardsItemTwoKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createPlanBodyPhasesItemRateCardsItemTwoNameMax = 256;

export const createPlanBodyPhasesItemRateCardsItemTwoDescriptionMax = 1024;

export const createPlanBodyPhasesItemRateCardsItemTwoFeatureKeyMax = 64;


export const createPlanBodyPhasesItemRateCardsItemTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault = false;export const createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const createPlanBodyPhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault = `in_advance`;export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault = `1`;export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createPlanBodyPhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');



export const CreatePlanBody = zod.object({
  "name": zod.coerce.string().min(1).max(createPlanBodyNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createPlanBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "key": zod.coerce.string().min(1).max(createPlanBodyKeyMax).regex(createPlanBodyKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "alignment": zod.object({
  "billablesMustAlign": zod.coerce.boolean().optional().describe('Whether all Billable items and RateCards must align.\nAlignment means the Price\'s BillingCadence must align for both duration and anchor time.')
}).describe('Alignment configuration for a plan or subscription.').optional().describe('Alignment configuration for the plan.'),
  "currency": zod.coerce.string().min(createPlanBodyCurrencyOneMin).max(createPlanBodyCurrencyOneMax).regex(createPlanBodyCurrencyOneRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.').describe('The currency code of the plan.'),
  "billingCadence": zod.coerce.string().describe('The default billing cadence for subscriptions using this plan.\nDefines how often customers are billed using ISO8601 duration format.\nExamples: \"P1M\" (monthly), \"P3M\" (quarterly), \"P1Y\" (annually).'),
  "proRatingConfig": zod.object({
  "enabled": zod.coerce.boolean().describe('Whether pro-rating is enabled for this plan.'),
  "mode": zod.enum(['prorate_prices']).describe('Pro-rating mode options for handling billing period changes.').describe('How to handle pro-rating for billing period changes.')
}).describe('Configuration for pro-rating behavior.').default(createPlanBodyProRatingConfigDefault).describe('Default pro-rating configuration for subscriptions using this plan.'),
  "phases": zod.array(zod.object({
  "key": zod.coerce.string().min(1).max(createPlanBodyPhasesItemKeyMax).regex(createPlanBodyPhasesItemKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(createPlanBodyPhasesItemNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createPlanBodyPhasesItemDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "duration": zod.coerce.string().nullable().describe('The duration of the phase.'),
  "rateCards": zod.array(zod.union([zod.object({
  "type": zod.enum(['flat_fee']),
  "key": zod.coerce.string().min(1).max(createPlanBodyPhasesItemRateCardsItemOneKeyMax).regex(createPlanBodyPhasesItemRateCardsItemOneKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(createPlanBodyPhasesItemRateCardsItemOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createPlanBodyPhasesItemRateCardsItemOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(createPlanBodyPhasesItemRateCardsItemOneFeatureKeyMax).regex(createPlanBodyPhasesItemRateCardsItemOneFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(createPlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().nullable().describe('The billing cadence of the rate card.\nWhen null it means it is a one time fee.'),
  "price": zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemOnePriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(createPlanBodyPhasesItemRateCardsItemOnePriceOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.')
}).describe('A flat fee rate card defines a one-time purchase or a recurring fee.'),zod.object({
  "type": zod.enum(['usage_based']),
  "key": zod.coerce.string().min(1).max(createPlanBodyPhasesItemRateCardsItemTwoKeyMax).regex(createPlanBodyPhasesItemRateCardsItemTwoKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(createPlanBodyPhasesItemRateCardsItemTwoNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createPlanBodyPhasesItemRateCardsItemTwoDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(createPlanBodyPhasesItemRateCardsItemTwoFeatureKeyMax).regex(createPlanBodyPhasesItemRateCardsItemTwoFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(createPlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().describe('The billing cadence of the rate card.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(createPlanBodyPhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(createPlanBodyPhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.')
}).describe('A usage-based rate card defines a price based on usage.')]).describe('A rate card defines the pricing and entitlement of a feature or service.')).describe('The rate cards of the plan.')
}).describe('The plan phase or pricing ramp allows changing a plan\'s rate cards over time as a subscription progresses.')).min(1).describe('The plan phase or pricing ramp allows changing a plan\'s rate cards over time as a subscription progresses.\nA phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.')
}).describe('Resource create operation model.')


/**
 * Create a new draft version from plan.
It returns error if there is already a plan in draft or planId does not reference the latest published version.
 * @deprecated
 * @summary New draft plan
 */
export const nextPlanPathPlanIdOrKeyMax = 64;


export const nextPlanPathPlanIdOrKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const NextPlanParams = zod.object({
  "planIdOrKey": zod.coerce.string().min(1).max(nextPlanPathPlanIdOrKeyMax).regex(nextPlanPathPlanIdOrKeyRegExp)
})


/**
 * Update plan by id.
 * @summary Update a plan
 */
export const updatePlanPathPlanIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdatePlanParams = zod.object({
  "planId": zod.coerce.string().regex(updatePlanPathPlanIdRegExp)
})

export const updatePlanBodyNameMax = 256;

export const updatePlanBodyDescriptionMax = 1024;

export const updatePlanBodyProRatingConfigOneEnabledDefault = true;export const updatePlanBodyProRatingConfigOneModeDefault = `prorate_prices`;export const updatePlanBodyProRatingConfigDefault = { enabled: true, mode: "prorate_prices" };export const updatePlanBodyPhasesItemKeyMax = 64;


export const updatePlanBodyPhasesItemKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updatePlanBodyPhasesItemNameMax = 256;

export const updatePlanBodyPhasesItemDescriptionMax = 1024;

export const updatePlanBodyPhasesItemRateCardsItemOneKeyMax = 64;


export const updatePlanBodyPhasesItemRateCardsItemOneKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updatePlanBodyPhasesItemRateCardsItemOneNameMax = 256;

export const updatePlanBodyPhasesItemRateCardsItemOneDescriptionMax = 1024;

export const updatePlanBodyPhasesItemRateCardsItemOneFeatureKeyMax = 64;


export const updatePlanBodyPhasesItemRateCardsItemOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault = false;export const updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const updatePlanBodyPhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const updatePlanBodyPhasesItemRateCardsItemOnePriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemOnePriceOnePaymentTermDefault = `in_advance`;export const updatePlanBodyPhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoKeyMax = 64;


export const updatePlanBodyPhasesItemRateCardsItemTwoKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updatePlanBodyPhasesItemRateCardsItemTwoNameMax = 256;

export const updatePlanBodyPhasesItemRateCardsItemTwoDescriptionMax = 1024;

export const updatePlanBodyPhasesItemRateCardsItemTwoFeatureKeyMax = 64;


export const updatePlanBodyPhasesItemRateCardsItemTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault = false;export const updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const updatePlanBodyPhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault = `in_advance`;export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault = `1`;export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const updatePlanBodyPhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');



export const UpdatePlanBody = zod.object({
  "name": zod.coerce.string().min(1).max(updatePlanBodyNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updatePlanBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "alignment": zod.object({
  "billablesMustAlign": zod.coerce.boolean().optional().describe('Whether all Billable items and RateCards must align.\nAlignment means the Price\'s BillingCadence must align for both duration and anchor time.')
}).describe('Alignment configuration for a plan or subscription.').optional().describe('Alignment configuration for the plan.'),
  "billingCadence": zod.coerce.string().describe('The default billing cadence for subscriptions using this plan.\nDefines how often customers are billed using ISO8601 duration format.\nExamples: \"P1M\" (monthly), \"P3M\" (quarterly), \"P1Y\" (annually).'),
  "proRatingConfig": zod.object({
  "enabled": zod.coerce.boolean().describe('Whether pro-rating is enabled for this plan.'),
  "mode": zod.enum(['prorate_prices']).describe('Pro-rating mode options for handling billing period changes.').describe('How to handle pro-rating for billing period changes.')
}).describe('Configuration for pro-rating behavior.').default(updatePlanBodyProRatingConfigDefault).describe('Default pro-rating configuration for subscriptions using this plan.'),
  "phases": zod.array(zod.object({
  "key": zod.coerce.string().min(1).max(updatePlanBodyPhasesItemKeyMax).regex(updatePlanBodyPhasesItemKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(updatePlanBodyPhasesItemNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updatePlanBodyPhasesItemDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "duration": zod.coerce.string().nullable().describe('The duration of the phase.'),
  "rateCards": zod.array(zod.union([zod.object({
  "type": zod.enum(['flat_fee']),
  "key": zod.coerce.string().min(1).max(updatePlanBodyPhasesItemRateCardsItemOneKeyMax).regex(updatePlanBodyPhasesItemRateCardsItemOneKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(updatePlanBodyPhasesItemRateCardsItemOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updatePlanBodyPhasesItemRateCardsItemOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(updatePlanBodyPhasesItemRateCardsItemOneFeatureKeyMax).regex(updatePlanBodyPhasesItemRateCardsItemOneFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(updatePlanBodyPhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().nullable().describe('The billing cadence of the rate card.\nWhen null it means it is a one time fee.'),
  "price": zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemOnePriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(updatePlanBodyPhasesItemRateCardsItemOnePriceOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.')
}).describe('A flat fee rate card defines a one-time purchase or a recurring fee.'),zod.object({
  "type": zod.enum(['usage_based']),
  "key": zod.coerce.string().min(1).max(updatePlanBodyPhasesItemRateCardsItemTwoKeyMax).regex(updatePlanBodyPhasesItemRateCardsItemTwoKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(updatePlanBodyPhasesItemRateCardsItemTwoNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updatePlanBodyPhasesItemRateCardsItemTwoDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(updatePlanBodyPhasesItemRateCardsItemTwoFeatureKeyMax).regex(updatePlanBodyPhasesItemRateCardsItemTwoFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(updatePlanBodyPhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().describe('The billing cadence of the rate card.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(updatePlanBodyPhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.')
}).describe('A usage-based rate card defines a price based on usage.')]).describe('A rate card defines the pricing and entitlement of a feature or service.')).describe('The rate cards of the plan.')
}).describe('The plan phase or pricing ramp allows changing a plan\'s rate cards over time as a subscription progresses.')).min(1).describe('The plan phase or pricing ramp allows changing a plan\'s rate cards over time as a subscription progresses.\nA phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.')
}).describe('Resource update operation model.')


/**
 * Get a plan by id or key. The latest published version is returned if latter is used.
 * @summary Get plan
 */
export const getPlanPathPlanIdMax = 64;


export const getPlanPathPlanIdRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetPlanParams = zod.object({
  "planId": zod.coerce.string().min(1).max(getPlanPathPlanIdMax).regex(getPlanPathPlanIdRegExp)
})

export const getPlanQueryIncludeLatestDefault = false;

export const GetPlanQueryParams = zod.object({
  "includeLatest": zod.coerce.boolean().default(getPlanQueryIncludeLatestDefault).describe('Include latest version of the Plan instead of the version in active state.\n\nUsage: `?includeLatest=true`')
})


/**
 * Soft delete plan by plan.id.

Once a plan is deleted it cannot be undeleted.
 * @summary Delete plan
 */
export const deletePlanPathPlanIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeletePlanParams = zod.object({
  "planId": zod.coerce.string().regex(deletePlanPathPlanIdRegExp)
})


/**
 * List all available add-ons for plan.
 * @summary List all available add-ons for plan
 */
export const listPlanAddonsPathPlanIdMax = 64;


export const listPlanAddonsPathPlanIdRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ListPlanAddonsParams = zod.object({
  "planId": zod.coerce.string().min(1).max(listPlanAddonsPathPlanIdMax).regex(listPlanAddonsPathPlanIdRegExp)
})

export const listPlanAddonsQueryIncludeDeletedDefault = false;export const listPlanAddonsQueryIdItemRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listPlanAddonsQueryKeyItemMax = 64;


export const listPlanAddonsQueryKeyItemRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const listPlanAddonsQueryPageDefault = 1;

export const listPlanAddonsQueryPageSizeDefault = 100;
export const listPlanAddonsQueryPageSizeMax = 1000;



export const ListPlanAddonsQueryParams = zod.object({
  "includeDeleted": zod.coerce.boolean().default(listPlanAddonsQueryIncludeDeletedDefault).describe('Include deleted plan add-on assignments.\n\nUsage: `?includeDeleted=true`'),
  "id": zod.array(zod.coerce.string().regex(listPlanAddonsQueryIdItemRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')).optional().describe('Filter by addon.id attribute.'),
  "key": zod.array(zod.coerce.string().min(1).max(listPlanAddonsQueryKeyItemMax).regex(listPlanAddonsQueryKeyItemRegExp).describe('A key is a unique string that is used to identify a resource.')).optional().describe('Filter by addon.key attribute.'),
  "keyVersion": zod.record(zod.string(), zod.array(zod.coerce.number())).optional().describe('Filter by addon.key and addon.version attributes.'),
  "page": zod.coerce.number().min(1).default(listPlanAddonsQueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listPlanAddonsQueryPageSizeMax).default(listPlanAddonsQueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'key', 'version', 'created_at', 'updated_at']).optional().describe('The order by field.')
})


/**
 * Create new add-on assignment for plan.
 * @summary Create new add-on assignment for plan
 */
export const createPlanAddonPathPlanIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const CreatePlanAddonParams = zod.object({
  "planId": zod.coerce.string().regex(createPlanAddonPathPlanIdRegExp)
})

export const createPlanAddonBodyAddonIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const CreatePlanAddonBody = zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the resource.'),
  "fromPlanPhase": zod.coerce.string().describe('The key of the plan phase from the add-on becomes available for purchase.'),
  "maxQuantity": zod.coerce.number().optional().describe('The maximum number of times the add-on can be purchased for the plan.\nIt is not applicable for add-ons with single instance type.'),
  "addonId": zod.coerce.string().regex(createPlanAddonBodyAddonIdRegExp).describe('The add-on unique identifier in ULID format.')
}).describe('A plan add-on assignment create request.')


/**
 * Update add-on assignment for plan.
 * @summary Update add-on assignment for plan
 */
export const updatePlanAddonPathPlanIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const updatePlanAddonPathPlanAddonIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdatePlanAddonParams = zod.object({
  "planId": zod.coerce.string().regex(updatePlanAddonPathPlanIdRegExp),
  "planAddonId": zod.coerce.string().regex(updatePlanAddonPathPlanAddonIdRegExp)
})

export const UpdatePlanAddonBody = zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the resource.'),
  "fromPlanPhase": zod.coerce.string().describe('The key of the plan phase from the add-on becomes available for purchase.'),
  "maxQuantity": zod.coerce.number().optional().describe('The maximum number of times the add-on can be purchased for the plan.\nIt is not applicable for add-ons with single instance type.')
}).describe('Resource update operation model.')


/**
 * Get add-on assignment for plan by id.
 * @summary Get add-on assignment for plan
 */
export const getPlanAddonPathPlanIdMax = 64;


export const getPlanAddonPathPlanIdRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const getPlanAddonPathPlanAddonIdMax = 64;


export const getPlanAddonPathPlanAddonIdRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetPlanAddonParams = zod.object({
  "planId": zod.coerce.string().min(1).max(getPlanAddonPathPlanIdMax).regex(getPlanAddonPathPlanIdRegExp),
  "planAddonId": zod.coerce.string().min(1).max(getPlanAddonPathPlanAddonIdMax).regex(getPlanAddonPathPlanAddonIdRegExp)
})


/**
 * Delete add-on assignment for plan.

Once a plan is deleted it cannot be undeleted.
 * @summary Delete add-on assignment for plan
 */
export const deletePlanAddonPathPlanIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const deletePlanAddonPathPlanAddonIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeletePlanAddonParams = zod.object({
  "planId": zod.coerce.string().regex(deletePlanAddonPathPlanIdRegExp),
  "planAddonId": zod.coerce.string().regex(deletePlanAddonPathPlanAddonIdRegExp)
})


/**
 * Archive a plan version.
 * @summary Archive plan version
 */
export const archivePlanPathPlanIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ArchivePlanParams = zod.object({
  "planId": zod.coerce.string().regex(archivePlanPathPlanIdRegExp)
})


/**
 * Publish a plan version.
 * @summary Publish plan
 */
export const publishPlanPathPlanIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const PublishPlanParams = zod.object({
  "planId": zod.coerce.string().regex(publishPlanPathPlanIdRegExp)
})


/**
 * Query meter for consumer portal. This endpoint is publicly exposable to consumers. Query meter for consumer portal. This endpoint is publicly exposable to consumers.
 * @summary Query meter Query meter
 */
export const queryPortalMeterPathMeterSlugMax = 64;


export const queryPortalMeterPathMeterSlugRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');


export const QueryPortalMeterParams = zod.object({
  "meterSlug": zod.coerce.string().min(1).max(queryPortalMeterPathMeterSlugMax).regex(queryPortalMeterPathMeterSlugRegExp)
})

export const queryPortalMeterQueryClientIdMax = 36;

export const queryPortalMeterQueryWindowTimeZoneDefault = `UTC`;export const queryPortalMeterQueryFilterCustomerIdMax = 100;



export const QueryPortalMeterQueryParams = zod.object({
  "clientId": zod.coerce.string().min(1).max(queryPortalMeterQueryClientIdMax).optional().describe('Client ID\nUseful to track progress of a query.'),
  "from": zod.coerce.date().optional().describe('Start date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?from=2025-01-01T00%3A00%3A00.000Z'),
  "to": zod.coerce.date().optional().describe('End date-time in RFC 3339 format.\n\nInclusive.\n\nFor example: ?to=2025-02-01T00%3A00%3A00.000Z'),
  "windowSize": zod.enum(['MINUTE', 'HOUR', 'DAY', 'MONTH']).optional().describe('If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.\n\nFor example: ?windowSize=DAY'),
  "windowTimeZone": zod.coerce.string().default(queryPortalMeterQueryWindowTimeZoneDefault).describe('The value is the name of the time zone as defined in the IANA Time Zone Database (http:\/\/www.iana.org\/time-zones).\nIf not specified, the UTC timezone will be used.\n\nFor example: ?windowTimeZone=UTC'),
  "filterCustomerId": zod.array(zod.coerce.string()).max(queryPortalMeterQueryFilterCustomerIdMax).optional().describe('Filtering by multiple customers.\n\nFor example: ?filterCustomerId=customer-1&filterCustomerId=customer-2'),
  "filterGroupBy": zod.record(zod.string(), zod.coerce.string()).optional().describe('Simple filter for group bys with exact match.\n\nFor example: ?filterGroupBy[vendor]=openai&filterGroupBy[model]=gpt-4-turbo\n\n‚ö†Ô∏è __Deprecated__: Use `advancedMeterGroupByFilters` instead'),
  "groupBy": zod.array(zod.coerce.string()).optional().describe('If not specified a single aggregate will be returned for each subject and time window.\n`subject` is a reserved group by value.\n\nFor example: ?groupBy=subject&groupBy=model')
})


/**
 * Create a consumer portal token.
 * @summary Create consumer portal token
 */
export const CreatePortalTokenBody = zod.object({
  "subject": zod.coerce.string(),
  "allowedMeterSlugs": zod.array(zod.coerce.string()).optional().describe('Optional, if defined only the specified meters will be allowed.')
}).describe('A consumer portal token.\n\nValidator doesn\'t obey required for readOnly properties\nSee: https:\/\/github.com\/stoplightio\/spectral\/issues\/1274')


/**
 * List tokens.
 * @summary List consumer portal tokens
 */
export const listPortalTokensQueryLimitDefault = 25;
export const listPortalTokensQueryLimitMax = 100;



export const ListPortalTokensQueryParams = zod.object({
  "limit": zod.coerce.number().min(1).max(listPortalTokensQueryLimitMax).default(listPortalTokensQueryLimitDefault)
})


/**
 * Invalidates consumer portal tokens by ID or subject.
 * @summary Invalidate portal tokens
 */
export const InvalidatePortalTokensBody = zod.object({
  "id": zod.coerce.string().optional().describe('Invalidate a portal token by ID.'),
  "subject": zod.coerce.string().optional().describe('Invalidate all portal tokens for a subject.')
})


/**
 * Create checkout session.
 * @summary Create checkout session
 */
export const createStripeCheckoutSessionBodyAppIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createStripeCheckoutSessionBodyCustomerOneIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createStripeCheckoutSessionBodyCustomerThreeNameMax = 256;

export const createStripeCheckoutSessionBodyCustomerThreeDescriptionMax = 1024;

export const createStripeCheckoutSessionBodyCustomerThreeKeyMax = 256;


export const createStripeCheckoutSessionBodyCustomerThreeUsageAttributionOneSubjectKeysMin = 0;

export const createStripeCheckoutSessionBodyCustomerThreeCurrencyOneMin = 3;
export const createStripeCheckoutSessionBodyCustomerThreeCurrencyOneMax = 3;


export const createStripeCheckoutSessionBodyCustomerThreeCurrencyOneRegExp = new RegExp('^[A-Z]{3}$');
export const createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneMin = 2;
export const createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneMax = 2;


export const createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneRegExp = new RegExp('^[A-Z]{2}$');
export const createStripeCheckoutSessionBodyOptionsOneCurrencyOneMin = 3;
export const createStripeCheckoutSessionBodyOptionsOneCurrencyOneMax = 3;


export const createStripeCheckoutSessionBodyOptionsOneCurrencyOneRegExp = new RegExp('^[A-Z]{3}$');
export const createStripeCheckoutSessionBodyOptionsOneCustomTextOneAfterSubmitMessageMax = 1200;

export const createStripeCheckoutSessionBodyOptionsOneCustomTextOneShippingAddressMessageMax = 1200;

export const createStripeCheckoutSessionBodyOptionsOneCustomTextOneSubmitMessageMax = 1200;

export const createStripeCheckoutSessionBodyOptionsOneCustomTextOneTermsOfServiceAcceptanceMessageMax = 1200;



export const CreateStripeCheckoutSessionBody = zod.object({
  "appId": zod.coerce.string().regex(createStripeCheckoutSessionBodyAppIdRegExp).optional().describe('If not provided, the default Stripe app is used if any.'),
  "customer": zod.union([zod.object({
  "id": zod.coerce.string().regex(createStripeCheckoutSessionBodyCustomerOneIdRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).')
}).describe('Create Stripe checkout session with customer ID.'),zod.object({
  "key": zod.coerce.string()
}).describe('Create Stripe checkout session with customer key.'),zod.object({
  "name": zod.coerce.string().min(1).max(createStripeCheckoutSessionBodyCustomerThreeNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createStripeCheckoutSessionBodyCustomerThreeDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "key": zod.coerce.string().min(1).max(createStripeCheckoutSessionBodyCustomerThreeKeyMax).optional().describe('An optional unique key of the customer.\nEither key or usageAttribution.subjectKeys must be provided.\nUseful to reference the customer in external systems.\nFor example, your database ID.'),
  "usageAttribution": zod.object({
  "subjectKeys": zod.array(zod.coerce.string().min(1).describe('SubjectKey is a key that is used to identify a subject.')).min(createStripeCheckoutSessionBodyCustomerThreeUsageAttributionOneSubjectKeysMin).describe('The subjects that are attributed to the customer.\nCan be empty when no subjects are associated with the customer.')
}).describe('Mapping to attribute metered usage to the customer.\nOne customer can have zero or more subjects,\nbut one subject can only belong to one customer.').optional().describe('Mapping to attribute metered usage to the customer\nEither key or usageAttribution.subjectKeys must be provided.'),
  "primaryEmail": zod.coerce.string().optional().describe('The primary email address of the customer.'),
  "currency": zod.coerce.string().min(createStripeCheckoutSessionBodyCustomerThreeCurrencyOneMin).max(createStripeCheckoutSessionBodyCustomerThreeCurrencyOneMax).regex(createStripeCheckoutSessionBodyCustomerThreeCurrencyOneRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.').optional().describe('Currency of the customer.\nUsed for billing, tax and invoicing.'),
  "billingAddress": zod.object({
  "country": zod.coerce.string().min(createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneMin).max(createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneMax).regex(createStripeCheckoutSessionBodyCustomerThreeBillingAddressOneCountryOneRegExp).describe('[ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 country code.\nCustom two-letter country codes are also supported for convenience.').optional().describe('Country code in [ISO 3166-1](https:\/\/www.iso.org\/iso-3166-country-codes.html) alpha-2 format.'),
  "postalCode": zod.coerce.string().optional().describe('Postal code.'),
  "state": zod.coerce.string().optional().describe('State or province.'),
  "city": zod.coerce.string().optional().describe('City.'),
  "line1": zod.coerce.string().optional().describe('First line of the address.'),
  "line2": zod.coerce.string().optional().describe('Second line of the address.'),
  "phoneNumber": zod.coerce.string().optional().describe('Phone number.')
}).describe('Address').optional().describe('The billing address of the customer.\nUsed for tax and invoicing.')
}).describe('Resource create operation model.')]).describe('Provide a customer ID or key to use an existing OpenMeter customer.\nor provide a customer object to create a new customer.'),
  "stripeCustomerId": zod.coerce.string().optional().describe('Stripe customer ID.\nIf not provided OpenMeter creates a new Stripe customer or\nuses the OpenMeter customer\'s default Stripe customer ID.'),
  "options": zod.object({
  "billingAddressCollection": zod.enum(['auto', 'required']).describe('Specify whether Checkout should collect the customer‚Äôs billing address.').optional().describe('Specify whether Checkout should collect the customer‚Äôs billing address. Defaults to auto.'),
  "cancelURL": zod.coerce.string().optional().describe('If set, Checkout displays a back button and customers will be directed to this URL if they decide to cancel payment and return to your website.\nThis parameter is not allowed if ui_mode is embedded.'),
  "clientReferenceID": zod.coerce.string().optional().describe('A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the session with your internal systems.'),
  "customerUpdate": zod.object({
  "address": zod.enum(['auto', 'never']).describe('Create Stripe checkout session customer update behavior.').optional().describe('Describes whether Checkout saves the billing address onto customer.address.\nTo always collect a full billing address, use billing_address_collection.\nDefaults to never.'),
  "name": zod.enum(['auto', 'never']).describe('Create Stripe checkout session customer update behavior.').optional().describe('Describes whether Checkout saves the name onto customer.name.\nDefaults to never.'),
  "shipping": zod.enum(['auto', 'never']).describe('Create Stripe checkout session customer update behavior.').optional().describe('Describes whether Checkout saves shipping information onto customer.shipping.\nTo collect shipping information, use shipping_address_collection.\nDefaults to never.')
}).describe('Controls what fields on Customer can be updated by the Checkout Session.').optional().describe('Controls what fields on Customer can be updated by the Checkout Session.'),
  "consentCollection": zod.object({
  "paymentMethodReuseAgreement": zod.object({
  "position": zod.enum(['auto', 'hidden']).optional().describe('Create Stripe checkout session consent collection agreement position.')
}).describe('Create Stripe checkout session payment method reuse agreement.').optional().describe('Determines the position and visibility of the payment method reuse agreement in the UI.\nWhen set to auto, Stripe‚Äôs defaults will be used. When set to hidden, the payment method reuse agreement text will always be hidden in the UI.'),
  "promotions": zod.enum(['auto', 'none']).describe('Create Stripe checkout session consent collection promotions.').optional().describe('If set to auto, enables the collection of customer consent for promotional communications.\nThe Checkout Session will determine whether to display an option to opt into promotional\ncommunication from the merchant depending on the customer‚Äôs locale. Only available to US merchants.'),
  "termsOfService": zod.enum(['none', 'required']).describe('Create Stripe checkout session consent collection terms of service.').optional().describe('If set to required, it requires customers to check a terms of service checkbox before being able to pay.\nThere must be a valid terms of service URL set in your Stripe Dashboard settings.\nhttps:\/\/dashboard.stripe.com\/settings\/public')
}).describe('Configure fields for the Checkout Session to gather active consent from customers.').optional().describe('Configure fields for the Checkout Session to gather active consent from customers.'),
  "currency": zod.coerce.string().min(createStripeCheckoutSessionBodyOptionsOneCurrencyOneMin).max(createStripeCheckoutSessionBodyOptionsOneCurrencyOneMax).regex(createStripeCheckoutSessionBodyOptionsOneCurrencyOneRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.').optional().describe('Three-letter ISO currency code, in lowercase.'),
  "customText": zod.object({
  "afterSubmit": zod.object({
  "message": zod.coerce.string().max(createStripeCheckoutSessionBodyOptionsOneCustomTextOneAfterSubmitMessageMax).optional()
}).optional().describe('Custom text that should be displayed after the payment confirmation button.'),
  "shippingAddress": zod.object({
  "message": zod.coerce.string().max(createStripeCheckoutSessionBodyOptionsOneCustomTextOneShippingAddressMessageMax).optional()
}).optional().describe('Custom text that should be displayed alongside shipping address collection.'),
  "submit": zod.object({
  "message": zod.coerce.string().max(createStripeCheckoutSessionBodyOptionsOneCustomTextOneSubmitMessageMax).optional()
}).optional().describe('Custom text that should be displayed alongside the payment confirmation button.'),
  "termsOfServiceAcceptance": zod.object({
  "message": zod.coerce.string().max(createStripeCheckoutSessionBodyOptionsOneCustomTextOneTermsOfServiceAcceptanceMessageMax).optional()
}).optional().describe('Custom text that should be displayed in place of the default terms of service agreement text.')
}).describe('Stripe CheckoutSession.custom_text').optional().describe('Display additional text for your customers using custom text.'),
  "expiresAt": zod.coerce.number().optional().describe('The Epoch time in seconds at which the Checkout Session will expire.\nIt can be anywhere from 30 minutes to 24 hours after Checkout Session creation. By default, this value is 24 hours from creation.'),
  "locale": zod.coerce.string().optional(),
  "metadata": zod.record(zod.string(), zod.coerce.string()).optional().describe('Set of key-value pairs that you can attach to an object.\nThis can be useful for storing additional information about the object in a structured format.\nIndividual keys can be unset by posting an empty value to them.\nAll keys can be unset by posting an empty value to metadata.'),
  "returnURL": zod.coerce.string().optional().describe('The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method‚Äôs app or site.\nThis parameter is required if ui_mode is embedded and redirect-based payment methods are enabled on the session.'),
  "successURL": zod.coerce.string().optional().describe('The URL to which Stripe should send customers when payment or setup is complete.\nThis parameter is not allowed if ui_mode is embedded.\nIf you‚Äôd like to use information from the successful Checkout Session on your page, read the guide on customizing your success page:\nhttps:\/\/docs.stripe.com\/payments\/checkout\/custom-success-page'),
  "uiMode": zod.enum(['embedded', 'hosted']).describe('Stripe CheckoutSession.ui_mode').optional().describe('The UI mode of the Session. Defaults to hosted.'),
  "paymentMethodTypes": zod.array(zod.coerce.string()).optional().describe('A list of the types of payment methods (e.g., card) this Checkout Session can accept.'),
  "redirectOnCompletion": zod.enum(['always', 'if_required', 'never']).describe('Create Stripe checkout session redirect on completion.').optional().describe('This parameter applies to ui_mode: embedded. Defaults to always.\nLearn more about the redirect behavior of embedded sessions at\nhttps:\/\/docs.stripe.com\/payments\/checkout\/custom-success-page?payment-ui=embedded-form'),
  "taxIdCollection": zod.object({
  "enabled": zod.coerce.boolean().describe('Enable tax ID collection during checkout. Defaults to false.'),
  "required": zod.enum(['if_supported', 'never']).describe('Create Stripe checkout session tax ID collection required.').optional().describe('Describes whether a tax ID is required during checkout. Defaults to never.')
}).describe('Create Stripe checkout session tax ID collection.').optional().describe('Controls tax ID collection during checkout.')
}).describe('Create Stripe checkout session options\nSee https:\/\/docs.stripe.com\/api\/checkout\/sessions\/create').describe('Options passed to Stripe when creating the checkout session.')
}).describe('Create Stripe checkout session request.')


/**
 * Upserts a subject. Creates or updates subject.

If the subject doesn't exist, it will be created.
If the subject exists, it will be partially updated with the provided fields.

‚ö†Ô∏è __Deprecated__: Subjects as managable entities are being depracated, use customers with subject key usage attribution instead.
 * @deprecated
 * @summary Upsert subject
 */
export const UpsertSubjectBodyItem = zod.object({
  "key": zod.coerce.string().describe('A unique, human-readable identifier for the subject.\nThis is typically a database ID or a customer key.'),
  "displayName": zod.coerce.string().nullish().describe('A human-readable display name for the subject.'),
  "metadata": zod.record(zod.string(), zod.unknown()).nullish().describe('Metadata for the subject.'),
  "currentPeriodStart": zod.coerce.date().optional().describe('The start of the current period for the subject.'),
  "currentPeriodEnd": zod.coerce.date().optional().describe('The end of the current period for the subject.'),
  "stripeCustomerId": zod.coerce.string().nullish().describe('The Stripe customer ID for the subject.')
}).describe('A subject is a unique identifier for a user or entity.\n\n‚ö†Ô∏è __Deprecated__: Subjects as managable entities are being depracated, use customers with subject key usage attribution instead.')
export const UpsertSubjectBody = zod.array(UpsertSubjectBodyItem)


/**
 * Get subject by ID or key.

‚ö†Ô∏è __Deprecated__: Subjects as managable entities are being depracated, use customers with subject key usage attribution instead.
 * @deprecated
 * @summary Get subject
 */
export const GetSubjectParams = zod.object({
  "subjectIdOrKey": zod.coerce.string()
})


/**
 * Delete subject by ID or key.

‚ö†Ô∏è __Deprecated__: Subjects as managable entities are being depracated, use customers with subject key usage attribution instead.
 * @deprecated
 * @summary Delete subject
 */
export const DeleteSubjectParams = zod.object({
  "subjectIdOrKey": zod.coerce.string()
})


/**
 * OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).

- Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
- Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
- Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.

A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.

Once an entitlement is created you cannot modify it, only delete it.

‚ö†Ô∏è __Deprecated__: Use [`POST /api/v2/customers/{customerIdOrKey}/entitlements`](#tag/entitlements/post/api/v2/customers/{customerIdOrKey}/entitlements) instead.
 * @deprecated
 * @summary Create a subject entitlement
 */
export const CreateEntitlementParams = zod.object({
  "subjectIdOrKey": zod.coerce.string()
})

export const createEntitlementBodyOneFeatureKeyMax = 64;


export const createEntitlementBodyOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createEntitlementBodyOneFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createEntitlementBodyOneIsSoftLimitDefault = false;export const createEntitlementBodyOneIsUnlimitedDefault = false;export const createEntitlementBodyOneUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const createEntitlementBodyOneIssueAfterResetMin = 0;

export const createEntitlementBodyOneIssueAfterResetPriorityDefault = 1;
export const createEntitlementBodyOneIssueAfterResetPriorityMax = 255;

export const createEntitlementBodyOnePreserveOverageAtResetDefault = false;export const createEntitlementBodyTwoFeatureKeyMax = 64;


export const createEntitlementBodyTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createEntitlementBodyTwoFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createEntitlementBodyTwoUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const createEntitlementBodyThreeFeatureKeyMax = 64;


export const createEntitlementBodyThreeFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createEntitlementBodyThreeFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createEntitlementBodyThreeUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');


export const CreateEntitlementBody = zod.union([zod.object({
  "featureKey": zod.coerce.string().min(1).max(createEntitlementBodyOneFeatureKeyMax).regex(createEntitlementBodyOneFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(createEntitlementBodyOneFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(createEntitlementBodyOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "isUnlimited": zod.coerce.boolean().default(createEntitlementBodyOneIsUnlimitedDefault).describe('Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(createEntitlementBodyOneUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').describe('The usage period associated with the entitlement.'),
  "measureUsageFrom": zod.union([zod.enum(['CURRENT_PERIOD_START', 'NOW']).describe('Start of measurement options'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Measure usage from').optional().describe('Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.'),
  "issueAfterReset": zod.coerce.number().min(createEntitlementBodyOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(createEntitlementBodyOneIssueAfterResetPriorityMax).default(createEntitlementBodyOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(createEntitlementBodyOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.')
}).describe('Create inpurs for metered entitlement'),zod.object({
  "featureKey": zod.coerce.string().min(1).max(createEntitlementBodyTwoFeatureKeyMax).regex(createEntitlementBodyTwoFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(createEntitlementBodyTwoFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(createEntitlementBodyTwoUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The usage period associated with the entitlement.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Create inputs for static entitlement'),zod.object({
  "featureKey": zod.coerce.string().min(1).max(createEntitlementBodyThreeFeatureKeyMax).regex(createEntitlementBodyThreeFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(createEntitlementBodyThreeFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(createEntitlementBodyThreeUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The usage period associated with the entitlement.'),
  "type": zod.enum(['boolean'])
}).describe('Create inputs for boolean entitlement')]).describe('Create inputs for entitlement')


/**
 * List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/customers/{customerIdOrKey}/entitlements`](#tag/entitlements/get/api/v2/customers/{customerIdOrKey}/entitlements) instead.
 * @deprecated
 * @summary List subject entitlements
 */
export const ListSubjectEntitlementsParams = zod.object({
  "subjectIdOrKey": zod.coerce.string()
})

export const listSubjectEntitlementsQueryIncludeDeletedDefault = false;

export const ListSubjectEntitlementsQueryParams = zod.object({
  "includeDeleted": zod.coerce.boolean().default(listSubjectEntitlementsQueryIncludeDeletedDefault)
})


/**
 * List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants`](#tag/entitlements/get/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants) instead.
 * @deprecated
 * @summary List subject entitlement grants
 */
export const ListEntitlementGrantsParams = zod.object({
  "subjectIdOrKey": zod.coerce.string(),
  "entitlementIdOrFeatureKey": zod.coerce.string()
})

export const listEntitlementGrantsQueryIncludeDeletedDefault = false;

export const ListEntitlementGrantsQueryParams = zod.object({
  "includeDeleted": zod.coerce.boolean().default(listEntitlementGrantsQueryIncludeDeletedDefault),
  "orderBy": zod.enum(['id', 'createdAt', 'updatedAt']).optional()
})


/**
 * Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.

A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.

Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.

Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).

Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))

Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.

‚ö†Ô∏è __Deprecated__: Use [`POST /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants`](#tag/entitlements/post/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants) instead.
 * @deprecated
 * @summary Create subject entitlement grant
 */
export const CreateGrantParams = zod.object({
  "subjectIdOrKey": zod.coerce.string(),
  "entitlementIdOrFeatureKey": zod.coerce.string()
})

export const createGrantBodyAmountMin = 0;

export const createGrantBodyPriorityMax = 255;

export const createGrantBodyExpirationOneCountMax = 1000;

export const createGrantBodyMaxRolloverAmountDefault = 0;export const createGrantBodyMinRolloverAmountDefault = 0;export const createGrantBodyRecurrenceOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');


export const CreateGrantBody = zod.object({
  "amount": zod.coerce.number().min(createGrantBodyAmountMin).describe('The amount to grant. Should be a positive number.'),
  "priority": zod.coerce.number().min(1).max(createGrantBodyPriorityMax).optional().describe('The priority of the grant. Grants with higher priority are applied first.\nPriority is a positive decimal numbers. With lower numbers indicating higher importance.\nFor example, a priority of 1 is more urgent than a priority of 2.\nWhen there are several grants available for the same subject, the system selects the grant with the highest priority.\nIn cases where grants share the same priority level, the grant closest to its expiration will be used first.\nIn the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.'),
  "effectiveAt": zod.coerce.date().describe('Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).'),
  "expiration": zod.object({
  "duration": zod.enum(['HOUR', 'DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The expiration duration enum').describe('The unit of time for the expiration period.'),
  "count": zod.coerce.number().min(1).max(createGrantBodyExpirationOneCountMax).describe('The number of time units in the expiration period.')
}).describe('The grant expiration definition').describe('The grant expiration definition'),
  "maxRolloverAmount": zod.coerce.number().default(createGrantBodyMaxRolloverAmountDefault).describe('Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))'),
  "minRolloverAmount": zod.coerce.number().default(createGrantBodyMinRolloverAmountDefault).describe('Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('The grant metadata.'),
  "recurrence": zod.object({
  "interval": zod.union([zod.coerce.string().regex(createGrantBodyRecurrenceOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The subject of the grant.')
}).describe('The grant creation input.')


/**
 * Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided subject-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.

This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime.

‚ö†Ô∏è __Deprecated__: Use [`PUT /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override`](#tag/entitlements/put/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override) instead.
 * @deprecated
 * @summary Override subject entitlement
 */
export const OverrideEntitlementParams = zod.object({
  "subjectIdOrKey": zod.coerce.string(),
  "entitlementIdOrFeatureKey": zod.coerce.string()
})

export const overrideEntitlementBodyOneFeatureKeyMax = 64;


export const overrideEntitlementBodyOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const overrideEntitlementBodyOneFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const overrideEntitlementBodyOneIsSoftLimitDefault = false;export const overrideEntitlementBodyOneIsUnlimitedDefault = false;export const overrideEntitlementBodyOneUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const overrideEntitlementBodyOneIssueAfterResetMin = 0;

export const overrideEntitlementBodyOneIssueAfterResetPriorityDefault = 1;
export const overrideEntitlementBodyOneIssueAfterResetPriorityMax = 255;

export const overrideEntitlementBodyOnePreserveOverageAtResetDefault = false;export const overrideEntitlementBodyTwoFeatureKeyMax = 64;


export const overrideEntitlementBodyTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const overrideEntitlementBodyTwoFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const overrideEntitlementBodyTwoUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const overrideEntitlementBodyThreeFeatureKeyMax = 64;


export const overrideEntitlementBodyThreeFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const overrideEntitlementBodyThreeFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const overrideEntitlementBodyThreeUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');


export const OverrideEntitlementBody = zod.union([zod.object({
  "featureKey": zod.coerce.string().min(1).max(overrideEntitlementBodyOneFeatureKeyMax).regex(overrideEntitlementBodyOneFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(overrideEntitlementBodyOneFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(overrideEntitlementBodyOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "isUnlimited": zod.coerce.boolean().default(overrideEntitlementBodyOneIsUnlimitedDefault).describe('Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(overrideEntitlementBodyOneUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').describe('The usage period associated with the entitlement.'),
  "measureUsageFrom": zod.union([zod.enum(['CURRENT_PERIOD_START', 'NOW']).describe('Start of measurement options'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Measure usage from').optional().describe('Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.'),
  "issueAfterReset": zod.coerce.number().min(overrideEntitlementBodyOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(overrideEntitlementBodyOneIssueAfterResetPriorityMax).default(overrideEntitlementBodyOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(overrideEntitlementBodyOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.')
}).describe('Create inpurs for metered entitlement'),zod.object({
  "featureKey": zod.coerce.string().min(1).max(overrideEntitlementBodyTwoFeatureKeyMax).regex(overrideEntitlementBodyTwoFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(overrideEntitlementBodyTwoFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(overrideEntitlementBodyTwoUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The usage period associated with the entitlement.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Create inputs for static entitlement'),zod.object({
  "featureKey": zod.coerce.string().min(1).max(overrideEntitlementBodyThreeFeatureKeyMax).regex(overrideEntitlementBodyThreeFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(overrideEntitlementBodyThreeFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(overrideEntitlementBodyThreeUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The usage period associated with the entitlement.'),
  "type": zod.enum(['boolean'])
}).describe('Create inputs for boolean entitlement')]).describe('Create inputs for entitlement')


/**
 * This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.

For convenience reasons, /value works with both entitlementId and featureKey.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value`](#tag/entitlements/get/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value) instead.
 * @deprecated
 * @summary Get subject entitlement value
 */
export const GetEntitlementValueParams = zod.object({
  "subjectIdOrKey": zod.coerce.string(),
  "entitlementIdOrFeatureKey": zod.coerce.string()
})

export const GetEntitlementValueQueryParams = zod.object({
  "time": zod.coerce.date().optional()
})


/**
 * Get entitlement by id. For checking entitlement access, use the /value endpoint instead.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}`](#tag/entitlements/get/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}) instead.
 * @deprecated
 * @summary Get subject entitlement
 */
export const GetEntitlementParams = zod.object({
  "subjectIdOrKey": zod.coerce.string(),
  "entitlementId": zod.coerce.string()
})


/**
 * Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.

‚ö†Ô∏è __Deprecated__: Use [`DELETE /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}`](#tag/entitlements/delete/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}) instead.
 * @deprecated
 * @summary Delete subject entitlement
 */
export const DeleteEntitlementParams = zod.object({
  "subjectIdOrKey": zod.coerce.string(),
  "entitlementId": zod.coerce.string()
})


/**
 * Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.

BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.

WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.

‚ö†Ô∏è __Deprecated__: Use [`GET /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/history`](#tag/entitlements/get/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/history) instead.
 * @deprecated
 * @summary Get subject entitlement history
 */
export const GetEntitlementHistoryParams = zod.object({
  "subjectIdOrKey": zod.coerce.string(),
  "entitlementId": zod.coerce.string()
})

export const getEntitlementHistoryQueryWindowTimeZoneDefault = `UTC`;

export const GetEntitlementHistoryQueryParams = zod.object({
  "from": zod.coerce.date().optional().describe('Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to the last reset. Gets truncated to the granularity of the underlying meter.'),
  "to": zod.coerce.date().optional().describe('End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.\nIf not now then gets truncated to the granularity of the underlying meter.'),
  "windowSize": zod.enum(['MINUTE', 'HOUR', 'DAY', 'MONTH']).describe('Windowsize'),
  "windowTimeZone": zod.coerce.string().default(getEntitlementHistoryQueryWindowTimeZoneDefault).describe('The timezone used when calculating the windows.')
})


/**
 * Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.

Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.

‚ö†Ô∏è __Deprecated__: Use [`POST /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/reset`](#tag/entitlements/post/api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/reset) instead.
 * @deprecated
 * @summary Reset subject entitlement
 */
export const ResetEntitlementUsageParams = zod.object({
  "subjectIdOrKey": zod.coerce.string(),
  "entitlementId": zod.coerce.string()
})

export const ResetEntitlementUsageBody = zod.object({
  "effectiveAt": zod.coerce.date().optional().describe('The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.'),
  "retainAnchor": zod.coerce.boolean().optional().describe('Determines whether the usage period anchor is retained or reset to the effectiveAt time.\n- If true, the usage period anchor is retained.\n- If false, the usage period anchor is reset to the effectiveAt time.'),
  "preserveOverage": zod.coerce.boolean().optional().describe('Determines whether the overage is preserved or forgiven, overriding the entitlement\'s default behavior.\n- If true, the overage is preserved.\n- If false, the overage is forgiven.')
}).describe('Reset parameters')


/**
 * @summary Create subscription
 */
export const createSubscriptionBodyOnePlanOneKeyMax = 64;


export const createSubscriptionBodyOnePlanOneKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');

export const createSubscriptionBodyOneTimingDefault = `immediate`;export const createSubscriptionBodyOneCustomerIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createSubscriptionBodyOneCustomerKeyMax = 256;

export const createSubscriptionBodyTwoCustomPlanOneOneNameMax = 256;

export const createSubscriptionBodyTwoCustomPlanOneOneDescriptionMax = 1024;

export const createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMin = 3;
export const createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMax = 3;


export const createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneRegExp = new RegExp('^[A-Z]{3}$');
export const createSubscriptionBodyTwoCustomPlanOneOneCurrencyDefault = `USD`;export const createSubscriptionBodyTwoCustomPlanOneOneProRatingConfigOneEnabledDefault = true;export const createSubscriptionBodyTwoCustomPlanOneOneProRatingConfigOneModeDefault = `prorate_prices`;export const createSubscriptionBodyTwoCustomPlanOneOneProRatingConfigDefault = { enabled: true, mode: "prorate_prices" };export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyMax = 64;


export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemNameMax = 256;

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemDescriptionMax = 1024;

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyMax = 64;


export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneNameMax = 256;

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDescriptionMax = 1024;

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyMax = 64;


export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault = false;export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOnePaymentTermDefault = `in_advance`;export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyMax = 64;


export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoNameMax = 256;

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDescriptionMax = 1024;

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyMax = 64;


export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault = false;export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault = `in_advance`;export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault = `1`;export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const createSubscriptionBodyTwoTimingDefault = `immediate`;export const createSubscriptionBodyTwoCustomerIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createSubscriptionBodyTwoCustomerKeyMax = 256;



export const CreateSubscriptionBody = zod.union([zod.object({
  "alignment": zod.object({
  "billablesMustAlign": zod.coerce.boolean().optional().describe('Whether all Billable items and RateCards must align.\nAlignment means the Price\'s BillingCadence must align for both duration and anchor time.')
}).describe('Alignment configuration for a plan or subscription.').optional().describe('What alignment settings the subscription should have.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Arbitrary metadata associated with the subscription.'),
  "plan": zod.object({
  "key": zod.coerce.string().min(1).max(createSubscriptionBodyOnePlanOneKeyMax).regex(createSubscriptionBodyOnePlanOneKeyRegExp).describe('The plan key.'),
  "version": zod.coerce.number().optional().describe('The plan version.')
}).describe('References an exact plan defaulting to the current active version.').describe('The plan reference to change to.'),
  "startingPhase": zod.coerce.string().min(1).optional().describe('The key of the phase to start the subscription in.\nIf not provided, the subscription will start in the first phase of the plan.'),
  "name": zod.coerce.string().optional().describe('The name of the Subscription. If not provided the plan name is used.'),
  "description": zod.coerce.string().optional().describe('Description for the Subscription.'),
  "timing": zod.union([zod.enum(['immediate', 'next_billing_cycle']).describe('Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.').default(createSubscriptionBodyOneTimingDefault).describe('Timing configuration for the change, when the change should take effect.\nThe default is immediate.'),
  "customerId": zod.coerce.string().regex(createSubscriptionBodyOneCustomerIdRegExp).optional().describe('The ID of the customer. Provide either the key or ID. Has presedence over the key.'),
  "customerKey": zod.coerce.string().min(1).max(createSubscriptionBodyOneCustomerKeyMax).optional().describe('The key of the customer. Provide either the key or ID.'),
  "billingAnchor": zod.coerce.date().optional().describe('The billing anchor of the subscription. The provided date will be normalized according to the billing cadence to the nearest recurrence before start time. If not provided, the subscription start time will be used.')
}).describe('Create subscription based on plan.'),zod.object({
  "customPlan": zod.object({
  "name": zod.coerce.string().min(1).max(createSubscriptionBodyTwoCustomPlanOneOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createSubscriptionBodyTwoCustomPlanOneOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "alignment": zod.object({
  "billablesMustAlign": zod.coerce.boolean().optional().describe('Whether all Billable items and RateCards must align.\nAlignment means the Price\'s BillingCadence must align for both duration and anchor time.')
}).describe('Alignment configuration for a plan or subscription.').optional().describe('Alignment configuration for the plan.'),
  "currency": zod.coerce.string().min(createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMin).max(createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMax).regex(createSubscriptionBodyTwoCustomPlanOneOneCurrencyOneRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.').describe('The currency code of the plan.'),
  "billingCadence": zod.coerce.string().describe('The default billing cadence for subscriptions using this plan.\nDefines how often customers are billed using ISO8601 duration format.\nExamples: \"P1M\" (monthly), \"P3M\" (quarterly), \"P1Y\" (annually).'),
  "proRatingConfig": zod.object({
  "enabled": zod.coerce.boolean().describe('Whether pro-rating is enabled for this plan.'),
  "mode": zod.enum(['prorate_prices']).describe('Pro-rating mode options for handling billing period changes.').describe('How to handle pro-rating for billing period changes.')
}).describe('Configuration for pro-rating behavior.').default(createSubscriptionBodyTwoCustomPlanOneOneProRatingConfigDefault).describe('Default pro-rating configuration for subscriptions using this plan.'),
  "phases": zod.array(zod.object({
  "key": zod.coerce.string().min(1).max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyMax).regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "duration": zod.coerce.string().nullable().describe('The duration of the phase.'),
  "rateCards": zod.array(zod.union([zod.object({
  "type": zod.enum(['flat_fee']),
  "key": zod.coerce.string().min(1).max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyMax).regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyMax).regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().nullable().describe('The billing cadence of the rate card.\nWhen null it means it is a one time fee.'),
  "price": zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.')
}).describe('A flat fee rate card defines a one-time purchase or a recurring fee.'),zod.object({
  "type": zod.enum(['usage_based']),
  "key": zod.coerce.string().min(1).max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyMax).regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyMax).regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().describe('The billing cadence of the rate card.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(createSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.')
}).describe('A usage-based rate card defines a price based on usage.')]).describe('A rate card defines the pricing and entitlement of a feature or service.')).describe('The rate cards of the plan.')
}).describe('The plan phase or pricing ramp allows changing a plan\'s rate cards over time as a subscription progresses.')).min(1).describe('The plan phase or pricing ramp allows changing a plan\'s rate cards over time as a subscription progresses.\nA phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.')
}).describe('The template for omitting properties.').describe('Plan input for custom subscription creation (without key and version).').describe('The custom plan description which defines the Subscription.'),
  "timing": zod.union([zod.enum(['immediate', 'next_billing_cycle']).describe('Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.').default(createSubscriptionBodyTwoTimingDefault).describe('Timing configuration for the change, when the change should take effect.\nThe default is immediate.'),
  "customerId": zod.coerce.string().regex(createSubscriptionBodyTwoCustomerIdRegExp).optional().describe('The ID of the customer. Provide either the key or ID. Has presedence over the key.'),
  "customerKey": zod.coerce.string().min(1).max(createSubscriptionBodyTwoCustomerKeyMax).optional().describe('The key of the customer. Provide either the key or ID.'),
  "billingAnchor": zod.coerce.date().optional().describe('The billing anchor of the subscription. The provided date will be normalized according to the billing cadence to the nearest recurrence before start time. If not provided, the subscription start time will be used.')
}).describe('Create a custom subscription.')]).describe('Create a subscription.')


/**
 * @summary Get subscription
 */
export const getSubscriptionPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetSubscriptionParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(getSubscriptionPathSubscriptionIdRegExp)
})

export const GetSubscriptionQueryParams = zod.object({
  "at": zod.coerce.date().optional().describe('The time at which the subscription should be queried. If not provided the current time is used.')
})


/**
 * Batch processing commands for manipulating running subscriptions.
The key format is `/phases/{phaseKey}` or `/phases/{phaseKey}/items/{itemKey}`.
 * @summary Edit subscription
 */
export const editSubscriptionPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const EditSubscriptionParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(editSubscriptionPathSubscriptionIdRegExp)
})

export const editSubscriptionBodyCustomizationsItemOneRateCardOneKeyMax = 64;


export const editSubscriptionBodyCustomizationsItemOneRateCardOneKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const editSubscriptionBodyCustomizationsItemOneRateCardOneNameMax = 256;

export const editSubscriptionBodyCustomizationsItemOneRateCardOneDescriptionMax = 1024;

export const editSubscriptionBodyCustomizationsItemOneRateCardOneFeatureKeyMax = 64;


export const editSubscriptionBodyCustomizationsItemOneRateCardOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIsSoftLimitDefault = false;export const editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const editSubscriptionBodyCustomizationsItemOneRateCardOneTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const editSubscriptionBodyCustomizationsItemOneRateCardOnePriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardOnePriceOnePaymentTermDefault = `in_advance`;export const editSubscriptionBodyCustomizationsItemOneRateCardOneDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoKeyMax = 64;


export const editSubscriptionBodyCustomizationsItemOneRateCardTwoKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoNameMax = 256;

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoDescriptionMax = 1024;

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoFeatureKeyMax = 64;


export const editSubscriptionBodyCustomizationsItemOneRateCardTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIsSoftLimitDefault = false;export const editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const editSubscriptionBodyCustomizationsItemOneRateCardTwoTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneOnePaymentTermDefault = `in_advance`;export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMultiplierDefault = `1`;export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemOneRateCardTwoDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemThreePhaseDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const editSubscriptionBodyCustomizationsItemThreePhaseKeyMax = 64;


export const editSubscriptionBodyCustomizationsItemThreePhaseKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const editSubscriptionBodyCustomizationsMax = 100;



export const EditSubscriptionBody = zod.object({
  "customizations": zod.array(zod.union([zod.object({
  "op": zod.enum(['add_item']),
  "phaseKey": zod.coerce.string(),
  "rateCard": zod.union([zod.object({
  "type": zod.enum(['flat_fee']),
  "key": zod.coerce.string().min(1).max(editSubscriptionBodyCustomizationsItemOneRateCardOneKeyMax).regex(editSubscriptionBodyCustomizationsItemOneRateCardOneKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(editSubscriptionBodyCustomizationsItemOneRateCardOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(editSubscriptionBodyCustomizationsItemOneRateCardOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(editSubscriptionBodyCustomizationsItemOneRateCardOneFeatureKeyMax).regex(editSubscriptionBodyCustomizationsItemOneRateCardOneFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(editSubscriptionBodyCustomizationsItemOneRateCardOneEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardOneTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().nullable().describe('The billing cadence of the rate card.\nWhen null it means it is a one time fee.'),
  "price": zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardOnePriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(editSubscriptionBodyCustomizationsItemOneRateCardOnePriceOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardOneDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.')
}).describe('A flat fee rate card defines a one-time purchase or a recurring fee.'),zod.object({
  "type": zod.enum(['usage_based']),
  "key": zod.coerce.string().min(1).max(editSubscriptionBodyCustomizationsItemOneRateCardTwoKeyMax).regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(editSubscriptionBodyCustomizationsItemOneRateCardTwoNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(editSubscriptionBodyCustomizationsItemOneRateCardTwoDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(editSubscriptionBodyCustomizationsItemOneRateCardTwoFeatureKeyMax).regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(editSubscriptionBodyCustomizationsItemOneRateCardTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().describe('The billing cadence of the rate card.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoPriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemOneRateCardTwoDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.')
}).describe('A usage-based rate card defines a price based on usage.')]).describe('A rate card defines the pricing and entitlement of a feature or service.')
}).describe('Add a new item to a phase.'),zod.object({
  "op": zod.enum(['remove_item']),
  "phaseKey": zod.coerce.string(),
  "itemKey": zod.coerce.string()
}).describe('Remove an item from a phase.'),zod.object({
  "op": zod.enum(['add_phase']),
  "phase": zod.object({
  "startAfter": zod.coerce.string().nullable().describe('Interval after the subscription starts to transition to the phase.\nWhen null, the phase starts immediately after the subscription starts.'),
  "duration": zod.coerce.string().optional().describe('The intended duration of the new phase.\nDuration is required when the phase will not be the last phase.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(editSubscriptionBodyCustomizationsItemThreePhaseDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discounts on the plan.'),
  "key": zod.coerce.string().min(1).max(editSubscriptionBodyCustomizationsItemThreePhaseKeyMax).regex(editSubscriptionBodyCustomizationsItemThreePhaseKeyRegExp).describe('A locally unique identifier for the phase.'),
  "name": zod.coerce.string().describe('The name of the phase.'),
  "description": zod.coerce.string().optional().describe('The description of the phase.')
}).describe('Subscription phase create input.')
}).describe('Add a new phase'),zod.object({
  "op": zod.enum(['remove_phase']),
  "phaseKey": zod.coerce.string(),
  "shift": zod.enum(['next', 'prev']).describe('The direction of the phase shift when a phase is removed.')
}).describe('Remove a phase'),zod.object({
  "op": zod.enum(['stretch_phase']),
  "phaseKey": zod.coerce.string(),
  "extendBy": zod.coerce.string()
}).describe('Stretch a phase'),zod.object({
  "op": zod.enum(['unschedule_edit'])
}).describe('Unschedules any edits from the current phase.')]).describe('The operation to be performed on the subscription.')).max(editSubscriptionBodyCustomizationsMax).describe('Batch processing commands for manipulating running subscriptions.\nThe key format is `\/phases\/{phaseKey}` or `\/phases\/{phaseKey}\/items\/{itemKey}`.'),
  "timing": zod.union([zod.enum(['immediate', 'next_billing_cycle']).describe('Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.').optional().describe('Whether the billing period should be restarted.Timing configuration to allow for the changes to take effect at different times.')
}).describe('Subscription edit input.')


/**
 * Deletes a subscription. Only scheduled subscriptions can be deleted.
 * @summary Delete subscription
 */
export const deleteSubscriptionPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeleteSubscriptionParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(deleteSubscriptionPathSubscriptionIdRegExp)
})


/**
 * Create a new subscription addon, either providing the key or the id of the addon.
 * @summary Create subscription addon
 */
export const createSubscriptionAddonPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const CreateSubscriptionAddonParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(createSubscriptionAddonPathSubscriptionIdRegExp)
})

export const createSubscriptionAddonBodyNameMax = 256;

export const createSubscriptionAddonBodyDescriptionMax = 1024;

export const createSubscriptionAddonBodyQuantityMin = 0;

export const createSubscriptionAddonBodyAddonIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const CreateSubscriptionAddonBody = zod.object({
  "name": zod.coerce.string().min(1).max(createSubscriptionAddonBodyNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(createSubscriptionAddonBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "quantity": zod.coerce.number().min(createSubscriptionAddonBodyQuantityMin).describe('The quantity of the add-on. Always 1 for single instance add-ons.'),
  "timing": zod.union([zod.enum(['immediate', 'next_billing_cycle']).describe('Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.').describe('The timing of the operation. After the create or update, a new entry will be created in the timeline.'),
  "addon": zod.object({
  "id": zod.coerce.string().regex(createSubscriptionAddonBodyAddonIdRegExp).describe('The ID of the add-on.')
}).describe('The add-on to create.')
}).describe('A subscription add-on create body.')


/**
 * List all addons of a subscription. In the returned list will match to a set unique by addonId.
 * @summary List subscription addons
 */
export const listSubscriptionAddonsPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ListSubscriptionAddonsParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(listSubscriptionAddonsPathSubscriptionIdRegExp)
})


/**
 * Get a subscription addon by id.
 * @summary Get subscription addon
 */
export const getSubscriptionAddonPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const getSubscriptionAddonPathSubscriptionAddonIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetSubscriptionAddonParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(getSubscriptionAddonPathSubscriptionIdRegExp),
  "subscriptionAddonId": zod.coerce.string().regex(getSubscriptionAddonPathSubscriptionAddonIdRegExp)
})


/**
 * Updates a subscription addon (allows changing the quantity: purchasing more instances or cancelling the current instances)
 * @summary Update subscription addon
 */
export const updateSubscriptionAddonPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const updateSubscriptionAddonPathSubscriptionAddonIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UpdateSubscriptionAddonParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(updateSubscriptionAddonPathSubscriptionIdRegExp),
  "subscriptionAddonId": zod.coerce.string().regex(updateSubscriptionAddonPathSubscriptionAddonIdRegExp)
})

export const updateSubscriptionAddonBodyNameMax = 256;

export const updateSubscriptionAddonBodyDescriptionMax = 1024;

export const updateSubscriptionAddonBodyQuantityMin = 0;



export const UpdateSubscriptionAddonBody = zod.object({
  "name": zod.coerce.string().min(1).max(updateSubscriptionAddonBodyNameMax).optional().describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(updateSubscriptionAddonBodyDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "quantity": zod.coerce.number().min(updateSubscriptionAddonBodyQuantityMin).optional().describe('The quantity of the add-on. Always 1 for single instance add-ons.'),
  "timing": zod.union([zod.enum(['immediate', 'next_billing_cycle']).describe('Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.').optional().describe('The timing of the operation. After the create or update, a new entry will be created in the timeline.')
}).describe('Resource create or update operation model.')


/**
 * Cancels the subscription.
Will result in a scheduling conflict if there are other subscriptions scheduled to start after the cancellation time.
 * @summary Cancel subscription
 */
export const cancelSubscriptionPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const CancelSubscriptionParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(cancelSubscriptionPathSubscriptionIdRegExp)
})

export const CancelSubscriptionBody = zod.object({
  "timing": zod.union([zod.enum(['immediate', 'next_billing_cycle']).describe('Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.').optional().describe('If not provided the subscription is canceled immediately.')
})


/**
 * Closes a running subscription and starts a new one according to the specification.
Can be used for upgrades, downgrades, and plan changes.
 * @summary Change subscription
 */
export const changeSubscriptionPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ChangeSubscriptionParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(changeSubscriptionPathSubscriptionIdRegExp)
})

export const changeSubscriptionBodyOnePlanOneKeyMax = 64;


export const changeSubscriptionBodyOnePlanOneKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');

export const changeSubscriptionBodyTwoCustomPlanOneOneNameMax = 256;

export const changeSubscriptionBodyTwoCustomPlanOneOneDescriptionMax = 1024;

export const changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMin = 3;
export const changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMax = 3;


export const changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneRegExp = new RegExp('^[A-Z]{3}$');
export const changeSubscriptionBodyTwoCustomPlanOneOneCurrencyDefault = `USD`;export const changeSubscriptionBodyTwoCustomPlanOneOneProRatingConfigOneEnabledDefault = true;export const changeSubscriptionBodyTwoCustomPlanOneOneProRatingConfigOneModeDefault = `prorate_prices`;export const changeSubscriptionBodyTwoCustomPlanOneOneProRatingConfigDefault = { enabled: true, mode: "prorate_prices" };export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyMax = 64;


export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemNameMax = 256;

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemDescriptionMax = 1024;

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyMax = 64;


export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneNameMax = 256;

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDescriptionMax = 1024;

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyMax = 64;


export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault = false;export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOnePaymentTermDefault = `in_advance`;export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyMax = 64;


export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoNameMax = 256;

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDescriptionMax = 1024;

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyMax = 64;


export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault = false;export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin = 0;

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault = 1;
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax = 255;

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault = false;export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp = new RegExp('^txcd_\\d{8}$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault = `in_advance`;export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');

export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault = `1`;export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');
export const changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp = new RegExp('^\\-?[0-9]+(\\.[0-9]+)?$');



export const ChangeSubscriptionBody = zod.union([zod.object({
  "timing": zod.union([zod.enum(['immediate', 'next_billing_cycle']).describe('Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.').describe('Timing configuration for the change, when the change should take effect.\nFor changing a subscription, the accepted values depend on the subscription configuration.'),
  "alignment": zod.object({
  "billablesMustAlign": zod.coerce.boolean().optional().describe('Whether all Billable items and RateCards must align.\nAlignment means the Price\'s BillingCadence must align for both duration and anchor time.')
}).describe('Alignment configuration for a plan or subscription.').optional().describe('What alignment settings the subscription should have.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Arbitrary metadata associated with the subscription.'),
  "plan": zod.object({
  "key": zod.coerce.string().min(1).max(changeSubscriptionBodyOnePlanOneKeyMax).regex(changeSubscriptionBodyOnePlanOneKeyRegExp).describe('The plan key.'),
  "version": zod.coerce.number().optional().describe('The plan version.')
}).describe('References an exact plan defaulting to the current active version.').describe('The plan reference to change to.'),
  "startingPhase": zod.coerce.string().min(1).optional().describe('The key of the phase to start the subscription in.\nIf not provided, the subscription will start in the first phase of the plan.'),
  "name": zod.coerce.string().optional().describe('The name of the Subscription. If not provided the plan name is used.'),
  "description": zod.coerce.string().optional().describe('Description for the Subscription.'),
  "billingAnchor": zod.coerce.date().optional().describe('The billing anchor of the subscription. The provided date will be normalized according to the billing cadence to the nearest recurrence before start time. If not provided, the previous subscription billing anchor will be used.')
}).describe('Change subscription based on plan.'),zod.object({
  "timing": zod.union([zod.enum(['immediate', 'next_billing_cycle']).describe('Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.').describe('Timing configuration for the change, when the change should take effect.\nFor changing a subscription, the accepted values depend on the subscription configuration.'),
  "billingAnchor": zod.coerce.date().optional().describe('The billing anchor of the subscription. The provided date will be normalized according to the billing cadence to the nearest recurrence before start time. If not provided, the previous subscription billing anchor will be used.'),
  "customPlan": zod.object({
  "name": zod.coerce.string().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(changeSubscriptionBodyTwoCustomPlanOneOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "alignment": zod.object({
  "billablesMustAlign": zod.coerce.boolean().optional().describe('Whether all Billable items and RateCards must align.\nAlignment means the Price\'s BillingCadence must align for both duration and anchor time.')
}).describe('Alignment configuration for a plan or subscription.').optional().describe('Alignment configuration for the plan.'),
  "currency": zod.coerce.string().min(changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMin).max(changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneMax).regex(changeSubscriptionBodyTwoCustomPlanOneOneCurrencyOneRegExp).describe('Three-letter [ISO4217](https:\/\/www.iso.org\/iso-4217-currency-codes.html) currency code.\nCustom three-letter currency codes are also supported for convenience.').describe('The currency code of the plan.'),
  "billingCadence": zod.coerce.string().describe('The default billing cadence for subscriptions using this plan.\nDefines how often customers are billed using ISO8601 duration format.\nExamples: \"P1M\" (monthly), \"P3M\" (quarterly), \"P1Y\" (annually).'),
  "proRatingConfig": zod.object({
  "enabled": zod.coerce.boolean().describe('Whether pro-rating is enabled for this plan.'),
  "mode": zod.enum(['prorate_prices']).describe('Pro-rating mode options for handling billing period changes.').describe('How to handle pro-rating for billing period changes.')
}).describe('Configuration for pro-rating behavior.').default(changeSubscriptionBodyTwoCustomPlanOneOneProRatingConfigDefault).describe('Default pro-rating configuration for subscriptions using this plan.'),
  "phases": zod.array(zod.object({
  "key": zod.coerce.string().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyMax).regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "duration": zod.coerce.string().nullable().describe('The duration of the phase.'),
  "rateCards": zod.array(zod.union([zod.object({
  "type": zod.enum(['flat_fee']),
  "key": zod.coerce.string().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyMax).regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyMax).regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().nullable().describe('The billing cadence of the rate card.\nWhen null it means it is a one time fee.'),
  "price": zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOnePriceOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemOneDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discount of the rate card. For flat fee rate cards only percentage discounts are supported.\nOnly available when price is set.')
}).describe('A flat fee rate card defines a one-time purchase or a recurring fee.'),zod.object({
  "type": zod.enum(['usage_based']),
  "key": zod.coerce.string().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyMax).regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoKeyRegExp).describe('A semi-unique identifier for the resource.'),
  "name": zod.coerce.string().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoNameMax).describe('Human-readable name for the resource. Between 1 and 256 characters.'),
  "description": zod.coerce.string().max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDescriptionMax).optional().describe('Optional description of the resource. Maximum 1024 characters.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').nullish().describe('Additional metadata for the resource.'),
  "featureKey": zod.coerce.string().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyMax).regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoFeatureKeyRegExp).optional().describe('The feature the customer is entitled to use.'),
  "entitlementTemplate": zod.union([zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "issueAfterReset": zod.coerce.number().min(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityMax).default(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoEntitlementTemplateOneOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "usagePeriod": zod.coerce.string().optional().describe('The interval of the metered entitlement.\nDefaults to the billing cadence of the rate card.')
}).describe('The entitlement template with a metered entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Entitlement template of a static entitlement.'),zod.object({
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['boolean'])
}).describe('Entitlement template of a boolean entitlement.')]).describe('Entitlement templates are used to define the entitlements of a plan.\nFeatures are omitted from the entitlement template, as they are defined in the rate card.').optional().describe('The entitlement of the rate card.\nOnly available when featureKey is set.'),
  "taxConfig": zod.object({
  "behavior": zod.enum(['inclusive', 'exclusive']).describe('Tax behavior.\n\nThis enum is used to specify whether tax is included in the price or excluded from the price.').optional().describe('Tax behavior.\n\nIf not specified the billing profile is used to determine the tax behavior.\nIf not specified in the billing profile, the provider\'s default behavior is used.'),
  "stripe": zod.object({
  "code": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoTaxConfigOneStripeOneCodeRegExp).describe('Product tax code.\n\nSee: https:\/\/docs.stripe.com\/tax\/tax-codes')
}).describe('The tax config for Stripe.').optional().describe('Stripe tax config.'),
  "customInvoicing": zod.object({
  "code": zod.coerce.string().describe('Tax code.\n\nThe tax code should be interpreted by the custom invoicing provider.')
}).describe('Custom invoicing tax config.').optional().describe('Custom invoicing tax config.')
}).describe('Set of provider specific tax configs.').optional().describe('The tax config of the rate card.\nWhen undefined, the tax config of the feature or the default tax config of the plan is used.'),
  "billingCadence": zod.coerce.string().describe('The billing cadence of the rate card.'),
  "price": zod.union([zod.object({
  "type": zod.enum(['flat']),
  "amount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.'),
  "paymentTerm": zod.enum(['in_advance', 'in_arrears']).describe('The payment term of a flat price.\nOne of: in_advance or in_arrears.').default(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneOnePaymentTermDefault).describe('The payment term of the flat price.\nDefaults to in advance.')
}).describe('Flat price with payment term.'),zod.object({
  "type": zod.enum(['unit']),
  "amount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.'),
  "minimumAmount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneTwoMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Unit price with spend commitments.'),zod.object({
  "type": zod.enum(['tiered']),
  "mode": zod.enum(['volume', 'graduated']).describe('The mode of the tiered price.').describe('Defines if the tiering mode is volume-based or graduated:\n- In `volume`-based tiering, the maximum quantity within a period determines the per unit price.\n- In `graduated` tiering, pricing can change as the quantity grows.'),
  "tiers": zod.array(zod.object({
  "upToAmount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUpToAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('Up to and including to this quantity will be contained in the tier.\nIf null, the tier is open-ended.'),
  "flatPrice": zod.object({
  "type": zod.enum(['flat']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemFlatPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the flat price.')
}).describe('Flat price.').nullable().describe('The flat price component of the tier.'),
  "unitPrice": zod.object({
  "type": zod.enum(['unit']).describe('The type of the price.'),
  "amount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeTiersItemUnitPriceOneAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The amount of the unit price.')
}).describe('Unit price.').nullable().describe('The unit price component of the tier.')
}).describe('A price tier.\nAt least one price component is required in each tier.')).min(1).describe('The tiers of the tiered price.\nAt least one price component is required in each tier.'),
  "minimumAmount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneThreeMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Tiered price with spend commitments.'),zod.object({
  "type": zod.enum(['dynamic']),
  "multiplier": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierOneRegExp).describe('Numeric represents an arbitrary precision number.').default(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMultiplierDefault).describe('The multiplier to apply to the base price to get the dynamic price.\n\nExamples:\n- 0.0: the price is zero\n- 0.5: the price is 50% of the base price\n- 1.0: the price is the same as the base price\n- 1.5: the price is 150% of the base price'),
  "minimumAmount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFourMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Dynamic price with spend commitments.'),zod.object({
  "type": zod.enum(['package']),
  "amount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The price of one package.'),
  "quantityPerPackage": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveQuantityPerPackageOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity per package.'),
  "minimumAmount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMinimumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is committed to spend at least the amount.'),
  "maximumAmount": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoPriceOneFiveMaximumAmountOneRegExp).describe('Numeric represents an arbitrary precision number.').optional().describe('The customer is limited to spend at most the amount.')
}).describe('Package price with spend commitments.')]).describe('The price of the usage based rate card.').nullable().describe('The price of the rate card.\nWhen null, the feature or service is free.'),
  "discounts": zod.object({
  "percentage": zod.object({
  "percentage": zod.coerce.number().describe('Numeric representation of a percentage\n\n50% is represented as 50').describe('The percentage of the discount.')
}).describe('Percentage discount.').optional().describe('The percentage discount.'),
  "usage": zod.object({
  "quantity": zod.coerce.string().regex(changeSubscriptionBodyTwoCustomPlanOneOnePhasesItemRateCardsItemTwoDiscountsOneUsageOneQuantityOneRegExp).describe('Numeric represents an arbitrary precision number.').describe('The quantity of the usage discount.\n\nMust be positive.')
}).describe('Usage discount.\n\nUsage discount means that the first N items are free. From billing perspective\nthis means that any usage on a specific feature is considered 0 until this discount\nis exhausted.').optional().describe('The usage discount.')
}).describe('Discount by type on a price').optional().describe('The discounts of the rate card.\n\nFlat fee rate cards only support percentage discounts.')
}).describe('A usage-based rate card defines a price based on usage.')]).describe('A rate card defines the pricing and entitlement of a feature or service.')).describe('The rate cards of the plan.')
}).describe('The plan phase or pricing ramp allows changing a plan\'s rate cards over time as a subscription progresses.')).min(1).describe('The plan phase or pricing ramp allows changing a plan\'s rate cards over time as a subscription progresses.\nA phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.')
}).describe('The template for omitting properties.').describe('Plan input for custom subscription creation (without key and version).').describe('The custom plan description which defines the Subscription.')
}).describe('Change a custom subscription.')]).describe('Change a subscription.')


/**
 * Migrates the subscripiton to the provided version of the current plan.
If possible, the migration will be done immediately.
If not, the migration will be scheduled to the end of the current billing period.
 * @summary Migrate subscription
 */
export const migrateSubscriptionPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const MigrateSubscriptionParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(migrateSubscriptionPathSubscriptionIdRegExp)
})

export const migrateSubscriptionBodyTimingDefault = `immediate`;



export const MigrateSubscriptionBody = zod.object({
  "timing": zod.union([zod.enum(['immediate', 'next_billing_cycle']).describe('Subscription edit timing.\nWhen immediate, the requested changes take effect immediately.\nWhen nextBillingCycle, the requested changes take effect at the next billing cycle.'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Subscription edit timing defined when the changes should take effect.\nIf the provided configuration is not supported by the subscription, an error will be returned.').default(migrateSubscriptionBodyTimingDefault).describe('Timing configuration for the migration, when the migration should take effect.\nIf not supported by the subscription, 400 will be returned.'),
  "targetVersion": zod.coerce.number().min(1).optional().describe('The version of the plan to migrate to.\nIf not provided, the subscription will migrate to the latest version of the current plan.'),
  "startingPhase": zod.coerce.string().min(1).optional().describe('The key of the phase to start the subscription in.\nIf not provided, the subscription will start in the first phase of the plan.'),
  "billingAnchor": zod.coerce.date().optional().describe('The billing anchor of the subscription. The provided date will be normalized according to the billing cadence to the nearest recurrence before start time. If not provided, the previous subscription billing anchor will be used.')
})


/**
 * Restores a canceled subscription.
Any subscription scheduled to start later will be deleted and this subscription will be continued indefinitely.
 * @deprecated
 * @summary Restore subscription
 */
export const restoreSubscriptionPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const RestoreSubscriptionParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(restoreSubscriptionPathSubscriptionIdRegExp)
})


/**
 * Cancels the scheduled cancelation.
 * @summary Unschedule cancelation
 */
export const unscheduleCancelationPathSubscriptionIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const UnscheduleCancelationParams = zod.object({
  "subscriptionId": zod.coerce.string().regex(unscheduleCancelationPathSubscriptionIdRegExp)
})


/**
 * OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).

- Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
- Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
- Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.

A given customer can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.

Once an entitlement is created you cannot modify it, only delete it.
 * @summary Create a customer entitlement
 */
export const createCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createCustomerEntitlementV2PathCustomerIdOrKeyTwoMax = 256;



export const CreateCustomerEntitlementV2Params = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(createCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(createCustomerEntitlementV2PathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})

export const createCustomerEntitlementV2BodyOneFeatureKeyMax = 64;


export const createCustomerEntitlementV2BodyOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createCustomerEntitlementV2BodyOneFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createCustomerEntitlementV2BodyOneIsSoftLimitDefault = false;export const createCustomerEntitlementV2BodyOneUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const createCustomerEntitlementV2BodyOnePreserveOverageAtResetDefault = false;export const createCustomerEntitlementV2BodyOneIssueAfterResetMin = 0;

export const createCustomerEntitlementV2BodyOneIssueAfterResetPriorityDefault = 1;
export const createCustomerEntitlementV2BodyOneIssueAfterResetPriorityMax = 255;

export const createCustomerEntitlementV2BodyOneIssueOneAmountMin = 0;

export const createCustomerEntitlementV2BodyOneIssueOnePriorityDefault = 1;
export const createCustomerEntitlementV2BodyOneIssueOnePriorityMax = 255;

export const createCustomerEntitlementV2BodyOneGrantsItemAmountMin = 0;

export const createCustomerEntitlementV2BodyOneGrantsItemPriorityMax = 255;

export const createCustomerEntitlementV2BodyOneGrantsItemMinRolloverAmountDefault = 0;export const createCustomerEntitlementV2BodyOneGrantsItemRecurrenceOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const createCustomerEntitlementV2BodyOneGrantsItemExpirationOneCountMax = 1000;

export const createCustomerEntitlementV2BodyTwoFeatureKeyMax = 64;


export const createCustomerEntitlementV2BodyTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createCustomerEntitlementV2BodyTwoFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createCustomerEntitlementV2BodyTwoUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const createCustomerEntitlementV2BodyThreeFeatureKeyMax = 64;


export const createCustomerEntitlementV2BodyThreeFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const createCustomerEntitlementV2BodyThreeFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createCustomerEntitlementV2BodyThreeUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');


export const CreateCustomerEntitlementV2Body = zod.union([zod.object({
  "featureKey": zod.coerce.string().min(1).max(createCustomerEntitlementV2BodyOneFeatureKeyMax).regex(createCustomerEntitlementV2BodyOneFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(createCustomerEntitlementV2BodyOneFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(createCustomerEntitlementV2BodyOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(createCustomerEntitlementV2BodyOneUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').describe('The usage period associated with the entitlement.'),
  "measureUsageFrom": zod.union([zod.enum(['CURRENT_PERIOD_START', 'NOW']).describe('Start of measurement options'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Measure usage from').optional().describe('Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(createCustomerEntitlementV2BodyOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "issueAfterReset": zod.coerce.number().min(createCustomerEntitlementV2BodyOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(createCustomerEntitlementV2BodyOneIssueAfterResetPriorityMax).default(createCustomerEntitlementV2BodyOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "issue": zod.object({
  "amount": zod.coerce.number().min(createCustomerEntitlementV2BodyOneIssueOneAmountMin).describe('The initial grant amount'),
  "priority": zod.coerce.number().min(1).max(createCustomerEntitlementV2BodyOneIssueOnePriorityMax).default(createCustomerEntitlementV2BodyOneIssueOnePriorityDefault).describe('The priority of the issue after reset')
}).describe('Issue after reset').optional().describe('Issue after reset'),
  "grants": zod.array(zod.object({
  "amount": zod.coerce.number().min(createCustomerEntitlementV2BodyOneGrantsItemAmountMin).describe('The amount to grant. Should be a positive number.'),
  "priority": zod.coerce.number().min(1).max(createCustomerEntitlementV2BodyOneGrantsItemPriorityMax).optional().describe('The priority of the grant. Grants with higher priority are applied first.\nPriority is a positive decimal numbers. With lower numbers indicating higher importance.\nFor example, a priority of 1 is more urgent than a priority of 2.\nWhen there are several grants available for the same subject, the system selects the grant with the highest priority.\nIn cases where grants share the same priority level, the grant closest to its expiration will be used first.\nIn the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.'),
  "effectiveAt": zod.coerce.date().describe('Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).'),
  "minRolloverAmount": zod.coerce.number().default(createCustomerEntitlementV2BodyOneGrantsItemMinRolloverAmountDefault).describe('Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('The grant metadata.'),
  "recurrence": zod.object({
  "interval": zod.union([zod.coerce.string().regex(createCustomerEntitlementV2BodyOneGrantsItemRecurrenceOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The subject of the grant.'),
  "maxRolloverAmount": zod.coerce.number().optional().describe('Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset. The default value equals grant amount.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))'),
  "expiration": zod.object({
  "duration": zod.enum(['HOUR', 'DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The expiration duration enum').describe('The unit of time for the expiration period.'),
  "count": zod.coerce.number().min(1).max(createCustomerEntitlementV2BodyOneGrantsItemExpirationOneCountMax).describe('The number of time units in the expiration period.')
}).describe('The grant expiration definition').optional().describe('The grant expiration definition. If no expiration is provided, the grant can be active indefinitely.'),
  "annotations": zod.record(zod.string(), zod.unknown()).describe('Set of key-value pairs managed by the system. Cannot be modified by user.').optional().describe('Grant annotations')
}).describe('The grant creation input.')).optional().describe('Grants')
}).describe('Create inputs for metered entitlement'),zod.object({
  "featureKey": zod.coerce.string().min(1).max(createCustomerEntitlementV2BodyTwoFeatureKeyMax).regex(createCustomerEntitlementV2BodyTwoFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(createCustomerEntitlementV2BodyTwoFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(createCustomerEntitlementV2BodyTwoUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The usage period associated with the entitlement.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Create inputs for static entitlement'),zod.object({
  "featureKey": zod.coerce.string().min(1).max(createCustomerEntitlementV2BodyThreeFeatureKeyMax).regex(createCustomerEntitlementV2BodyThreeFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(createCustomerEntitlementV2BodyThreeFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(createCustomerEntitlementV2BodyThreeUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The usage period associated with the entitlement.'),
  "type": zod.enum(['boolean'])
}).describe('Create inputs for boolean entitlement')]).describe('Create inputs for entitlement')


/**
 * List all entitlements for a customer. For checking entitlement access, use the /value endpoint instead.
 * @summary List customer entitlements
 */
export const listCustomerEntitlementsV2PathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listCustomerEntitlementsV2PathCustomerIdOrKeyTwoMax = 256;



export const ListCustomerEntitlementsV2Params = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(listCustomerEntitlementsV2PathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(listCustomerEntitlementsV2PathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})

export const listCustomerEntitlementsV2QueryIncludeDeletedDefault = false;export const listCustomerEntitlementsV2QueryPageDefault = 1;

export const listCustomerEntitlementsV2QueryPageSizeDefault = 100;
export const listCustomerEntitlementsV2QueryPageSizeMax = 1000;



export const ListCustomerEntitlementsV2QueryParams = zod.object({
  "includeDeleted": zod.coerce.boolean().default(listCustomerEntitlementsV2QueryIncludeDeletedDefault),
  "page": zod.coerce.number().min(1).default(listCustomerEntitlementsV2QueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listCustomerEntitlementsV2QueryPageSizeMax).default(listCustomerEntitlementsV2QueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['createdAt', 'updatedAt']).optional().describe('The order by field.')
})


/**
 * Get entitlement by feature key. For checking entitlement access, use the /value endpoint instead.
If featureKey is used, the entitlement is resolved for the current timestamp.
 * @summary Get customer entitlement
 */
export const getCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const getCustomerEntitlementV2PathCustomerIdOrKeyTwoMax = 256;

export const getCustomerEntitlementV2PathEntitlementIdOrFeatureKeyMax = 64;


export const getCustomerEntitlementV2PathEntitlementIdOrFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetCustomerEntitlementV2Params = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(getCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(getCustomerEntitlementV2PathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')]),
  "entitlementIdOrFeatureKey": zod.coerce.string().min(1).max(getCustomerEntitlementV2PathEntitlementIdOrFeatureKeyMax).regex(getCustomerEntitlementV2PathEntitlementIdOrFeatureKeyRegExp)
})


/**
 * Deleting an entitlement revokes access to the associated feature. As a single customer can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.
 * @summary Delete customer entitlement
 */
export const deleteCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const deleteCustomerEntitlementV2PathCustomerIdOrKeyTwoMax = 256;

export const deleteCustomerEntitlementV2PathEntitlementIdOrFeatureKeyMax = 64;


export const deleteCustomerEntitlementV2PathEntitlementIdOrFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const DeleteCustomerEntitlementV2Params = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(deleteCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(deleteCustomerEntitlementV2PathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')]),
  "entitlementIdOrFeatureKey": zod.coerce.string().min(1).max(deleteCustomerEntitlementV2PathEntitlementIdOrFeatureKeyMax).regex(deleteCustomerEntitlementV2PathEntitlementIdOrFeatureKeyRegExp)
})


/**
 * List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey.
 * @summary List customer entitlement grants
 */
export const listCustomerEntitlementGrantsV2PathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listCustomerEntitlementGrantsV2PathCustomerIdOrKeyTwoMax = 256;

export const listCustomerEntitlementGrantsV2PathEntitlementIdOrFeatureKeyMax = 64;


export const listCustomerEntitlementGrantsV2PathEntitlementIdOrFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ListCustomerEntitlementGrantsV2Params = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(listCustomerEntitlementGrantsV2PathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(listCustomerEntitlementGrantsV2PathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')]),
  "entitlementIdOrFeatureKey": zod.coerce.string().min(1).max(listCustomerEntitlementGrantsV2PathEntitlementIdOrFeatureKeyMax).regex(listCustomerEntitlementGrantsV2PathEntitlementIdOrFeatureKeyRegExp)
})

export const listCustomerEntitlementGrantsV2QueryIncludeDeletedDefault = false;export const listCustomerEntitlementGrantsV2QueryPageDefault = 1;

export const listCustomerEntitlementGrantsV2QueryPageSizeDefault = 100;
export const listCustomerEntitlementGrantsV2QueryPageSizeMax = 1000;

export const listCustomerEntitlementGrantsV2QueryOffsetDefault = 0;
export const listCustomerEntitlementGrantsV2QueryOffsetMin = 0;

export const listCustomerEntitlementGrantsV2QueryLimitDefault = 100;
export const listCustomerEntitlementGrantsV2QueryLimitMax = 1000;



export const ListCustomerEntitlementGrantsV2QueryParams = zod.object({
  "includeDeleted": zod.coerce.boolean().default(listCustomerEntitlementGrantsV2QueryIncludeDeletedDefault),
  "page": zod.coerce.number().min(1).default(listCustomerEntitlementGrantsV2QueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listCustomerEntitlementGrantsV2QueryPageSizeMax).default(listCustomerEntitlementGrantsV2QueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "offset": zod.coerce.number().min(listCustomerEntitlementGrantsV2QueryOffsetMin).default(listCustomerEntitlementGrantsV2QueryOffsetDefault).describe('Number of items to skip.\n\nDefault is 0.'),
  "limit": zod.coerce.number().min(1).max(listCustomerEntitlementGrantsV2QueryLimitMax).default(listCustomerEntitlementGrantsV2QueryLimitDefault).describe('Number of items to return.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'createdAt', 'updatedAt']).optional().describe('The order by field.')
})


/**
 * Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.

A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.

Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.

Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).

Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))

Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.
 * @summary Create customer entitlement grant
 */
export const createCustomerEntitlementGrantV2PathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const createCustomerEntitlementGrantV2PathCustomerIdOrKeyTwoMax = 256;

export const createCustomerEntitlementGrantV2PathEntitlementIdOrFeatureKeyMax = 64;


export const createCustomerEntitlementGrantV2PathEntitlementIdOrFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const CreateCustomerEntitlementGrantV2Params = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(createCustomerEntitlementGrantV2PathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(createCustomerEntitlementGrantV2PathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')]),
  "entitlementIdOrFeatureKey": zod.coerce.string().min(1).max(createCustomerEntitlementGrantV2PathEntitlementIdOrFeatureKeyMax).regex(createCustomerEntitlementGrantV2PathEntitlementIdOrFeatureKeyRegExp)
})

export const createCustomerEntitlementGrantV2BodyAmountMin = 0;

export const createCustomerEntitlementGrantV2BodyPriorityMax = 255;

export const createCustomerEntitlementGrantV2BodyMinRolloverAmountDefault = 0;export const createCustomerEntitlementGrantV2BodyRecurrenceOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const createCustomerEntitlementGrantV2BodyExpirationOneCountMax = 1000;



export const CreateCustomerEntitlementGrantV2Body = zod.object({
  "amount": zod.coerce.number().min(createCustomerEntitlementGrantV2BodyAmountMin).describe('The amount to grant. Should be a positive number.'),
  "priority": zod.coerce.number().min(1).max(createCustomerEntitlementGrantV2BodyPriorityMax).optional().describe('The priority of the grant. Grants with higher priority are applied first.\nPriority is a positive decimal numbers. With lower numbers indicating higher importance.\nFor example, a priority of 1 is more urgent than a priority of 2.\nWhen there are several grants available for the same subject, the system selects the grant with the highest priority.\nIn cases where grants share the same priority level, the grant closest to its expiration will be used first.\nIn the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.'),
  "effectiveAt": zod.coerce.date().describe('Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).'),
  "minRolloverAmount": zod.coerce.number().default(createCustomerEntitlementGrantV2BodyMinRolloverAmountDefault).describe('Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('The grant metadata.'),
  "recurrence": zod.object({
  "interval": zod.union([zod.coerce.string().regex(createCustomerEntitlementGrantV2BodyRecurrenceOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The subject of the grant.'),
  "maxRolloverAmount": zod.coerce.number().optional().describe('Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset. The default value equals grant amount.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))'),
  "expiration": zod.object({
  "duration": zod.enum(['HOUR', 'DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The expiration duration enum').describe('The unit of time for the expiration period.'),
  "count": zod.coerce.number().min(1).max(createCustomerEntitlementGrantV2BodyExpirationOneCountMax).describe('The number of time units in the expiration period.')
}).describe('The grant expiration definition').optional().describe('The grant expiration definition. If no expiration is provided, the grant can be active indefinitely.'),
  "annotations": zod.record(zod.string(), zod.unknown()).describe('Set of key-value pairs managed by the system. Cannot be modified by user.').optional().describe('Grant annotations')
}).describe('The grant creation input.')


/**
 * Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.

BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.

WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.
 * @summary Get customer entitlement history
 */
export const getCustomerEntitlementHistoryV2PathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const getCustomerEntitlementHistoryV2PathCustomerIdOrKeyTwoMax = 256;

export const getCustomerEntitlementHistoryV2PathEntitlementIdOrFeatureKeyMax = 64;


export const getCustomerEntitlementHistoryV2PathEntitlementIdOrFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetCustomerEntitlementHistoryV2Params = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(getCustomerEntitlementHistoryV2PathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(getCustomerEntitlementHistoryV2PathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')]),
  "entitlementIdOrFeatureKey": zod.coerce.string().min(1).max(getCustomerEntitlementHistoryV2PathEntitlementIdOrFeatureKeyMax).regex(getCustomerEntitlementHistoryV2PathEntitlementIdOrFeatureKeyRegExp)
})

export const getCustomerEntitlementHistoryV2QueryWindowTimeZoneDefault = `UTC`;

export const GetCustomerEntitlementHistoryV2QueryParams = zod.object({
  "from": zod.coerce.date().optional().describe('Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to the last reset. Gets truncated to the granularity of the underlying meter.'),
  "to": zod.coerce.date().optional().describe('End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.\nIf not now then gets truncated to the granularity of the underlying meter.'),
  "windowSize": zod.enum(['MINUTE', 'HOUR', 'DAY', 'MONTH']).describe('Windowsize'),
  "windowTimeZone": zod.coerce.string().default(getCustomerEntitlementHistoryV2QueryWindowTimeZoneDefault).describe('The timezone used when calculating the windows.')
})


/**
 * Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided customer-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.

This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime.
 * @summary Override customer entitlement
 */
export const overrideCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const overrideCustomerEntitlementV2PathCustomerIdOrKeyTwoMax = 256;

export const overrideCustomerEntitlementV2PathEntitlementIdOrFeatureKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const overrideCustomerEntitlementV2PathEntitlementIdOrFeatureKeyTwoMax = 256;



export const OverrideCustomerEntitlementV2Params = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(overrideCustomerEntitlementV2PathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(overrideCustomerEntitlementV2PathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')]),
  "entitlementIdOrFeatureKey": zod.union([zod.coerce.string().regex(overrideCustomerEntitlementV2PathEntitlementIdOrFeatureKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(overrideCustomerEntitlementV2PathEntitlementIdOrFeatureKeyTwoMax).describe('ExternalKey is a looser version of key.')])
})

export const overrideCustomerEntitlementV2BodyOneFeatureKeyMax = 64;


export const overrideCustomerEntitlementV2BodyOneFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const overrideCustomerEntitlementV2BodyOneFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const overrideCustomerEntitlementV2BodyOneIsSoftLimitDefault = false;export const overrideCustomerEntitlementV2BodyOneUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const overrideCustomerEntitlementV2BodyOnePreserveOverageAtResetDefault = false;export const overrideCustomerEntitlementV2BodyOneIssueAfterResetMin = 0;

export const overrideCustomerEntitlementV2BodyOneIssueAfterResetPriorityDefault = 1;
export const overrideCustomerEntitlementV2BodyOneIssueAfterResetPriorityMax = 255;

export const overrideCustomerEntitlementV2BodyOneIssueOneAmountMin = 0;

export const overrideCustomerEntitlementV2BodyOneIssueOnePriorityDefault = 1;
export const overrideCustomerEntitlementV2BodyOneIssueOnePriorityMax = 255;

export const overrideCustomerEntitlementV2BodyOneGrantsItemAmountMin = 0;

export const overrideCustomerEntitlementV2BodyOneGrantsItemPriorityMax = 255;

export const overrideCustomerEntitlementV2BodyOneGrantsItemMinRolloverAmountDefault = 0;export const overrideCustomerEntitlementV2BodyOneGrantsItemRecurrenceOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const overrideCustomerEntitlementV2BodyOneGrantsItemExpirationOneCountMax = 1000;

export const overrideCustomerEntitlementV2BodyTwoFeatureKeyMax = 64;


export const overrideCustomerEntitlementV2BodyTwoFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const overrideCustomerEntitlementV2BodyTwoFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const overrideCustomerEntitlementV2BodyTwoUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');
export const overrideCustomerEntitlementV2BodyThreeFeatureKeyMax = 64;


export const overrideCustomerEntitlementV2BodyThreeFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$');
export const overrideCustomerEntitlementV2BodyThreeFeatureIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const overrideCustomerEntitlementV2BodyThreeUsagePeriodOneIntervalOneOneRegExp = new RegExp('^P(?:\\d+(?:\\.\\d+)?Y)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?W)?(?:\\d+(?:\\.\\d+)?D)?(?:T(?:\\d+(?:\\.\\d+)?H)?(?:\\d+(?:\\.\\d+)?M)?(?:\\d+(?:\\.\\d+)?S)?)?$');


export const OverrideCustomerEntitlementV2Body = zod.union([zod.object({
  "featureKey": zod.coerce.string().min(1).max(overrideCustomerEntitlementV2BodyOneFeatureKeyMax).regex(overrideCustomerEntitlementV2BodyOneFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(overrideCustomerEntitlementV2BodyOneFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "type": zod.enum(['metered']),
  "isSoftLimit": zod.coerce.boolean().default(overrideCustomerEntitlementV2BodyOneIsSoftLimitDefault).describe('If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(overrideCustomerEntitlementV2BodyOneUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').describe('The usage period associated with the entitlement.'),
  "measureUsageFrom": zod.union([zod.enum(['CURRENT_PERIOD_START', 'NOW']).describe('Start of measurement options'),zod.coerce.date().describe('[RFC3339](https:\/\/tools.ietf.org\/html\/rfc3339) formatted date-time string in UTC.')]).describe('Measure usage from').optional().describe('Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.'),
  "preserveOverageAtReset": zod.coerce.boolean().default(overrideCustomerEntitlementV2BodyOnePreserveOverageAtResetDefault).describe('If true, the overage is preserved at reset. If false, the usage is reset to 0.'),
  "issueAfterReset": zod.coerce.number().min(overrideCustomerEntitlementV2BodyOneIssueAfterResetMin).optional().describe('You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.\nIf an amount is specified here, a grant will be created alongside the entitlement with the specified amount.\nThat grant will have it\'s rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.\nManually creating such a grant would mean having the \"amount\", \"minRolloverAmount\", and \"maxRolloverAmount\" fields all be the same.'),
  "issueAfterResetPriority": zod.coerce.number().min(1).max(overrideCustomerEntitlementV2BodyOneIssueAfterResetPriorityMax).default(overrideCustomerEntitlementV2BodyOneIssueAfterResetPriorityDefault).describe('Defines the grant priority for the default grant.'),
  "issue": zod.object({
  "amount": zod.coerce.number().min(overrideCustomerEntitlementV2BodyOneIssueOneAmountMin).describe('The initial grant amount'),
  "priority": zod.coerce.number().min(1).max(overrideCustomerEntitlementV2BodyOneIssueOnePriorityMax).default(overrideCustomerEntitlementV2BodyOneIssueOnePriorityDefault).describe('The priority of the issue after reset')
}).describe('Issue after reset').optional().describe('Issue after reset'),
  "grants": zod.array(zod.object({
  "amount": zod.coerce.number().min(overrideCustomerEntitlementV2BodyOneGrantsItemAmountMin).describe('The amount to grant. Should be a positive number.'),
  "priority": zod.coerce.number().min(1).max(overrideCustomerEntitlementV2BodyOneGrantsItemPriorityMax).optional().describe('The priority of the grant. Grants with higher priority are applied first.\nPriority is a positive decimal numbers. With lower numbers indicating higher importance.\nFor example, a priority of 1 is more urgent than a priority of 2.\nWhen there are several grants available for the same subject, the system selects the grant with the highest priority.\nIn cases where grants share the same priority level, the grant closest to its expiration will be used first.\nIn the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.'),
  "effectiveAt": zod.coerce.date().describe('Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).'),
  "minRolloverAmount": zod.coerce.number().default(overrideCustomerEntitlementV2BodyOneGrantsItemMinRolloverAmountDefault).describe('Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('The grant metadata.'),
  "recurrence": zod.object({
  "interval": zod.union([zod.coerce.string().regex(overrideCustomerEntitlementV2BodyOneGrantsItemRecurrenceOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The subject of the grant.'),
  "maxRolloverAmount": zod.coerce.number().optional().describe('Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset. The default value equals grant amount.\nBalance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))'),
  "expiration": zod.object({
  "duration": zod.enum(['HOUR', 'DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The expiration duration enum').describe('The unit of time for the expiration period.'),
  "count": zod.coerce.number().min(1).max(overrideCustomerEntitlementV2BodyOneGrantsItemExpirationOneCountMax).describe('The number of time units in the expiration period.')
}).describe('The grant expiration definition').optional().describe('The grant expiration definition. If no expiration is provided, the grant can be active indefinitely.'),
  "annotations": zod.record(zod.string(), zod.unknown()).describe('Set of key-value pairs managed by the system. Cannot be modified by user.').optional().describe('Grant annotations')
}).describe('The grant creation input.')).optional().describe('Grants')
}).describe('Create inputs for metered entitlement'),zod.object({
  "featureKey": zod.coerce.string().min(1).max(overrideCustomerEntitlementV2BodyTwoFeatureKeyMax).regex(overrideCustomerEntitlementV2BodyTwoFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(overrideCustomerEntitlementV2BodyTwoFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(overrideCustomerEntitlementV2BodyTwoUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The usage period associated with the entitlement.'),
  "type": zod.enum(['static']),
  "config": zod.coerce.string().describe('The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.')
}).describe('Create inputs for static entitlement'),zod.object({
  "featureKey": zod.coerce.string().min(1).max(overrideCustomerEntitlementV2BodyThreeFeatureKeyMax).regex(overrideCustomerEntitlementV2BodyThreeFeatureKeyRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "featureId": zod.coerce.string().regex(overrideCustomerEntitlementV2BodyThreeFeatureIdRegExp).optional().describe('The feature the subject is entitled to use.\nEither featureKey or featureId is required.'),
  "metadata": zod.record(zod.string(), zod.coerce.string()).describe('Set of key-value pairs.\nMetadata can be used to store additional information about a resource.').optional().describe('Additional metadata for the feature.'),
  "usagePeriod": zod.object({
  "interval": zod.union([zod.coerce.string().regex(overrideCustomerEntitlementV2BodyThreeUsagePeriodOneIntervalOneOneRegExp),zod.enum(['DAY', 'WEEK', 'MONTH', 'YEAR']).describe('The unit of time for the interval.\nOne of: `day`, `week`, `month`, or `year`.')]).describe('Period duration for the recurrence').describe('The unit of time for the interval.'),
  "anchor": zod.coerce.date().optional().describe('A date-time anchor to base the recurring period on.')
}).describe('Recurring period with an interval and an anchor.').optional().describe('The usage period associated with the entitlement.'),
  "type": zod.enum(['boolean'])
}).describe('Create inputs for boolean entitlement')]).describe('Create inputs for entitlement')


/**
 * Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the customers billing period to enforce usage based on their subscription.

Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.
 * @summary Reset customer entitlement
 */
export const resetCustomerEntitlementUsageV2PathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const resetCustomerEntitlementUsageV2PathCustomerIdOrKeyTwoMax = 256;

export const resetCustomerEntitlementUsageV2PathEntitlementIdOrFeatureKeyMax = 64;


export const resetCustomerEntitlementUsageV2PathEntitlementIdOrFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const ResetCustomerEntitlementUsageV2Params = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(resetCustomerEntitlementUsageV2PathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(resetCustomerEntitlementUsageV2PathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')]),
  "entitlementIdOrFeatureKey": zod.coerce.string().min(1).max(resetCustomerEntitlementUsageV2PathEntitlementIdOrFeatureKeyMax).regex(resetCustomerEntitlementUsageV2PathEntitlementIdOrFeatureKeyRegExp)
})

export const ResetCustomerEntitlementUsageV2Body = zod.object({
  "effectiveAt": zod.coerce.date().optional().describe('The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.'),
  "retainAnchor": zod.coerce.boolean().optional().describe('Determines whether the usage period anchor is retained or reset to the effectiveAt time.\n- If true, the usage period anchor is retained.\n- If false, the usage period anchor is reset to the effectiveAt time.'),
  "preserveOverage": zod.coerce.boolean().optional().describe('Determines whether the overage is preserved or forgiven, overriding the entitlement\'s default behavior.\n- If true, the overage is preserved.\n- If false, the overage is forgiven.')
}).describe('Reset parameters')


/**
 * Checks customer access to a given feature (by key). All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
 * @summary Get customer entitlement value
 */
export const getCustomerEntitlementValueV2PathCustomerIdOrKeyOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const getCustomerEntitlementValueV2PathCustomerIdOrKeyTwoMax = 256;

export const getCustomerEntitlementValueV2PathEntitlementIdOrFeatureKeyMax = 64;


export const getCustomerEntitlementValueV2PathEntitlementIdOrFeatureKeyRegExp = new RegExp('^[a-z0-9]+(?:_[a-z0-9]+)\*$|^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetCustomerEntitlementValueV2Params = zod.object({
  "customerIdOrKey": zod.union([zod.coerce.string().regex(getCustomerEntitlementValueV2PathCustomerIdOrKeyOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(getCustomerEntitlementValueV2PathCustomerIdOrKeyTwoMax).describe('ExternalKey is a looser version of key.')]),
  "entitlementIdOrFeatureKey": zod.coerce.string().min(1).max(getCustomerEntitlementValueV2PathEntitlementIdOrFeatureKeyMax).regex(getCustomerEntitlementValueV2PathEntitlementIdOrFeatureKeyRegExp)
})

export const GetCustomerEntitlementValueV2QueryParams = zod.object({
  "time": zod.coerce.date().optional()
})


/**
 * List all entitlements for all the customers and features. This endpoint is intended for administrative purposes only.
To fetch the entitlements of a specific subject please use the /api/v2/customers/{customerIdOrKey}/entitlements endpoint.
 * @summary List all entitlements
 */
export const listEntitlementsV2QueryExcludeInactiveDefault = false;export const listEntitlementsV2QueryPageDefault = 1;

export const listEntitlementsV2QueryPageSizeDefault = 100;
export const listEntitlementsV2QueryPageSizeMax = 1000;

export const listEntitlementsV2QueryOffsetDefault = 0;
export const listEntitlementsV2QueryOffsetMin = 0;

export const listEntitlementsV2QueryLimitDefault = 100;
export const listEntitlementsV2QueryLimitMax = 1000;



export const ListEntitlementsV2QueryParams = zod.object({
  "feature": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple features.\n\nUsage: `?feature=feature-1&feature=feature-2`'),
  "customerKeys": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple customers.\n\nUsage: `?customerKeys=customer-1&customerKeys=customer-3`'),
  "customerIds": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple customers.\n\nUsage: `?customerIds=01K4WAQ0J99ZZ0MD75HXR112H8&customerIds=01K4WAQ0J99ZZ0MD75HXR112H9`'),
  "entitlementType": zod.array(zod.enum(['metered', 'boolean', 'static']).describe('Type of the entitlement.')).optional().describe('Filtering by multiple entitlement types.\n\nUsage: `?entitlementType=metered&entitlementType=boolean`'),
  "excludeInactive": zod.coerce.boolean().default(listEntitlementsV2QueryExcludeInactiveDefault).describe('Exclude inactive entitlements in the response (those scheduled for later or earlier)'),
  "page": zod.coerce.number().min(1).default(listEntitlementsV2QueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listEntitlementsV2QueryPageSizeMax).default(listEntitlementsV2QueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "offset": zod.coerce.number().min(listEntitlementsV2QueryOffsetMin).default(listEntitlementsV2QueryOffsetDefault).describe('Number of items to skip.\n\nDefault is 0.'),
  "limit": zod.coerce.number().min(1).max(listEntitlementsV2QueryLimitMax).default(listEntitlementsV2QueryLimitDefault).describe('Number of items to return.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['createdAt', 'updatedAt']).optional().describe('The order by field.')
})


/**
 * Get entitlement by ID.
 * @summary Get entitlement by ID
 */
export const getEntitlementByIdV2PathEntitlementIdRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');


export const GetEntitlementByIdV2Params = zod.object({
  "entitlementId": zod.coerce.string().regex(getEntitlementByIdV2PathEntitlementIdRegExp)
})


/**
 * List ingested events with advanced filtering and cursor pagination.
 * @summary List ingested events
 */
export const listEventsV2QueryLimitDefault = 100;
export const listEventsV2QueryLimitMax = 100;

export const listEventsV2QueryClientIdMax = 36;



export const ListEventsV2QueryParams = zod.object({
  "cursor": zod.coerce.string().optional().describe('The cursor after which to start the pagination.'),
  "limit": zod.coerce.number().min(1).max(listEventsV2QueryLimitMax).default(listEventsV2QueryLimitDefault).describe('The limit of the pagination.'),
  "clientId": zod.coerce.string().min(1).max(listEventsV2QueryClientIdMax).optional().describe('Client ID\nUseful to track progress of a query.')
})


/**
 * List all grants for all the customers and entitlements. This endpoint is intended for administrative purposes only.
To fetch the grants of a specific entitlement please use the /api/v2/customers/{customerIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants endpoint.
If page is provided that takes precedence and the paginated response is returned.
 * @summary List grants
 */
export const listGrantsV2QueryCustomerItemOneRegExp = new RegExp('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$');
export const listGrantsV2QueryCustomerItemTwoMax = 256;

export const listGrantsV2QueryIncludeDeletedDefault = false;export const listGrantsV2QueryPageDefault = 1;

export const listGrantsV2QueryPageSizeDefault = 100;
export const listGrantsV2QueryPageSizeMax = 1000;

export const listGrantsV2QueryOffsetDefault = 0;
export const listGrantsV2QueryOffsetMin = 0;

export const listGrantsV2QueryLimitDefault = 100;
export const listGrantsV2QueryLimitMax = 1000;



export const ListGrantsV2QueryParams = zod.object({
  "feature": zod.array(zod.coerce.string()).optional().describe('Filtering by multiple features.\n\nUsage: `?feature=feature-1&feature=feature-2`'),
  "customer": zod.array(zod.union([zod.coerce.string().regex(listGrantsV2QueryCustomerItemOneRegExp).describe('ULID (Universally Unique Lexicographically Sortable Identifier).'),zod.coerce.string().min(1).max(listGrantsV2QueryCustomerItemTwoMax).describe('ExternalKey is a looser version of key.')]).describe('ULID (Universally Unique Lexicographically Sortable Identifier) or external unique key.')).optional().describe('Filtering by multiple customers (either by ID or key).\n\nUsage: `?customer=customer-1&customer=customer-2`'),
  "includeDeleted": zod.coerce.boolean().default(listGrantsV2QueryIncludeDeletedDefault).describe('Include deleted'),
  "page": zod.coerce.number().min(1).default(listGrantsV2QueryPageDefault).describe('Page index.\n\nDefault is 1.'),
  "pageSize": zod.coerce.number().min(1).max(listGrantsV2QueryPageSizeMax).default(listGrantsV2QueryPageSizeDefault).describe('The maximum number of items per page.\n\nDefault is 100.'),
  "offset": zod.coerce.number().min(listGrantsV2QueryOffsetMin).default(listGrantsV2QueryOffsetDefault).describe('Number of items to skip.\n\nDefault is 0.'),
  "limit": zod.coerce.number().min(1).max(listGrantsV2QueryLimitMax).default(listGrantsV2QueryLimitDefault).describe('Number of items to return.\n\nDefault is 100.'),
  "order": zod.enum(['ASC', 'DESC']).optional().describe('The order direction.'),
  "orderBy": zod.enum(['id', 'createdAt', 'updatedAt']).optional().describe('The order by field.')
})
