// Package openmeter provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package openmeter

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/cloudevents/sdk-go/v2/event"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	"github.com/openmeterio/openmeter/pkg/models"
)

const (
	CloudCookieAuthScopes      = "CloudCookieAuth.Scopes"
	CloudPortalTokenAuthScopes = "CloudPortalTokenAuth.Scopes"
	CloudTokenAuthScopes       = "CloudTokenAuth.Scopes"
	PortalTokenAuthScopes      = "PortalTokenAuth.Scopes"
)

// Defines values for AppCapabilityType.
const (
	CalculateTax     AppCapabilityType = "calculateTax"
	CollectPayments  AppCapabilityType = "collectPayments"
	InvoiceCustomers AppCapabilityType = "invoiceCustomers"
	ReportEvents     AppCapabilityType = "reportEvents"
	ReportUsage      AppCapabilityType = "reportUsage"
)

// Defines values for AppRequirements.
const (
	CustomerCountryCode              AppRequirements = "customer.countryCode"
	CustomerExternalStripeCustomerId AppRequirements = "customer.external.stripeCustomerId"
)

// Defines values for CheckoutSessionUIMode.
const (
	Embedded CheckoutSessionUIMode = "embedded"
	Hosted   CheckoutSessionUIMode = "hosted"
)

// Defines values for EntitlementBooleanCreateInputsType.
const (
	Boolean EntitlementBooleanCreateInputsType = "boolean"
)

// Defines values for EntitlementMeteredType.
const (
	EntitlementMeteredTypeMetered EntitlementMeteredType = "metered"
)

// Defines values for EntitlementMeteredCreateInputsType.
const (
	EntitlementMeteredCreateInputsTypeMetered EntitlementMeteredCreateInputsType = "metered"
)

// Defines values for EntitlementOrderBy.
const (
	EntitlementOrderByCreatedAt EntitlementOrderBy = "createdAt"
	EntitlementOrderByUpdatedAt EntitlementOrderBy = "updatedAt"
)

// Defines values for EntitlementStaticType.
const (
	EntitlementStaticTypeStatic EntitlementStaticType = "static"
)

// Defines values for EntitlementStaticCreateInputsType.
const (
	EntitlementStaticCreateInputsTypeStatic EntitlementStaticCreateInputsType = "static"
)

// Defines values for ExpirationDuration.
const (
	ExpirationDurationDAY   ExpirationDuration = "DAY"
	ExpirationDurationHOUR  ExpirationDuration = "HOUR"
	ExpirationDurationMONTH ExpirationDuration = "MONTH"
	ExpirationDurationWEEK  ExpirationDuration = "WEEK"
	ExpirationDurationYEAR  ExpirationDuration = "YEAR"
)

// Defines values for FeatureOrderBy.
const (
	FeatureOrderByCreatedAt FeatureOrderBy = "createdAt"
	FeatureOrderById        FeatureOrderBy = "id"
	FeatureOrderByUpdatedAt FeatureOrderBy = "updatedAt"
)

// Defines values for GrantOrderBy.
const (
	GrantOrderByCreatedAt GrantOrderBy = "createdAt"
	GrantOrderById        GrantOrderBy = "id"
	GrantOrderByUpdatedAt GrantOrderBy = "updatedAt"
)

// Defines values for MeasureUsageFromEnum.
const (
	CURRENTPERIODSTART MeasureUsageFromEnum = "CURRENT_PERIOD_START"
	NOW                MeasureUsageFromEnum = "NOW"
)

// Defines values for NotificationChannelOrderBy.
const (
	NotificationChannelOrderByCreatedAt NotificationChannelOrderBy = "createdAt"
	NotificationChannelOrderById        NotificationChannelOrderBy = "id"
	NotificationChannelOrderByType      NotificationChannelOrderBy = "type"
	NotificationChannelOrderByUpdatedAt NotificationChannelOrderBy = "updatedAt"
)

// Defines values for NotificationChannelType.
const (
	NotificationChannelTypeWEBHOOK NotificationChannelType = "WEBHOOK"
)

// Defines values for NotificationChannelWebhookType.
const (
	NotificationChannelWebhookTypeWEBHOOK NotificationChannelWebhookType = "WEBHOOK"
)

// Defines values for NotificationChannelWebhookCreateRequestType.
const (
	WEBHOOK NotificationChannelWebhookCreateRequestType = "WEBHOOK"
)

// Defines values for NotificationEventBalanceThresholdPayloadType.
const (
	NotificationEventBalanceThresholdPayloadTypeEntitlementsBalanceThreshold NotificationEventBalanceThresholdPayloadType = "entitlements.balance.threshold"
)

// Defines values for NotificationEventDeliveryStatusState.
const (
	FAILED  NotificationEventDeliveryStatusState = "FAILED"
	PENDING NotificationEventDeliveryStatusState = "PENDING"
	SENDING NotificationEventDeliveryStatusState = "SENDING"
	SUCCESS NotificationEventDeliveryStatusState = "SUCCESS"
)

// Defines values for NotificationEventOrderBy.
const (
	NotificationEventOrderByCreatedAt NotificationEventOrderBy = "createdAt"
	NotificationEventOrderById        NotificationEventOrderBy = "id"
)

// Defines values for NotificationEventType.
const (
	NotificationEventTypeEntitlementsBalanceThreshold NotificationEventType = "entitlements.balance.threshold"
)

// Defines values for NotificationRuleBalanceThresholdType.
const (
	NotificationRuleBalanceThresholdTypeEntitlementsBalanceThreshold NotificationRuleBalanceThresholdType = "entitlements.balance.threshold"
)

// Defines values for NotificationRuleBalanceThresholdCreateRequestType.
const (
	NotificationRuleBalanceThresholdCreateRequestTypeEntitlementsBalanceThreshold NotificationRuleBalanceThresholdCreateRequestType = "entitlements.balance.threshold"
)

// Defines values for NotificationRuleBalanceThresholdValueType.
const (
	NUMBER  NotificationRuleBalanceThresholdValueType = "NUMBER"
	PERCENT NotificationRuleBalanceThresholdValueType = "PERCENT"
)

// Defines values for NotificationRuleOrderBy.
const (
	NotificationRuleOrderByCreatedAt NotificationRuleOrderBy = "createdAt"
	NotificationRuleOrderById        NotificationRuleOrderBy = "id"
	NotificationRuleOrderByType      NotificationRuleOrderBy = "type"
	NotificationRuleOrderByUpdatedAt NotificationRuleOrderBy = "updatedAt"
)

// Defines values for OAuth2AuthorizationCodeGrantErrorType.
const (
	AccessDenied            OAuth2AuthorizationCodeGrantErrorType = "access_denied"
	InvalidRequest          OAuth2AuthorizationCodeGrantErrorType = "invalid_request"
	InvalidScope            OAuth2AuthorizationCodeGrantErrorType = "invalid_scope"
	ServerError             OAuth2AuthorizationCodeGrantErrorType = "server_error"
	TemporarilyUnavailable  OAuth2AuthorizationCodeGrantErrorType = "temporarily_unavailable"
	UnauthorizedClient      OAuth2AuthorizationCodeGrantErrorType = "unauthorized_client"
	UnsupportedResponseType OAuth2AuthorizationCodeGrantErrorType = "unsupported_response_type"
)

// Defines values for OpenMeterAppAppStatus.
const (
	Ready        OpenMeterAppAppStatus = "ready"
	Unauthorized OpenMeterAppAppStatus = "unauthorized"
)

// Defines values for OpenMeterAppAppType.
const (
	OpenMeterAppAppTypeStripe OpenMeterAppAppType = "stripe"
)

// Defines values for OpenMeterAppStripePaymentIntentStatus.
const (
	Canceled              OpenMeterAppStripePaymentIntentStatus = "canceled"
	Processing            OpenMeterAppStripePaymentIntentStatus = "processing"
	RequiresAction        OpenMeterAppStripePaymentIntentStatus = "requires_action"
	RequiresConfirmation  OpenMeterAppStripePaymentIntentStatus = "requires_confirmation"
	RequiresPaymentMethod OpenMeterAppStripePaymentIntentStatus = "requires_payment_method"
	Succeeded             OpenMeterAppStripePaymentIntentStatus = "succeeded"
)

// Defines values for Order.
const (
	SortOrderASC  Order = "ASC"
	SortOrderDESC Order = "DESC"
)

// Defines values for RecurringPeriodInterval.
const (
	RecurringPeriodIntervalDAY   RecurringPeriodInterval = "DAY"
	RecurringPeriodIntervalMONTH RecurringPeriodInterval = "MONTH"
	RecurringPeriodIntervalWEEK  RecurringPeriodInterval = "WEEK"
	RecurringPeriodIntervalYEAR  RecurringPeriodInterval = "YEAR"
)

// Defines values for StripeAppType.
const (
	StripeAppTypeStripe StripeAppType = "stripe"
)

// Defines values for SvixOperationalWebhookRequestType.
const (
	EndpointCreated         SvixOperationalWebhookRequestType = "endpoint.created"
	EndpointDeleted         SvixOperationalWebhookRequestType = "endpoint.deleted"
	EndpointDisabled        SvixOperationalWebhookRequestType = "endpoint.disabled"
	EndpointUpdated         SvixOperationalWebhookRequestType = "endpoint.updated"
	MessageAttemptExhausted SvixOperationalWebhookRequestType = "message.attempt.exhausted"
	MessageAttemptFailing   SvixOperationalWebhookRequestType = "message.attempt.failing"
	MessageAttemptRecovered SvixOperationalWebhookRequestType = "message.attempt.recovered"
)

// Address Address
type Address struct {
	City *string `json:"city,omitempty"`

	// Country [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.
	// Custom two-letter country codes are also supported for convenience.
	Country     *CountryCode `json:"country,omitempty"`
	Line1       *string      `json:"line1,omitempty"`
	Line2       *string      `json:"line2,omitempty"`
	PhoneNumber *string      `json:"phoneNumber,omitempty"`
	PostalCode  *string      `json:"postalCode,omitempty"`
	State       *string      `json:"state,omitempty"`
}

// Annotations Set of key-value pairs managed by the system. Cannot be modified by user.
type Annotations map[string]interface{}

// App A installed Stripe app object.
type App = StripeApp

// AppBase Abstract base model for installed apps.
//
// Represent an app installed to the organization.
// This is an actual instance, with its own configuration and credentials.
type AppBase struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id *string `json:"id,omitempty"`

	// Listing The marketplace listing that this installed app is based on.
	Listing *MarketplaceListing `json:"listing,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Status Status of the app connection.
	Status *OpenMeterAppAppStatus `json:"status,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// AppCapability App capability.
//
// Capabilities only exist in config so they don't extend the Resource model.
type AppCapability struct {
	// Description The capability description.
	Description string `json:"description"`

	// Key Key
	Key string `json:"key"`

	// Name The capability name.
	Name string `json:"name"`

	// Requirements The capability requirements.
	Requirements *[]AppRequirements `json:"requirements,omitempty"`

	// Type The capability type.
	Type AppCapabilityType `json:"type"`
}

// AppCapabilityType App capability type.
type AppCapabilityType string

// AppList A page of results.
type AppList struct {
	// Items The items in the page.
	Items []App `json:"items"`

	// Page The page number.
	Page int `json:"page"`

	// PageSize The number of items in the page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// AppRequirements App requirements.
type AppRequirements string

// BadRequestProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type BadRequestProblemResponse = UnexpectedProblemResponse

// BalanceHistoryWindow The balance history window.
type BalanceHistoryWindow struct {
	// BalanceAtStart The entitlement balance at the start of the period.
	BalanceAtStart *float64 `json:"balanceAtStart,omitempty"`

	// Period A period with a start and end time.
	Period Period `json:"period"`

	// Usage The total usage of the feature in the period.
	Usage *float64 `json:"usage,omitempty"`
}

// CheckoutSessionCustomTextAfterSubmitParams Stripe CheckoutSession.custom_text
type CheckoutSessionCustomTextAfterSubmitParams struct {
	AfterSubmit *struct {
		Message *string `json:"message,omitempty"`
	} `json:"afterSubmit,omitempty"`
	ShippingAddress *struct {
		Message *string `json:"message,omitempty"`
	} `json:"shippingAddress,omitempty"`
	Submit *struct {
		Message *string `json:"message,omitempty"`
	} `json:"submit,omitempty"`
	TermsOfServiceAcceptance *struct {
		Message *string `json:"message,omitempty"`
	} `json:"termsOfServiceAcceptance,omitempty"`
}

// CheckoutSessionUIMode Stripe CheckoutSession.ui_mode
type CheckoutSessionUIMode string

// ClientAppStartResponse Response from the client app (OpenMeter backend) to start the OAuth2 flow.
type ClientAppStartResponse struct {
	// Url The URL to start the OAuth2 authorization code grant flow.
	Url string `json:"url"`
}

// ConflictProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type ConflictProblemResponse = UnexpectedProblemResponse

// CountryCode [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.
// Custom two-letter country codes are also supported for convenience.
type CountryCode = string

// CurrencyCode Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.
// Custom three-letter currency codes are also supported for convenience.
type CurrencyCode = string

// Customer A customer object.
type Customer struct {
	// BillingAddress The billing address of the customer.
	// Used for tax and invoicing.
	BillingAddress *Address `json:"billingAddress,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Currency Currency of the customer.
	// Used for billing, tax and invoicing.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// External External mappings for the customer.
	External *CustomerExternalMapping `json:"external,omitempty"`

	// Id A unique identifier for the resource.
	Id *string `json:"id,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PrimaryEmail The primary email address of the customer.
	PrimaryEmail *string `json:"primaryEmail,omitempty"`

	// Timezone Timezone of the customer.
	Timezone *string `json:"timezone,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UsageAttribution Mapping to attribute metered usage to the customer
	UsageAttribution CustomerUsageAttribution `json:"usageAttribution"`
}

// CustomerExternalMapping External mappings for the customer.
type CustomerExternalMapping struct {
	// StripeCustomerId The Stripe customer ID.
	// Mapping to a Stripe Customer object.
	// Required to use Stripe as an invocing provider.
	StripeCustomerId *string `json:"stripeCustomerId,omitempty"`
}

// CustomerIdentifier A unique customer identifier.
type CustomerIdentifier = string

// CustomerList A page of results.
type CustomerList struct {
	// Items The items in the page.
	Items []Customer `json:"items"`

	// Page The page number.
	Page int `json:"page"`

	// PageSize The number of items in the page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// CustomerUsageAttribution Mapping to attribute metered usage to the customer.
// One customer can have multiple subjects,
// but one subject can only belong to one customer.
type CustomerUsageAttribution struct {
	// SubjectKeys The subjects that are attributed to the customer.
	SubjectKeys []string `json:"subjectKeys"`
}

// Entitlement Entitlement templates are used to define the entitlements of a plan.
// Features are omitted from the entitlement template, as they are defined in the rate card.
type Entitlement struct {
	union json.RawMessage
}

// EntitlementBaseTemplate Shared fields of the entitlement templates.
type EntitlementBaseTemplate struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CurrentUsagePeriod The current usage period.
	CurrentUsagePeriod *Period `json:"currentUsagePeriod,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string `json:"subjectKey"`

	// Type The type of the entitlement.
	Type EntitlementType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UsagePeriod The defined usage period of the entitlement
	UsagePeriod *RecurringPeriod `json:"usagePeriod,omitempty"`
}

// EntitlementBoolean Shared fields of the entitlement templates.
type EntitlementBoolean = EntitlementBaseTemplate

// EntitlementBooleanCreateInputs Create inputs for boolean entitlement
type EntitlementBooleanCreateInputs struct {
	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata                          `json:"metadata,omitempty"`
	Type     EntitlementBooleanCreateInputsType `json:"type"`

	// UsagePeriod The usage period associated with the entitlement.
	UsagePeriod *RecurringPeriodCreateInput `json:"usagePeriod,omitempty"`
}

// EntitlementBooleanCreateInputsType defines model for EntitlementBooleanCreateInputs.Type.
type EntitlementBooleanCreateInputsType string

// EntitlementCreateInputs Create inputs for entitlement
type EntitlementCreateInputs struct {
	union json.RawMessage
}

// EntitlementGrant The grant.
type EntitlementGrant struct {
	// Amount The amount to grant. Should be a positive number.
	Amount float64 `json:"amount"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// EffectiveAt Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
	EffectiveAt time.Time `json:"effectiveAt"`

	// EntitlementId The unique entitlement ULID that the grant is associated with.
	EntitlementId *string `json:"entitlementId,omitempty"`

	// Expiration The grant expiration definition
	Expiration ExpirationPeriod `json:"expiration"`

	// ExpiresAt The time the grant expires.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// MaxRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MaxRolloverAmount *float64 `json:"maxRolloverAmount,omitempty"`

	// Metadata The grant metadata.
	Metadata *Metadata `json:"metadata,omitempty"`

	// MinRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MinRolloverAmount *float64 `json:"minRolloverAmount,omitempty"`

	// NextRecurrence The next time the grant will recurr.
	NextRecurrence *time.Time `json:"nextRecurrence,omitempty"`

	// Priority The priority of the grant. Grants with higher priority are applied first.
	// Priority is a positive decimal numbers. With lower numbers indicating higher importance.
	// For example, a priority of 1 is more urgent than a priority of 2.
	// When there are several grants available for the same subject, the system selects the grant with the highest priority.
	// In cases where grants share the same priority level, the grant closest to its expiration will be used first.
	// In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
	Priority *int8 `json:"priority,omitempty"`

	// Recurrence The recurrence period of the grant.
	Recurrence *RecurringPeriod `json:"recurrence,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// VoidedAt The time the grant was voided.
	VoidedAt *time.Time `json:"voidedAt,omitempty"`
}

// EntitlementGrantCreateInput The grant creation input.
type EntitlementGrantCreateInput struct {
	// Amount The amount to grant. Should be a positive number.
	Amount float64 `json:"amount"`

	// EffectiveAt Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
	EffectiveAt time.Time `json:"effectiveAt"`

	// Expiration The grant expiration definition
	Expiration ExpirationPeriod `json:"expiration"`

	// MaxRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MaxRolloverAmount *float64 `json:"maxRolloverAmount,omitempty"`

	// Metadata The grant metadata.
	Metadata *Metadata `json:"metadata,omitempty"`

	// MinRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MinRolloverAmount *float64 `json:"minRolloverAmount,omitempty"`

	// Priority The priority of the grant. Grants with higher priority are applied first.
	// Priority is a positive decimal numbers. With lower numbers indicating higher importance.
	// For example, a priority of 1 is more urgent than a priority of 2.
	// When there are several grants available for the same subject, the system selects the grant with the highest priority.
	// In cases where grants share the same priority level, the grant closest to its expiration will be used first.
	// In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
	Priority *int8 `json:"priority,omitempty"`

	// Recurrence The subject of the grant.
	Recurrence *RecurringPeriodCreateInput `json:"recurrence,omitempty"`
}

// EntitlementMetered Metered entitlements are useful for many different use cases, from setting up usage based access to implementing complex credit systems.
// Access is determined based on feature usage using a balance calculation (the "usage allowance" provided by the issued grants is "burnt down" by the usage).
type EntitlementMetered struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CurrentUsagePeriod The current usage period.
	CurrentUsagePeriod *Period `json:"currentUsagePeriod,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// IsSoftLimit If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
	IsSoftLimit *bool `json:"isSoftLimit,omitempty"`

	// IsUnlimited Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
	// Deprecated:
	IsUnlimited *bool `json:"isUnlimited,omitempty"`

	// IssueAfterReset You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
	// If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
	// That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
	// Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
	IssueAfterReset *float64 `json:"issueAfterReset,omitempty"`

	// IssueAfterResetPriority Defines the grant priority for the default grant.
	IssueAfterResetPriority *uint8 `json:"issueAfterResetPriority,omitempty"`

	// LastReset The time the last reset happened.
	LastReset *time.Time `json:"lastReset,omitempty"`

	// MeasureUsageFrom The time from which usage is measured. If not specified on creation, defaults to entitlement creation time.
	MeasureUsageFrom *time.Time `json:"measureUsageFrom,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// PreserveOverageAtReset If true, the overage is preserved at reset. If false, the usage is reset to 0.
	PreserveOverageAtReset *bool `json:"preserveOverageAtReset,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string                 `json:"subjectKey"`
	Type       EntitlementMeteredType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UsagePeriod THe usage period of the entitlement.
	UsagePeriod *RecurringPeriod `json:"usagePeriod,omitempty"`
}

// EntitlementMeteredType defines model for EntitlementMetered.Type.
type EntitlementMeteredType string

// EntitlementMeteredCreateInputs Create inpurs for metered entitlement
type EntitlementMeteredCreateInputs struct {
	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// IsSoftLimit If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
	IsSoftLimit *bool `json:"isSoftLimit,omitempty"`

	// IsUnlimited Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
	// Deprecated:
	IsUnlimited *bool `json:"isUnlimited,omitempty"`

	// IssueAfterReset You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
	// If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
	// That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
	// Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
	IssueAfterReset *float64 `json:"issueAfterReset,omitempty"`

	// IssueAfterResetPriority Defines the grant priority for the default grant.
	IssueAfterResetPriority *uint8 `json:"issueAfterResetPriority,omitempty"`

	// MeasureUsageFrom Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.
	MeasureUsageFrom *MeasureUsageFrom `json:"measureUsageFrom,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// PreserveOverageAtReset If true, the overage is preserved at reset. If false, the usage is reset to 0.
	PreserveOverageAtReset *bool                              `json:"preserveOverageAtReset,omitempty"`
	Type                   EntitlementMeteredCreateInputsType `json:"type"`

	// UsagePeriod The usage period associated with the entitlement.
	UsagePeriod RecurringPeriodCreateInput `json:"usagePeriod"`
}

// EntitlementMeteredCreateInputsType defines model for EntitlementMeteredCreateInputs.Type.
type EntitlementMeteredCreateInputsType string

// EntitlementOrderBy Order by options for entitlements.
type EntitlementOrderBy string

// EntitlementPaginatedResponse Paginated response
type EntitlementPaginatedResponse struct {
	// Items The items in the current page.
	Items []Entitlement `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// EntitlementStatic A static entitlement.
type EntitlementStatic struct {
	// Config The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
	Config json.RawMessage `json:"config"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CurrentUsagePeriod The current usage period.
	CurrentUsagePeriod *Period `json:"currentUsagePeriod,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string                `json:"subjectKey"`
	Type       EntitlementStaticType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UsagePeriod The defined usage period of the entitlement
	UsagePeriod *RecurringPeriod `json:"usagePeriod,omitempty"`
}

// EntitlementStaticType defines model for EntitlementStatic.Type.
type EntitlementStaticType string

// EntitlementStaticCreateInputs Create inputs for static entitlement
type EntitlementStaticCreateInputs struct {
	// Config The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
	Config json.RawMessage `json:"config"`

	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata                         `json:"metadata,omitempty"`
	Type     EntitlementStaticCreateInputsType `json:"type"`

	// UsagePeriod The usage period associated with the entitlement.
	UsagePeriod *RecurringPeriodCreateInput `json:"usagePeriod,omitempty"`
}

// EntitlementStaticCreateInputsType defines model for EntitlementStaticCreateInputs.Type.
type EntitlementStaticCreateInputsType string

// EntitlementType Type of the entitlement.
type EntitlementType = string

// EntitlementValue Entitlements are the core of OpenMeter access management. They define access to features for subjects. Entitlements can be metered, boolean, or static.
type EntitlementValue struct {
	// Balance Only available for metered entitlements. Metered entitlements are built around a balance calculation where feature usage is deducted from the issued grants. Balance represents the remaining balance of the entitlement, it's value never turns negative.
	Balance *float64 `json:"balance,omitempty"`

	// Config Only available for static entitlements. The JSON parsable config of the entitlement.
	Config *string `json:"config,omitempty"`

	// HasAccess Whether the subject has access to the feature. Shared accross all entitlement types.
	HasAccess *bool `json:"hasAccess,omitempty"`

	// Overage Only available for metered entitlements. Overage represents the usage that wasn't covered by grants, e.g. if the subject had a total feature usage of 100 in the period but they were only granted 80, there would be 20 overage.
	Overage *float64 `json:"overage,omitempty"`

	// Usage Only available for metered entitlements. Returns the total feature usage in the current period.
	Usage *float64 `json:"usage,omitempty"`
}

// Event CloudEvents Specification JSON Schema
type Event = event.Event

// ExpirationDuration The expiration duration enum
type ExpirationDuration string

// ExpirationPeriod The grant expiration definition
type ExpirationPeriod struct {
	// Count The number of time units in the expiration period.
	Count int `json:"count"`

	// Duration The unit of time for the expiration period.
	Duration ExpirationDuration `json:"duration"`
}

// Feature Represents a feature that can be enabled or disabled for a plan.
// Used both for product catalog and entitlements.
type Feature struct {
	// ArchivedAt Timestamp of when the resource was archived.
	ArchivedAt *time.Time `json:"archivedAt,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// Key A key is a unique string that is used to identify a resource.
	Key      string    `json:"key"`
	Metadata *Metadata `json:"metadata,omitempty"`

	// MeterGroupByFilters Optional meter group by filters.
	// Useful if the meter scope is broader than what feature tracks.
	// Example scenario would be a meter tracking all token use with groupBy fields for the model,
	// then the feature could filter for model=gpt-4.
	MeterGroupByFilters *map[string]string `json:"meterGroupByFilters,omitempty"`

	// MeterSlug A key is a unique string that is used to identify a resource.
	MeterSlug *string `json:"meterSlug,omitempty"`
	Name      string  `json:"name"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// FeatureCreateInputs Represents a feature that can be enabled or disabled for a plan.
// Used both for product catalog and entitlements.
type FeatureCreateInputs struct {
	// Key A key is a unique string that is used to identify a resource.
	Key      string    `json:"key"`
	Metadata *Metadata `json:"metadata,omitempty"`

	// MeterGroupByFilters Optional meter group by filters.
	// Useful if the meter scope is broader than what feature tracks.
	// Example scenario would be a meter tracking all token use with groupBy fields for the model,
	// then the feature could filter for model=gpt-4.
	MeterGroupByFilters *map[string]string `json:"meterGroupByFilters,omitempty"`

	// MeterSlug A key is a unique string that is used to identify a resource.
	MeterSlug *string `json:"meterSlug,omitempty"`
	Name      string  `json:"name"`
}

// FeatureMeta Limited representation of a feature resource which includes only its unique identifiers (id, key).
type FeatureMeta struct {
	// Id Unique identifier of a feature.
	Id string `json:"id"`

	// Key The key is an immutable unique identifier of the feature used throughout the API,
	// for example when interacting with a subject's entitlements.
	Key string `json:"key"`
}

// FeatureOrderBy Order by options for features.
type FeatureOrderBy string

// FeaturePaginatedResponse Paginated response
type FeaturePaginatedResponse struct {
	// Items The items in the current page.
	Items []Feature `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// ForbiddenProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type ForbiddenProblemResponse = UnexpectedProblemResponse

// GrantBurnDownHistorySegment A segment of the grant burn down history.
//
// A given segment represents the usage of a grant between events that changed either the grant burn down priority order or the usag period.
type GrantBurnDownHistorySegment struct {
	// BalanceAtEnd The entitlement balance at the end of the period.
	BalanceAtEnd *float64 `json:"balanceAtEnd,omitempty"`

	// BalanceAtStart entitlement balance at the start of the period.
	BalanceAtStart *float64 `json:"balanceAtStart,omitempty"`

	// GrantBalancesAtEnd The balance breakdown of each active grant at the end of the period: GrantID: Balance
	GrantBalancesAtEnd *map[string]float64 `json:"grantBalancesAtEnd,omitempty"`

	// GrantBalancesAtStart The balance breakdown of each active grant at the start of the period: GrantID: Balance
	GrantBalancesAtStart *map[string]float64 `json:"grantBalancesAtStart,omitempty"`

	// GrantUsages Which grants were actually burnt down in the period and by what amount.
	GrantUsages *[]GrantUsageRecord `json:"grantUsages,omitempty"`

	// Overage Overuse that wasn't covered by grants.
	Overage *float64 `json:"overage,omitempty"`

	// Period The period of the segment.
	Period Period `json:"period"`

	// Usage The total usage of the grant in the period.
	Usage *float64 `json:"usage,omitempty"`
}

// GrantOrderBy Order by options for grants.
type GrantOrderBy string

// GrantPaginatedResponse Paginated response
type GrantPaginatedResponse struct {
	// Items The items in the current page.
	Items []EntitlementGrant `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// GrantUsageRecord Usage Record
type GrantUsageRecord struct {
	// GrantId The id of the grant
	GrantId string `json:"grantId"`

	// Usage The usage in the period
	Usage float64 `json:"usage"`
}

// IngestedEvent An ingested event with optional validation error.
type IngestedEvent struct {
	// Event CloudEvents Specification JSON Schema
	Event Event `json:"event"`

	// IngestedAt The date and time the event was ingested.
	IngestedAt time.Time `json:"ingestedAt"`

	// StoredAt The date and time the event was stored.
	StoredAt time.Time `json:"storedAt"`

	// ValidationError The validation error if the event failed validation.
	ValidationError *string `json:"validationError,omitempty"`
}

// InternalServerErrorProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type InternalServerErrorProblemResponse = UnexpectedProblemResponse

// ListingList A page of results.
type ListingList struct {
	// Items The items in the page.
	Items []MarketplaceListing `json:"items"`

	// Page The page number.
	Page int `json:"page"`

	// PageSize The number of items in the page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// MarketplaceListing A marketplace listing.
// Represent an available app in the app marketplace that can be installed to the organization.
//
// Marketplace apps only exist in config so they don't extend the Resource model.
type MarketplaceListing struct {
	// Capabilities The app's capabilities.
	Capabilities []AppCapability `json:"capabilities"`

	// Description The app's description.
	Description string `json:"description"`

	// IconUrl The app's icon URL.
	IconUrl string `json:"iconUrl"`

	// Name The app's name.
	Name string `json:"name"`

	// Type The app's type
	Type OpenMeterAppAppType `json:"type"`
}

// MeasureUsageFrom Measure usage from
type MeasureUsageFrom struct {
	union json.RawMessage
}

// MeasureUsageFromEnum Start of measurement options
type MeasureUsageFromEnum string

// MeasureUsageFromTime [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
type MeasureUsageFromTime = time.Time

// Metadata Set of key-value pairs.
// Metadata can be used to store additional information about a resource.
type Metadata = map[string]string

// Meter A meter is a configuration that defines how to match and aggregate events.
type Meter = models.Meter

// MeterAggregation The aggregation type to use for the meter.
type MeterAggregation = models.MeterAggregation

// MeterQueryResult The result of a meter query.
type MeterQueryResult struct {
	Data []MeterQueryRow `json:"data"`

	// From [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	From *time.Time `json:"from,omitempty"`

	// To [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	To *time.Time `json:"to,omitempty"`

	// WindowSize Aggregation window size.
	WindowSize *WindowSize `json:"windowSize,omitempty"`
}

// MeterQueryRow A row in the result of a meter query.
type MeterQueryRow = models.MeterQueryRow

// NotFoundProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type NotFoundProblemResponse = UnexpectedProblemResponse

// NotificationChannel Notification channel with webhook type.
type NotificationChannel = NotificationChannelWebhook

// NotificationChannelCreateRequest Notification channel with webhook type.
type NotificationChannelCreateRequest = NotificationChannelWebhookCreateRequest

// NotificationChannelMeta Metadata only fields of a notification channel.
type NotificationChannelMeta struct {
	// Id Identifies the notification channel.
	Id *string `json:"id,omitempty"`

	// Type Notification channel type.
	Type *NotificationChannelType `json:"type,omitempty"`
}

// NotificationChannelOrderBy Order by options for notification channels.
type NotificationChannelOrderBy string

// NotificationChannelPaginatedResponse Paginated response
type NotificationChannelPaginatedResponse struct {
	// Items The items in the current page.
	Items []NotificationChannel `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// NotificationChannelType Type of the notification channel.
type NotificationChannelType string

// NotificationChannelWebhook Notification channel with webhook type.
type NotificationChannelWebhook struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CustomHeaders Custom HTTP headers sent as part of the webhook request.
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Disabled Whether the channel is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Id Identifies the notification channel.
	Id *string `json:"id,omitempty"`

	// Name User friendly name of the channel.
	Name string `json:"name"`

	// SigningSecret Signing secret used for webhook request validation on the receiving end.
	//
	// Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
	SigningSecret *string `json:"signingSecret,omitempty"`

	// Type Notification channel type.
	Type NotificationChannelWebhookType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Url Webhook URL where the notification is sent.
	Url string `json:"url"`
}

// NotificationChannelWebhookType Notification channel type.
type NotificationChannelWebhookType string

// NotificationChannelWebhookCreateRequest Notification channel with webhook type.
type NotificationChannelWebhookCreateRequest struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CustomHeaders Custom HTTP headers sent as part of the webhook request.
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Disabled Whether the channel is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Id Identifies the notification channel.
	Id *string `json:"id,omitempty"`

	// Name User friendly name of the channel.
	Name string `json:"name"`

	// SigningSecret Signing secret used for webhook request validation on the receiving end.
	//
	// Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
	SigningSecret *string `json:"signingSecret,omitempty"`

	// Type Notification channel type.
	Type NotificationChannelWebhookCreateRequestType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Url Webhook URL where the notification is sent.
	Url string `json:"url"`
}

// NotificationChannelWebhookCreateRequestType Notification channel type.
type NotificationChannelWebhookCreateRequestType string

// NotificationEvent Type of the notification event.
type NotificationEvent struct {
	// Annotations Set of key-value pairs managed by the system. Cannot be modified by user.
	Annotations *Annotations `json:"annotations,omitempty"`

	// CreatedAt Timestamp when the notification event was created in RFC 3339 format.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DeliveryStatus The delivery status of the notification event.
	DeliveryStatus *[]NotificationEventDeliveryStatus `json:"deliveryStatus,omitempty"`

	// Id A unique identifier of the notification event.
	Id *string `json:"id,omitempty"`

	// Payload Timestamp when the notification event was created in RFC 3339 format.
	Payload *NotificationEventPayload `json:"payload,omitempty"`

	// Rule The nnotification rule which generated this event.
	Rule *NotificationRule `json:"rule,omitempty"`

	// Type Type of the notification event.
	Type *NotificationEventType `json:"type,omitempty"`
}

// NotificationEventBalanceThresholdPayload Payload for notification event with `entitlements.balance.threshold` type.
type NotificationEventBalanceThresholdPayload struct {
	// Data The data of the payload.
	Data *NotificationEventBalanceThresholdPayloadData `json:"data,omitempty"`

	// Id A unique identifier for the notification event the payload belongs to.
	Id *string `json:"id,omitempty"`

	// Timestamp Timestamp when the notification event was created in RFC 3339 format.
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Type Type of the notification event.
	Type *NotificationEventBalanceThresholdPayloadType `json:"type,omitempty"`
}

// NotificationEventBalanceThresholdPayloadType Type of the notification event.
type NotificationEventBalanceThresholdPayloadType string

// NotificationEventBalanceThresholdPayloadData Data of the payload for notification event with `entitlements.balance.threshold` type.
type NotificationEventBalanceThresholdPayloadData struct {
	Entitlement *EntitlementMetered                    `json:"entitlement,omitempty"`
	Feature     *Feature                               `json:"feature,omitempty"`
	Subject     *Subject                               `json:"subject,omitempty"`
	Threshold   *NotificationRuleBalanceThresholdValue `json:"threshold,omitempty"`
	Value       *EntitlementValue                      `json:"value,omitempty"`
}

// NotificationEventDeliveryStatus The delivery status of the notification event.
type NotificationEventDeliveryStatus struct {
	// Channel Notification channel the delivery sattus associated with.
	Channel *NotificationChannelMeta `json:"channel,omitempty"`

	// Reason The reason of the last deliverry state update.
	Reason *string `json:"reason,omitempty"`

	// State Delivery state of the notification event to the channel.
	State *NotificationEventDeliveryStatusState `json:"state,omitempty"`

	// UpdatedAt Timestamp of when the status was last updated in RFC 3339 format.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// NotificationEventDeliveryStatusState Delivery state of the notification event to the channel.
type NotificationEventDeliveryStatusState string

// NotificationEventOrderBy Order by options for notification channels.
type NotificationEventOrderBy string

// NotificationEventPaginatedResponse Paginated response
type NotificationEventPaginatedResponse struct {
	// Items The items in the current page.
	Items []NotificationEvent `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// NotificationEventPayload Payload for notification event with `entitlements.balance.threshold` type.
type NotificationEventPayload = NotificationEventBalanceThresholdPayload

// NotificationEventType Type of the notification event.
type NotificationEventType string

// NotificationRule Notification rule with entitlements.balance.threshold type.
type NotificationRule = NotificationRuleBalanceThreshold

// NotificationRuleBalanceThreshold Notification rule with entitlements.balance.threshold type.
type NotificationRuleBalanceThreshold struct {
	// Channels List of notification channels the rule applies to.
	Channels []NotificationChannelMeta `json:"channels"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Features Optional field containing list of features the rule applies to.
	Features *[]FeatureMeta `json:"features,omitempty"`

	// Id Identifies the notification rule.
	Id *string `json:"id,omitempty"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Thresholds List of thresholds the rule suppose to be triggered.
	Thresholds []NotificationRuleBalanceThresholdValue `json:"thresholds"`

	// Type Notification rule type.
	Type NotificationRuleBalanceThresholdType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// NotificationRuleBalanceThresholdType Notification rule type.
type NotificationRuleBalanceThresholdType string

// NotificationRuleBalanceThresholdCreateRequest Request with input parameters for creating new notification rule with webhook type.
type NotificationRuleBalanceThresholdCreateRequest struct {
	// Channels List of notification channels the rule is applied to.
	Channels []string `json:"channels"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Features Optional field for defining the scope of notification by feature. It may contain features by id or key.
	Features *[]string `json:"features,omitempty"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Thresholds List of thresholds the rule suppose to be triggered.
	Thresholds []NotificationRuleBalanceThresholdValue `json:"thresholds"`

	// Type Notification rule type.
	Type NotificationRuleBalanceThresholdCreateRequestType `json:"type"`
}

// NotificationRuleBalanceThresholdCreateRequestType Notification rule type.
type NotificationRuleBalanceThresholdCreateRequestType string

// NotificationRuleBalanceThresholdValue Threshold value with multiple supported types.
type NotificationRuleBalanceThresholdValue struct {
	// Type Type of the threshold.
	Type NotificationRuleBalanceThresholdValueType `json:"type"`

	// Value Value of the threshold.
	Value float64 `json:"value"`
}

// NotificationRuleBalanceThresholdValueType Type of the threshold.
type NotificationRuleBalanceThresholdValueType string

// NotificationRuleCreateRequest Request with input parameters for creating new notification rule with webhook type.
type NotificationRuleCreateRequest = NotificationRuleBalanceThresholdCreateRequest

// NotificationRuleOrderBy Order by options for notification channels.
type NotificationRuleOrderBy string

// NotificationRulePaginatedResponse Paginated response
type NotificationRulePaginatedResponse struct {
	// Items The items in the current page.
	Items []NotificationRule `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// OAuth2AuthorizationCodeGrantErrorType OAuth2 authorization code grant error types.
type OAuth2AuthorizationCodeGrantErrorType string

// OpenMeterAppAppStatus App installed status.
type OpenMeterAppAppStatus string

// OpenMeterAppAppType App type.
type OpenMeterAppAppType string

// OpenMeterAppStripePaymentIntentStatus Stripe payment intent status.
type OpenMeterAppStripePaymentIntentStatus string

// Order The order direction.
type Order string

// Period A period with a start and end time.
type Period struct {
	// From Period start time.
	From time.Time `json:"from"`

	// To Period end time.
	To time.Time `json:"to"`
}

// PortalToken A consumer portal token.
//
// Validator doesn't obey required for readOnly properties
// See: https://github.com/stoplightio/spectral/issues/1274
type PortalToken struct {
	// AllowedMeterSlugs Optional, if defined only the specified meters will be allowed.
	AllowedMeterSlugs *[]string `json:"allowedMeterSlugs,omitempty"`

	// CreatedAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Expired   *bool      `json:"expired,omitempty"`

	// ExpiresAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id      *string `json:"id,omitempty"`
	Subject string  `json:"subject"`

	// Token The token is only returned at creation.
	Token *string `json:"token,omitempty"`
}

// RecurringPeriod Recurring period with an interval and an anchor.
type RecurringPeriod struct {
	// Anchor A date-time anchor to base the recurring period on.
	Anchor time.Time `json:"anchor"`

	// Interval The unit of time for the interval.
	Interval RecurringPeriodInterval `json:"interval"`
}

// RecurringPeriodCreateInput Recurring period with an interval and an anchor.
type RecurringPeriodCreateInput struct {
	// Anchor A date-time anchor to base the recurring period on.
	Anchor *time.Time `json:"anchor,omitempty"`

	// Interval The unit of time for the interval.
	Interval RecurringPeriodInterval `json:"interval"`
}

// RecurringPeriodInterval The unit of time for the interval.
// One of: `day`, `week`, `month`, or `year`.
type RecurringPeriodInterval string

// ResetEntitlementUsageInput Reset parameters
type ResetEntitlementUsageInput struct {
	// EffectiveAt The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.
	EffectiveAt *time.Time `json:"effectiveAt,omitempty"`

	// PreserveOverage Determines whether the overage is preserved or forgiven, overriding the entitlement's default behavior.
	// - If true, the overage is preserved.
	// - If false, the overage is forgiven.
	PreserveOverage *bool `json:"preserveOverage,omitempty"`

	// RetainAnchor Determines whether the usage period anchor is retained or reset to the effectiveAt time.
	// - If true, the usage period anchor is retained.
	// - If false, the usage period anchor is reset to the effectiveAt time.
	RetainAnchor *bool `json:"retainAnchor,omitempty"`
}

// ServiceUnavailableProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type ServiceUnavailableProblemResponse = UnexpectedProblemResponse

// StripeApp A installed Stripe app object.
type StripeApp struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id *string `json:"id,omitempty"`

	// Listing The marketplace listing that this installed app is based on.
	Listing *MarketplaceListing `json:"listing,omitempty"`

	// Livemode Livemode, true if the app is in production mode.
	Livemode bool `json:"livemode"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Status Status of the app connection.
	Status *OpenMeterAppAppStatus `json:"status,omitempty"`

	// StripeAccountId The Stripe account ID.
	StripeAccountId string `json:"stripeAccountId"`

	// Type The app's type is Stripe.
	Type StripeAppType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// StripeAppType The app's type is Stripe.
type StripeAppType string

// StripeCheckoutSessionMode Stripe CheckoutSession.mode
type StripeCheckoutSessionMode string

// StripeSetupIntent Stripe setup intent.
type StripeSetupIntent struct {
	// Customer The setup intent customer.
	Customer string `json:"customer"`

	// Id The setup intent id.
	Id string `json:"id"`

	// Metadata The setup intent metadata.
	Metadata map[string]string `json:"metadata"`

	// PaymentMethod The setup intent payment method.
	PaymentMethod *string `json:"payment_method,omitempty"`

	// PaymentMethodTypes The setup intent payment method types.
	PaymentMethodTypes *[]string `json:"payment_method_types,omitempty"`

	// Status The setup intent status.
	Status OpenMeterAppStripePaymentIntentStatus `json:"status"`
}

// StripeWebhookEvent Stripe webhook event.
type StripeWebhookEvent struct {
	// Created The event created timestamp.
	Created int32 `json:"created"`

	// Data The event data.
	Data struct {
		// Object Stripe setup intent.
		Object StripeSetupIntent `json:"object"`
	} `json:"data"`

	// Id The event ID.
	Id string `json:"id"`

	// Livemode Live mode.
	Livemode bool `json:"livemode"`

	// Type The event type.
	Type string `json:"type"`
}

// StripeWebhookResponse Stripe webhook response.
type StripeWebhookResponse struct {
	// AppId ULID (Universally Unique Lexicographically Sortable Identifier).
	AppId string `json:"appId"`

	// CustomerId ULID (Universally Unique Lexicographically Sortable Identifier).
	CustomerId *string `json:"customerId,omitempty"`

	// NamespaceId ULID (Universally Unique Lexicographically Sortable Identifier).
	NamespaceId string `json:"namespaceId"`
}

// Subject A subject is a unique identifier for a user or entity.
type Subject struct {
	// CurrentPeriodEnd [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CurrentPeriodEnd *time.Time `json:"currentPeriodEnd,omitempty"`

	// CurrentPeriodStart [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CurrentPeriodStart *time.Time `json:"currentPeriodStart,omitempty"`

	// DisplayName A human-readable display name for the subject.
	DisplayName *string `json:"displayName,omitempty"`

	// Id A unique identifier for the subject.
	Id *string `json:"id,omitempty"`

	// Key A unique, human-readable identifier for the subject.
	// Must consist only alphanumeric and underscore characters.
	Key              string                  `json:"key"`
	Metadata         *map[string]interface{} `json:"metadata"`
	StripeCustomerId *string                 `json:"stripeCustomerId,omitempty"`
}

// SubjectUpsert A subject is a unique identifier for a user or entity.
type SubjectUpsert struct {
	// CurrentPeriodEnd [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CurrentPeriodEnd *time.Time `json:"currentPeriodEnd,omitempty"`

	// CurrentPeriodStart [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CurrentPeriodStart *time.Time `json:"currentPeriodStart,omitempty"`

	// DisplayName A human-readable display name for the subject.
	DisplayName *string `json:"displayName,omitempty"`

	// Key A unique, human-readable identifier for the subject.
	// Must consist only alphanumeric and underscore characters.
	Key              string                  `json:"key"`
	Metadata         *map[string]interface{} `json:"metadata"`
	StripeCustomerId *string                 `json:"stripeCustomerId,omitempty"`
}

// SvixOperationalWebhookRequest Operational webhook reqeuest sent by Svix.
type SvixOperationalWebhookRequest struct {
	// Data The payload of the Svix operational webhook request.
	Data map[string]string `json:"data"`

	// Type The type of the Svix operational webhook request.
	Type SvixOperationalWebhookRequestType `json:"type"`
}

// SvixOperationalWebhookRequestType The type of the Svix operational webhook request.
type SvixOperationalWebhookRequestType string

// UnauthorizedProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type UnauthorizedProblemResponse = UnexpectedProblemResponse

// UnexpectedProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type UnexpectedProblemResponse = models.Problem

// WindowSize Aggregation window size.
type WindowSize = models.WindowSize

// WindowedBalanceHistory The windowed balance history.
type WindowedBalanceHistory struct {
	// BurndownHistory Grant burndown history.
	BurndownHistory []GrantBurnDownHistorySegment `json:"burndownHistory"`

	// WindowedHistory The windowed balance history.
	// - It only returns rows for windows where there was usage.
	// - The windows are inclusive at their start and exclusive at their end.
	// - The last window may be smaller than the window size and is inclusive at both ends.
	WindowedHistory []BalanceHistoryWindow `json:"windowedHistory"`
}

// EntitlementOrderByOrderingOrder The order direction.
type EntitlementOrderByOrderingOrder = Order

// EntitlementOrderByOrderingOrderBy Order by options for entitlements.
type EntitlementOrderByOrderingOrderBy = EntitlementOrderBy

// FeatureOrderByOrderingOrder The order direction.
type FeatureOrderByOrderingOrder = Order

// FeatureOrderByOrderingOrderBy Order by options for features.
type FeatureOrderByOrderingOrderBy = FeatureOrderBy

// GrantOrderByOrderingOrder The order direction.
type GrantOrderByOrderingOrder = Order

// GrantOrderByOrderingOrderBy Order by options for grants.
type GrantOrderByOrderingOrderBy = GrantOrderBy

// LimitOffsetLimit defines model for LimitOffset.limit.
type LimitOffsetLimit = int

// LimitOffsetOffset defines model for LimitOffset.offset.
type LimitOffsetOffset = int

// MarketplaceOAuth2InstallAuthorizeRequestAppKey defines model for MarketplaceOAuth2InstallAuthorizeRequest.appKey.
type MarketplaceOAuth2InstallAuthorizeRequestAppKey = string

// MeterQueryFilterGroupBy defines model for MeterQuery.filterGroupBy.
type MeterQueryFilterGroupBy map[string]string

// MeterQueryFrom defines model for MeterQuery.from.
type MeterQueryFrom = time.Time

// MeterQueryGroupBy defines model for MeterQuery.groupBy.
type MeterQueryGroupBy = []string

// MeterQuerySubject defines model for MeterQuery.subject.
type MeterQuerySubject = []string

// MeterQueryTo defines model for MeterQuery.to.
type MeterQueryTo = time.Time

// MeterQueryWindowSize Aggregation window size.
type MeterQueryWindowSize = WindowSize

// MeterQueryWindowTimeZone defines model for MeterQuery.windowTimeZone.
type MeterQueryWindowTimeZone = string

// NotificationChannelOrderByOrderingOrder The order direction.
type NotificationChannelOrderByOrderingOrder = Order

// NotificationChannelOrderByOrderingOrderBy Order by options for notification channels.
type NotificationChannelOrderByOrderingOrderBy = NotificationChannelOrderBy

// NotificationEventOrderByOrderingOrder The order direction.
type NotificationEventOrderByOrderingOrder = Order

// NotificationEventOrderByOrderingOrderBy Order by options for notification channels.
type NotificationEventOrderByOrderingOrderBy = NotificationEventOrderBy

// NotificationRuleOrderByOrderingOrder The order direction.
type NotificationRuleOrderByOrderingOrder = Order

// NotificationRuleOrderByOrderingOrderBy Order by options for notification channels.
type NotificationRuleOrderByOrderingOrderBy = NotificationRuleOrderBy

// OAuth2AuthorizationCodeGrantErrorParamsError OAuth2 authorization code grant error types.
type OAuth2AuthorizationCodeGrantErrorParamsError = OAuth2AuthorizationCodeGrantErrorType

// OAuth2AuthorizationCodeGrantErrorParamsErrorDescription defines model for OAuth2AuthorizationCodeGrantErrorParams.error_description.
type OAuth2AuthorizationCodeGrantErrorParamsErrorDescription = string

// OAuth2AuthorizationCodeGrantErrorParamsErrorUri defines model for OAuth2AuthorizationCodeGrantErrorParams.error_uri.
type OAuth2AuthorizationCodeGrantErrorParamsErrorUri = string

// OAuth2AuthorizationCodeGrantSuccessParamsCode defines model for OAuth2AuthorizationCodeGrantSuccessParams.code.
type OAuth2AuthorizationCodeGrantSuccessParamsCode = string

// OAuth2AuthorizationCodeGrantSuccessParamsState defines model for OAuth2AuthorizationCodeGrantSuccessParams.state.
type OAuth2AuthorizationCodeGrantSuccessParamsState = string

// PaginatedQueryPage defines model for PaginatedQuery.page.
type PaginatedQueryPage = int

// PaginatedQueryPageSize defines model for PaginatedQuery.pageSize.
type PaginatedQueryPageSize = int

// PaginationPage defines model for Pagination.page.
type PaginationPage = int

// PaginationPageSize defines model for Pagination.pageSize.
type PaginationPageSize = int

// QueryCustomerList defines model for queryCustomerList.
type QueryCustomerList = bool

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
	// Page The page number.
	Page *PaginatedQueryPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items in the page.
	PageSize *PaginatedQueryPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ListCustomersParams defines parameters for ListCustomers.
type ListCustomersParams struct {
	// IncludeDeleted Include deleted customers.
	IncludeDeleted *QueryCustomerList `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Page The page number.
	Page *PaginatedQueryPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items in the page.
	PageSize *PaginatedQueryPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ListEntitlementsParams defines parameters for ListEntitlements.
type ListEntitlementsParams struct {
	// Feature Filtering by multiple features.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Subject Filtering by multiple subjects.
	//
	// Usage: `?subject=customer-1&subject=customer-2`
	Subject *[]string `form:"subject,omitempty" json:"subject,omitempty"`

	// EntitlementType Filtering by multiple entitlement types.
	//
	// Usage: `?entitlementType=metered&entitlementType=boolean`
	EntitlementType *[]EntitlementType `form:"entitlementType,omitempty" json:"entitlementType,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *EntitlementOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *EntitlementOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListEventsParams defines parameters for ListEvents.
type ListEventsParams struct {
	// IngestedAtFrom Start date-time in RFC 3339 format.
	//
	// Inclusive.
	IngestedAtFrom *time.Time `form:"ingestedAtFrom,omitempty" json:"ingestedAtFrom,omitempty"`

	// IngestedAtTo End date-time in RFC 3339 format.
	//
	// Inclusive.
	IngestedAtTo *time.Time `form:"ingestedAtTo,omitempty" json:"ingestedAtTo,omitempty"`

	// HasError If not provided lists all events.
	//
	// If provided with true, only list events with processing error.
	//
	// If provided with false, only list events without processing error.
	HasError *bool `form:"hasError,omitempty" json:"hasError,omitempty"`

	// Id The event ID.
	//
	// Accepts partial ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Subject The event subject.
	//
	// Accepts partial subject.
	Subject *string `form:"subject,omitempty" json:"subject,omitempty"`

	// From Start date-time in RFC 3339 format.
	//
	// Inclusive.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	//
	// Inclusive.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Limit Number of events to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// IngestEventsApplicationCloudeventsBatchPlusJSONBody defines parameters for IngestEvents.
type IngestEventsApplicationCloudeventsBatchPlusJSONBody = []Event

// ListFeaturesParams defines parameters for ListFeatures.
type ListFeaturesParams struct {
	// MeterSlug Filter by meterSlug
	MeterSlug *[]string `form:"meterSlug,omitempty" json:"meterSlug,omitempty"`

	// IncludeArchived Filter by meterGroupByFilters
	IncludeArchived *bool `form:"includeArchived,omitempty" json:"includeArchived,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *FeatureOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *FeatureOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListGrantsParams defines parameters for ListGrants.
type ListGrantsParams struct {
	// Feature Filtering by multiple features.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Subject Filtering by multiple subjects.
	//
	// Usage: `?subject=customer-1&subject=customer-2`
	Subject *[]string `form:"subject,omitempty" json:"subject,omitempty"`

	// IncludeDeleted Include deleted
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *GrantOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *GrantOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// MarketplaceAppAPIKeyInstallJSONBody defines parameters for MarketplaceAppAPIKeyInstall.
type MarketplaceAppAPIKeyInstallJSONBody struct {
	// ApiKey The API key for the provider.
	// For example, the Stripe API key.
	ApiKey string `json:"apiKey"`

	// Type The type of the app to install.
	// For example `stripe`.
	Type OpenMeterAppAppType `json:"type"`
}

// MarketplaceOAuth2InstallGetURLParams defines parameters for MarketplaceOAuth2InstallGetURL.
type MarketplaceOAuth2InstallGetURLParams struct {
	AppKey string `form:"appKey" json:"appKey"`
}

// MarketplaceOAuth2InstallAuthorizeParams defines parameters for MarketplaceOAuth2InstallAuthorize.
type MarketplaceOAuth2InstallAuthorizeParams struct {
	// State Required if the "state" parameter was present in the client authorization request.
	// The exact value received from the client:
	//
	// Unique, randomly generated, opaque, and non-guessable string that is sent
	// when starting an authentication request and validated when processing the response.
	State *OAuth2AuthorizationCodeGrantSuccessParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Code Authorization code which the client will later exchange for an access token.
	// Required with the success response.
	Code *OAuth2AuthorizationCodeGrantSuccessParamsCode `form:"code,omitempty" json:"code,omitempty"`

	// Error Error code.
	// Required with the error response.
	Error *OAuth2AuthorizationCodeGrantErrorParamsError `form:"error,omitempty" json:"error,omitempty"`

	// ErrorDescription Optional human-readable text providing additional information,
	// used to assist the client developer in understanding the error that occurred.
	ErrorDescription *OAuth2AuthorizationCodeGrantErrorParamsErrorDescription `form:"error_description,omitempty" json:"error_description,omitempty"`

	// ErrorUri Optional uri identifying a human-readable web page with
	// information about the error, used to provide the client
	// developer with additional information about the error
	ErrorUri *OAuth2AuthorizationCodeGrantErrorParamsErrorUri `form:"error_uri,omitempty" json:"error_uri,omitempty"`

	// AppKey The key of the app to install.
	AppKey MarketplaceOAuth2InstallAuthorizeRequestAppKey `form:"appKey" json:"appKey"`
}

// MarketplaceListListingsParams defines parameters for MarketplaceListListings.
type MarketplaceListListingsParams struct {
	// Page The page number.
	Page *PaginatedQueryPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items in the page.
	PageSize *PaginatedQueryPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// QueryMeterParams defines parameters for QueryMeter.
type QueryMeterParams struct {
	// From Start date-time in RFC 3339 format.
	//
	// Inclusive.
	From *MeterQueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	//
	// Inclusive.
	To *MeterQueryTo `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.
	WindowSize *MeterQueryWindowSize `form:"windowSize,omitempty" json:"windowSize,omitempty"`

	// WindowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
	// If not specified, the UTC timezone will be used.
	WindowTimeZone *MeterQueryWindowTimeZone `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`

	// Subject Filtering by multiple subjects.
	Subject *MeterQuerySubject `form:"subject,omitempty" json:"subject,omitempty"`

	// FilterGroupBy Simple filter for group bys with exact match.
	FilterGroupBy *MeterQueryFilterGroupBy `json:"filterGroupBy,omitempty"`

	// GroupBy If not specified a single aggregate will be returned for each subject and time window.
	// `subject` is a reserved group by value.
	GroupBy *MeterQueryGroupBy `form:"groupBy,omitempty" json:"groupBy,omitempty"`
}

// ListNotificationChannelsParams defines parameters for ListNotificationChannels.
type ListNotificationChannelsParams struct {
	// IncludeDeleted Include deleted notification channels in response.
	//
	// Usage: `?includeDeleted=true`
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// IncludeDisabled Include disabled notification channels in response.
	//
	// Usage: `?includeDisabled=false`
	IncludeDisabled *bool `form:"includeDisabled,omitempty" json:"includeDisabled,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *NotificationChannelOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *NotificationChannelOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListNotificationEventsParams defines parameters for ListNotificationEvents.
type ListNotificationEventsParams struct {
	// From Start date-time in RFC 3339 format.
	// Inclusive.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	// Inclusive.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Feature Filtering by multiple feature ids or keys.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Subject Filtering by multiple subject ids or keys.
	//
	// Usage: `?subject=subject-1&subject=subject-2`
	Subject *[]string `form:"subject,omitempty" json:"subject,omitempty"`

	// Rule Filtering by multiple rule ids.
	//
	// Usage: `?rule=01J8J2XYZ2N5WBYK09EDZFBSZM&rule=01J8J4R4VZH180KRKQ63NB2VA5`
	Rule *[]string `form:"rule,omitempty" json:"rule,omitempty"`

	// Channel Filtering by multiple channel ids.
	//
	// Usage: `?channel=01J8J4RXH778XB056JS088PCYT&channel=01J8J4S1R1G9EVN62RG23A9M6J`
	Channel *[]string `form:"channel,omitempty" json:"channel,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *NotificationEventOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *NotificationEventOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListNotificationRulesParams defines parameters for ListNotificationRules.
type ListNotificationRulesParams struct {
	// IncludeDeleted Include deleted notification rules in response.
	//
	// Usage: `?includeDeleted=true`
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// IncludeDisabled Include disabled notification rules in response.
	//
	// Usage: `?includeDisabled=false`
	IncludeDisabled *bool `form:"includeDisabled,omitempty" json:"includeDisabled,omitempty"`

	// Feature Filtering by multiple feature ids/keys.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Channel Filtering by multiple notifiaction channel ids.
	//
	// Usage: `?channel=01ARZ3NDEKTSV4RRFFQ69G5FAV&channel=01J8J2Y5X4NNGQS32CF81W95E3`
	Channel *[]string `form:"channel,omitempty" json:"channel,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *NotificationRuleOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *NotificationRuleOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// QueryPortalMeterParams defines parameters for QueryPortalMeter.
type QueryPortalMeterParams struct {
	// From Start date-time in RFC 3339 format.
	//
	// Inclusive.
	From *MeterQueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	//
	// Inclusive.
	To *MeterQueryTo `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.
	WindowSize *MeterQueryWindowSize `form:"windowSize,omitempty" json:"windowSize,omitempty"`

	// WindowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
	// If not specified, the UTC timezone will be used.
	WindowTimeZone *MeterQueryWindowTimeZone `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`

	// FilterGroupBy Simple filter for group bys with exact match.
	FilterGroupBy *MeterQueryFilterGroupBy `json:"filterGroupBy,omitempty"`

	// GroupBy If not specified a single aggregate will be returned for each subject and time window.
	// `subject` is a reserved group by value.
	GroupBy *MeterQueryGroupBy `form:"groupBy,omitempty" json:"groupBy,omitempty"`
}

// ListPortalTokensParams defines parameters for ListPortalTokens.
type ListPortalTokensParams struct {
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// InvalidatePortalTokensJSONBody defines parameters for InvalidatePortalTokens.
type InvalidatePortalTokensJSONBody struct {
	// Id Invalidate a portal token by ID.
	Id *string `json:"id,omitempty"`

	// Subject Invalidate all portal tokens for a subject.
	Subject *string `json:"subject,omitempty"`
}

// UpsertSubjectJSONBody defines parameters for UpsertSubject.
type UpsertSubjectJSONBody = []SubjectUpsert

// ListSubjectEntitlementsParams defines parameters for ListSubjectEntitlements.
type ListSubjectEntitlementsParams struct {
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`
}

// ListEntitlementGrantsParams defines parameters for ListEntitlementGrants.
type ListEntitlementGrantsParams struct {
	IncludeDeleted *bool         `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`
	OrderBy        *GrantOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// GetEntitlementValueParams defines parameters for GetEntitlementValue.
type GetEntitlementValueParams struct {
	Time *time.Time `form:"time,omitempty" json:"time,omitempty"`
}

// GetEntitlementHistoryParams defines parameters for GetEntitlementHistory.
type GetEntitlementHistoryParams struct {
	// From Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to the last reset. Gets truncated to the granularity of the underlying meter.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.
	// If not now then gets truncated to the granularity of the underlying meter.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize Windowsize
	WindowSize WindowSize `form:"windowSize" json:"windowSize"`

	// WindowTimeZone The timezone used when calculating the windows.
	WindowTimeZone *string `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`
}

// CreateCustomerJSONRequestBody defines body for CreateCustomer for application/json ContentType.
type CreateCustomerJSONRequestBody = Customer

// UpdateCustomerJSONRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody = Customer

// IngestEventsApplicationCloudeventsPlusJSONRequestBody defines body for IngestEvents for application/cloudevents+json ContentType.
type IngestEventsApplicationCloudeventsPlusJSONRequestBody = Event

// IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody defines body for IngestEvents for application/cloudevents-batch+json ContentType.
type IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody = IngestEventsApplicationCloudeventsBatchPlusJSONBody

// CreateFeatureJSONRequestBody defines body for CreateFeature for application/json ContentType.
type CreateFeatureJSONRequestBody = FeatureCreateInputs

// MarketplaceAppAPIKeyInstallJSONRequestBody defines body for MarketplaceAppAPIKeyInstall for application/json ContentType.
type MarketplaceAppAPIKeyInstallJSONRequestBody MarketplaceAppAPIKeyInstallJSONBody

// CreateMeterJSONRequestBody defines body for CreateMeter for application/json ContentType.
type CreateMeterJSONRequestBody = Meter

// CreateNotificationChannelJSONRequestBody defines body for CreateNotificationChannel for application/json ContentType.
type CreateNotificationChannelJSONRequestBody = NotificationChannelCreateRequest

// UpdateNotificationChannelJSONRequestBody defines body for UpdateNotificationChannel for application/json ContentType.
type UpdateNotificationChannelJSONRequestBody = NotificationChannelCreateRequest

// CreateNotificationRuleJSONRequestBody defines body for CreateNotificationRule for application/json ContentType.
type CreateNotificationRuleJSONRequestBody = NotificationRuleCreateRequest

// UpdateNotificationRuleJSONRequestBody defines body for UpdateNotificationRule for application/json ContentType.
type UpdateNotificationRuleJSONRequestBody = NotificationRuleCreateRequest

// ReceiveSvixOperationalEventJSONRequestBody defines body for ReceiveSvixOperationalEvent for application/json ContentType.
type ReceiveSvixOperationalEventJSONRequestBody = SvixOperationalWebhookRequest

// CreatePortalTokenJSONRequestBody defines body for CreatePortalToken for application/json ContentType.
type CreatePortalTokenJSONRequestBody = PortalToken

// InvalidatePortalTokensJSONRequestBody defines body for InvalidatePortalTokens for application/json ContentType.
type InvalidatePortalTokensJSONRequestBody InvalidatePortalTokensJSONBody

// UpsertSubjectJSONRequestBody defines body for UpsertSubject for application/json ContentType.
type UpsertSubjectJSONRequestBody = UpsertSubjectJSONBody

// CreateEntitlementJSONRequestBody defines body for CreateEntitlement for application/json ContentType.
type CreateEntitlementJSONRequestBody = EntitlementCreateInputs

// CreateGrantJSONRequestBody defines body for CreateGrant for application/json ContentType.
type CreateGrantJSONRequestBody = EntitlementGrantCreateInput

// OverrideEntitlementJSONRequestBody defines body for OverrideEntitlement for application/json ContentType.
type OverrideEntitlementJSONRequestBody = EntitlementCreateInputs

// ResetEntitlementUsageJSONRequestBody defines body for ResetEntitlementUsage for application/json ContentType.
type ResetEntitlementUsageJSONRequestBody = ResetEntitlementUsageInput

// AsEntitlementMetered returns the union data inside the Entitlement as a EntitlementMetered
func (t Entitlement) AsEntitlementMetered() (EntitlementMetered, error) {
	var body EntitlementMetered
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementMetered overwrites any union data inside the Entitlement as the provided EntitlementMetered
func (t *Entitlement) FromEntitlementMetered(v EntitlementMetered) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementMetered performs a merge with any union data inside the Entitlement, using the provided EntitlementMetered
func (t *Entitlement) MergeEntitlementMetered(v EntitlementMetered) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementStatic returns the union data inside the Entitlement as a EntitlementStatic
func (t Entitlement) AsEntitlementStatic() (EntitlementStatic, error) {
	var body EntitlementStatic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementStatic overwrites any union data inside the Entitlement as the provided EntitlementStatic
func (t *Entitlement) FromEntitlementStatic(v EntitlementStatic) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementStatic performs a merge with any union data inside the Entitlement, using the provided EntitlementStatic
func (t *Entitlement) MergeEntitlementStatic(v EntitlementStatic) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementBoolean returns the union data inside the Entitlement as a EntitlementBoolean
func (t Entitlement) AsEntitlementBoolean() (EntitlementBoolean, error) {
	var body EntitlementBoolean
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementBoolean overwrites any union data inside the Entitlement as the provided EntitlementBoolean
func (t *Entitlement) FromEntitlementBoolean(v EntitlementBoolean) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementBoolean performs a merge with any union data inside the Entitlement, using the provided EntitlementBoolean
func (t *Entitlement) MergeEntitlementBoolean(v EntitlementBoolean) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Entitlement) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Entitlement) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsEntitlementBoolean()
	case "metered":
		return t.AsEntitlementMetered()
	case "static":
		return t.AsEntitlementStatic()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Entitlement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Entitlement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEntitlementMeteredCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementMeteredCreateInputs
func (t EntitlementCreateInputs) AsEntitlementMeteredCreateInputs() (EntitlementMeteredCreateInputs, error) {
	var body EntitlementMeteredCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementMeteredCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementMeteredCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementMeteredCreateInputs(v EntitlementMeteredCreateInputs) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementMeteredCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementMeteredCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementMeteredCreateInputs(v EntitlementMeteredCreateInputs) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementStaticCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementStaticCreateInputs
func (t EntitlementCreateInputs) AsEntitlementStaticCreateInputs() (EntitlementStaticCreateInputs, error) {
	var body EntitlementStaticCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementStaticCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementStaticCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementStaticCreateInputs(v EntitlementStaticCreateInputs) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementStaticCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementStaticCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementStaticCreateInputs(v EntitlementStaticCreateInputs) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementBooleanCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementBooleanCreateInputs
func (t EntitlementCreateInputs) AsEntitlementBooleanCreateInputs() (EntitlementBooleanCreateInputs, error) {
	var body EntitlementBooleanCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementBooleanCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementBooleanCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementBooleanCreateInputs(v EntitlementBooleanCreateInputs) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementBooleanCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementBooleanCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementBooleanCreateInputs(v EntitlementBooleanCreateInputs) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntitlementCreateInputs) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EntitlementCreateInputs) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsEntitlementBooleanCreateInputs()
	case "metered":
		return t.AsEntitlementMeteredCreateInputs()
	case "static":
		return t.AsEntitlementStaticCreateInputs()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EntitlementCreateInputs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntitlementCreateInputs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMeasureUsageFromEnum returns the union data inside the MeasureUsageFrom as a MeasureUsageFromEnum
func (t MeasureUsageFrom) AsMeasureUsageFromEnum() (MeasureUsageFromEnum, error) {
	var body MeasureUsageFromEnum
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeasureUsageFromEnum overwrites any union data inside the MeasureUsageFrom as the provided MeasureUsageFromEnum
func (t *MeasureUsageFrom) FromMeasureUsageFromEnum(v MeasureUsageFromEnum) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeasureUsageFromEnum performs a merge with any union data inside the MeasureUsageFrom, using the provided MeasureUsageFromEnum
func (t *MeasureUsageFrom) MergeMeasureUsageFromEnum(v MeasureUsageFromEnum) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMeasureUsageFromTime returns the union data inside the MeasureUsageFrom as a MeasureUsageFromTime
func (t MeasureUsageFrom) AsMeasureUsageFromTime() (MeasureUsageFromTime, error) {
	var body MeasureUsageFromTime
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeasureUsageFromTime overwrites any union data inside the MeasureUsageFrom as the provided MeasureUsageFromTime
func (t *MeasureUsageFrom) FromMeasureUsageFromTime(v MeasureUsageFromTime) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeasureUsageFromTime performs a merge with any union data inside the MeasureUsageFrom, using the provided MeasureUsageFromTime
func (t *MeasureUsageFrom) MergeMeasureUsageFromTime(v MeasureUsageFromTime) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MeasureUsageFrom) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MeasureUsageFrom) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListApps request
	ListApps(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallApp request
	UninstallApp(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppStripeCheckoutSessionWithBody request with any body
	CreateAppStripeCheckoutSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAppStripeCheckoutSession(ctx context.Context, id string, body CreateAppStripeCheckoutSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppStripeWebhookWithBody request with any body
	AppStripeWebhookWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppStripeWebhook(ctx context.Context, id string, body AppStripeWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomers request
	ListCustomers(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomerWithBody request with any body
	CreateCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomer(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomer request
	DeleteCustomer(ctx context.Context, customerIdOrKey CustomerIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomer request
	GetCustomer(ctx context.Context, customerIdOrKey CustomerIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomerWithBody request with any body
	UpdateCustomerWithBody(ctx context.Context, customerIdOrKey CustomerIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomer(ctx context.Context, customerIdOrKey CustomerIdentifier, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDebugMetrics request
	GetDebugMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEntitlements request
	ListEntitlements(ctx context.Context, params *ListEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntitlementById request
	GetEntitlementById(ctx context.Context, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvents request
	ListEvents(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IngestEventsWithBody request with any body
	IngestEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IngestEventsWithApplicationCloudeventsPlusJSONBody(ctx context.Context, body IngestEventsApplicationCloudeventsPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	IngestEventsWithApplicationCloudeventsBatchPlusJSONBody(ctx context.Context, body IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFeatures request
	ListFeatures(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFeatureWithBody request with any body
	CreateFeatureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFeature(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFeature request
	DeleteFeature(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeature request
	GetFeature(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGrants request
	ListGrants(ctx context.Context, params *ListGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VoidGrant request
	VoidGrant(ctx context.Context, grantId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarketplaceAppAPIKeyInstallWithBody request with any body
	MarketplaceAppAPIKeyInstallWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarketplaceAppAPIKeyInstall(ctx context.Context, body MarketplaceAppAPIKeyInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarketplaceOAuth2InstallGetURL request
	MarketplaceOAuth2InstallGetURL(ctx context.Context, params *MarketplaceOAuth2InstallGetURLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarketplaceOAuth2InstallAuthorize request
	MarketplaceOAuth2InstallAuthorize(ctx context.Context, params *MarketplaceOAuth2InstallAuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarketplaceListListings request
	MarketplaceListListings(ctx context.Context, params *MarketplaceListListingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMeters request
	ListMeters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMeterWithBody request with any body
	CreateMeterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMeter(ctx context.Context, body CreateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMeter request
	DeleteMeter(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeter request
	GetMeter(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryMeter request
	QueryMeter(ctx context.Context, meterIdOrSlug string, params *QueryMeterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMeterSubjects request
	ListMeterSubjects(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNotificationChannels request
	ListNotificationChannels(ctx context.Context, params *ListNotificationChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNotificationChannelWithBody request with any body
	CreateNotificationChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNotificationChannel(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotificationChannel request
	DeleteNotificationChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationChannel request
	GetNotificationChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNotificationChannelWithBody request with any body
	UpdateNotificationChannelWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNotificationChannel(ctx context.Context, channelId string, body UpdateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNotificationEvents request
	ListNotificationEvents(ctx context.Context, params *ListNotificationEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationEvent request
	GetNotificationEvent(ctx context.Context, eventId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNotificationRules request
	ListNotificationRules(ctx context.Context, params *ListNotificationRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNotificationRuleWithBody request with any body
	CreateNotificationRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNotificationRule(ctx context.Context, body CreateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotificationRule request
	DeleteNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationRule request
	GetNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNotificationRuleWithBody request with any body
	UpdateNotificationRuleWithBody(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNotificationRule(ctx context.Context, ruleId string, body UpdateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestNotificationRule request
	TestNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiveSvixOperationalEventWithBody request with any body
	ReceiveSvixOperationalEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReceiveSvixOperationalEvent(ctx context.Context, body ReceiveSvixOperationalEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryPortalMeter request
	QueryPortalMeter(ctx context.Context, meterSlug string, params *QueryPortalMeterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPortalTokens request
	ListPortalTokens(ctx context.Context, params *ListPortalTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePortalTokenWithBody request with any body
	CreatePortalTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePortalToken(ctx context.Context, body CreatePortalTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InvalidatePortalTokensWithBody request with any body
	InvalidatePortalTokensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InvalidatePortalTokens(ctx context.Context, body InvalidatePortalTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSubjects request
	ListSubjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertSubjectWithBody request with any body
	UpsertSubjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertSubject(ctx context.Context, body UpsertSubjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubject request
	DeleteSubject(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubject request
	GetSubject(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSubjectEntitlements request
	ListSubjectEntitlements(ctx context.Context, subjectIdOrKey string, params *ListSubjectEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEntitlementWithBody request with any body
	CreateEntitlementWithBody(ctx context.Context, subjectIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEntitlement(ctx context.Context, subjectIdOrKey string, body CreateEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEntitlementGrants request
	ListEntitlementGrants(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *ListEntitlementGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGrantWithBody request with any body
	CreateGrantWithBody(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGrant(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OverrideEntitlementWithBody request with any body
	OverrideEntitlementWithBody(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OverrideEntitlement(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body OverrideEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntitlementValue request
	GetEntitlementValue(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *GetEntitlementValueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEntitlement request
	DeleteEntitlement(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntitlement request
	GetEntitlement(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntitlementHistory request
	GetEntitlementHistory(ctx context.Context, subjectIdOrKey string, entitlementId string, params *GetEntitlementHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetEntitlementUsageWithBody request with any body
	ResetEntitlementUsageWithBody(ctx context.Context, subjectIdOrKey string, entitlementId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetEntitlementUsage(ctx context.Context, subjectIdOrKey string, entitlementId string, body ResetEntitlementUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListApps(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallApp(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallAppRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApp(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomers(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomer(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomer(ctx context.Context, customerIdOrKey CustomerIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomerRequest(c.Server, customerIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomer(ctx context.Context, customerIdOrKey CustomerIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerRequest(c.Server, customerIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomerWithBody(ctx context.Context, customerIdOrKey CustomerIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerRequestWithBody(c.Server, customerIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomer(ctx context.Context, customerIdOrKey CustomerIdentifier, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerRequest(c.Server, customerIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDebugMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDebugMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEntitlements(ctx context.Context, params *ListEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEntitlementsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntitlementById(ctx context.Context, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntitlementByIdRequest(c.Server, entitlementId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEvents(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestEventsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestEventsWithApplicationCloudeventsPlusJSONBody(ctx context.Context, body IngestEventsApplicationCloudeventsPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestEventsRequestWithApplicationCloudeventsPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestEventsWithApplicationCloudeventsBatchPlusJSONBody(ctx context.Context, body IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestEventsRequestWithApplicationCloudeventsBatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFeatures(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFeaturesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFeatureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFeatureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFeature(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFeatureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFeature(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFeatureRequest(c.Server, featureId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeature(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeatureRequest(c.Server, featureId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGrants(ctx context.Context, params *ListGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGrantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VoidGrant(ctx context.Context, grantId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVoidGrantRequest(c.Server, grantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceAppAPIKeyInstallWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceAppAPIKeyInstallRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceAppAPIKeyInstall(ctx context.Context, body MarketplaceAppAPIKeyInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceAppAPIKeyInstallRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceOAuth2InstallGetURL(ctx context.Context, params *MarketplaceOAuth2InstallGetURLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceOAuth2InstallGetURLRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceOAuth2InstallAuthorize(ctx context.Context, params *MarketplaceOAuth2InstallAuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceOAuth2InstallAuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceListListings(ctx context.Context, params *MarketplaceListListingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceListListingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMeters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMetersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMeterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMeterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMeter(ctx context.Context, body CreateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMeterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMeter(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMeterRequest(c.Server, meterIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeter(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeterRequest(c.Server, meterIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryMeter(ctx context.Context, meterIdOrSlug string, params *QueryMeterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryMeterRequest(c.Server, meterIdOrSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMeterSubjects(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMeterSubjectsRequest(c.Server, meterIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNotificationChannels(ctx context.Context, params *ListNotificationChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNotificationChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationChannelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationChannel(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationChannelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotificationChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationChannelRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationChannelRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationChannelWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationChannelRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationChannel(ctx context.Context, channelId string, body UpdateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationChannelRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNotificationEvents(ctx context.Context, params *ListNotificationEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNotificationEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationEvent(ctx context.Context, eventId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationEventRequest(c.Server, eventId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNotificationRules(ctx context.Context, params *ListNotificationRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNotificationRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationRule(ctx context.Context, body CreateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationRuleWithBody(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationRuleRequestWithBody(c.Server, ruleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationRule(ctx context.Context, ruleId string, body UpdateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationRuleRequest(c.Server, ruleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestNotificationRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveSvixOperationalEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveSvixOperationalEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveSvixOperationalEvent(ctx context.Context, body ReceiveSvixOperationalEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveSvixOperationalEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryPortalMeter(ctx context.Context, meterSlug string, params *QueryPortalMeterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryPortalMeterRequest(c.Server, meterSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPortalTokens(ctx context.Context, params *ListPortalTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPortalTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePortalTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePortalTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePortalToken(ctx context.Context, body CreatePortalTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePortalTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvalidatePortalTokensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvalidatePortalTokensRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvalidatePortalTokens(ctx context.Context, body InvalidatePortalTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvalidatePortalTokensRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSubjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSubjectsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertSubjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertSubjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertSubject(ctx context.Context, body UpsertSubjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertSubjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubject(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubjectRequest(c.Server, subjectIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubject(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubjectRequest(c.Server, subjectIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSubjectEntitlements(ctx context.Context, subjectIdOrKey string, params *ListSubjectEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSubjectEntitlementsRequest(c.Server, subjectIdOrKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEntitlementWithBody(ctx context.Context, subjectIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEntitlementRequestWithBody(c.Server, subjectIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEntitlement(ctx context.Context, subjectIdOrKey string, body CreateEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEntitlementRequest(c.Server, subjectIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEntitlementGrants(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *ListEntitlementGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEntitlementGrantsRequest(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGrantWithBody(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGrantRequestWithBody(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGrant(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGrantRequest(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OverrideEntitlementWithBody(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOverrideEntitlementRequestWithBody(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OverrideEntitlement(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body OverrideEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOverrideEntitlementRequest(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntitlementValue(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *GetEntitlementValueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntitlementValueRequest(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEntitlement(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEntitlementRequest(c.Server, subjectIdOrKey, entitlementId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntitlement(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntitlementRequest(c.Server, subjectIdOrKey, entitlementId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntitlementHistory(ctx context.Context, subjectIdOrKey string, entitlementId string, params *GetEntitlementHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntitlementHistoryRequest(c.Server, subjectIdOrKey, entitlementId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetEntitlementUsageWithBody(ctx context.Context, subjectIdOrKey string, entitlementId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetEntitlementUsageRequestWithBody(c.Server, subjectIdOrKey, entitlementId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetEntitlementUsage(ctx context.Context, subjectIdOrKey string, entitlementId string, body ResetEntitlementUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetEntitlementUsageRequest(c.Server, subjectIdOrKey, entitlementId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, params *ListAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUninstallAppRequest generates requests for UninstallApp
func NewUninstallAppRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAppStripeCheckoutSessionRequest calls the generic CreateAppStripeCheckoutSession builder with application/json body
func NewCreateAppStripeCheckoutSessionRequest(server string, id string, body CreateAppStripeCheckoutSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppStripeCheckoutSessionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateAppStripeCheckoutSessionRequestWithBody generates requests for CreateAppStripeCheckoutSession with any type of body
func NewCreateAppStripeCheckoutSessionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/%s/stripe/checkout/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppStripeWebhookRequest calls the generic AppStripeWebhook builder with application/json body
func NewAppStripeWebhookRequest(server string, id string, body AppStripeWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStripeWebhookRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppStripeWebhookRequestWithBody generates requests for AppStripeWebhook with any type of body
func NewAppStripeWebhookRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/%s/stripe/webhook", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCustomersRequest generates requests for ListCustomers
func NewListCustomersRequest(server string, params *ListCustomersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomerRequest calls the generic CreateCustomer builder with application/json body
func NewCreateCustomerRequest(server string, body CreateCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCustomerRequestWithBody generates requests for CreateCustomer with any type of body
func NewCreateCustomerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomerRequest generates requests for DeleteCustomer
func NewDeleteCustomerRequest(server string, customerIdOrKey CustomerIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomerRequest generates requests for GetCustomer
func NewGetCustomerRequest(server string, customerIdOrKey CustomerIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomerRequest calls the generic UpdateCustomer builder with application/json body
func NewUpdateCustomerRequest(server string, customerIdOrKey CustomerIdentifier, body UpdateCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomerRequestWithBody(server, customerIdOrKey, "application/json", bodyReader)
}

// NewUpdateCustomerRequestWithBody generates requests for UpdateCustomer with any type of body
func NewUpdateCustomerRequestWithBody(server string, customerIdOrKey CustomerIdentifier, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDebugMetricsRequest generates requests for GetDebugMetrics
func NewGetDebugMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/debug/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEntitlementsRequest generates requests for ListEntitlements
func NewListEntitlementsRequest(server string, params *ListEntitlementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/entitlements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Feature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feature", runtime.ParamLocationQuery, *params.Feature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntitlementType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entitlementType", runtime.ParamLocationQuery, *params.EntitlementType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntitlementByIdRequest generates requests for GetEntitlementById
func NewGetEntitlementByIdRequest(server string, entitlementId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entitlementId", runtime.ParamLocationPath, entitlementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/entitlements/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventsRequest generates requests for ListEvents
func NewListEventsRequest(server string, params *ListEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IngestedAtFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ingestedAtFrom", runtime.ParamLocationQuery, *params.IngestedAtFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IngestedAtTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ingestedAtTo", runtime.ParamLocationQuery, *params.IngestedAtTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasError != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasError", runtime.ParamLocationQuery, *params.HasError); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIngestEventsRequestWithApplicationCloudeventsPlusJSONBody calls the generic IngestEvents builder with application/cloudevents+json body
func NewIngestEventsRequestWithApplicationCloudeventsPlusJSONBody(server string, body IngestEventsApplicationCloudeventsPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIngestEventsRequestWithBody(server, "application/cloudevents+json", bodyReader)
}

// NewIngestEventsRequestWithApplicationCloudeventsBatchPlusJSONBody calls the generic IngestEvents builder with application/cloudevents-batch+json body
func NewIngestEventsRequestWithApplicationCloudeventsBatchPlusJSONBody(server string, body IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIngestEventsRequestWithBody(server, "application/cloudevents-batch+json", bodyReader)
}

// NewIngestEventsRequestWithBody generates requests for IngestEvents with any type of body
func NewIngestEventsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFeaturesRequest generates requests for ListFeatures
func NewListFeaturesRequest(server string, params *ListFeaturesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MeterSlug != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meterSlug", runtime.ParamLocationQuery, *params.MeterSlug); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeArchived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeArchived", runtime.ParamLocationQuery, *params.IncludeArchived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFeatureRequest calls the generic CreateFeature builder with application/json body
func NewCreateFeatureRequest(server string, body CreateFeatureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFeatureRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFeatureRequestWithBody generates requests for CreateFeature with any type of body
func NewCreateFeatureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFeatureRequest generates requests for DeleteFeature
func NewDeleteFeatureRequest(server string, featureId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "featureId", runtime.ParamLocationPath, featureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/features/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeatureRequest generates requests for GetFeature
func NewGetFeatureRequest(server string, featureId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "featureId", runtime.ParamLocationPath, featureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/features/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGrantsRequest generates requests for ListGrants
func NewListGrantsRequest(server string, params *ListGrantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/grants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Feature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feature", runtime.ParamLocationQuery, *params.Feature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVoidGrantRequest generates requests for VoidGrant
func NewVoidGrantRequest(server string, grantId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "grantId", runtime.ParamLocationPath, grantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/grants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarketplaceAppAPIKeyInstallRequest calls the generic MarketplaceAppAPIKeyInstall builder with application/json body
func NewMarketplaceAppAPIKeyInstallRequest(server string, body MarketplaceAppAPIKeyInstallJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarketplaceAppAPIKeyInstallRequestWithBody(server, "application/json", bodyReader)
}

// NewMarketplaceAppAPIKeyInstallRequestWithBody generates requests for MarketplaceAppAPIKeyInstall with any type of body
func NewMarketplaceAppAPIKeyInstallRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/marketplace/install/apikey")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarketplaceOAuth2InstallGetURLRequest generates requests for MarketplaceOAuth2InstallGetURL
func NewMarketplaceOAuth2InstallGetURLRequest(server string, params *MarketplaceOAuth2InstallGetURLParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/marketplace/install/oauth2")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "appKey", runtime.ParamLocationQuery, params.AppKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarketplaceOAuth2InstallAuthorizeRequest generates requests for MarketplaceOAuth2InstallAuthorize
func NewMarketplaceOAuth2InstallAuthorizeRequest(server string, params *MarketplaceOAuth2InstallAuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/marketplace/install/oauth2/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Error != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "error", runtime.ParamLocationQuery, *params.Error); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ErrorDescription != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "error_description", runtime.ParamLocationQuery, *params.ErrorDescription); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ErrorUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "error_uri", runtime.ParamLocationQuery, *params.ErrorUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "appKey", runtime.ParamLocationQuery, params.AppKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarketplaceListListingsRequest generates requests for MarketplaceListListings
func NewMarketplaceListListingsRequest(server string, params *MarketplaceListListingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/marketplace/listings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMetersRequest generates requests for ListMeters
func NewListMetersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMeterRequest calls the generic CreateMeter builder with application/json body
func NewCreateMeterRequest(server string, body CreateMeterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMeterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMeterRequestWithBody generates requests for CreateMeter with any type of body
func NewCreateMeterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMeterRequest generates requests for DeleteMeter
func NewDeleteMeterRequest(server string, meterIdOrSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterIdOrSlug", runtime.ParamLocationPath, meterIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeterRequest generates requests for GetMeter
func NewGetMeterRequest(server string, meterIdOrSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterIdOrSlug", runtime.ParamLocationPath, meterIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryMeterRequest generates requests for QueryMeter
func NewQueryMeterRequest(server string, meterIdOrSlug string, params *QueryMeterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterIdOrSlug", runtime.ParamLocationPath, meterIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "windowSize", runtime.ParamLocationQuery, *params.WindowSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowTimeZone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "windowTimeZone", runtime.ParamLocationQuery, *params.WindowTimeZone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterGroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filterGroupBy", runtime.ParamLocationQuery, *params.FilterGroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMeterSubjectsRequest generates requests for ListMeterSubjects
func NewListMeterSubjectsRequest(server string, meterIdOrSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterIdOrSlug", runtime.ParamLocationPath, meterIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters/%s/subjects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNotificationChannelsRequest generates requests for ListNotificationChannels
func NewListNotificationChannelsRequest(server string, params *ListNotificationChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDisabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDisabled", runtime.ParamLocationQuery, *params.IncludeDisabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNotificationChannelRequest calls the generic CreateNotificationChannel builder with application/json body
func NewCreateNotificationChannelRequest(server string, body CreateNotificationChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNotificationChannelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNotificationChannelRequestWithBody generates requests for CreateNotificationChannel with any type of body
func NewCreateNotificationChannelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNotificationChannelRequest generates requests for DeleteNotificationChannel
func NewDeleteNotificationChannelRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationChannelRequest generates requests for GetNotificationChannel
func NewGetNotificationChannelRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNotificationChannelRequest calls the generic UpdateNotificationChannel builder with application/json body
func NewUpdateNotificationChannelRequest(server string, channelId string, body UpdateNotificationChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNotificationChannelRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewUpdateNotificationChannelRequestWithBody generates requests for UpdateNotificationChannel with any type of body
func NewUpdateNotificationChannelRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNotificationEventsRequest generates requests for ListNotificationEvents
func NewListNotificationEventsRequest(server string, params *ListNotificationEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Feature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feature", runtime.ParamLocationQuery, *params.Feature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rule", runtime.ParamLocationQuery, *params.Rule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Channel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel", runtime.ParamLocationQuery, *params.Channel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationEventRequest generates requests for GetNotificationEvent
func NewGetNotificationEventRequest(server string, eventId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "eventId", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNotificationRulesRequest generates requests for ListNotificationRules
func NewListNotificationRulesRequest(server string, params *ListNotificationRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDisabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDisabled", runtime.ParamLocationQuery, *params.IncludeDisabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Feature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feature", runtime.ParamLocationQuery, *params.Feature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Channel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel", runtime.ParamLocationQuery, *params.Channel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNotificationRuleRequest calls the generic CreateNotificationRule builder with application/json body
func NewCreateNotificationRuleRequest(server string, body CreateNotificationRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNotificationRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNotificationRuleRequestWithBody generates requests for CreateNotificationRule with any type of body
func NewCreateNotificationRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNotificationRuleRequest generates requests for DeleteNotificationRule
func NewDeleteNotificationRuleRequest(server string, ruleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationRuleRequest generates requests for GetNotificationRule
func NewGetNotificationRuleRequest(server string, ruleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNotificationRuleRequest calls the generic UpdateNotificationRule builder with application/json body
func NewUpdateNotificationRuleRequest(server string, ruleId string, body UpdateNotificationRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNotificationRuleRequestWithBody(server, ruleId, "application/json", bodyReader)
}

// NewUpdateNotificationRuleRequestWithBody generates requests for UpdateNotificationRule with any type of body
func NewUpdateNotificationRuleRequestWithBody(server string, ruleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestNotificationRuleRequest generates requests for TestNotificationRule
func NewTestNotificationRuleRequest(server string, ruleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules/%s/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReceiveSvixOperationalEventRequest calls the generic ReceiveSvixOperationalEvent builder with application/json body
func NewReceiveSvixOperationalEventRequest(server string, body ReceiveSvixOperationalEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReceiveSvixOperationalEventRequestWithBody(server, "application/json", bodyReader)
}

// NewReceiveSvixOperationalEventRequestWithBody generates requests for ReceiveSvixOperationalEvent with any type of body
func NewReceiveSvixOperationalEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/webhook/svix")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryPortalMeterRequest generates requests for QueryPortalMeter
func NewQueryPortalMeterRequest(server string, meterSlug string, params *QueryPortalMeterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterSlug", runtime.ParamLocationPath, meterSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/portal/meters/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "windowSize", runtime.ParamLocationQuery, *params.WindowSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowTimeZone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "windowTimeZone", runtime.ParamLocationQuery, *params.WindowTimeZone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterGroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filterGroupBy", runtime.ParamLocationQuery, *params.FilterGroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPortalTokensRequest generates requests for ListPortalTokens
func NewListPortalTokensRequest(server string, params *ListPortalTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/portal/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePortalTokenRequest calls the generic CreatePortalToken builder with application/json body
func NewCreatePortalTokenRequest(server string, body CreatePortalTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePortalTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePortalTokenRequestWithBody generates requests for CreatePortalToken with any type of body
func NewCreatePortalTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/portal/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInvalidatePortalTokensRequest calls the generic InvalidatePortalTokens builder with application/json body
func NewInvalidatePortalTokensRequest(server string, body InvalidatePortalTokensJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInvalidatePortalTokensRequestWithBody(server, "application/json", bodyReader)
}

// NewInvalidatePortalTokensRequestWithBody generates requests for InvalidatePortalTokens with any type of body
func NewInvalidatePortalTokensRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/portal/tokens/invalidate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSubjectsRequest generates requests for ListSubjects
func NewListSubjectsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertSubjectRequest calls the generic UpsertSubject builder with application/json body
func NewUpsertSubjectRequest(server string, body UpsertSubjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertSubjectRequestWithBody(server, "application/json", bodyReader)
}

// NewUpsertSubjectRequestWithBody generates requests for UpsertSubject with any type of body
func NewUpsertSubjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubjectRequest generates requests for DeleteSubject
func NewDeleteSubjectRequest(server string, subjectIdOrKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubjectRequest generates requests for GetSubject
func NewGetSubjectRequest(server string, subjectIdOrKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSubjectEntitlementsRequest generates requests for ListSubjectEntitlements
func NewListSubjectEntitlementsRequest(server string, subjectIdOrKey string, params *ListSubjectEntitlementsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEntitlementRequest calls the generic CreateEntitlement builder with application/json body
func NewCreateEntitlementRequest(server string, subjectIdOrKey string, body CreateEntitlementJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEntitlementRequestWithBody(server, subjectIdOrKey, "application/json", bodyReader)
}

// NewCreateEntitlementRequestWithBody generates requests for CreateEntitlement with any type of body
func NewCreateEntitlementRequestWithBody(server string, subjectIdOrKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEntitlementGrantsRequest generates requests for ListEntitlementGrants
func NewListEntitlementGrantsRequest(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *ListEntitlementGrantsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementIdOrFeatureKey", runtime.ParamLocationPath, entitlementIdOrFeatureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/grants", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGrantRequest calls the generic CreateGrant builder with application/json body
func NewCreateGrantRequest(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, body CreateGrantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGrantRequestWithBody(server, subjectIdOrKey, entitlementIdOrFeatureKey, "application/json", bodyReader)
}

// NewCreateGrantRequestWithBody generates requests for CreateGrant with any type of body
func NewCreateGrantRequestWithBody(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementIdOrFeatureKey", runtime.ParamLocationPath, entitlementIdOrFeatureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/grants", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOverrideEntitlementRequest calls the generic OverrideEntitlement builder with application/json body
func NewOverrideEntitlementRequest(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, body OverrideEntitlementJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOverrideEntitlementRequestWithBody(server, subjectIdOrKey, entitlementIdOrFeatureKey, "application/json", bodyReader)
}

// NewOverrideEntitlementRequestWithBody generates requests for OverrideEntitlement with any type of body
func NewOverrideEntitlementRequestWithBody(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementIdOrFeatureKey", runtime.ParamLocationPath, entitlementIdOrFeatureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/override", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEntitlementValueRequest generates requests for GetEntitlementValue
func NewGetEntitlementValueRequest(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *GetEntitlementValueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementIdOrFeatureKey", runtime.ParamLocationPath, entitlementIdOrFeatureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/value", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteEntitlementRequest generates requests for DeleteEntitlement
func NewDeleteEntitlementRequest(server string, subjectIdOrKey string, entitlementId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementId", runtime.ParamLocationPath, entitlementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntitlementRequest generates requests for GetEntitlement
func NewGetEntitlementRequest(server string, subjectIdOrKey string, entitlementId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementId", runtime.ParamLocationPath, entitlementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntitlementHistoryRequest generates requests for GetEntitlementHistory
func NewGetEntitlementHistoryRequest(server string, subjectIdOrKey string, entitlementId string, params *GetEntitlementHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementId", runtime.ParamLocationPath, entitlementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/history", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "windowSize", runtime.ParamLocationQuery, params.WindowSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.WindowTimeZone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "windowTimeZone", runtime.ParamLocationQuery, *params.WindowTimeZone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetEntitlementUsageRequest calls the generic ResetEntitlementUsage builder with application/json body
func NewResetEntitlementUsageRequest(server string, subjectIdOrKey string, entitlementId string, body ResetEntitlementUsageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetEntitlementUsageRequestWithBody(server, subjectIdOrKey, entitlementId, "application/json", bodyReader)
}

// NewResetEntitlementUsageRequestWithBody generates requests for ResetEntitlementUsage with any type of body
func NewResetEntitlementUsageRequestWithBody(server string, subjectIdOrKey string, entitlementId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementId", runtime.ParamLocationPath, entitlementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/reset", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAppsWithResponse request
	ListAppsWithResponse(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// UninstallAppWithResponse request
	UninstallAppWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UninstallAppResponse, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

	// CreateAppStripeCheckoutSessionWithBodyWithResponse request with any body
	CreateAppStripeCheckoutSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppStripeCheckoutSessionResponse, error)

	CreateAppStripeCheckoutSessionWithResponse(ctx context.Context, id string, body CreateAppStripeCheckoutSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppStripeCheckoutSessionResponse, error)

	// AppStripeWebhookWithBodyWithResponse request with any body
	AppStripeWebhookWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppStripeWebhookResponse, error)

	AppStripeWebhookWithResponse(ctx context.Context, id string, body AppStripeWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*AppStripeWebhookResponse, error)

	// ListCustomersWithResponse request
	ListCustomersWithResponse(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*ListCustomersResponse, error)

	// CreateCustomerWithBodyWithResponse request with any body
	CreateCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error)

	CreateCustomerWithResponse(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error)

	// DeleteCustomerWithResponse request
	DeleteCustomerWithResponse(ctx context.Context, customerIdOrKey CustomerIdentifier, reqEditors ...RequestEditorFn) (*DeleteCustomerResponse, error)

	// GetCustomerWithResponse request
	GetCustomerWithResponse(ctx context.Context, customerIdOrKey CustomerIdentifier, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error)

	// UpdateCustomerWithBodyWithResponse request with any body
	UpdateCustomerWithBodyWithResponse(ctx context.Context, customerIdOrKey CustomerIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error)

	UpdateCustomerWithResponse(ctx context.Context, customerIdOrKey CustomerIdentifier, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error)

	// GetDebugMetricsWithResponse request
	GetDebugMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDebugMetricsResponse, error)

	// ListEntitlementsWithResponse request
	ListEntitlementsWithResponse(ctx context.Context, params *ListEntitlementsParams, reqEditors ...RequestEditorFn) (*ListEntitlementsResponse, error)

	// GetEntitlementByIdWithResponse request
	GetEntitlementByIdWithResponse(ctx context.Context, entitlementId string, reqEditors ...RequestEditorFn) (*GetEntitlementByIdResponse, error)

	// ListEventsWithResponse request
	ListEventsWithResponse(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResponse, error)

	// IngestEventsWithBodyWithResponse request with any body
	IngestEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error)

	IngestEventsWithApplicationCloudeventsPlusJSONBodyWithResponse(ctx context.Context, body IngestEventsApplicationCloudeventsPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error)

	IngestEventsWithApplicationCloudeventsBatchPlusJSONBodyWithResponse(ctx context.Context, body IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error)

	// ListFeaturesWithResponse request
	ListFeaturesWithResponse(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*ListFeaturesResponse, error)

	// CreateFeatureWithBodyWithResponse request with any body
	CreateFeatureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error)

	CreateFeatureWithResponse(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error)

	// DeleteFeatureWithResponse request
	DeleteFeatureWithResponse(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*DeleteFeatureResponse, error)

	// GetFeatureWithResponse request
	GetFeatureWithResponse(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*GetFeatureResponse, error)

	// ListGrantsWithResponse request
	ListGrantsWithResponse(ctx context.Context, params *ListGrantsParams, reqEditors ...RequestEditorFn) (*ListGrantsResponse, error)

	// VoidGrantWithResponse request
	VoidGrantWithResponse(ctx context.Context, grantId string, reqEditors ...RequestEditorFn) (*VoidGrantResponse, error)

	// MarketplaceAppAPIKeyInstallWithBodyWithResponse request with any body
	MarketplaceAppAPIKeyInstallWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarketplaceAppAPIKeyInstallResponse, error)

	MarketplaceAppAPIKeyInstallWithResponse(ctx context.Context, body MarketplaceAppAPIKeyInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*MarketplaceAppAPIKeyInstallResponse, error)

	// MarketplaceOAuth2InstallGetURLWithResponse request
	MarketplaceOAuth2InstallGetURLWithResponse(ctx context.Context, params *MarketplaceOAuth2InstallGetURLParams, reqEditors ...RequestEditorFn) (*MarketplaceOAuth2InstallGetURLResponse, error)

	// MarketplaceOAuth2InstallAuthorizeWithResponse request
	MarketplaceOAuth2InstallAuthorizeWithResponse(ctx context.Context, params *MarketplaceOAuth2InstallAuthorizeParams, reqEditors ...RequestEditorFn) (*MarketplaceOAuth2InstallAuthorizeResponse, error)

	// MarketplaceListListingsWithResponse request
	MarketplaceListListingsWithResponse(ctx context.Context, params *MarketplaceListListingsParams, reqEditors ...RequestEditorFn) (*MarketplaceListListingsResponse, error)

	// ListMetersWithResponse request
	ListMetersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMetersResponse, error)

	// CreateMeterWithBodyWithResponse request with any body
	CreateMeterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMeterResponse, error)

	CreateMeterWithResponse(ctx context.Context, body CreateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMeterResponse, error)

	// DeleteMeterWithResponse request
	DeleteMeterWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*DeleteMeterResponse, error)

	// GetMeterWithResponse request
	GetMeterWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*GetMeterResponse, error)

	// QueryMeterWithResponse request
	QueryMeterWithResponse(ctx context.Context, meterIdOrSlug string, params *QueryMeterParams, reqEditors ...RequestEditorFn) (*QueryMeterResponse, error)

	// ListMeterSubjectsWithResponse request
	ListMeterSubjectsWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*ListMeterSubjectsResponse, error)

	// ListNotificationChannelsWithResponse request
	ListNotificationChannelsWithResponse(ctx context.Context, params *ListNotificationChannelsParams, reqEditors ...RequestEditorFn) (*ListNotificationChannelsResponse, error)

	// CreateNotificationChannelWithBodyWithResponse request with any body
	CreateNotificationChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error)

	CreateNotificationChannelWithResponse(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error)

	// DeleteNotificationChannelWithResponse request
	DeleteNotificationChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*DeleteNotificationChannelResponse, error)

	// GetNotificationChannelWithResponse request
	GetNotificationChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetNotificationChannelResponse, error)

	// UpdateNotificationChannelWithBodyWithResponse request with any body
	UpdateNotificationChannelWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelResponse, error)

	UpdateNotificationChannelWithResponse(ctx context.Context, channelId string, body UpdateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelResponse, error)

	// ListNotificationEventsWithResponse request
	ListNotificationEventsWithResponse(ctx context.Context, params *ListNotificationEventsParams, reqEditors ...RequestEditorFn) (*ListNotificationEventsResponse, error)

	// GetNotificationEventWithResponse request
	GetNotificationEventWithResponse(ctx context.Context, eventId string, reqEditors ...RequestEditorFn) (*GetNotificationEventResponse, error)

	// ListNotificationRulesWithResponse request
	ListNotificationRulesWithResponse(ctx context.Context, params *ListNotificationRulesParams, reqEditors ...RequestEditorFn) (*ListNotificationRulesResponse, error)

	// CreateNotificationRuleWithBodyWithResponse request with any body
	CreateNotificationRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationRuleResponse, error)

	CreateNotificationRuleWithResponse(ctx context.Context, body CreateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationRuleResponse, error)

	// DeleteNotificationRuleWithResponse request
	DeleteNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*DeleteNotificationRuleResponse, error)

	// GetNotificationRuleWithResponse request
	GetNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*GetNotificationRuleResponse, error)

	// UpdateNotificationRuleWithBodyWithResponse request with any body
	UpdateNotificationRuleWithBodyWithResponse(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationRuleResponse, error)

	UpdateNotificationRuleWithResponse(ctx context.Context, ruleId string, body UpdateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationRuleResponse, error)

	// TestNotificationRuleWithResponse request
	TestNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*TestNotificationRuleResponse, error)

	// ReceiveSvixOperationalEventWithBodyWithResponse request with any body
	ReceiveSvixOperationalEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveSvixOperationalEventResponse, error)

	ReceiveSvixOperationalEventWithResponse(ctx context.Context, body ReceiveSvixOperationalEventJSONRequestBody, reqEditors ...RequestEditorFn) (*ReceiveSvixOperationalEventResponse, error)

	// QueryPortalMeterWithResponse request
	QueryPortalMeterWithResponse(ctx context.Context, meterSlug string, params *QueryPortalMeterParams, reqEditors ...RequestEditorFn) (*QueryPortalMeterResponse, error)

	// ListPortalTokensWithResponse request
	ListPortalTokensWithResponse(ctx context.Context, params *ListPortalTokensParams, reqEditors ...RequestEditorFn) (*ListPortalTokensResponse, error)

	// CreatePortalTokenWithBodyWithResponse request with any body
	CreatePortalTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePortalTokenResponse, error)

	CreatePortalTokenWithResponse(ctx context.Context, body CreatePortalTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePortalTokenResponse, error)

	// InvalidatePortalTokensWithBodyWithResponse request with any body
	InvalidatePortalTokensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvalidatePortalTokensResponse, error)

	InvalidatePortalTokensWithResponse(ctx context.Context, body InvalidatePortalTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*InvalidatePortalTokensResponse, error)

	// ListSubjectsWithResponse request
	ListSubjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSubjectsResponse, error)

	// UpsertSubjectWithBodyWithResponse request with any body
	UpsertSubjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertSubjectResponse, error)

	UpsertSubjectWithResponse(ctx context.Context, body UpsertSubjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertSubjectResponse, error)

	// DeleteSubjectWithResponse request
	DeleteSubjectWithResponse(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*DeleteSubjectResponse, error)

	// GetSubjectWithResponse request
	GetSubjectWithResponse(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*GetSubjectResponse, error)

	// ListSubjectEntitlementsWithResponse request
	ListSubjectEntitlementsWithResponse(ctx context.Context, subjectIdOrKey string, params *ListSubjectEntitlementsParams, reqEditors ...RequestEditorFn) (*ListSubjectEntitlementsResponse, error)

	// CreateEntitlementWithBodyWithResponse request with any body
	CreateEntitlementWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEntitlementResponse, error)

	CreateEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, body CreateEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEntitlementResponse, error)

	// ListEntitlementGrantsWithResponse request
	ListEntitlementGrantsWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *ListEntitlementGrantsParams, reqEditors ...RequestEditorFn) (*ListEntitlementGrantsResponse, error)

	// CreateGrantWithBodyWithResponse request with any body
	CreateGrantWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error)

	CreateGrantWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error)

	// OverrideEntitlementWithBodyWithResponse request with any body
	OverrideEntitlementWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OverrideEntitlementResponse, error)

	OverrideEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body OverrideEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*OverrideEntitlementResponse, error)

	// GetEntitlementValueWithResponse request
	GetEntitlementValueWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *GetEntitlementValueParams, reqEditors ...RequestEditorFn) (*GetEntitlementValueResponse, error)

	// DeleteEntitlementWithResponse request
	DeleteEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*DeleteEntitlementResponse, error)

	// GetEntitlementWithResponse request
	GetEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*GetEntitlementResponse, error)

	// GetEntitlementHistoryWithResponse request
	GetEntitlementHistoryWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, params *GetEntitlementHistoryParams, reqEditors ...RequestEditorFn) (*GetEntitlementHistoryResponse, error)

	// ResetEntitlementUsageWithBodyWithResponse request with any body
	ResetEntitlementUsageWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetEntitlementUsageResponse, error)

	ResetEntitlementUsageWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, body ResetEntitlementUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetEntitlementUsageResponse, error)
}

type ListAppsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]AppList
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallAppResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *App
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UninstallAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *App
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppStripeCheckoutSessionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *CreateStripeCheckoutSessionResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateAppStripeCheckoutSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppStripeCheckoutSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStripeWebhookResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *StripeWebhookResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r AppStripeWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStripeWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]CustomerList
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomerResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Customer
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomerResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Customer
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Customer
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomerResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Customer
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDebugMetricsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetDebugMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDebugMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEntitlementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListEntitlementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEntitlementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntitlementByIdResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Entitlement
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetEntitlementByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntitlementByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]IngestedEvent
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IngestEventsResponse struct {
	Body                               []byte
	HTTPResponse                       *http.Response
	ApplicationcloudeventsJSON200      *Event
	ApplicationcloudeventsBatchJSON200 *[]Event
	ApplicationproblemJSON400          *BadRequestProblemResponse
	ApplicationproblemJSON401          *UnauthorizedProblemResponse
	ApplicationproblemJSON403          *ForbiddenProblemResponse
	ApplicationproblemJSON500          *InternalServerErrorProblemResponse
	ApplicationproblemJSON503          *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault      *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r IngestEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IngestEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFeatureResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Feature
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFeatureResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeatureResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Feature
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGrantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListGrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VoidGrantResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r VoidGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VoidGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarketplaceAppAPIKeyInstallResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *AppBase
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r MarketplaceAppAPIKeyInstallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarketplaceAppAPIKeyInstallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarketplaceOAuth2InstallGetURLResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *ClientAppStartResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r MarketplaceOAuth2InstallGetURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarketplaceOAuth2InstallGetURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarketplaceOAuth2InstallAuthorizeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r MarketplaceOAuth2InstallAuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarketplaceOAuth2InstallAuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarketplaceListListingsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *ListingList
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r MarketplaceListListingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarketplaceListListingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMetersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]Meter
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListMetersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Meter
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Meter
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MeterQueryResult
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r QueryMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMeterSubjectsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]string
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListMeterSubjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMeterSubjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNotificationChannelsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationChannelPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListNotificationChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNotificationChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNotificationChannelResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *NotificationChannel
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateNotificationChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNotificationChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationChannelResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationChannelResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationChannel
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetNotificationChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNotificationChannelResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationChannel
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateNotificationChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNotificationChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNotificationEventsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationEventPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListNotificationEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNotificationEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationEventResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Event
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetNotificationEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNotificationRulesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationRulePaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListNotificationRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNotificationRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNotificationRuleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *NotificationRule
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateNotificationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNotificationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationRuleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationRuleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationRule
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetNotificationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNotificationRuleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationRule
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateNotificationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNotificationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestNotificationRuleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Event
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r TestNotificationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestNotificationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiveSvixOperationalEventResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ReceiveSvixOperationalEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiveSvixOperationalEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryPortalMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MeterQueryResult
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r QueryPortalMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryPortalMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPortalTokensResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]PortalToken
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListPortalTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPortalTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePortalTokenResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *PortalToken
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreatePortalTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePortalTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InvalidatePortalTokensResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r InvalidatePortalTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InvalidatePortalTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSubjectsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]Subject
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListSubjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSubjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertSubjectResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]Subject
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpsertSubjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertSubjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubjectResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteSubjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubjectResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Subject
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetSubjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSubjectEntitlementsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]Entitlement
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListSubjectEntitlementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSubjectEntitlementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEntitlementResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *EntitlementCreateInputs
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateEntitlementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEntitlementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEntitlementGrantsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]EntitlementGrant
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListEntitlementGrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEntitlementGrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGrantResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *EntitlementGrant
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OverrideEntitlementResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Entitlement
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r OverrideEntitlementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OverrideEntitlementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntitlementValueResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *EntitlementValue
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetEntitlementValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntitlementValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEntitlementResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteEntitlementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEntitlementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntitlementResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Entitlement
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetEntitlementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntitlementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntitlementHistoryResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *WindowedBalanceHistory
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetEntitlementHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntitlementHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetEntitlementUsageResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ResetEntitlementUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetEntitlementUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// UninstallAppWithResponse request returning *UninstallAppResponse
func (c *ClientWithResponses) UninstallAppWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UninstallAppResponse, error) {
	rsp, err := c.UninstallApp(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallAppResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAppResponse, error) {
	rsp, err := c.GetApp(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResponse(rsp)
}

// CreateAppStripeCheckoutSessionWithBodyWithResponse request with arbitrary body returning *CreateAppStripeCheckoutSessionResponse
func (c *ClientWithResponses) CreateAppStripeCheckoutSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppStripeCheckoutSessionResponse, error) {
	rsp, err := c.CreateAppStripeCheckoutSessionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppStripeCheckoutSessionResponse(rsp)
}

func (c *ClientWithResponses) CreateAppStripeCheckoutSessionWithResponse(ctx context.Context, id string, body CreateAppStripeCheckoutSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppStripeCheckoutSessionResponse, error) {
	rsp, err := c.CreateAppStripeCheckoutSession(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppStripeCheckoutSessionResponse(rsp)
}

// AppStripeWebhookWithBodyWithResponse request with arbitrary body returning *AppStripeWebhookResponse
func (c *ClientWithResponses) AppStripeWebhookWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppStripeWebhookResponse, error) {
	rsp, err := c.AppStripeWebhookWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppStripeWebhookResponse(rsp)
}

func (c *ClientWithResponses) AppStripeWebhookWithResponse(ctx context.Context, id string, body AppStripeWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*AppStripeWebhookResponse, error) {
	rsp, err := c.AppStripeWebhook(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppStripeWebhookResponse(rsp)
}

// ListCustomersWithResponse request returning *ListCustomersResponse
func (c *ClientWithResponses) ListCustomersWithResponse(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*ListCustomersResponse, error) {
	rsp, err := c.ListCustomers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomersResponse(rsp)
}

// CreateCustomerWithBodyWithResponse request with arbitrary body returning *CreateCustomerResponse
func (c *ClientWithResponses) CreateCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error) {
	rsp, err := c.CreateCustomerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomerWithResponse(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error) {
	rsp, err := c.CreateCustomer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerResponse(rsp)
}

// DeleteCustomerWithResponse request returning *DeleteCustomerResponse
func (c *ClientWithResponses) DeleteCustomerWithResponse(ctx context.Context, customerIdOrKey CustomerIdentifier, reqEditors ...RequestEditorFn) (*DeleteCustomerResponse, error) {
	rsp, err := c.DeleteCustomer(ctx, customerIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomerResponse(rsp)
}

// GetCustomerWithResponse request returning *GetCustomerResponse
func (c *ClientWithResponses) GetCustomerWithResponse(ctx context.Context, customerIdOrKey CustomerIdentifier, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error) {
	rsp, err := c.GetCustomer(ctx, customerIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerResponse(rsp)
}

// UpdateCustomerWithBodyWithResponse request with arbitrary body returning *UpdateCustomerResponse
func (c *ClientWithResponses) UpdateCustomerWithBodyWithResponse(ctx context.Context, customerIdOrKey CustomerIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error) {
	rsp, err := c.UpdateCustomerWithBody(ctx, customerIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomerWithResponse(ctx context.Context, customerIdOrKey CustomerIdentifier, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error) {
	rsp, err := c.UpdateCustomer(ctx, customerIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerResponse(rsp)
}

// GetDebugMetricsWithResponse request returning *GetDebugMetricsResponse
func (c *ClientWithResponses) GetDebugMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDebugMetricsResponse, error) {
	rsp, err := c.GetDebugMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDebugMetricsResponse(rsp)
}

// ListEntitlementsWithResponse request returning *ListEntitlementsResponse
func (c *ClientWithResponses) ListEntitlementsWithResponse(ctx context.Context, params *ListEntitlementsParams, reqEditors ...RequestEditorFn) (*ListEntitlementsResponse, error) {
	rsp, err := c.ListEntitlements(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEntitlementsResponse(rsp)
}

// GetEntitlementByIdWithResponse request returning *GetEntitlementByIdResponse
func (c *ClientWithResponses) GetEntitlementByIdWithResponse(ctx context.Context, entitlementId string, reqEditors ...RequestEditorFn) (*GetEntitlementByIdResponse, error) {
	rsp, err := c.GetEntitlementById(ctx, entitlementId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntitlementByIdResponse(rsp)
}

// ListEventsWithResponse request returning *ListEventsResponse
func (c *ClientWithResponses) ListEventsWithResponse(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResponse, error) {
	rsp, err := c.ListEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsResponse(rsp)
}

// IngestEventsWithBodyWithResponse request with arbitrary body returning *IngestEventsResponse
func (c *ClientWithResponses) IngestEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error) {
	rsp, err := c.IngestEventsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestEventsResponse(rsp)
}

func (c *ClientWithResponses) IngestEventsWithApplicationCloudeventsPlusJSONBodyWithResponse(ctx context.Context, body IngestEventsApplicationCloudeventsPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error) {
	rsp, err := c.IngestEventsWithApplicationCloudeventsPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestEventsResponse(rsp)
}

func (c *ClientWithResponses) IngestEventsWithApplicationCloudeventsBatchPlusJSONBodyWithResponse(ctx context.Context, body IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error) {
	rsp, err := c.IngestEventsWithApplicationCloudeventsBatchPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestEventsResponse(rsp)
}

// ListFeaturesWithResponse request returning *ListFeaturesResponse
func (c *ClientWithResponses) ListFeaturesWithResponse(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*ListFeaturesResponse, error) {
	rsp, err := c.ListFeatures(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFeaturesResponse(rsp)
}

// CreateFeatureWithBodyWithResponse request with arbitrary body returning *CreateFeatureResponse
func (c *ClientWithResponses) CreateFeatureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error) {
	rsp, err := c.CreateFeatureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFeatureResponse(rsp)
}

func (c *ClientWithResponses) CreateFeatureWithResponse(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error) {
	rsp, err := c.CreateFeature(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFeatureResponse(rsp)
}

// DeleteFeatureWithResponse request returning *DeleteFeatureResponse
func (c *ClientWithResponses) DeleteFeatureWithResponse(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*DeleteFeatureResponse, error) {
	rsp, err := c.DeleteFeature(ctx, featureId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFeatureResponse(rsp)
}

// GetFeatureWithResponse request returning *GetFeatureResponse
func (c *ClientWithResponses) GetFeatureWithResponse(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*GetFeatureResponse, error) {
	rsp, err := c.GetFeature(ctx, featureId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeatureResponse(rsp)
}

// ListGrantsWithResponse request returning *ListGrantsResponse
func (c *ClientWithResponses) ListGrantsWithResponse(ctx context.Context, params *ListGrantsParams, reqEditors ...RequestEditorFn) (*ListGrantsResponse, error) {
	rsp, err := c.ListGrants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGrantsResponse(rsp)
}

// VoidGrantWithResponse request returning *VoidGrantResponse
func (c *ClientWithResponses) VoidGrantWithResponse(ctx context.Context, grantId string, reqEditors ...RequestEditorFn) (*VoidGrantResponse, error) {
	rsp, err := c.VoidGrant(ctx, grantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVoidGrantResponse(rsp)
}

// MarketplaceAppAPIKeyInstallWithBodyWithResponse request with arbitrary body returning *MarketplaceAppAPIKeyInstallResponse
func (c *ClientWithResponses) MarketplaceAppAPIKeyInstallWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarketplaceAppAPIKeyInstallResponse, error) {
	rsp, err := c.MarketplaceAppAPIKeyInstallWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceAppAPIKeyInstallResponse(rsp)
}

func (c *ClientWithResponses) MarketplaceAppAPIKeyInstallWithResponse(ctx context.Context, body MarketplaceAppAPIKeyInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*MarketplaceAppAPIKeyInstallResponse, error) {
	rsp, err := c.MarketplaceAppAPIKeyInstall(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceAppAPIKeyInstallResponse(rsp)
}

// MarketplaceOAuth2InstallGetURLWithResponse request returning *MarketplaceOAuth2InstallGetURLResponse
func (c *ClientWithResponses) MarketplaceOAuth2InstallGetURLWithResponse(ctx context.Context, params *MarketplaceOAuth2InstallGetURLParams, reqEditors ...RequestEditorFn) (*MarketplaceOAuth2InstallGetURLResponse, error) {
	rsp, err := c.MarketplaceOAuth2InstallGetURL(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceOAuth2InstallGetURLResponse(rsp)
}

// MarketplaceOAuth2InstallAuthorizeWithResponse request returning *MarketplaceOAuth2InstallAuthorizeResponse
func (c *ClientWithResponses) MarketplaceOAuth2InstallAuthorizeWithResponse(ctx context.Context, params *MarketplaceOAuth2InstallAuthorizeParams, reqEditors ...RequestEditorFn) (*MarketplaceOAuth2InstallAuthorizeResponse, error) {
	rsp, err := c.MarketplaceOAuth2InstallAuthorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceOAuth2InstallAuthorizeResponse(rsp)
}

// MarketplaceListListingsWithResponse request returning *MarketplaceListListingsResponse
func (c *ClientWithResponses) MarketplaceListListingsWithResponse(ctx context.Context, params *MarketplaceListListingsParams, reqEditors ...RequestEditorFn) (*MarketplaceListListingsResponse, error) {
	rsp, err := c.MarketplaceListListings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceListListingsResponse(rsp)
}

// ListMetersWithResponse request returning *ListMetersResponse
func (c *ClientWithResponses) ListMetersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMetersResponse, error) {
	rsp, err := c.ListMeters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMetersResponse(rsp)
}

// CreateMeterWithBodyWithResponse request with arbitrary body returning *CreateMeterResponse
func (c *ClientWithResponses) CreateMeterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMeterResponse, error) {
	rsp, err := c.CreateMeterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMeterResponse(rsp)
}

func (c *ClientWithResponses) CreateMeterWithResponse(ctx context.Context, body CreateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMeterResponse, error) {
	rsp, err := c.CreateMeter(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMeterResponse(rsp)
}

// DeleteMeterWithResponse request returning *DeleteMeterResponse
func (c *ClientWithResponses) DeleteMeterWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*DeleteMeterResponse, error) {
	rsp, err := c.DeleteMeter(ctx, meterIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMeterResponse(rsp)
}

// GetMeterWithResponse request returning *GetMeterResponse
func (c *ClientWithResponses) GetMeterWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*GetMeterResponse, error) {
	rsp, err := c.GetMeter(ctx, meterIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeterResponse(rsp)
}

// QueryMeterWithResponse request returning *QueryMeterResponse
func (c *ClientWithResponses) QueryMeterWithResponse(ctx context.Context, meterIdOrSlug string, params *QueryMeterParams, reqEditors ...RequestEditorFn) (*QueryMeterResponse, error) {
	rsp, err := c.QueryMeter(ctx, meterIdOrSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryMeterResponse(rsp)
}

// ListMeterSubjectsWithResponse request returning *ListMeterSubjectsResponse
func (c *ClientWithResponses) ListMeterSubjectsWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*ListMeterSubjectsResponse, error) {
	rsp, err := c.ListMeterSubjects(ctx, meterIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMeterSubjectsResponse(rsp)
}

// ListNotificationChannelsWithResponse request returning *ListNotificationChannelsResponse
func (c *ClientWithResponses) ListNotificationChannelsWithResponse(ctx context.Context, params *ListNotificationChannelsParams, reqEditors ...RequestEditorFn) (*ListNotificationChannelsResponse, error) {
	rsp, err := c.ListNotificationChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNotificationChannelsResponse(rsp)
}

// CreateNotificationChannelWithBodyWithResponse request with arbitrary body returning *CreateNotificationChannelResponse
func (c *ClientWithResponses) CreateNotificationChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error) {
	rsp, err := c.CreateNotificationChannelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationChannelResponse(rsp)
}

func (c *ClientWithResponses) CreateNotificationChannelWithResponse(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error) {
	rsp, err := c.CreateNotificationChannel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationChannelResponse(rsp)
}

// DeleteNotificationChannelWithResponse request returning *DeleteNotificationChannelResponse
func (c *ClientWithResponses) DeleteNotificationChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*DeleteNotificationChannelResponse, error) {
	rsp, err := c.DeleteNotificationChannel(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationChannelResponse(rsp)
}

// GetNotificationChannelWithResponse request returning *GetNotificationChannelResponse
func (c *ClientWithResponses) GetNotificationChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetNotificationChannelResponse, error) {
	rsp, err := c.GetNotificationChannel(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationChannelResponse(rsp)
}

// UpdateNotificationChannelWithBodyWithResponse request with arbitrary body returning *UpdateNotificationChannelResponse
func (c *ClientWithResponses) UpdateNotificationChannelWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelResponse, error) {
	rsp, err := c.UpdateNotificationChannelWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationChannelResponse(rsp)
}

func (c *ClientWithResponses) UpdateNotificationChannelWithResponse(ctx context.Context, channelId string, body UpdateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelResponse, error) {
	rsp, err := c.UpdateNotificationChannel(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationChannelResponse(rsp)
}

// ListNotificationEventsWithResponse request returning *ListNotificationEventsResponse
func (c *ClientWithResponses) ListNotificationEventsWithResponse(ctx context.Context, params *ListNotificationEventsParams, reqEditors ...RequestEditorFn) (*ListNotificationEventsResponse, error) {
	rsp, err := c.ListNotificationEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNotificationEventsResponse(rsp)
}

// GetNotificationEventWithResponse request returning *GetNotificationEventResponse
func (c *ClientWithResponses) GetNotificationEventWithResponse(ctx context.Context, eventId string, reqEditors ...RequestEditorFn) (*GetNotificationEventResponse, error) {
	rsp, err := c.GetNotificationEvent(ctx, eventId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationEventResponse(rsp)
}

// ListNotificationRulesWithResponse request returning *ListNotificationRulesResponse
func (c *ClientWithResponses) ListNotificationRulesWithResponse(ctx context.Context, params *ListNotificationRulesParams, reqEditors ...RequestEditorFn) (*ListNotificationRulesResponse, error) {
	rsp, err := c.ListNotificationRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNotificationRulesResponse(rsp)
}

// CreateNotificationRuleWithBodyWithResponse request with arbitrary body returning *CreateNotificationRuleResponse
func (c *ClientWithResponses) CreateNotificationRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationRuleResponse, error) {
	rsp, err := c.CreateNotificationRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateNotificationRuleWithResponse(ctx context.Context, body CreateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationRuleResponse, error) {
	rsp, err := c.CreateNotificationRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationRuleResponse(rsp)
}

// DeleteNotificationRuleWithResponse request returning *DeleteNotificationRuleResponse
func (c *ClientWithResponses) DeleteNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*DeleteNotificationRuleResponse, error) {
	rsp, err := c.DeleteNotificationRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationRuleResponse(rsp)
}

// GetNotificationRuleWithResponse request returning *GetNotificationRuleResponse
func (c *ClientWithResponses) GetNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*GetNotificationRuleResponse, error) {
	rsp, err := c.GetNotificationRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationRuleResponse(rsp)
}

// UpdateNotificationRuleWithBodyWithResponse request with arbitrary body returning *UpdateNotificationRuleResponse
func (c *ClientWithResponses) UpdateNotificationRuleWithBodyWithResponse(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationRuleResponse, error) {
	rsp, err := c.UpdateNotificationRuleWithBody(ctx, ruleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateNotificationRuleWithResponse(ctx context.Context, ruleId string, body UpdateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationRuleResponse, error) {
	rsp, err := c.UpdateNotificationRule(ctx, ruleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationRuleResponse(rsp)
}

// TestNotificationRuleWithResponse request returning *TestNotificationRuleResponse
func (c *ClientWithResponses) TestNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*TestNotificationRuleResponse, error) {
	rsp, err := c.TestNotificationRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestNotificationRuleResponse(rsp)
}

// ReceiveSvixOperationalEventWithBodyWithResponse request with arbitrary body returning *ReceiveSvixOperationalEventResponse
func (c *ClientWithResponses) ReceiveSvixOperationalEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveSvixOperationalEventResponse, error) {
	rsp, err := c.ReceiveSvixOperationalEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveSvixOperationalEventResponse(rsp)
}

func (c *ClientWithResponses) ReceiveSvixOperationalEventWithResponse(ctx context.Context, body ReceiveSvixOperationalEventJSONRequestBody, reqEditors ...RequestEditorFn) (*ReceiveSvixOperationalEventResponse, error) {
	rsp, err := c.ReceiveSvixOperationalEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveSvixOperationalEventResponse(rsp)
}

// QueryPortalMeterWithResponse request returning *QueryPortalMeterResponse
func (c *ClientWithResponses) QueryPortalMeterWithResponse(ctx context.Context, meterSlug string, params *QueryPortalMeterParams, reqEditors ...RequestEditorFn) (*QueryPortalMeterResponse, error) {
	rsp, err := c.QueryPortalMeter(ctx, meterSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryPortalMeterResponse(rsp)
}

// ListPortalTokensWithResponse request returning *ListPortalTokensResponse
func (c *ClientWithResponses) ListPortalTokensWithResponse(ctx context.Context, params *ListPortalTokensParams, reqEditors ...RequestEditorFn) (*ListPortalTokensResponse, error) {
	rsp, err := c.ListPortalTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPortalTokensResponse(rsp)
}

// CreatePortalTokenWithBodyWithResponse request with arbitrary body returning *CreatePortalTokenResponse
func (c *ClientWithResponses) CreatePortalTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePortalTokenResponse, error) {
	rsp, err := c.CreatePortalTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePortalTokenResponse(rsp)
}

func (c *ClientWithResponses) CreatePortalTokenWithResponse(ctx context.Context, body CreatePortalTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePortalTokenResponse, error) {
	rsp, err := c.CreatePortalToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePortalTokenResponse(rsp)
}

// InvalidatePortalTokensWithBodyWithResponse request with arbitrary body returning *InvalidatePortalTokensResponse
func (c *ClientWithResponses) InvalidatePortalTokensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvalidatePortalTokensResponse, error) {
	rsp, err := c.InvalidatePortalTokensWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvalidatePortalTokensResponse(rsp)
}

func (c *ClientWithResponses) InvalidatePortalTokensWithResponse(ctx context.Context, body InvalidatePortalTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*InvalidatePortalTokensResponse, error) {
	rsp, err := c.InvalidatePortalTokens(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvalidatePortalTokensResponse(rsp)
}

// ListSubjectsWithResponse request returning *ListSubjectsResponse
func (c *ClientWithResponses) ListSubjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSubjectsResponse, error) {
	rsp, err := c.ListSubjects(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSubjectsResponse(rsp)
}

// UpsertSubjectWithBodyWithResponse request with arbitrary body returning *UpsertSubjectResponse
func (c *ClientWithResponses) UpsertSubjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertSubjectResponse, error) {
	rsp, err := c.UpsertSubjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertSubjectResponse(rsp)
}

func (c *ClientWithResponses) UpsertSubjectWithResponse(ctx context.Context, body UpsertSubjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertSubjectResponse, error) {
	rsp, err := c.UpsertSubject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertSubjectResponse(rsp)
}

// DeleteSubjectWithResponse request returning *DeleteSubjectResponse
func (c *ClientWithResponses) DeleteSubjectWithResponse(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*DeleteSubjectResponse, error) {
	rsp, err := c.DeleteSubject(ctx, subjectIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubjectResponse(rsp)
}

// GetSubjectWithResponse request returning *GetSubjectResponse
func (c *ClientWithResponses) GetSubjectWithResponse(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*GetSubjectResponse, error) {
	rsp, err := c.GetSubject(ctx, subjectIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubjectResponse(rsp)
}

// ListSubjectEntitlementsWithResponse request returning *ListSubjectEntitlementsResponse
func (c *ClientWithResponses) ListSubjectEntitlementsWithResponse(ctx context.Context, subjectIdOrKey string, params *ListSubjectEntitlementsParams, reqEditors ...RequestEditorFn) (*ListSubjectEntitlementsResponse, error) {
	rsp, err := c.ListSubjectEntitlements(ctx, subjectIdOrKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSubjectEntitlementsResponse(rsp)
}

// CreateEntitlementWithBodyWithResponse request with arbitrary body returning *CreateEntitlementResponse
func (c *ClientWithResponses) CreateEntitlementWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEntitlementResponse, error) {
	rsp, err := c.CreateEntitlementWithBody(ctx, subjectIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEntitlementResponse(rsp)
}

func (c *ClientWithResponses) CreateEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, body CreateEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEntitlementResponse, error) {
	rsp, err := c.CreateEntitlement(ctx, subjectIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEntitlementResponse(rsp)
}

// ListEntitlementGrantsWithResponse request returning *ListEntitlementGrantsResponse
func (c *ClientWithResponses) ListEntitlementGrantsWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *ListEntitlementGrantsParams, reqEditors ...RequestEditorFn) (*ListEntitlementGrantsResponse, error) {
	rsp, err := c.ListEntitlementGrants(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEntitlementGrantsResponse(rsp)
}

// CreateGrantWithBodyWithResponse request with arbitrary body returning *CreateGrantResponse
func (c *ClientWithResponses) CreateGrantWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error) {
	rsp, err := c.CreateGrantWithBody(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGrantResponse(rsp)
}

func (c *ClientWithResponses) CreateGrantWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error) {
	rsp, err := c.CreateGrant(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGrantResponse(rsp)
}

// OverrideEntitlementWithBodyWithResponse request with arbitrary body returning *OverrideEntitlementResponse
func (c *ClientWithResponses) OverrideEntitlementWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OverrideEntitlementResponse, error) {
	rsp, err := c.OverrideEntitlementWithBody(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOverrideEntitlementResponse(rsp)
}

func (c *ClientWithResponses) OverrideEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body OverrideEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*OverrideEntitlementResponse, error) {
	rsp, err := c.OverrideEntitlement(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOverrideEntitlementResponse(rsp)
}

// GetEntitlementValueWithResponse request returning *GetEntitlementValueResponse
func (c *ClientWithResponses) GetEntitlementValueWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *GetEntitlementValueParams, reqEditors ...RequestEditorFn) (*GetEntitlementValueResponse, error) {
	rsp, err := c.GetEntitlementValue(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntitlementValueResponse(rsp)
}

// DeleteEntitlementWithResponse request returning *DeleteEntitlementResponse
func (c *ClientWithResponses) DeleteEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*DeleteEntitlementResponse, error) {
	rsp, err := c.DeleteEntitlement(ctx, subjectIdOrKey, entitlementId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEntitlementResponse(rsp)
}

// GetEntitlementWithResponse request returning *GetEntitlementResponse
func (c *ClientWithResponses) GetEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*GetEntitlementResponse, error) {
	rsp, err := c.GetEntitlement(ctx, subjectIdOrKey, entitlementId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntitlementResponse(rsp)
}

// GetEntitlementHistoryWithResponse request returning *GetEntitlementHistoryResponse
func (c *ClientWithResponses) GetEntitlementHistoryWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, params *GetEntitlementHistoryParams, reqEditors ...RequestEditorFn) (*GetEntitlementHistoryResponse, error) {
	rsp, err := c.GetEntitlementHistory(ctx, subjectIdOrKey, entitlementId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntitlementHistoryResponse(rsp)
}

// ResetEntitlementUsageWithBodyWithResponse request with arbitrary body returning *ResetEntitlementUsageResponse
func (c *ClientWithResponses) ResetEntitlementUsageWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetEntitlementUsageResponse, error) {
	rsp, err := c.ResetEntitlementUsageWithBody(ctx, subjectIdOrKey, entitlementId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetEntitlementUsageResponse(rsp)
}

func (c *ClientWithResponses) ResetEntitlementUsageWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, body ResetEntitlementUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetEntitlementUsageResponse, error) {
	rsp, err := c.ResetEntitlementUsage(ctx, subjectIdOrKey, entitlementId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetEntitlementUsageResponse(rsp)
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AppList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUninstallAppResponse parses an HTTP response from a UninstallAppWithResponse call
func ParseUninstallAppResponse(rsp *http.Response) (*UninstallAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UninstallAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAppStripeCheckoutSessionResponse parses an HTTP response from a CreateAppStripeCheckoutSessionWithResponse call
func ParseCreateAppStripeCheckoutSessionResponse(rsp *http.Response) (*CreateAppStripeCheckoutSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppStripeCheckoutSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateStripeCheckoutSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseAppStripeWebhookResponse parses an HTTP response from a AppStripeWebhookWithResponse call
func ParseAppStripeWebhookResponse(rsp *http.Response) (*AppStripeWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppStripeWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StripeWebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListCustomersResponse parses an HTTP response from a ListCustomersWithResponse call
func ParseListCustomersResponse(rsp *http.Response) (*ListCustomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CustomerList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCustomerResponse parses an HTTP response from a CreateCustomerWithResponse call
func ParseCreateCustomerResponse(rsp *http.Response) (*CreateCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCustomerResponse parses an HTTP response from a DeleteCustomerWithResponse call
func ParseDeleteCustomerResponse(rsp *http.Response) (*DeleteCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetCustomerResponse parses an HTTP response from a GetCustomerWithResponse call
func ParseGetCustomerResponse(rsp *http.Response) (*GetCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateCustomerResponse parses an HTTP response from a UpdateCustomerWithResponse call
func ParseUpdateCustomerResponse(rsp *http.Response) (*UpdateCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetDebugMetricsResponse parses an HTTP response from a GetDebugMetricsWithResponse call
func ParseGetDebugMetricsResponse(rsp *http.Response) (*GetDebugMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDebugMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListEntitlementsResponse parses an HTTP response from a ListEntitlementsWithResponse call
func ParseListEntitlementsResponse(rsp *http.Response) (*ListEntitlementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEntitlementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntitlementByIdResponse parses an HTTP response from a GetEntitlementByIdWithResponse call
func ParseGetEntitlementByIdResponse(rsp *http.Response) (*GetEntitlementByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntitlementByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entitlement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListEventsResponse parses an HTTP response from a ListEventsWithResponse call
func ParseListEventsResponse(rsp *http.Response) (*ListEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IngestedEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseIngestEventsResponse parses an HTTP response from a IngestEventsWithResponse call
func ParseIngestEventsResponse(rsp *http.Response) (*IngestEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IngestEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/cloudevents+json" && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationcloudeventsJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/cloudevents-batch+json" && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationcloudeventsBatchJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListFeaturesResponse parses an HTTP response from a ListFeaturesWithResponse call
func ParseListFeaturesResponse(rsp *http.Response) (*ListFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFeatureResponse parses an HTTP response from a CreateFeatureWithResponse call
func ParseCreateFeatureResponse(rsp *http.Response) (*CreateFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Feature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFeatureResponse parses an HTTP response from a DeleteFeatureWithResponse call
func ParseDeleteFeatureResponse(rsp *http.Response) (*DeleteFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetFeatureResponse parses an HTTP response from a GetFeatureWithResponse call
func ParseGetFeatureResponse(rsp *http.Response) (*GetFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Feature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListGrantsResponse parses an HTTP response from a ListGrantsWithResponse call
func ParseListGrantsResponse(rsp *http.Response) (*ListGrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseVoidGrantResponse parses an HTTP response from a VoidGrantWithResponse call
func ParseVoidGrantResponse(rsp *http.Response) (*VoidGrantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VoidGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMarketplaceAppAPIKeyInstallResponse parses an HTTP response from a MarketplaceAppAPIKeyInstallWithResponse call
func ParseMarketplaceAppAPIKeyInstallResponse(rsp *http.Response) (*MarketplaceAppAPIKeyInstallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarketplaceAppAPIKeyInstallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppBase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMarketplaceOAuth2InstallGetURLResponse parses an HTTP response from a MarketplaceOAuth2InstallGetURLWithResponse call
func ParseMarketplaceOAuth2InstallGetURLResponse(rsp *http.Response) (*MarketplaceOAuth2InstallGetURLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarketplaceOAuth2InstallGetURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientAppStartResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMarketplaceOAuth2InstallAuthorizeResponse parses an HTTP response from a MarketplaceOAuth2InstallAuthorizeWithResponse call
func ParseMarketplaceOAuth2InstallAuthorizeResponse(rsp *http.Response) (*MarketplaceOAuth2InstallAuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarketplaceOAuth2InstallAuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMarketplaceListListingsResponse parses an HTTP response from a MarketplaceListListingsWithResponse call
func ParseMarketplaceListListingsResponse(rsp *http.Response) (*MarketplaceListListingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarketplaceListListingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListMetersResponse parses an HTTP response from a ListMetersWithResponse call
func ParseListMetersResponse(rsp *http.Response) (*ListMetersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMetersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Meter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateMeterResponse parses an HTTP response from a CreateMeterWithResponse call
func ParseCreateMeterResponse(rsp *http.Response) (*CreateMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Meter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMeterResponse parses an HTTP response from a DeleteMeterWithResponse call
func ParseDeleteMeterResponse(rsp *http.Response) (*DeleteMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetMeterResponse parses an HTTP response from a GetMeterWithResponse call
func ParseGetMeterResponse(rsp *http.Response) (*GetMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Meter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseQueryMeterResponse parses an HTTP response from a QueryMeterWithResponse call
func ParseQueryMeterResponse(rsp *http.Response) (*QueryMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeterQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListMeterSubjectsResponse parses an HTTP response from a ListMeterSubjectsWithResponse call
func ParseListMeterSubjectsResponse(rsp *http.Response) (*ListMeterSubjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMeterSubjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListNotificationChannelsResponse parses an HTTP response from a ListNotificationChannelsWithResponse call
func ParseListNotificationChannelsResponse(rsp *http.Response) (*ListNotificationChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNotificationChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationChannelPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNotificationChannelResponse parses an HTTP response from a CreateNotificationChannelWithResponse call
func ParseCreateNotificationChannelResponse(rsp *http.Response) (*CreateNotificationChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNotificationChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NotificationChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteNotificationChannelResponse parses an HTTP response from a DeleteNotificationChannelWithResponse call
func ParseDeleteNotificationChannelResponse(rsp *http.Response) (*DeleteNotificationChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetNotificationChannelResponse parses an HTTP response from a GetNotificationChannelWithResponse call
func ParseGetNotificationChannelResponse(rsp *http.Response) (*GetNotificationChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateNotificationChannelResponse parses an HTTP response from a UpdateNotificationChannelWithResponse call
func ParseUpdateNotificationChannelResponse(rsp *http.Response) (*UpdateNotificationChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNotificationChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListNotificationEventsResponse parses an HTTP response from a ListNotificationEventsWithResponse call
func ParseListNotificationEventsResponse(rsp *http.Response) (*ListNotificationEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNotificationEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationEventPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetNotificationEventResponse parses an HTTP response from a GetNotificationEventWithResponse call
func ParseGetNotificationEventResponse(rsp *http.Response) (*GetNotificationEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListNotificationRulesResponse parses an HTTP response from a ListNotificationRulesWithResponse call
func ParseListNotificationRulesResponse(rsp *http.Response) (*ListNotificationRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNotificationRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationRulePaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNotificationRuleResponse parses an HTTP response from a CreateNotificationRuleWithResponse call
func ParseCreateNotificationRuleResponse(rsp *http.Response) (*CreateNotificationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNotificationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NotificationRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteNotificationRuleResponse parses an HTTP response from a DeleteNotificationRuleWithResponse call
func ParseDeleteNotificationRuleResponse(rsp *http.Response) (*DeleteNotificationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetNotificationRuleResponse parses an HTTP response from a GetNotificationRuleWithResponse call
func ParseGetNotificationRuleResponse(rsp *http.Response) (*GetNotificationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateNotificationRuleResponse parses an HTTP response from a UpdateNotificationRuleWithResponse call
func ParseUpdateNotificationRuleResponse(rsp *http.Response) (*UpdateNotificationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNotificationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseTestNotificationRuleResponse parses an HTTP response from a TestNotificationRuleWithResponse call
func ParseTestNotificationRuleResponse(rsp *http.Response) (*TestNotificationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestNotificationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseReceiveSvixOperationalEventResponse parses an HTTP response from a ReceiveSvixOperationalEventWithResponse call
func ParseReceiveSvixOperationalEventResponse(rsp *http.Response) (*ReceiveSvixOperationalEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiveSvixOperationalEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseQueryPortalMeterResponse parses an HTTP response from a QueryPortalMeterWithResponse call
func ParseQueryPortalMeterResponse(rsp *http.Response) (*QueryPortalMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryPortalMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeterQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListPortalTokensResponse parses an HTTP response from a ListPortalTokensWithResponse call
func ParseListPortalTokensResponse(rsp *http.Response) (*ListPortalTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPortalTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PortalToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePortalTokenResponse parses an HTTP response from a CreatePortalTokenWithResponse call
func ParseCreatePortalTokenResponse(rsp *http.Response) (*CreatePortalTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePortalTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortalToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseInvalidatePortalTokensResponse parses an HTTP response from a InvalidatePortalTokensWithResponse call
func ParseInvalidatePortalTokensResponse(rsp *http.Response) (*InvalidatePortalTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InvalidatePortalTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListSubjectsResponse parses an HTTP response from a ListSubjectsWithResponse call
func ParseListSubjectsResponse(rsp *http.Response) (*ListSubjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSubjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Subject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpsertSubjectResponse parses an HTTP response from a UpsertSubjectWithResponse call
func ParseUpsertSubjectResponse(rsp *http.Response) (*UpsertSubjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertSubjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Subject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSubjectResponse parses an HTTP response from a DeleteSubjectWithResponse call
func ParseDeleteSubjectResponse(rsp *http.Response) (*DeleteSubjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetSubjectResponse parses an HTTP response from a GetSubjectWithResponse call
func ParseGetSubjectResponse(rsp *http.Response) (*GetSubjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListSubjectEntitlementsResponse parses an HTTP response from a ListSubjectEntitlementsWithResponse call
func ParseListSubjectEntitlementsResponse(rsp *http.Response) (*ListSubjectEntitlementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSubjectEntitlementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Entitlement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateEntitlementResponse parses an HTTP response from a CreateEntitlementWithResponse call
func ParseCreateEntitlementResponse(rsp *http.Response) (*CreateEntitlementResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEntitlementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EntitlementCreateInputs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListEntitlementGrantsResponse parses an HTTP response from a ListEntitlementGrantsWithResponse call
func ParseListEntitlementGrantsResponse(rsp *http.Response) (*ListEntitlementGrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEntitlementGrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EntitlementGrant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateGrantResponse parses an HTTP response from a CreateGrantWithResponse call
func ParseCreateGrantResponse(rsp *http.Response) (*CreateGrantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EntitlementGrant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseOverrideEntitlementResponse parses an HTTP response from a OverrideEntitlementWithResponse call
func ParseOverrideEntitlementResponse(rsp *http.Response) (*OverrideEntitlementResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OverrideEntitlementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Entitlement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntitlementValueResponse parses an HTTP response from a GetEntitlementValueWithResponse call
func ParseGetEntitlementValueResponse(rsp *http.Response) (*GetEntitlementValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntitlementValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntitlementValue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEntitlementResponse parses an HTTP response from a DeleteEntitlementWithResponse call
func ParseDeleteEntitlementResponse(rsp *http.Response) (*DeleteEntitlementResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEntitlementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntitlementResponse parses an HTTP response from a GetEntitlementWithResponse call
func ParseGetEntitlementResponse(rsp *http.Response) (*GetEntitlementResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntitlementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entitlement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntitlementHistoryResponse parses an HTTP response from a GetEntitlementHistoryWithResponse call
func ParseGetEntitlementHistoryResponse(rsp *http.Response) (*GetEntitlementHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntitlementHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WindowedBalanceHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseResetEntitlementUsageResponse parses an HTTP response from a ResetEntitlementUsageWithResponse call
func ParseResetEntitlementUsageResponse(rsp *http.Response) (*ResetEntitlementUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetEntitlementUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
