// Package openmeter provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openmeter

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/cloudevents/sdk-go/v2/event"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	"github.com/openmeterio/openmeter/pkg/models"
)

const (
	CloudCookieAuthScopes      = "CloudCookieAuth.Scopes"
	CloudPortalTokenAuthScopes = "CloudPortalTokenAuth.Scopes"
	CloudTokenAuthScopes       = "CloudTokenAuth.Scopes"
)

// Defines values for AddonInstanceType.
const (
	AddonInstanceTypeMultiple AddonInstanceType = "multiple"
	AddonInstanceTypeSingle   AddonInstanceType = "single"
)

// Defines values for AddonOrderBy.
const (
	AddonOrderByCreatedAt AddonOrderBy = "created_at"
	AddonOrderById        AddonOrderBy = "id"
	AddonOrderByKey       AddonOrderBy = "key"
	AddonOrderByUpdatedAt AddonOrderBy = "updated_at"
	AddonOrderByVersion   AddonOrderBy = "version"
)

// Defines values for AddonStatus.
const (
	AddonStatusActive   AddonStatus = "active"
	AddonStatusArchived AddonStatus = "archived"
	AddonStatusDraft    AddonStatus = "draft"
)

// Defines values for AppCapabilityType.
const (
	AppCapabilityTypeCalculateTax     AppCapabilityType = "calculateTax"
	AppCapabilityTypeCollectPayments  AppCapabilityType = "collectPayments"
	AppCapabilityTypeInvoiceCustomers AppCapabilityType = "invoiceCustomers"
	AppCapabilityTypeReportEvents     AppCapabilityType = "reportEvents"
	AppCapabilityTypeReportUsage      AppCapabilityType = "reportUsage"
)

// Defines values for AppStatus.
const (
	AppStatusReady        AppStatus = "ready"
	AppStatusUnauthorized AppStatus = "unauthorized"
)

// Defines values for AppType.
const (
	AppTypeCustomInvoicing AppType = "custom_invoicing"
	AppTypeSandbox         AppType = "sandbox"
	AppTypeStripe          AppType = "stripe"
)

// Defines values for BillingProfileCustomerOverrideExpand.
const (
	BillingProfileCustomerOverrideExpandApps     BillingProfileCustomerOverrideExpand = "apps"
	BillingProfileCustomerOverrideExpandCustomer BillingProfileCustomerOverrideExpand = "customer"
)

// Defines values for BillingProfileCustomerOverrideOrderBy.
const (
	BillingProfileCustomerOverrideOrderByCustomerCreatedAt    BillingProfileCustomerOverrideOrderBy = "customerCreatedAt"
	BillingProfileCustomerOverrideOrderByCustomerId           BillingProfileCustomerOverrideOrderBy = "customerId"
	BillingProfileCustomerOverrideOrderByCustomerKey          BillingProfileCustomerOverrideOrderBy = "customerKey"
	BillingProfileCustomerOverrideOrderByCustomerName         BillingProfileCustomerOverrideOrderBy = "customerName"
	BillingProfileCustomerOverrideOrderByCustomerPrimaryEmail BillingProfileCustomerOverrideOrderBy = "customerPrimaryEmail"
)

// Defines values for BillingProfileExpand.
const (
	BillingProfileExpandApps BillingProfileExpand = "apps"
)

// Defines values for BillingProfileOrderBy.
const (
	BillingProfileOrderByCreatedAt BillingProfileOrderBy = "createdAt"
	BillingProfileOrderByDefault   BillingProfileOrderBy = "default"
	BillingProfileOrderByName      BillingProfileOrderBy = "name"
	BillingProfileOrderByUpdatedAt BillingProfileOrderBy = "updatedAt"
)

// Defines values for BillingWorkflowCollectionAlignmentSubscriptionType.
const (
	BillingWorkflowCollectionAlignmentSubscriptionTypeSubscription BillingWorkflowCollectionAlignmentSubscriptionType = "subscription"
)

// Defines values for CheckoutSessionUIMode.
const (
	CheckoutSessionUIModeEmbedded CheckoutSessionUIMode = "embedded"
	CheckoutSessionUIModeHosted   CheckoutSessionUIMode = "hosted"
)

// Defines values for CollectionMethod.
const (
	CollectionMethodChargeAutomatically CollectionMethod = "charge_automatically"
	CollectionMethodSendInvoice         CollectionMethod = "send_invoice"
)

// Defines values for CreateCheckoutSessionTaxIdCollectionRequired.
const (
	CreateCheckoutSessionTaxIdCollectionRequiredIfSupported CreateCheckoutSessionTaxIdCollectionRequired = "if_supported"
	CreateCheckoutSessionTaxIdCollectionRequiredNever       CreateCheckoutSessionTaxIdCollectionRequired = "never"
)

// Defines values for CreateStripeCheckoutSessionBillingAddressCollection.
const (
	CreateStripeCheckoutSessionBillingAddressCollectionAuto     CreateStripeCheckoutSessionBillingAddressCollection = "auto"
	CreateStripeCheckoutSessionBillingAddressCollectionRequired CreateStripeCheckoutSessionBillingAddressCollection = "required"
)

// Defines values for CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreementPosition.
const (
	CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreementPositionAuto   CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreementPosition = "auto"
	CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreementPositionHidden CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreementPosition = "hidden"
)

// Defines values for CreateStripeCheckoutSessionConsentCollectionPromotions.
const (
	CreateStripeCheckoutSessionConsentCollectionPromotionsAuto CreateStripeCheckoutSessionConsentCollectionPromotions = "auto"
	CreateStripeCheckoutSessionConsentCollectionPromotionsNone CreateStripeCheckoutSessionConsentCollectionPromotions = "none"
)

// Defines values for CreateStripeCheckoutSessionConsentCollectionTermsOfService.
const (
	CreateStripeCheckoutSessionConsentCollectionTermsOfServiceNone     CreateStripeCheckoutSessionConsentCollectionTermsOfService = "none"
	CreateStripeCheckoutSessionConsentCollectionTermsOfServiceRequired CreateStripeCheckoutSessionConsentCollectionTermsOfService = "required"
)

// Defines values for CreateStripeCheckoutSessionCustomerUpdateBehavior.
const (
	CreateStripeCheckoutSessionCustomerUpdateBehaviorAuto  CreateStripeCheckoutSessionCustomerUpdateBehavior = "auto"
	CreateStripeCheckoutSessionCustomerUpdateBehaviorNever CreateStripeCheckoutSessionCustomerUpdateBehavior = "never"
)

// Defines values for CreateStripeCheckoutSessionRedirectOnCompletion.
const (
	CreateStripeCheckoutSessionRedirectOnCompletionAlways     CreateStripeCheckoutSessionRedirectOnCompletion = "always"
	CreateStripeCheckoutSessionRedirectOnCompletionIfRequired CreateStripeCheckoutSessionRedirectOnCompletion = "if_required"
	CreateStripeCheckoutSessionRedirectOnCompletionNever      CreateStripeCheckoutSessionRedirectOnCompletion = "never"
)

// Defines values for CustomInvoicingAppType.
const (
	CustomInvoicingAppTypeCustomInvoicing CustomInvoicingAppType = "custom_invoicing"
)

// Defines values for CustomInvoicingAppReplaceUpdateType.
const (
	CustomInvoicingAppReplaceUpdateTypeCustomInvoicing CustomInvoicingAppReplaceUpdateType = "custom_invoicing"
)

// Defines values for CustomInvoicingCustomerAppDataType.
const (
	CustomInvoicingCustomerAppDataTypeCustomInvoicing CustomInvoicingCustomerAppDataType = "custom_invoicing"
)

// Defines values for CustomInvoicingPaymentTrigger.
const (
	CustomInvoicingPaymentTriggerActionRequired       CustomInvoicingPaymentTrigger = "action_required"
	CustomInvoicingPaymentTriggerPaid                 CustomInvoicingPaymentTrigger = "paid"
	CustomInvoicingPaymentTriggerPaymentFailed        CustomInvoicingPaymentTrigger = "payment_failed"
	CustomInvoicingPaymentTriggerPaymentOverdue       CustomInvoicingPaymentTrigger = "payment_overdue"
	CustomInvoicingPaymentTriggerPaymentUncollectible CustomInvoicingPaymentTrigger = "payment_uncollectible"
	CustomInvoicingPaymentTriggerVoid                 CustomInvoicingPaymentTrigger = "void"
)

// Defines values for CustomerExpand.
const (
	CustomerExpandSubscriptions CustomerExpand = "subscriptions"
)

// Defines values for CustomerOrderBy.
const (
	CustomerOrderByCreatedAt CustomerOrderBy = "createdAt"
	CustomerOrderById        CustomerOrderBy = "id"
	CustomerOrderByName      CustomerOrderBy = "name"
)

// Defines values for DiscountReasonMaximumSpendType.
const (
	DiscountReasonMaximumSpendTypeMaximumSpend DiscountReasonMaximumSpendType = "maximum_spend"
)

// Defines values for DiscountReasonRatecardPercentageType.
const (
	DiscountReasonRatecardPercentageTypeRatecardPercentage DiscountReasonRatecardPercentageType = "ratecard_percentage"
)

// Defines values for DiscountReasonRatecardUsageType.
const (
	DiscountReasonRatecardUsageTypeRatecardUsage DiscountReasonRatecardUsageType = "ratecard_usage"
)

// Defines values for DynamicPriceWithCommitmentsType.
const (
	DynamicPriceWithCommitmentsTypeDynamic DynamicPriceWithCommitmentsType = "dynamic"
)

// Defines values for EditSubscriptionAddItemOp.
const (
	EditSubscriptionAddItemOpAddItem EditSubscriptionAddItemOp = "add_item"
)

// Defines values for EditSubscriptionAddPhaseOp.
const (
	EditSubscriptionAddPhaseOpAddPhase EditSubscriptionAddPhaseOp = "add_phase"
)

// Defines values for EditSubscriptionRemoveItemOp.
const (
	EditSubscriptionRemoveItemOpRemoveItem EditSubscriptionRemoveItemOp = "remove_item"
)

// Defines values for EditSubscriptionRemovePhaseOp.
const (
	EditSubscriptionRemovePhaseOpRemovePhase EditSubscriptionRemovePhaseOp = "remove_phase"
)

// Defines values for EditSubscriptionStretchPhaseOp.
const (
	EditSubscriptionStretchPhaseOpStretchPhase EditSubscriptionStretchPhaseOp = "stretch_phase"
)

// Defines values for EditSubscriptionUnscheduleEditOp.
const (
	EditSubscriptionUnscheduleEditOpUnscheduleEdit EditSubscriptionUnscheduleEditOp = "unschedule_edit"
)

// Defines values for EntitlementBooleanCreateInputsType.
const (
	EntitlementBooleanCreateInputsTypeBoolean EntitlementBooleanCreateInputsType = "boolean"
)

// Defines values for EntitlementMeteredType.
const (
	EntitlementMeteredTypeMetered EntitlementMeteredType = "metered"
)

// Defines values for EntitlementMeteredCreateInputsType.
const (
	EntitlementMeteredCreateInputsTypeMetered EntitlementMeteredCreateInputsType = "metered"
)

// Defines values for EntitlementOrderBy.
const (
	EntitlementOrderByCreatedAt EntitlementOrderBy = "createdAt"
	EntitlementOrderByUpdatedAt EntitlementOrderBy = "updatedAt"
)

// Defines values for EntitlementStaticType.
const (
	EntitlementStaticTypeStatic EntitlementStaticType = "static"
)

// Defines values for EntitlementStaticCreateInputsType.
const (
	EntitlementStaticCreateInputsTypeStatic EntitlementStaticCreateInputsType = "static"
)

// Defines values for ExpirationDuration.
const (
	ExpirationDurationDAY   ExpirationDuration = "DAY"
	ExpirationDurationHOUR  ExpirationDuration = "HOUR"
	ExpirationDurationMONTH ExpirationDuration = "MONTH"
	ExpirationDurationWEEK  ExpirationDuration = "WEEK"
	ExpirationDurationYEAR  ExpirationDuration = "YEAR"
)

// Defines values for FeatureOrderBy.
const (
	FeatureOrderByCreatedAt FeatureOrderBy = "createdAt"
	FeatureOrderById        FeatureOrderBy = "id"
	FeatureOrderByKey       FeatureOrderBy = "key"
	FeatureOrderByName      FeatureOrderBy = "name"
	FeatureOrderByUpdatedAt FeatureOrderBy = "updatedAt"
)

// Defines values for FlatPriceType.
const (
	FlatPriceTypeFlat FlatPriceType = "flat"
)

// Defines values for FlatPriceWithPaymentTermType.
const (
	FlatPriceWithPaymentTermTypeFlat FlatPriceWithPaymentTermType = "flat"
)

// Defines values for GrantOrderBy.
const (
	GrantOrderByCreatedAt GrantOrderBy = "createdAt"
	GrantOrderById        GrantOrderBy = "id"
	GrantOrderByUpdatedAt GrantOrderBy = "updatedAt"
)

// Defines values for InstallMethod.
const (
	InstallMethodNoCredentialsRequired InstallMethod = "no_credentials_required"
	InstallMethodWithApiKey            InstallMethod = "with_api_key"
	InstallMethodWithOauth2            InstallMethod = "with_oauth2"
)

// Defines values for InvoiceDocumentRefType.
const (
	InvoiceDocumentRefTypeCreditNodeOriginalInvoice InvoiceDocumentRefType = "credit_node_original_invoice"
)

// Defines values for InvoiceExpand.
const (
	InvoiceExpandLines        InvoiceExpand = "lines"
	InvoiceExpandPreceding    InvoiceExpand = "preceding"
	InvoiceExpandWorkflowApps InvoiceExpand = "workflow.apps"
)

// Defines values for InvoiceFlatFeeCategory.
const (
	InvoiceFlatFeeCategoryCommitment InvoiceFlatFeeCategory = "commitment"
	InvoiceFlatFeeCategoryRegular    InvoiceFlatFeeCategory = "regular"
)

// Defines values for InvoiceFlatFeeLineType.
const (
	InvoiceFlatFeeLineTypeFlatFee InvoiceFlatFeeLineType = "flat_fee"
)

// Defines values for InvoiceFlatFeeLineReplaceUpdateType.
const (
	InvoiceFlatFeeLineReplaceUpdateTypeFlatFee InvoiceFlatFeeLineReplaceUpdateType = "flat_fee"
)

// Defines values for InvoiceFlatFeePendingLineCreateType.
const (
	InvoiceFlatFeePendingLineCreateTypeFlatFee InvoiceFlatFeePendingLineCreateType = "flat_fee"
)

// Defines values for InvoiceLineManagedBy.
const (
	InvoiceLineManagedByManual       InvoiceLineManagedBy = "manual"
	InvoiceLineManagedBySubscription InvoiceLineManagedBy = "subscription"
	InvoiceLineManagedBySystem       InvoiceLineManagedBy = "system"
)

// Defines values for InvoiceLineStatus.
const (
	InvoiceLineStatusDetail InvoiceLineStatus = "detail"
	InvoiceLineStatusSplit  InvoiceLineStatus = "split"
	InvoiceLineStatusValid  InvoiceLineStatus = "valid"
)

// Defines values for InvoiceLineTaxBehavior.
const (
	InvoiceLineTaxBehaviorExclusive InvoiceLineTaxBehavior = "exclusive"
	InvoiceLineTaxBehaviorInclusive InvoiceLineTaxBehavior = "inclusive"
)

// Defines values for InvoiceOrderBy.
const (
	InvoiceOrderByCreatedAt    InvoiceOrderBy = "createdAt"
	InvoiceOrderByCustomerName InvoiceOrderBy = "customer.name"
	InvoiceOrderByIssuedAt     InvoiceOrderBy = "issuedAt"
	InvoiceOrderByPeriodStart  InvoiceOrderBy = "periodStart"
	InvoiceOrderByStatus       InvoiceOrderBy = "status"
	InvoiceOrderByUpdatedAt    InvoiceOrderBy = "updatedAt"
)

// Defines values for InvoiceSimulationFlatFeeLineType.
const (
	InvoiceSimulationFlatFeeLineTypeFlatFee InvoiceSimulationFlatFeeLineType = "flat_fee"
)

// Defines values for InvoiceSimulationUsageBasedLineType.
const (
	InvoiceSimulationUsageBasedLineTypeUsageBased InvoiceSimulationUsageBasedLineType = "usage_based"
)

// Defines values for InvoiceStatus.
const (
	InvoiceStatusDraft             InvoiceStatus = "draft"
	InvoiceStatusGathering         InvoiceStatus = "gathering"
	InvoiceStatusIssued            InvoiceStatus = "issued"
	InvoiceStatusIssuing           InvoiceStatus = "issuing"
	InvoiceStatusOverdue           InvoiceStatus = "overdue"
	InvoiceStatusPaid              InvoiceStatus = "paid"
	InvoiceStatusPaymentProcessing InvoiceStatus = "payment_processing"
	InvoiceStatusUncollectible     InvoiceStatus = "uncollectible"
	InvoiceStatusVoided            InvoiceStatus = "voided"
)

// Defines values for InvoiceType.
const (
	InvoiceTypeCreditNote InvoiceType = "credit_note"
	InvoiceTypeStandard   InvoiceType = "standard"
)

// Defines values for InvoiceUsageBasedLineType.
const (
	InvoiceUsageBasedLineTypeUsageBased InvoiceUsageBasedLineType = "usage_based"
)

// Defines values for InvoiceUsageBasedLineReplaceUpdateType.
const (
	InvoiceUsageBasedLineReplaceUpdateTypeUsageBased InvoiceUsageBasedLineReplaceUpdateType = "usage_based"
)

// Defines values for InvoiceUsageBasedPendingLineCreateType.
const (
	InvoiceUsageBasedPendingLineCreateTypeUsageBased InvoiceUsageBasedPendingLineCreateType = "usage_based"
)

// Defines values for MeasureUsageFromPreset.
const (
	MeasureUsageFromPresetCurrentPeriodStart MeasureUsageFromPreset = "CURRENT_PERIOD_START"
	MeasureUsageFromPresetNow                MeasureUsageFromPreset = "NOW"
)

// Defines values for MeterAggregation.
const (
	MeterAggregationAvg         MeterAggregation = "AVG"
	MeterAggregationCount       MeterAggregation = "COUNT"
	MeterAggregationLatest      MeterAggregation = "LATEST"
	MeterAggregationMax         MeterAggregation = "MAX"
	MeterAggregationMin         MeterAggregation = "MIN"
	MeterAggregationSum         MeterAggregation = "SUM"
	MeterAggregationUniqueCount MeterAggregation = "UNIQUE_COUNT"
)

// Defines values for MeterOrderBy.
const (
	MeterOrderByAggregation MeterOrderBy = "aggregation"
	MeterOrderByCreatedAt   MeterOrderBy = "createdAt"
	MeterOrderByKey         MeterOrderBy = "key"
	MeterOrderByName        MeterOrderBy = "name"
	MeterOrderByUpdatedAt   MeterOrderBy = "updatedAt"
)

// Defines values for NotificationChannelOrderBy.
const (
	NotificationChannelOrderByCreatedAt NotificationChannelOrderBy = "createdAt"
	NotificationChannelOrderById        NotificationChannelOrderBy = "id"
	NotificationChannelOrderByType      NotificationChannelOrderBy = "type"
	NotificationChannelOrderByUpdatedAt NotificationChannelOrderBy = "updatedAt"
)

// Defines values for NotificationChannelType.
const (
	NotificationChannelTypeWebhook NotificationChannelType = "WEBHOOK"
)

// Defines values for NotificationChannelWebhookType.
const (
	NotificationChannelWebhookTypeWEBHOOK NotificationChannelWebhookType = "WEBHOOK"
)

// Defines values for NotificationChannelWebhookCreateRequestType.
const (
	NotificationChannelWebhookCreateRequestTypeWEBHOOK NotificationChannelWebhookCreateRequestType = "WEBHOOK"
)

// Defines values for NotificationEventBalanceThresholdPayloadType.
const (
	NotificationEventBalanceThresholdPayloadTypeEntitlementsBalanceThreshold NotificationEventBalanceThresholdPayloadType = "entitlements.balance.threshold"
)

// Defines values for NotificationEventDeliveryStatusState.
const (
	NotificationEventDeliveryStatusStateFailed  NotificationEventDeliveryStatusState = "FAILED"
	NotificationEventDeliveryStatusStatePending NotificationEventDeliveryStatusState = "PENDING"
	NotificationEventDeliveryStatusStateSending NotificationEventDeliveryStatusState = "SENDING"
	NotificationEventDeliveryStatusStateSuccess NotificationEventDeliveryStatusState = "SUCCESS"
)

// Defines values for NotificationEventInvoiceCreatedPayloadType.
const (
	NotificationEventInvoiceCreatedPayloadTypeInvoiceCreated NotificationEventInvoiceCreatedPayloadType = "invoice.created"
)

// Defines values for NotificationEventInvoiceUpdatedPayloadType.
const (
	NotificationEventInvoiceUpdatedPayloadTypeInvoiceUpdated NotificationEventInvoiceUpdatedPayloadType = "invoice.updated"
)

// Defines values for NotificationEventOrderBy.
const (
	NotificationEventOrderByCreatedAt NotificationEventOrderBy = "createdAt"
	NotificationEventOrderById        NotificationEventOrderBy = "id"
)

// Defines values for NotificationEventResetPayloadType.
const (
	NotificationEventResetPayloadTypeEntitlementsReset NotificationEventResetPayloadType = "entitlements.reset"
)

// Defines values for NotificationEventType.
const (
	NotificationEventTypeEntitlementsBalanceThreshold NotificationEventType = "entitlements.balance.threshold"
	NotificationEventTypeEntitlementsReset            NotificationEventType = "entitlements.reset"
	NotificationEventTypeInvoiceCreated               NotificationEventType = "invoice.created"
	NotificationEventTypeInvoiceUpdated               NotificationEventType = "invoice.updated"
)

// Defines values for NotificationRuleBalanceThresholdType.
const (
	NotificationRuleBalanceThresholdTypeEntitlementsBalanceThreshold NotificationRuleBalanceThresholdType = "entitlements.balance.threshold"
)

// Defines values for NotificationRuleBalanceThresholdCreateRequestType.
const (
	NotificationRuleBalanceThresholdCreateRequestTypeEntitlementsBalanceThreshold NotificationRuleBalanceThresholdCreateRequestType = "entitlements.balance.threshold"
)

// Defines values for NotificationRuleBalanceThresholdValueType.
const (
	NotificationRuleBalanceThresholdValueTypeNumber  NotificationRuleBalanceThresholdValueType = "NUMBER"
	NotificationRuleBalanceThresholdValueTypePercent NotificationRuleBalanceThresholdValueType = "PERCENT"
)

// Defines values for NotificationRuleEntitlementResetType.
const (
	NotificationRuleEntitlementResetTypeEntitlementsReset NotificationRuleEntitlementResetType = "entitlements.reset"
)

// Defines values for NotificationRuleEntitlementResetCreateRequestType.
const (
	NotificationRuleEntitlementResetCreateRequestTypeEntitlementsReset NotificationRuleEntitlementResetCreateRequestType = "entitlements.reset"
)

// Defines values for NotificationRuleInvoiceCreatedType.
const (
	NotificationRuleInvoiceCreatedTypeInvoiceCreated NotificationRuleInvoiceCreatedType = "invoice.created"
)

// Defines values for NotificationRuleInvoiceCreatedCreateRequestType.
const (
	NotificationRuleInvoiceCreatedCreateRequestTypeInvoiceCreated NotificationRuleInvoiceCreatedCreateRequestType = "invoice.created"
)

// Defines values for NotificationRuleInvoiceUpdatedType.
const (
	NotificationRuleInvoiceUpdatedTypeInvoiceUpdated NotificationRuleInvoiceUpdatedType = "invoice.updated"
)

// Defines values for NotificationRuleInvoiceUpdatedCreateRequestType.
const (
	NotificationRuleInvoiceUpdatedCreateRequestTypeInvoiceUpdated NotificationRuleInvoiceUpdatedCreateRequestType = "invoice.updated"
)

// Defines values for NotificationRuleOrderBy.
const (
	NotificationRuleOrderByCreatedAt NotificationRuleOrderBy = "createdAt"
	NotificationRuleOrderById        NotificationRuleOrderBy = "id"
	NotificationRuleOrderByType      NotificationRuleOrderBy = "type"
	NotificationRuleOrderByUpdatedAt NotificationRuleOrderBy = "updatedAt"
)

// Defines values for OAuth2AuthorizationCodeGrantErrorType.
const (
	OAuth2AuthorizationCodeGrantErrorTypeAccessDenied            OAuth2AuthorizationCodeGrantErrorType = "access_denied"
	OAuth2AuthorizationCodeGrantErrorTypeInvalidRequest          OAuth2AuthorizationCodeGrantErrorType = "invalid_request"
	OAuth2AuthorizationCodeGrantErrorTypeInvalidScope            OAuth2AuthorizationCodeGrantErrorType = "invalid_scope"
	OAuth2AuthorizationCodeGrantErrorTypeServerError             OAuth2AuthorizationCodeGrantErrorType = "server_error"
	OAuth2AuthorizationCodeGrantErrorTypeTemporarilyUnavailable  OAuth2AuthorizationCodeGrantErrorType = "temporarily_unavailable"
	OAuth2AuthorizationCodeGrantErrorTypeUnauthorizedClient      OAuth2AuthorizationCodeGrantErrorType = "unauthorized_client"
	OAuth2AuthorizationCodeGrantErrorTypeUnsupportedResponseType OAuth2AuthorizationCodeGrantErrorType = "unsupported_response_type"
)

// Defines values for PackagePriceWithCommitmentsType.
const (
	PackagePriceWithCommitmentsTypePackage PackagePriceWithCommitmentsType = "package"
)

// Defines values for PaymentTermDueDateType.
const (
	PaymentTermDueDateTypeDueDate PaymentTermDueDateType = "due_date"
)

// Defines values for PaymentTermInstantType.
const (
	PaymentTermInstantTypeInstant PaymentTermInstantType = "instant"
)

// Defines values for PlanAddonOrderBy.
const (
	PlanAddonOrderByCreatedAt PlanAddonOrderBy = "created_at"
	PlanAddonOrderById        PlanAddonOrderBy = "id"
	PlanAddonOrderByKey       PlanAddonOrderBy = "key"
	PlanAddonOrderByUpdatedAt PlanAddonOrderBy = "updated_at"
	PlanAddonOrderByVersion   PlanAddonOrderBy = "version"
)

// Defines values for PlanOrderBy.
const (
	PlanOrderByCreatedAt PlanOrderBy = "created_at"
	PlanOrderById        PlanOrderBy = "id"
	PlanOrderByKey       PlanOrderBy = "key"
	PlanOrderByUpdatedAt PlanOrderBy = "updated_at"
	PlanOrderByVersion   PlanOrderBy = "version"
)

// Defines values for PlanStatus.
const (
	PlanStatusActive    PlanStatus = "active"
	PlanStatusArchived  PlanStatus = "archived"
	PlanStatusDraft     PlanStatus = "draft"
	PlanStatusScheduled PlanStatus = "scheduled"
)

// Defines values for PricePaymentTerm.
const (
	PricePaymentTermInAdvance PricePaymentTerm = "in_advance"
	PricePaymentTermInArrears PricePaymentTerm = "in_arrears"
)

// Defines values for RateCardBooleanEntitlementType.
const (
	RateCardBooleanEntitlementTypeBoolean RateCardBooleanEntitlementType = "boolean"
)

// Defines values for RateCardFlatFeeType.
const (
	RateCardFlatFeeTypeFlatFee RateCardFlatFeeType = "flat_fee"
)

// Defines values for RateCardMeteredEntitlementType.
const (
	RateCardMeteredEntitlementTypeMetered RateCardMeteredEntitlementType = "metered"
)

// Defines values for RateCardStaticEntitlementType.
const (
	RateCardStaticEntitlementTypeStatic RateCardStaticEntitlementType = "static"
)

// Defines values for RateCardUsageBasedType.
const (
	RateCardUsageBasedTypeUsageBased RateCardUsageBasedType = "usage_based"
)

// Defines values for RecurringPeriodIntervalEnum.
const (
	RecurringPeriodIntervalEnumDAY   RecurringPeriodIntervalEnum = "DAY"
	RecurringPeriodIntervalEnumMONTH RecurringPeriodIntervalEnum = "MONTH"
	RecurringPeriodIntervalEnumWEEK  RecurringPeriodIntervalEnum = "WEEK"
	RecurringPeriodIntervalEnumYEAR  RecurringPeriodIntervalEnum = "YEAR"
)

// Defines values for RemovePhaseShifting.
const (
	RemovePhaseShiftingNext RemovePhaseShifting = "next"
	RemovePhaseShiftingPrev RemovePhaseShifting = "prev"
)

// Defines values for SandboxAppType.
const (
	SandboxAppTypeSandbox SandboxAppType = "sandbox"
)

// Defines values for SandboxAppReplaceUpdateType.
const (
	SandboxAppReplaceUpdateTypeSandbox SandboxAppReplaceUpdateType = "sandbox"
)

// Defines values for SandboxCustomerAppDataType.
const (
	SandboxCustomerAppDataTypeSandbox SandboxCustomerAppDataType = "sandbox"
)

// Defines values for SortOrder.
const (
	SortOrderASC  SortOrder = "ASC"
	SortOrderDESC SortOrder = "DESC"
)

// Defines values for StripeAppType.
const (
	StripeAppTypeStripe StripeAppType = "stripe"
)

// Defines values for StripeAppReplaceUpdateType.
const (
	StripeAppReplaceUpdateTypeStripe StripeAppReplaceUpdateType = "stripe"
)

// Defines values for StripeCheckoutSessionMode.
const (
	StripeCheckoutSessionModeSetup StripeCheckoutSessionMode = "setup"
)

// Defines values for StripeCustomerAppDataType.
const (
	StripeCustomerAppDataTypeStripe StripeCustomerAppDataType = "stripe"
)

// Defines values for StripeCustomerAppDataCreateOrUpdateItemType.
const (
	StripeCustomerAppDataCreateOrUpdateItemTypeStripe StripeCustomerAppDataCreateOrUpdateItemType = "stripe"
)

// Defines values for SubscriptionStatus.
const (
	SubscriptionStatusActive    SubscriptionStatus = "active"
	SubscriptionStatusCanceled  SubscriptionStatus = "canceled"
	SubscriptionStatusInactive  SubscriptionStatus = "inactive"
	SubscriptionStatusScheduled SubscriptionStatus = "scheduled"
)

// Defines values for SubscriptionTimingEnum.
const (
	SubscriptionTimingEnumImmediate        SubscriptionTimingEnum = "immediate"
	SubscriptionTimingEnumNextBillingCycle SubscriptionTimingEnum = "next_billing_cycle"
)

// Defines values for TaxBehavior.
const (
	TaxBehaviorExclusive TaxBehavior = "exclusive"
	TaxBehaviorInclusive TaxBehavior = "inclusive"
)

// Defines values for TieredPriceMode.
const (
	TieredPriceModeGraduated TieredPriceMode = "graduated"
	TieredPriceModeVolume    TieredPriceMode = "volume"
)

// Defines values for TieredPriceWithCommitmentsType.
const (
	TieredPriceWithCommitmentsTypeTiered TieredPriceWithCommitmentsType = "tiered"
)

// Defines values for UnitPriceType.
const (
	UnitPriceTypeUnit UnitPriceType = "unit"
)

// Defines values for UnitPriceWithCommitmentsType.
const (
	UnitPriceWithCommitmentsTypeUnit UnitPriceWithCommitmentsType = "unit"
)

// Defines values for ValidationIssueSeverity.
const (
	ValidationIssueSeverityCritical ValidationIssueSeverity = "critical"
	ValidationIssueSeverityWarning  ValidationIssueSeverity = "warning"
)

// Defines values for VoidInvoiceLineDiscardActionType.
const (
	VoidInvoiceLineDiscardActionTypeDiscard VoidInvoiceLineDiscardActionType = "discard"
)

// Defines values for VoidInvoiceLinePendingActionCreateType.
const (
	VoidInvoiceLinePendingActionCreateTypePending VoidInvoiceLinePendingActionCreateType = "pending"
)

// Defines values for VoidInvoiceLinePendingActionCreateItemType.
const (
	VoidInvoiceLinePendingActionCreateItemTypePending VoidInvoiceLinePendingActionCreateItemType = "pending"
)

// Defines values for WindowSize.
const (
	WindowSizeDay    WindowSize = "DAY"
	WindowSizeHour   WindowSize = "HOUR"
	WindowSizeMinute WindowSize = "MINUTE"
)

// Addon Add-on allows extending subscriptions with compatible plans with additional ratecards.
type Addon struct {
	// Annotations Set of key-value pairs managed by the system. Cannot be modified by user.
	Annotations *Annotations `json:"annotations,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency The currency code of the add-on.
	Currency CurrencyCode `json:"currency"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EffectiveFrom The date and time when the add-on becomes effective. When not specified, the add-on is a draft.
	EffectiveFrom *time.Time `json:"effectiveFrom,omitempty"`

	// EffectiveTo The date and time when the add-on is no longer effective. When not specified, the add-on is effective indefinitely.
	EffectiveTo *time.Time `json:"effectiveTo,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// InstanceType The instanceType of the add-ons. Can be "single" or "multiple".
	InstanceType AddonInstanceType `json:"instanceType"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// RateCards The rate cards of the add-on.
	RateCards []RateCard `json:"rateCards"`

	// Status The status of the add-on.
	// Computed based on the effective start and end dates:
	// - draft = no effectiveFrom
	// - active = effectiveFrom <= now < effectiveTo
	// - archived  = effectiveTo <= now
	Status AddonStatus `json:"status"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// Version Version of the add-on. Incremented when the add-on is updated.
	Version int `json:"version"`
}

// AddonCreate Resource create operation model.
type AddonCreate struct {
	// Currency The currency code of the add-on.
	Currency CurrencyCode `json:"currency"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// InstanceType The instanceType of the add-ons. Can be "single" or "multiple".
	InstanceType AddonInstanceType `json:"instanceType"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// RateCards The rate cards of the add-on.
	RateCards []RateCard `json:"rateCards"`
}

// AddonInstanceType The instanceType of the add-on.
// Single instance add-ons can be added to subscription only once while add-ons with multiple type can be added more then once.
type AddonInstanceType string

// AddonOrderBy Order by options for add-ons.
type AddonOrderBy string

// AddonPaginatedResponse Paginated response
type AddonPaginatedResponse struct {
	// Items The items in the current page.
	Items []Addon `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// AddonReplaceUpdate Resource update operation model.
type AddonReplaceUpdate struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// InstanceType The instanceType of the add-ons. Can be "single" or "multiple".
	InstanceType AddonInstanceType `json:"instanceType"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// RateCards The rate cards of the add-on.
	RateCards []RateCard `json:"rateCards"`
}

// AddonStatus The status of the add-on defined by the effectiveFrom and effectiveTo properties.
type AddonStatus string

// Address Address
type Address struct {
	// City City.
	City *string `json:"city,omitempty"`

	// Country Country code in [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 format.
	Country *CountryCode `json:"country,omitempty"`

	// Line1 First line of the address.
	Line1 *string `json:"line1,omitempty"`

	// Line2 Second line of the address.
	Line2 *string `json:"line2,omitempty"`

	// PhoneNumber Phone number.
	PhoneNumber *string `json:"phoneNumber,omitempty"`

	// PostalCode Postal code.
	PostalCode *string `json:"postalCode,omitempty"`

	// State State or province.
	State *string `json:"state,omitempty"`
}

// Alignment Alignment configuration for a plan or subscription.
type Alignment struct {
	// BillablesMustAlign Whether all Billable items and RateCards must align.
	// Alignment means the Price's BillingCadence must align for both duration and anchor time.
	BillablesMustAlign *bool `json:"billablesMustAlign,omitempty"`
}

// Annotations Set of key-value pairs managed by the system. Cannot be modified by user.
type Annotations map[string]interface{}

// App App.
// One of: stripe
type App struct {
	union json.RawMessage
}

// AppCapability App capability.
//
// Capabilities only exist in config so they don't extend the Resource model.
type AppCapability struct {
	// Description The capability description.
	Description string `json:"description"`

	// Key Key
	Key string `json:"key"`

	// Name The capability name.
	Name string `json:"name"`

	// Type The capability type.
	Type AppCapabilityType `json:"type"`
}

// AppCapabilityType App capability type.
type AppCapabilityType string

// AppPaginatedResponse Paginated response
type AppPaginatedResponse struct {
	// Items The items in the current page.
	Items []App `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// AppReference App reference
//
// Can be used as a short reference to an app if the full app object is not needed.
type AppReference struct {
	// Id The ID of the app.
	Id string `json:"id"`
}

// AppReplaceUpdate App ReplaceUpdate Model
type AppReplaceUpdate struct {
	union json.RawMessage
}

// AppStatus App installed status.
type AppStatus string

// AppType Type of the app.
type AppType string

// BadRequestProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type BadRequestProblemResponse = UnexpectedProblemResponse

// BalanceHistoryWindow The balance history window.
type BalanceHistoryWindow struct {
	// BalanceAtStart The entitlement balance at the start of the period.
	BalanceAtStart float64 `json:"balanceAtStart"`

	// Period A period with a start and end time.
	Period Period `json:"period"`

	// Usage The total usage of the feature in the period.
	Usage float64 `json:"usage"`
}

// BillingCustomerProfile Customer specific merged profile.
//
// This profile is calculated from the customer override and the billing profile it references or the default.
//
// Thus this does not have any kind of resource fields, only the calculated values.
type BillingCustomerProfile struct {
	// Apps The applications used by this billing profile.
	//
	// Expand settings govern if this includes the whole app object or just the ID references.
	Apps BillingProfileAppsOrReference `json:"apps"`

	// Supplier The name and contact information for the supplier this billing profile represents
	Supplier BillingParty `json:"supplier"`

	// Workflow The billing workflow settings for this profile
	Workflow BillingWorkflow `json:"workflow"`
}

// BillingDiscountPercentage A percentage discount.
type BillingDiscountPercentage struct {
	// CorrelationId Correlation ID for the discount.
	//
	// This is used to link discounts across different invoices (progressive billing use case).
	//
	// If not provided, the invoicing engine will auto-generate one. When editing an invoice line,
	// please make sure to keep the same correlation ID of the discount or in progressive billing
	// setups the discount amounts might be incorrect.
	CorrelationId *string `json:"correlationId,omitempty"`

	// Percentage The percentage of the discount.
	Percentage Percentage `json:"percentage"`
}

// BillingDiscountReason The reason for the discount.
type BillingDiscountReason struct {
	union json.RawMessage
}

// BillingDiscountUsage A usage discount.
type BillingDiscountUsage struct {
	// CorrelationId Correlation ID for the discount.
	//
	// This is used to link discounts across different invoices (progressive billing use case).
	//
	// If not provided, the invoicing engine will auto-generate one. When editing an invoice line,
	// please make sure to keep the same correlation ID of the discount or in progressive billing
	// setups the discount amounts might be incorrect.
	CorrelationId *string `json:"correlationId,omitempty"`

	// Quantity The quantity of the usage discount.
	//
	// Must be positive.
	Quantity Numeric `json:"quantity"`
}

// BillingDiscounts A discount by type.
type BillingDiscounts struct {
	// Percentage The percentage discount.
	Percentage *BillingDiscountPercentage `json:"percentage,omitempty"`

	// Usage The usage discount.
	Usage *BillingDiscountUsage `json:"usage,omitempty"`
}

// BillingParty Party represents a person or business entity.
type BillingParty struct {
	// Addresses Regular post addresses for where information should be sent if needed.
	Addresses *[]Address `json:"addresses,omitempty"`

	// Id Unique identifier for the party (if available)
	Id *string `json:"id,omitempty"`

	// Name Legal name or representation of the organization.
	Name *string `json:"name,omitempty"`

	// TaxId The entity's legal ID code used for tax purposes. They may have
	// other numbers, but we're only interested in those valid for tax purposes.
	TaxId *BillingPartyTaxIdentity `json:"taxId,omitempty"`
}

// BillingPartyReplaceUpdate Resource update operation model.
type BillingPartyReplaceUpdate struct {
	// Addresses Regular post addresses for where information should be sent if needed.
	Addresses *[]Address `json:"addresses,omitempty"`

	// Name Legal name or representation of the organization.
	Name *string `json:"name,omitempty"`

	// TaxId The entity's legal ID code used for tax purposes. They may have
	// other numbers, but we're only interested in those valid for tax purposes.
	TaxId *BillingPartyTaxIdentity `json:"taxId,omitempty"`
}

// BillingPartyTaxIdentity Identity stores the details required to identify an entity for tax purposes in a specific country.
type BillingPartyTaxIdentity struct {
	// Code Normalized tax code shown on the original identity document.
	Code *BillingTaxIdentificationCode `json:"code,omitempty"`
}

// BillingProfile BillingProfile represents a billing profile
type BillingProfile struct {
	// Apps The applications used by this billing profile.
	//
	// Expand settings govern if this includes the whole app object or just the ID references.
	Apps BillingProfileAppsOrReference `json:"apps"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Default Is this the default profile?
	Default bool `json:"default"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Supplier The name and contact information for the supplier this billing profile represents
	Supplier BillingParty `json:"supplier"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// Workflow The billing workflow settings for this profile
	Workflow BillingWorkflow `json:"workflow"`
}

// BillingProfileAppReferences BillingProfileAppReferences represents the references (id, type) to the apps used by a billing profile
type BillingProfileAppReferences struct {
	// Invoicing The invoicing app used for this workflow
	Invoicing AppReference `json:"invoicing"`

	// Payment The payment app used for this workflow
	Payment AppReference `json:"payment"`

	// Tax The tax app used for this workflow
	Tax AppReference `json:"tax"`
}

// BillingProfileApps BillingProfileApps represents the applications used by a billing profile
type BillingProfileApps struct {
	// Invoicing The invoicing app used for this workflow
	Invoicing App `json:"invoicing"`

	// Payment The payment app used for this workflow
	Payment App `json:"payment"`

	// Tax The tax app used for this workflow
	Tax App `json:"tax"`
}

// BillingProfileAppsCreate BillingProfileAppsCreate represents the input for creating a billing profile's apps
type BillingProfileAppsCreate struct {
	// Invoicing The invoicing app used for this workflow
	Invoicing string `json:"invoicing"`

	// Payment The payment app used for this workflow
	Payment string `json:"payment"`

	// Tax The tax app used for this workflow
	Tax string `json:"tax"`
}

// BillingProfileAppsOrReference ProfileAppsOrReference represents the union of ProfileApps and ProfileAppReferences
// for a billing profile.
type BillingProfileAppsOrReference struct {
	union json.RawMessage
}

// BillingProfileCreate BillingProfileCreate represents the input for creating a billing profile
type BillingProfileCreate struct {
	// Apps The apps used by this billing profile.
	Apps BillingProfileAppsCreate `json:"apps"`

	// Default Is this the default profile?
	Default bool `json:"default"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Supplier The name and contact information for the supplier this billing profile represents
	Supplier BillingParty `json:"supplier"`

	// Workflow The billing workflow settings for this profile.
	Workflow BillingWorkflowCreate `json:"workflow"`
}

// BillingProfileCustomerOverride Customer override values.
type BillingProfileCustomerOverride struct {
	// BillingProfileId The billing profile this override is associated with.
	//
	// If empty the default profile is looked up dynamically.
	BillingProfileId *string `json:"billingProfileId,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// CustomerId The customer id this override is associated with.
	CustomerId string `json:"customerId"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// BillingProfileCustomerOverrideCreate Payload for creating a new or updating an existing customer override.
type BillingProfileCustomerOverrideCreate struct {
	// BillingProfileId The billing profile this override is associated with.
	//
	// If not provided, the default billing profile is chosen if available.
	BillingProfileId *string `json:"billingProfileId,omitempty"`
}

// BillingProfileCustomerOverrideExpand CustomerOverrideExpand specifies the parts of the profile to expand.
type BillingProfileCustomerOverrideExpand string

// BillingProfileCustomerOverrideOrderBy Order by options for customers.
type BillingProfileCustomerOverrideOrderBy string

// BillingProfileCustomerOverrideWithDetails Customer specific workflow overrides.
type BillingProfileCustomerOverrideWithDetails struct {
	// BaseBillingProfileId The billing profile the customerProfile is associated with at the time of query.
	//
	// customerOverride contains the explicit mapping set in the customer override object. If that is
	// empty, then the baseBillingProfileId is the default profile.
	BaseBillingProfileId string `json:"baseBillingProfileId"`

	// Customer The customer this override belongs to.
	Customer *Customer `json:"customer,omitempty"`

	// CustomerOverride The customer override values.
	//
	// If empty the merged values are calculated based on the default profile.
	CustomerOverride *BillingProfileCustomerOverride `json:"customerOverride,omitempty"`

	// CustomerProfile Merged billing profile with the customer specific overrides.
	CustomerProfile *BillingCustomerProfile `json:"customerProfile,omitempty"`
}

// BillingProfileCustomerOverrideWithDetailsPaginatedResponse Paginated response
type BillingProfileCustomerOverrideWithDetailsPaginatedResponse struct {
	// Items The items in the current page.
	Items []BillingProfileCustomerOverrideWithDetails `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// BillingProfileExpand BillingProfileExpand details what profile fields to expand
type BillingProfileExpand string

// BillingProfileOrderBy BillingProfileOrderBy specifies the ordering options for profiles
type BillingProfileOrderBy string

// BillingProfilePaginatedResponse Paginated response
type BillingProfilePaginatedResponse struct {
	// Items The items in the current page.
	Items []BillingProfile `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// BillingProfileReplaceUpdateWithWorkflow BillingProfileReplaceUpdate represents the input for updating a billing profile
//
// The apps field cannot be updated directly, if an app change is desired a new
// profile should be created.
type BillingProfileReplaceUpdateWithWorkflow struct {
	// Default Is this the default profile?
	Default bool `json:"default"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Supplier The name and contact information for the supplier this billing profile represents
	Supplier BillingParty `json:"supplier"`

	// Workflow The billing workflow settings for this profile.
	Workflow BillingWorkflow `json:"workflow"`
}

// BillingTaxIdentificationCode TaxIdentificationCode is a normalized tax code shown on the original identity document.
type BillingTaxIdentificationCode = string

// BillingWorkflow BillingWorkflow represents the settings for a billing workflow.
type BillingWorkflow struct {
	// Collection The collection settings for this workflow
	Collection *BillingWorkflowCollectionSettings `json:"collection,omitempty"`

	// Invoicing The invoicing settings for this workflow
	Invoicing *BillingWorkflowInvoicingSettings `json:"invoicing,omitempty"`

	// Payment The payment settings for this workflow
	Payment *BillingWorkflowPaymentSettings `json:"payment,omitempty"`

	// Tax The tax settings for this workflow
	Tax *BillingWorkflowTaxSettings `json:"tax,omitempty"`
}

// BillingWorkflowCollectionAlignment BillingWorkflowCollectionAlignmentSubscription specifies the alignment for collecting the pending line items
// into an invoice.
type BillingWorkflowCollectionAlignment = BillingWorkflowCollectionAlignmentSubscription

// BillingWorkflowCollectionAlignmentSubscription BillingWorkflowCollectionAlignmentSubscription specifies the alignment for collecting the pending line items
// into an invoice.
type BillingWorkflowCollectionAlignmentSubscription struct {
	// Type The type of alignment.
	Type BillingWorkflowCollectionAlignmentSubscriptionType `json:"type"`
}

// BillingWorkflowCollectionAlignmentSubscriptionType The type of alignment.
type BillingWorkflowCollectionAlignmentSubscriptionType string

// BillingWorkflowCollectionSettings Workflow collection specifies how to collect the pending line items for an invoice
type BillingWorkflowCollectionSettings struct {
	// Alignment The alignment for collecting the pending line items into an invoice.
	Alignment *BillingWorkflowCollectionAlignment `json:"alignment,omitempty"`

	// Interval This grace period can be used to delay the collection of the pending line items specified in
	// alignment.
	//
	// This is useful, in case of multiple subscriptions having slightly different billing periods.
	Interval *string `json:"interval,omitempty"`
}

// BillingWorkflowCreate Resource create operation model.
type BillingWorkflowCreate struct {
	// Collection The collection settings for this workflow
	Collection *BillingWorkflowCollectionSettings `json:"collection,omitempty"`

	// Invoicing The invoicing settings for this workflow
	Invoicing *BillingWorkflowInvoicingSettings `json:"invoicing,omitempty"`

	// Payment The payment settings for this workflow
	Payment *BillingWorkflowPaymentSettings `json:"payment,omitempty"`

	// Tax The tax settings for this workflow
	Tax *BillingWorkflowTaxSettings `json:"tax,omitempty"`
}

// BillingWorkflowInvoicingSettings BillingWorkflowInvoicingSettings represents the invoice settings for a billing workflow
type BillingWorkflowInvoicingSettings struct {
	// AutoAdvance Whether to automatically issue the invoice after the draftPeriod has passed.
	AutoAdvance *bool `json:"autoAdvance,omitempty"`

	// DefaultTaxConfig Default tax configuration to apply to the invoices.
	DefaultTaxConfig *TaxConfig `json:"defaultTaxConfig,omitempty"`

	// DraftPeriod The period for the invoice to be kept in draft status for manual reviews.
	DraftPeriod *string `json:"draftPeriod,omitempty"`

	// DueAfter The period after which the invoice is due.
	// With some payment solutions it's only applicable for manual collection method.
	DueAfter *string `json:"dueAfter,omitempty"`

	// ProgressiveBilling Should progressive billing be allowed for this workflow?
	ProgressiveBilling *bool `json:"progressiveBilling,omitempty"`
}

// BillingWorkflowPaymentSettings BillingWorkflowPaymentSettings represents the payment settings for a billing workflow
type BillingWorkflowPaymentSettings struct {
	// CollectionMethod The payment method for the invoice.
	CollectionMethod *CollectionMethod `json:"collectionMethod,omitempty"`
}

// BillingWorkflowTaxSettings BillingWorkflowTaxSettings represents the tax settings for a billing workflow
type BillingWorkflowTaxSettings struct {
	// Enabled Enable automatic tax calculation when tax is supported by the app.
	// For example, with Stripe Invoicing when enabled, tax is calculated via Stripe Tax.
	Enabled *bool `json:"enabled,omitempty"`

	// Enforced Enforce tax calculation when tax is supported by the app.
	// When enabled, OpenMeter will not allow to create an invoice without tax calculation.
	// Enforcement is different per apps, for example, Stripe app requires customer
	// to have a tax location when starting a paid subscription.
	Enforced *bool `json:"enforced,omitempty"`
}

// CheckoutSessionCustomTextAfterSubmitParams Stripe CheckoutSession.custom_text
type CheckoutSessionCustomTextAfterSubmitParams struct {
	// AfterSubmit Custom text that should be displayed after the payment confirmation button.
	AfterSubmit *struct {
		Message *string `json:"message,omitempty"`
	} `json:"afterSubmit,omitempty"`

	// ShippingAddress Custom text that should be displayed alongside shipping address collection.
	ShippingAddress *struct {
		Message *string `json:"message,omitempty"`
	} `json:"shippingAddress,omitempty"`

	// Submit Custom text that should be displayed alongside the payment confirmation button.
	Submit *struct {
		Message *string `json:"message,omitempty"`
	} `json:"submit,omitempty"`

	// TermsOfServiceAcceptance Custom text that should be displayed in place of the default terms of service agreement text.
	TermsOfServiceAcceptance *struct {
		Message *string `json:"message,omitempty"`
	} `json:"termsOfServiceAcceptance,omitempty"`
}

// CheckoutSessionUIMode Stripe CheckoutSession.ui_mode
type CheckoutSessionUIMode string

// ClientAppStartResponse Response from the client app (OpenMeter backend) to start the OAuth2 flow.
type ClientAppStartResponse struct {
	// Url The URL to start the OAuth2 authorization code grant flow.
	Url string `json:"url"`
}

// CollectionMethod CollectionMethod specifies how the invoice should be collected (automatic vs manual)
type CollectionMethod string

// ConflictProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type ConflictProblemResponse = UnexpectedProblemResponse

// CountryCode [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.
// Custom two-letter country codes are also supported for convenience.
type CountryCode = string

// CreateCheckoutSessionTaxIdCollection Create Stripe checkout session tax ID collection.
type CreateCheckoutSessionTaxIdCollection struct {
	// Enabled Enable tax ID collection during checkout. Defaults to false.
	Enabled bool `json:"enabled"`

	// Required Describes whether a tax ID is required during checkout. Defaults to never.
	Required *CreateCheckoutSessionTaxIdCollectionRequired `json:"required,omitempty"`
}

// CreateCheckoutSessionTaxIdCollectionRequired Create Stripe checkout session tax ID collection required.
type CreateCheckoutSessionTaxIdCollectionRequired string

// CreateStripeCheckoutSessionBillingAddressCollection Specify whether Checkout should collect the customers billing address.
type CreateStripeCheckoutSessionBillingAddressCollection string

// CreateStripeCheckoutSessionConsentCollection Configure fields for the Checkout Session to gather active consent from customers.
type CreateStripeCheckoutSessionConsentCollection struct {
	// PaymentMethodReuseAgreement Determines the position and visibility of the payment method reuse agreement in the UI.
	// When set to auto, Stripes defaults will be used. When set to hidden, the payment method reuse agreement text will always be hidden in the UI.
	PaymentMethodReuseAgreement *CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreement `json:"paymentMethodReuseAgreement,omitempty"`

	// Promotions If set to auto, enables the collection of customer consent for promotional communications.
	// The Checkout Session will determine whether to display an option to opt into promotional
	// communication from the merchant depending on the customers locale. Only available to US merchants.
	Promotions *CreateStripeCheckoutSessionConsentCollectionPromotions `json:"promotions,omitempty"`

	// TermsOfService If set to required, it requires customers to check a terms of service checkbox before being able to pay.
	// There must be a valid terms of service URL set in your Stripe Dashboard settings.
	// https://dashboard.stripe.com/settings/public
	TermsOfService *CreateStripeCheckoutSessionConsentCollectionTermsOfService `json:"termsOfService,omitempty"`
}

// CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreement Create Stripe checkout session payment method reuse agreement.
type CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreement struct {
	// Position Create Stripe checkout session consent collection agreement position.
	Position *CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreementPosition `json:"position,omitempty"`
}

// CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreementPosition Create Stripe checkout session consent collection agreement position.
type CreateStripeCheckoutSessionConsentCollectionPaymentMethodReuseAgreementPosition string

// CreateStripeCheckoutSessionConsentCollectionPromotions Create Stripe checkout session consent collection promotions.
type CreateStripeCheckoutSessionConsentCollectionPromotions string

// CreateStripeCheckoutSessionConsentCollectionTermsOfService Create Stripe checkout session consent collection terms of service.
type CreateStripeCheckoutSessionConsentCollectionTermsOfService string

// CreateStripeCheckoutSessionCustomerUpdate Controls what fields on Customer can be updated by the Checkout Session.
type CreateStripeCheckoutSessionCustomerUpdate struct {
	// Address Describes whether Checkout saves the billing address onto customer.address.
	// To always collect a full billing address, use billing_address_collection.
	// Defaults to never.
	Address *CreateStripeCheckoutSessionCustomerUpdateBehavior `json:"address,omitempty"`

	// Name Describes whether Checkout saves the name onto customer.name.
	// Defaults to never.
	Name *CreateStripeCheckoutSessionCustomerUpdateBehavior `json:"name,omitempty"`

	// Shipping Describes whether Checkout saves shipping information onto customer.shipping.
	// To collect shipping information, use shipping_address_collection.
	// Defaults to never.
	Shipping *CreateStripeCheckoutSessionCustomerUpdateBehavior `json:"shipping,omitempty"`
}

// CreateStripeCheckoutSessionCustomerUpdateBehavior Create Stripe checkout session customer update behavior.
type CreateStripeCheckoutSessionCustomerUpdateBehavior string

// CreateStripeCheckoutSessionRedirectOnCompletion Create Stripe checkout session redirect on completion.
type CreateStripeCheckoutSessionRedirectOnCompletion string

// CreateStripeCheckoutSessionRequest Create Stripe checkout session request.
type CreateStripeCheckoutSessionRequest struct {
	// AppId If not provided, the default Stripe app is used if any.
	AppId *string `json:"appId,omitempty"`

	// Customer Provide a customer ID or key to use an existing OpenMeter customer.
	// or provide a customer object to create a new customer.
	Customer CreateStripeCheckoutSessionRequest_Customer `json:"customer"`

	// Options Options passed to Stripe when creating the checkout session.
	Options CreateStripeCheckoutSessionRequestOptions `json:"options"`

	// StripeCustomerId Stripe customer ID.
	// If not provided OpenMeter creates a new Stripe customer or
	// uses the OpenMeter customer's default Stripe customer ID.
	StripeCustomerId *string `json:"stripeCustomerId,omitempty"`
}

// CreateStripeCheckoutSessionRequest_Customer Provide a customer ID or key to use an existing OpenMeter customer.
// or provide a customer object to create a new customer.
type CreateStripeCheckoutSessionRequest_Customer struct {
	union json.RawMessage
}

// CreateStripeCheckoutSessionRequestOptions Create Stripe checkout session options
// See https://docs.stripe.com/api/checkout/sessions/create
type CreateStripeCheckoutSessionRequestOptions struct {
	// BillingAddressCollection Specify whether Checkout should collect the customers billing address. Defaults to auto.
	BillingAddressCollection *CreateStripeCheckoutSessionBillingAddressCollection `json:"billingAddressCollection,omitempty"`

	// CancelURL If set, Checkout displays a back button and customers will be directed to this URL if they decide to cancel payment and return to your website.
	// This parameter is not allowed if ui_mode is embedded.
	CancelURL *string `json:"cancelURL,omitempty"`

	// ClientReferenceID A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the session with your internal systems.
	ClientReferenceID *string `json:"clientReferenceID,omitempty"`

	// ConsentCollection Configure fields for the Checkout Session to gather active consent from customers.
	ConsentCollection *CreateStripeCheckoutSessionConsentCollection `json:"consentCollection,omitempty"`

	// Currency Three-letter ISO currency code, in lowercase.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// CustomText Display additional text for your customers using custom text.
	CustomText *CheckoutSessionCustomTextAfterSubmitParams `json:"customText,omitempty"`

	// CustomerUpdate Controls what fields on Customer can be updated by the Checkout Session.
	CustomerUpdate *CreateStripeCheckoutSessionCustomerUpdate `json:"customerUpdate,omitempty"`

	// ExpiresAt The Epoch time in seconds at which the Checkout Session will expire.
	// It can be anywhere from 30 minutes to 24 hours after Checkout Session creation. By default, this value is 24 hours from creation.
	ExpiresAt *int64  `json:"expiresAt,omitempty"`
	Locale    *string `json:"locale,omitempty"`

	// Metadata Set of key-value pairs that you can attach to an object.
	// This can be useful for storing additional information about the object in a structured format.
	// Individual keys can be unset by posting an empty value to them.
	// All keys can be unset by posting an empty value to metadata.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// PaymentMethodTypes A list of the types of payment methods (e.g., card) this Checkout Session can accept.
	PaymentMethodTypes *[]string `json:"paymentMethodTypes,omitempty"`

	// RedirectOnCompletion This parameter applies to ui_mode: embedded. Defaults to always.
	// Learn more about the redirect behavior of embedded sessions at
	// https://docs.stripe.com/payments/checkout/custom-success-page?payment-ui=embedded-form
	RedirectOnCompletion *CreateStripeCheckoutSessionRedirectOnCompletion `json:"redirectOnCompletion,omitempty"`

	// ReturnURL The URL to redirect your customer back to after they authenticate or cancel their payment on the payment methods app or site.
	// This parameter is required if ui_mode is embedded and redirect-based payment methods are enabled on the session.
	ReturnURL *string `json:"returnURL,omitempty"`

	// SuccessURL The URL to which Stripe should send customers when payment or setup is complete.
	// This parameter is not allowed if ui_mode is embedded.
	// If youd like to use information from the successful Checkout Session on your page, read the guide on customizing your success page:
	// https://docs.stripe.com/payments/checkout/custom-success-page
	SuccessURL *string `json:"successURL,omitempty"`

	// TaxIdCollection Controls tax ID collection during checkout.
	TaxIdCollection *CreateCheckoutSessionTaxIdCollection `json:"taxIdCollection,omitempty"`

	// UiMode The UI mode of the Session. Defaults to hosted.
	UiMode *CheckoutSessionUIMode `json:"uiMode,omitempty"`
}

// CreateStripeCheckoutSessionResult Create Stripe Checkout Session response.
type CreateStripeCheckoutSessionResult struct {
	// CancelURL Cancel URL.
	CancelURL *string `json:"cancelURL,omitempty"`

	// ClientReferenceId A unique string to reference the Checkout Session.
	// This can be a customer ID, a cart ID, or similar, and can be used to reconcile the session with your internal systems.
	ClientReferenceId *string `json:"clientReferenceId,omitempty"`

	// ClientSecret The client secret of the checkout session.
	// This can be used to initialize Stripe.js for your client-side implementation.
	ClientSecret *string `json:"clientSecret,omitempty"`

	// CreatedAt Timestamp at which the checkout session was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency Three-letter ISO currency code, in lowercase.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// CustomerEmail Customer's email address provided to Stripe.
	CustomerEmail *string `json:"customerEmail,omitempty"`

	// CustomerId The OpenMeter customer ID.
	CustomerId string `json:"customerId"`

	// ExpiresAt Timestamp at which the checkout session will expire.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Metadata Set of key-value pairs attached to the checkout session.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// Mode Mode
	// Always `setup` for now.
	Mode StripeCheckoutSessionMode `json:"mode"`

	// ReturnURL Return URL.
	ReturnURL *string `json:"returnURL,omitempty"`

	// SessionId The checkout session ID.
	SessionId string `json:"sessionId"`

	// SetupIntentId The checkout session setup intent ID.
	SetupIntentId string `json:"setupIntentId"`

	// Status The status of the checkout session.
	Status *string `json:"status,omitempty"`

	// StripeCustomerId The Stripe customer ID.
	StripeCustomerId string `json:"stripeCustomerId"`

	// SuccessURL Success URL.
	SuccessURL *string `json:"successURL,omitempty"`

	// Url URL to show the checkout session.
	Url *string `json:"url,omitempty"`
}

// CreditNoteOriginalInvoiceRef Omitted fields:
// period: Tax period in which the referred document had an effect required by some tax regimes and formats.
// stamps: Seals of approval from other organisations that may need to be listed.
// ext: 	Extensions for additional codes that may be required.
type CreditNoteOriginalInvoiceRef = InvoiceGenericDocumentRef

// Currency Currency describes a currency supported by OpenMeter.
type Currency struct {
	// Code The currency ISO code.
	Code CurrencyCode `json:"code"`

	// Name The currency name.
	Name string `json:"name"`

	// Subunits Subunit of the currency.
	Subunits uint32 `json:"subunits"`

	// Symbol The currency symbol.
	Symbol string `json:"symbol"`
}

// CurrencyCode Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.
// Custom three-letter currency codes are also supported for convenience.
type CurrencyCode = string

// CustomInvoicingApp Custom Invoicing app can be used for interface with any invoicing or payment system.
//
// This app provides ways to manipulate invoices and payments, however the integration
// must rely on Notifications API to get notified about invoice changes.
type CustomInvoicingApp struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Default Default for the app type
	// Only one app of each type can be default.
	Default bool `json:"default"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EnableDraftSyncHook Enable draft.sync hook.
	//
	// If the hook is not enabled, the invoice will be progressed to the next state automatically.
	EnableDraftSyncHook bool `json:"enableDraftSyncHook"`

	// EnableIssuingSyncHook Enable issuing.sync hook.
	//
	// If the hook is not enabled, the invoice will be progressed to the next state automatically.
	EnableIssuingSyncHook bool `json:"enableIssuingSyncHook"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Listing The marketplace listing that this installed app is based on.
	Listing MarketplaceListing `json:"listing"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Status Status of the app connection.
	Status AppStatus `json:"status"`

	// Type The app's type is CustomInvoicing.
	Type CustomInvoicingAppType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// CustomInvoicingAppType The app's type is CustomInvoicing.
type CustomInvoicingAppType string

// CustomInvoicingAppReplaceUpdate Resource update operation model.
type CustomInvoicingAppReplaceUpdate struct {
	// Default Default for the app type
	// Only one app of each type can be default.
	Default bool `json:"default"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EnableDraftSyncHook Enable draft.sync hook.
	//
	// If the hook is not enabled, the invoice will be progressed to the next state automatically.
	EnableDraftSyncHook bool `json:"enableDraftSyncHook"`

	// EnableIssuingSyncHook Enable issuing.sync hook.
	//
	// If the hook is not enabled, the invoice will be progressed to the next state automatically.
	EnableIssuingSyncHook bool `json:"enableIssuingSyncHook"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Type The app's type is CustomInvoicing.
	Type CustomInvoicingAppReplaceUpdateType `json:"type"`
}

// CustomInvoicingAppReplaceUpdateType The app's type is CustomInvoicing.
type CustomInvoicingAppReplaceUpdateType string

// CustomInvoicingCustomerAppData Custom Invoicing Customer App Data.
type CustomInvoicingCustomerAppData struct {
	// App The installed custom invoicing app this data belongs to.
	App *CustomInvoicingApp `json:"app,omitempty"`

	// Id The app ID.
	// If not provided, it will use the global default for the app type.
	Id *string `json:"id,omitempty"`

	// Metadata Metadata to be used by the custom invoicing provider.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Type The app name.
	Type CustomInvoicingCustomerAppDataType `json:"type"`
}

// CustomInvoicingCustomerAppDataType The app name.
type CustomInvoicingCustomerAppDataType string

// CustomInvoicingDraftSynchronizedRequest Information to finalize the draft details of an invoice.
type CustomInvoicingDraftSynchronizedRequest struct {
	// Invoicing The result of the synchronization.
	Invoicing *CustomInvoicingSyncResult `json:"invoicing,omitempty"`
}

// CustomInvoicingFinalizedInvoicingRequest Information to finalize the invoicing details of an invoice.
type CustomInvoicingFinalizedInvoicingRequest struct {
	// InvoiceNumber If set the invoice's number will be set to this value.
	InvoiceNumber *InvoiceNumber `json:"invoiceNumber,omitempty"`

	// SentToCustomerAt If set the invoice's sent to customer at will be set to this value.
	SentToCustomerAt *time.Time `json:"sentToCustomerAt,omitempty"`
}

// CustomInvoicingFinalizedPaymentRequest Information to finalize the payment details of an invoice.
type CustomInvoicingFinalizedPaymentRequest struct {
	// ExternalId If set the invoice's payment external ID will be set to this value.
	ExternalId *string `json:"externalId,omitempty"`
}

// CustomInvoicingFinalizedRequest Information to finalize the invoice.
//
// If invoicing.invoiceNumber is not set, then a new invoice number will be generated (INV- prefix).
type CustomInvoicingFinalizedRequest struct {
	// Invoicing The result of the synchronization.
	Invoicing *CustomInvoicingFinalizedInvoicingRequest `json:"invoicing,omitempty"`

	// Payment The result of the payment synchronization.
	Payment *CustomInvoicingFinalizedPaymentRequest `json:"payment,omitempty"`
}

// CustomInvoicingLineDiscountExternalIdMapping Mapping between line discounts and external IDs.
type CustomInvoicingLineDiscountExternalIdMapping struct {
	// ExternalId The external ID (e.g. custom invoicing system's ID).
	ExternalId string `json:"externalId"`

	// LineDiscountId The line discount ID.
	LineDiscountId string `json:"lineDiscountId"`
}

// CustomInvoicingLineExternalIdMapping Mapping between lines and external IDs.
type CustomInvoicingLineExternalIdMapping struct {
	// ExternalId The external ID (e.g. custom invoicing system's ID).
	ExternalId string `json:"externalId"`

	// LineId The line ID.
	LineId string `json:"lineId"`
}

// CustomInvoicingPaymentTrigger Payment trigger to execute on a finalized invoice.
type CustomInvoicingPaymentTrigger string

// CustomInvoicingSyncResult Information to synchronize the invoice.
//
// Can be used to store external app's IDs on the invoice or lines.
type CustomInvoicingSyncResult struct {
	// ExternalId If set the invoice's invoicing external ID will be set to this value.
	ExternalId *string `json:"externalId,omitempty"`

	// InvoiceNumber If set the invoice's number will be set to this value.
	InvoiceNumber *InvoiceNumber `json:"invoiceNumber,omitempty"`

	// LineDiscountExternalIds If set the invoice's line discount external IDs will be set to this value.
	//
	// This can be used to reference the external system's entities in the
	// invoice.
	LineDiscountExternalIds *[]CustomInvoicingLineDiscountExternalIdMapping `json:"lineDiscountExternalIds,omitempty"`

	// LineExternalIds If set the invoice's line external IDs will be set to this value.
	//
	// This can be used to reference the external system's entities in the
	// invoice.
	LineExternalIds *[]CustomInvoicingLineExternalIdMapping `json:"lineExternalIds,omitempty"`
}

// CustomInvoicingTaxConfig Custom invoicing tax config.
type CustomInvoicingTaxConfig struct {
	// Code Tax code.
	//
	// The tax code should be interpreted by the custom invoicing provider.
	Code string `json:"code"`
}

// CustomInvoicingUpdatePaymentStatusRequest Update payment status request.
//
// Can be used to manipulate invoice's payment status (when custominvoicing app is being used).
type CustomInvoicingUpdatePaymentStatusRequest struct {
	// Trigger The trigger to be executed on the invoice.
	Trigger CustomInvoicingPaymentTrigger `json:"trigger"`
}

// CustomPlanInput The template for omitting properties.
type CustomPlanInput struct {
	// Alignment Alignment configuration for the plan.
	Alignment *Alignment `json:"alignment,omitempty"`

	// Currency The currency code of the plan.
	Currency CurrencyCode `json:"currency"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Phases The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
	// A phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.
	Phases []PlanPhase `json:"phases"`
}

// CustomSubscriptionChange Change a custom subscription.
type CustomSubscriptionChange struct {
	// CustomPlan The custom plan description which defines the Subscription.
	CustomPlan CustomPlanInput `json:"customPlan"`

	// Timing Timing configuration for the change, when the change should take effect.
	// For changing a subscription, the accepted values depend on the subscription configuration.
	Timing SubscriptionTiming `json:"timing"`
}

// CustomSubscriptionCreate Create a custom subscription.
type CustomSubscriptionCreate struct {
	// CustomPlan The custom plan description which defines the Subscription.
	CustomPlan CustomPlanInput `json:"customPlan"`

	// CustomerId The ID of the customer. Provide either the key or ID. Has presedence over the key.
	CustomerId *string `json:"customerId,omitempty"`

	// CustomerKey The key of the customer. Provide either the key or ID.
	CustomerKey *string `json:"customerKey,omitempty"`

	// Timing Timing configuration for the change, when the change should take effect.
	// The default is immediate.
	Timing *SubscriptionTiming `json:"timing,omitempty"`
}

// Customer A customer object.
type Customer struct {
	// BillingAddress The billing address of the customer.
	// Used for tax and invoicing.
	BillingAddress *Address `json:"billingAddress,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency Currency of the customer.
	// Used for billing, tax and invoicing.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// CurrentSubscriptionId The ID of the Subscription if the customer has one.
	CurrentSubscriptionId *string `json:"currentSubscriptionId,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Key An optional unique key of the customer.
	// Useful to reference the customer in external systems.
	// For example, your database ID.
	Key *string `json:"key,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PrimaryEmail The primary email address of the customer.
	PrimaryEmail *string `json:"primaryEmail,omitempty"`

	// Subscriptions The subscriptions of the customer.
	// Only with the `subscriptions` expand option.
	Subscriptions *[]Subscription `json:"subscriptions,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// UsageAttribution Mapping to attribute metered usage to the customer
	UsageAttribution CustomerUsageAttribution `json:"usageAttribution"`
}

// CustomerAccess CustomerAccess describes what features the customer has access to.
type CustomerAccess struct {
	// Entitlements Map of entitlements the customer has access to.
	// The key is the feature key, the value is the entitlement value + the entitlement ID.
	Entitlements map[string]EntitlementValue `json:"entitlements"`
}

// CustomerAppData CustomerAppData
// Stores the app specific data for the customer.
// One of: stripe, sandbox, custom_invoicing
type CustomerAppData struct {
	union json.RawMessage
}

// CustomerAppDataCreateOrUpdateItem CustomerAppData
// Stores the app specific data for the customer.
// One of: stripe, sandbox, custom_invoicing
type CustomerAppDataCreateOrUpdateItem struct {
	union json.RawMessage
}

// CustomerAppDataPaginatedResponse Paginated response
type CustomerAppDataPaginatedResponse struct {
	// Items The items in the current page.
	Items []CustomerAppData `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// CustomerCreate Resource create operation model.
type CustomerCreate struct {
	// BillingAddress The billing address of the customer.
	// Used for tax and invoicing.
	BillingAddress *Address `json:"billingAddress,omitempty"`

	// Currency Currency of the customer.
	// Used for billing, tax and invoicing.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Key An optional unique key of the customer.
	// Useful to reference the customer in external systems.
	// For example, your database ID.
	Key *string `json:"key,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PrimaryEmail The primary email address of the customer.
	PrimaryEmail *string `json:"primaryEmail,omitempty"`

	// UsageAttribution Mapping to attribute metered usage to the customer
	UsageAttribution CustomerUsageAttribution `json:"usageAttribution"`
}

// CustomerExpand CustomerExpand specifies the parts of the customer to expand in the list output.
type CustomerExpand string

// CustomerId Create Stripe checkout session with customer ID.
type CustomerId struct {
	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id string `json:"id"`
}

// CustomerKey Create Stripe checkout session with customer key.
type CustomerKey struct {
	Key string `json:"key"`
}

// CustomerOrderBy Order by options for customers.
type CustomerOrderBy string

// CustomerPaginatedResponse Paginated response
type CustomerPaginatedResponse struct {
	// Items The items in the current page.
	Items []Customer `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// CustomerReplaceUpdate Resource update operation model.
type CustomerReplaceUpdate struct {
	// BillingAddress The billing address of the customer.
	// Used for tax and invoicing.
	BillingAddress *Address `json:"billingAddress,omitempty"`

	// Currency Currency of the customer.
	// Used for billing, tax and invoicing.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Key An optional unique key of the customer.
	// Useful to reference the customer in external systems.
	// For example, your database ID.
	Key *string `json:"key,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PrimaryEmail The primary email address of the customer.
	PrimaryEmail *string `json:"primaryEmail,omitempty"`

	// UsageAttribution Mapping to attribute metered usage to the customer
	UsageAttribution CustomerUsageAttribution `json:"usageAttribution"`
}

// CustomerUsageAttribution Mapping to attribute metered usage to the customer.
// One customer can have multiple subjects,
// but one subject can only belong to one customer.
type CustomerUsageAttribution struct {
	// SubjectKeys The subjects that are attributed to the customer.
	SubjectKeys []string `json:"subjectKeys"`
}

// DiscountPercentage Percentage discount.
type DiscountPercentage struct {
	// Percentage The percentage of the discount.
	Percentage Percentage `json:"percentage"`
}

// DiscountReasonMaximumSpend The reason for the discount is a maximum spend.
type DiscountReasonMaximumSpend struct {
	Type DiscountReasonMaximumSpendType `json:"type"`
}

// DiscountReasonMaximumSpendType defines model for DiscountReasonMaximumSpend.Type.
type DiscountReasonMaximumSpendType string

// DiscountReasonRatecardPercentage The reason for the discount is a ratecard percentage.
type DiscountReasonRatecardPercentage struct {
	// CorrelationId Correlation ID for the discount.
	//
	// This is used to link discounts across different invoices (progressive billing use case).
	//
	// If not provided, the invoicing engine will auto-generate one. When editing an invoice line,
	// please make sure to keep the same correlation ID of the discount or in progressive billing
	// setups the discount amounts might be incorrect.
	CorrelationId *string `json:"correlationId,omitempty"`

	// Percentage The percentage of the discount.
	Percentage Percentage                           `json:"percentage"`
	Type       DiscountReasonRatecardPercentageType `json:"type"`
}

// DiscountReasonRatecardPercentageType defines model for DiscountReasonRatecardPercentage.Type.
type DiscountReasonRatecardPercentageType string

// DiscountReasonRatecardUsage The reason for the discount is a ratecard usage.
type DiscountReasonRatecardUsage struct {
	// CorrelationId Correlation ID for the discount.
	//
	// This is used to link discounts across different invoices (progressive billing use case).
	//
	// If not provided, the invoicing engine will auto-generate one. When editing an invoice line,
	// please make sure to keep the same correlation ID of the discount or in progressive billing
	// setups the discount amounts might be incorrect.
	CorrelationId *string `json:"correlationId,omitempty"`

	// Quantity The quantity of the usage discount.
	//
	// Must be positive.
	Quantity Numeric                         `json:"quantity"`
	Type     DiscountReasonRatecardUsageType `json:"type"`
}

// DiscountReasonRatecardUsageType defines model for DiscountReasonRatecardUsage.Type.
type DiscountReasonRatecardUsageType string

// DiscountUsage Usage discount.
//
// Usage discount means that the first N items are free. From billing perspective
// this means that any usage on a specific feature is considered 0 until this discount
// is exhausted.
type DiscountUsage struct {
	// Quantity The quantity of the usage discount.
	//
	// Must be positive.
	Quantity Numeric `json:"quantity"`
}

// Discounts Discount by type on a price
type Discounts struct {
	// Percentage The percentage discount.
	Percentage *DiscountPercentage `json:"percentage,omitempty"`

	// Usage The usage discount.
	Usage *DiscountUsage `json:"usage,omitempty"`
}

// DynamicPriceWithCommitments Dynamic price with spend commitments.
type DynamicPriceWithCommitments struct {
	// MaximumAmount The customer is limited to spend at most the amount.
	MaximumAmount *Numeric `json:"maximumAmount,omitempty"`

	// MinimumAmount The customer is committed to spend at least the amount.
	MinimumAmount *Numeric `json:"minimumAmount,omitempty"`

	// Multiplier The multiplier to apply to the base price to get the dynamic price.
	//
	// Examples:
	// - 0.0: the price is zero
	// - 0.5: the price is 50% of the base price
	// - 1.0: the price is the same as the base price
	// - 1.5: the price is 150% of the base price
	Multiplier *Numeric `json:"multiplier,omitempty"`

	// Type The type of the price.
	Type DynamicPriceWithCommitmentsType `json:"type"`
}

// DynamicPriceWithCommitmentsType The type of the price.
type DynamicPriceWithCommitmentsType string

// EditSubscriptionAddItem Add a new item to a phase.
type EditSubscriptionAddItem struct {
	Op       EditSubscriptionAddItemOp `json:"op"`
	PhaseKey string                    `json:"phaseKey"`

	// RateCard A rate card defines the pricing and entitlement of a feature or service.
	RateCard RateCard `json:"rateCard"`
}

// EditSubscriptionAddItemOp defines model for EditSubscriptionAddItem.Op.
type EditSubscriptionAddItemOp string

// EditSubscriptionAddPhase Add a new phase
type EditSubscriptionAddPhase struct {
	Op EditSubscriptionAddPhaseOp `json:"op"`

	// Phase Subscription phase create input.
	Phase SubscriptionPhaseCreate `json:"phase"`
}

// EditSubscriptionAddPhaseOp defines model for EditSubscriptionAddPhase.Op.
type EditSubscriptionAddPhaseOp string

// EditSubscriptionRemoveItem Remove an item from a phase.
type EditSubscriptionRemoveItem struct {
	ItemKey  string                       `json:"itemKey"`
	Op       EditSubscriptionRemoveItemOp `json:"op"`
	PhaseKey string                       `json:"phaseKey"`
}

// EditSubscriptionRemoveItemOp defines model for EditSubscriptionRemoveItem.Op.
type EditSubscriptionRemoveItemOp string

// EditSubscriptionRemovePhase Remove a phase
type EditSubscriptionRemovePhase struct {
	Op       EditSubscriptionRemovePhaseOp `json:"op"`
	PhaseKey string                        `json:"phaseKey"`

	// Shift The direction of the phase shift when a phase is removed.
	Shift RemovePhaseShifting `json:"shift"`
}

// EditSubscriptionRemovePhaseOp defines model for EditSubscriptionRemovePhase.Op.
type EditSubscriptionRemovePhaseOp string

// EditSubscriptionStretchPhase Stretch a phase
type EditSubscriptionStretchPhase struct {
	ExtendBy string                         `json:"extendBy"`
	Op       EditSubscriptionStretchPhaseOp `json:"op"`
	PhaseKey string                         `json:"phaseKey"`
}

// EditSubscriptionStretchPhaseOp defines model for EditSubscriptionStretchPhase.Op.
type EditSubscriptionStretchPhaseOp string

// EditSubscriptionUnscheduleEdit Unschedules any edits from the current phase.
type EditSubscriptionUnscheduleEdit struct {
	Op EditSubscriptionUnscheduleEditOp `json:"op"`
}

// EditSubscriptionUnscheduleEditOp defines model for EditSubscriptionUnscheduleEdit.Op.
type EditSubscriptionUnscheduleEditOp string

// Entitlement Entitlement templates are used to define the entitlements of a plan.
// Features are omitted from the entitlement template, as they are defined in the rate card.
type Entitlement struct {
	union json.RawMessage
}

// EntitlementBaseTemplate Shared fields of the entitlement templates.
type EntitlementBaseTemplate struct {
	// ActiveFrom The cadence start of the resource.
	ActiveFrom time.Time `json:"activeFrom"`

	// ActiveTo The cadence end of the resource.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// Annotations The annotations of the entitlement.
	Annotations *Annotations `json:"annotations,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// CurrentUsagePeriod The current usage period.
	CurrentUsagePeriod *Period `json:"currentUsagePeriod,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id string `json:"id"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string `json:"subjectKey"`

	// Type The type of the entitlement.
	Type EntitlementType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// UsagePeriod The defined usage period of the entitlement
	UsagePeriod *RecurringPeriod `json:"usagePeriod,omitempty"`
}

// EntitlementBoolean Shared fields of the entitlement templates.
type EntitlementBoolean = EntitlementBaseTemplate

// EntitlementBooleanCreateInputs Create inputs for boolean entitlement
type EntitlementBooleanCreateInputs struct {
	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata                          `json:"metadata,omitempty"`
	Type     EntitlementBooleanCreateInputsType `json:"type"`

	// UsagePeriod The usage period associated with the entitlement.
	UsagePeriod *RecurringPeriodCreateInput `json:"usagePeriod,omitempty"`
}

// EntitlementBooleanCreateInputsType defines model for EntitlementBooleanCreateInputs.Type.
type EntitlementBooleanCreateInputsType string

// EntitlementCreateInputs Create inputs for entitlement
type EntitlementCreateInputs struct {
	union json.RawMessage
}

// EntitlementGrant The grant.
type EntitlementGrant struct {
	// Amount The amount to grant. Should be a positive number.
	Amount float64 `json:"amount"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// EffectiveAt Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
	EffectiveAt time.Time `json:"effectiveAt"`

	// EntitlementId The unique entitlement ULID that the grant is associated with.
	EntitlementId string `json:"entitlementId"`

	// Expiration The grant expiration definition
	Expiration ExpirationPeriod `json:"expiration"`

	// ExpiresAt The time the grant expires.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Id Readonly unique ULID identifier.
	Id string `json:"id"`

	// MaxRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MaxRolloverAmount *float64 `json:"maxRolloverAmount,omitempty"`

	// Metadata The grant metadata.
	Metadata *Metadata `json:"metadata,omitempty"`

	// MinRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MinRolloverAmount *float64 `json:"minRolloverAmount,omitempty"`

	// NextRecurrence The next time the grant will recurr.
	NextRecurrence *time.Time `json:"nextRecurrence,omitempty"`

	// Priority The priority of the grant. Grants with higher priority are applied first.
	// Priority is a positive decimal numbers. With lower numbers indicating higher importance.
	// For example, a priority of 1 is more urgent than a priority of 2.
	// When there are several grants available for the same subject, the system selects the grant with the highest priority.
	// In cases where grants share the same priority level, the grant closest to its expiration will be used first.
	// In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
	Priority *uint8 `json:"priority,omitempty"`

	// Recurrence The recurrence period of the grant.
	Recurrence *RecurringPeriod `json:"recurrence,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// VoidedAt The time the grant was voided.
	VoidedAt *time.Time `json:"voidedAt,omitempty"`
}

// EntitlementGrantCreateInput The grant creation input.
type EntitlementGrantCreateInput struct {
	// Amount The amount to grant. Should be a positive number.
	Amount float64 `json:"amount"`

	// EffectiveAt Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
	EffectiveAt time.Time `json:"effectiveAt"`

	// Expiration The grant expiration definition
	Expiration ExpirationPeriod `json:"expiration"`

	// MaxRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MaxRolloverAmount *float64 `json:"maxRolloverAmount,omitempty"`

	// Metadata The grant metadata.
	Metadata *Metadata `json:"metadata,omitempty"`

	// MinRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MinRolloverAmount *float64 `json:"minRolloverAmount,omitempty"`

	// Priority The priority of the grant. Grants with higher priority are applied first.
	// Priority is a positive decimal numbers. With lower numbers indicating higher importance.
	// For example, a priority of 1 is more urgent than a priority of 2.
	// When there are several grants available for the same subject, the system selects the grant with the highest priority.
	// In cases where grants share the same priority level, the grant closest to its expiration will be used first.
	// In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
	Priority *uint8 `json:"priority,omitempty"`

	// Recurrence The subject of the grant.
	Recurrence *RecurringPeriodCreateInput `json:"recurrence,omitempty"`
}

// EntitlementMetered Metered entitlements are useful for many different use cases, from setting up usage based access to implementing complex credit systems.
// Access is determined based on feature usage using a balance calculation (the "usage allowance" provided by the issued grants is "burnt down" by the usage).
type EntitlementMetered struct {
	// ActiveFrom The cadence start of the resource.
	ActiveFrom time.Time `json:"activeFrom"`

	// ActiveTo The cadence end of the resource.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// Annotations The annotations of the entitlement.
	Annotations *Annotations `json:"annotations,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// CurrentUsagePeriod The current usage period.
	CurrentUsagePeriod Period `json:"currentUsagePeriod"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id string `json:"id"`

	// IsSoftLimit If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
	IsSoftLimit *bool `json:"isSoftLimit,omitempty"`

	// IsUnlimited Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
	// Deprecated:
	IsUnlimited *bool `json:"isUnlimited,omitempty"`

	// IssueAfterReset You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
	// If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
	// That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
	// Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
	IssueAfterReset *float64 `json:"issueAfterReset,omitempty"`

	// IssueAfterResetPriority Defines the grant priority for the default grant.
	IssueAfterResetPriority *uint8 `json:"issueAfterResetPriority,omitempty"`

	// LastReset The time the last reset happened.
	LastReset time.Time `json:"lastReset"`

	// MeasureUsageFrom The time from which usage is measured. If not specified on creation, defaults to entitlement creation time.
	MeasureUsageFrom time.Time `json:"measureUsageFrom"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// PreserveOverageAtReset If true, the overage is preserved at reset. If false, the usage is reset to 0.
	PreserveOverageAtReset *bool `json:"preserveOverageAtReset,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string                 `json:"subjectKey"`
	Type       EntitlementMeteredType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// UsagePeriod THe usage period of the entitlement.
	UsagePeriod RecurringPeriod `json:"usagePeriod"`
}

// EntitlementMeteredType defines model for EntitlementMetered.Type.
type EntitlementMeteredType string

// EntitlementMeteredCreateInputs Create inpurs for metered entitlement
type EntitlementMeteredCreateInputs struct {
	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// IsSoftLimit If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
	IsSoftLimit *bool `json:"isSoftLimit,omitempty"`

	// IsUnlimited Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
	// Deprecated:
	IsUnlimited *bool `json:"isUnlimited,omitempty"`

	// IssueAfterReset You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
	// If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
	// That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
	// Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
	IssueAfterReset *float64 `json:"issueAfterReset,omitempty"`

	// IssueAfterResetPriority Defines the grant priority for the default grant.
	IssueAfterResetPriority *uint8 `json:"issueAfterResetPriority,omitempty"`

	// MeasureUsageFrom Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.
	MeasureUsageFrom *MeasureUsageFrom `json:"measureUsageFrom,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// PreserveOverageAtReset If true, the overage is preserved at reset. If false, the usage is reset to 0.
	PreserveOverageAtReset *bool                              `json:"preserveOverageAtReset,omitempty"`
	Type                   EntitlementMeteredCreateInputsType `json:"type"`

	// UsagePeriod The usage period associated with the entitlement.
	UsagePeriod RecurringPeriodCreateInput `json:"usagePeriod"`
}

// EntitlementMeteredCreateInputsType defines model for EntitlementMeteredCreateInputs.Type.
type EntitlementMeteredCreateInputsType string

// EntitlementOrderBy Order by options for entitlements.
type EntitlementOrderBy string

// EntitlementPaginatedResponse Paginated response
type EntitlementPaginatedResponse struct {
	// Items The items in the current page.
	Items []Entitlement `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// EntitlementStatic A static entitlement.
type EntitlementStatic struct {
	// ActiveFrom The cadence start of the resource.
	ActiveFrom time.Time `json:"activeFrom"`

	// ActiveTo The cadence end of the resource.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// Annotations The annotations of the entitlement.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Config The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
	Config json.RawMessage `json:"config"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// CurrentUsagePeriod The current usage period.
	CurrentUsagePeriod *Period `json:"currentUsagePeriod,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id string `json:"id"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string                `json:"subjectKey"`
	Type       EntitlementStaticType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// UsagePeriod The defined usage period of the entitlement
	UsagePeriod *RecurringPeriod `json:"usagePeriod,omitempty"`
}

// EntitlementStaticType defines model for EntitlementStatic.Type.
type EntitlementStaticType string

// EntitlementStaticCreateInputs Create inputs for static entitlement
type EntitlementStaticCreateInputs struct {
	// Config The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
	Config json.RawMessage `json:"config"`

	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata                         `json:"metadata,omitempty"`
	Type     EntitlementStaticCreateInputsType `json:"type"`

	// UsagePeriod The usage period associated with the entitlement.
	UsagePeriod *RecurringPeriodCreateInput `json:"usagePeriod,omitempty"`
}

// EntitlementStaticCreateInputsType defines model for EntitlementStaticCreateInputs.Type.
type EntitlementStaticCreateInputsType string

// EntitlementType Type of the entitlement.
type EntitlementType = string

// EntitlementValue Entitlements are the core of OpenMeter access management. They define access to features for subjects. Entitlements can be metered, boolean, or static.
type EntitlementValue struct {
	// Balance Only available for metered entitlements. Metered entitlements are built around a balance calculation where feature usage is deducted from the issued grants. Balance represents the remaining balance of the entitlement, it's value never turns negative.
	Balance *float64 `json:"balance,omitempty"`

	// Config Only available for static entitlements. The JSON parsable config of the entitlement.
	Config *string `json:"config,omitempty"`

	// HasAccess Whether the subject has access to the feature. Shared accross all entitlement types.
	HasAccess bool `json:"hasAccess"`

	// Overage Only available for metered entitlements. Overage represents the usage that wasn't covered by grants, e.g. if the subject had a total feature usage of 100 in the period but they were only granted 80, there would be 20 overage.
	Overage *float64 `json:"overage,omitempty"`

	// Usage Only available for metered entitlements. Returns the total feature usage in the current period.
	Usage *float64 `json:"usage,omitempty"`
}

// Event CloudEvents Specification JSON Schema
//
// Optional properties are nullable according to the CloudEvents specification:
// OPTIONAL not omitted attributes MAY be represented as a null JSON value.
type Event = event.Event

// ExpirationDuration The expiration duration enum
type ExpirationDuration string

// ExpirationPeriod The grant expiration definition
type ExpirationPeriod struct {
	// Count The number of time units in the expiration period.
	Count int `json:"count"`

	// Duration The unit of time for the expiration period.
	Duration ExpirationDuration `json:"duration"`
}

// Feature Represents a feature that can be enabled or disabled for a plan.
// Used both for product catalog and entitlements.
type Feature struct {
	// ArchivedAt Timestamp of when the resource was archived.
	ArchivedAt *time.Time `json:"archivedAt,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Id Readonly unique ULID identifier.
	Id string `json:"id"`

	// Key A key is a unique string that is used to identify a resource.
	Key      string    `json:"key"`
	Metadata *Metadata `json:"metadata,omitempty"`

	// MeterGroupByFilters Optional meter group by filters.
	// Useful if the meter scope is broader than what feature tracks.
	// Example scenario would be a meter tracking all token use with groupBy fields for the model,
	// then the feature could filter for model=gpt-4.
	MeterGroupByFilters *map[string]string `json:"meterGroupByFilters,omitempty"`

	// MeterSlug A key is a unique string that is used to identify a resource.
	MeterSlug *string `json:"meterSlug,omitempty"`
	Name      string  `json:"name"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// FeatureCreateInputs Represents a feature that can be enabled or disabled for a plan.
// Used both for product catalog and entitlements.
type FeatureCreateInputs struct {
	// Key A key is a unique string that is used to identify a resource.
	Key      string    `json:"key"`
	Metadata *Metadata `json:"metadata,omitempty"`

	// MeterGroupByFilters Optional meter group by filters.
	// Useful if the meter scope is broader than what feature tracks.
	// Example scenario would be a meter tracking all token use with groupBy fields for the model,
	// then the feature could filter for model=gpt-4.
	MeterGroupByFilters *map[string]string `json:"meterGroupByFilters,omitempty"`

	// MeterSlug A key is a unique string that is used to identify a resource.
	MeterSlug *string `json:"meterSlug,omitempty"`
	Name      string  `json:"name"`
}

// FeatureMeta Limited representation of a feature resource which includes only its unique identifiers (id, key).
type FeatureMeta struct {
	// Id Unique identifier of a feature.
	Id string `json:"id"`

	// Key The key is an immutable unique identifier of the feature used throughout the API,
	// for example when interacting with a subject's entitlements.
	Key string `json:"key"`
}

// FeatureOrderBy Order by options for features.
type FeatureOrderBy string

// FeaturePaginatedResponse Paginated response
type FeaturePaginatedResponse struct {
	// Items The items in the current page.
	Items []Feature `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// FilterString A filter for a string field.
type FilterString struct {
	// And Provide a list of filters to be combined with a logical AND.
	And *[]FilterString `json:"$and"`

	// Eq The field must be equal to the provided value.
	Eq *string `json:"$eq"`

	// Gt The field must be greater than the provided value.
	Gt *string `json:"$gt"`

	// Gte The field must be greater than or equal to the provided value.
	Gte *string `json:"$gte"`

	// Ilike The field must match the provided value, ignoring case.
	Ilike *string `json:"$ilike"`

	// In The field must be in the provided list of values.
	In *[]string `json:"$in"`

	// Like The field must match the provided value.
	Like *string `json:"$like"`

	// Lt The field must be less than the provided value.
	Lt *string `json:"$lt"`

	// Lte The field must be less than or equal to the provided value.
	Lte *string `json:"$lte"`

	// Ne The field must not be equal to the provided value.
	Ne *string `json:"$ne"`

	// Nilike The field must not match the provided value, ignoring case.
	Nilike *string `json:"$nilike"`

	// Nin The field must not be in the provided list of values.
	Nin *[]string `json:"$nin"`

	// Nlike The field must not match the provided value.
	Nlike *string `json:"$nlike"`

	// Or Provide a list of filters to be combined with a logical OR.
	Or *[]FilterString `json:"$or"`
}

// FilterTime A filter for a time field.
type FilterTime struct {
	// And Provide a list of filters to be combined with a logical AND.
	And *[]FilterTime `json:"$and"`

	// Gt The field must be greater than the provided value.
	Gt *time.Time `json:"$gt"`

	// Gte The field must be greater than or equal to the provided value.
	Gte *time.Time `json:"$gte"`

	// Lt The field must be less than the provided value.
	Lt *time.Time `json:"$lt"`

	// Lte The field must be less than or equal to the provided value.
	Lte *time.Time `json:"$lte"`

	// Or Provide a list of filters to be combined with a logical OR.
	Or *[]FilterTime `json:"$or"`
}

// FlatPrice Flat price.
type FlatPrice struct {
	// Amount The amount of the flat price.
	Amount Numeric `json:"amount"`

	// Type The type of the price.
	Type FlatPriceType `json:"type"`
}

// FlatPriceType The type of the price.
type FlatPriceType string

// FlatPriceWithPaymentTerm Flat price with payment term.
type FlatPriceWithPaymentTerm struct {
	// Amount The amount of the flat price.
	Amount Numeric `json:"amount"`

	// PaymentTerm The payment term of the flat price.
	// Defaults to in advance.
	PaymentTerm *PricePaymentTerm `json:"paymentTerm,omitempty"`

	// Type The type of the price.
	Type FlatPriceWithPaymentTermType `json:"type"`
}

// FlatPriceWithPaymentTermType The type of the price.
type FlatPriceWithPaymentTermType string

// ForbiddenProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type ForbiddenProblemResponse = UnexpectedProblemResponse

// GrantBurnDownHistorySegment A segment of the grant burn down history.
//
// A given segment represents the usage of a grant between events that changed either the grant burn down priority order or the usag period.
type GrantBurnDownHistorySegment struct {
	// BalanceAtEnd The entitlement balance at the end of the period.
	BalanceAtEnd float64 `json:"balanceAtEnd"`

	// BalanceAtStart entitlement balance at the start of the period.
	BalanceAtStart float64 `json:"balanceAtStart"`

	// GrantBalancesAtEnd The balance breakdown of each active grant at the end of the period: GrantID: Balance
	GrantBalancesAtEnd map[string]float64 `json:"grantBalancesAtEnd"`

	// GrantBalancesAtStart The balance breakdown of each active grant at the start of the period: GrantID: Balance
	GrantBalancesAtStart map[string]float64 `json:"grantBalancesAtStart"`

	// GrantUsages Which grants were actually burnt down in the period and by what amount.
	GrantUsages []GrantUsageRecord `json:"grantUsages"`

	// Overage Overuse that wasn't covered by grants.
	Overage float64 `json:"overage"`

	// Period The period of the segment.
	Period Period `json:"period"`

	// Usage The total usage of the grant in the period.
	Usage float64 `json:"usage"`
}

// GrantOrderBy Order by options for grants.
type GrantOrderBy string

// GrantPaginatedResponse Paginated response
type GrantPaginatedResponse struct {
	// Items The items in the current page.
	Items []EntitlementGrant `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// GrantUsageRecord Usage Record
type GrantUsageRecord struct {
	// GrantId The id of the grant
	GrantId string `json:"grantId"`

	// Usage The usage in the period
	Usage float64 `json:"usage"`
}

// IDResource IDResource is a resouce with an ID.
type IDResource struct {
	// Id A unique identifier for the resource.
	Id string `json:"id"`
}

// IngestEventsBody The body of the events request.
// Either a single event or a batch of events.
type IngestEventsBody struct {
	union json.RawMessage
}

// IngestEventsBody1 defines model for .
type IngestEventsBody1 = []Event

// IngestedEvent An ingested event with optional validation error.
type IngestedEvent struct {
	// Event The original event ingested.
	Event Event `json:"event"`

	// IngestedAt The date and time the event was ingested.
	IngestedAt time.Time `json:"ingestedAt"`

	// StoredAt The date and time the event was stored.
	StoredAt time.Time `json:"storedAt"`

	// ValidationError The validation error if the event failed validation.
	ValidationError *string `json:"validationError,omitempty"`
}

// IngestedEventCursorPaginatedResponse A response for cursor pagination.
type IngestedEventCursorPaginatedResponse struct {
	// Items The items in the response.
	Items []IngestedEvent `json:"items"`

	// NextCursor The cursor of the last item in the list.
	NextCursor *string `json:"nextCursor,omitempty"`
}

// InstallMethod Install method of the application.
type InstallMethod string

// InternalServerErrorProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type InternalServerErrorProblemResponse = UnexpectedProblemResponse

// Invoice Invoice represents an invoice in the system.
type Invoice struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency Currency for all invoice line items.
	//
	// Multi currency invoices are not supported yet.
	Currency CurrencyCode `json:"currency"`

	// Customer Legal entity receiving the goods or services.
	Customer BillingParty `json:"customer"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// DraftUntil The time until the invoice is in draft status.
	//
	// On draft invoice creation it is calculated from the workflow settings.
	//
	// If manual approval is required, the draftUntil time is set.
	DraftUntil *time.Time `json:"draftUntil,omitempty"`

	// DueAt Due time of the fulfillment of the invoice (if available).
	DueAt *time.Time `json:"dueAt,omitempty"`

	// ExternalIds External IDs of the invoice in other apps such as Stripe.
	ExternalIds *InvoiceAppExternalIds `json:"externalIds,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// IssuedAt The time the invoice was issued.
	//
	// Depending on the status of the invoice this can mean multiple things:
	// - draft, gathering: The time the invoice will be issued based on the workflow settings.
	// - issued: The time the invoice was issued.
	IssuedAt *time.Time `json:"issuedAt,omitempty"`

	// Lines List of invoice lines representing each of the items sold to the customer.
	Lines *[]InvoiceLine `json:"lines,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Number Number specifies the human readable key used to reference this Invoice.
	//
	// The invoice number can change in the draft phases, as we are allocating temporary draft
	// invoice numbers, but it's final as soon as the invoice gets finalized (issued state).
	//
	// Please note that the number is (depending on the upstream settings) either unique for the
	// whole organization or unique for the customer, or in multi (stripe) account setups unique for the
	// account.
	Number InvoiceNumber `json:"number"`

	// Payment Information on when, how, and to whom the invoice should be paid.
	Payment *InvoicePaymentTerms `json:"payment,omitempty"`

	// Period The period the invoice covers. If the invoice has no line items, it's not set.
	Period *Period `json:"period,omitempty"`

	// Preceding Key information regarding previous invoices and potentially details as to why they were corrected.
	Preceding *[]InvoiceDocumentRef `json:"preceding,omitempty"`

	// QuantitySnapshotedAt The time when the quantity snapshots on the invoice lines were taken.
	QuantitySnapshotedAt *time.Time `json:"quantitySnapshotedAt,omitempty"`

	// SentToCustomerAt The time the invoice was sent to customer.
	SentToCustomerAt *time.Time `json:"sentToCustomerAt,omitempty"`

	// Status The status of the invoice.
	//
	// This field only conatins a simplified status, for more detailed information use the statusDetails field.
	Status InvoiceStatus `json:"status"`

	// StatusDetails The details of the current invoice status.
	StatusDetails InvoiceStatusDetails `json:"statusDetails"`

	// Supplier The taxable entity supplying the goods or services.
	Supplier BillingParty `json:"supplier"`

	// Totals Summary of all the invoice totals, including taxes (calculated).
	Totals InvoiceTotals `json:"totals"`

	// Type Type of the invoice.
	//
	// The type of invoice determines the purpose of the invoice and how it should be handled.
	//
	// Supported types:
	// - standard: A regular commercial invoice document between a supplier and customer.
	// - credit_note: Reflects a refund either partial or complete of the preceding document. A credit note effectively *extends* the previous document.
	Type InvoiceType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// ValidationIssues Validation issues reported by the invoice workflow.
	ValidationIssues *[]ValidationIssue `json:"validationIssues,omitempty"`

	// VoidedAt The time the invoice was voided.
	//
	// If the invoice was voided, this field will be set to the time the invoice was voided.
	VoidedAt *time.Time `json:"voidedAt,omitempty"`

	// Workflow The workflow associated with the invoice.
	//
	// It is always a snapshot of the workflow settings at the time of invoice creation. The
	// field is optional as it should be explicitly requested with expand options.
	Workflow InvoiceWorkflowSettings `json:"workflow"`
}

// InvoiceAppExternalIds InvoiceAppExternalIds contains the external IDs of the invoice in other apps such as Stripe.
type InvoiceAppExternalIds struct {
	// Invoicing The external ID of the invoice in the invoicing app if available.
	Invoicing *string `json:"invoicing,omitempty"`

	// Payment The external ID of the invoice in the payment app if available.
	Payment *string `json:"payment,omitempty"`

	// Tax The external ID of the invoice in the tax app if available.
	Tax *string `json:"tax,omitempty"`
}

// InvoiceAvailableActionDetails InvoiceAvailableActionInvoiceDetails represents the details of the invoice action for
// non-gathering invoices.
type InvoiceAvailableActionDetails struct {
	// ResultingState The state the invoice will reach if the action is activated and
	// all intermediate steps are successful.
	//
	// For example advancing a draft_created invoice will result in a draft_manual_approval_needed invoice.
	ResultingState string `json:"resultingState"`
}

// InvoiceAvailableActionInvoiceDetails InvoiceAvailableActionInvoiceDetails represents the details of the invoice action for
// gathering invoices.
type InvoiceAvailableActionInvoiceDetails = map[string]interface{}

// InvoiceAvailableActions InvoiceAvailableActions represents the actions that can be performed on the invoice.
type InvoiceAvailableActions struct {
	// Advance Advance the invoice to the next status.
	Advance *InvoiceAvailableActionDetails `json:"advance,omitempty"`

	// Approve Approve an invoice that requires manual approval.
	Approve *InvoiceAvailableActionDetails `json:"approve,omitempty"`

	// Delete Delete the invoice (only non-issued invoices can be deleted).
	Delete *InvoiceAvailableActionDetails `json:"delete,omitempty"`

	// Invoice Invoice a gathering invoice
	Invoice *InvoiceAvailableActionInvoiceDetails `json:"invoice,omitempty"`

	// Retry Retry an invoice issuing step that failed.
	Retry *InvoiceAvailableActionDetails `json:"retry,omitempty"`

	// Void Void an already issued invoice.
	Void *InvoiceAvailableActionDetails `json:"void,omitempty"`
}

// InvoiceDocumentRef CreditNoteOriginalInvoiceRef is used to reference the original invoice that a credit note is based on.
type InvoiceDocumentRef = CreditNoteOriginalInvoiceRef

// InvoiceDocumentRefType InvoiceDocumentRefType defines the type of document that is being referenced.
type InvoiceDocumentRefType string

// InvoiceExpand InvoiceExpand specifies the parts of the invoice to expand in the list output.
type InvoiceExpand string

// InvoiceFlatFeeCategory InvoiceFlatFeeCategory determines if the flat fee is a regular fee due to use due to a
// commitment.
type InvoiceFlatFeeCategory string

// InvoiceFlatFeeLine InvoiceFlatFeeLine represents a line item that is sold to the customer as a manually added fee.
type InvoiceFlatFeeLine struct {
	// Category Category of the flat fee.
	Category *InvoiceFlatFeeCategory `json:"category,omitempty"`

	// Children The lines detailing the item or service sold.
	Children *[]InvoiceLine `json:"children,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency The currency of this line.
	Currency CurrencyCode `json:"currency"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Discounts Discounts detailes applied to this line.
	//
	// New discounts can be added via the invoice's discounts API, to facilitate
	// discounts that are affecting multiple lines.
	Discounts *InvoiceLineDiscounts `json:"discounts,omitempty"`

	// ExternalIds External IDs of the invoice in other apps such as Stripe.
	ExternalIds *InvoiceLineAppExternalIds `json:"externalIds,omitempty"`

	// Id ID of the line.
	Id string `json:"id"`

	// Invoice The invoice this item belongs to.
	Invoice *InvoiceReference `json:"invoice,omitempty"`

	// InvoiceAt The time this line item should be invoiced.
	InvoiceAt time.Time `json:"invoiceAt"`

	// ManagedBy managedBy specifies if the line is manually added via the api or managed by OpenMeter.
	ManagedBy InvoiceLineManagedBy `json:"managedBy"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PaymentTerm Payment term of the line.
	// Deprecated:
	PaymentTerm *PricePaymentTerm `json:"paymentTerm,omitempty"`

	// PerUnitAmount Price of the item being sold.
	// Deprecated:
	PerUnitAmount *Numeric `json:"perUnitAmount,omitempty"`

	// Period Period of the line item applies to for revenue recognition pruposes.
	//
	// Billing always treats periods as start being inclusive and end being exclusive.
	Period Period `json:"period"`

	// Quantity Quantity of the item being sold.
	// Deprecated:
	Quantity *Numeric `json:"quantity,omitempty"`

	// RateCard The rate card that is used for this line.
	RateCard *InvoiceFlatFeeRateCard `json:"rateCard,omitempty"`

	// Status Status of the line.
	//
	// External calls always create valid lines, other line types are managed by the
	// billing engine of OpenMeter.
	Status InvoiceLineStatus `json:"status"`

	// Subscription Subscription are the references to the subscritpions that this line is related to.
	Subscription *InvoiceLineSubscriptionReference `json:"subscription,omitempty"`

	// TaxConfig Tax config specify the tax configuration for this line.
	// Deprecated:
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Taxes Taxes applied to the invoice totals.
	Taxes *[]InvoiceLineTaxItem `json:"taxes,omitempty"`

	// Totals Totals for this line.
	Totals InvoiceTotals `json:"totals"`

	// Type Type of the line.
	Type InvoiceFlatFeeLineType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// InvoiceFlatFeeLineType Type of the line.
type InvoiceFlatFeeLineType string

// InvoiceFlatFeeLineReplaceUpdate InvoiceFlatFeeLineReplaceUpdate represents the update model for a flat fee invoice line.
//
// This type makes ID optional to allow for creating new lines as part of the update.
type InvoiceFlatFeeLineReplaceUpdate struct {
	// Category Category of the flat fee.
	Category *InvoiceFlatFeeCategory `json:"category,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id The ID of the line.
	Id *string `json:"id,omitempty"`

	// InvoiceAt The time this line item should be invoiced.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PaymentTerm Payment term of the line.
	// Deprecated:
	PaymentTerm *PricePaymentTerm `json:"paymentTerm,omitempty"`

	// PerUnitAmount Price of the item being sold.
	// Deprecated:
	PerUnitAmount *Numeric `json:"perUnitAmount,omitempty"`

	// Period Period of the line item applies to for revenue recognition pruposes.
	//
	// Billing always treats periods as start being inclusive and end being exclusive.
	Period Period `json:"period"`

	// Quantity Quantity of the item being sold.
	// Deprecated:
	Quantity *Numeric `json:"quantity,omitempty"`

	// RateCard The rate card that is used for this line.
	RateCard *InvoiceFlatFeeRateCard `json:"rateCard,omitempty"`

	// TaxConfig Tax config specify the tax configuration for this line.
	// Deprecated:
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type Type of the line.
	Type InvoiceFlatFeeLineReplaceUpdateType `json:"type"`
}

// InvoiceFlatFeeLineReplaceUpdateType Type of the line.
type InvoiceFlatFeeLineReplaceUpdateType string

// InvoiceFlatFeePendingLineCreate InvoiceFlatFeePendingLineCreate represents the create model for an invoice line that is sold to the customer as a manually added fee.
type InvoiceFlatFeePendingLineCreate struct {
	// Category Category of the flat fee.
	Category *InvoiceFlatFeeCategory `json:"category,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// InvoiceAt The time this line item should be invoiced.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PaymentTerm Payment term of the line.
	// Deprecated:
	PaymentTerm *PricePaymentTerm `json:"paymentTerm,omitempty"`

	// PerUnitAmount Price of the item being sold.
	// Deprecated:
	PerUnitAmount *Numeric `json:"perUnitAmount,omitempty"`

	// Period Period of the line item applies to for revenue recognition pruposes.
	//
	// Billing always treats periods as start being inclusive and end being exclusive.
	Period Period `json:"period"`

	// Quantity Quantity of the item being sold.
	// Deprecated:
	Quantity *Numeric `json:"quantity,omitempty"`

	// RateCard The rate card that is used for this line.
	RateCard *InvoiceFlatFeeRateCard `json:"rateCard,omitempty"`

	// TaxConfig Tax config specify the tax configuration for this line.
	// Deprecated:
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type Type of the line.
	Type InvoiceFlatFeePendingLineCreateType `json:"type"`
}

// InvoiceFlatFeePendingLineCreateType Type of the line.
type InvoiceFlatFeePendingLineCreateType string

// InvoiceFlatFeeRateCard InvoiceFlatFeeRateCard represents the rate card (intent) for a flat fee line.
type InvoiceFlatFeeRateCard struct {
	// Discounts The discounts that are applied to the line.
	Discounts *BillingDiscounts `json:"discounts,omitempty"`

	// Price The price of the rate card.
	// When null, the feature or service is free.
	Price *FlatPriceWithPaymentTerm `json:"price"`

	// Quantity Quantity of the item being sold.
	//
	// Default: 1
	Quantity *Numeric `json:"quantity,omitempty"`

	// TaxConfig The tax config of the rate card.
	// When undefined, the tax config of the feature or the default tax config of the plan is used.
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`
}

// InvoiceGenericDocumentRef Omitted fields:
// period: Tax period in which the referred document had an effect required by some tax regimes and formats.
// stamps: Seals of approval from other organisations that may need to be listed.
// ext: 	Extensions for additional codes that may be required.
type InvoiceGenericDocumentRef struct {
	// Description Additional details about the document.
	Description *string `json:"description,omitempty"`

	// Reason Human readable description on why this reference is here or needs to be used.
	Reason *string `json:"reason,omitempty"`

	// Type Type of the document referenced.
	Type InvoiceDocumentRefType `json:"type"`
}

// InvoiceLine BillingInvoiceLine represents a line item that is sold to the customer based on a specific (unit) price.
type InvoiceLine struct {
	union json.RawMessage
}

// InvoiceLineAmountDiscount InvoiceLineAmountDiscount represents an amount deducted from the line, and will be applied before taxes.
type InvoiceLineAmountDiscount struct {
	// Amount Fixed discount amount to apply (calculated if percent present).
	Amount Numeric `json:"amount"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Text description as to why the discount was applied.
	Description *string `json:"description,omitempty"`

	// ExternalIds External IDs of the invoice in other apps such as Stripe.
	ExternalIds *InvoiceLineAppExternalIds `json:"externalIds,omitempty"`

	// Id ID of the charge or discount.
	Id string `json:"id"`

	// Reason Reason code.
	Reason BillingDiscountReason `json:"reason"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// InvoiceLineAppExternalIds InvoiceLineAppExternalIds contains the external IDs of the invoice in other apps such as Stripe.
type InvoiceLineAppExternalIds struct {
	// Invoicing The external ID of the invoice in the invoicing app if available.
	Invoicing *string `json:"invoicing,omitempty"`

	// Tax The external ID of the invoice in the tax app if available.
	Tax *string `json:"tax,omitempty"`
}

// InvoiceLineDiscounts InvoiceLineDiscounts represents the discounts applied to the invoice line by type.
type InvoiceLineDiscounts struct {
	// Amount Amount based discounts applied to the line.
	//
	// Amount based discounts are deduced from the total price of the line.
	Amount *[]InvoiceLineAmountDiscount `json:"amount,omitempty"`

	// Usage Usage based discounts applied to the line.
	//
	// Usage based discounts are deduced from the usage of the line before price calculations are applied.
	Usage *[]InvoiceLineUsageDiscount `json:"usage,omitempty"`
}

// InvoiceLineManagedBy InvoiceLineManagedBy specifies who manages the line.
type InvoiceLineManagedBy string

// InvoiceLineReplaceUpdate InvoiceLineReplaceUpdate represents the update model for an invoice line.
type InvoiceLineReplaceUpdate struct {
	union json.RawMessage
}

// InvoiceLineStatus Line status specifies the status of the line.
type InvoiceLineStatus string

// InvoiceLineSubscriptionReference InvoiceLineSubscriptionReference contains the references to the subscription that this line is related to.
type InvoiceLineSubscriptionReference struct {
	// Item The item this line is related to.
	Item IDResource `json:"item"`

	// Phase The phase of the subscription.
	Phase IDResource `json:"phase"`

	// Subscription The subscription.
	Subscription IDResource `json:"subscription"`
}

// InvoiceLineTaxBehavior InvoiceLineTaxBehavior details how the tax item is applied to the base amount.
//
// Inclusive means the tax is included in the base amount.
// Exclusive means the tax is added to the base amount.
type InvoiceLineTaxBehavior string

// InvoiceLineTaxItem TaxConfig stores the configuration for a tax line relative to an invoice line.
type InvoiceLineTaxItem struct {
	// Behavior Is the tax item inclusive or exclusive of the base amount.
	Behavior *InvoiceLineTaxBehavior `json:"behavior,omitempty"`

	// Config Tax provider configuration.
	Config *TaxConfig `json:"config,omitempty"`

	// Percent Percent defines the percentage set manually or determined from
	// the rate key (calculated if rate present). A nil percent implies that
	// this tax combo is **exempt** from tax.")
	Percent *Percentage `json:"percent,omitempty"`

	// Surcharge Some countries require an additional surcharge (calculated if rate present).
	Surcharge *Numeric `json:"surcharge,omitempty"`
}

// InvoiceLineUsageDiscount InvoiceLineUsageDiscount represents an usage-based discount applied to the line.
//
// The deduction is done before the pricing algorithm is applied.
type InvoiceLineUsageDiscount struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Text description as to why the discount was applied.
	Description *string `json:"description,omitempty"`

	// ExternalIds External IDs of the invoice in other apps such as Stripe.
	ExternalIds *InvoiceLineAppExternalIds `json:"externalIds,omitempty"`

	// Id ID of the charge or discount.
	Id string `json:"id"`

	// PreLinePeriodQuantity The usage discount already applied to the previous split lines.
	//
	// Only set if progressive billing is enabled and the line is a split line.
	PreLinePeriodQuantity *Numeric `json:"preLinePeriodQuantity,omitempty"`

	// Quantity The usage to apply.
	Quantity Numeric `json:"quantity"`

	// Reason Reason code.
	Reason BillingDiscountReason `json:"reason"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// InvoiceNumber InvoiceNumber is a unique identifier for the invoice, generated by the
// invoicing app.
//
// The uniqueness depends on a lot of factors:
// - app setting (unique per app or unique per customer)
// - multiple app scenarios (multiple apps generating invoices with the same prefix)
type InvoiceNumber = string

// InvoiceOrderBy InvoiceOrderBy specifies the ordering options for invoice listing.
type InvoiceOrderBy string

// InvoicePaginatedResponse Paginated response
type InvoicePaginatedResponse struct {
	// Items The items in the current page.
	Items []Invoice `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// InvoicePaymentTerms Payment contains details as to how the invoice should be paid.
type InvoicePaymentTerms struct {
	// Terms The terms of payment for the invoice.
	Terms *PaymentTerms `json:"terms,omitempty"`
}

// InvoicePendingLineCreate InvoiceLineCreate represents the create model for an invoice line.
type InvoicePendingLineCreate struct {
	union json.RawMessage
}

// InvoicePendingLineCreateInput InvoicePendingLineCreate represents the create model for a pending invoice line.
type InvoicePendingLineCreateInput struct {
	// Currency The currency of the lines to be created.
	Currency CurrencyCode `json:"currency"`

	// Lines The lines to be created.
	Lines []InvoicePendingLineCreate `json:"lines"`
}

// InvoicePendingLineCreateResponse InvoicePendingLineCreateResponse represents the response from the create pending line endpoint.
type InvoicePendingLineCreateResponse struct {
	// Invoice The invoice containing the created lines.
	Invoice Invoice `json:"invoice"`

	// IsInvoiceNew Whether the invoice was newly created.
	IsInvoiceNew bool `json:"isInvoiceNew"`

	// Lines The lines that were created.
	Lines []InvoiceLine `json:"lines"`
}

// InvoicePendingLinesActionFiltersInput InvoicePendingLinesActionFiltersInput specifies which lines to include in the invoice.
type InvoicePendingLinesActionFiltersInput struct {
	// LineIds The pending line items to include in the invoice, if not provided:
	// - all line items that have invoice_at < asOf will be included
	// - [progressive billing only] all usage based line items will be included up to asOf, new
	// usage-based line items will be staged for the rest of the billing cycle
	//
	// All lineIDs present in the list, must exists and must be invoicable as of asOf, or the action will fail.
	LineIds *[]string `json:"lineIds,omitempty"`
}

// InvoicePendingLinesActionInput BillingInvoiceActionInput is the input for creating an invoice.
//
// Invoice creation is always based on already pending line items created by the billingCreateLineByCustomer
// operation. Empty invoices are not allowed.
type InvoicePendingLinesActionInput struct {
	// AsOf The time as of which the invoice is created.
	//
	// If not provided, the current time is used.
	AsOf *time.Time `json:"asOf,omitempty"`

	// CustomerId The customer ID for which to create the invoice.
	CustomerId string `json:"customerId"`

	// Filters Filters to apply when creating the invoice.
	Filters *InvoicePendingLinesActionFiltersInput `json:"filters,omitempty"`

	// ProgressiveBillingOverride Override the progressive billing setting of the customer.
	//
	// Can be used to disable/enable progressive billing in case the business logic
	// requires it, if not provided the billing profile's progressive billing setting will be used.
	ProgressiveBillingOverride *bool `json:"progressiveBillingOverride,omitempty"`
}

// InvoiceReference Reference to an invoice.
type InvoiceReference struct {
	// Id The ID of the invoice.
	Id string `json:"id"`

	// Number The number of the invoice.
	Number *InvoiceNumber `json:"number,omitempty"`
}

// InvoiceReplaceUpdate InvoiceReplaceUpdate represents the update model for an invoice.
type InvoiceReplaceUpdate struct {
	// Customer The customer the invoice is sent to.
	Customer BillingPartyReplaceUpdate `json:"customer"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Lines The lines included in the invoice.
	Lines []InvoiceLineReplaceUpdate `json:"lines"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Supplier The supplier of the lines included in the invoice.
	Supplier BillingPartyReplaceUpdate `json:"supplier"`

	// Workflow The workflow settings for the invoice.
	Workflow InvoiceWorkflowReplaceUpdate `json:"workflow"`
}

// InvoiceSimulationFlatFeeLine InvoiceSimulationFlatFeeLine represents a flat fee line item that can be input to the simulation endpoint.
type InvoiceSimulationFlatFeeLine struct {
	// Category Category of the flat fee.
	Category *InvoiceFlatFeeCategory `json:"category,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id ID of the line. If not specified it will be auto-generated.
	//
	// When discounts are specified, this must be provided, so that the discount can reference it.
	Id *string `json:"id,omitempty"`

	// InvoiceAt The time this line item should be invoiced.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PaymentTerm Payment term of the line.
	// Deprecated:
	PaymentTerm *PricePaymentTerm `json:"paymentTerm,omitempty"`

	// PerUnitAmount Price of the item being sold.
	// Deprecated:
	PerUnitAmount *Numeric `json:"perUnitAmount,omitempty"`

	// Period Period of the line item applies to for revenue recognition pruposes.
	//
	// Billing always treats periods as start being inclusive and end being exclusive.
	Period Period `json:"period"`

	// Quantity Quantity of the item being sold.
	// Deprecated:
	Quantity *Numeric `json:"quantity,omitempty"`

	// RateCard The rate card that is used for this line.
	RateCard *InvoiceFlatFeeRateCard `json:"rateCard,omitempty"`

	// TaxConfig Tax config specify the tax configuration for this line.
	// Deprecated:
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type Type of the line.
	Type InvoiceSimulationFlatFeeLineType `json:"type"`
}

// InvoiceSimulationFlatFeeLineType Type of the line.
type InvoiceSimulationFlatFeeLineType string

// InvoiceSimulationInput InvoiceSimulationInput is the input for simulating an invoice.
type InvoiceSimulationInput struct {
	// Currency Currency for all invoice line items.
	//
	// Multi currency invoices are not supported yet.
	Currency CurrencyCode `json:"currency"`

	// Lines Lines to be included in the generated invoice.
	Lines []InvoiceSimulationLine `json:"lines"`

	// Number The number of the invoice.
	Number *InvoiceNumber `json:"number,omitempty"`
}

// InvoiceSimulationLine InvoiceSimulationInput represents a line item that can be input to the simulation endpoint.
type InvoiceSimulationLine struct {
	union json.RawMessage
}

// InvoiceSimulationUsageBasedLine InvoiceSimulationUsageBasedLine represents a usage-based line item that can be input to the simulation endpoint.
type InvoiceSimulationUsageBasedLine struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// FeatureKey The feature that the usage is based on.
	// Deprecated:
	FeatureKey *string `json:"featureKey,omitempty"`

	// Id ID of the line. If not specified it will be auto-generated.
	//
	// When discounts are specified, this must be provided, so that the discount can reference it.
	Id *string `json:"id,omitempty"`

	// InvoiceAt The time this line item should be invoiced.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Period Period of the line item applies to for revenue recognition pruposes.
	//
	// Billing always treats periods as start being inclusive and end being exclusive.
	Period Period `json:"period"`

	// PreLinePeriodQuantity The quantity of the item used before this line's period, if the line is billed progressively.
	PreLinePeriodQuantity *Numeric `json:"preLinePeriodQuantity,omitempty"`

	// Price Price of the usage-based item being sold.
	// Deprecated:
	Price *RateCardUsageBasedPrice `json:"price,omitempty"`

	// Quantity The quantity of the item being sold.
	Quantity Numeric `json:"quantity"`

	// RateCard The rate card that is used for this line.
	//
	// The rate card captures the intent of the price and discounts for the usage-based item.
	RateCard *InvoiceUsageBasedRateCard `json:"rateCard,omitempty"`

	// TaxConfig Tax config specify the tax configuration for this line.
	// Deprecated:
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type Type of the line.
	Type InvoiceSimulationUsageBasedLineType `json:"type"`
}

// InvoiceSimulationUsageBasedLineType Type of the line.
type InvoiceSimulationUsageBasedLineType string

// InvoiceStatus InvoiceStatus describes the status of an invoice.
type InvoiceStatus string

// InvoiceStatusDetails InvoiceStatusDetails represents the details of the invoice status.
//
// API users are encouraged to rely on the immutable/failed/avaliableActions fields to determine
// the next steps of the invoice instead of the extendedStatus field.
type InvoiceStatusDetails struct {
	// AvailableActions The actions that can be performed on the invoice.
	AvailableActions InvoiceAvailableActions `json:"availableActions"`

	// ExtendedStatus Extended status information for the invoice.
	ExtendedStatus string `json:"extendedStatus"`

	// Failed Is the invoice in a failed state?
	Failed bool `json:"failed"`

	// Immutable Is the invoice editable?
	Immutable bool `json:"immutable"`
}

// InvoiceTotals Totals contains the summaries of all calculations for the invoice.
type InvoiceTotals struct {
	// Amount The total value of the line before taxes, discounts and commitments.
	Amount Numeric `json:"amount"`

	// ChargesTotal The amount of value of the line that are due to additional charges.
	ChargesTotal Numeric `json:"chargesTotal"`

	// DiscountsTotal The amount of value of the line that are due to discounts.
	DiscountsTotal Numeric `json:"discountsTotal"`

	// TaxesExclusiveTotal The total amount of taxes that are added on top of amount from the line.
	TaxesExclusiveTotal Numeric `json:"taxesExclusiveTotal"`

	// TaxesInclusiveTotal The total amount of taxes that are included in the line.
	TaxesInclusiveTotal Numeric `json:"taxesInclusiveTotal"`

	// TaxesTotal The total amount of taxes for this line.
	TaxesTotal Numeric `json:"taxesTotal"`

	// Total The total amount value of the line after taxes, discounts and commitments.
	Total Numeric `json:"total"`
}

// InvoiceType InvoiceType represents the type of invoice.
//
// The type of invoice determines the purpose of the invoice and how it should be handled.
type InvoiceType string

// InvoiceUsageBasedLine InvoiceUsageBasedLine represents a line item that is sold to the customer based on usage.
type InvoiceUsageBasedLine struct {
	// Children The lines detailing the item or service sold.
	Children *[]InvoiceLine `json:"children,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency The currency of this line.
	Currency CurrencyCode `json:"currency"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Discounts Discounts detailes applied to this line.
	//
	// New discounts can be added via the invoice's discounts API, to facilitate
	// discounts that are affecting multiple lines.
	Discounts *InvoiceLineDiscounts `json:"discounts,omitempty"`

	// ExternalIds External IDs of the invoice in other apps such as Stripe.
	ExternalIds *InvoiceLineAppExternalIds `json:"externalIds,omitempty"`

	// FeatureKey The feature that the usage is based on.
	// Deprecated:
	FeatureKey *string `json:"featureKey,omitempty"`

	// Id ID of the line.
	Id string `json:"id"`

	// Invoice The invoice this item belongs to.
	Invoice *InvoiceReference `json:"invoice,omitempty"`

	// InvoiceAt The time this line item should be invoiced.
	InvoiceAt time.Time `json:"invoiceAt"`

	// ManagedBy managedBy specifies if the line is manually added via the api or managed by OpenMeter.
	ManagedBy InvoiceLineManagedBy `json:"managedBy"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// MeteredPreLinePeriodQuantity The metered quantity of the item used in before this line's period without any discounts applied.
	//
	// It is non-zero in case of progressive billing, when this shows how much of the usage was already billed.
	MeteredPreLinePeriodQuantity *Numeric `json:"meteredPreLinePeriodQuantity,omitempty"`

	// MeteredQuantity The quantity of the item that has been metered for the period before any discounts were applied.
	MeteredQuantity *Numeric `json:"meteredQuantity,omitempty"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Period Period of the line item applies to for revenue recognition pruposes.
	//
	// Billing always treats periods as start being inclusive and end being exclusive.
	Period Period `json:"period"`

	// PreLinePeriodQuantity The quantity of the item used before this line's period.
	//
	// It is non-zero in case of progressive billing, when this shows how much of the usage was already billed.
	//
	// Any usage discounts applied previously are deducted from this quantity.
	PreLinePeriodQuantity *Numeric `json:"preLinePeriodQuantity,omitempty"`

	// Price Price of the usage-based item being sold.
	// Deprecated:
	Price *RateCardUsageBasedPrice `json:"price,omitempty"`

	// Quantity The quantity of the item being sold.
	//
	// Any usage discounts applied previously are deducted from this quantity.
	Quantity *Numeric `json:"quantity,omitempty"`

	// RateCard The rate card that is used for this line.
	//
	// The rate card captures the intent of the price and discounts for the usage-based item.
	RateCard *InvoiceUsageBasedRateCard `json:"rateCard,omitempty"`

	// Status Status of the line.
	//
	// External calls always create valid lines, other line types are managed by the
	// billing engine of OpenMeter.
	Status InvoiceLineStatus `json:"status"`

	// Subscription Subscription are the references to the subscritpions that this line is related to.
	Subscription *InvoiceLineSubscriptionReference `json:"subscription,omitempty"`

	// TaxConfig Tax config specify the tax configuration for this line.
	// Deprecated:
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Taxes Taxes applied to the invoice totals.
	Taxes *[]InvoiceLineTaxItem `json:"taxes,omitempty"`

	// Totals Totals for this line.
	Totals InvoiceTotals `json:"totals"`

	// Type Type of the line.
	Type InvoiceUsageBasedLineType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// InvoiceUsageBasedLineType Type of the line.
type InvoiceUsageBasedLineType string

// InvoiceUsageBasedLineReplaceUpdate InvoiceUpdateUsageBasedLineReplaceUpdate represents the update model for an UBP invoice line.
//
// This type makes ID optional to allow for creating new lines as part of the update.
type InvoiceUsageBasedLineReplaceUpdate struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// FeatureKey The feature that the usage is based on.
	// Deprecated:
	FeatureKey *string `json:"featureKey,omitempty"`

	// Id The ID of the line.
	Id *string `json:"id,omitempty"`

	// InvoiceAt The time this line item should be invoiced.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Period Period of the line item applies to for revenue recognition pruposes.
	//
	// Billing always treats periods as start being inclusive and end being exclusive.
	Period Period `json:"period"`

	// Price Price of the usage-based item being sold.
	// Deprecated:
	Price *RateCardUsageBasedPrice `json:"price,omitempty"`

	// RateCard The rate card that is used for this line.
	//
	// The rate card captures the intent of the price and discounts for the usage-based item.
	RateCard *InvoiceUsageBasedRateCard `json:"rateCard,omitempty"`

	// TaxConfig Tax config specify the tax configuration for this line.
	// Deprecated:
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type Type of the line.
	Type InvoiceUsageBasedLineReplaceUpdateType `json:"type"`
}

// InvoiceUsageBasedLineReplaceUpdateType Type of the line.
type InvoiceUsageBasedLineReplaceUpdateType string

// InvoiceUsageBasedPendingLineCreate InvoiceUsageBasedLineCreateWithCustomer represents the create model for an invoice line that is sold to the customer based on usage.
type InvoiceUsageBasedPendingLineCreate struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// FeatureKey The feature that the usage is based on.
	// Deprecated:
	FeatureKey *string `json:"featureKey,omitempty"`

	// InvoiceAt The time this line item should be invoiced.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Period Period of the line item applies to for revenue recognition pruposes.
	//
	// Billing always treats periods as start being inclusive and end being exclusive.
	Period Period `json:"period"`

	// Price Price of the usage-based item being sold.
	// Deprecated:
	Price *RateCardUsageBasedPrice `json:"price,omitempty"`

	// RateCard The rate card that is used for this line.
	//
	// The rate card captures the intent of the price and discounts for the usage-based item.
	RateCard *InvoiceUsageBasedRateCard `json:"rateCard,omitempty"`

	// TaxConfig Tax config specify the tax configuration for this line.
	// Deprecated:
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type Type of the line.
	Type InvoiceUsageBasedPendingLineCreateType `json:"type"`
}

// InvoiceUsageBasedPendingLineCreateType Type of the line.
type InvoiceUsageBasedPendingLineCreateType string

// InvoiceUsageBasedRateCard InvoiceUsageBasedRateCard represents the rate card (intent) for an usage-based line.
type InvoiceUsageBasedRateCard struct {
	// Discounts The discounts that are applied to the line.
	Discounts *BillingDiscounts `json:"discounts,omitempty"`

	// FeatureKey The feature the customer is entitled to use.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Price The price of the rate card.
	// When null, the feature or service is free.
	Price *RateCardUsageBasedPrice `json:"price"`

	// TaxConfig The tax config of the rate card.
	// When undefined, the tax config of the feature or the default tax config of the plan is used.
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`
}

// InvoiceWorkflowInvoicingSettingsReplaceUpdate InvoiceWorkflowInvoicingSettingsReplaceUpdate represents the update model for the invoicing settings of an invoice workflow.
type InvoiceWorkflowInvoicingSettingsReplaceUpdate struct {
	// AutoAdvance Whether to automatically issue the invoice after the draftPeriod has passed.
	AutoAdvance *bool `json:"autoAdvance,omitempty"`

	// DefaultTaxConfig Default tax configuration to apply to the invoices.
	DefaultTaxConfig *TaxConfig `json:"defaultTaxConfig,omitempty"`

	// DraftPeriod The period for the invoice to be kept in draft status for manual reviews.
	DraftPeriod *string `json:"draftPeriod,omitempty"`

	// DueAfter The period after which the invoice is due.
	// With some payment solutions it's only applicable for manual collection method.
	DueAfter *string `json:"dueAfter,omitempty"`
}

// InvoiceWorkflowReplaceUpdate InvoiceWorkflowReplaceUpdate represents the update model for an invoice workflow.
//
// Fields that are immutable a re removed from the model. This is based on InvoiceWorkflowSettings.
type InvoiceWorkflowReplaceUpdate struct {
	// Workflow The workflow used for this invoice.
	Workflow InvoiceWorkflowSettingsReplaceUpdate `json:"workflow"`
}

// InvoiceWorkflowSettings InvoiceWorkflowSettings represents the workflow settings used by the invoice.
//
// This is a clone of the billing profile's workflow settings at the time of invoice creation
// with customer overrides considered.
type InvoiceWorkflowSettings struct {
	// Apps The apps that will be used to orchestrate the invoice's workflow.
	Apps *BillingProfileAppsOrReference `json:"apps,omitempty"`

	// SourceBillingProfileId sourceBillingProfileID is the billing profile on which the workflow was based on.
	//
	// The profile is snapshotted on invoice creation, after which it can be altered independently
	// of the profile itself.
	SourceBillingProfileId string `json:"sourceBillingProfileId"`

	// Workflow The workflow details used by this invoice.
	Workflow BillingWorkflow `json:"workflow"`
}

// InvoiceWorkflowSettingsReplaceUpdate Mutable workflow settings for an invoice.
//
// Other fields on the invoice's workflow are not mutable, they serve as a history of the invoice's workflow
// at creation time.
type InvoiceWorkflowSettingsReplaceUpdate struct {
	// Invoicing The invoicing settings for this workflow
	Invoicing InvoiceWorkflowInvoicingSettingsReplaceUpdate `json:"invoicing"`

	// Payment The payment settings for this workflow
	Payment BillingWorkflowPaymentSettings `json:"payment"`
}

// ListEntitlementsResult List entitlements result
type ListEntitlementsResult struct {
	union json.RawMessage
}

// ListEntitlementsResult0 defines model for .
type ListEntitlementsResult0 = []Entitlement

// ListFeaturesResult List features result
type ListFeaturesResult struct {
	union json.RawMessage
}

// ListFeaturesResult0 defines model for .
type ListFeaturesResult0 = []Feature

// MarketplaceInstallResponse Marketplace install response.
type MarketplaceInstallResponse struct {
	// App App.
	// One of: stripe
	App App `json:"app"`

	// DefaultForCapabilityTypes Default for capabilities
	DefaultForCapabilityTypes []AppCapabilityType `json:"defaultForCapabilityTypes"`
}

// MarketplaceListing A marketplace listing.
// Represent an available app in the app marketplace that can be installed to the organization.
//
// Marketplace apps only exist in config so they don't extend the Resource model.
type MarketplaceListing struct {
	// Capabilities The app's capabilities.
	Capabilities []AppCapability `json:"capabilities"`

	// Description The app's description.
	Description string `json:"description"`

	// InstallMethods Install methods.
	//
	// List of methods to install the app.
	InstallMethods []InstallMethod `json:"installMethods"`

	// Name The app's name.
	Name string `json:"name"`

	// Type The app's type
	Type AppType `json:"type"`
}

// MarketplaceListingPaginatedResponse Paginated response
type MarketplaceListingPaginatedResponse struct {
	// Items The items in the current page.
	Items []MarketplaceListing `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// MeasureUsageFrom Measure usage from
type MeasureUsageFrom struct {
	union json.RawMessage
}

// MeasureUsageFromPreset Start of measurement options
type MeasureUsageFromPreset string

// MeasureUsageFromTime [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
type MeasureUsageFromTime = time.Time

// Metadata Set of key-value pairs.
// Metadata can be used to store additional information about a resource.
type Metadata = map[string]string

// Meter A meter is a configuration that defines how to match and aggregate events.
type Meter struct {
	// Aggregation The aggregation type to use for the meter.
	Aggregation MeterAggregation `json:"aggregation"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EventFrom The date since the meter should include events.
	// Useful to skip old events.
	// If not specified, all historical events are included.
	EventFrom *time.Time `json:"eventFrom,omitempty"`

	// EventType The event type to aggregate.
	EventType string `json:"eventType"`

	// GroupBy Named JSONPath expressions to extract the group by values from the event data.
	//
	// Keys must be unique and consist only alphanumeric and underscore characters.
	GroupBy *map[string]string `json:"groupBy,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	// Defaults to the slug if not specified.
	Name *string `json:"name,omitempty"`

	// Slug A unique, human-readable identifier for the meter.
	// Must consist only alphanumeric and underscore characters.
	Slug string `json:"slug"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// ValueProperty JSONPath expression to extract the value from the ingested event's data property.
	//
	// The ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.
	//
	// For UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.
	ValueProperty *string `json:"valueProperty,omitempty"`
}

// MeterAggregation The aggregation type to use for the meter.
type MeterAggregation string

// MeterCreate A meter create model.
type MeterCreate struct {
	// Aggregation The aggregation type to use for the meter.
	Aggregation MeterAggregation `json:"aggregation"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EventFrom The date since the meter should include events.
	// Useful to skip old events.
	// If not specified, all historical events are included.
	EventFrom *time.Time `json:"eventFrom,omitempty"`

	// EventType The event type to aggregate.
	EventType string `json:"eventType"`

	// GroupBy Named JSONPath expressions to extract the group by values from the event data.
	//
	// Keys must be unique and consist only alphanumeric and underscore characters.
	GroupBy *map[string]string `json:"groupBy,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	// Defaults to the slug if not specified.
	Name *string `json:"name,omitempty"`

	// Slug A unique, human-readable identifier for the meter.
	// Must consist only alphanumeric and underscore characters.
	Slug string `json:"slug"`

	// ValueProperty JSONPath expression to extract the value from the ingested event's data property.
	//
	// The ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.
	//
	// For UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.
	ValueProperty *string `json:"valueProperty,omitempty"`
}

// MeterOrderBy Order by options for meters.
type MeterOrderBy string

// MeterQueryRequest A meter query request.
type MeterQueryRequest struct {
	// ClientId Client ID
	// Useful to track progress of a query.
	ClientId *string `json:"clientId,omitempty"`

	// FilterGroupBy Simple filter for group bys with exact match.
	FilterGroupBy *map[string][]string `json:"filterGroupBy,omitempty"`

	// From Start date-time in RFC 3339 format.
	//
	// Inclusive.
	From *time.Time `json:"from,omitempty"`

	// GroupBy If not specified a single aggregate will be returned for each subject and time window.
	// `subject` is a reserved group by value.
	GroupBy *[]string `json:"groupBy,omitempty"`

	// Subject Filtering by multiple subjects.
	Subject *[]string `json:"subject,omitempty"`

	// To End date-time in RFC 3339 format.
	//
	// Inclusive.
	To *time.Time `json:"to,omitempty"`

	// WindowSize If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.
	WindowSize *WindowSize `json:"windowSize,omitempty"`

	// WindowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
	// If not specified, the UTC timezone will be used.
	WindowTimeZone *string `json:"windowTimeZone,omitempty"`
}

// MeterQueryResult The result of a meter query.
type MeterQueryResult struct {
	// Data The usage data.
	// If no data is available, an empty array is returned.
	Data []MeterQueryRow `json:"data"`

	// From The start of the period the usage is queried from.
	// If not specified, the usage is queried from the beginning of time.
	From *time.Time `json:"from,omitempty"`

	// To The end of the period the usage is queried to.
	// If not specified, the usage is queried up to the current time.
	To *time.Time `json:"to,omitempty"`

	// WindowSize The window size that the usage is aggregated.
	// If not specified, the usage is aggregated over the entire period.
	WindowSize *WindowSize `json:"windowSize,omitempty"`
}

// MeterQueryRow A row in the result of a meter query.
type MeterQueryRow struct {
	// GroupBy The group by values the value is aggregated over.
	GroupBy map[string]*string `json:"groupBy"`

	// Subject The subject the value is aggregated over.
	// If not specified, the value is aggregated over all subjects.
	Subject *string `json:"subject"`

	// Value The aggregated value.
	Value float64 `json:"value"`

	// WindowEnd The end of the window the value is aggregated over.
	WindowEnd time.Time `json:"windowEnd"`

	// WindowStart The start of the window the value is aggregated over.
	WindowStart time.Time `json:"windowStart"`
}

// MeterUpdate A meter update model.
//
// Only the properties that can be updated are included.
// For example, the slug and aggregation cannot be updated.
type MeterUpdate struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// GroupBy Named JSONPath expressions to extract the group by values from the event data.
	//
	// Keys must be unique and consist only alphanumeric and underscore characters.
	GroupBy *map[string]string `json:"groupBy,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	// Defaults to the slug if not specified.
	Name *string `json:"name,omitempty"`
}

// NotFoundProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type NotFoundProblemResponse = UnexpectedProblemResponse

// NotificationChannel Notification channel with webhook type.
type NotificationChannel = NotificationChannelWebhook

// NotificationChannelCreateRequest Request with input parameters for creating new notification channel with webhook type.
type NotificationChannelCreateRequest = NotificationChannelWebhookCreateRequest

// NotificationChannelMeta Metadata only fields of a notification channel.
type NotificationChannelMeta struct {
	// Id Identifies the notification channel.
	Id string `json:"id"`

	// Type Notification channel type.
	Type NotificationChannelType `json:"type"`
}

// NotificationChannelOrderBy Order by options for notification channels.
type NotificationChannelOrderBy string

// NotificationChannelPaginatedResponse Paginated response
type NotificationChannelPaginatedResponse struct {
	// Items The items in the current page.
	Items []NotificationChannel `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// NotificationChannelType Type of the notification channel.
type NotificationChannelType string

// NotificationChannelWebhook Notification channel with webhook type.
type NotificationChannelWebhook struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// CustomHeaders Custom HTTP headers sent as part of the webhook request.
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Disabled Whether the channel is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Id Identifies the notification channel.
	Id string `json:"id"`

	// Name User friendly name of the channel.
	Name string `json:"name"`

	// SigningSecret Signing secret used for webhook request validation on the receiving end.
	//
	// Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
	SigningSecret *string `json:"signingSecret,omitempty"`

	// Type Notification channel type.
	Type NotificationChannelWebhookType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// Url Webhook URL where the notification is sent.
	Url string `json:"url"`
}

// NotificationChannelWebhookType Notification channel type.
type NotificationChannelWebhookType string

// NotificationChannelWebhookCreateRequest Request with input parameters for creating new notification channel with webhook type.
type NotificationChannelWebhookCreateRequest struct {
	// CustomHeaders Custom HTTP headers sent as part of the webhook request.
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// Disabled Whether the channel is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Name User friendly name of the channel.
	Name string `json:"name"`

	// SigningSecret Signing secret used for webhook request validation on the receiving end.
	//
	// Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
	SigningSecret *string `json:"signingSecret,omitempty"`

	// Type Notification channel type.
	Type NotificationChannelWebhookCreateRequestType `json:"type"`

	// Url Webhook URL where the notification is sent.
	Url string `json:"url"`
}

// NotificationChannelWebhookCreateRequestType Notification channel type.
type NotificationChannelWebhookCreateRequestType string

// NotificationEvent Type of the notification event.
type NotificationEvent struct {
	// Annotations Set of key-value pairs managed by the system. Cannot be modified by user.
	Annotations *Annotations `json:"annotations,omitempty"`

	// CreatedAt Timestamp when the notification event was created in RFC 3339 format.
	CreatedAt time.Time `json:"createdAt"`

	// DeliveryStatus The delivery status of the notification event.
	DeliveryStatus []NotificationEventDeliveryStatus `json:"deliveryStatus"`

	// Id A unique identifier of the notification event.
	Id string `json:"id"`

	// Payload Timestamp when the notification event was created in RFC 3339 format.
	Payload NotificationEventPayload `json:"payload"`

	// Rule The nnotification rule which generated this event.
	Rule NotificationRule `json:"rule"`

	// Type Type of the notification event.
	Type NotificationEventType `json:"type"`
}

// NotificationEventBalanceThresholdPayload Payload for notification event with `entitlements.balance.threshold` type.
type NotificationEventBalanceThresholdPayload struct {
	// Data The data of the payload.
	Data NotificationEventBalanceThresholdPayloadData `json:"data"`

	// Id A unique identifier for the notification event the payload belongs to.
	Id string `json:"id"`

	// Timestamp Timestamp when the notification event was created in RFC 3339 format.
	Timestamp time.Time `json:"timestamp"`

	// Type Type of the notification event.
	Type NotificationEventBalanceThresholdPayloadType `json:"type"`
}

// NotificationEventBalanceThresholdPayloadType Type of the notification event.
type NotificationEventBalanceThresholdPayloadType string

// NotificationEventBalanceThresholdPayloadData Data of the payload for notification event with `entitlements.balance.threshold` type.
type NotificationEventBalanceThresholdPayloadData struct {
	Entitlement EntitlementMetered                    `json:"entitlement"`
	Feature     Feature                               `json:"feature"`
	Subject     Subject                               `json:"subject"`
	Threshold   NotificationRuleBalanceThresholdValue `json:"threshold"`
	Value       EntitlementValue                      `json:"value"`
}

// NotificationEventDeliveryStatus The delivery status of the notification event.
type NotificationEventDeliveryStatus struct {
	// Channel Notification channel the delivery sattus associated with.
	Channel NotificationChannelMeta `json:"channel"`

	// Reason The reason of the last deliverry state update.
	Reason string `json:"reason"`

	// State Delivery state of the notification event to the channel.
	State NotificationEventDeliveryStatusState `json:"state"`

	// UpdatedAt Timestamp of when the status was last updated in RFC 3339 format.
	UpdatedAt time.Time `json:"updatedAt"`
}

// NotificationEventDeliveryStatusState The delivery state of the notification event to the channel.
type NotificationEventDeliveryStatusState string

// NotificationEventEntitlementValuePayloadBase Base data for any payload with entitlement entitlement value.
type NotificationEventEntitlementValuePayloadBase struct {
	Entitlement EntitlementMetered `json:"entitlement"`
	Feature     Feature            `json:"feature"`
	Subject     Subject            `json:"subject"`
	Value       EntitlementValue   `json:"value"`
}

// NotificationEventInvoiceCreatedPayload Payload for notification event with `invoice.created` type.
type NotificationEventInvoiceCreatedPayload struct {
	// Data The data of the payload.
	Data Invoice `json:"data"`

	// Id A unique identifier for the notification event the payload belongs to.
	Id string `json:"id"`

	// Timestamp Timestamp when the notification event was created in RFC 3339 format.
	Timestamp time.Time `json:"timestamp"`

	// Type Type of the notification event.
	Type NotificationEventInvoiceCreatedPayloadType `json:"type"`
}

// NotificationEventInvoiceCreatedPayloadType Type of the notification event.
type NotificationEventInvoiceCreatedPayloadType string

// NotificationEventInvoiceUpdatedPayload Payload for notification event with `invoice.updated` type.
type NotificationEventInvoiceUpdatedPayload struct {
	// Data The data of the payload.
	Data Invoice `json:"data"`

	// Id A unique identifier for the notification event the payload belongs to.
	Id string `json:"id"`

	// Timestamp Timestamp when the notification event was created in RFC 3339 format.
	Timestamp time.Time `json:"timestamp"`

	// Type Type of the notification event.
	Type NotificationEventInvoiceUpdatedPayloadType `json:"type"`
}

// NotificationEventInvoiceUpdatedPayloadType Type of the notification event.
type NotificationEventInvoiceUpdatedPayloadType string

// NotificationEventOrderBy Order by options for notification channels.
type NotificationEventOrderBy string

// NotificationEventPaginatedResponse Paginated response
type NotificationEventPaginatedResponse struct {
	// Items The items in the current page.
	Items []NotificationEvent `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// NotificationEventPayload The delivery status of the notification event.
type NotificationEventPayload struct {
	union json.RawMessage
}

// NotificationEventResetPayload Payload for notification event with `entitlements.reset` type.
type NotificationEventResetPayload struct {
	// Data The data of the payload.
	Data NotificationEventEntitlementValuePayloadBase `json:"data"`

	// Id A unique identifier for the notification event the payload belongs to.
	Id string `json:"id"`

	// Timestamp Timestamp when the notification event was created in RFC 3339 format.
	Timestamp time.Time `json:"timestamp"`

	// Type Type of the notification event.
	Type NotificationEventResetPayloadType `json:"type"`
}

// NotificationEventResetPayloadType Type of the notification event.
type NotificationEventResetPayloadType string

// NotificationEventType Type of the notification event.
type NotificationEventType string

// NotificationRule Notification Rule.
type NotificationRule struct {
	union json.RawMessage
}

// NotificationRuleBalanceThreshold Notification rule with entitlements.balance.threshold type.
type NotificationRuleBalanceThreshold struct {
	// Channels List of notification channels the rule applies to.
	Channels []NotificationChannelMeta `json:"channels"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Features Optional field containing list of features the rule applies to.
	Features *[]FeatureMeta `json:"features,omitempty"`

	// Id Identifies the notification rule.
	Id string `json:"id"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Thresholds List of thresholds the rule suppose to be triggered.
	Thresholds []NotificationRuleBalanceThresholdValue `json:"thresholds"`

	// Type Notification rule type.
	Type NotificationRuleBalanceThresholdType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// NotificationRuleBalanceThresholdType Notification rule type.
type NotificationRuleBalanceThresholdType string

// NotificationRuleBalanceThresholdCreateRequest Request with input parameters for creating new notification rule with entitlements.balance.threshold type.
type NotificationRuleBalanceThresholdCreateRequest struct {
	// Channels List of notification channels the rule is applied to.
	Channels []string `json:"channels"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Features Optional field for defining the scope of notification by feature. It may contain features by id or key.
	Features *[]string `json:"features,omitempty"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Thresholds List of thresholds the rule suppose to be triggered.
	Thresholds []NotificationRuleBalanceThresholdValue `json:"thresholds"`

	// Type Notification rule type.
	Type NotificationRuleBalanceThresholdCreateRequestType `json:"type"`
}

// NotificationRuleBalanceThresholdCreateRequestType Notification rule type.
type NotificationRuleBalanceThresholdCreateRequestType string

// NotificationRuleBalanceThresholdValue Threshold value with multiple supported types.
type NotificationRuleBalanceThresholdValue struct {
	// Type Type of the threshold.
	Type NotificationRuleBalanceThresholdValueType `json:"type"`

	// Value Value of the threshold.
	Value float64 `json:"value"`
}

// NotificationRuleBalanceThresholdValueType Type of the rule in the balance threshold specification.
type NotificationRuleBalanceThresholdValueType string

// NotificationRuleCreateRequest Union type for requests creating new notification rule with certain type.
type NotificationRuleCreateRequest struct {
	union json.RawMessage
}

// NotificationRuleEntitlementReset Notification rule with entitlements.reset type.
type NotificationRuleEntitlementReset struct {
	// Channels List of notification channels the rule applies to.
	Channels []NotificationChannelMeta `json:"channels"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Features Optional field containing list of features the rule applies to.
	Features *[]FeatureMeta `json:"features,omitempty"`

	// Id Identifies the notification rule.
	Id string `json:"id"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Type Notification rule type.
	Type NotificationRuleEntitlementResetType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// NotificationRuleEntitlementResetType Notification rule type.
type NotificationRuleEntitlementResetType string

// NotificationRuleEntitlementResetCreateRequest Request with input parameters for creating new notification rule with entitlements.reset type.
type NotificationRuleEntitlementResetCreateRequest struct {
	// Channels List of notification channels the rule is applied to.
	Channels []string `json:"channels"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Features Optional field for defining the scope of notification by feature. It may contain features by id or key.
	Features *[]string `json:"features,omitempty"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Type Notification rule type.
	Type NotificationRuleEntitlementResetCreateRequestType `json:"type"`
}

// NotificationRuleEntitlementResetCreateRequestType Notification rule type.
type NotificationRuleEntitlementResetCreateRequestType string

// NotificationRuleInvoiceCreated Notification rule with invoice.created type.
type NotificationRuleInvoiceCreated struct {
	// Channels List of notification channels the rule applies to.
	Channels []NotificationChannelMeta `json:"channels"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Id Identifies the notification rule.
	Id string `json:"id"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Type Notification rule type.
	Type NotificationRuleInvoiceCreatedType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// NotificationRuleInvoiceCreatedType Notification rule type.
type NotificationRuleInvoiceCreatedType string

// NotificationRuleInvoiceCreatedCreateRequest Request with input parameters for creating new notification rule with invoice.created type.
type NotificationRuleInvoiceCreatedCreateRequest struct {
	// Channels List of notification channels the rule is applied to.
	Channels []string `json:"channels"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Type Notification rule type.
	Type NotificationRuleInvoiceCreatedCreateRequestType `json:"type"`
}

// NotificationRuleInvoiceCreatedCreateRequestType Notification rule type.
type NotificationRuleInvoiceCreatedCreateRequestType string

// NotificationRuleInvoiceUpdated Notification rule with invoice.updated type.
type NotificationRuleInvoiceUpdated struct {
	// Channels List of notification channels the rule applies to.
	Channels []NotificationChannelMeta `json:"channels"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Id Identifies the notification rule.
	Id string `json:"id"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Type Notification rule type.
	Type NotificationRuleInvoiceUpdatedType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// NotificationRuleInvoiceUpdatedType Notification rule type.
type NotificationRuleInvoiceUpdatedType string

// NotificationRuleInvoiceUpdatedCreateRequest Request with input parameters for creating new notification rule with invoice.updated  type.
type NotificationRuleInvoiceUpdatedCreateRequest struct {
	// Channels List of notification channels the rule is applied to.
	Channels []string `json:"channels"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Type Notification rule type.
	Type NotificationRuleInvoiceUpdatedCreateRequestType `json:"type"`
}

// NotificationRuleInvoiceUpdatedCreateRequestType Notification rule type.
type NotificationRuleInvoiceUpdatedCreateRequestType string

// NotificationRuleOrderBy Order by options for notification channels.
type NotificationRuleOrderBy string

// NotificationRulePaginatedResponse Paginated response
type NotificationRulePaginatedResponse struct {
	// Items The items in the current page.
	Items []NotificationRule `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// Numeric Numeric represents an arbitrary precision number.
type Numeric = string

// OAuth2AuthorizationCodeGrantErrorType OAuth2 authorization code grant error types.
type OAuth2AuthorizationCodeGrantErrorType string

// PackagePriceWithCommitments Package price with spend commitments.
type PackagePriceWithCommitments struct {
	// Amount The price of one package.
	Amount Numeric `json:"amount"`

	// MaximumAmount The customer is limited to spend at most the amount.
	MaximumAmount *Numeric `json:"maximumAmount,omitempty"`

	// MinimumAmount The customer is committed to spend at least the amount.
	MinimumAmount *Numeric `json:"minimumAmount,omitempty"`

	// QuantityPerPackage The quantity per package.
	QuantityPerPackage Numeric `json:"quantityPerPackage"`

	// Type The type of the price.
	Type PackagePriceWithCommitmentsType `json:"type"`
}

// PackagePriceWithCommitmentsType The type of the price.
type PackagePriceWithCommitmentsType string

// PaymentDueDate PaymentDueDate contains an amount that should be paid by the given date.
type PaymentDueDate struct {
	// Amount How much needs to be paid by the date.
	Amount Numeric `json:"amount"`

	// Currency If different from the parent document's base currency.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// DueAt When the payment is due.
	DueAt time.Time `json:"dueAt"`

	// Notes Other details to take into account for the due date.
	Notes *string `json:"notes,omitempty"`

	// Percent Percentage of the total that should be paid by the date.
	Percent *Percentage `json:"percent,omitempty"`
}

// PaymentTermDueDate PaymentTermDueDate defines the terms for payment on a specific date.
type PaymentTermDueDate struct {
	// Detail Text detail of the chosen payment terms.
	Detail *string `json:"detail,omitempty"`

	// DueAt When the payment is due.
	DueAt []PaymentDueDate `json:"dueAt"`

	// Notes Description of the conditions for payment.
	Notes *string `json:"notes,omitempty"`

	// Type Type of terms to be applied.
	Type PaymentTermDueDateType `json:"type"`
}

// PaymentTermDueDateType Type of terms to be applied.
type PaymentTermDueDateType string

// PaymentTermInstant PaymentTermInstant defines the terms for payment on receipt of invoice.
type PaymentTermInstant struct {
	// Detail Text detail of the chosen payment terms.
	Detail *string `json:"detail,omitempty"`

	// Notes Description of the conditions for payment.
	Notes *string `json:"notes,omitempty"`

	// Type Type of terms to be applied.
	Type PaymentTermInstantType `json:"type"`
}

// PaymentTermInstantType Type of terms to be applied.
type PaymentTermInstantType string

// PaymentTerms PaymentTerms defines the terms for payment.
type PaymentTerms struct {
	union json.RawMessage
}

// Percentage Numeric representation of a percentage
//
// 50% is represented as 50
type Percentage = models.Percentage

// Period A period with a start and end time.
type Period struct {
	// From Period start time.
	From time.Time `json:"from"`

	// To Period end time.
	To time.Time `json:"to"`
}

// Plan Plans provide a template for subscriptions.
type Plan struct {
	// Alignment Alignment configuration for the plan.
	Alignment *Alignment `json:"alignment,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency The currency code of the plan.
	Currency CurrencyCode `json:"currency"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EffectiveFrom The date and time when the plan becomes effective. When not specified, the plan is a draft.
	EffectiveFrom *time.Time `json:"effectiveFrom,omitempty"`

	// EffectiveTo The date and time when the plan is no longer effective. When not specified, the plan is effective indefinitely.
	EffectiveTo *time.Time `json:"effectiveTo,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Phases The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
	// A phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.
	Phases []PlanPhase `json:"phases"`

	// Status The status of the plan.
	// Computed based on the effective start and end dates:
	// - draft = no effectiveFrom
	// - active = effectiveFrom <= now < effectiveTo
	// - archived / inactive = effectiveTo <= now
	// - scheduled = now < effectiveFrom < effectiveTo
	Status PlanStatus `json:"status"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// Version Version of the plan. Incremented when the plan is updated.
	Version int `json:"version"`
}

// PlanAddon The PlanAddon describes the association between a plan and add-on.
type PlanAddon struct {
	// Addon Add-on object.
	Addon Addon `json:"addon"`

	// Annotations Set of key-value pairs managed by the system. Cannot be modified by user.
	Annotations *Annotations `json:"annotations,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FromPlanPhase The key of the plan phase from the add-on becomes available for purchase.
	FromPlanPhase string `json:"fromPlanPhase"`

	// MaxQuantity The maximum number of times the add-on can be purchased for the plan.
	// It is not applicable for add-ons with single instance type.
	MaxQuantity *int `json:"maxQuantity,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// ValidationErrors List of validation errors.
	ValidationErrors *[]ValidationError `json:"validationErrors"`
}

// PlanAddonCreate A plan add-on assignment create request.
type PlanAddonCreate struct {
	// AddonId The add-on unique identifier in ULID format.
	AddonId string `json:"addonId"`

	// FromPlanPhase The key of the plan phase from the add-on becomes available for purchase.
	FromPlanPhase string `json:"fromPlanPhase"`

	// MaxQuantity The maximum number of times the add-on can be purchased for the plan.
	// It is not applicable for add-ons with single instance type.
	MaxQuantity *int `json:"maxQuantity,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata,omitempty"`
}

// PlanAddonOrderBy Order by options for plan add-on assignments.
type PlanAddonOrderBy string

// PlanAddonPaginatedResponse Paginated response
type PlanAddonPaginatedResponse struct {
	// Items The items in the current page.
	Items []PlanAddon `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// PlanAddonReplaceUpdate Resource update operation model.
type PlanAddonReplaceUpdate struct {
	// FromPlanPhase The key of the plan phase from the add-on becomes available for purchase.
	FromPlanPhase string `json:"fromPlanPhase"`

	// MaxQuantity The maximum number of times the add-on can be purchased for the plan.
	// It is not applicable for add-ons with single instance type.
	MaxQuantity *int `json:"maxQuantity,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata,omitempty"`
}

// PlanCreate Resource create operation model.
type PlanCreate struct {
	// Alignment Alignment configuration for the plan.
	Alignment *Alignment `json:"alignment,omitempty"`

	// Currency The currency code of the plan.
	Currency CurrencyCode `json:"currency"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Phases The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
	// A phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.
	Phases []PlanPhase `json:"phases"`
}

// PlanOrderBy Order by options for plans.
type PlanOrderBy string

// PlanPaginatedResponse Paginated response
type PlanPaginatedResponse struct {
	// Items The items in the current page.
	Items []Plan `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// PlanPhase The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
type PlanPhase struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Duration The duration of the phase.
	Duration *string `json:"duration"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// RateCards The rate cards of the plan.
	RateCards []RateCard `json:"rateCards"`
}

// PlanReference References an exact plan.
type PlanReference struct {
	// Id The plan ID.
	Id string `json:"id"`

	// Key The plan key.
	Key string `json:"key"`

	// Version The plan version.
	Version int `json:"version"`
}

// PlanReferenceInput References an exact plan defaulting to the current active version.
type PlanReferenceInput struct {
	// Key The plan key.
	Key string `json:"key"`

	// Version The plan version.
	Version *int `json:"version,omitempty"`
}

// PlanReplaceUpdate Resource update operation model.
type PlanReplaceUpdate struct {
	// Alignment Alignment configuration for the plan.
	Alignment *Alignment `json:"alignment,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Phases The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
	// A phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.
	Phases []PlanPhase `json:"phases"`
}

// PlanStatus The status of a plan.
type PlanStatus string

// PlanSubscriptionChange Change subscription based on plan.
type PlanSubscriptionChange struct {
	// Alignment What alignment settings the subscription should have.
	Alignment *Alignment `json:"alignment,omitempty"`

	// Description Description for the Subscription.
	Description *string `json:"description,omitempty"`

	// Metadata Arbitrary metadata associated with the subscription.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the Subscription. If not provided the plan name is used.
	Name *string `json:"name,omitempty"`

	// Plan The plan reference to change to.
	Plan PlanReferenceInput `json:"plan"`

	// StartingPhase The key of the phase to start the subscription in.
	// If not provided, the subscription will start in the first phase of the plan.
	StartingPhase *string `json:"startingPhase,omitempty"`

	// Timing Timing configuration for the change, when the change should take effect.
	// For changing a subscription, the accepted values depend on the subscription configuration.
	Timing SubscriptionTiming `json:"timing"`
}

// PlanSubscriptionCreate Create subscription based on plan.
type PlanSubscriptionCreate struct {
	// Alignment What alignment settings the subscription should have.
	Alignment *Alignment `json:"alignment,omitempty"`

	// CustomerId The ID of the customer. Provide either the key or ID. Has presedence over the key.
	CustomerId *string `json:"customerId,omitempty"`

	// CustomerKey The key of the customer. Provide either the key or ID.
	CustomerKey *string `json:"customerKey,omitempty"`

	// Description Description for the Subscription.
	Description *string `json:"description,omitempty"`

	// Metadata Arbitrary metadata associated with the subscription.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name The name of the Subscription. If not provided the plan name is used.
	Name *string `json:"name,omitempty"`

	// Plan The plan reference to change to.
	Plan PlanReferenceInput `json:"plan"`

	// StartingPhase The key of the phase to start the subscription in.
	// If not provided, the subscription will start in the first phase of the plan.
	StartingPhase *string `json:"startingPhase,omitempty"`

	// Timing Timing configuration for the change, when the change should take effect.
	// The default is immediate.
	Timing *SubscriptionTiming `json:"timing,omitempty"`
}

// PortalToken A consumer portal token.
//
// Validator doesn't obey required for readOnly properties
// See: https://github.com/stoplightio/spectral/issues/1274
type PortalToken struct {
	// AllowedMeterSlugs Optional, if defined only the specified meters will be allowed.
	AllowedMeterSlugs *[]string `json:"allowedMeterSlugs,omitempty"`

	// CreatedAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Expired   *bool      `json:"expired,omitempty"`

	// ExpiresAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id      *string `json:"id,omitempty"`
	Subject string  `json:"subject"`

	// Token The token is only returned at creation.
	Token *string `json:"token,omitempty"`
}

// PreconditionFailedProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type PreconditionFailedProblemResponse = UnexpectedProblemResponse

// PricePaymentTerm The payment term of a flat price.
// One of: in_advance or in_arrears.
type PricePaymentTerm string

// PriceTier A price tier.
// At least one price component is required in each tier.
type PriceTier struct {
	// FlatPrice The flat price component of the tier.
	FlatPrice *FlatPrice `json:"flatPrice"`

	// UnitPrice The unit price component of the tier.
	UnitPrice *UnitPrice `json:"unitPrice"`

	// UpToAmount Up to and including to this quantity will be contained in the tier.
	// If null, the tier is open-ended.
	UpToAmount *Numeric `json:"upToAmount,omitempty"`
}

// Progress Progress describes a progress of a task.
type Progress struct {
	// Failed Failed is the number of items that failed
	Failed uint64 `json:"failed"`

	// Success Success is the number of items that succeeded
	Success uint64 `json:"success"`

	// Total The total number of items to process
	Total uint64 `json:"total"`

	// UpdatedAt The time the progress was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// RateCard A rate card defines the pricing and entitlement of a feature or service.
type RateCard struct {
	union json.RawMessage
}

// RateCardBooleanEntitlement Entitlement template of a boolean entitlement.
type RateCardBooleanEntitlement struct {
	// Metadata Additional metadata for the feature.
	Metadata *Metadata                      `json:"metadata,omitempty"`
	Type     RateCardBooleanEntitlementType `json:"type"`
}

// RateCardBooleanEntitlementType defines model for RateCardBooleanEntitlement.Type.
type RateCardBooleanEntitlementType string

// RateCardEntitlement Entitlement templates are used to define the entitlements of a plan.
// Features are omitted from the entitlement template, as they are defined in the rate card.
type RateCardEntitlement struct {
	union json.RawMessage
}

// RateCardFlatFee A flat fee rate card defines a one-time purchase or a recurring fee.
type RateCardFlatFee struct {
	// BillingCadence The billing cadence of the rate card.
	// When null it means it is a one time fee.
	BillingCadence *string `json:"billingCadence"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Discounts The discount of the rate card. For flat fee rate cards only percentage discounts are supported.
	// Only available when price is set.
	Discounts *Discounts `json:"discounts,omitempty"`

	// EntitlementTemplate The entitlement of the rate card.
	// Only available when featureKey is set.
	EntitlementTemplate *RateCardEntitlement `json:"entitlementTemplate,omitempty"`

	// FeatureKey The feature the customer is entitled to use.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Price The price of the rate card.
	// When null, the feature or service is free.
	Price *FlatPriceWithPaymentTerm `json:"price"`

	// TaxConfig The tax config of the rate card.
	// When undefined, the tax config of the feature or the default tax config of the plan is used.
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type The type of the RateCard.
	Type RateCardFlatFeeType `json:"type"`
}

// RateCardFlatFeeType The type of the RateCard.
type RateCardFlatFeeType string

// RateCardMeteredEntitlement The entitlement template with a metered entitlement.
type RateCardMeteredEntitlement struct {
	// IsSoftLimit If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
	IsSoftLimit *bool `json:"isSoftLimit,omitempty"`

	// IssueAfterReset You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
	// If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
	// That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
	// Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
	IssueAfterReset *float64 `json:"issueAfterReset,omitempty"`

	// IssueAfterResetPriority Defines the grant priority for the default grant.
	IssueAfterResetPriority *uint8 `json:"issueAfterResetPriority,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// PreserveOverageAtReset If true, the overage is preserved at reset. If false, the usage is reset to 0.
	PreserveOverageAtReset *bool                          `json:"preserveOverageAtReset,omitempty"`
	Type                   RateCardMeteredEntitlementType `json:"type"`

	// UsagePeriod The interval of the metered entitlement.
	// Defaults to the billing cadence of the rate card.
	UsagePeriod *string `json:"usagePeriod,omitempty"`
}

// RateCardMeteredEntitlementType defines model for RateCardMeteredEntitlement.Type.
type RateCardMeteredEntitlementType string

// RateCardStaticEntitlement Entitlement template of a static entitlement.
type RateCardStaticEntitlement struct {
	// Config The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
	Config json.RawMessage `json:"config"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata                     `json:"metadata,omitempty"`
	Type     RateCardStaticEntitlementType `json:"type"`
}

// RateCardStaticEntitlementType defines model for RateCardStaticEntitlement.Type.
type RateCardStaticEntitlementType string

// RateCardUsageBased A usage-based rate card defines a price based on usage.
type RateCardUsageBased struct {
	// BillingCadence The billing cadence of the rate card.
	BillingCadence string `json:"billingCadence"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Discounts The discounts of the rate card.
	//
	// Flat fee rate cards only support percentage discounts.
	Discounts *Discounts `json:"discounts,omitempty"`

	// EntitlementTemplate The entitlement of the rate card.
	// Only available when featureKey is set.
	EntitlementTemplate *RateCardEntitlement `json:"entitlementTemplate,omitempty"`

	// FeatureKey The feature the customer is entitled to use.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Price The price of the rate card.
	// When null, the feature or service is free.
	Price *RateCardUsageBasedPrice `json:"price"`

	// TaxConfig The tax config of the rate card.
	// When undefined, the tax config of the feature or the default tax config of the plan is used.
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type The type of the RateCard.
	Type RateCardUsageBasedType `json:"type"`
}

// RateCardUsageBasedType The type of the RateCard.
type RateCardUsageBasedType string

// RateCardUsageBasedPrice The price of the usage based rate card.
type RateCardUsageBasedPrice struct {
	union json.RawMessage
}

// RecurringPeriod Recurring period with an interval and an anchor.
type RecurringPeriod struct {
	// Anchor A date-time anchor to base the recurring period on.
	Anchor time.Time `json:"anchor"`

	// Interval The unit of time for the interval. Heuristically maps ISO duraitons to enum values or returns the ISO duration.
	Interval RecurringPeriodInterval `json:"interval"`

	// IntervalISO The unit of time for the interval in ISO8601 format.
	IntervalISO string `json:"intervalISO"`
}

// RecurringPeriodCreateInput Recurring period with an interval and an anchor.
type RecurringPeriodCreateInput struct {
	// Anchor A date-time anchor to base the recurring period on.
	Anchor *time.Time `json:"anchor,omitempty"`

	// Interval The unit of time for the interval.
	Interval RecurringPeriodInterval `json:"interval"`
}

// RecurringPeriodInterval Period duration for the recurrence
type RecurringPeriodInterval struct {
	union json.RawMessage
}

// RecurringPeriodInterval0 defines model for .
type RecurringPeriodInterval0 = string

// RecurringPeriodIntervalEnum The unit of time for the interval.
// One of: `day`, `week`, `month`, or `year`.
type RecurringPeriodIntervalEnum string

// RemovePhaseShifting The direction of the phase shift when a phase is removed.
type RemovePhaseShifting string

// ResetEntitlementUsageInput Reset parameters
type ResetEntitlementUsageInput struct {
	// EffectiveAt The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.
	EffectiveAt *time.Time `json:"effectiveAt,omitempty"`

	// PreserveOverage Determines whether the overage is preserved or forgiven, overriding the entitlement's default behavior.
	// - If true, the overage is preserved.
	// - If false, the overage is forgiven.
	PreserveOverage *bool `json:"preserveOverage,omitempty"`

	// RetainAnchor Determines whether the usage period anchor is retained or reset to the effectiveAt time.
	// - If true, the usage period anchor is retained.
	// - If false, the usage period anchor is reset to the effectiveAt time.
	RetainAnchor *bool `json:"retainAnchor,omitempty"`
}

// SandboxApp Sandbox app can be used for testing OpenMeter features.
//
// The app is not creating anything in external systems, thus it is safe to use for
// verifying OpenMeter features.
type SandboxApp struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Default Default for the app type
	// Only one app of each type can be default.
	Default bool `json:"default"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Listing The marketplace listing that this installed app is based on.
	Listing MarketplaceListing `json:"listing"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Status Status of the app connection.
	Status AppStatus `json:"status"`

	// Type The app's type is Sandbox.
	Type SandboxAppType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SandboxAppType The app's type is Sandbox.
type SandboxAppType string

// SandboxAppReplaceUpdate Resource update operation model.
type SandboxAppReplaceUpdate struct {
	// Default Default for the app type
	// Only one app of each type can be default.
	Default bool `json:"default"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Type The app's type is Sandbox.
	Type SandboxAppReplaceUpdateType `json:"type"`
}

// SandboxAppReplaceUpdateType The app's type is Sandbox.
type SandboxAppReplaceUpdateType string

// SandboxCustomerAppData Sandbox Customer App Data.
type SandboxCustomerAppData struct {
	// App The installed sandbox app this data belongs to.
	App *SandboxApp `json:"app,omitempty"`

	// Id The app ID.
	// If not provided, it will use the global default for the app type.
	Id *string `json:"id,omitempty"`

	// Type The app name.
	Type SandboxCustomerAppDataType `json:"type"`
}

// SandboxCustomerAppDataType The app name.
type SandboxCustomerAppDataType string

// ServiceUnavailableProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type ServiceUnavailableProblemResponse = UnexpectedProblemResponse

// SortOrder The order direction.
type SortOrder string

// StripeAPIKeyInput The Stripe API key input.
// Used to authenticate with the Stripe API.
type StripeAPIKeyInput struct {
	SecretAPIKey string `json:"secretAPIKey"`
}

// StripeApp A installed Stripe app object.
type StripeApp struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Default Default for the app type
	// Only one app of each type can be default.
	Default bool `json:"default"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Listing The marketplace listing that this installed app is based on.
	Listing MarketplaceListing `json:"listing"`

	// Livemode Livemode, true if the app is in production mode.
	Livemode bool `json:"livemode"`

	// MaskedAPIKey The masked API key.
	// Only shows the first 8 and last 3 characters.
	MaskedAPIKey string `json:"maskedAPIKey"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Status Status of the app connection.
	Status AppStatus `json:"status"`

	// StripeAccountId The Stripe account ID.
	StripeAccountId string `json:"stripeAccountId"`

	// Type The app's type is Stripe.
	Type StripeAppType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// StripeAppType The app's type is Stripe.
type StripeAppType string

// StripeAppReplaceUpdate Resource update operation model.
type StripeAppReplaceUpdate struct {
	// Default Default for the app type
	// Only one app of each type can be default.
	Default bool `json:"default"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// SecretAPIKey The Stripe API key.
	SecretAPIKey *string `json:"secretAPIKey,omitempty"`

	// Type The app's type is Stripe.
	Type StripeAppReplaceUpdateType `json:"type"`
}

// StripeAppReplaceUpdateType The app's type is Stripe.
type StripeAppReplaceUpdateType string

// StripeCheckoutSessionMode Stripe CheckoutSession.mode
type StripeCheckoutSessionMode string

// StripeCustomerAppData Stripe Customer App Data.
type StripeCustomerAppData struct {
	// App The installed stripe app this data belongs to.
	App *StripeApp `json:"app,omitempty"`

	// Id The app ID.
	// If not provided, it will use the global default for the app type.
	Id *string `json:"id,omitempty"`

	// StripeCustomerId The Stripe customer ID.
	StripeCustomerId string `json:"stripeCustomerId"`

	// StripeDefaultPaymentMethodId The Stripe default payment method ID.
	StripeDefaultPaymentMethodId *string `json:"stripeDefaultPaymentMethodId,omitempty"`

	// Type The app name.
	Type StripeCustomerAppDataType `json:"type"`
}

// StripeCustomerAppDataType The app name.
type StripeCustomerAppDataType string

// StripeCustomerAppDataCreateOrUpdateItem Stripe Customer App Data.
type StripeCustomerAppDataCreateOrUpdateItem struct {
	// Id The app ID.
	// If not provided, it will use the global default for the app type.
	Id *string `json:"id,omitempty"`

	// StripeCustomerId The Stripe customer ID.
	StripeCustomerId string `json:"stripeCustomerId"`

	// StripeDefaultPaymentMethodId The Stripe default payment method ID.
	StripeDefaultPaymentMethodId *string `json:"stripeDefaultPaymentMethodId,omitempty"`

	// Type The app name.
	Type StripeCustomerAppDataCreateOrUpdateItemType `json:"type"`
}

// StripeCustomerAppDataCreateOrUpdateItemType The app name.
type StripeCustomerAppDataCreateOrUpdateItemType string

// StripeTaxConfig The tax config for Stripe.
type StripeTaxConfig struct {
	// Code Product tax code.
	//
	// See: https://docs.stripe.com/tax/tax-codes
	Code string `json:"code"`
}

// StripeWebhookEvent Stripe webhook event.
type StripeWebhookEvent struct {
	// Created The event created timestamp.
	Created int32 `json:"created"`

	// Data The event data.
	Data struct {
		Object interface{} `json:"object"`
	} `json:"data"`

	// Id The event ID.
	Id string `json:"id"`

	// Livemode Live mode.
	Livemode bool `json:"livemode"`

	// Type The event type.
	Type string `json:"type"`
}

// StripeWebhookResponse Stripe webhook response.
type StripeWebhookResponse struct {
	// AppId ULID (Universally Unique Lexicographically Sortable Identifier).
	AppId string `json:"appId"`

	// CustomerId ULID (Universally Unique Lexicographically Sortable Identifier).
	CustomerId *string `json:"customerId,omitempty"`
	Message    *string `json:"message,omitempty"`

	// NamespaceId ULID (Universally Unique Lexicographically Sortable Identifier).
	NamespaceId string `json:"namespaceId"`
}

// Subject A subject is a unique identifier for a user or entity.
type Subject struct {
	// CurrentPeriodEnd [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CurrentPeriodEnd *time.Time `json:"currentPeriodEnd,omitempty"`

	// CurrentPeriodStart [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CurrentPeriodStart *time.Time `json:"currentPeriodStart,omitempty"`

	// DisplayName A human-readable display name for the subject.
	DisplayName *string `json:"displayName"`

	// Id A unique identifier for the subject.
	Id string `json:"id"`

	// Key A unique, human-readable identifier for the subject.
	Key              string                  `json:"key"`
	Metadata         *map[string]interface{} `json:"metadata"`
	StripeCustomerId *string                 `json:"stripeCustomerId"`
}

// SubjectUpsert A subject is a unique identifier for a user or entity.
type SubjectUpsert struct {
	// CurrentPeriodEnd [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CurrentPeriodEnd *time.Time `json:"currentPeriodEnd,omitempty"`

	// CurrentPeriodStart [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CurrentPeriodStart *time.Time `json:"currentPeriodStart,omitempty"`

	// DisplayName A human-readable display name for the subject.
	DisplayName *string `json:"displayName"`

	// Key A unique, human-readable identifier for the subject.
	Key              string                  `json:"key"`
	Metadata         *map[string]interface{} `json:"metadata"`
	StripeCustomerId *string                 `json:"stripeCustomerId"`
}

// Subscription Subscription is an exact subscription instance.
type Subscription struct {
	// ActiveFrom The cadence start of the resource.
	ActiveFrom time.Time `json:"activeFrom"`

	// ActiveTo The cadence end of the resource.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// Alignment Alignment configuration for the plan.
	Alignment *Alignment `json:"alignment,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency The currency code of the subscription.
	// Will be revised once we add multi currency support.
	Currency CurrencyCode `json:"currency"`

	// CustomerId The customer ID of the subscription.
	CustomerId string `json:"customerId"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Plan The plan of the subscription.
	Plan *PlanReference `json:"plan,omitempty"`

	// Status The status of the subscription.
	Status SubscriptionStatus `json:"status"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SubscriptionAddon A subscription add-on, represents concrete instances of an add-on for a given subscription.
type SubscriptionAddon struct {
	// ActiveFrom The cadence start of the resource.
	ActiveFrom time.Time `json:"activeFrom"`

	// ActiveTo The cadence end of the resource.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// Addon Partially populated add-on properties.
	Addon struct {
		// Id The ID of the add-on.
		Id string `json:"id"`

		// InstanceType The instance type of the add-on.
		InstanceType AddonInstanceType `json:"instanceType"`

		// Key A semi-unique identifier for the resource.
		Key string `json:"key"`

		// Version The version of the Add-on which templates this instance.
		Version int `json:"version"`
	} `json:"addon"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Quantity The quantity of the add-on. Always 1 for single instance add-ons.
	Quantity int `json:"quantity"`

	// QuantityAt For which point in time the quantity was resolved to.
	QuantityAt time.Time `json:"quantityAt"`

	// RateCards The rate cards of the add-on.
	RateCards []SubscriptionAddonRateCard `json:"rateCards"`

	// SubscriptionId The ID of the subscription.
	SubscriptionId string `json:"subscriptionId"`

	// Timeline The timeline of the add-on. The returned periods are sorted and continuous.
	Timeline []SubscriptionAddonTimelineSegment `json:"timeline"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SubscriptionAddonCreate A subscription add-on create body.
type SubscriptionAddonCreate struct {
	// Addon The add-on to create.
	Addon struct {
		// Id The ID of the add-on.
		Id string `json:"id"`
	} `json:"addon"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Quantity The quantity of the add-on. Always 1 for single instance add-ons.
	Quantity int `json:"quantity"`

	// Timing The timing of the operation. After the create or update, a new entry will be created in the timeline.
	Timing SubscriptionTiming `json:"timing"`
}

// SubscriptionAddonRateCard A rate card for a subscription add-on.
type SubscriptionAddonRateCard struct {
	// AffectedSubscriptionItemIds The IDs of the subscription items that this rate card belongs to.
	AffectedSubscriptionItemIds []string `json:"affectedSubscriptionItemIds"`

	// RateCard The rate card.
	RateCard RateCard `json:"rateCard"`
}

// SubscriptionAddonTimelineSegment A subscription add-on event.
type SubscriptionAddonTimelineSegment struct {
	// ActiveFrom The cadence start of the resource.
	ActiveFrom time.Time `json:"activeFrom"`

	// ActiveTo The cadence end of the resource.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// Quantity The quantity of the add-on for the given period.
	Quantity int `json:"quantity"`
}

// SubscriptionAddonUpdate Resource create or update operation model.
type SubscriptionAddonUpdate struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name *string `json:"name,omitempty"`

	// Quantity The quantity of the add-on. Always 1 for single instance add-ons.
	Quantity *int `json:"quantity,omitempty"`

	// Timing The timing of the operation. After the create or update, a new entry will be created in the timeline.
	Timing *SubscriptionTiming `json:"timing,omitempty"`
}

// SubscriptionAlignment Alignment details enriched with the current billing period.
type SubscriptionAlignment struct {
	// BillablesMustAlign Whether all Billable items and RateCards must align.
	// Alignment means the Price's BillingCadence must align for both duration and anchor time.
	BillablesMustAlign *bool `json:"billablesMustAlign,omitempty"`

	// CurrentAlignedBillingPeriod The current billing period. Only has value if the subscription is aligned and active.
	CurrentAlignedBillingPeriod *Period `json:"currentAlignedBillingPeriod,omitempty"`
}

// SubscriptionChange Change a subscription.
type SubscriptionChange struct {
	union json.RawMessage
}

// SubscriptionChangeResponseBody Response body for subscription change.
type SubscriptionChangeResponseBody struct {
	// Current The current subscription before the change.
	Current Subscription `json:"current"`

	// Next The new state of the subscription after the change.
	Next SubscriptionExpanded `json:"next"`
}

// SubscriptionCreate Create a subscription.
type SubscriptionCreate struct {
	union json.RawMessage
}

// SubscriptionEdit Subscription edit input.
type SubscriptionEdit struct {
	// Customizations Batch processing commands for manipulating running subscriptions.
	// The key format is `/phases/{phaseKey}` or `/phases/{phaseKey}/items/{itemKey}`.
	Customizations []SubscriptionEditOperation `json:"customizations"`

	// Timing Whether the billing period should be restarted.Timing configuration to allow for the changes to take effect at different times.
	Timing *SubscriptionTiming `json:"timing,omitempty"`
}

// SubscriptionEditOperation The operation to be performed on the subscription.
type SubscriptionEditOperation struct {
	union json.RawMessage
}

// SubscriptionExpanded Expanded subscription
type SubscriptionExpanded struct {
	// ActiveFrom The cadence start of the resource.
	ActiveFrom time.Time `json:"activeFrom"`

	// ActiveTo The cadence end of the resource.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// Alignment Alignment details enriched with the current billing period.
	Alignment *SubscriptionAlignment `json:"alignment,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency The currency code of the subscription.
	// Will be revised once we add multi currency support.
	Currency CurrencyCode `json:"currency"`

	// CustomerId The customer ID of the subscription.
	CustomerId string `json:"customerId"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Phases The phases of the subscription.
	Phases []SubscriptionPhaseExpanded `json:"phases"`

	// Plan The plan of the subscription.
	Plan *PlanReference `json:"plan,omitempty"`

	// Status The status of the subscription.
	Status SubscriptionStatus `json:"status"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SubscriptionItem The actual contents of the Subscription, what the user gets, what they pay, etc...
type SubscriptionItem struct {
	// ActiveFrom The cadence start of the resource.
	ActiveFrom time.Time `json:"activeFrom"`

	// ActiveTo The cadence end of the resource.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// BillingCadence The billing cadence of the rate card.
	// When null, the rate card is a one-time purchase.
	BillingCadence *string `json:"billingCadence"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Discounts The discounts applied to the rate card.
	Discounts *Discounts `json:"discounts,omitempty"`

	// FeatureKey The feature's key (if present).
	FeatureKey *string `json:"featureKey,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Included Describes what access is gained via the SubscriptionItem
	Included *SubscriptionItemIncluded `json:"included,omitempty"`

	// Key The identifier of the RateCard.
	// SubscriptionItem/RateCard can be identified, it has a reference:
	//
	// 1. If a Feature is associated with the SubscriptionItem, it is identified by the Feature
	// 1.1 It can be an ID reference, for an exact version of the Feature (Features can change across versions)
	// 1.2 It can be a Key reference, which always refers to the latest (active or inactive) version of a Feature
	//
	// 2. If a Feature is not associated with the SubscriptionItem, it is referenced by the Price
	//
	// We say referenced by the Price regardless of how a price itself is referenced, it colloquially makes sense to say paying the same price for the same thing. In practice this should be derived from what's printed on the invoice line-item.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Price The price of the rate card.
	// When null, the feature or service is free.
	Price *RateCardUsageBasedPrice `json:"price"`

	// TaxConfig The tax config of the Subscription Item.
	// When undefined, the tax config of the feature or the default tax config of the plan is used.
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SubscriptionItemIncluded Included contents like Entitlement, or the Feature.
type SubscriptionItemIncluded struct {
	// Entitlement The entitlement of the Subscription Item.
	Entitlement *Entitlement `json:"entitlement,omitempty"`

	// Feature The feature the customer is entitled to use.
	Feature Feature `json:"feature"`
}

// SubscriptionPaginatedResponse Paginated response
type SubscriptionPaginatedResponse struct {
	// Items The items in the current page.
	Items []Subscription `json:"items"`

	// Page The page index.
	Page int `json:"page"`

	// PageSize The maximum number of items per page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// SubscriptionPhaseCreate Subscription phase create input.
type SubscriptionPhaseCreate struct {
	// Description The description of the phase.
	Description *string `json:"description,omitempty"`

	// Discounts The discounts on the plan.
	Discounts *Discounts `json:"discounts,omitempty"`

	// Duration The intended duration of the new phase.
	// Duration is required when the phase will not be the last phase.
	Duration *string `json:"duration,omitempty"`

	// Key A locally unique identifier for the phase.
	Key string `json:"key"`

	// Name The name of the phase.
	Name string `json:"name"`

	// StartAfter Interval after the subscription starts to transition to the phase.
	// When null, the phase starts immediately after the subscription starts.
	StartAfter *string `json:"startAfter"`
}

// SubscriptionPhaseExpanded Expanded subscription phase
type SubscriptionPhaseExpanded struct {
	// ActiveFrom The time from which the phase is active.
	ActiveFrom time.Time `json:"activeFrom"`

	// ActiveTo The until which the Phase is active.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Discounts The discounts on the plan.
	Discounts *Discounts `json:"discounts,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// ItemTimelines Includes all versions of the items on each key, including all edits, scheduled changes, etc...
	ItemTimelines map[string][]SubscriptionItem `json:"itemTimelines"`

	// Items The items of the phase. The structure is flattened to better conform to the Plan API.
	// The timelines are flattened according to the following rules:
	// - for the current phase, the `items` contains only the active item for each key
	// - for past phases, the `items` contains only the last item for each key
	// - for future phases, the `items` contains only the first version of the item for each key
	Items []SubscriptionItem `json:"items"`

	// Key A locally unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SubscriptionStatus Subscription status.
type SubscriptionStatus string

// SubscriptionTiming Subscription edit timing defined when the changes should take effect.
// If the provided configuration is not supported by the subscription, an error will be returned.
type SubscriptionTiming struct {
	union json.RawMessage
}

// SubscriptionTiming1 [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
type SubscriptionTiming1 = time.Time

// SubscriptionTimingEnum Subscription edit timing.
// When immediate, the requested changes take effect immediately.
// When nextBillingCycle, the requested changes take effect at the next billing cycle.
type SubscriptionTimingEnum string

// TaxBehavior Tax behavior.
//
// This enum is used to specify whether tax is included in the price or excluded from the price.
type TaxBehavior string

// TaxConfig Set of provider specific tax configs.
type TaxConfig struct {
	// Behavior Tax behavior.
	//
	// If not specified the billing profile is used to determine the tax behavior.
	// If not specified in the billing profile, the provider's default behavior is used.
	Behavior *TaxBehavior `json:"behavior,omitempty"`

	// CustomInvoicing Custom invoicing tax config.
	CustomInvoicing *CustomInvoicingTaxConfig `json:"customInvoicing,omitempty"`

	// Stripe Stripe tax config.
	Stripe *StripeTaxConfig `json:"stripe,omitempty"`
}

// TieredPriceMode The mode of the tiered price.
type TieredPriceMode string

// TieredPriceWithCommitments Tiered price with spend commitments.
type TieredPriceWithCommitments struct {
	// MaximumAmount The customer is limited to spend at most the amount.
	MaximumAmount *Numeric `json:"maximumAmount,omitempty"`

	// MinimumAmount The customer is committed to spend at least the amount.
	MinimumAmount *Numeric `json:"minimumAmount,omitempty"`

	// Mode Defines if the tiering mode is volume-based or graduated:
	// - In `volume`-based tiering, the maximum quantity within a period determines the per unit price.
	// - In `graduated` tiering, pricing can change as the quantity grows.
	Mode TieredPriceMode `json:"mode"`

	// Tiers The tiers of the tiered price.
	// At least one price component is required in each tier.
	Tiers []PriceTier `json:"tiers"`

	// Type The type of the price.
	//
	// One of: flat, unit, or tiered.
	Type TieredPriceWithCommitmentsType `json:"type"`
}

// TieredPriceWithCommitmentsType The type of the price.
//
// One of: flat, unit, or tiered.
type TieredPriceWithCommitmentsType string

// UnauthorizedProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type UnauthorizedProblemResponse = UnexpectedProblemResponse

// UnexpectedProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type UnexpectedProblemResponse = models.StatusProblem

// UnitPrice Unit price.
type UnitPrice struct {
	// Amount The amount of the unit price.
	Amount Numeric `json:"amount"`

	// Type The type of the price.
	Type UnitPriceType `json:"type"`
}

// UnitPriceType The type of the price.
type UnitPriceType string

// UnitPriceWithCommitments Unit price with spend commitments.
type UnitPriceWithCommitments struct {
	// Amount The amount of the unit price.
	Amount Numeric `json:"amount"`

	// MaximumAmount The customer is limited to spend at most the amount.
	MaximumAmount *Numeric `json:"maximumAmount,omitempty"`

	// MinimumAmount The customer is committed to spend at least the amount.
	MinimumAmount *Numeric `json:"minimumAmount,omitempty"`

	// Type The type of the price.
	Type UnitPriceWithCommitmentsType `json:"type"`
}

// UnitPriceWithCommitmentsType The type of the price.
type UnitPriceWithCommitmentsType string

// ValidationError Validation errors providing details about compatibility issues between a plan and its add-on.
type ValidationError struct {
	// Attributes Additional attributes.
	Attributes *Annotations `json:"attributes,omitempty"`

	// Code The machine readable description of the error.
	Code string `json:"code"`

	// Field The path to the field.
	Field string `json:"field"`

	// Message The human readable description of the error.
	Message string `json:"message"`
}

// ValidationIssue ValidationIssue captures any validation issues related to the invoice.
//
// Issues with severity "critical" will prevent the invoice from being issued.
type ValidationIssue struct {
	// Code Machine indentifiable code for the issue, if available.
	Code *string `json:"code,omitempty"`

	// Component Component reporting the issue.
	Component string `json:"component"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Field The field that the issue is related to, if available in JSON path format.
	Field *string `json:"field,omitempty"`

	// Id ID of the charge or discount.
	Id string `json:"id"`

	// Message A human-readable description of the issue.
	Message string `json:"message"`

	// Metadata Additional context for the issue.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Severity The severity of the issue.
	Severity ValidationIssueSeverity `json:"severity"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// ValidationIssueSeverity ValidationIssueSeverity describes the severity of a validation issue.
//
// Issues with severity "critical" will prevent the invoice from being issued.
type ValidationIssueSeverity string

// VoidInvoiceActionCreate InvoiceVoidAction describes how to handle the voided line items.
type VoidInvoiceActionCreate struct {
	// Action The action to take on the line items.
	Action VoidInvoiceLineActionCreate `json:"action"`

	// Percentage How much of the total line items to be voided? (e.g. 100% means all charges are voided)
	Percentage Percentage `json:"percentage"`
}

// VoidInvoiceActionCreateItem InvoiceVoidAction describes how to handle the voided line items.
type VoidInvoiceActionCreateItem struct {
	// Action The action to take on the line items.
	Action VoidInvoiceLineActionCreateItem `json:"action"`

	// Percentage How much of the total line items to be voided? (e.g. 100% means all charges are voided)
	Percentage Percentage `json:"percentage"`
}

// VoidInvoiceActionInput Request to void an invoice
type VoidInvoiceActionInput struct {
	// Action The action to take on the voided line items.
	Action VoidInvoiceActionCreate `json:"action"`

	// Overrides Per line item overrides for the action.
	//
	// If not specified, the `action` will be applied to all line items.
	Overrides *[]VoidInvoiceActionLineOverride `json:"overrides"`

	// Reason The reason for voiding the invoice.
	Reason string `json:"reason"`
}

// VoidInvoiceActionLineOverride VoidInvoiceLineOverride describes how to handle a specific line item in the invoice when voiding.
type VoidInvoiceActionLineOverride struct {
	// Action The action to take on the line item.
	Action VoidInvoiceActionCreateItem `json:"action"`

	// LineId The line item ID to override.
	LineId string `json:"lineId"`
}

// VoidInvoiceLineActionCreate VoidInvoiceLineAction describes how to handle a specific line item in the invoice when voiding.
type VoidInvoiceLineActionCreate struct {
	union json.RawMessage
}

// VoidInvoiceLineActionCreateItem VoidInvoiceLineAction describes how to handle a specific line item in the invoice when voiding.
type VoidInvoiceLineActionCreateItem struct {
	union json.RawMessage
}

// VoidInvoiceLineDiscardAction VoidInvoiceLineDiscardAction describes how to handle the voidied line item in the invoice.
type VoidInvoiceLineDiscardAction struct {
	// Type The action to take on the line item.
	Type VoidInvoiceLineDiscardActionType `json:"type"`
}

// VoidInvoiceLineDiscardActionType The action to take on the line item.
type VoidInvoiceLineDiscardActionType string

// VoidInvoiceLinePendingActionCreate VoidInvoiceLinePendingAction describes how to handle the voidied line item in the invoice.
type VoidInvoiceLinePendingActionCreate struct {
	// NextInvoiceAt The time at which the line item should be invoiced again.
	//
	// If not provided, the line item will be re-invoiced now.
	NextInvoiceAt *time.Time `json:"nextInvoiceAt,omitempty"`

	// Type The action to take on the line item.
	Type VoidInvoiceLinePendingActionCreateType `json:"type"`
}

// VoidInvoiceLinePendingActionCreateType The action to take on the line item.
type VoidInvoiceLinePendingActionCreateType string

// VoidInvoiceLinePendingActionCreateItem VoidInvoiceLinePendingAction describes how to handle the voidied line item in the invoice.
type VoidInvoiceLinePendingActionCreateItem struct {
	// NextInvoiceAt The time at which the line item should be invoiced again.
	//
	// If not provided, the line item will be re-invoiced now.
	NextInvoiceAt *time.Time `json:"nextInvoiceAt,omitempty"`

	// Type The action to take on the line item.
	Type VoidInvoiceLinePendingActionCreateItemType `json:"type"`
}

// VoidInvoiceLinePendingActionCreateItemType The action to take on the line item.
type VoidInvoiceLinePendingActionCreateItemType string

// WindowSize Aggregation window size.
type WindowSize string

// WindowedBalanceHistory The windowed balance history.
type WindowedBalanceHistory struct {
	// BurndownHistory Grant burndown history.
	BurndownHistory []GrantBurnDownHistorySegment `json:"burndownHistory"`

	// WindowedHistory The windowed balance history.
	// - It only returns rows for windows where there was usage.
	// - The windows are inclusive at their start and exclusive at their end.
	// - The last window may be smaller than the window size and is inclusive at both ends.
	WindowedHistory []BalanceHistoryWindow `json:"windowedHistory"`
}

// AddonOrderByOrderingOrder The order direction.
type AddonOrderByOrderingOrder = SortOrder

// AddonOrderByOrderingOrderBy Order by options for add-ons.
type AddonOrderByOrderingOrderBy = AddonOrderBy

// BillingProfileCustomerOverrideOrderByOrderingOrder The order direction.
type BillingProfileCustomerOverrideOrderByOrderingOrder = SortOrder

// BillingProfileCustomerOverrideOrderByOrderingOrderBy Order by options for customers.
type BillingProfileCustomerOverrideOrderByOrderingOrderBy = BillingProfileCustomerOverrideOrderBy

// BillingProfileListCustomerOverridesParamsBillingProfile defines model for BillingProfileListCustomerOverridesParams.billingProfile.
type BillingProfileListCustomerOverridesParamsBillingProfile = []string

// BillingProfileListCustomerOverridesParamsCustomerId defines model for BillingProfileListCustomerOverridesParams.customerId.
type BillingProfileListCustomerOverridesParamsCustomerId = []string

// BillingProfileListCustomerOverridesParamsCustomerKey defines model for BillingProfileListCustomerOverridesParams.customerKey.
type BillingProfileListCustomerOverridesParamsCustomerKey = string

// BillingProfileListCustomerOverridesParamsCustomerName defines model for BillingProfileListCustomerOverridesParams.customerName.
type BillingProfileListCustomerOverridesParamsCustomerName = string

// BillingProfileListCustomerOverridesParamsCustomerPrimaryEmail defines model for BillingProfileListCustomerOverridesParams.customerPrimaryEmail.
type BillingProfileListCustomerOverridesParamsCustomerPrimaryEmail = string

// BillingProfileListCustomerOverridesParamsExpand defines model for BillingProfileListCustomerOverridesParams.expand.
type BillingProfileListCustomerOverridesParamsExpand = []BillingProfileCustomerOverrideExpand

// BillingProfileListCustomerOverridesParamsIncludeAllCustomers defines model for BillingProfileListCustomerOverridesParams.includeAllCustomers.
type BillingProfileListCustomerOverridesParamsIncludeAllCustomers = bool

// BillingProfileOrderByOrderingOrder The order direction.
type BillingProfileOrderByOrderingOrder = SortOrder

// BillingProfileOrderByOrderingOrderBy BillingProfileOrderBy specifies the ordering options for profiles
type BillingProfileOrderByOrderingOrderBy = BillingProfileOrderBy

// CursorPaginationCursor defines model for CursorPagination.cursor.
type CursorPaginationCursor = string

// CursorPaginationLimit defines model for CursorPagination.limit.
type CursorPaginationLimit = int

// CustomerOrderByOrderingOrder The order direction.
type CustomerOrderByOrderingOrder = SortOrder

// CustomerOrderByOrderingOrderBy Order by options for customers.
type CustomerOrderByOrderingOrderBy = CustomerOrderBy

// EntitlementOrderByOrderingOrder The order direction.
type EntitlementOrderByOrderingOrder = SortOrder

// EntitlementOrderByOrderingOrderBy Order by options for entitlements.
type EntitlementOrderByOrderingOrderBy = EntitlementOrderBy

// FeatureOrderByOrderingOrder The order direction.
type FeatureOrderByOrderingOrder = SortOrder

// FeatureOrderByOrderingOrderBy Order by options for features.
type FeatureOrderByOrderingOrderBy = FeatureOrderBy

// GrantOrderByOrderingOrder The order direction.
type GrantOrderByOrderingOrder = SortOrder

// GrantOrderByOrderingOrderBy Order by options for grants.
type GrantOrderByOrderingOrderBy = GrantOrderBy

// InvoiceListParamsCreatedAfter defines model for InvoiceListParams.createdAfter.
type InvoiceListParamsCreatedAfter = time.Time

// InvoiceListParamsCreatedBefore defines model for InvoiceListParams.createdBefore.
type InvoiceListParamsCreatedBefore = time.Time

// InvoiceListParamsCustomers defines model for InvoiceListParams.customers.
type InvoiceListParamsCustomers = []string

// InvoiceListParamsExpand defines model for InvoiceListParams.expand.
type InvoiceListParamsExpand = []InvoiceExpand

// InvoiceListParamsExtendedStatuses defines model for InvoiceListParams.extendedStatuses.
type InvoiceListParamsExtendedStatuses = []string

// InvoiceListParamsIncludeDeleted defines model for InvoiceListParams.includeDeleted.
type InvoiceListParamsIncludeDeleted = bool

// InvoiceListParamsIssuedAfter defines model for InvoiceListParams.issuedAfter.
type InvoiceListParamsIssuedAfter = time.Time

// InvoiceListParamsIssuedBefore defines model for InvoiceListParams.issuedBefore.
type InvoiceListParamsIssuedBefore = time.Time

// InvoiceListParamsPeriodStartAfter defines model for InvoiceListParams.periodStartAfter.
type InvoiceListParamsPeriodStartAfter = time.Time

// InvoiceListParamsPeriodStartBefore defines model for InvoiceListParams.periodStartBefore.
type InvoiceListParamsPeriodStartBefore = time.Time

// InvoiceListParamsStatuses defines model for InvoiceListParams.statuses.
type InvoiceListParamsStatuses = []InvoiceStatus

// InvoiceOrderByOrderingOrder The order direction.
type InvoiceOrderByOrderingOrder = SortOrder

// InvoiceOrderByOrderingOrderBy InvoiceOrderBy specifies the ordering options for invoice listing.
type InvoiceOrderByOrderingOrderBy = InvoiceOrderBy

// LimitOffsetLimit defines model for LimitOffset.limit.
type LimitOffsetLimit = int

// LimitOffsetOffset defines model for LimitOffset.offset.
type LimitOffsetOffset = int

// MarketplaceApiKeyInstallRequestType Type of the app.
type MarketplaceApiKeyInstallRequestType = AppType

// MarketplaceInstallRequestType Type of the app.
type MarketplaceInstallRequestType = AppType

// MarketplaceOAuth2InstallAuthorizeRequestType Type of the app.
type MarketplaceOAuth2InstallAuthorizeRequestType = AppType

// MeterOrderByOrderingOrder The order direction.
type MeterOrderByOrderingOrder = SortOrder

// MeterOrderByOrderingOrderBy Order by options for meters.
type MeterOrderByOrderingOrderBy = MeterOrderBy

// MeterQueryClientId defines model for MeterQuery.clientId.
type MeterQueryClientId = string

// MeterQueryFilterGroupBy defines model for MeterQuery.filterGroupBy.
type MeterQueryFilterGroupBy map[string]string

// MeterQueryFrom defines model for MeterQuery.from.
type MeterQueryFrom = time.Time

// MeterQueryGroupBy defines model for MeterQuery.groupBy.
type MeterQueryGroupBy = []string

// MeterQuerySubject defines model for MeterQuery.subject.
type MeterQuerySubject = []string

// MeterQueryTo defines model for MeterQuery.to.
type MeterQueryTo = time.Time

// MeterQueryWindowSize Aggregation window size.
type MeterQueryWindowSize = WindowSize

// MeterQueryWindowTimeZone defines model for MeterQuery.windowTimeZone.
type MeterQueryWindowTimeZone = string

// NotificationChannelOrderByOrderingOrder The order direction.
type NotificationChannelOrderByOrderingOrder = SortOrder

// NotificationChannelOrderByOrderingOrderBy Order by options for notification channels.
type NotificationChannelOrderByOrderingOrderBy = NotificationChannelOrderBy

// NotificationEventOrderByOrderingOrder The order direction.
type NotificationEventOrderByOrderingOrder = SortOrder

// NotificationEventOrderByOrderingOrderBy Order by options for notification channels.
type NotificationEventOrderByOrderingOrderBy = NotificationEventOrderBy

// NotificationRuleOrderByOrderingOrder The order direction.
type NotificationRuleOrderByOrderingOrder = SortOrder

// NotificationRuleOrderByOrderingOrderBy Order by options for notification channels.
type NotificationRuleOrderByOrderingOrderBy = NotificationRuleOrderBy

// OAuth2AuthorizationCodeGrantErrorParamsError OAuth2 authorization code grant error types.
type OAuth2AuthorizationCodeGrantErrorParamsError = OAuth2AuthorizationCodeGrantErrorType

// OAuth2AuthorizationCodeGrantErrorParamsErrorDescription defines model for OAuth2AuthorizationCodeGrantErrorParams.error_description.
type OAuth2AuthorizationCodeGrantErrorParamsErrorDescription = string

// OAuth2AuthorizationCodeGrantErrorParamsErrorUri defines model for OAuth2AuthorizationCodeGrantErrorParams.error_uri.
type OAuth2AuthorizationCodeGrantErrorParamsErrorUri = string

// OAuth2AuthorizationCodeGrantSuccessParamsCode defines model for OAuth2AuthorizationCodeGrantSuccessParams.code.
type OAuth2AuthorizationCodeGrantSuccessParamsCode = string

// OAuth2AuthorizationCodeGrantSuccessParamsState defines model for OAuth2AuthorizationCodeGrantSuccessParams.state.
type OAuth2AuthorizationCodeGrantSuccessParamsState = string

// PaginationPage defines model for Pagination.page.
type PaginationPage = int

// PaginationPageSize defines model for Pagination.pageSize.
type PaginationPageSize = int

// PlanAddonOrderByOrderingOrder The order direction.
type PlanAddonOrderByOrderingOrder = SortOrder

// PlanAddonOrderByOrderingOrderBy Order by options for plan add-on assignments.
type PlanAddonOrderByOrderingOrderBy = PlanAddonOrderBy

// PlanOrderByOrderingOrder The order direction.
type PlanOrderByOrderingOrder = SortOrder

// PlanOrderByOrderingOrderBy Order by options for plans.
type PlanOrderByOrderingOrderBy = PlanOrderBy

// QueryCustomerGet defines model for queryCustomerGet.
type QueryCustomerGet = []CustomerExpand

// QueryCustomerListExpand defines model for queryCustomerList.expand.
type QueryCustomerListExpand = []CustomerExpand

// QueryCustomerListIncludeDeleted defines model for queryCustomerList.includeDeleted.
type QueryCustomerListIncludeDeleted = bool

// QueryCustomerListKey defines model for queryCustomerList.key.
type QueryCustomerListKey = string

// QueryCustomerListName defines model for queryCustomerList.name.
type QueryCustomerListName = string

// QueryCustomerListPlanKey defines model for queryCustomerList.planKey.
type QueryCustomerListPlanKey = string

// QueryCustomerListPrimaryEmail defines model for queryCustomerList.primaryEmail.
type QueryCustomerListPrimaryEmail = string

// QueryCustomerListSubject defines model for queryCustomerList.subject.
type QueryCustomerListSubject = string

// QueryCustomerListType Type of the app.
type QueryCustomerListType = AppType

// QueryMeterListIncludeDeleted defines model for queryMeterList.includeDeleted.
type QueryMeterListIncludeDeleted = bool

// ListAddonsParams defines parameters for ListAddons.
type ListAddonsParams struct {
	// IncludeDeleted Include deleted add-ons in response.
	//
	// Usage: `?includeDeleted=true`
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Id Filter by addon.id attribute
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Key Filter by addon.key attribute
	Key *[]string `form:"key,omitempty" json:"key,omitempty"`

	// KeyVersion Filter by addon.key and addon.version attributes
	KeyVersion *map[string][]int `json:"keyVersion,omitempty"`

	// Status Only return add-ons with the given status.
	//
	// Usage:
	// - `?status=active`: return only the currently active add-ons
	// - `?status=draft`: return only the draft add-ons
	// - `?status=archived`: return only the archived add-ons
	Status *[]AddonStatus `form:"status,omitempty" json:"status,omitempty"`

	// Currency Filter by addon.currency attribute
	Currency *[]CurrencyCode `form:"currency,omitempty" json:"currency,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *AddonOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *AddonOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// GetAddonParams defines parameters for GetAddon.
type GetAddonParams struct {
	// IncludeLatest Include latest version of the add-on instead of the version in active state.
	//
	// Usage: `?includeLatest=true`
	IncludeLatest *bool `form:"includeLatest,omitempty" json:"includeLatest,omitempty"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ListBillingProfileCustomerOverridesParams defines parameters for ListBillingProfileCustomerOverrides.
type ListBillingProfileCustomerOverridesParams struct {
	// BillingProfile Filter by billing profile.
	BillingProfile *BillingProfileListCustomerOverridesParamsBillingProfile `form:"billingProfile,omitempty" json:"billingProfile,omitempty"`

	// IncludeAllCustomers Include customers without customer overrides.
	//
	// If set to false only the customers specifically associated with a billing profile will be returned.
	//
	// If set to true, in case of the default billing profile, all customers will be returned.
	IncludeAllCustomers *BillingProfileListCustomerOverridesParamsIncludeAllCustomers `form:"includeAllCustomers,omitempty" json:"includeAllCustomers,omitempty"`

	// CustomerId Filter by customer id.
	CustomerId *BillingProfileListCustomerOverridesParamsCustomerId `form:"customerId,omitempty" json:"customerId,omitempty"`

	// CustomerName Filter by customer name.
	CustomerName *BillingProfileListCustomerOverridesParamsCustomerName `form:"customerName,omitempty" json:"customerName,omitempty"`

	// CustomerKey Filter by customer key
	CustomerKey *BillingProfileListCustomerOverridesParamsCustomerKey `form:"customerKey,omitempty" json:"customerKey,omitempty"`

	// CustomerPrimaryEmail Filter by customer primary email
	CustomerPrimaryEmail *BillingProfileListCustomerOverridesParamsCustomerPrimaryEmail `form:"customerPrimaryEmail,omitempty" json:"customerPrimaryEmail,omitempty"`

	// Expand Expand the response with additional details.
	Expand *BillingProfileListCustomerOverridesParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// Order The order direction.
	Order *BillingProfileCustomerOverrideOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *BillingProfileCustomerOverrideOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// GetBillingProfileCustomerOverrideParams defines parameters for GetBillingProfileCustomerOverride.
type GetBillingProfileCustomerOverrideParams struct {
	Expand *[]BillingProfileCustomerOverrideExpand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListInvoicesParams defines parameters for ListInvoices.
type ListInvoicesParams struct {
	// Statuses Filter by the invoice status.
	Statuses *InvoiceListParamsStatuses `form:"statuses,omitempty" json:"statuses,omitempty"`

	// ExtendedStatuses Filter by invoice extended statuses
	ExtendedStatuses *InvoiceListParamsExtendedStatuses `form:"extendedStatuses,omitempty" json:"extendedStatuses,omitempty"`

	// IssuedAfter Filter by invoice issued time.
	// Inclusive.
	IssuedAfter *InvoiceListParamsIssuedAfter `form:"issuedAfter,omitempty" json:"issuedAfter,omitempty"`

	// IssuedBefore Filter by invoice issued time.
	// Inclusive.
	IssuedBefore *InvoiceListParamsIssuedBefore `form:"issuedBefore,omitempty" json:"issuedBefore,omitempty"`

	// PeriodStartAfter Filter by period start time.
	// Inclusive.
	PeriodStartAfter *InvoiceListParamsPeriodStartAfter `form:"periodStartAfter,omitempty" json:"periodStartAfter,omitempty"`

	// PeriodStartBefore Filter by period start time.
	// Inclusive.
	PeriodStartBefore *InvoiceListParamsPeriodStartBefore `form:"periodStartBefore,omitempty" json:"periodStartBefore,omitempty"`

	// CreatedAfter Filter by invoice created time.
	// Inclusive.
	CreatedAfter *InvoiceListParamsCreatedAfter `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// CreatedBefore Filter by invoice created time.
	// Inclusive.
	CreatedBefore *InvoiceListParamsCreatedBefore `form:"createdBefore,omitempty" json:"createdBefore,omitempty"`

	// Expand What parts of the list output to expand in listings
	Expand *InvoiceListParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// Customers Filter by customer ID
	Customers *InvoiceListParamsCustomers `form:"customers,omitempty" json:"customers,omitempty"`

	// IncludeDeleted Include deleted invoices
	IncludeDeleted *InvoiceListParamsIncludeDeleted `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *InvoiceOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *InvoiceOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// GetInvoiceParams defines parameters for GetInvoice.
type GetInvoiceParams struct {
	Expand              *[]InvoiceExpand `form:"expand,omitempty" json:"expand,omitempty"`
	IncludeDeletedLines *bool            `form:"includeDeletedLines,omitempty" json:"includeDeletedLines,omitempty"`
}

// ListBillingProfilesParams defines parameters for ListBillingProfiles.
type ListBillingProfilesParams struct {
	IncludeArchived *bool                   `form:"includeArchived,omitempty" json:"includeArchived,omitempty"`
	Expand          *[]BillingProfileExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *BillingProfileOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *BillingProfileOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// GetBillingProfileParams defines parameters for GetBillingProfile.
type GetBillingProfileParams struct {
	Expand *[]BillingProfileExpand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListCustomersParams defines parameters for ListCustomers.
type ListCustomersParams struct {
	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *CustomerOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *CustomerOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// IncludeDeleted Include deleted customers.
	IncludeDeleted *QueryCustomerListIncludeDeleted `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Key Filter customers by key.
	// Case-sensitive exact match.
	Key *QueryCustomerListKey `form:"key,omitempty" json:"key,omitempty"`

	// Name Filter customers by name.
	// Case-insensitive partial match.
	Name *QueryCustomerListName `form:"name,omitempty" json:"name,omitempty"`

	// PrimaryEmail Filter customers by primary email.
	// Case-insensitive partial match.
	PrimaryEmail *QueryCustomerListPrimaryEmail `form:"primaryEmail,omitempty" json:"primaryEmail,omitempty"`

	// Subject Filter customers by usage attribution subject.
	// Case-insensitive partial match.
	Subject *QueryCustomerListSubject `form:"subject,omitempty" json:"subject,omitempty"`

	// PlanKey Filter customers by the plan key of their susbcription.
	PlanKey *QueryCustomerListPlanKey `form:"planKey,omitempty" json:"planKey,omitempty"`

	// Expand What parts of the list output to expand in listings
	Expand *QueryCustomerListExpand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetCustomerParams defines parameters for GetCustomer.
type GetCustomerParams struct {
	// Expand What parts of the customer output to expand
	Expand *QueryCustomerGet `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListCustomerAppDataParams defines parameters for ListCustomerAppData.
type ListCustomerAppDataParams struct {
	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Type Filter customer data by app type.
	Type *QueryCustomerListType `form:"type,omitempty" json:"type,omitempty"`
}

// UpsertCustomerAppDataJSONBody defines parameters for UpsertCustomerAppData.
type UpsertCustomerAppDataJSONBody = []CustomerAppDataCreateOrUpdateItem

// GetCustomerEntitlementValueParams defines parameters for GetCustomerEntitlementValue.
type GetCustomerEntitlementValueParams struct {
	Time *time.Time `form:"time,omitempty" json:"time,omitempty"`
}

// ListCustomerSubscriptionsParams defines parameters for ListCustomerSubscriptions.
type ListCustomerSubscriptionsParams struct {
	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ListEntitlementsParams defines parameters for ListEntitlements.
type ListEntitlementsParams struct {
	// Feature Filtering by multiple features.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Subject Filtering by multiple subjects.
	//
	// Usage: `?subject=customer-1&subject=customer-2`
	Subject *[]string `form:"subject,omitempty" json:"subject,omitempty"`

	// EntitlementType Filtering by multiple entitlement types.
	//
	// Usage: `?entitlementType=metered&entitlementType=boolean`
	EntitlementType *[]EntitlementType `form:"entitlementType,omitempty" json:"entitlementType,omitempty"`

	// ExcludeInactive Exclude inactive entitlements in the response (those scheduled for later or earlier)
	ExcludeInactive *bool `form:"excludeInactive,omitempty" json:"excludeInactive,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *EntitlementOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *EntitlementOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListEventsParams defines parameters for ListEvents.
type ListEventsParams struct {
	// ClientId Client ID
	// Useful to track progress of a query.
	ClientId *string `form:"clientId,omitempty" json:"clientId,omitempty"`

	// IngestedAtFrom Start date-time in RFC 3339 format.
	//
	// Inclusive.
	IngestedAtFrom *time.Time `form:"ingestedAtFrom,omitempty" json:"ingestedAtFrom,omitempty"`

	// IngestedAtTo End date-time in RFC 3339 format.
	//
	// Inclusive.
	IngestedAtTo *time.Time `form:"ingestedAtTo,omitempty" json:"ingestedAtTo,omitempty"`

	// Id The event ID.
	//
	// Accepts partial ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Subject The event subject.
	//
	// Accepts partial subject.
	Subject *string `form:"subject,omitempty" json:"subject,omitempty"`

	// From Start date-time in RFC 3339 format.
	//
	// Inclusive.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	//
	// Inclusive.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Limit Number of events to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// IngestEventsApplicationCloudeventsBatchPlusJSONBody defines parameters for IngestEvents.
type IngestEventsApplicationCloudeventsBatchPlusJSONBody = []Event

// ListFeaturesParams defines parameters for ListFeatures.
type ListFeaturesParams struct {
	// MeterSlug Filter by meterSlug
	MeterSlug *[]string `form:"meterSlug,omitempty" json:"meterSlug,omitempty"`

	// IncludeArchived Filter by meterGroupByFilters
	IncludeArchived *bool `form:"includeArchived,omitempty" json:"includeArchived,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *FeatureOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *FeatureOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListGrantsParams defines parameters for ListGrants.
type ListGrantsParams struct {
	// Feature Filtering by multiple features.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Subject Filtering by multiple subjects.
	//
	// Usage: `?subject=customer-1&subject=customer-2`
	Subject *[]string `form:"subject,omitempty" json:"subject,omitempty"`

	// IncludeDeleted Include deleted
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *GrantOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *GrantOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListMarketplaceListingsParams defines parameters for ListMarketplaceListings.
type ListMarketplaceListingsParams struct {
	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// MarketplaceAppInstallJSONBody defines parameters for MarketplaceAppInstall.
type MarketplaceAppInstallJSONBody struct {
	// Name Name of the application to install.
	//
	// If not set defaults to the marketplace item's description.
	Name *string `json:"name,omitempty"`
}

// MarketplaceAppAPIKeyInstallJSONBody defines parameters for MarketplaceAppAPIKeyInstall.
type MarketplaceAppAPIKeyInstallJSONBody struct {
	// ApiKey The API key for the provider.
	// For example, the Stripe API key.
	ApiKey string `json:"apiKey"`

	// Name Name of the application to install.
	//
	// If not set defaults to the marketplace item's description.
	Name *string `json:"name,omitempty"`
}

// MarketplaceOAuth2InstallAuthorizeParams defines parameters for MarketplaceOAuth2InstallAuthorize.
type MarketplaceOAuth2InstallAuthorizeParams struct {
	// State Required if the "state" parameter was present in the client authorization request.
	// The exact value received from the client:
	//
	// Unique, randomly generated, opaque, and non-guessable string that is sent
	// when starting an authentication request and validated when processing the response.
	State *OAuth2AuthorizationCodeGrantSuccessParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Code Authorization code which the client will later exchange for an access token.
	// Required with the success response.
	Code *OAuth2AuthorizationCodeGrantSuccessParamsCode `form:"code,omitempty" json:"code,omitempty"`

	// Error Error code.
	// Required with the error response.
	Error *OAuth2AuthorizationCodeGrantErrorParamsError `form:"error,omitempty" json:"error,omitempty"`

	// ErrorDescription Optional human-readable text providing additional information,
	// used to assist the client developer in understanding the error that occurred.
	ErrorDescription *OAuth2AuthorizationCodeGrantErrorParamsErrorDescription `form:"error_description,omitempty" json:"error_description,omitempty"`

	// ErrorUri Optional uri identifying a human-readable web page with
	// information about the error, used to provide the client
	// developer with additional information about the error
	ErrorUri *OAuth2AuthorizationCodeGrantErrorParamsErrorUri `form:"error_uri,omitempty" json:"error_uri,omitempty"`
}

// ListMetersParams defines parameters for ListMeters.
type ListMetersParams struct {
	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *MeterOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *MeterOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// IncludeDeleted Include deleted meters.
	IncludeDeleted *QueryMeterListIncludeDeleted `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`
}

// QueryMeterParams defines parameters for QueryMeter.
type QueryMeterParams struct {
	// ClientId Client ID
	// Useful to track progress of a query.
	ClientId *MeterQueryClientId `form:"clientId,omitempty" json:"clientId,omitempty"`

	// From Start date-time in RFC 3339 format.
	//
	// Inclusive.
	//
	// For example: ?from=2025-01-01T00%3A00%3A00.000Z
	From *MeterQueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	//
	// Inclusive.
	//
	// For example: ?to=2025-02-01T00%3A00%3A00.000Z
	To *MeterQueryTo `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.
	//
	// For example: ?windowSize=DAY
	WindowSize *MeterQueryWindowSize `form:"windowSize,omitempty" json:"windowSize,omitempty"`

	// WindowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
	// If not specified, the UTC timezone will be used.
	//
	// For example: ?windowTimeZone=UTC
	WindowTimeZone *MeterQueryWindowTimeZone `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`

	// Subject Filtering by multiple subjects.
	//
	// For example: ?subject=customer-1&subject=customer-2
	Subject *MeterQuerySubject `form:"subject,omitempty" json:"subject,omitempty"`

	// FilterGroupBy Simple filter for group bys with exact match.
	//
	// For example: ?filterGroupBy[vendor]=openai&filterGroupBy[model]=gpt-4-turbo
	FilterGroupBy *MeterQueryFilterGroupBy `json:"filterGroupBy,omitempty"`

	// GroupBy If not specified a single aggregate will be returned for each subject and time window.
	// `subject` is a reserved group by value.
	//
	// For example: ?groupBy=subject&groupBy=model
	GroupBy *MeterQueryGroupBy `form:"groupBy,omitempty" json:"groupBy,omitempty"`
}

// ListNotificationChannelsParams defines parameters for ListNotificationChannels.
type ListNotificationChannelsParams struct {
	// IncludeDeleted Include deleted notification channels in response.
	//
	// Usage: `?includeDeleted=true`
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// IncludeDisabled Include disabled notification channels in response.
	//
	// Usage: `?includeDisabled=false`
	IncludeDisabled *bool `form:"includeDisabled,omitempty" json:"includeDisabled,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *NotificationChannelOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *NotificationChannelOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListNotificationEventsParams defines parameters for ListNotificationEvents.
type ListNotificationEventsParams struct {
	// From Start date-time in RFC 3339 format.
	// Inclusive.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	// Inclusive.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Feature Filtering by multiple feature ids or keys.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Subject Filtering by multiple subject ids or keys.
	//
	// Usage: `?subject=subject-1&subject=subject-2`
	Subject *[]string `form:"subject,omitempty" json:"subject,omitempty"`

	// Rule Filtering by multiple rule ids.
	//
	// Usage: `?rule=01J8J2XYZ2N5WBYK09EDZFBSZM&rule=01J8J4R4VZH180KRKQ63NB2VA5`
	Rule *[]string `form:"rule,omitempty" json:"rule,omitempty"`

	// Channel Filtering by multiple channel ids.
	//
	// Usage: `?channel=01J8J4RXH778XB056JS088PCYT&channel=01J8J4S1R1G9EVN62RG23A9M6J`
	Channel *[]string `form:"channel,omitempty" json:"channel,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *NotificationEventOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *NotificationEventOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListNotificationRulesParams defines parameters for ListNotificationRules.
type ListNotificationRulesParams struct {
	// IncludeDeleted Include deleted notification rules in response.
	//
	// Usage: `?includeDeleted=true`
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// IncludeDisabled Include disabled notification rules in response.
	//
	// Usage: `?includeDisabled=false`
	IncludeDisabled *bool `form:"includeDisabled,omitempty" json:"includeDisabled,omitempty"`

	// Feature Filtering by multiple feature ids/keys.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Channel Filtering by multiple notifiaction channel ids.
	//
	// Usage: `?channel=01ARZ3NDEKTSV4RRFFQ69G5FAV&channel=01J8J2Y5X4NNGQS32CF81W95E3`
	Channel *[]string `form:"channel,omitempty" json:"channel,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *NotificationRuleOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *NotificationRuleOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListPlansParams defines parameters for ListPlans.
type ListPlansParams struct {
	// IncludeDeleted Include deleted plans in response.
	//
	// Usage: `?includeDeleted=true`
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Id Filter by plan.id attribute
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Key Filter by plan.key attribute
	Key *[]string `form:"key,omitempty" json:"key,omitempty"`

	// KeyVersion Filter by plan.key and plan.version attributes
	KeyVersion *map[string][]int `json:"keyVersion,omitempty"`

	// Status Only return plans with the given status.
	//
	// Usage:
	// - `?status=active`: return only the currently active plan
	// - `?status=draft`: return only the draft plan
	// - `?status=archived`: return only the archived plans
	Status *[]PlanStatus `form:"status,omitempty" json:"status,omitempty"`

	// Currency Filter by plan.currency attribute
	Currency *[]CurrencyCode `form:"currency,omitempty" json:"currency,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *PlanOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *PlanOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// GetPlanParams defines parameters for GetPlan.
type GetPlanParams struct {
	// IncludeLatest Include latest version of the Plan instead of the version in active state.
	//
	// Usage: `?includeLatest=true`
	IncludeLatest *bool `form:"includeLatest,omitempty" json:"includeLatest,omitempty"`
}

// ListPlanAddonsParams defines parameters for ListPlanAddons.
type ListPlanAddonsParams struct {
	// IncludeDeleted Include deleted plan add-on assignments.
	//
	// Usage: `?includeDeleted=true`
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Id Filter by addon.id attribute.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Key Filter by addon.key attribute.
	Key *[]string `form:"key,omitempty" json:"key,omitempty"`

	// KeyVersion Filter by addon.key and addon.version attributes.
	KeyVersion *map[string][]int `json:"keyVersion,omitempty"`

	// Page Page index.
	//
	// Default is 1.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The maximum number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *PlanAddonOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *PlanAddonOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// QueryPortalMeterParams defines parameters for QueryPortalMeter.
type QueryPortalMeterParams struct {
	// ClientId Client ID
	// Useful to track progress of a query.
	ClientId *MeterQueryClientId `form:"clientId,omitempty" json:"clientId,omitempty"`

	// From Start date-time in RFC 3339 format.
	//
	// Inclusive.
	//
	// For example: ?from=2025-01-01T00%3A00%3A00.000Z
	From *MeterQueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	//
	// Inclusive.
	//
	// For example: ?to=2025-02-01T00%3A00%3A00.000Z
	To *MeterQueryTo `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.
	//
	// For example: ?windowSize=DAY
	WindowSize *MeterQueryWindowSize `form:"windowSize,omitempty" json:"windowSize,omitempty"`

	// WindowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
	// If not specified, the UTC timezone will be used.
	//
	// For example: ?windowTimeZone=UTC
	WindowTimeZone *MeterQueryWindowTimeZone `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`

	// FilterGroupBy Simple filter for group bys with exact match.
	//
	// For example: ?filterGroupBy[vendor]=openai&filterGroupBy[model]=gpt-4-turbo
	FilterGroupBy *MeterQueryFilterGroupBy `json:"filterGroupBy,omitempty"`

	// GroupBy If not specified a single aggregate will be returned for each subject and time window.
	// `subject` is a reserved group by value.
	//
	// For example: ?groupBy=subject&groupBy=model
	GroupBy *MeterQueryGroupBy `form:"groupBy,omitempty" json:"groupBy,omitempty"`
}

// ListPortalTokensParams defines parameters for ListPortalTokens.
type ListPortalTokensParams struct {
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// InvalidatePortalTokensJSONBody defines parameters for InvalidatePortalTokens.
type InvalidatePortalTokensJSONBody struct {
	// Id Invalidate a portal token by ID.
	Id *string `json:"id,omitempty"`

	// Subject Invalidate all portal tokens for a subject.
	Subject *string `json:"subject,omitempty"`
}

// UpsertSubjectJSONBody defines parameters for UpsertSubject.
type UpsertSubjectJSONBody = []SubjectUpsert

// ListSubjectEntitlementsParams defines parameters for ListSubjectEntitlements.
type ListSubjectEntitlementsParams struct {
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`
}

// ListEntitlementGrantsParams defines parameters for ListEntitlementGrants.
type ListEntitlementGrantsParams struct {
	IncludeDeleted *bool         `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`
	OrderBy        *GrantOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// GetEntitlementValueParams defines parameters for GetEntitlementValue.
type GetEntitlementValueParams struct {
	Time *time.Time `form:"time,omitempty" json:"time,omitempty"`
}

// GetEntitlementHistoryParams defines parameters for GetEntitlementHistory.
type GetEntitlementHistoryParams struct {
	// From Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to the last reset. Gets truncated to the granularity of the underlying meter.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.
	// If not now then gets truncated to the granularity of the underlying meter.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize Windowsize
	WindowSize WindowSize `form:"windowSize" json:"windowSize"`

	// WindowTimeZone The timezone used when calculating the windows.
	WindowTimeZone *string `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`
}

// GetSubscriptionParams defines parameters for GetSubscription.
type GetSubscriptionParams struct {
	// At The time at which the subscription should be queried. If not provided the current time is used.
	At *time.Time `form:"at,omitempty" json:"at,omitempty"`
}

// CancelSubscriptionJSONBody defines parameters for CancelSubscription.
type CancelSubscriptionJSONBody struct {
	// Timing If not provided the subscription is canceled immediately.
	Timing *SubscriptionTiming `json:"timing,omitempty"`
}

// MigrateSubscriptionJSONBody defines parameters for MigrateSubscription.
type MigrateSubscriptionJSONBody struct {
	// StartingPhase The key of the phase to start the subscription in.
	// If not provided, the subscription will start in the first phase of the plan.
	StartingPhase *string `json:"startingPhase,omitempty"`

	// TargetVersion The version of the plan to migrate to.
	// If not provided, the subscription will migrate to the latest version of the current plan.
	TargetVersion *int `json:"targetVersion,omitempty"`
}

// ListEventsV2Params defines parameters for ListEventsV2.
type ListEventsV2Params struct {
	// Cursor The cursor after which to start the pagination.
	Cursor *CursorPaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The limit of the pagination.
	Limit *CursorPaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// ClientId Client ID
	// Useful to track progress of a query.
	ClientId *string `form:"clientId,omitempty" json:"clientId,omitempty"`

	// Filter The filter for the events encoded as JSON string.
	Filter *struct {
		// Id A filter for a string field.
		Id *FilterString `json:"id,omitempty"`

		// IngestedAt A filter for a time field.
		IngestedAt *FilterTime `json:"ingestedAt,omitempty"`

		// Source A filter for a string field.
		Source *FilterString `json:"source,omitempty"`

		// Subject A filter for a string field.
		Subject *FilterString `json:"subject,omitempty"`

		// Time A filter for a time field.
		Time *FilterTime `json:"time,omitempty"`

		// Type A filter for a string field.
		Type *FilterString `json:"type,omitempty"`
	} `form:"filter,omitempty" json:"filter,omitempty"`
}

// CreateAddonJSONRequestBody defines body for CreateAddon for application/json ContentType.
type CreateAddonJSONRequestBody = AddonCreate

// UpdateAddonJSONRequestBody defines body for UpdateAddon for application/json ContentType.
type UpdateAddonJSONRequestBody = AddonReplaceUpdate

// AppCustomInvoicingDraftSynchronizedJSONRequestBody defines body for AppCustomInvoicingDraftSynchronized for application/json ContentType.
type AppCustomInvoicingDraftSynchronizedJSONRequestBody = CustomInvoicingDraftSynchronizedRequest

// AppCustomInvoicingIssuingSynchronizedJSONRequestBody defines body for AppCustomInvoicingIssuingSynchronized for application/json ContentType.
type AppCustomInvoicingIssuingSynchronizedJSONRequestBody = CustomInvoicingFinalizedRequest

// AppCustomInvoicingUpdatePaymentStatusJSONRequestBody defines body for AppCustomInvoicingUpdatePaymentStatus for application/json ContentType.
type AppCustomInvoicingUpdatePaymentStatusJSONRequestBody = CustomInvoicingUpdatePaymentStatusRequest

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody = AppReplaceUpdate

// UpdateStripeAPIKeyJSONRequestBody defines body for UpdateStripeAPIKey for application/json ContentType.
type UpdateStripeAPIKeyJSONRequestBody = StripeAPIKeyInput

// AppStripeWebhookJSONRequestBody defines body for AppStripeWebhook for application/json ContentType.
type AppStripeWebhookJSONRequestBody = StripeWebhookEvent

// UpsertBillingProfileCustomerOverrideJSONRequestBody defines body for UpsertBillingProfileCustomerOverride for application/json ContentType.
type UpsertBillingProfileCustomerOverrideJSONRequestBody = BillingProfileCustomerOverrideCreate

// CreatePendingInvoiceLineJSONRequestBody defines body for CreatePendingInvoiceLine for application/json ContentType.
type CreatePendingInvoiceLineJSONRequestBody = InvoicePendingLineCreateInput

// SimulateInvoiceJSONRequestBody defines body for SimulateInvoice for application/json ContentType.
type SimulateInvoiceJSONRequestBody = InvoiceSimulationInput

// InvoicePendingLinesActionJSONRequestBody defines body for InvoicePendingLinesAction for application/json ContentType.
type InvoicePendingLinesActionJSONRequestBody = InvoicePendingLinesActionInput

// UpdateInvoiceJSONRequestBody defines body for UpdateInvoice for application/json ContentType.
type UpdateInvoiceJSONRequestBody = InvoiceReplaceUpdate

// VoidInvoiceActionJSONRequestBody defines body for VoidInvoiceAction for application/json ContentType.
type VoidInvoiceActionJSONRequestBody = VoidInvoiceActionInput

// CreateBillingProfileJSONRequestBody defines body for CreateBillingProfile for application/json ContentType.
type CreateBillingProfileJSONRequestBody = BillingProfileCreate

// UpdateBillingProfileJSONRequestBody defines body for UpdateBillingProfile for application/json ContentType.
type UpdateBillingProfileJSONRequestBody = BillingProfileReplaceUpdateWithWorkflow

// CreateCustomerJSONRequestBody defines body for CreateCustomer for application/json ContentType.
type CreateCustomerJSONRequestBody = CustomerCreate

// UpdateCustomerJSONRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody = CustomerReplaceUpdate

// UpsertCustomerAppDataJSONRequestBody defines body for UpsertCustomerAppData for application/json ContentType.
type UpsertCustomerAppDataJSONRequestBody = UpsertCustomerAppDataJSONBody

// IngestEventsApplicationCloudeventsPlusJSONRequestBody defines body for IngestEvents for application/cloudevents+json ContentType.
type IngestEventsApplicationCloudeventsPlusJSONRequestBody = Event

// IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody defines body for IngestEvents for application/cloudevents-batch+json ContentType.
type IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody = IngestEventsApplicationCloudeventsBatchPlusJSONBody

// IngestEventsJSONRequestBody defines body for IngestEvents for application/json ContentType.
type IngestEventsJSONRequestBody = IngestEventsBody

// CreateFeatureJSONRequestBody defines body for CreateFeature for application/json ContentType.
type CreateFeatureJSONRequestBody = FeatureCreateInputs

// MarketplaceAppInstallJSONRequestBody defines body for MarketplaceAppInstall for application/json ContentType.
type MarketplaceAppInstallJSONRequestBody MarketplaceAppInstallJSONBody

// MarketplaceAppAPIKeyInstallJSONRequestBody defines body for MarketplaceAppAPIKeyInstall for application/json ContentType.
type MarketplaceAppAPIKeyInstallJSONRequestBody MarketplaceAppAPIKeyInstallJSONBody

// CreateMeterJSONRequestBody defines body for CreateMeter for application/json ContentType.
type CreateMeterJSONRequestBody = MeterCreate

// UpdateMeterJSONRequestBody defines body for UpdateMeter for application/json ContentType.
type UpdateMeterJSONRequestBody = MeterUpdate

// QueryMeterPostJSONRequestBody defines body for QueryMeterPost for application/json ContentType.
type QueryMeterPostJSONRequestBody = MeterQueryRequest

// CreateNotificationChannelJSONRequestBody defines body for CreateNotificationChannel for application/json ContentType.
type CreateNotificationChannelJSONRequestBody = NotificationChannelCreateRequest

// UpdateNotificationChannelJSONRequestBody defines body for UpdateNotificationChannel for application/json ContentType.
type UpdateNotificationChannelJSONRequestBody = NotificationChannelCreateRequest

// CreateNotificationRuleJSONRequestBody defines body for CreateNotificationRule for application/json ContentType.
type CreateNotificationRuleJSONRequestBody = NotificationRuleCreateRequest

// UpdateNotificationRuleJSONRequestBody defines body for UpdateNotificationRule for application/json ContentType.
type UpdateNotificationRuleJSONRequestBody = NotificationRuleCreateRequest

// CreatePlanJSONRequestBody defines body for CreatePlan for application/json ContentType.
type CreatePlanJSONRequestBody = PlanCreate

// UpdatePlanJSONRequestBody defines body for UpdatePlan for application/json ContentType.
type UpdatePlanJSONRequestBody = PlanReplaceUpdate

// CreatePlanAddonJSONRequestBody defines body for CreatePlanAddon for application/json ContentType.
type CreatePlanAddonJSONRequestBody = PlanAddonCreate

// UpdatePlanAddonJSONRequestBody defines body for UpdatePlanAddon for application/json ContentType.
type UpdatePlanAddonJSONRequestBody = PlanAddonReplaceUpdate

// CreatePortalTokenJSONRequestBody defines body for CreatePortalToken for application/json ContentType.
type CreatePortalTokenJSONRequestBody = PortalToken

// InvalidatePortalTokensJSONRequestBody defines body for InvalidatePortalTokens for application/json ContentType.
type InvalidatePortalTokensJSONRequestBody InvalidatePortalTokensJSONBody

// CreateStripeCheckoutSessionJSONRequestBody defines body for CreateStripeCheckoutSession for application/json ContentType.
type CreateStripeCheckoutSessionJSONRequestBody = CreateStripeCheckoutSessionRequest

// UpsertSubjectJSONRequestBody defines body for UpsertSubject for application/json ContentType.
type UpsertSubjectJSONRequestBody = UpsertSubjectJSONBody

// CreateEntitlementJSONRequestBody defines body for CreateEntitlement for application/json ContentType.
type CreateEntitlementJSONRequestBody = EntitlementCreateInputs

// CreateGrantJSONRequestBody defines body for CreateGrant for application/json ContentType.
type CreateGrantJSONRequestBody = EntitlementGrantCreateInput

// OverrideEntitlementJSONRequestBody defines body for OverrideEntitlement for application/json ContentType.
type OverrideEntitlementJSONRequestBody = EntitlementCreateInputs

// ResetEntitlementUsageJSONRequestBody defines body for ResetEntitlementUsage for application/json ContentType.
type ResetEntitlementUsageJSONRequestBody = ResetEntitlementUsageInput

// CreateSubscriptionJSONRequestBody defines body for CreateSubscription for application/json ContentType.
type CreateSubscriptionJSONRequestBody = SubscriptionCreate

// EditSubscriptionJSONRequestBody defines body for EditSubscription for application/json ContentType.
type EditSubscriptionJSONRequestBody = SubscriptionEdit

// CreateSubscriptionAddonJSONRequestBody defines body for CreateSubscriptionAddon for application/json ContentType.
type CreateSubscriptionAddonJSONRequestBody = SubscriptionAddonCreate

// UpdateSubscriptionAddonJSONRequestBody defines body for UpdateSubscriptionAddon for application/json ContentType.
type UpdateSubscriptionAddonJSONRequestBody = SubscriptionAddonUpdate

// CancelSubscriptionJSONRequestBody defines body for CancelSubscription for application/json ContentType.
type CancelSubscriptionJSONRequestBody CancelSubscriptionJSONBody

// ChangeSubscriptionJSONRequestBody defines body for ChangeSubscription for application/json ContentType.
type ChangeSubscriptionJSONRequestBody = SubscriptionChange

// MigrateSubscriptionJSONRequestBody defines body for MigrateSubscription for application/json ContentType.
type MigrateSubscriptionJSONRequestBody MigrateSubscriptionJSONBody

// AsStripeApp returns the union data inside the App as a StripeApp
func (t App) AsStripeApp() (StripeApp, error) {
	var body StripeApp
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStripeApp overwrites any union data inside the App as the provided StripeApp
func (t *App) FromStripeApp(v StripeApp) error {
	v.Type = "stripe"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStripeApp performs a merge with any union data inside the App, using the provided StripeApp
func (t *App) MergeStripeApp(v StripeApp) error {
	v.Type = "stripe"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxApp returns the union data inside the App as a SandboxApp
func (t App) AsSandboxApp() (SandboxApp, error) {
	var body SandboxApp
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxApp overwrites any union data inside the App as the provided SandboxApp
func (t *App) FromSandboxApp(v SandboxApp) error {
	v.Type = "sandbox"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxApp performs a merge with any union data inside the App, using the provided SandboxApp
func (t *App) MergeSandboxApp(v SandboxApp) error {
	v.Type = "sandbox"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomInvoicingApp returns the union data inside the App as a CustomInvoicingApp
func (t App) AsCustomInvoicingApp() (CustomInvoicingApp, error) {
	var body CustomInvoicingApp
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomInvoicingApp overwrites any union data inside the App as the provided CustomInvoicingApp
func (t *App) FromCustomInvoicingApp(v CustomInvoicingApp) error {
	v.Type = "custom_invoicing"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomInvoicingApp performs a merge with any union data inside the App, using the provided CustomInvoicingApp
func (t *App) MergeCustomInvoicingApp(v CustomInvoicingApp) error {
	v.Type = "custom_invoicing"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t App) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t App) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "custom_invoicing":
		return t.AsCustomInvoicingApp()
	case "sandbox":
		return t.AsSandboxApp()
	case "stripe":
		return t.AsStripeApp()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t App) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *App) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStripeAppReplaceUpdate returns the union data inside the AppReplaceUpdate as a StripeAppReplaceUpdate
func (t AppReplaceUpdate) AsStripeAppReplaceUpdate() (StripeAppReplaceUpdate, error) {
	var body StripeAppReplaceUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStripeAppReplaceUpdate overwrites any union data inside the AppReplaceUpdate as the provided StripeAppReplaceUpdate
func (t *AppReplaceUpdate) FromStripeAppReplaceUpdate(v StripeAppReplaceUpdate) error {
	v.Type = "stripe"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStripeAppReplaceUpdate performs a merge with any union data inside the AppReplaceUpdate, using the provided StripeAppReplaceUpdate
func (t *AppReplaceUpdate) MergeStripeAppReplaceUpdate(v StripeAppReplaceUpdate) error {
	v.Type = "stripe"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxAppReplaceUpdate returns the union data inside the AppReplaceUpdate as a SandboxAppReplaceUpdate
func (t AppReplaceUpdate) AsSandboxAppReplaceUpdate() (SandboxAppReplaceUpdate, error) {
	var body SandboxAppReplaceUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxAppReplaceUpdate overwrites any union data inside the AppReplaceUpdate as the provided SandboxAppReplaceUpdate
func (t *AppReplaceUpdate) FromSandboxAppReplaceUpdate(v SandboxAppReplaceUpdate) error {
	v.Type = "sandbox"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxAppReplaceUpdate performs a merge with any union data inside the AppReplaceUpdate, using the provided SandboxAppReplaceUpdate
func (t *AppReplaceUpdate) MergeSandboxAppReplaceUpdate(v SandboxAppReplaceUpdate) error {
	v.Type = "sandbox"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomInvoicingAppReplaceUpdate returns the union data inside the AppReplaceUpdate as a CustomInvoicingAppReplaceUpdate
func (t AppReplaceUpdate) AsCustomInvoicingAppReplaceUpdate() (CustomInvoicingAppReplaceUpdate, error) {
	var body CustomInvoicingAppReplaceUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomInvoicingAppReplaceUpdate overwrites any union data inside the AppReplaceUpdate as the provided CustomInvoicingAppReplaceUpdate
func (t *AppReplaceUpdate) FromCustomInvoicingAppReplaceUpdate(v CustomInvoicingAppReplaceUpdate) error {
	v.Type = "custom_invoicing"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomInvoicingAppReplaceUpdate performs a merge with any union data inside the AppReplaceUpdate, using the provided CustomInvoicingAppReplaceUpdate
func (t *AppReplaceUpdate) MergeCustomInvoicingAppReplaceUpdate(v CustomInvoicingAppReplaceUpdate) error {
	v.Type = "custom_invoicing"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppReplaceUpdate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppReplaceUpdate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "custom_invoicing":
		return t.AsCustomInvoicingAppReplaceUpdate()
	case "sandbox":
		return t.AsSandboxAppReplaceUpdate()
	case "stripe":
		return t.AsStripeAppReplaceUpdate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppReplaceUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AppReplaceUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDiscountReasonMaximumSpend returns the union data inside the BillingDiscountReason as a DiscountReasonMaximumSpend
func (t BillingDiscountReason) AsDiscountReasonMaximumSpend() (DiscountReasonMaximumSpend, error) {
	var body DiscountReasonMaximumSpend
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountReasonMaximumSpend overwrites any union data inside the BillingDiscountReason as the provided DiscountReasonMaximumSpend
func (t *BillingDiscountReason) FromDiscountReasonMaximumSpend(v DiscountReasonMaximumSpend) error {
	v.Type = "maximum_spend"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountReasonMaximumSpend performs a merge with any union data inside the BillingDiscountReason, using the provided DiscountReasonMaximumSpend
func (t *BillingDiscountReason) MergeDiscountReasonMaximumSpend(v DiscountReasonMaximumSpend) error {
	v.Type = "maximum_spend"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDiscountReasonRatecardPercentage returns the union data inside the BillingDiscountReason as a DiscountReasonRatecardPercentage
func (t BillingDiscountReason) AsDiscountReasonRatecardPercentage() (DiscountReasonRatecardPercentage, error) {
	var body DiscountReasonRatecardPercentage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountReasonRatecardPercentage overwrites any union data inside the BillingDiscountReason as the provided DiscountReasonRatecardPercentage
func (t *BillingDiscountReason) FromDiscountReasonRatecardPercentage(v DiscountReasonRatecardPercentage) error {
	v.Type = "ratecard_percentage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountReasonRatecardPercentage performs a merge with any union data inside the BillingDiscountReason, using the provided DiscountReasonRatecardPercentage
func (t *BillingDiscountReason) MergeDiscountReasonRatecardPercentage(v DiscountReasonRatecardPercentage) error {
	v.Type = "ratecard_percentage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDiscountReasonRatecardUsage returns the union data inside the BillingDiscountReason as a DiscountReasonRatecardUsage
func (t BillingDiscountReason) AsDiscountReasonRatecardUsage() (DiscountReasonRatecardUsage, error) {
	var body DiscountReasonRatecardUsage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountReasonRatecardUsage overwrites any union data inside the BillingDiscountReason as the provided DiscountReasonRatecardUsage
func (t *BillingDiscountReason) FromDiscountReasonRatecardUsage(v DiscountReasonRatecardUsage) error {
	v.Type = "ratecard_usage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountReasonRatecardUsage performs a merge with any union data inside the BillingDiscountReason, using the provided DiscountReasonRatecardUsage
func (t *BillingDiscountReason) MergeDiscountReasonRatecardUsage(v DiscountReasonRatecardUsage) error {
	v.Type = "ratecard_usage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BillingDiscountReason) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BillingDiscountReason) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "maximum_spend":
		return t.AsDiscountReasonMaximumSpend()
	case "ratecard_percentage":
		return t.AsDiscountReasonRatecardPercentage()
	case "ratecard_usage":
		return t.AsDiscountReasonRatecardUsage()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BillingDiscountReason) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BillingDiscountReason) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingProfileApps returns the union data inside the BillingProfileAppsOrReference as a BillingProfileApps
func (t BillingProfileAppsOrReference) AsBillingProfileApps() (BillingProfileApps, error) {
	var body BillingProfileApps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingProfileApps overwrites any union data inside the BillingProfileAppsOrReference as the provided BillingProfileApps
func (t *BillingProfileAppsOrReference) FromBillingProfileApps(v BillingProfileApps) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingProfileApps performs a merge with any union data inside the BillingProfileAppsOrReference, using the provided BillingProfileApps
func (t *BillingProfileAppsOrReference) MergeBillingProfileApps(v BillingProfileApps) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingProfileAppReferences returns the union data inside the BillingProfileAppsOrReference as a BillingProfileAppReferences
func (t BillingProfileAppsOrReference) AsBillingProfileAppReferences() (BillingProfileAppReferences, error) {
	var body BillingProfileAppReferences
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingProfileAppReferences overwrites any union data inside the BillingProfileAppsOrReference as the provided BillingProfileAppReferences
func (t *BillingProfileAppsOrReference) FromBillingProfileAppReferences(v BillingProfileAppReferences) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingProfileAppReferences performs a merge with any union data inside the BillingProfileAppsOrReference, using the provided BillingProfileAppReferences
func (t *BillingProfileAppsOrReference) MergeBillingProfileAppReferences(v BillingProfileAppReferences) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BillingProfileAppsOrReference) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BillingProfileAppsOrReference) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCustomerId returns the union data inside the CreateStripeCheckoutSessionRequest_Customer as a CustomerId
func (t CreateStripeCheckoutSessionRequest_Customer) AsCustomerId() (CustomerId, error) {
	var body CustomerId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerId overwrites any union data inside the CreateStripeCheckoutSessionRequest_Customer as the provided CustomerId
func (t *CreateStripeCheckoutSessionRequest_Customer) FromCustomerId(v CustomerId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerId performs a merge with any union data inside the CreateStripeCheckoutSessionRequest_Customer, using the provided CustomerId
func (t *CreateStripeCheckoutSessionRequest_Customer) MergeCustomerId(v CustomerId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerKey returns the union data inside the CreateStripeCheckoutSessionRequest_Customer as a CustomerKey
func (t CreateStripeCheckoutSessionRequest_Customer) AsCustomerKey() (CustomerKey, error) {
	var body CustomerKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerKey overwrites any union data inside the CreateStripeCheckoutSessionRequest_Customer as the provided CustomerKey
func (t *CreateStripeCheckoutSessionRequest_Customer) FromCustomerKey(v CustomerKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerKey performs a merge with any union data inside the CreateStripeCheckoutSessionRequest_Customer, using the provided CustomerKey
func (t *CreateStripeCheckoutSessionRequest_Customer) MergeCustomerKey(v CustomerKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerCreate returns the union data inside the CreateStripeCheckoutSessionRequest_Customer as a CustomerCreate
func (t CreateStripeCheckoutSessionRequest_Customer) AsCustomerCreate() (CustomerCreate, error) {
	var body CustomerCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerCreate overwrites any union data inside the CreateStripeCheckoutSessionRequest_Customer as the provided CustomerCreate
func (t *CreateStripeCheckoutSessionRequest_Customer) FromCustomerCreate(v CustomerCreate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerCreate performs a merge with any union data inside the CreateStripeCheckoutSessionRequest_Customer, using the provided CustomerCreate
func (t *CreateStripeCheckoutSessionRequest_Customer) MergeCustomerCreate(v CustomerCreate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateStripeCheckoutSessionRequest_Customer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateStripeCheckoutSessionRequest_Customer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStripeCustomerAppData returns the union data inside the CustomerAppData as a StripeCustomerAppData
func (t CustomerAppData) AsStripeCustomerAppData() (StripeCustomerAppData, error) {
	var body StripeCustomerAppData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStripeCustomerAppData overwrites any union data inside the CustomerAppData as the provided StripeCustomerAppData
func (t *CustomerAppData) FromStripeCustomerAppData(v StripeCustomerAppData) error {
	v.Type = "stripe"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStripeCustomerAppData performs a merge with any union data inside the CustomerAppData, using the provided StripeCustomerAppData
func (t *CustomerAppData) MergeStripeCustomerAppData(v StripeCustomerAppData) error {
	v.Type = "stripe"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxCustomerAppData returns the union data inside the CustomerAppData as a SandboxCustomerAppData
func (t CustomerAppData) AsSandboxCustomerAppData() (SandboxCustomerAppData, error) {
	var body SandboxCustomerAppData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxCustomerAppData overwrites any union data inside the CustomerAppData as the provided SandboxCustomerAppData
func (t *CustomerAppData) FromSandboxCustomerAppData(v SandboxCustomerAppData) error {
	v.Type = "sandbox"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxCustomerAppData performs a merge with any union data inside the CustomerAppData, using the provided SandboxCustomerAppData
func (t *CustomerAppData) MergeSandboxCustomerAppData(v SandboxCustomerAppData) error {
	v.Type = "sandbox"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomInvoicingCustomerAppData returns the union data inside the CustomerAppData as a CustomInvoicingCustomerAppData
func (t CustomerAppData) AsCustomInvoicingCustomerAppData() (CustomInvoicingCustomerAppData, error) {
	var body CustomInvoicingCustomerAppData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomInvoicingCustomerAppData overwrites any union data inside the CustomerAppData as the provided CustomInvoicingCustomerAppData
func (t *CustomerAppData) FromCustomInvoicingCustomerAppData(v CustomInvoicingCustomerAppData) error {
	v.Type = "custom_invoicing"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomInvoicingCustomerAppData performs a merge with any union data inside the CustomerAppData, using the provided CustomInvoicingCustomerAppData
func (t *CustomerAppData) MergeCustomInvoicingCustomerAppData(v CustomInvoicingCustomerAppData) error {
	v.Type = "custom_invoicing"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomerAppData) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CustomerAppData) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "custom_invoicing":
		return t.AsCustomInvoicingCustomerAppData()
	case "sandbox":
		return t.AsSandboxCustomerAppData()
	case "stripe":
		return t.AsStripeCustomerAppData()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CustomerAppData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CustomerAppData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStripeCustomerAppDataCreateOrUpdateItem returns the union data inside the CustomerAppDataCreateOrUpdateItem as a StripeCustomerAppDataCreateOrUpdateItem
func (t CustomerAppDataCreateOrUpdateItem) AsStripeCustomerAppDataCreateOrUpdateItem() (StripeCustomerAppDataCreateOrUpdateItem, error) {
	var body StripeCustomerAppDataCreateOrUpdateItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStripeCustomerAppDataCreateOrUpdateItem overwrites any union data inside the CustomerAppDataCreateOrUpdateItem as the provided StripeCustomerAppDataCreateOrUpdateItem
func (t *CustomerAppDataCreateOrUpdateItem) FromStripeCustomerAppDataCreateOrUpdateItem(v StripeCustomerAppDataCreateOrUpdateItem) error {
	v.Type = "stripe"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStripeCustomerAppDataCreateOrUpdateItem performs a merge with any union data inside the CustomerAppDataCreateOrUpdateItem, using the provided StripeCustomerAppDataCreateOrUpdateItem
func (t *CustomerAppDataCreateOrUpdateItem) MergeStripeCustomerAppDataCreateOrUpdateItem(v StripeCustomerAppDataCreateOrUpdateItem) error {
	v.Type = "stripe"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxCustomerAppData returns the union data inside the CustomerAppDataCreateOrUpdateItem as a SandboxCustomerAppData
func (t CustomerAppDataCreateOrUpdateItem) AsSandboxCustomerAppData() (SandboxCustomerAppData, error) {
	var body SandboxCustomerAppData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxCustomerAppData overwrites any union data inside the CustomerAppDataCreateOrUpdateItem as the provided SandboxCustomerAppData
func (t *CustomerAppDataCreateOrUpdateItem) FromSandboxCustomerAppData(v SandboxCustomerAppData) error {
	v.Type = "sandbox"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxCustomerAppData performs a merge with any union data inside the CustomerAppDataCreateOrUpdateItem, using the provided SandboxCustomerAppData
func (t *CustomerAppDataCreateOrUpdateItem) MergeSandboxCustomerAppData(v SandboxCustomerAppData) error {
	v.Type = "sandbox"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomInvoicingCustomerAppData returns the union data inside the CustomerAppDataCreateOrUpdateItem as a CustomInvoicingCustomerAppData
func (t CustomerAppDataCreateOrUpdateItem) AsCustomInvoicingCustomerAppData() (CustomInvoicingCustomerAppData, error) {
	var body CustomInvoicingCustomerAppData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomInvoicingCustomerAppData overwrites any union data inside the CustomerAppDataCreateOrUpdateItem as the provided CustomInvoicingCustomerAppData
func (t *CustomerAppDataCreateOrUpdateItem) FromCustomInvoicingCustomerAppData(v CustomInvoicingCustomerAppData) error {
	v.Type = "custom_invoicing"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomInvoicingCustomerAppData performs a merge with any union data inside the CustomerAppDataCreateOrUpdateItem, using the provided CustomInvoicingCustomerAppData
func (t *CustomerAppDataCreateOrUpdateItem) MergeCustomInvoicingCustomerAppData(v CustomInvoicingCustomerAppData) error {
	v.Type = "custom_invoicing"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomerAppDataCreateOrUpdateItem) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CustomerAppDataCreateOrUpdateItem) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "custom_invoicing":
		return t.AsCustomInvoicingCustomerAppData()
	case "sandbox":
		return t.AsSandboxCustomerAppData()
	case "stripe":
		return t.AsStripeCustomerAppDataCreateOrUpdateItem()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CustomerAppDataCreateOrUpdateItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CustomerAppDataCreateOrUpdateItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEntitlementMetered returns the union data inside the Entitlement as a EntitlementMetered
func (t Entitlement) AsEntitlementMetered() (EntitlementMetered, error) {
	var body EntitlementMetered
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementMetered overwrites any union data inside the Entitlement as the provided EntitlementMetered
func (t *Entitlement) FromEntitlementMetered(v EntitlementMetered) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementMetered performs a merge with any union data inside the Entitlement, using the provided EntitlementMetered
func (t *Entitlement) MergeEntitlementMetered(v EntitlementMetered) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementStatic returns the union data inside the Entitlement as a EntitlementStatic
func (t Entitlement) AsEntitlementStatic() (EntitlementStatic, error) {
	var body EntitlementStatic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementStatic overwrites any union data inside the Entitlement as the provided EntitlementStatic
func (t *Entitlement) FromEntitlementStatic(v EntitlementStatic) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementStatic performs a merge with any union data inside the Entitlement, using the provided EntitlementStatic
func (t *Entitlement) MergeEntitlementStatic(v EntitlementStatic) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementBoolean returns the union data inside the Entitlement as a EntitlementBoolean
func (t Entitlement) AsEntitlementBoolean() (EntitlementBoolean, error) {
	var body EntitlementBoolean
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementBoolean overwrites any union data inside the Entitlement as the provided EntitlementBoolean
func (t *Entitlement) FromEntitlementBoolean(v EntitlementBoolean) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementBoolean performs a merge with any union data inside the Entitlement, using the provided EntitlementBoolean
func (t *Entitlement) MergeEntitlementBoolean(v EntitlementBoolean) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Entitlement) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Entitlement) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsEntitlementBoolean()
	case "metered":
		return t.AsEntitlementMetered()
	case "static":
		return t.AsEntitlementStatic()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Entitlement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Entitlement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEntitlementMeteredCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementMeteredCreateInputs
func (t EntitlementCreateInputs) AsEntitlementMeteredCreateInputs() (EntitlementMeteredCreateInputs, error) {
	var body EntitlementMeteredCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementMeteredCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementMeteredCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementMeteredCreateInputs(v EntitlementMeteredCreateInputs) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementMeteredCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementMeteredCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementMeteredCreateInputs(v EntitlementMeteredCreateInputs) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementStaticCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementStaticCreateInputs
func (t EntitlementCreateInputs) AsEntitlementStaticCreateInputs() (EntitlementStaticCreateInputs, error) {
	var body EntitlementStaticCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementStaticCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementStaticCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementStaticCreateInputs(v EntitlementStaticCreateInputs) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementStaticCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementStaticCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementStaticCreateInputs(v EntitlementStaticCreateInputs) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementBooleanCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementBooleanCreateInputs
func (t EntitlementCreateInputs) AsEntitlementBooleanCreateInputs() (EntitlementBooleanCreateInputs, error) {
	var body EntitlementBooleanCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementBooleanCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementBooleanCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementBooleanCreateInputs(v EntitlementBooleanCreateInputs) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementBooleanCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementBooleanCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementBooleanCreateInputs(v EntitlementBooleanCreateInputs) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntitlementCreateInputs) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EntitlementCreateInputs) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsEntitlementBooleanCreateInputs()
	case "metered":
		return t.AsEntitlementMeteredCreateInputs()
	case "static":
		return t.AsEntitlementStaticCreateInputs()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EntitlementCreateInputs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntitlementCreateInputs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvent returns the union data inside the IngestEventsBody as a Event
func (t IngestEventsBody) AsEvent() (Event, error) {
	var body Event
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvent overwrites any union data inside the IngestEventsBody as the provided Event
func (t *IngestEventsBody) FromEvent(v Event) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvent performs a merge with any union data inside the IngestEventsBody, using the provided Event
func (t *IngestEventsBody) MergeEvent(v Event) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestEventsBody1 returns the union data inside the IngestEventsBody as a IngestEventsBody1
func (t IngestEventsBody) AsIngestEventsBody1() (IngestEventsBody1, error) {
	var body IngestEventsBody1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestEventsBody1 overwrites any union data inside the IngestEventsBody as the provided IngestEventsBody1
func (t *IngestEventsBody) FromIngestEventsBody1(v IngestEventsBody1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestEventsBody1 performs a merge with any union data inside the IngestEventsBody, using the provided IngestEventsBody1
func (t *IngestEventsBody) MergeIngestEventsBody1(v IngestEventsBody1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IngestEventsBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IngestEventsBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvoiceUsageBasedLine returns the union data inside the InvoiceLine as a InvoiceUsageBasedLine
func (t InvoiceLine) AsInvoiceUsageBasedLine() (InvoiceUsageBasedLine, error) {
	var body InvoiceUsageBasedLine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvoiceUsageBasedLine overwrites any union data inside the InvoiceLine as the provided InvoiceUsageBasedLine
func (t *InvoiceLine) FromInvoiceUsageBasedLine(v InvoiceUsageBasedLine) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvoiceUsageBasedLine performs a merge with any union data inside the InvoiceLine, using the provided InvoiceUsageBasedLine
func (t *InvoiceLine) MergeInvoiceUsageBasedLine(v InvoiceUsageBasedLine) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvoiceFlatFeeLine returns the union data inside the InvoiceLine as a InvoiceFlatFeeLine
func (t InvoiceLine) AsInvoiceFlatFeeLine() (InvoiceFlatFeeLine, error) {
	var body InvoiceFlatFeeLine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvoiceFlatFeeLine overwrites any union data inside the InvoiceLine as the provided InvoiceFlatFeeLine
func (t *InvoiceLine) FromInvoiceFlatFeeLine(v InvoiceFlatFeeLine) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvoiceFlatFeeLine performs a merge with any union data inside the InvoiceLine, using the provided InvoiceFlatFeeLine
func (t *InvoiceLine) MergeInvoiceFlatFeeLine(v InvoiceFlatFeeLine) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InvoiceLine) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t InvoiceLine) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat_fee":
		return t.AsInvoiceFlatFeeLine()
	case "usage_based":
		return t.AsInvoiceUsageBasedLine()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t InvoiceLine) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InvoiceLine) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvoiceUsageBasedLineReplaceUpdate returns the union data inside the InvoiceLineReplaceUpdate as a InvoiceUsageBasedLineReplaceUpdate
func (t InvoiceLineReplaceUpdate) AsInvoiceUsageBasedLineReplaceUpdate() (InvoiceUsageBasedLineReplaceUpdate, error) {
	var body InvoiceUsageBasedLineReplaceUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvoiceUsageBasedLineReplaceUpdate overwrites any union data inside the InvoiceLineReplaceUpdate as the provided InvoiceUsageBasedLineReplaceUpdate
func (t *InvoiceLineReplaceUpdate) FromInvoiceUsageBasedLineReplaceUpdate(v InvoiceUsageBasedLineReplaceUpdate) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvoiceUsageBasedLineReplaceUpdate performs a merge with any union data inside the InvoiceLineReplaceUpdate, using the provided InvoiceUsageBasedLineReplaceUpdate
func (t *InvoiceLineReplaceUpdate) MergeInvoiceUsageBasedLineReplaceUpdate(v InvoiceUsageBasedLineReplaceUpdate) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvoiceFlatFeeLineReplaceUpdate returns the union data inside the InvoiceLineReplaceUpdate as a InvoiceFlatFeeLineReplaceUpdate
func (t InvoiceLineReplaceUpdate) AsInvoiceFlatFeeLineReplaceUpdate() (InvoiceFlatFeeLineReplaceUpdate, error) {
	var body InvoiceFlatFeeLineReplaceUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvoiceFlatFeeLineReplaceUpdate overwrites any union data inside the InvoiceLineReplaceUpdate as the provided InvoiceFlatFeeLineReplaceUpdate
func (t *InvoiceLineReplaceUpdate) FromInvoiceFlatFeeLineReplaceUpdate(v InvoiceFlatFeeLineReplaceUpdate) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvoiceFlatFeeLineReplaceUpdate performs a merge with any union data inside the InvoiceLineReplaceUpdate, using the provided InvoiceFlatFeeLineReplaceUpdate
func (t *InvoiceLineReplaceUpdate) MergeInvoiceFlatFeeLineReplaceUpdate(v InvoiceFlatFeeLineReplaceUpdate) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InvoiceLineReplaceUpdate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t InvoiceLineReplaceUpdate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat_fee":
		return t.AsInvoiceFlatFeeLineReplaceUpdate()
	case "usage_based":
		return t.AsInvoiceUsageBasedLineReplaceUpdate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t InvoiceLineReplaceUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InvoiceLineReplaceUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvoiceUsageBasedPendingLineCreate returns the union data inside the InvoicePendingLineCreate as a InvoiceUsageBasedPendingLineCreate
func (t InvoicePendingLineCreate) AsInvoiceUsageBasedPendingLineCreate() (InvoiceUsageBasedPendingLineCreate, error) {
	var body InvoiceUsageBasedPendingLineCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvoiceUsageBasedPendingLineCreate overwrites any union data inside the InvoicePendingLineCreate as the provided InvoiceUsageBasedPendingLineCreate
func (t *InvoicePendingLineCreate) FromInvoiceUsageBasedPendingLineCreate(v InvoiceUsageBasedPendingLineCreate) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvoiceUsageBasedPendingLineCreate performs a merge with any union data inside the InvoicePendingLineCreate, using the provided InvoiceUsageBasedPendingLineCreate
func (t *InvoicePendingLineCreate) MergeInvoiceUsageBasedPendingLineCreate(v InvoiceUsageBasedPendingLineCreate) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvoiceFlatFeePendingLineCreate returns the union data inside the InvoicePendingLineCreate as a InvoiceFlatFeePendingLineCreate
func (t InvoicePendingLineCreate) AsInvoiceFlatFeePendingLineCreate() (InvoiceFlatFeePendingLineCreate, error) {
	var body InvoiceFlatFeePendingLineCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvoiceFlatFeePendingLineCreate overwrites any union data inside the InvoicePendingLineCreate as the provided InvoiceFlatFeePendingLineCreate
func (t *InvoicePendingLineCreate) FromInvoiceFlatFeePendingLineCreate(v InvoiceFlatFeePendingLineCreate) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvoiceFlatFeePendingLineCreate performs a merge with any union data inside the InvoicePendingLineCreate, using the provided InvoiceFlatFeePendingLineCreate
func (t *InvoicePendingLineCreate) MergeInvoiceFlatFeePendingLineCreate(v InvoiceFlatFeePendingLineCreate) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InvoicePendingLineCreate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t InvoicePendingLineCreate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat_fee":
		return t.AsInvoiceFlatFeePendingLineCreate()
	case "usage_based":
		return t.AsInvoiceUsageBasedPendingLineCreate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t InvoicePendingLineCreate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InvoicePendingLineCreate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvoiceSimulationUsageBasedLine returns the union data inside the InvoiceSimulationLine as a InvoiceSimulationUsageBasedLine
func (t InvoiceSimulationLine) AsInvoiceSimulationUsageBasedLine() (InvoiceSimulationUsageBasedLine, error) {
	var body InvoiceSimulationUsageBasedLine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvoiceSimulationUsageBasedLine overwrites any union data inside the InvoiceSimulationLine as the provided InvoiceSimulationUsageBasedLine
func (t *InvoiceSimulationLine) FromInvoiceSimulationUsageBasedLine(v InvoiceSimulationUsageBasedLine) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvoiceSimulationUsageBasedLine performs a merge with any union data inside the InvoiceSimulationLine, using the provided InvoiceSimulationUsageBasedLine
func (t *InvoiceSimulationLine) MergeInvoiceSimulationUsageBasedLine(v InvoiceSimulationUsageBasedLine) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvoiceSimulationFlatFeeLine returns the union data inside the InvoiceSimulationLine as a InvoiceSimulationFlatFeeLine
func (t InvoiceSimulationLine) AsInvoiceSimulationFlatFeeLine() (InvoiceSimulationFlatFeeLine, error) {
	var body InvoiceSimulationFlatFeeLine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvoiceSimulationFlatFeeLine overwrites any union data inside the InvoiceSimulationLine as the provided InvoiceSimulationFlatFeeLine
func (t *InvoiceSimulationLine) FromInvoiceSimulationFlatFeeLine(v InvoiceSimulationFlatFeeLine) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvoiceSimulationFlatFeeLine performs a merge with any union data inside the InvoiceSimulationLine, using the provided InvoiceSimulationFlatFeeLine
func (t *InvoiceSimulationLine) MergeInvoiceSimulationFlatFeeLine(v InvoiceSimulationFlatFeeLine) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InvoiceSimulationLine) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t InvoiceSimulationLine) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat_fee":
		return t.AsInvoiceSimulationFlatFeeLine()
	case "usage_based":
		return t.AsInvoiceSimulationUsageBasedLine()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t InvoiceSimulationLine) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InvoiceSimulationLine) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsListEntitlementsResult0 returns the union data inside the ListEntitlementsResult as a ListEntitlementsResult0
func (t ListEntitlementsResult) AsListEntitlementsResult0() (ListEntitlementsResult0, error) {
	var body ListEntitlementsResult0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListEntitlementsResult0 overwrites any union data inside the ListEntitlementsResult as the provided ListEntitlementsResult0
func (t *ListEntitlementsResult) FromListEntitlementsResult0(v ListEntitlementsResult0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListEntitlementsResult0 performs a merge with any union data inside the ListEntitlementsResult, using the provided ListEntitlementsResult0
func (t *ListEntitlementsResult) MergeListEntitlementsResult0(v ListEntitlementsResult0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementPaginatedResponse returns the union data inside the ListEntitlementsResult as a EntitlementPaginatedResponse
func (t ListEntitlementsResult) AsEntitlementPaginatedResponse() (EntitlementPaginatedResponse, error) {
	var body EntitlementPaginatedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementPaginatedResponse overwrites any union data inside the ListEntitlementsResult as the provided EntitlementPaginatedResponse
func (t *ListEntitlementsResult) FromEntitlementPaginatedResponse(v EntitlementPaginatedResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementPaginatedResponse performs a merge with any union data inside the ListEntitlementsResult, using the provided EntitlementPaginatedResponse
func (t *ListEntitlementsResult) MergeEntitlementPaginatedResponse(v EntitlementPaginatedResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ListEntitlementsResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ListEntitlementsResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsListFeaturesResult0 returns the union data inside the ListFeaturesResult as a ListFeaturesResult0
func (t ListFeaturesResult) AsListFeaturesResult0() (ListFeaturesResult0, error) {
	var body ListFeaturesResult0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListFeaturesResult0 overwrites any union data inside the ListFeaturesResult as the provided ListFeaturesResult0
func (t *ListFeaturesResult) FromListFeaturesResult0(v ListFeaturesResult0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListFeaturesResult0 performs a merge with any union data inside the ListFeaturesResult, using the provided ListFeaturesResult0
func (t *ListFeaturesResult) MergeListFeaturesResult0(v ListFeaturesResult0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeaturePaginatedResponse returns the union data inside the ListFeaturesResult as a FeaturePaginatedResponse
func (t ListFeaturesResult) AsFeaturePaginatedResponse() (FeaturePaginatedResponse, error) {
	var body FeaturePaginatedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeaturePaginatedResponse overwrites any union data inside the ListFeaturesResult as the provided FeaturePaginatedResponse
func (t *ListFeaturesResult) FromFeaturePaginatedResponse(v FeaturePaginatedResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeaturePaginatedResponse performs a merge with any union data inside the ListFeaturesResult, using the provided FeaturePaginatedResponse
func (t *ListFeaturesResult) MergeFeaturePaginatedResponse(v FeaturePaginatedResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ListFeaturesResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ListFeaturesResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMeasureUsageFromPreset returns the union data inside the MeasureUsageFrom as a MeasureUsageFromPreset
func (t MeasureUsageFrom) AsMeasureUsageFromPreset() (MeasureUsageFromPreset, error) {
	var body MeasureUsageFromPreset
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeasureUsageFromPreset overwrites any union data inside the MeasureUsageFrom as the provided MeasureUsageFromPreset
func (t *MeasureUsageFrom) FromMeasureUsageFromPreset(v MeasureUsageFromPreset) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeasureUsageFromPreset performs a merge with any union data inside the MeasureUsageFrom, using the provided MeasureUsageFromPreset
func (t *MeasureUsageFrom) MergeMeasureUsageFromPreset(v MeasureUsageFromPreset) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMeasureUsageFromTime returns the union data inside the MeasureUsageFrom as a MeasureUsageFromTime
func (t MeasureUsageFrom) AsMeasureUsageFromTime() (MeasureUsageFromTime, error) {
	var body MeasureUsageFromTime
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeasureUsageFromTime overwrites any union data inside the MeasureUsageFrom as the provided MeasureUsageFromTime
func (t *MeasureUsageFrom) FromMeasureUsageFromTime(v MeasureUsageFromTime) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeasureUsageFromTime performs a merge with any union data inside the MeasureUsageFrom, using the provided MeasureUsageFromTime
func (t *MeasureUsageFrom) MergeMeasureUsageFromTime(v MeasureUsageFromTime) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MeasureUsageFrom) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MeasureUsageFrom) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotificationEventResetPayload returns the union data inside the NotificationEventPayload as a NotificationEventResetPayload
func (t NotificationEventPayload) AsNotificationEventResetPayload() (NotificationEventResetPayload, error) {
	var body NotificationEventResetPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationEventResetPayload overwrites any union data inside the NotificationEventPayload as the provided NotificationEventResetPayload
func (t *NotificationEventPayload) FromNotificationEventResetPayload(v NotificationEventResetPayload) error {
	v.Type = "entitlements.reset"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationEventResetPayload performs a merge with any union data inside the NotificationEventPayload, using the provided NotificationEventResetPayload
func (t *NotificationEventPayload) MergeNotificationEventResetPayload(v NotificationEventResetPayload) error {
	v.Type = "entitlements.reset"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotificationEventBalanceThresholdPayload returns the union data inside the NotificationEventPayload as a NotificationEventBalanceThresholdPayload
func (t NotificationEventPayload) AsNotificationEventBalanceThresholdPayload() (NotificationEventBalanceThresholdPayload, error) {
	var body NotificationEventBalanceThresholdPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationEventBalanceThresholdPayload overwrites any union data inside the NotificationEventPayload as the provided NotificationEventBalanceThresholdPayload
func (t *NotificationEventPayload) FromNotificationEventBalanceThresholdPayload(v NotificationEventBalanceThresholdPayload) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationEventBalanceThresholdPayload performs a merge with any union data inside the NotificationEventPayload, using the provided NotificationEventBalanceThresholdPayload
func (t *NotificationEventPayload) MergeNotificationEventBalanceThresholdPayload(v NotificationEventBalanceThresholdPayload) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotificationEventInvoiceCreatedPayload returns the union data inside the NotificationEventPayload as a NotificationEventInvoiceCreatedPayload
func (t NotificationEventPayload) AsNotificationEventInvoiceCreatedPayload() (NotificationEventInvoiceCreatedPayload, error) {
	var body NotificationEventInvoiceCreatedPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationEventInvoiceCreatedPayload overwrites any union data inside the NotificationEventPayload as the provided NotificationEventInvoiceCreatedPayload
func (t *NotificationEventPayload) FromNotificationEventInvoiceCreatedPayload(v NotificationEventInvoiceCreatedPayload) error {
	v.Type = "invoice.created"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationEventInvoiceCreatedPayload performs a merge with any union data inside the NotificationEventPayload, using the provided NotificationEventInvoiceCreatedPayload
func (t *NotificationEventPayload) MergeNotificationEventInvoiceCreatedPayload(v NotificationEventInvoiceCreatedPayload) error {
	v.Type = "invoice.created"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotificationEventInvoiceUpdatedPayload returns the union data inside the NotificationEventPayload as a NotificationEventInvoiceUpdatedPayload
func (t NotificationEventPayload) AsNotificationEventInvoiceUpdatedPayload() (NotificationEventInvoiceUpdatedPayload, error) {
	var body NotificationEventInvoiceUpdatedPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationEventInvoiceUpdatedPayload overwrites any union data inside the NotificationEventPayload as the provided NotificationEventInvoiceUpdatedPayload
func (t *NotificationEventPayload) FromNotificationEventInvoiceUpdatedPayload(v NotificationEventInvoiceUpdatedPayload) error {
	v.Type = "invoice.updated"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationEventInvoiceUpdatedPayload performs a merge with any union data inside the NotificationEventPayload, using the provided NotificationEventInvoiceUpdatedPayload
func (t *NotificationEventPayload) MergeNotificationEventInvoiceUpdatedPayload(v NotificationEventInvoiceUpdatedPayload) error {
	v.Type = "invoice.updated"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NotificationEventPayload) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NotificationEventPayload) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "entitlements.balance.threshold":
		return t.AsNotificationEventBalanceThresholdPayload()
	case "entitlements.reset":
		return t.AsNotificationEventResetPayload()
	case "invoice.created":
		return t.AsNotificationEventInvoiceCreatedPayload()
	case "invoice.updated":
		return t.AsNotificationEventInvoiceUpdatedPayload()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NotificationEventPayload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NotificationEventPayload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotificationRuleBalanceThreshold returns the union data inside the NotificationRule as a NotificationRuleBalanceThreshold
func (t NotificationRule) AsNotificationRuleBalanceThreshold() (NotificationRuleBalanceThreshold, error) {
	var body NotificationRuleBalanceThreshold
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationRuleBalanceThreshold overwrites any union data inside the NotificationRule as the provided NotificationRuleBalanceThreshold
func (t *NotificationRule) FromNotificationRuleBalanceThreshold(v NotificationRuleBalanceThreshold) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationRuleBalanceThreshold performs a merge with any union data inside the NotificationRule, using the provided NotificationRuleBalanceThreshold
func (t *NotificationRule) MergeNotificationRuleBalanceThreshold(v NotificationRuleBalanceThreshold) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotificationRuleEntitlementReset returns the union data inside the NotificationRule as a NotificationRuleEntitlementReset
func (t NotificationRule) AsNotificationRuleEntitlementReset() (NotificationRuleEntitlementReset, error) {
	var body NotificationRuleEntitlementReset
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationRuleEntitlementReset overwrites any union data inside the NotificationRule as the provided NotificationRuleEntitlementReset
func (t *NotificationRule) FromNotificationRuleEntitlementReset(v NotificationRuleEntitlementReset) error {
	v.Type = "entitlements.reset"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationRuleEntitlementReset performs a merge with any union data inside the NotificationRule, using the provided NotificationRuleEntitlementReset
func (t *NotificationRule) MergeNotificationRuleEntitlementReset(v NotificationRuleEntitlementReset) error {
	v.Type = "entitlements.reset"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotificationRuleInvoiceCreated returns the union data inside the NotificationRule as a NotificationRuleInvoiceCreated
func (t NotificationRule) AsNotificationRuleInvoiceCreated() (NotificationRuleInvoiceCreated, error) {
	var body NotificationRuleInvoiceCreated
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationRuleInvoiceCreated overwrites any union data inside the NotificationRule as the provided NotificationRuleInvoiceCreated
func (t *NotificationRule) FromNotificationRuleInvoiceCreated(v NotificationRuleInvoiceCreated) error {
	v.Type = "invoice.created"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationRuleInvoiceCreated performs a merge with any union data inside the NotificationRule, using the provided NotificationRuleInvoiceCreated
func (t *NotificationRule) MergeNotificationRuleInvoiceCreated(v NotificationRuleInvoiceCreated) error {
	v.Type = "invoice.created"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotificationRuleInvoiceUpdated returns the union data inside the NotificationRule as a NotificationRuleInvoiceUpdated
func (t NotificationRule) AsNotificationRuleInvoiceUpdated() (NotificationRuleInvoiceUpdated, error) {
	var body NotificationRuleInvoiceUpdated
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationRuleInvoiceUpdated overwrites any union data inside the NotificationRule as the provided NotificationRuleInvoiceUpdated
func (t *NotificationRule) FromNotificationRuleInvoiceUpdated(v NotificationRuleInvoiceUpdated) error {
	v.Type = "invoice.updated"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationRuleInvoiceUpdated performs a merge with any union data inside the NotificationRule, using the provided NotificationRuleInvoiceUpdated
func (t *NotificationRule) MergeNotificationRuleInvoiceUpdated(v NotificationRuleInvoiceUpdated) error {
	v.Type = "invoice.updated"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NotificationRule) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NotificationRule) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "entitlements.balance.threshold":
		return t.AsNotificationRuleBalanceThreshold()
	case "entitlements.reset":
		return t.AsNotificationRuleEntitlementReset()
	case "invoice.created":
		return t.AsNotificationRuleInvoiceCreated()
	case "invoice.updated":
		return t.AsNotificationRuleInvoiceUpdated()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NotificationRule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NotificationRule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotificationRuleBalanceThresholdCreateRequest returns the union data inside the NotificationRuleCreateRequest as a NotificationRuleBalanceThresholdCreateRequest
func (t NotificationRuleCreateRequest) AsNotificationRuleBalanceThresholdCreateRequest() (NotificationRuleBalanceThresholdCreateRequest, error) {
	var body NotificationRuleBalanceThresholdCreateRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationRuleBalanceThresholdCreateRequest overwrites any union data inside the NotificationRuleCreateRequest as the provided NotificationRuleBalanceThresholdCreateRequest
func (t *NotificationRuleCreateRequest) FromNotificationRuleBalanceThresholdCreateRequest(v NotificationRuleBalanceThresholdCreateRequest) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationRuleBalanceThresholdCreateRequest performs a merge with any union data inside the NotificationRuleCreateRequest, using the provided NotificationRuleBalanceThresholdCreateRequest
func (t *NotificationRuleCreateRequest) MergeNotificationRuleBalanceThresholdCreateRequest(v NotificationRuleBalanceThresholdCreateRequest) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotificationRuleEntitlementResetCreateRequest returns the union data inside the NotificationRuleCreateRequest as a NotificationRuleEntitlementResetCreateRequest
func (t NotificationRuleCreateRequest) AsNotificationRuleEntitlementResetCreateRequest() (NotificationRuleEntitlementResetCreateRequest, error) {
	var body NotificationRuleEntitlementResetCreateRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationRuleEntitlementResetCreateRequest overwrites any union data inside the NotificationRuleCreateRequest as the provided NotificationRuleEntitlementResetCreateRequest
func (t *NotificationRuleCreateRequest) FromNotificationRuleEntitlementResetCreateRequest(v NotificationRuleEntitlementResetCreateRequest) error {
	v.Type = "entitlements.reset"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationRuleEntitlementResetCreateRequest performs a merge with any union data inside the NotificationRuleCreateRequest, using the provided NotificationRuleEntitlementResetCreateRequest
func (t *NotificationRuleCreateRequest) MergeNotificationRuleEntitlementResetCreateRequest(v NotificationRuleEntitlementResetCreateRequest) error {
	v.Type = "entitlements.reset"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotificationRuleInvoiceCreatedCreateRequest returns the union data inside the NotificationRuleCreateRequest as a NotificationRuleInvoiceCreatedCreateRequest
func (t NotificationRuleCreateRequest) AsNotificationRuleInvoiceCreatedCreateRequest() (NotificationRuleInvoiceCreatedCreateRequest, error) {
	var body NotificationRuleInvoiceCreatedCreateRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationRuleInvoiceCreatedCreateRequest overwrites any union data inside the NotificationRuleCreateRequest as the provided NotificationRuleInvoiceCreatedCreateRequest
func (t *NotificationRuleCreateRequest) FromNotificationRuleInvoiceCreatedCreateRequest(v NotificationRuleInvoiceCreatedCreateRequest) error {
	v.Type = "invoice.created"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationRuleInvoiceCreatedCreateRequest performs a merge with any union data inside the NotificationRuleCreateRequest, using the provided NotificationRuleInvoiceCreatedCreateRequest
func (t *NotificationRuleCreateRequest) MergeNotificationRuleInvoiceCreatedCreateRequest(v NotificationRuleInvoiceCreatedCreateRequest) error {
	v.Type = "invoice.created"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotificationRuleInvoiceUpdatedCreateRequest returns the union data inside the NotificationRuleCreateRequest as a NotificationRuleInvoiceUpdatedCreateRequest
func (t NotificationRuleCreateRequest) AsNotificationRuleInvoiceUpdatedCreateRequest() (NotificationRuleInvoiceUpdatedCreateRequest, error) {
	var body NotificationRuleInvoiceUpdatedCreateRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationRuleInvoiceUpdatedCreateRequest overwrites any union data inside the NotificationRuleCreateRequest as the provided NotificationRuleInvoiceUpdatedCreateRequest
func (t *NotificationRuleCreateRequest) FromNotificationRuleInvoiceUpdatedCreateRequest(v NotificationRuleInvoiceUpdatedCreateRequest) error {
	v.Type = "invoice.updated"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationRuleInvoiceUpdatedCreateRequest performs a merge with any union data inside the NotificationRuleCreateRequest, using the provided NotificationRuleInvoiceUpdatedCreateRequest
func (t *NotificationRuleCreateRequest) MergeNotificationRuleInvoiceUpdatedCreateRequest(v NotificationRuleInvoiceUpdatedCreateRequest) error {
	v.Type = "invoice.updated"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NotificationRuleCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NotificationRuleCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "entitlements.balance.threshold":
		return t.AsNotificationRuleBalanceThresholdCreateRequest()
	case "entitlements.reset":
		return t.AsNotificationRuleEntitlementResetCreateRequest()
	case "invoice.created":
		return t.AsNotificationRuleInvoiceCreatedCreateRequest()
	case "invoice.updated":
		return t.AsNotificationRuleInvoiceUpdatedCreateRequest()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NotificationRuleCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NotificationRuleCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPaymentTermInstant returns the union data inside the PaymentTerms as a PaymentTermInstant
func (t PaymentTerms) AsPaymentTermInstant() (PaymentTermInstant, error) {
	var body PaymentTermInstant
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentTermInstant overwrites any union data inside the PaymentTerms as the provided PaymentTermInstant
func (t *PaymentTerms) FromPaymentTermInstant(v PaymentTermInstant) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentTermInstant performs a merge with any union data inside the PaymentTerms, using the provided PaymentTermInstant
func (t *PaymentTerms) MergePaymentTermInstant(v PaymentTermInstant) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentTermDueDate returns the union data inside the PaymentTerms as a PaymentTermDueDate
func (t PaymentTerms) AsPaymentTermDueDate() (PaymentTermDueDate, error) {
	var body PaymentTermDueDate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentTermDueDate overwrites any union data inside the PaymentTerms as the provided PaymentTermDueDate
func (t *PaymentTerms) FromPaymentTermDueDate(v PaymentTermDueDate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentTermDueDate performs a merge with any union data inside the PaymentTerms, using the provided PaymentTermDueDate
func (t *PaymentTerms) MergePaymentTermDueDate(v PaymentTermDueDate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PaymentTerms) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PaymentTerms) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRateCardFlatFee returns the union data inside the RateCard as a RateCardFlatFee
func (t RateCard) AsRateCardFlatFee() (RateCardFlatFee, error) {
	var body RateCardFlatFee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardFlatFee overwrites any union data inside the RateCard as the provided RateCardFlatFee
func (t *RateCard) FromRateCardFlatFee(v RateCardFlatFee) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardFlatFee performs a merge with any union data inside the RateCard, using the provided RateCardFlatFee
func (t *RateCard) MergeRateCardFlatFee(v RateCardFlatFee) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRateCardUsageBased returns the union data inside the RateCard as a RateCardUsageBased
func (t RateCard) AsRateCardUsageBased() (RateCardUsageBased, error) {
	var body RateCardUsageBased
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardUsageBased overwrites any union data inside the RateCard as the provided RateCardUsageBased
func (t *RateCard) FromRateCardUsageBased(v RateCardUsageBased) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardUsageBased performs a merge with any union data inside the RateCard, using the provided RateCardUsageBased
func (t *RateCard) MergeRateCardUsageBased(v RateCardUsageBased) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RateCard) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RateCard) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat_fee":
		return t.AsRateCardFlatFee()
	case "usage_based":
		return t.AsRateCardUsageBased()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RateCard) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RateCard) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRateCardMeteredEntitlement returns the union data inside the RateCardEntitlement as a RateCardMeteredEntitlement
func (t RateCardEntitlement) AsRateCardMeteredEntitlement() (RateCardMeteredEntitlement, error) {
	var body RateCardMeteredEntitlement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardMeteredEntitlement overwrites any union data inside the RateCardEntitlement as the provided RateCardMeteredEntitlement
func (t *RateCardEntitlement) FromRateCardMeteredEntitlement(v RateCardMeteredEntitlement) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardMeteredEntitlement performs a merge with any union data inside the RateCardEntitlement, using the provided RateCardMeteredEntitlement
func (t *RateCardEntitlement) MergeRateCardMeteredEntitlement(v RateCardMeteredEntitlement) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRateCardStaticEntitlement returns the union data inside the RateCardEntitlement as a RateCardStaticEntitlement
func (t RateCardEntitlement) AsRateCardStaticEntitlement() (RateCardStaticEntitlement, error) {
	var body RateCardStaticEntitlement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardStaticEntitlement overwrites any union data inside the RateCardEntitlement as the provided RateCardStaticEntitlement
func (t *RateCardEntitlement) FromRateCardStaticEntitlement(v RateCardStaticEntitlement) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardStaticEntitlement performs a merge with any union data inside the RateCardEntitlement, using the provided RateCardStaticEntitlement
func (t *RateCardEntitlement) MergeRateCardStaticEntitlement(v RateCardStaticEntitlement) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRateCardBooleanEntitlement returns the union data inside the RateCardEntitlement as a RateCardBooleanEntitlement
func (t RateCardEntitlement) AsRateCardBooleanEntitlement() (RateCardBooleanEntitlement, error) {
	var body RateCardBooleanEntitlement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardBooleanEntitlement overwrites any union data inside the RateCardEntitlement as the provided RateCardBooleanEntitlement
func (t *RateCardEntitlement) FromRateCardBooleanEntitlement(v RateCardBooleanEntitlement) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardBooleanEntitlement performs a merge with any union data inside the RateCardEntitlement, using the provided RateCardBooleanEntitlement
func (t *RateCardEntitlement) MergeRateCardBooleanEntitlement(v RateCardBooleanEntitlement) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RateCardEntitlement) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RateCardEntitlement) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsRateCardBooleanEntitlement()
	case "metered":
		return t.AsRateCardMeteredEntitlement()
	case "static":
		return t.AsRateCardStaticEntitlement()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RateCardEntitlement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RateCardEntitlement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFlatPriceWithPaymentTerm returns the union data inside the RateCardUsageBasedPrice as a FlatPriceWithPaymentTerm
func (t RateCardUsageBasedPrice) AsFlatPriceWithPaymentTerm() (FlatPriceWithPaymentTerm, error) {
	var body FlatPriceWithPaymentTerm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFlatPriceWithPaymentTerm overwrites any union data inside the RateCardUsageBasedPrice as the provided FlatPriceWithPaymentTerm
func (t *RateCardUsageBasedPrice) FromFlatPriceWithPaymentTerm(v FlatPriceWithPaymentTerm) error {
	v.Type = "flat"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFlatPriceWithPaymentTerm performs a merge with any union data inside the RateCardUsageBasedPrice, using the provided FlatPriceWithPaymentTerm
func (t *RateCardUsageBasedPrice) MergeFlatPriceWithPaymentTerm(v FlatPriceWithPaymentTerm) error {
	v.Type = "flat"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnitPriceWithCommitments returns the union data inside the RateCardUsageBasedPrice as a UnitPriceWithCommitments
func (t RateCardUsageBasedPrice) AsUnitPriceWithCommitments() (UnitPriceWithCommitments, error) {
	var body UnitPriceWithCommitments
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnitPriceWithCommitments overwrites any union data inside the RateCardUsageBasedPrice as the provided UnitPriceWithCommitments
func (t *RateCardUsageBasedPrice) FromUnitPriceWithCommitments(v UnitPriceWithCommitments) error {
	v.Type = "unit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnitPriceWithCommitments performs a merge with any union data inside the RateCardUsageBasedPrice, using the provided UnitPriceWithCommitments
func (t *RateCardUsageBasedPrice) MergeUnitPriceWithCommitments(v UnitPriceWithCommitments) error {
	v.Type = "unit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTieredPriceWithCommitments returns the union data inside the RateCardUsageBasedPrice as a TieredPriceWithCommitments
func (t RateCardUsageBasedPrice) AsTieredPriceWithCommitments() (TieredPriceWithCommitments, error) {
	var body TieredPriceWithCommitments
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTieredPriceWithCommitments overwrites any union data inside the RateCardUsageBasedPrice as the provided TieredPriceWithCommitments
func (t *RateCardUsageBasedPrice) FromTieredPriceWithCommitments(v TieredPriceWithCommitments) error {
	v.Type = "tiered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTieredPriceWithCommitments performs a merge with any union data inside the RateCardUsageBasedPrice, using the provided TieredPriceWithCommitments
func (t *RateCardUsageBasedPrice) MergeTieredPriceWithCommitments(v TieredPriceWithCommitments) error {
	v.Type = "tiered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDynamicPriceWithCommitments returns the union data inside the RateCardUsageBasedPrice as a DynamicPriceWithCommitments
func (t RateCardUsageBasedPrice) AsDynamicPriceWithCommitments() (DynamicPriceWithCommitments, error) {
	var body DynamicPriceWithCommitments
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDynamicPriceWithCommitments overwrites any union data inside the RateCardUsageBasedPrice as the provided DynamicPriceWithCommitments
func (t *RateCardUsageBasedPrice) FromDynamicPriceWithCommitments(v DynamicPriceWithCommitments) error {
	v.Type = "dynamic"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDynamicPriceWithCommitments performs a merge with any union data inside the RateCardUsageBasedPrice, using the provided DynamicPriceWithCommitments
func (t *RateCardUsageBasedPrice) MergeDynamicPriceWithCommitments(v DynamicPriceWithCommitments) error {
	v.Type = "dynamic"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackagePriceWithCommitments returns the union data inside the RateCardUsageBasedPrice as a PackagePriceWithCommitments
func (t RateCardUsageBasedPrice) AsPackagePriceWithCommitments() (PackagePriceWithCommitments, error) {
	var body PackagePriceWithCommitments
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackagePriceWithCommitments overwrites any union data inside the RateCardUsageBasedPrice as the provided PackagePriceWithCommitments
func (t *RateCardUsageBasedPrice) FromPackagePriceWithCommitments(v PackagePriceWithCommitments) error {
	v.Type = "package"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackagePriceWithCommitments performs a merge with any union data inside the RateCardUsageBasedPrice, using the provided PackagePriceWithCommitments
func (t *RateCardUsageBasedPrice) MergePackagePriceWithCommitments(v PackagePriceWithCommitments) error {
	v.Type = "package"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RateCardUsageBasedPrice) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RateCardUsageBasedPrice) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dynamic":
		return t.AsDynamicPriceWithCommitments()
	case "flat":
		return t.AsFlatPriceWithPaymentTerm()
	case "package":
		return t.AsPackagePriceWithCommitments()
	case "tiered":
		return t.AsTieredPriceWithCommitments()
	case "unit":
		return t.AsUnitPriceWithCommitments()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RateCardUsageBasedPrice) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RateCardUsageBasedPrice) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRecurringPeriodInterval0 returns the union data inside the RecurringPeriodInterval as a RecurringPeriodInterval0
func (t RecurringPeriodInterval) AsRecurringPeriodInterval0() (RecurringPeriodInterval0, error) {
	var body RecurringPeriodInterval0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecurringPeriodInterval0 overwrites any union data inside the RecurringPeriodInterval as the provided RecurringPeriodInterval0
func (t *RecurringPeriodInterval) FromRecurringPeriodInterval0(v RecurringPeriodInterval0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecurringPeriodInterval0 performs a merge with any union data inside the RecurringPeriodInterval, using the provided RecurringPeriodInterval0
func (t *RecurringPeriodInterval) MergeRecurringPeriodInterval0(v RecurringPeriodInterval0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRecurringPeriodIntervalEnum returns the union data inside the RecurringPeriodInterval as a RecurringPeriodIntervalEnum
func (t RecurringPeriodInterval) AsRecurringPeriodIntervalEnum() (RecurringPeriodIntervalEnum, error) {
	var body RecurringPeriodIntervalEnum
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecurringPeriodIntervalEnum overwrites any union data inside the RecurringPeriodInterval as the provided RecurringPeriodIntervalEnum
func (t *RecurringPeriodInterval) FromRecurringPeriodIntervalEnum(v RecurringPeriodIntervalEnum) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecurringPeriodIntervalEnum performs a merge with any union data inside the RecurringPeriodInterval, using the provided RecurringPeriodIntervalEnum
func (t *RecurringPeriodInterval) MergeRecurringPeriodIntervalEnum(v RecurringPeriodIntervalEnum) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RecurringPeriodInterval) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecurringPeriodInterval) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlanSubscriptionChange returns the union data inside the SubscriptionChange as a PlanSubscriptionChange
func (t SubscriptionChange) AsPlanSubscriptionChange() (PlanSubscriptionChange, error) {
	var body PlanSubscriptionChange
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlanSubscriptionChange overwrites any union data inside the SubscriptionChange as the provided PlanSubscriptionChange
func (t *SubscriptionChange) FromPlanSubscriptionChange(v PlanSubscriptionChange) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlanSubscriptionChange performs a merge with any union data inside the SubscriptionChange, using the provided PlanSubscriptionChange
func (t *SubscriptionChange) MergePlanSubscriptionChange(v PlanSubscriptionChange) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomSubscriptionChange returns the union data inside the SubscriptionChange as a CustomSubscriptionChange
func (t SubscriptionChange) AsCustomSubscriptionChange() (CustomSubscriptionChange, error) {
	var body CustomSubscriptionChange
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomSubscriptionChange overwrites any union data inside the SubscriptionChange as the provided CustomSubscriptionChange
func (t *SubscriptionChange) FromCustomSubscriptionChange(v CustomSubscriptionChange) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomSubscriptionChange performs a merge with any union data inside the SubscriptionChange, using the provided CustomSubscriptionChange
func (t *SubscriptionChange) MergeCustomSubscriptionChange(v CustomSubscriptionChange) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SubscriptionChange) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SubscriptionChange) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlanSubscriptionCreate returns the union data inside the SubscriptionCreate as a PlanSubscriptionCreate
func (t SubscriptionCreate) AsPlanSubscriptionCreate() (PlanSubscriptionCreate, error) {
	var body PlanSubscriptionCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlanSubscriptionCreate overwrites any union data inside the SubscriptionCreate as the provided PlanSubscriptionCreate
func (t *SubscriptionCreate) FromPlanSubscriptionCreate(v PlanSubscriptionCreate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlanSubscriptionCreate performs a merge with any union data inside the SubscriptionCreate, using the provided PlanSubscriptionCreate
func (t *SubscriptionCreate) MergePlanSubscriptionCreate(v PlanSubscriptionCreate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomSubscriptionCreate returns the union data inside the SubscriptionCreate as a CustomSubscriptionCreate
func (t SubscriptionCreate) AsCustomSubscriptionCreate() (CustomSubscriptionCreate, error) {
	var body CustomSubscriptionCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomSubscriptionCreate overwrites any union data inside the SubscriptionCreate as the provided CustomSubscriptionCreate
func (t *SubscriptionCreate) FromCustomSubscriptionCreate(v CustomSubscriptionCreate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomSubscriptionCreate performs a merge with any union data inside the SubscriptionCreate, using the provided CustomSubscriptionCreate
func (t *SubscriptionCreate) MergeCustomSubscriptionCreate(v CustomSubscriptionCreate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SubscriptionCreate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SubscriptionCreate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEditSubscriptionAddItem returns the union data inside the SubscriptionEditOperation as a EditSubscriptionAddItem
func (t SubscriptionEditOperation) AsEditSubscriptionAddItem() (EditSubscriptionAddItem, error) {
	var body EditSubscriptionAddItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEditSubscriptionAddItem overwrites any union data inside the SubscriptionEditOperation as the provided EditSubscriptionAddItem
func (t *SubscriptionEditOperation) FromEditSubscriptionAddItem(v EditSubscriptionAddItem) error {
	v.Op = "add_item"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEditSubscriptionAddItem performs a merge with any union data inside the SubscriptionEditOperation, using the provided EditSubscriptionAddItem
func (t *SubscriptionEditOperation) MergeEditSubscriptionAddItem(v EditSubscriptionAddItem) error {
	v.Op = "add_item"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEditSubscriptionRemoveItem returns the union data inside the SubscriptionEditOperation as a EditSubscriptionRemoveItem
func (t SubscriptionEditOperation) AsEditSubscriptionRemoveItem() (EditSubscriptionRemoveItem, error) {
	var body EditSubscriptionRemoveItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEditSubscriptionRemoveItem overwrites any union data inside the SubscriptionEditOperation as the provided EditSubscriptionRemoveItem
func (t *SubscriptionEditOperation) FromEditSubscriptionRemoveItem(v EditSubscriptionRemoveItem) error {
	v.Op = "remove_item"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEditSubscriptionRemoveItem performs a merge with any union data inside the SubscriptionEditOperation, using the provided EditSubscriptionRemoveItem
func (t *SubscriptionEditOperation) MergeEditSubscriptionRemoveItem(v EditSubscriptionRemoveItem) error {
	v.Op = "remove_item"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEditSubscriptionAddPhase returns the union data inside the SubscriptionEditOperation as a EditSubscriptionAddPhase
func (t SubscriptionEditOperation) AsEditSubscriptionAddPhase() (EditSubscriptionAddPhase, error) {
	var body EditSubscriptionAddPhase
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEditSubscriptionAddPhase overwrites any union data inside the SubscriptionEditOperation as the provided EditSubscriptionAddPhase
func (t *SubscriptionEditOperation) FromEditSubscriptionAddPhase(v EditSubscriptionAddPhase) error {
	v.Op = "add_phase"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEditSubscriptionAddPhase performs a merge with any union data inside the SubscriptionEditOperation, using the provided EditSubscriptionAddPhase
func (t *SubscriptionEditOperation) MergeEditSubscriptionAddPhase(v EditSubscriptionAddPhase) error {
	v.Op = "add_phase"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEditSubscriptionRemovePhase returns the union data inside the SubscriptionEditOperation as a EditSubscriptionRemovePhase
func (t SubscriptionEditOperation) AsEditSubscriptionRemovePhase() (EditSubscriptionRemovePhase, error) {
	var body EditSubscriptionRemovePhase
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEditSubscriptionRemovePhase overwrites any union data inside the SubscriptionEditOperation as the provided EditSubscriptionRemovePhase
func (t *SubscriptionEditOperation) FromEditSubscriptionRemovePhase(v EditSubscriptionRemovePhase) error {
	v.Op = "remove_phase"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEditSubscriptionRemovePhase performs a merge with any union data inside the SubscriptionEditOperation, using the provided EditSubscriptionRemovePhase
func (t *SubscriptionEditOperation) MergeEditSubscriptionRemovePhase(v EditSubscriptionRemovePhase) error {
	v.Op = "remove_phase"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEditSubscriptionStretchPhase returns the union data inside the SubscriptionEditOperation as a EditSubscriptionStretchPhase
func (t SubscriptionEditOperation) AsEditSubscriptionStretchPhase() (EditSubscriptionStretchPhase, error) {
	var body EditSubscriptionStretchPhase
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEditSubscriptionStretchPhase overwrites any union data inside the SubscriptionEditOperation as the provided EditSubscriptionStretchPhase
func (t *SubscriptionEditOperation) FromEditSubscriptionStretchPhase(v EditSubscriptionStretchPhase) error {
	v.Op = "stretch_phase"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEditSubscriptionStretchPhase performs a merge with any union data inside the SubscriptionEditOperation, using the provided EditSubscriptionStretchPhase
func (t *SubscriptionEditOperation) MergeEditSubscriptionStretchPhase(v EditSubscriptionStretchPhase) error {
	v.Op = "stretch_phase"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEditSubscriptionUnscheduleEdit returns the union data inside the SubscriptionEditOperation as a EditSubscriptionUnscheduleEdit
func (t SubscriptionEditOperation) AsEditSubscriptionUnscheduleEdit() (EditSubscriptionUnscheduleEdit, error) {
	var body EditSubscriptionUnscheduleEdit
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEditSubscriptionUnscheduleEdit overwrites any union data inside the SubscriptionEditOperation as the provided EditSubscriptionUnscheduleEdit
func (t *SubscriptionEditOperation) FromEditSubscriptionUnscheduleEdit(v EditSubscriptionUnscheduleEdit) error {
	v.Op = "unschedule_edit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEditSubscriptionUnscheduleEdit performs a merge with any union data inside the SubscriptionEditOperation, using the provided EditSubscriptionUnscheduleEdit
func (t *SubscriptionEditOperation) MergeEditSubscriptionUnscheduleEdit(v EditSubscriptionUnscheduleEdit) error {
	v.Op = "unschedule_edit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SubscriptionEditOperation) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"op"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SubscriptionEditOperation) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "add_item":
		return t.AsEditSubscriptionAddItem()
	case "add_phase":
		return t.AsEditSubscriptionAddPhase()
	case "remove_item":
		return t.AsEditSubscriptionRemoveItem()
	case "remove_phase":
		return t.AsEditSubscriptionRemovePhase()
	case "stretch_phase":
		return t.AsEditSubscriptionStretchPhase()
	case "unschedule_edit":
		return t.AsEditSubscriptionUnscheduleEdit()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SubscriptionEditOperation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SubscriptionEditOperation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSubscriptionTimingEnum returns the union data inside the SubscriptionTiming as a SubscriptionTimingEnum
func (t SubscriptionTiming) AsSubscriptionTimingEnum() (SubscriptionTimingEnum, error) {
	var body SubscriptionTimingEnum
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubscriptionTimingEnum overwrites any union data inside the SubscriptionTiming as the provided SubscriptionTimingEnum
func (t *SubscriptionTiming) FromSubscriptionTimingEnum(v SubscriptionTimingEnum) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubscriptionTimingEnum performs a merge with any union data inside the SubscriptionTiming, using the provided SubscriptionTimingEnum
func (t *SubscriptionTiming) MergeSubscriptionTimingEnum(v SubscriptionTimingEnum) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubscriptionTiming1 returns the union data inside the SubscriptionTiming as a SubscriptionTiming1
func (t SubscriptionTiming) AsSubscriptionTiming1() (SubscriptionTiming1, error) {
	var body SubscriptionTiming1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubscriptionTiming1 overwrites any union data inside the SubscriptionTiming as the provided SubscriptionTiming1
func (t *SubscriptionTiming) FromSubscriptionTiming1(v SubscriptionTiming1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubscriptionTiming1 performs a merge with any union data inside the SubscriptionTiming, using the provided SubscriptionTiming1
func (t *SubscriptionTiming) MergeSubscriptionTiming1(v SubscriptionTiming1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SubscriptionTiming) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SubscriptionTiming) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVoidInvoiceLineDiscardAction returns the union data inside the VoidInvoiceLineActionCreate as a VoidInvoiceLineDiscardAction
func (t VoidInvoiceLineActionCreate) AsVoidInvoiceLineDiscardAction() (VoidInvoiceLineDiscardAction, error) {
	var body VoidInvoiceLineDiscardAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVoidInvoiceLineDiscardAction overwrites any union data inside the VoidInvoiceLineActionCreate as the provided VoidInvoiceLineDiscardAction
func (t *VoidInvoiceLineActionCreate) FromVoidInvoiceLineDiscardAction(v VoidInvoiceLineDiscardAction) error {
	v.Type = "discard"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVoidInvoiceLineDiscardAction performs a merge with any union data inside the VoidInvoiceLineActionCreate, using the provided VoidInvoiceLineDiscardAction
func (t *VoidInvoiceLineActionCreate) MergeVoidInvoiceLineDiscardAction(v VoidInvoiceLineDiscardAction) error {
	v.Type = "discard"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVoidInvoiceLinePendingActionCreate returns the union data inside the VoidInvoiceLineActionCreate as a VoidInvoiceLinePendingActionCreate
func (t VoidInvoiceLineActionCreate) AsVoidInvoiceLinePendingActionCreate() (VoidInvoiceLinePendingActionCreate, error) {
	var body VoidInvoiceLinePendingActionCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVoidInvoiceLinePendingActionCreate overwrites any union data inside the VoidInvoiceLineActionCreate as the provided VoidInvoiceLinePendingActionCreate
func (t *VoidInvoiceLineActionCreate) FromVoidInvoiceLinePendingActionCreate(v VoidInvoiceLinePendingActionCreate) error {
	v.Type = "pending"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVoidInvoiceLinePendingActionCreate performs a merge with any union data inside the VoidInvoiceLineActionCreate, using the provided VoidInvoiceLinePendingActionCreate
func (t *VoidInvoiceLineActionCreate) MergeVoidInvoiceLinePendingActionCreate(v VoidInvoiceLinePendingActionCreate) error {
	v.Type = "pending"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VoidInvoiceLineActionCreate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t VoidInvoiceLineActionCreate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "discard":
		return t.AsVoidInvoiceLineDiscardAction()
	case "pending":
		return t.AsVoidInvoiceLinePendingActionCreate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t VoidInvoiceLineActionCreate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VoidInvoiceLineActionCreate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVoidInvoiceLineDiscardAction returns the union data inside the VoidInvoiceLineActionCreateItem as a VoidInvoiceLineDiscardAction
func (t VoidInvoiceLineActionCreateItem) AsVoidInvoiceLineDiscardAction() (VoidInvoiceLineDiscardAction, error) {
	var body VoidInvoiceLineDiscardAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVoidInvoiceLineDiscardAction overwrites any union data inside the VoidInvoiceLineActionCreateItem as the provided VoidInvoiceLineDiscardAction
func (t *VoidInvoiceLineActionCreateItem) FromVoidInvoiceLineDiscardAction(v VoidInvoiceLineDiscardAction) error {
	v.Type = "discard"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVoidInvoiceLineDiscardAction performs a merge with any union data inside the VoidInvoiceLineActionCreateItem, using the provided VoidInvoiceLineDiscardAction
func (t *VoidInvoiceLineActionCreateItem) MergeVoidInvoiceLineDiscardAction(v VoidInvoiceLineDiscardAction) error {
	v.Type = "discard"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVoidInvoiceLinePendingActionCreateItem returns the union data inside the VoidInvoiceLineActionCreateItem as a VoidInvoiceLinePendingActionCreateItem
func (t VoidInvoiceLineActionCreateItem) AsVoidInvoiceLinePendingActionCreateItem() (VoidInvoiceLinePendingActionCreateItem, error) {
	var body VoidInvoiceLinePendingActionCreateItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVoidInvoiceLinePendingActionCreateItem overwrites any union data inside the VoidInvoiceLineActionCreateItem as the provided VoidInvoiceLinePendingActionCreateItem
func (t *VoidInvoiceLineActionCreateItem) FromVoidInvoiceLinePendingActionCreateItem(v VoidInvoiceLinePendingActionCreateItem) error {
	v.Type = "pending"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVoidInvoiceLinePendingActionCreateItem performs a merge with any union data inside the VoidInvoiceLineActionCreateItem, using the provided VoidInvoiceLinePendingActionCreateItem
func (t *VoidInvoiceLineActionCreateItem) MergeVoidInvoiceLinePendingActionCreateItem(v VoidInvoiceLinePendingActionCreateItem) error {
	v.Type = "pending"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VoidInvoiceLineActionCreateItem) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t VoidInvoiceLineActionCreateItem) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "discard":
		return t.AsVoidInvoiceLineDiscardAction()
	case "pending":
		return t.AsVoidInvoiceLinePendingActionCreateItem()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t VoidInvoiceLineActionCreateItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VoidInvoiceLineActionCreateItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAddons request
	ListAddons(ctx context.Context, params *ListAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAddonWithBody request with any body
	CreateAddonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAddon(ctx context.Context, body CreateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAddon request
	DeleteAddon(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddon request
	GetAddon(ctx context.Context, addonId string, params *GetAddonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAddonWithBody request with any body
	UpdateAddonWithBody(ctx context.Context, addonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAddon(ctx context.Context, addonId string, body UpdateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveAddon request
	ArchiveAddon(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishAddon request
	PublishAddon(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApps request
	ListApps(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppCustomInvoicingDraftSynchronizedWithBody request with any body
	AppCustomInvoicingDraftSynchronizedWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppCustomInvoicingDraftSynchronized(ctx context.Context, invoiceId string, body AppCustomInvoicingDraftSynchronizedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppCustomInvoicingIssuingSynchronizedWithBody request with any body
	AppCustomInvoicingIssuingSynchronizedWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppCustomInvoicingIssuingSynchronized(ctx context.Context, invoiceId string, body AppCustomInvoicingIssuingSynchronizedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppCustomInvoicingUpdatePaymentStatusWithBody request with any body
	AppCustomInvoicingUpdatePaymentStatusWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppCustomInvoicingUpdatePaymentStatus(ctx context.Context, invoiceId string, body AppCustomInvoicingUpdatePaymentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallApp request
	UninstallApp(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppWithBody request with any body
	UpdateAppWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApp(ctx context.Context, id string, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateStripeAPIKeyWithBody request with any body
	UpdateStripeAPIKeyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateStripeAPIKey(ctx context.Context, id string, body UpdateStripeAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppStripeWebhookWithBody request with any body
	AppStripeWebhookWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppStripeWebhook(ctx context.Context, id string, body AppStripeWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillingProfileCustomerOverrides request
	ListBillingProfileCustomerOverrides(ctx context.Context, params *ListBillingProfileCustomerOverridesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBillingProfileCustomerOverride request
	DeleteBillingProfileCustomerOverride(ctx context.Context, customerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingProfileCustomerOverride request
	GetBillingProfileCustomerOverride(ctx context.Context, customerId string, params *GetBillingProfileCustomerOverrideParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertBillingProfileCustomerOverrideWithBody request with any body
	UpsertBillingProfileCustomerOverrideWithBody(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertBillingProfileCustomerOverride(ctx context.Context, customerId string, body UpsertBillingProfileCustomerOverrideJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePendingInvoiceLineWithBody request with any body
	CreatePendingInvoiceLineWithBody(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePendingInvoiceLine(ctx context.Context, customerId string, body CreatePendingInvoiceLineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SimulateInvoiceWithBody request with any body
	SimulateInvoiceWithBody(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SimulateInvoice(ctx context.Context, customerId string, body SimulateInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoices request
	ListInvoices(ctx context.Context, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InvoicePendingLinesActionWithBody request with any body
	InvoicePendingLinesActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InvoicePendingLinesAction(ctx context.Context, body InvoicePendingLinesActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInvoice request
	DeleteInvoice(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoice request
	GetInvoice(ctx context.Context, invoiceId string, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInvoiceWithBody request with any body
	UpdateInvoiceWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInvoice(ctx context.Context, invoiceId string, body UpdateInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdvanceInvoiceAction request
	AdvanceInvoiceAction(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveInvoiceAction request
	ApproveInvoiceAction(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryInvoiceAction request
	RetryInvoiceAction(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecalculateInvoiceTaxAction request
	RecalculateInvoiceTaxAction(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VoidInvoiceActionWithBody request with any body
	VoidInvoiceActionWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VoidInvoiceAction(ctx context.Context, invoiceId string, body VoidInvoiceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillingProfiles request
	ListBillingProfiles(ctx context.Context, params *ListBillingProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBillingProfileWithBody request with any body
	CreateBillingProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBillingProfile(ctx context.Context, body CreateBillingProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBillingProfile request
	DeleteBillingProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingProfile request
	GetBillingProfile(ctx context.Context, id string, params *GetBillingProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBillingProfileWithBody request with any body
	UpdateBillingProfileWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBillingProfile(ctx context.Context, id string, body UpdateBillingProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomers request
	ListCustomers(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomerWithBody request with any body
	CreateCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomer(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomer request
	DeleteCustomer(ctx context.Context, customerIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomer request
	GetCustomer(ctx context.Context, customerIdOrKey string, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomerWithBody request with any body
	UpdateCustomerWithBody(ctx context.Context, customerIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomer(ctx context.Context, customerIdOrKey string, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerAccess request
	GetCustomerAccess(ctx context.Context, customerIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomerAppData request
	ListCustomerAppData(ctx context.Context, customerIdOrKey string, params *ListCustomerAppDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertCustomerAppDataWithBody request with any body
	UpsertCustomerAppDataWithBody(ctx context.Context, customerIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertCustomerAppData(ctx context.Context, customerIdOrKey string, body UpsertCustomerAppDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomerAppData request
	DeleteCustomerAppData(ctx context.Context, customerIdOrKey string, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerEntitlementValue request
	GetCustomerEntitlementValue(ctx context.Context, customerIdOrKey string, featureKey string, params *GetCustomerEntitlementValueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomerSubscriptions request
	ListCustomerSubscriptions(ctx context.Context, customerIdOrKey string, params *ListCustomerSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDebugMetrics request
	GetDebugMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEntitlements request
	ListEntitlements(ctx context.Context, params *ListEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntitlementById request
	GetEntitlementById(ctx context.Context, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvents request
	ListEvents(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IngestEventsWithBody request with any body
	IngestEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IngestEventsWithApplicationCloudeventsPlusJSONBody(ctx context.Context, body IngestEventsApplicationCloudeventsPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	IngestEventsWithApplicationCloudeventsBatchPlusJSONBody(ctx context.Context, body IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	IngestEvents(ctx context.Context, body IngestEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFeatures request
	ListFeatures(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFeatureWithBody request with any body
	CreateFeatureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFeature(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFeature request
	DeleteFeature(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeature request
	GetFeature(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGrants request
	ListGrants(ctx context.Context, params *ListGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VoidGrant request
	VoidGrant(ctx context.Context, grantId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCurrencies request
	ListCurrencies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgress request
	GetProgress(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMarketplaceListings request
	ListMarketplaceListings(ctx context.Context, params *ListMarketplaceListingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarketplaceListing request
	GetMarketplaceListing(ctx context.Context, pType AppType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarketplaceAppInstallWithBody request with any body
	MarketplaceAppInstallWithBody(ctx context.Context, pType MarketplaceInstallRequestType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarketplaceAppInstall(ctx context.Context, pType MarketplaceInstallRequestType, body MarketplaceAppInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarketplaceAppAPIKeyInstallWithBody request with any body
	MarketplaceAppAPIKeyInstallWithBody(ctx context.Context, pType MarketplaceApiKeyInstallRequestType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarketplaceAppAPIKeyInstall(ctx context.Context, pType MarketplaceApiKeyInstallRequestType, body MarketplaceAppAPIKeyInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarketplaceOAuth2InstallGetURL request
	MarketplaceOAuth2InstallGetURL(ctx context.Context, pType AppType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarketplaceOAuth2InstallAuthorize request
	MarketplaceOAuth2InstallAuthorize(ctx context.Context, pType MarketplaceOAuth2InstallAuthorizeRequestType, params *MarketplaceOAuth2InstallAuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMeters request
	ListMeters(ctx context.Context, params *ListMetersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMeterWithBody request with any body
	CreateMeterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMeter(ctx context.Context, body CreateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMeter request
	DeleteMeter(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeter request
	GetMeter(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMeterWithBody request with any body
	UpdateMeterWithBody(ctx context.Context, meterIdOrSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMeter(ctx context.Context, meterIdOrSlug string, body UpdateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryMeter request
	QueryMeter(ctx context.Context, meterIdOrSlug string, params *QueryMeterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryMeterPostWithBody request with any body
	QueryMeterPostWithBody(ctx context.Context, meterIdOrSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryMeterPost(ctx context.Context, meterIdOrSlug string, body QueryMeterPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMeterSubjects request
	ListMeterSubjects(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNotificationChannels request
	ListNotificationChannels(ctx context.Context, params *ListNotificationChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNotificationChannelWithBody request with any body
	CreateNotificationChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNotificationChannel(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotificationChannel request
	DeleteNotificationChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationChannel request
	GetNotificationChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNotificationChannelWithBody request with any body
	UpdateNotificationChannelWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNotificationChannel(ctx context.Context, channelId string, body UpdateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNotificationEvents request
	ListNotificationEvents(ctx context.Context, params *ListNotificationEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationEvent request
	GetNotificationEvent(ctx context.Context, eventId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNotificationRules request
	ListNotificationRules(ctx context.Context, params *ListNotificationRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNotificationRuleWithBody request with any body
	CreateNotificationRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNotificationRule(ctx context.Context, body CreateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotificationRule request
	DeleteNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationRule request
	GetNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNotificationRuleWithBody request with any body
	UpdateNotificationRuleWithBody(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNotificationRule(ctx context.Context, ruleId string, body UpdateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestNotificationRule request
	TestNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlans request
	ListPlans(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlanWithBody request with any body
	CreatePlanWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlan(ctx context.Context, body CreatePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NextPlan request
	NextPlan(ctx context.Context, planIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePlan request
	DeletePlan(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlan request
	GetPlan(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePlanWithBody request with any body
	UpdatePlanWithBody(ctx context.Context, planId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlan(ctx context.Context, planId string, body UpdatePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlanAddons request
	ListPlanAddons(ctx context.Context, planId string, params *ListPlanAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlanAddonWithBody request with any body
	CreatePlanAddonWithBody(ctx context.Context, planId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlanAddon(ctx context.Context, planId string, body CreatePlanAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePlanAddon request
	DeletePlanAddon(ctx context.Context, planId string, planAddonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlanAddon request
	GetPlanAddon(ctx context.Context, planId string, planAddonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePlanAddonWithBody request with any body
	UpdatePlanAddonWithBody(ctx context.Context, planId string, planAddonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlanAddon(ctx context.Context, planId string, planAddonId string, body UpdatePlanAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchivePlan request
	ArchivePlan(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishPlan request
	PublishPlan(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryPortalMeter request
	QueryPortalMeter(ctx context.Context, meterSlug string, params *QueryPortalMeterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPortalTokens request
	ListPortalTokens(ctx context.Context, params *ListPortalTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePortalTokenWithBody request with any body
	CreatePortalTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePortalToken(ctx context.Context, body CreatePortalTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InvalidatePortalTokensWithBody request with any body
	InvalidatePortalTokensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InvalidatePortalTokens(ctx context.Context, body InvalidatePortalTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStripeCheckoutSessionWithBody request with any body
	CreateStripeCheckoutSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStripeCheckoutSession(ctx context.Context, body CreateStripeCheckoutSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSubjects request
	ListSubjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertSubjectWithBody request with any body
	UpsertSubjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertSubject(ctx context.Context, body UpsertSubjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubject request
	DeleteSubject(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubject request
	GetSubject(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSubjectEntitlements request
	ListSubjectEntitlements(ctx context.Context, subjectIdOrKey string, params *ListSubjectEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEntitlementWithBody request with any body
	CreateEntitlementWithBody(ctx context.Context, subjectIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEntitlement(ctx context.Context, subjectIdOrKey string, body CreateEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEntitlementGrants request
	ListEntitlementGrants(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *ListEntitlementGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGrantWithBody request with any body
	CreateGrantWithBody(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGrant(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OverrideEntitlementWithBody request with any body
	OverrideEntitlementWithBody(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OverrideEntitlement(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body OverrideEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntitlementValue request
	GetEntitlementValue(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *GetEntitlementValueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEntitlement request
	DeleteEntitlement(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntitlement request
	GetEntitlement(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntitlementHistory request
	GetEntitlementHistory(ctx context.Context, subjectIdOrKey string, entitlementId string, params *GetEntitlementHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetEntitlementUsageWithBody request with any body
	ResetEntitlementUsageWithBody(ctx context.Context, subjectIdOrKey string, entitlementId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetEntitlementUsage(ctx context.Context, subjectIdOrKey string, entitlementId string, body ResetEntitlementUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscriptionWithBody request with any body
	CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubscription(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscription request
	DeleteSubscription(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscription request
	GetSubscription(ctx context.Context, subscriptionId string, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditSubscriptionWithBody request with any body
	EditSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditSubscription(ctx context.Context, subscriptionId string, body EditSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSubscriptionAddons request
	ListSubscriptionAddons(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscriptionAddonWithBody request with any body
	CreateSubscriptionAddonWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubscriptionAddon(ctx context.Context, subscriptionId string, body CreateSubscriptionAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionAddon request
	GetSubscriptionAddon(ctx context.Context, subscriptionId string, subscriptionAddonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSubscriptionAddonWithBody request with any body
	UpdateSubscriptionAddonWithBody(ctx context.Context, subscriptionId string, subscriptionAddonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSubscriptionAddon(ctx context.Context, subscriptionId string, subscriptionAddonId string, body UpdateSubscriptionAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelSubscriptionWithBody request with any body
	CancelSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelSubscription(ctx context.Context, subscriptionId string, body CancelSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeSubscriptionWithBody request with any body
	ChangeSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeSubscription(ctx context.Context, subscriptionId string, body ChangeSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateSubscriptionWithBody request with any body
	MigrateSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateSubscription(ctx context.Context, subscriptionId string, body MigrateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreSubscription request
	RestoreSubscription(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnscheduleCancelation request
	UnscheduleCancelation(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventsV2 request
	ListEventsV2(ctx context.Context, params *ListEventsV2Params, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAddons(ctx context.Context, params *ListAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAddonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAddonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAddonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAddon(ctx context.Context, body CreateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAddonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAddon(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAddonRequest(c.Server, addonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddon(ctx context.Context, addonId string, params *GetAddonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonRequest(c.Server, addonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAddonWithBody(ctx context.Context, addonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAddonRequestWithBody(c.Server, addonId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAddon(ctx context.Context, addonId string, body UpdateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAddonRequest(c.Server, addonId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAddon(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAddonRequest(c.Server, addonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishAddon(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishAddonRequest(c.Server, addonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApps(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppCustomInvoicingDraftSynchronizedWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppCustomInvoicingDraftSynchronizedRequestWithBody(c.Server, invoiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppCustomInvoicingDraftSynchronized(ctx context.Context, invoiceId string, body AppCustomInvoicingDraftSynchronizedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppCustomInvoicingDraftSynchronizedRequest(c.Server, invoiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppCustomInvoicingIssuingSynchronizedWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppCustomInvoicingIssuingSynchronizedRequestWithBody(c.Server, invoiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppCustomInvoicingIssuingSynchronized(ctx context.Context, invoiceId string, body AppCustomInvoicingIssuingSynchronizedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppCustomInvoicingIssuingSynchronizedRequest(c.Server, invoiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppCustomInvoicingUpdatePaymentStatusWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppCustomInvoicingUpdatePaymentStatusRequestWithBody(c.Server, invoiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppCustomInvoicingUpdatePaymentStatus(ctx context.Context, invoiceId string, body AppCustomInvoicingUpdatePaymentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppCustomInvoicingUpdatePaymentStatusRequest(c.Server, invoiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallApp(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallAppRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApp(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApp(ctx context.Context, id string, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStripeAPIKeyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStripeAPIKeyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStripeAPIKey(ctx context.Context, id string, body UpdateStripeAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStripeAPIKeyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppStripeWebhookWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppStripeWebhookRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppStripeWebhook(ctx context.Context, id string, body AppStripeWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppStripeWebhookRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingProfileCustomerOverrides(ctx context.Context, params *ListBillingProfileCustomerOverridesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingProfileCustomerOverridesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBillingProfileCustomerOverride(ctx context.Context, customerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBillingProfileCustomerOverrideRequest(c.Server, customerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingProfileCustomerOverride(ctx context.Context, customerId string, params *GetBillingProfileCustomerOverrideParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingProfileCustomerOverrideRequest(c.Server, customerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertBillingProfileCustomerOverrideWithBody(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertBillingProfileCustomerOverrideRequestWithBody(c.Server, customerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertBillingProfileCustomerOverride(ctx context.Context, customerId string, body UpsertBillingProfileCustomerOverrideJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertBillingProfileCustomerOverrideRequest(c.Server, customerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePendingInvoiceLineWithBody(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePendingInvoiceLineRequestWithBody(c.Server, customerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePendingInvoiceLine(ctx context.Context, customerId string, body CreatePendingInvoiceLineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePendingInvoiceLineRequest(c.Server, customerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SimulateInvoiceWithBody(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSimulateInvoiceRequestWithBody(c.Server, customerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SimulateInvoice(ctx context.Context, customerId string, body SimulateInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSimulateInvoiceRequest(c.Server, customerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoices(ctx context.Context, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvoicePendingLinesActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvoicePendingLinesActionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvoicePendingLinesAction(ctx context.Context, body InvoicePendingLinesActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvoicePendingLinesActionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvoice(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInvoiceRequest(c.Server, invoiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoice(ctx context.Context, invoiceId string, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoiceRequest(c.Server, invoiceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInvoiceWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInvoiceRequestWithBody(c.Server, invoiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInvoice(ctx context.Context, invoiceId string, body UpdateInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInvoiceRequest(c.Server, invoiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdvanceInvoiceAction(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdvanceInvoiceActionRequest(c.Server, invoiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveInvoiceAction(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveInvoiceActionRequest(c.Server, invoiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryInvoiceAction(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryInvoiceActionRequest(c.Server, invoiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecalculateInvoiceTaxAction(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecalculateInvoiceTaxActionRequest(c.Server, invoiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VoidInvoiceActionWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVoidInvoiceActionRequestWithBody(c.Server, invoiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VoidInvoiceAction(ctx context.Context, invoiceId string, body VoidInvoiceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVoidInvoiceActionRequest(c.Server, invoiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingProfiles(ctx context.Context, params *ListBillingProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingProfilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBillingProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBillingProfileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBillingProfile(ctx context.Context, body CreateBillingProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBillingProfileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBillingProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBillingProfileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingProfile(ctx context.Context, id string, params *GetBillingProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingProfileRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBillingProfileWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillingProfileRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBillingProfile(ctx context.Context, id string, body UpdateBillingProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillingProfileRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomers(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomer(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomer(ctx context.Context, customerIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomerRequest(c.Server, customerIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomer(ctx context.Context, customerIdOrKey string, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerRequest(c.Server, customerIdOrKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomerWithBody(ctx context.Context, customerIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerRequestWithBody(c.Server, customerIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomer(ctx context.Context, customerIdOrKey string, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerRequest(c.Server, customerIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerAccess(ctx context.Context, customerIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerAccessRequest(c.Server, customerIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomerAppData(ctx context.Context, customerIdOrKey string, params *ListCustomerAppDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomerAppDataRequest(c.Server, customerIdOrKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertCustomerAppDataWithBody(ctx context.Context, customerIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertCustomerAppDataRequestWithBody(c.Server, customerIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertCustomerAppData(ctx context.Context, customerIdOrKey string, body UpsertCustomerAppDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertCustomerAppDataRequest(c.Server, customerIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomerAppData(ctx context.Context, customerIdOrKey string, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomerAppDataRequest(c.Server, customerIdOrKey, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerEntitlementValue(ctx context.Context, customerIdOrKey string, featureKey string, params *GetCustomerEntitlementValueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerEntitlementValueRequest(c.Server, customerIdOrKey, featureKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomerSubscriptions(ctx context.Context, customerIdOrKey string, params *ListCustomerSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomerSubscriptionsRequest(c.Server, customerIdOrKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDebugMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDebugMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEntitlements(ctx context.Context, params *ListEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEntitlementsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntitlementById(ctx context.Context, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntitlementByIdRequest(c.Server, entitlementId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEvents(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestEventsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestEventsWithApplicationCloudeventsPlusJSONBody(ctx context.Context, body IngestEventsApplicationCloudeventsPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestEventsRequestWithApplicationCloudeventsPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestEventsWithApplicationCloudeventsBatchPlusJSONBody(ctx context.Context, body IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestEventsRequestWithApplicationCloudeventsBatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestEvents(ctx context.Context, body IngestEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestEventsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFeatures(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFeaturesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFeatureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFeatureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFeature(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFeatureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFeature(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFeatureRequest(c.Server, featureId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeature(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeatureRequest(c.Server, featureId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGrants(ctx context.Context, params *ListGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGrantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VoidGrant(ctx context.Context, grantId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVoidGrantRequest(c.Server, grantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCurrencies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCurrenciesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgress(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgressRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMarketplaceListings(ctx context.Context, params *ListMarketplaceListingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMarketplaceListingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarketplaceListing(ctx context.Context, pType AppType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketplaceListingRequest(c.Server, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceAppInstallWithBody(ctx context.Context, pType MarketplaceInstallRequestType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceAppInstallRequestWithBody(c.Server, pType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceAppInstall(ctx context.Context, pType MarketplaceInstallRequestType, body MarketplaceAppInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceAppInstallRequest(c.Server, pType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceAppAPIKeyInstallWithBody(ctx context.Context, pType MarketplaceApiKeyInstallRequestType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceAppAPIKeyInstallRequestWithBody(c.Server, pType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceAppAPIKeyInstall(ctx context.Context, pType MarketplaceApiKeyInstallRequestType, body MarketplaceAppAPIKeyInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceAppAPIKeyInstallRequest(c.Server, pType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceOAuth2InstallGetURL(ctx context.Context, pType AppType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceOAuth2InstallGetURLRequest(c.Server, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarketplaceOAuth2InstallAuthorize(ctx context.Context, pType MarketplaceOAuth2InstallAuthorizeRequestType, params *MarketplaceOAuth2InstallAuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarketplaceOAuth2InstallAuthorizeRequest(c.Server, pType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMeters(ctx context.Context, params *ListMetersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMetersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMeterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMeterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMeter(ctx context.Context, body CreateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMeterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMeter(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMeterRequest(c.Server, meterIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeter(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeterRequest(c.Server, meterIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMeterWithBody(ctx context.Context, meterIdOrSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMeterRequestWithBody(c.Server, meterIdOrSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMeter(ctx context.Context, meterIdOrSlug string, body UpdateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMeterRequest(c.Server, meterIdOrSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryMeter(ctx context.Context, meterIdOrSlug string, params *QueryMeterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryMeterRequest(c.Server, meterIdOrSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryMeterPostWithBody(ctx context.Context, meterIdOrSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryMeterPostRequestWithBody(c.Server, meterIdOrSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryMeterPost(ctx context.Context, meterIdOrSlug string, body QueryMeterPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryMeterPostRequest(c.Server, meterIdOrSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMeterSubjects(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMeterSubjectsRequest(c.Server, meterIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNotificationChannels(ctx context.Context, params *ListNotificationChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNotificationChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationChannelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationChannel(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationChannelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotificationChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationChannelRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationChannelRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationChannelWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationChannelRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationChannel(ctx context.Context, channelId string, body UpdateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationChannelRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNotificationEvents(ctx context.Context, params *ListNotificationEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNotificationEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationEvent(ctx context.Context, eventId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationEventRequest(c.Server, eventId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNotificationRules(ctx context.Context, params *ListNotificationRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNotificationRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationRule(ctx context.Context, body CreateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationRuleWithBody(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationRuleRequestWithBody(c.Server, ruleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationRule(ctx context.Context, ruleId string, body UpdateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationRuleRequest(c.Server, ruleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestNotificationRule(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestNotificationRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlans(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlanWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlanRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlan(ctx context.Context, body CreatePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlanRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NextPlan(ctx context.Context, planIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNextPlanRequest(c.Server, planIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePlan(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePlanRequest(c.Server, planId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlan(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanRequest(c.Server, planId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlanWithBody(ctx context.Context, planId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlanRequestWithBody(c.Server, planId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlan(ctx context.Context, planId string, body UpdatePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlanRequest(c.Server, planId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlanAddons(ctx context.Context, planId string, params *ListPlanAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlanAddonsRequest(c.Server, planId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlanAddonWithBody(ctx context.Context, planId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlanAddonRequestWithBody(c.Server, planId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlanAddon(ctx context.Context, planId string, body CreatePlanAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlanAddonRequest(c.Server, planId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePlanAddon(ctx context.Context, planId string, planAddonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePlanAddonRequest(c.Server, planId, planAddonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlanAddon(ctx context.Context, planId string, planAddonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanAddonRequest(c.Server, planId, planAddonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlanAddonWithBody(ctx context.Context, planId string, planAddonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlanAddonRequestWithBody(c.Server, planId, planAddonId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlanAddon(ctx context.Context, planId string, planAddonId string, body UpdatePlanAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlanAddonRequest(c.Server, planId, planAddonId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchivePlan(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchivePlanRequest(c.Server, planId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishPlan(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishPlanRequest(c.Server, planId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryPortalMeter(ctx context.Context, meterSlug string, params *QueryPortalMeterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryPortalMeterRequest(c.Server, meterSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPortalTokens(ctx context.Context, params *ListPortalTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPortalTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePortalTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePortalTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePortalToken(ctx context.Context, body CreatePortalTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePortalTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvalidatePortalTokensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvalidatePortalTokensRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvalidatePortalTokens(ctx context.Context, body InvalidatePortalTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvalidatePortalTokensRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStripeCheckoutSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStripeCheckoutSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStripeCheckoutSession(ctx context.Context, body CreateStripeCheckoutSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStripeCheckoutSessionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSubjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSubjectsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertSubjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertSubjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertSubject(ctx context.Context, body UpsertSubjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertSubjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubject(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubjectRequest(c.Server, subjectIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubject(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubjectRequest(c.Server, subjectIdOrKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSubjectEntitlements(ctx context.Context, subjectIdOrKey string, params *ListSubjectEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSubjectEntitlementsRequest(c.Server, subjectIdOrKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEntitlementWithBody(ctx context.Context, subjectIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEntitlementRequestWithBody(c.Server, subjectIdOrKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEntitlement(ctx context.Context, subjectIdOrKey string, body CreateEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEntitlementRequest(c.Server, subjectIdOrKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEntitlementGrants(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *ListEntitlementGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEntitlementGrantsRequest(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGrantWithBody(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGrantRequestWithBody(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGrant(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGrantRequest(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OverrideEntitlementWithBody(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOverrideEntitlementRequestWithBody(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OverrideEntitlement(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body OverrideEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOverrideEntitlementRequest(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntitlementValue(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *GetEntitlementValueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntitlementValueRequest(c.Server, subjectIdOrKey, entitlementIdOrFeatureKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEntitlement(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEntitlementRequest(c.Server, subjectIdOrKey, entitlementId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntitlement(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntitlementRequest(c.Server, subjectIdOrKey, entitlementId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntitlementHistory(ctx context.Context, subjectIdOrKey string, entitlementId string, params *GetEntitlementHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntitlementHistoryRequest(c.Server, subjectIdOrKey, entitlementId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetEntitlementUsageWithBody(ctx context.Context, subjectIdOrKey string, entitlementId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetEntitlementUsageRequestWithBody(c.Server, subjectIdOrKey, entitlementId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetEntitlementUsage(ctx context.Context, subjectIdOrKey string, entitlementId string, body ResetEntitlementUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetEntitlementUsageRequest(c.Server, subjectIdOrKey, entitlementId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscription(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscription(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscription(ctx context.Context, subscriptionId string, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionRequest(c.Server, subscriptionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditSubscriptionRequestWithBody(c.Server, subscriptionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditSubscription(ctx context.Context, subscriptionId string, body EditSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditSubscriptionRequest(c.Server, subscriptionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSubscriptionAddons(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSubscriptionAddonsRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionAddonWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionAddonRequestWithBody(c.Server, subscriptionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionAddon(ctx context.Context, subscriptionId string, body CreateSubscriptionAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionAddonRequest(c.Server, subscriptionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionAddon(ctx context.Context, subscriptionId string, subscriptionAddonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionAddonRequest(c.Server, subscriptionId, subscriptionAddonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubscriptionAddonWithBody(ctx context.Context, subscriptionId string, subscriptionAddonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubscriptionAddonRequestWithBody(c.Server, subscriptionId, subscriptionAddonId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubscriptionAddon(ctx context.Context, subscriptionId string, subscriptionAddonId string, body UpdateSubscriptionAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubscriptionAddonRequest(c.Server, subscriptionId, subscriptionAddonId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSubscriptionRequestWithBody(c.Server, subscriptionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSubscription(ctx context.Context, subscriptionId string, body CancelSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSubscriptionRequest(c.Server, subscriptionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeSubscriptionRequestWithBody(c.Server, subscriptionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeSubscription(ctx context.Context, subscriptionId string, body ChangeSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeSubscriptionRequest(c.Server, subscriptionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateSubscriptionRequestWithBody(c.Server, subscriptionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateSubscription(ctx context.Context, subscriptionId string, body MigrateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateSubscriptionRequest(c.Server, subscriptionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreSubscription(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnscheduleCancelation(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnscheduleCancelationRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventsV2(ctx context.Context, params *ListEventsV2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsV2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAddonsRequest generates requests for ListAddons
func NewListAddonsRequest(server string, params *ListAddonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/addons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "keyVersion", runtime.ParamLocationQuery, *params.KeyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Currency != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "currency", runtime.ParamLocationQuery, *params.Currency); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAddonRequest calls the generic CreateAddon builder with application/json body
func NewCreateAddonRequest(server string, body CreateAddonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAddonRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAddonRequestWithBody generates requests for CreateAddon with any type of body
func NewCreateAddonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/addons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAddonRequest generates requests for DeleteAddon
func NewDeleteAddonRequest(server string, addonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/addons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAddonRequest generates requests for GetAddon
func NewGetAddonRequest(server string, addonId string, params *GetAddonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/addons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeLatest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeLatest", runtime.ParamLocationQuery, *params.IncludeLatest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAddonRequest calls the generic UpdateAddon builder with application/json body
func NewUpdateAddonRequest(server string, addonId string, body UpdateAddonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAddonRequestWithBody(server, addonId, "application/json", bodyReader)
}

// NewUpdateAddonRequestWithBody generates requests for UpdateAddon with any type of body
func NewUpdateAddonRequestWithBody(server string, addonId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/addons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveAddonRequest generates requests for ArchiveAddon
func NewArchiveAddonRequest(server string, addonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/addons/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPublishAddonRequest generates requests for PublishAddon
func NewPublishAddonRequest(server string, addonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/addons/%s/publish", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, params *ListAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppCustomInvoicingDraftSynchronizedRequest calls the generic AppCustomInvoicingDraftSynchronized builder with application/json body
func NewAppCustomInvoicingDraftSynchronizedRequest(server string, invoiceId string, body AppCustomInvoicingDraftSynchronizedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppCustomInvoicingDraftSynchronizedRequestWithBody(server, invoiceId, "application/json", bodyReader)
}

// NewAppCustomInvoicingDraftSynchronizedRequestWithBody generates requests for AppCustomInvoicingDraftSynchronized with any type of body
func NewAppCustomInvoicingDraftSynchronizedRequestWithBody(server string, invoiceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/custom-invoicing/%s/draft/synchronized", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppCustomInvoicingIssuingSynchronizedRequest calls the generic AppCustomInvoicingIssuingSynchronized builder with application/json body
func NewAppCustomInvoicingIssuingSynchronizedRequest(server string, invoiceId string, body AppCustomInvoicingIssuingSynchronizedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppCustomInvoicingIssuingSynchronizedRequestWithBody(server, invoiceId, "application/json", bodyReader)
}

// NewAppCustomInvoicingIssuingSynchronizedRequestWithBody generates requests for AppCustomInvoicingIssuingSynchronized with any type of body
func NewAppCustomInvoicingIssuingSynchronizedRequestWithBody(server string, invoiceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/custom-invoicing/%s/issuing/synchronized", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppCustomInvoicingUpdatePaymentStatusRequest calls the generic AppCustomInvoicingUpdatePaymentStatus builder with application/json body
func NewAppCustomInvoicingUpdatePaymentStatusRequest(server string, invoiceId string, body AppCustomInvoicingUpdatePaymentStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppCustomInvoicingUpdatePaymentStatusRequestWithBody(server, invoiceId, "application/json", bodyReader)
}

// NewAppCustomInvoicingUpdatePaymentStatusRequestWithBody generates requests for AppCustomInvoicingUpdatePaymentStatus with any type of body
func NewAppCustomInvoicingUpdatePaymentStatusRequestWithBody(server string, invoiceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/custom-invoicing/%s/payment/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUninstallAppRequest generates requests for UninstallApp
func NewUninstallAppRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, id string, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateStripeAPIKeyRequest calls the generic UpdateStripeAPIKey builder with application/json body
func NewUpdateStripeAPIKeyRequest(server string, id string, body UpdateStripeAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateStripeAPIKeyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateStripeAPIKeyRequestWithBody generates requests for UpdateStripeAPIKey with any type of body
func NewUpdateStripeAPIKeyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/%s/stripe/api-key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppStripeWebhookRequest calls the generic AppStripeWebhook builder with application/json body
func NewAppStripeWebhookRequest(server string, id string, body AppStripeWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStripeWebhookRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppStripeWebhookRequestWithBody generates requests for AppStripeWebhook with any type of body
func NewAppStripeWebhookRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apps/%s/stripe/webhook", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBillingProfileCustomerOverridesRequest generates requests for ListBillingProfileCustomerOverrides
func NewListBillingProfileCustomerOverridesRequest(server string, params *ListBillingProfileCustomerOverridesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BillingProfile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "billingProfile", runtime.ParamLocationQuery, *params.BillingProfile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAllCustomers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeAllCustomers", runtime.ParamLocationQuery, *params.IncludeAllCustomers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customerId", runtime.ParamLocationQuery, *params.CustomerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomerName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "customerName", runtime.ParamLocationQuery, *params.CustomerName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomerKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "customerKey", runtime.ParamLocationQuery, *params.CustomerKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomerPrimaryEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "customerPrimaryEmail", runtime.ParamLocationQuery, *params.CustomerPrimaryEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBillingProfileCustomerOverrideRequest generates requests for DeleteBillingProfileCustomerOverride
func NewDeleteBillingProfileCustomerOverrideRequest(server string, customerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerId", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingProfileCustomerOverrideRequest generates requests for GetBillingProfileCustomerOverride
func NewGetBillingProfileCustomerOverrideRequest(server string, customerId string, params *GetBillingProfileCustomerOverrideParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerId", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertBillingProfileCustomerOverrideRequest calls the generic UpsertBillingProfileCustomerOverride builder with application/json body
func NewUpsertBillingProfileCustomerOverrideRequest(server string, customerId string, body UpsertBillingProfileCustomerOverrideJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertBillingProfileCustomerOverrideRequestWithBody(server, customerId, "application/json", bodyReader)
}

// NewUpsertBillingProfileCustomerOverrideRequestWithBody generates requests for UpsertBillingProfileCustomerOverride with any type of body
func NewUpsertBillingProfileCustomerOverrideRequestWithBody(server string, customerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerId", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePendingInvoiceLineRequest calls the generic CreatePendingInvoiceLine builder with application/json body
func NewCreatePendingInvoiceLineRequest(server string, customerId string, body CreatePendingInvoiceLineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePendingInvoiceLineRequestWithBody(server, customerId, "application/json", bodyReader)
}

// NewCreatePendingInvoiceLineRequestWithBody generates requests for CreatePendingInvoiceLine with any type of body
func NewCreatePendingInvoiceLineRequestWithBody(server string, customerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerId", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/customers/%s/invoices/pending-lines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSimulateInvoiceRequest calls the generic SimulateInvoice builder with application/json body
func NewSimulateInvoiceRequest(server string, customerId string, body SimulateInvoiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSimulateInvoiceRequestWithBody(server, customerId, "application/json", bodyReader)
}

// NewSimulateInvoiceRequestWithBody generates requests for SimulateInvoice with any type of body
func NewSimulateInvoiceRequestWithBody(server string, customerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerId", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/customers/%s/invoices/simulate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListInvoicesRequest generates requests for ListInvoices
func NewListInvoicesRequest(server string, params *ListInvoicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExtendedStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extendedStatuses", runtime.ParamLocationQuery, *params.ExtendedStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issuedAfter", runtime.ParamLocationQuery, *params.IssuedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssuedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issuedBefore", runtime.ParamLocationQuery, *params.IssuedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodStartAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "periodStartAfter", runtime.ParamLocationQuery, *params.PeriodStartAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodStartBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "periodStartBefore", runtime.ParamLocationQuery, *params.PeriodStartBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Customers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customers", runtime.ParamLocationQuery, *params.Customers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInvoicePendingLinesActionRequest calls the generic InvoicePendingLinesAction builder with application/json body
func NewInvoicePendingLinesActionRequest(server string, body InvoicePendingLinesActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInvoicePendingLinesActionRequestWithBody(server, "application/json", bodyReader)
}

// NewInvoicePendingLinesActionRequestWithBody generates requests for InvoicePendingLinesAction with any type of body
func NewInvoicePendingLinesActionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/invoices/invoice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInvoiceRequest generates requests for DeleteInvoice
func NewDeleteInvoiceRequest(server string, invoiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/invoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoiceRequest generates requests for GetInvoice
func NewGetInvoiceRequest(server string, invoiceId string, params *GetInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/invoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeletedLines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeletedLines", runtime.ParamLocationQuery, *params.IncludeDeletedLines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInvoiceRequest calls the generic UpdateInvoice builder with application/json body
func NewUpdateInvoiceRequest(server string, invoiceId string, body UpdateInvoiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInvoiceRequestWithBody(server, invoiceId, "application/json", bodyReader)
}

// NewUpdateInvoiceRequestWithBody generates requests for UpdateInvoice with any type of body
func NewUpdateInvoiceRequestWithBody(server string, invoiceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/invoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAdvanceInvoiceActionRequest generates requests for AdvanceInvoiceAction
func NewAdvanceInvoiceActionRequest(server string, invoiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/invoices/%s/advance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApproveInvoiceActionRequest generates requests for ApproveInvoiceAction
func NewApproveInvoiceActionRequest(server string, invoiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/invoices/%s/approve", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetryInvoiceActionRequest generates requests for RetryInvoiceAction
func NewRetryInvoiceActionRequest(server string, invoiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/invoices/%s/retry", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecalculateInvoiceTaxActionRequest generates requests for RecalculateInvoiceTaxAction
func NewRecalculateInvoiceTaxActionRequest(server string, invoiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/invoices/%s/taxes/recalculate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVoidInvoiceActionRequest calls the generic VoidInvoiceAction builder with application/json body
func NewVoidInvoiceActionRequest(server string, invoiceId string, body VoidInvoiceActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVoidInvoiceActionRequestWithBody(server, invoiceId, "application/json", bodyReader)
}

// NewVoidInvoiceActionRequestWithBody generates requests for VoidInvoiceAction with any type of body
func NewVoidInvoiceActionRequestWithBody(server string, invoiceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/invoices/%s/void", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBillingProfilesRequest generates requests for ListBillingProfiles
func NewListBillingProfilesRequest(server string, params *ListBillingProfilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeArchived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeArchived", runtime.ParamLocationQuery, *params.IncludeArchived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBillingProfileRequest calls the generic CreateBillingProfile builder with application/json body
func NewCreateBillingProfileRequest(server string, body CreateBillingProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBillingProfileRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBillingProfileRequestWithBody generates requests for CreateBillingProfile with any type of body
func NewCreateBillingProfileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBillingProfileRequest generates requests for DeleteBillingProfile
func NewDeleteBillingProfileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingProfileRequest generates requests for GetBillingProfile
func NewGetBillingProfileRequest(server string, id string, params *GetBillingProfileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBillingProfileRequest calls the generic UpdateBillingProfile builder with application/json body
func NewUpdateBillingProfileRequest(server string, id string, body UpdateBillingProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBillingProfileRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateBillingProfileRequestWithBody generates requests for UpdateBillingProfile with any type of body
func NewUpdateBillingProfileRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCustomersRequest generates requests for ListCustomers
func NewListCustomersRequest(server string, params *ListCustomersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "primaryEmail", runtime.ParamLocationQuery, *params.PrimaryEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlanKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "planKey", runtime.ParamLocationQuery, *params.PlanKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomerRequest calls the generic CreateCustomer builder with application/json body
func NewCreateCustomerRequest(server string, body CreateCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCustomerRequestWithBody generates requests for CreateCustomer with any type of body
func NewCreateCustomerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomerRequest generates requests for DeleteCustomer
func NewDeleteCustomerRequest(server string, customerIdOrKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomerRequest generates requests for GetCustomer
func NewGetCustomerRequest(server string, customerIdOrKey string, params *GetCustomerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomerRequest calls the generic UpdateCustomer builder with application/json body
func NewUpdateCustomerRequest(server string, customerIdOrKey string, body UpdateCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomerRequestWithBody(server, customerIdOrKey, "application/json", bodyReader)
}

// NewUpdateCustomerRequestWithBody generates requests for UpdateCustomer with any type of body
func NewUpdateCustomerRequestWithBody(server string, customerIdOrKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomerAccessRequest generates requests for GetCustomerAccess
func NewGetCustomerAccessRequest(server string, customerIdOrKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCustomerAppDataRequest generates requests for ListCustomerAppData
func NewListCustomerAppDataRequest(server string, customerIdOrKey string, params *ListCustomerAppDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertCustomerAppDataRequest calls the generic UpsertCustomerAppData builder with application/json body
func NewUpsertCustomerAppDataRequest(server string, customerIdOrKey string, body UpsertCustomerAppDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertCustomerAppDataRequestWithBody(server, customerIdOrKey, "application/json", bodyReader)
}

// NewUpsertCustomerAppDataRequestWithBody generates requests for UpsertCustomerAppData with any type of body
func NewUpsertCustomerAppDataRequestWithBody(server string, customerIdOrKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomerAppDataRequest generates requests for DeleteCustomerAppData
func NewDeleteCustomerAppDataRequest(server string, customerIdOrKey string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomerEntitlementValueRequest generates requests for GetCustomerEntitlementValue
func NewGetCustomerEntitlementValueRequest(server string, customerIdOrKey string, featureKey string, params *GetCustomerEntitlementValueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "featureKey", runtime.ParamLocationPath, featureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s/entitlements/%s/value", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCustomerSubscriptionsRequest generates requests for ListCustomerSubscriptions
func NewListCustomerSubscriptionsRequest(server string, customerIdOrKey string, params *ListCustomerSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerIdOrKey", runtime.ParamLocationPath, customerIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/customers/%s/subscriptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDebugMetricsRequest generates requests for GetDebugMetrics
func NewGetDebugMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/debug/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEntitlementsRequest generates requests for ListEntitlements
func NewListEntitlementsRequest(server string, params *ListEntitlementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/entitlements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Feature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feature", runtime.ParamLocationQuery, *params.Feature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntitlementType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entitlementType", runtime.ParamLocationQuery, *params.EntitlementType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeInactive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "excludeInactive", runtime.ParamLocationQuery, *params.ExcludeInactive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntitlementByIdRequest generates requests for GetEntitlementById
func NewGetEntitlementByIdRequest(server string, entitlementId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entitlementId", runtime.ParamLocationPath, entitlementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/entitlements/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventsRequest generates requests for ListEvents
func NewListEventsRequest(server string, params *ListEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "clientId", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IngestedAtFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ingestedAtFrom", runtime.ParamLocationQuery, *params.IngestedAtFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IngestedAtTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ingestedAtTo", runtime.ParamLocationQuery, *params.IngestedAtTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIngestEventsRequestWithApplicationCloudeventsPlusJSONBody calls the generic IngestEvents builder with application/cloudevents+json body
func NewIngestEventsRequestWithApplicationCloudeventsPlusJSONBody(server string, body IngestEventsApplicationCloudeventsPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIngestEventsRequestWithBody(server, "application/cloudevents+json", bodyReader)
}

// NewIngestEventsRequestWithApplicationCloudeventsBatchPlusJSONBody calls the generic IngestEvents builder with application/cloudevents-batch+json body
func NewIngestEventsRequestWithApplicationCloudeventsBatchPlusJSONBody(server string, body IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIngestEventsRequestWithBody(server, "application/cloudevents-batch+json", bodyReader)
}

// NewIngestEventsRequest calls the generic IngestEvents builder with application/json body
func NewIngestEventsRequest(server string, body IngestEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIngestEventsRequestWithBody(server, "application/json", bodyReader)
}

// NewIngestEventsRequestWithBody generates requests for IngestEvents with any type of body
func NewIngestEventsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFeaturesRequest generates requests for ListFeatures
func NewListFeaturesRequest(server string, params *ListFeaturesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MeterSlug != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meterSlug", runtime.ParamLocationQuery, *params.MeterSlug); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeArchived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeArchived", runtime.ParamLocationQuery, *params.IncludeArchived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFeatureRequest calls the generic CreateFeature builder with application/json body
func NewCreateFeatureRequest(server string, body CreateFeatureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFeatureRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFeatureRequestWithBody generates requests for CreateFeature with any type of body
func NewCreateFeatureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFeatureRequest generates requests for DeleteFeature
func NewDeleteFeatureRequest(server string, featureId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "featureId", runtime.ParamLocationPath, featureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/features/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeatureRequest generates requests for GetFeature
func NewGetFeatureRequest(server string, featureId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "featureId", runtime.ParamLocationPath, featureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/features/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGrantsRequest generates requests for ListGrants
func NewListGrantsRequest(server string, params *ListGrantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/grants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Feature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feature", runtime.ParamLocationQuery, *params.Feature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVoidGrantRequest generates requests for VoidGrant
func NewVoidGrantRequest(server string, grantId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "grantId", runtime.ParamLocationPath, grantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/grants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCurrenciesRequest generates requests for ListCurrencies
func NewListCurrenciesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/info/currencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgressRequest generates requests for GetProgress
func NewGetProgressRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/info/progress/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMarketplaceListingsRequest generates requests for ListMarketplaceListings
func NewListMarketplaceListingsRequest(server string, params *ListMarketplaceListingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/marketplace/listings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMarketplaceListingRequest generates requests for GetMarketplaceListing
func NewGetMarketplaceListingRequest(server string, pType AppType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/marketplace/listings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarketplaceAppInstallRequest calls the generic MarketplaceAppInstall builder with application/json body
func NewMarketplaceAppInstallRequest(server string, pType MarketplaceInstallRequestType, body MarketplaceAppInstallJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarketplaceAppInstallRequestWithBody(server, pType, "application/json", bodyReader)
}

// NewMarketplaceAppInstallRequestWithBody generates requests for MarketplaceAppInstall with any type of body
func NewMarketplaceAppInstallRequestWithBody(server string, pType MarketplaceInstallRequestType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/marketplace/listings/%s/install", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarketplaceAppAPIKeyInstallRequest calls the generic MarketplaceAppAPIKeyInstall builder with application/json body
func NewMarketplaceAppAPIKeyInstallRequest(server string, pType MarketplaceApiKeyInstallRequestType, body MarketplaceAppAPIKeyInstallJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarketplaceAppAPIKeyInstallRequestWithBody(server, pType, "application/json", bodyReader)
}

// NewMarketplaceAppAPIKeyInstallRequestWithBody generates requests for MarketplaceAppAPIKeyInstall with any type of body
func NewMarketplaceAppAPIKeyInstallRequestWithBody(server string, pType MarketplaceApiKeyInstallRequestType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/marketplace/listings/%s/install/apikey", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarketplaceOAuth2InstallGetURLRequest generates requests for MarketplaceOAuth2InstallGetURL
func NewMarketplaceOAuth2InstallGetURLRequest(server string, pType AppType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/marketplace/listings/%s/install/oauth2", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarketplaceOAuth2InstallAuthorizeRequest generates requests for MarketplaceOAuth2InstallAuthorize
func NewMarketplaceOAuth2InstallAuthorizeRequest(server string, pType MarketplaceOAuth2InstallAuthorizeRequestType, params *MarketplaceOAuth2InstallAuthorizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/marketplace/listings/%s/install/oauth2/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Error != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "error", runtime.ParamLocationQuery, *params.Error); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ErrorDescription != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "error_description", runtime.ParamLocationQuery, *params.ErrorDescription); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ErrorUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "error_uri", runtime.ParamLocationQuery, *params.ErrorUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMetersRequest generates requests for ListMeters
func NewListMetersRequest(server string, params *ListMetersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMeterRequest calls the generic CreateMeter builder with application/json body
func NewCreateMeterRequest(server string, body CreateMeterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMeterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMeterRequestWithBody generates requests for CreateMeter with any type of body
func NewCreateMeterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMeterRequest generates requests for DeleteMeter
func NewDeleteMeterRequest(server string, meterIdOrSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterIdOrSlug", runtime.ParamLocationPath, meterIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeterRequest generates requests for GetMeter
func NewGetMeterRequest(server string, meterIdOrSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterIdOrSlug", runtime.ParamLocationPath, meterIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMeterRequest calls the generic UpdateMeter builder with application/json body
func NewUpdateMeterRequest(server string, meterIdOrSlug string, body UpdateMeterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMeterRequestWithBody(server, meterIdOrSlug, "application/json", bodyReader)
}

// NewUpdateMeterRequestWithBody generates requests for UpdateMeter with any type of body
func NewUpdateMeterRequestWithBody(server string, meterIdOrSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterIdOrSlug", runtime.ParamLocationPath, meterIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryMeterRequest generates requests for QueryMeter
func NewQueryMeterRequest(server string, meterIdOrSlug string, params *QueryMeterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterIdOrSlug", runtime.ParamLocationPath, meterIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "clientId", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "windowSize", runtime.ParamLocationQuery, *params.WindowSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowTimeZone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "windowTimeZone", runtime.ParamLocationQuery, *params.WindowTimeZone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterGroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filterGroupBy", runtime.ParamLocationQuery, *params.FilterGroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryMeterPostRequest calls the generic QueryMeterPost builder with application/json body
func NewQueryMeterPostRequest(server string, meterIdOrSlug string, body QueryMeterPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryMeterPostRequestWithBody(server, meterIdOrSlug, "application/json", bodyReader)
}

// NewQueryMeterPostRequestWithBody generates requests for QueryMeterPost with any type of body
func NewQueryMeterPostRequestWithBody(server string, meterIdOrSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterIdOrSlug", runtime.ParamLocationPath, meterIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMeterSubjectsRequest generates requests for ListMeterSubjects
func NewListMeterSubjectsRequest(server string, meterIdOrSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterIdOrSlug", runtime.ParamLocationPath, meterIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meters/%s/subjects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNotificationChannelsRequest generates requests for ListNotificationChannels
func NewListNotificationChannelsRequest(server string, params *ListNotificationChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDisabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDisabled", runtime.ParamLocationQuery, *params.IncludeDisabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNotificationChannelRequest calls the generic CreateNotificationChannel builder with application/json body
func NewCreateNotificationChannelRequest(server string, body CreateNotificationChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNotificationChannelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNotificationChannelRequestWithBody generates requests for CreateNotificationChannel with any type of body
func NewCreateNotificationChannelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNotificationChannelRequest generates requests for DeleteNotificationChannel
func NewDeleteNotificationChannelRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationChannelRequest generates requests for GetNotificationChannel
func NewGetNotificationChannelRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNotificationChannelRequest calls the generic UpdateNotificationChannel builder with application/json body
func NewUpdateNotificationChannelRequest(server string, channelId string, body UpdateNotificationChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNotificationChannelRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewUpdateNotificationChannelRequestWithBody generates requests for UpdateNotificationChannel with any type of body
func NewUpdateNotificationChannelRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNotificationEventsRequest generates requests for ListNotificationEvents
func NewListNotificationEventsRequest(server string, params *ListNotificationEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Feature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feature", runtime.ParamLocationQuery, *params.Feature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rule", runtime.ParamLocationQuery, *params.Rule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Channel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel", runtime.ParamLocationQuery, *params.Channel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationEventRequest generates requests for GetNotificationEvent
func NewGetNotificationEventRequest(server string, eventId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "eventId", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNotificationRulesRequest generates requests for ListNotificationRules
func NewListNotificationRulesRequest(server string, params *ListNotificationRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDisabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDisabled", runtime.ParamLocationQuery, *params.IncludeDisabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Feature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feature", runtime.ParamLocationQuery, *params.Feature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Channel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel", runtime.ParamLocationQuery, *params.Channel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNotificationRuleRequest calls the generic CreateNotificationRule builder with application/json body
func NewCreateNotificationRuleRequest(server string, body CreateNotificationRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNotificationRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNotificationRuleRequestWithBody generates requests for CreateNotificationRule with any type of body
func NewCreateNotificationRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNotificationRuleRequest generates requests for DeleteNotificationRule
func NewDeleteNotificationRuleRequest(server string, ruleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationRuleRequest generates requests for GetNotificationRule
func NewGetNotificationRuleRequest(server string, ruleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNotificationRuleRequest calls the generic UpdateNotificationRule builder with application/json body
func NewUpdateNotificationRuleRequest(server string, ruleId string, body UpdateNotificationRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNotificationRuleRequestWithBody(server, ruleId, "application/json", bodyReader)
}

// NewUpdateNotificationRuleRequestWithBody generates requests for UpdateNotificationRule with any type of body
func NewUpdateNotificationRuleRequestWithBody(server string, ruleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestNotificationRuleRequest generates requests for TestNotificationRule
func NewTestNotificationRuleRequest(server string, ruleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/rules/%s/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlansRequest generates requests for ListPlans
func NewListPlansRequest(server string, params *ListPlansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "keyVersion", runtime.ParamLocationQuery, *params.KeyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Currency != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "currency", runtime.ParamLocationQuery, *params.Currency); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePlanRequest calls the generic CreatePlan builder with application/json body
func NewCreatePlanRequest(server string, body CreatePlanJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlanRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePlanRequestWithBody generates requests for CreatePlan with any type of body
func NewCreatePlanRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNextPlanRequest generates requests for NextPlan
func NewNextPlanRequest(server string, planIdOrKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planIdOrKey", runtime.ParamLocationPath, planIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s/next", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePlanRequest generates requests for DeletePlan
func NewDeletePlanRequest(server string, planId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlanRequest generates requests for GetPlan
func NewGetPlanRequest(server string, planId string, params *GetPlanParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeLatest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeLatest", runtime.ParamLocationQuery, *params.IncludeLatest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePlanRequest calls the generic UpdatePlan builder with application/json body
func NewUpdatePlanRequest(server string, planId string, body UpdatePlanJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePlanRequestWithBody(server, planId, "application/json", bodyReader)
}

// NewUpdatePlanRequestWithBody generates requests for UpdatePlan with any type of body
func NewUpdatePlanRequestWithBody(server string, planId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPlanAddonsRequest generates requests for ListPlanAddons
func NewListPlanAddonsRequest(server string, planId string, params *ListPlanAddonsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s/addons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "keyVersion", runtime.ParamLocationQuery, *params.KeyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePlanAddonRequest calls the generic CreatePlanAddon builder with application/json body
func NewCreatePlanAddonRequest(server string, planId string, body CreatePlanAddonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlanAddonRequestWithBody(server, planId, "application/json", bodyReader)
}

// NewCreatePlanAddonRequestWithBody generates requests for CreatePlanAddon with any type of body
func NewCreatePlanAddonRequestWithBody(server string, planId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s/addons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePlanAddonRequest generates requests for DeletePlanAddon
func NewDeletePlanAddonRequest(server string, planId string, planAddonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "planAddonId", runtime.ParamLocationPath, planAddonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s/addons/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlanAddonRequest generates requests for GetPlanAddon
func NewGetPlanAddonRequest(server string, planId string, planAddonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "planAddonId", runtime.ParamLocationPath, planAddonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s/addons/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePlanAddonRequest calls the generic UpdatePlanAddon builder with application/json body
func NewUpdatePlanAddonRequest(server string, planId string, planAddonId string, body UpdatePlanAddonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePlanAddonRequestWithBody(server, planId, planAddonId, "application/json", bodyReader)
}

// NewUpdatePlanAddonRequestWithBody generates requests for UpdatePlanAddon with any type of body
func NewUpdatePlanAddonRequestWithBody(server string, planId string, planAddonId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "planAddonId", runtime.ParamLocationPath, planAddonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s/addons/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchivePlanRequest generates requests for ArchivePlan
func NewArchivePlanRequest(server string, planId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPublishPlanRequest generates requests for PublishPlan
func NewPublishPlanRequest(server string, planId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/plans/%s/publish", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryPortalMeterRequest generates requests for QueryPortalMeter
func NewQueryPortalMeterRequest(server string, meterSlug string, params *QueryPortalMeterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterSlug", runtime.ParamLocationPath, meterSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/portal/meters/%s/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "clientId", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "windowSize", runtime.ParamLocationQuery, *params.WindowSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WindowTimeZone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "windowTimeZone", runtime.ParamLocationQuery, *params.WindowTimeZone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterGroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filterGroupBy", runtime.ParamLocationQuery, *params.FilterGroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPortalTokensRequest generates requests for ListPortalTokens
func NewListPortalTokensRequest(server string, params *ListPortalTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/portal/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePortalTokenRequest calls the generic CreatePortalToken builder with application/json body
func NewCreatePortalTokenRequest(server string, body CreatePortalTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePortalTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePortalTokenRequestWithBody generates requests for CreatePortalToken with any type of body
func NewCreatePortalTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/portal/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInvalidatePortalTokensRequest calls the generic InvalidatePortalTokens builder with application/json body
func NewInvalidatePortalTokensRequest(server string, body InvalidatePortalTokensJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInvalidatePortalTokensRequestWithBody(server, "application/json", bodyReader)
}

// NewInvalidatePortalTokensRequestWithBody generates requests for InvalidatePortalTokens with any type of body
func NewInvalidatePortalTokensRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/portal/tokens/invalidate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateStripeCheckoutSessionRequest calls the generic CreateStripeCheckoutSession builder with application/json body
func NewCreateStripeCheckoutSessionRequest(server string, body CreateStripeCheckoutSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStripeCheckoutSessionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateStripeCheckoutSessionRequestWithBody generates requests for CreateStripeCheckoutSession with any type of body
func NewCreateStripeCheckoutSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stripe/checkout/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSubjectsRequest generates requests for ListSubjects
func NewListSubjectsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertSubjectRequest calls the generic UpsertSubject builder with application/json body
func NewUpsertSubjectRequest(server string, body UpsertSubjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertSubjectRequestWithBody(server, "application/json", bodyReader)
}

// NewUpsertSubjectRequestWithBody generates requests for UpsertSubject with any type of body
func NewUpsertSubjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubjectRequest generates requests for DeleteSubject
func NewDeleteSubjectRequest(server string, subjectIdOrKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubjectRequest generates requests for GetSubject
func NewGetSubjectRequest(server string, subjectIdOrKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSubjectEntitlementsRequest generates requests for ListSubjectEntitlements
func NewListSubjectEntitlementsRequest(server string, subjectIdOrKey string, params *ListSubjectEntitlementsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEntitlementRequest calls the generic CreateEntitlement builder with application/json body
func NewCreateEntitlementRequest(server string, subjectIdOrKey string, body CreateEntitlementJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEntitlementRequestWithBody(server, subjectIdOrKey, "application/json", bodyReader)
}

// NewCreateEntitlementRequestWithBody generates requests for CreateEntitlement with any type of body
func NewCreateEntitlementRequestWithBody(server string, subjectIdOrKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEntitlementGrantsRequest generates requests for ListEntitlementGrants
func NewListEntitlementGrantsRequest(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *ListEntitlementGrantsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementIdOrFeatureKey", runtime.ParamLocationPath, entitlementIdOrFeatureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/grants", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGrantRequest calls the generic CreateGrant builder with application/json body
func NewCreateGrantRequest(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, body CreateGrantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGrantRequestWithBody(server, subjectIdOrKey, entitlementIdOrFeatureKey, "application/json", bodyReader)
}

// NewCreateGrantRequestWithBody generates requests for CreateGrant with any type of body
func NewCreateGrantRequestWithBody(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementIdOrFeatureKey", runtime.ParamLocationPath, entitlementIdOrFeatureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/grants", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOverrideEntitlementRequest calls the generic OverrideEntitlement builder with application/json body
func NewOverrideEntitlementRequest(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, body OverrideEntitlementJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOverrideEntitlementRequestWithBody(server, subjectIdOrKey, entitlementIdOrFeatureKey, "application/json", bodyReader)
}

// NewOverrideEntitlementRequestWithBody generates requests for OverrideEntitlement with any type of body
func NewOverrideEntitlementRequestWithBody(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementIdOrFeatureKey", runtime.ParamLocationPath, entitlementIdOrFeatureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/override", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEntitlementValueRequest generates requests for GetEntitlementValue
func NewGetEntitlementValueRequest(server string, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *GetEntitlementValueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementIdOrFeatureKey", runtime.ParamLocationPath, entitlementIdOrFeatureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/value", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteEntitlementRequest generates requests for DeleteEntitlement
func NewDeleteEntitlementRequest(server string, subjectIdOrKey string, entitlementId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementId", runtime.ParamLocationPath, entitlementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntitlementRequest generates requests for GetEntitlement
func NewGetEntitlementRequest(server string, subjectIdOrKey string, entitlementId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementId", runtime.ParamLocationPath, entitlementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntitlementHistoryRequest generates requests for GetEntitlementHistory
func NewGetEntitlementHistoryRequest(server string, subjectIdOrKey string, entitlementId string, params *GetEntitlementHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementId", runtime.ParamLocationPath, entitlementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/history", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "windowSize", runtime.ParamLocationQuery, params.WindowSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.WindowTimeZone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "windowTimeZone", runtime.ParamLocationQuery, *params.WindowTimeZone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetEntitlementUsageRequest calls the generic ResetEntitlementUsage builder with application/json body
func NewResetEntitlementUsageRequest(server string, subjectIdOrKey string, entitlementId string, body ResetEntitlementUsageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetEntitlementUsageRequestWithBody(server, subjectIdOrKey, entitlementId, "application/json", bodyReader)
}

// NewResetEntitlementUsageRequestWithBody generates requests for ResetEntitlementUsage with any type of body
func NewResetEntitlementUsageRequestWithBody(server string, subjectIdOrKey string, entitlementId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectIdOrKey", runtime.ParamLocationPath, subjectIdOrKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "entitlementId", runtime.ParamLocationPath, entitlementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subjects/%s/entitlements/%s/reset", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSubscriptionRequest calls the generic CreateSubscription builder with application/json body
func NewCreateSubscriptionRequest(server string, body CreateSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSubscriptionRequestWithBody generates requests for CreateSubscription with any type of body
func NewCreateSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscriptionRequest generates requests for DeleteSubscription
func NewDeleteSubscriptionRequest(server string, subscriptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionRequest generates requests for GetSubscription
func NewGetSubscriptionRequest(server string, subscriptionId string, params *GetSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditSubscriptionRequest calls the generic EditSubscription builder with application/json body
func NewEditSubscriptionRequest(server string, subscriptionId string, body EditSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditSubscriptionRequestWithBody(server, subscriptionId, "application/json", bodyReader)
}

// NewEditSubscriptionRequestWithBody generates requests for EditSubscription with any type of body
func NewEditSubscriptionRequestWithBody(server string, subscriptionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSubscriptionAddonsRequest generates requests for ListSubscriptionAddons
func NewListSubscriptionAddonsRequest(server string, subscriptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s/addons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubscriptionAddonRequest calls the generic CreateSubscriptionAddon builder with application/json body
func NewCreateSubscriptionAddonRequest(server string, subscriptionId string, body CreateSubscriptionAddonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubscriptionAddonRequestWithBody(server, subscriptionId, "application/json", bodyReader)
}

// NewCreateSubscriptionAddonRequestWithBody generates requests for CreateSubscriptionAddon with any type of body
func NewCreateSubscriptionAddonRequestWithBody(server string, subscriptionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s/addons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSubscriptionAddonRequest generates requests for GetSubscriptionAddon
func NewGetSubscriptionAddonRequest(server string, subscriptionId string, subscriptionAddonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subscriptionAddonId", runtime.ParamLocationPath, subscriptionAddonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s/addons/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSubscriptionAddonRequest calls the generic UpdateSubscriptionAddon builder with application/json body
func NewUpdateSubscriptionAddonRequest(server string, subscriptionId string, subscriptionAddonId string, body UpdateSubscriptionAddonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSubscriptionAddonRequestWithBody(server, subscriptionId, subscriptionAddonId, "application/json", bodyReader)
}

// NewUpdateSubscriptionAddonRequestWithBody generates requests for UpdateSubscriptionAddon with any type of body
func NewUpdateSubscriptionAddonRequestWithBody(server string, subscriptionId string, subscriptionAddonId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subscriptionAddonId", runtime.ParamLocationPath, subscriptionAddonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s/addons/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelSubscriptionRequest calls the generic CancelSubscription builder with application/json body
func NewCancelSubscriptionRequest(server string, subscriptionId string, body CancelSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelSubscriptionRequestWithBody(server, subscriptionId, "application/json", bodyReader)
}

// NewCancelSubscriptionRequestWithBody generates requests for CancelSubscription with any type of body
func NewCancelSubscriptionRequestWithBody(server string, subscriptionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChangeSubscriptionRequest calls the generic ChangeSubscription builder with application/json body
func NewChangeSubscriptionRequest(server string, subscriptionId string, body ChangeSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeSubscriptionRequestWithBody(server, subscriptionId, "application/json", bodyReader)
}

// NewChangeSubscriptionRequestWithBody generates requests for ChangeSubscription with any type of body
func NewChangeSubscriptionRequestWithBody(server string, subscriptionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s/change", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrateSubscriptionRequest calls the generic MigrateSubscription builder with application/json body
func NewMigrateSubscriptionRequest(server string, subscriptionId string, body MigrateSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateSubscriptionRequestWithBody(server, subscriptionId, "application/json", bodyReader)
}

// NewMigrateSubscriptionRequestWithBody generates requests for MigrateSubscription with any type of body
func NewMigrateSubscriptionRequestWithBody(server string, subscriptionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s/migrate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreSubscriptionRequest generates requests for RestoreSubscription
func NewRestoreSubscriptionRequest(server string, subscriptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnscheduleCancelationRequest generates requests for UnscheduleCancelation
func NewUnscheduleCancelationRequest(server string, subscriptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/subscriptions/%s/unschedule-cancelation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventsV2Request generates requests for ListEventsV2
func NewListEventsV2Request(server string, params *ListEventsV2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "clientId", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
				return nil, err
			} else {
				queryValues.Add("filter", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAddonsWithResponse request
	ListAddonsWithResponse(ctx context.Context, params *ListAddonsParams, reqEditors ...RequestEditorFn) (*ListAddonsResponse, error)

	// CreateAddonWithBodyWithResponse request with any body
	CreateAddonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAddonResponse, error)

	CreateAddonWithResponse(ctx context.Context, body CreateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAddonResponse, error)

	// DeleteAddonWithResponse request
	DeleteAddonWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*DeleteAddonResponse, error)

	// GetAddonWithResponse request
	GetAddonWithResponse(ctx context.Context, addonId string, params *GetAddonParams, reqEditors ...RequestEditorFn) (*GetAddonResponse, error)

	// UpdateAddonWithBodyWithResponse request with any body
	UpdateAddonWithBodyWithResponse(ctx context.Context, addonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAddonResponse, error)

	UpdateAddonWithResponse(ctx context.Context, addonId string, body UpdateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAddonResponse, error)

	// ArchiveAddonWithResponse request
	ArchiveAddonWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*ArchiveAddonResponse, error)

	// PublishAddonWithResponse request
	PublishAddonWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*PublishAddonResponse, error)

	// ListAppsWithResponse request
	ListAppsWithResponse(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// AppCustomInvoicingDraftSynchronizedWithBodyWithResponse request with any body
	AppCustomInvoicingDraftSynchronizedWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppCustomInvoicingDraftSynchronizedResponse, error)

	AppCustomInvoicingDraftSynchronizedWithResponse(ctx context.Context, invoiceId string, body AppCustomInvoicingDraftSynchronizedJSONRequestBody, reqEditors ...RequestEditorFn) (*AppCustomInvoicingDraftSynchronizedResponse, error)

	// AppCustomInvoicingIssuingSynchronizedWithBodyWithResponse request with any body
	AppCustomInvoicingIssuingSynchronizedWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppCustomInvoicingIssuingSynchronizedResponse, error)

	AppCustomInvoicingIssuingSynchronizedWithResponse(ctx context.Context, invoiceId string, body AppCustomInvoicingIssuingSynchronizedJSONRequestBody, reqEditors ...RequestEditorFn) (*AppCustomInvoicingIssuingSynchronizedResponse, error)

	// AppCustomInvoicingUpdatePaymentStatusWithBodyWithResponse request with any body
	AppCustomInvoicingUpdatePaymentStatusWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppCustomInvoicingUpdatePaymentStatusResponse, error)

	AppCustomInvoicingUpdatePaymentStatusWithResponse(ctx context.Context, invoiceId string, body AppCustomInvoicingUpdatePaymentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*AppCustomInvoicingUpdatePaymentStatusResponse, error)

	// UninstallAppWithResponse request
	UninstallAppWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UninstallAppResponse, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

	// UpdateAppWithBodyWithResponse request with any body
	UpdateAppWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	UpdateAppWithResponse(ctx context.Context, id string, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	// UpdateStripeAPIKeyWithBodyWithResponse request with any body
	UpdateStripeAPIKeyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStripeAPIKeyResponse, error)

	UpdateStripeAPIKeyWithResponse(ctx context.Context, id string, body UpdateStripeAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStripeAPIKeyResponse, error)

	// AppStripeWebhookWithBodyWithResponse request with any body
	AppStripeWebhookWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppStripeWebhookResponse, error)

	AppStripeWebhookWithResponse(ctx context.Context, id string, body AppStripeWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*AppStripeWebhookResponse, error)

	// ListBillingProfileCustomerOverridesWithResponse request
	ListBillingProfileCustomerOverridesWithResponse(ctx context.Context, params *ListBillingProfileCustomerOverridesParams, reqEditors ...RequestEditorFn) (*ListBillingProfileCustomerOverridesResponse, error)

	// DeleteBillingProfileCustomerOverrideWithResponse request
	DeleteBillingProfileCustomerOverrideWithResponse(ctx context.Context, customerId string, reqEditors ...RequestEditorFn) (*DeleteBillingProfileCustomerOverrideResponse, error)

	// GetBillingProfileCustomerOverrideWithResponse request
	GetBillingProfileCustomerOverrideWithResponse(ctx context.Context, customerId string, params *GetBillingProfileCustomerOverrideParams, reqEditors ...RequestEditorFn) (*GetBillingProfileCustomerOverrideResponse, error)

	// UpsertBillingProfileCustomerOverrideWithBodyWithResponse request with any body
	UpsertBillingProfileCustomerOverrideWithBodyWithResponse(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertBillingProfileCustomerOverrideResponse, error)

	UpsertBillingProfileCustomerOverrideWithResponse(ctx context.Context, customerId string, body UpsertBillingProfileCustomerOverrideJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertBillingProfileCustomerOverrideResponse, error)

	// CreatePendingInvoiceLineWithBodyWithResponse request with any body
	CreatePendingInvoiceLineWithBodyWithResponse(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePendingInvoiceLineResponse, error)

	CreatePendingInvoiceLineWithResponse(ctx context.Context, customerId string, body CreatePendingInvoiceLineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePendingInvoiceLineResponse, error)

	// SimulateInvoiceWithBodyWithResponse request with any body
	SimulateInvoiceWithBodyWithResponse(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SimulateInvoiceResponse, error)

	SimulateInvoiceWithResponse(ctx context.Context, customerId string, body SimulateInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*SimulateInvoiceResponse, error)

	// ListInvoicesWithResponse request
	ListInvoicesWithResponse(ctx context.Context, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*ListInvoicesResponse, error)

	// InvoicePendingLinesActionWithBodyWithResponse request with any body
	InvoicePendingLinesActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvoicePendingLinesActionResponse, error)

	InvoicePendingLinesActionWithResponse(ctx context.Context, body InvoicePendingLinesActionJSONRequestBody, reqEditors ...RequestEditorFn) (*InvoicePendingLinesActionResponse, error)

	// DeleteInvoiceWithResponse request
	DeleteInvoiceWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*DeleteInvoiceResponse, error)

	// GetInvoiceWithResponse request
	GetInvoiceWithResponse(ctx context.Context, invoiceId string, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*GetInvoiceResponse, error)

	// UpdateInvoiceWithBodyWithResponse request with any body
	UpdateInvoiceWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInvoiceResponse, error)

	UpdateInvoiceWithResponse(ctx context.Context, invoiceId string, body UpdateInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInvoiceResponse, error)

	// AdvanceInvoiceActionWithResponse request
	AdvanceInvoiceActionWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*AdvanceInvoiceActionResponse, error)

	// ApproveInvoiceActionWithResponse request
	ApproveInvoiceActionWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*ApproveInvoiceActionResponse, error)

	// RetryInvoiceActionWithResponse request
	RetryInvoiceActionWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*RetryInvoiceActionResponse, error)

	// RecalculateInvoiceTaxActionWithResponse request
	RecalculateInvoiceTaxActionWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*RecalculateInvoiceTaxActionResponse, error)

	// VoidInvoiceActionWithBodyWithResponse request with any body
	VoidInvoiceActionWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VoidInvoiceActionResponse, error)

	VoidInvoiceActionWithResponse(ctx context.Context, invoiceId string, body VoidInvoiceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*VoidInvoiceActionResponse, error)

	// ListBillingProfilesWithResponse request
	ListBillingProfilesWithResponse(ctx context.Context, params *ListBillingProfilesParams, reqEditors ...RequestEditorFn) (*ListBillingProfilesResponse, error)

	// CreateBillingProfileWithBodyWithResponse request with any body
	CreateBillingProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBillingProfileResponse, error)

	CreateBillingProfileWithResponse(ctx context.Context, body CreateBillingProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBillingProfileResponse, error)

	// DeleteBillingProfileWithResponse request
	DeleteBillingProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBillingProfileResponse, error)

	// GetBillingProfileWithResponse request
	GetBillingProfileWithResponse(ctx context.Context, id string, params *GetBillingProfileParams, reqEditors ...RequestEditorFn) (*GetBillingProfileResponse, error)

	// UpdateBillingProfileWithBodyWithResponse request with any body
	UpdateBillingProfileWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBillingProfileResponse, error)

	UpdateBillingProfileWithResponse(ctx context.Context, id string, body UpdateBillingProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillingProfileResponse, error)

	// ListCustomersWithResponse request
	ListCustomersWithResponse(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*ListCustomersResponse, error)

	// CreateCustomerWithBodyWithResponse request with any body
	CreateCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error)

	CreateCustomerWithResponse(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error)

	// DeleteCustomerWithResponse request
	DeleteCustomerWithResponse(ctx context.Context, customerIdOrKey string, reqEditors ...RequestEditorFn) (*DeleteCustomerResponse, error)

	// GetCustomerWithResponse request
	GetCustomerWithResponse(ctx context.Context, customerIdOrKey string, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error)

	// UpdateCustomerWithBodyWithResponse request with any body
	UpdateCustomerWithBodyWithResponse(ctx context.Context, customerIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error)

	UpdateCustomerWithResponse(ctx context.Context, customerIdOrKey string, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error)

	// GetCustomerAccessWithResponse request
	GetCustomerAccessWithResponse(ctx context.Context, customerIdOrKey string, reqEditors ...RequestEditorFn) (*GetCustomerAccessResponse, error)

	// ListCustomerAppDataWithResponse request
	ListCustomerAppDataWithResponse(ctx context.Context, customerIdOrKey string, params *ListCustomerAppDataParams, reqEditors ...RequestEditorFn) (*ListCustomerAppDataResponse, error)

	// UpsertCustomerAppDataWithBodyWithResponse request with any body
	UpsertCustomerAppDataWithBodyWithResponse(ctx context.Context, customerIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertCustomerAppDataResponse, error)

	UpsertCustomerAppDataWithResponse(ctx context.Context, customerIdOrKey string, body UpsertCustomerAppDataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertCustomerAppDataResponse, error)

	// DeleteCustomerAppDataWithResponse request
	DeleteCustomerAppDataWithResponse(ctx context.Context, customerIdOrKey string, appId string, reqEditors ...RequestEditorFn) (*DeleteCustomerAppDataResponse, error)

	// GetCustomerEntitlementValueWithResponse request
	GetCustomerEntitlementValueWithResponse(ctx context.Context, customerIdOrKey string, featureKey string, params *GetCustomerEntitlementValueParams, reqEditors ...RequestEditorFn) (*GetCustomerEntitlementValueResponse, error)

	// ListCustomerSubscriptionsWithResponse request
	ListCustomerSubscriptionsWithResponse(ctx context.Context, customerIdOrKey string, params *ListCustomerSubscriptionsParams, reqEditors ...RequestEditorFn) (*ListCustomerSubscriptionsResponse, error)

	// GetDebugMetricsWithResponse request
	GetDebugMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDebugMetricsResponse, error)

	// ListEntitlementsWithResponse request
	ListEntitlementsWithResponse(ctx context.Context, params *ListEntitlementsParams, reqEditors ...RequestEditorFn) (*ListEntitlementsResponse, error)

	// GetEntitlementByIdWithResponse request
	GetEntitlementByIdWithResponse(ctx context.Context, entitlementId string, reqEditors ...RequestEditorFn) (*GetEntitlementByIdResponse, error)

	// ListEventsWithResponse request
	ListEventsWithResponse(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResponse, error)

	// IngestEventsWithBodyWithResponse request with any body
	IngestEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error)

	IngestEventsWithApplicationCloudeventsPlusJSONBodyWithResponse(ctx context.Context, body IngestEventsApplicationCloudeventsPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error)

	IngestEventsWithApplicationCloudeventsBatchPlusJSONBodyWithResponse(ctx context.Context, body IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error)

	IngestEventsWithResponse(ctx context.Context, body IngestEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error)

	// ListFeaturesWithResponse request
	ListFeaturesWithResponse(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*ListFeaturesResponse, error)

	// CreateFeatureWithBodyWithResponse request with any body
	CreateFeatureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error)

	CreateFeatureWithResponse(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error)

	// DeleteFeatureWithResponse request
	DeleteFeatureWithResponse(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*DeleteFeatureResponse, error)

	// GetFeatureWithResponse request
	GetFeatureWithResponse(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*GetFeatureResponse, error)

	// ListGrantsWithResponse request
	ListGrantsWithResponse(ctx context.Context, params *ListGrantsParams, reqEditors ...RequestEditorFn) (*ListGrantsResponse, error)

	// VoidGrantWithResponse request
	VoidGrantWithResponse(ctx context.Context, grantId string, reqEditors ...RequestEditorFn) (*VoidGrantResponse, error)

	// ListCurrenciesWithResponse request
	ListCurrenciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCurrenciesResponse, error)

	// GetProgressWithResponse request
	GetProgressWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetProgressResponse, error)

	// ListMarketplaceListingsWithResponse request
	ListMarketplaceListingsWithResponse(ctx context.Context, params *ListMarketplaceListingsParams, reqEditors ...RequestEditorFn) (*ListMarketplaceListingsResponse, error)

	// GetMarketplaceListingWithResponse request
	GetMarketplaceListingWithResponse(ctx context.Context, pType AppType, reqEditors ...RequestEditorFn) (*GetMarketplaceListingResponse, error)

	// MarketplaceAppInstallWithBodyWithResponse request with any body
	MarketplaceAppInstallWithBodyWithResponse(ctx context.Context, pType MarketplaceInstallRequestType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarketplaceAppInstallResponse, error)

	MarketplaceAppInstallWithResponse(ctx context.Context, pType MarketplaceInstallRequestType, body MarketplaceAppInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*MarketplaceAppInstallResponse, error)

	// MarketplaceAppAPIKeyInstallWithBodyWithResponse request with any body
	MarketplaceAppAPIKeyInstallWithBodyWithResponse(ctx context.Context, pType MarketplaceApiKeyInstallRequestType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarketplaceAppAPIKeyInstallResponse, error)

	MarketplaceAppAPIKeyInstallWithResponse(ctx context.Context, pType MarketplaceApiKeyInstallRequestType, body MarketplaceAppAPIKeyInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*MarketplaceAppAPIKeyInstallResponse, error)

	// MarketplaceOAuth2InstallGetURLWithResponse request
	MarketplaceOAuth2InstallGetURLWithResponse(ctx context.Context, pType AppType, reqEditors ...RequestEditorFn) (*MarketplaceOAuth2InstallGetURLResponse, error)

	// MarketplaceOAuth2InstallAuthorizeWithResponse request
	MarketplaceOAuth2InstallAuthorizeWithResponse(ctx context.Context, pType MarketplaceOAuth2InstallAuthorizeRequestType, params *MarketplaceOAuth2InstallAuthorizeParams, reqEditors ...RequestEditorFn) (*MarketplaceOAuth2InstallAuthorizeResponse, error)

	// ListMetersWithResponse request
	ListMetersWithResponse(ctx context.Context, params *ListMetersParams, reqEditors ...RequestEditorFn) (*ListMetersResponse, error)

	// CreateMeterWithBodyWithResponse request with any body
	CreateMeterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMeterResponse, error)

	CreateMeterWithResponse(ctx context.Context, body CreateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMeterResponse, error)

	// DeleteMeterWithResponse request
	DeleteMeterWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*DeleteMeterResponse, error)

	// GetMeterWithResponse request
	GetMeterWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*GetMeterResponse, error)

	// UpdateMeterWithBodyWithResponse request with any body
	UpdateMeterWithBodyWithResponse(ctx context.Context, meterIdOrSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMeterResponse, error)

	UpdateMeterWithResponse(ctx context.Context, meterIdOrSlug string, body UpdateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMeterResponse, error)

	// QueryMeterWithResponse request
	QueryMeterWithResponse(ctx context.Context, meterIdOrSlug string, params *QueryMeterParams, reqEditors ...RequestEditorFn) (*QueryMeterResponse, error)

	// QueryMeterPostWithBodyWithResponse request with any body
	QueryMeterPostWithBodyWithResponse(ctx context.Context, meterIdOrSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryMeterPostResponse, error)

	QueryMeterPostWithResponse(ctx context.Context, meterIdOrSlug string, body QueryMeterPostJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryMeterPostResponse, error)

	// ListMeterSubjectsWithResponse request
	ListMeterSubjectsWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*ListMeterSubjectsResponse, error)

	// ListNotificationChannelsWithResponse request
	ListNotificationChannelsWithResponse(ctx context.Context, params *ListNotificationChannelsParams, reqEditors ...RequestEditorFn) (*ListNotificationChannelsResponse, error)

	// CreateNotificationChannelWithBodyWithResponse request with any body
	CreateNotificationChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error)

	CreateNotificationChannelWithResponse(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error)

	// DeleteNotificationChannelWithResponse request
	DeleteNotificationChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*DeleteNotificationChannelResponse, error)

	// GetNotificationChannelWithResponse request
	GetNotificationChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetNotificationChannelResponse, error)

	// UpdateNotificationChannelWithBodyWithResponse request with any body
	UpdateNotificationChannelWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelResponse, error)

	UpdateNotificationChannelWithResponse(ctx context.Context, channelId string, body UpdateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelResponse, error)

	// ListNotificationEventsWithResponse request
	ListNotificationEventsWithResponse(ctx context.Context, params *ListNotificationEventsParams, reqEditors ...RequestEditorFn) (*ListNotificationEventsResponse, error)

	// GetNotificationEventWithResponse request
	GetNotificationEventWithResponse(ctx context.Context, eventId string, reqEditors ...RequestEditorFn) (*GetNotificationEventResponse, error)

	// ListNotificationRulesWithResponse request
	ListNotificationRulesWithResponse(ctx context.Context, params *ListNotificationRulesParams, reqEditors ...RequestEditorFn) (*ListNotificationRulesResponse, error)

	// CreateNotificationRuleWithBodyWithResponse request with any body
	CreateNotificationRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationRuleResponse, error)

	CreateNotificationRuleWithResponse(ctx context.Context, body CreateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationRuleResponse, error)

	// DeleteNotificationRuleWithResponse request
	DeleteNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*DeleteNotificationRuleResponse, error)

	// GetNotificationRuleWithResponse request
	GetNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*GetNotificationRuleResponse, error)

	// UpdateNotificationRuleWithBodyWithResponse request with any body
	UpdateNotificationRuleWithBodyWithResponse(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationRuleResponse, error)

	UpdateNotificationRuleWithResponse(ctx context.Context, ruleId string, body UpdateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationRuleResponse, error)

	// TestNotificationRuleWithResponse request
	TestNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*TestNotificationRuleResponse, error)

	// ListPlansWithResponse request
	ListPlansWithResponse(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*ListPlansResponse, error)

	// CreatePlanWithBodyWithResponse request with any body
	CreatePlanWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlanResponse, error)

	CreatePlanWithResponse(ctx context.Context, body CreatePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlanResponse, error)

	// NextPlanWithResponse request
	NextPlanWithResponse(ctx context.Context, planIdOrKey string, reqEditors ...RequestEditorFn) (*NextPlanResponse, error)

	// DeletePlanWithResponse request
	DeletePlanWithResponse(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*DeletePlanResponse, error)

	// GetPlanWithResponse request
	GetPlanWithResponse(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*GetPlanResponse, error)

	// UpdatePlanWithBodyWithResponse request with any body
	UpdatePlanWithBodyWithResponse(ctx context.Context, planId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlanResponse, error)

	UpdatePlanWithResponse(ctx context.Context, planId string, body UpdatePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlanResponse, error)

	// ListPlanAddonsWithResponse request
	ListPlanAddonsWithResponse(ctx context.Context, planId string, params *ListPlanAddonsParams, reqEditors ...RequestEditorFn) (*ListPlanAddonsResponse, error)

	// CreatePlanAddonWithBodyWithResponse request with any body
	CreatePlanAddonWithBodyWithResponse(ctx context.Context, planId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlanAddonResponse, error)

	CreatePlanAddonWithResponse(ctx context.Context, planId string, body CreatePlanAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlanAddonResponse, error)

	// DeletePlanAddonWithResponse request
	DeletePlanAddonWithResponse(ctx context.Context, planId string, planAddonId string, reqEditors ...RequestEditorFn) (*DeletePlanAddonResponse, error)

	// GetPlanAddonWithResponse request
	GetPlanAddonWithResponse(ctx context.Context, planId string, planAddonId string, reqEditors ...RequestEditorFn) (*GetPlanAddonResponse, error)

	// UpdatePlanAddonWithBodyWithResponse request with any body
	UpdatePlanAddonWithBodyWithResponse(ctx context.Context, planId string, planAddonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlanAddonResponse, error)

	UpdatePlanAddonWithResponse(ctx context.Context, planId string, planAddonId string, body UpdatePlanAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlanAddonResponse, error)

	// ArchivePlanWithResponse request
	ArchivePlanWithResponse(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*ArchivePlanResponse, error)

	// PublishPlanWithResponse request
	PublishPlanWithResponse(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*PublishPlanResponse, error)

	// QueryPortalMeterWithResponse request
	QueryPortalMeterWithResponse(ctx context.Context, meterSlug string, params *QueryPortalMeterParams, reqEditors ...RequestEditorFn) (*QueryPortalMeterResponse, error)

	// ListPortalTokensWithResponse request
	ListPortalTokensWithResponse(ctx context.Context, params *ListPortalTokensParams, reqEditors ...RequestEditorFn) (*ListPortalTokensResponse, error)

	// CreatePortalTokenWithBodyWithResponse request with any body
	CreatePortalTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePortalTokenResponse, error)

	CreatePortalTokenWithResponse(ctx context.Context, body CreatePortalTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePortalTokenResponse, error)

	// InvalidatePortalTokensWithBodyWithResponse request with any body
	InvalidatePortalTokensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvalidatePortalTokensResponse, error)

	InvalidatePortalTokensWithResponse(ctx context.Context, body InvalidatePortalTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*InvalidatePortalTokensResponse, error)

	// CreateStripeCheckoutSessionWithBodyWithResponse request with any body
	CreateStripeCheckoutSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStripeCheckoutSessionResponse, error)

	CreateStripeCheckoutSessionWithResponse(ctx context.Context, body CreateStripeCheckoutSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStripeCheckoutSessionResponse, error)

	// ListSubjectsWithResponse request
	ListSubjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSubjectsResponse, error)

	// UpsertSubjectWithBodyWithResponse request with any body
	UpsertSubjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertSubjectResponse, error)

	UpsertSubjectWithResponse(ctx context.Context, body UpsertSubjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertSubjectResponse, error)

	// DeleteSubjectWithResponse request
	DeleteSubjectWithResponse(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*DeleteSubjectResponse, error)

	// GetSubjectWithResponse request
	GetSubjectWithResponse(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*GetSubjectResponse, error)

	// ListSubjectEntitlementsWithResponse request
	ListSubjectEntitlementsWithResponse(ctx context.Context, subjectIdOrKey string, params *ListSubjectEntitlementsParams, reqEditors ...RequestEditorFn) (*ListSubjectEntitlementsResponse, error)

	// CreateEntitlementWithBodyWithResponse request with any body
	CreateEntitlementWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEntitlementResponse, error)

	CreateEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, body CreateEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEntitlementResponse, error)

	// ListEntitlementGrantsWithResponse request
	ListEntitlementGrantsWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *ListEntitlementGrantsParams, reqEditors ...RequestEditorFn) (*ListEntitlementGrantsResponse, error)

	// CreateGrantWithBodyWithResponse request with any body
	CreateGrantWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error)

	CreateGrantWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error)

	// OverrideEntitlementWithBodyWithResponse request with any body
	OverrideEntitlementWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OverrideEntitlementResponse, error)

	OverrideEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body OverrideEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*OverrideEntitlementResponse, error)

	// GetEntitlementValueWithResponse request
	GetEntitlementValueWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *GetEntitlementValueParams, reqEditors ...RequestEditorFn) (*GetEntitlementValueResponse, error)

	// DeleteEntitlementWithResponse request
	DeleteEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*DeleteEntitlementResponse, error)

	// GetEntitlementWithResponse request
	GetEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*GetEntitlementResponse, error)

	// GetEntitlementHistoryWithResponse request
	GetEntitlementHistoryWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, params *GetEntitlementHistoryParams, reqEditors ...RequestEditorFn) (*GetEntitlementHistoryResponse, error)

	// ResetEntitlementUsageWithBodyWithResponse request with any body
	ResetEntitlementUsageWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetEntitlementUsageResponse, error)

	ResetEntitlementUsageWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, body ResetEntitlementUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetEntitlementUsageResponse, error)

	// CreateSubscriptionWithBodyWithResponse request with any body
	CreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	CreateSubscriptionWithResponse(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	// DeleteSubscriptionWithResponse request
	DeleteSubscriptionWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error)

	// GetSubscriptionWithResponse request
	GetSubscriptionWithResponse(ctx context.Context, subscriptionId string, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error)

	// EditSubscriptionWithBodyWithResponse request with any body
	EditSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditSubscriptionResponse, error)

	EditSubscriptionWithResponse(ctx context.Context, subscriptionId string, body EditSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*EditSubscriptionResponse, error)

	// ListSubscriptionAddonsWithResponse request
	ListSubscriptionAddonsWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*ListSubscriptionAddonsResponse, error)

	// CreateSubscriptionAddonWithBodyWithResponse request with any body
	CreateSubscriptionAddonWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionAddonResponse, error)

	CreateSubscriptionAddonWithResponse(ctx context.Context, subscriptionId string, body CreateSubscriptionAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionAddonResponse, error)

	// GetSubscriptionAddonWithResponse request
	GetSubscriptionAddonWithResponse(ctx context.Context, subscriptionId string, subscriptionAddonId string, reqEditors ...RequestEditorFn) (*GetSubscriptionAddonResponse, error)

	// UpdateSubscriptionAddonWithBodyWithResponse request with any body
	UpdateSubscriptionAddonWithBodyWithResponse(ctx context.Context, subscriptionId string, subscriptionAddonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubscriptionAddonResponse, error)

	UpdateSubscriptionAddonWithResponse(ctx context.Context, subscriptionId string, subscriptionAddonId string, body UpdateSubscriptionAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubscriptionAddonResponse, error)

	// CancelSubscriptionWithBodyWithResponse request with any body
	CancelSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelSubscriptionResponse, error)

	CancelSubscriptionWithResponse(ctx context.Context, subscriptionId string, body CancelSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelSubscriptionResponse, error)

	// ChangeSubscriptionWithBodyWithResponse request with any body
	ChangeSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeSubscriptionResponse, error)

	ChangeSubscriptionWithResponse(ctx context.Context, subscriptionId string, body ChangeSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeSubscriptionResponse, error)

	// MigrateSubscriptionWithBodyWithResponse request with any body
	MigrateSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateSubscriptionResponse, error)

	MigrateSubscriptionWithResponse(ctx context.Context, subscriptionId string, body MigrateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateSubscriptionResponse, error)

	// RestoreSubscriptionWithResponse request
	RestoreSubscriptionWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*RestoreSubscriptionResponse, error)

	// UnscheduleCancelationWithResponse request
	UnscheduleCancelationWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*UnscheduleCancelationResponse, error)

	// ListEventsV2WithResponse request
	ListEventsV2WithResponse(ctx context.Context, params *ListEventsV2Params, reqEditors ...RequestEditorFn) (*ListEventsV2Response, error)
}

type ListAddonsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *AddonPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListAddonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAddonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Addon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Addon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Addon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Addon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ArchiveAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Addon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r PublishAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *AppPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppCustomInvoicingDraftSynchronizedResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r AppCustomInvoicingDraftSynchronizedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppCustomInvoicingDraftSynchronizedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppCustomInvoicingIssuingSynchronizedResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r AppCustomInvoicingIssuingSynchronizedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppCustomInvoicingIssuingSynchronizedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppCustomInvoicingUpdatePaymentStatusResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r AppCustomInvoicingUpdatePaymentStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppCustomInvoicingUpdatePaymentStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallAppResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UninstallAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *App
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *App
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateStripeAPIKeyResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateStripeAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStripeAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStripeWebhookResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *StripeWebhookResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r AppStripeWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStripeWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillingProfileCustomerOverridesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *BillingProfileCustomerOverrideWithDetailsPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListBillingProfileCustomerOverridesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillingProfileCustomerOverridesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBillingProfileCustomerOverrideResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteBillingProfileCustomerOverrideResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBillingProfileCustomerOverrideResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingProfileCustomerOverrideResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *BillingProfileCustomerOverrideWithDetails
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetBillingProfileCustomerOverrideResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingProfileCustomerOverrideResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertBillingProfileCustomerOverrideResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *BillingProfileCustomerOverrideWithDetails
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpsertBillingProfileCustomerOverrideResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertBillingProfileCustomerOverrideResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePendingInvoiceLineResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *InvoicePendingLineCreateResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreatePendingInvoiceLineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePendingInvoiceLineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SimulateInvoiceResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Invoice
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r SimulateInvoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SimulateInvoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *InvoicePaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListInvoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InvoicePendingLinesActionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *[]Invoice
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r InvoicePendingLinesActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InvoicePendingLinesActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInvoiceResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteInvoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInvoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoiceResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Invoice
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetInvoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInvoiceResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Invoice
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateInvoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInvoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdvanceInvoiceActionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Invoice
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r AdvanceInvoiceActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdvanceInvoiceActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveInvoiceActionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Invoice
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ApproveInvoiceActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveInvoiceActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryInvoiceActionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Invoice
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r RetryInvoiceActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryInvoiceActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecalculateInvoiceTaxActionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Invoice
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r RecalculateInvoiceTaxActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecalculateInvoiceTaxActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VoidInvoiceActionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Invoice
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r VoidInvoiceActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VoidInvoiceActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillingProfilesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *BillingProfilePaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListBillingProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillingProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBillingProfileResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *BillingProfile
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateBillingProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBillingProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBillingProfileResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteBillingProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBillingProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingProfileResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *BillingProfile
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetBillingProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBillingProfileResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *BillingProfile
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateBillingProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBillingProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *CustomerPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomerResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Customer
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomerResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Customer
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomerResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Customer
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerAccessResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *CustomerAccess
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetCustomerAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomerAppDataResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *CustomerAppDataPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListCustomerAppDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomerAppDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertCustomerAppDataResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]CustomerAppData
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpsertCustomerAppDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertCustomerAppDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomerAppDataResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerAppDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerAppDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerEntitlementValueResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *EntitlementValue
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetCustomerEntitlementValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerEntitlementValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomerSubscriptionsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *SubscriptionPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListCustomerSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomerSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDebugMetricsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetDebugMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDebugMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEntitlementsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *ListEntitlementsResult
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListEntitlementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEntitlementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntitlementByIdResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Entitlement
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetEntitlementByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntitlementByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]IngestedEvent
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IngestEventsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r IngestEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IngestEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFeaturesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *ListFeaturesResult
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFeatureResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Feature
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFeatureResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeatureResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Feature
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGrantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}
type ListGrants2000 = []EntitlementGrant

// Status returns HTTPResponse.Status
func (r ListGrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VoidGrantResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r VoidGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VoidGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCurrenciesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]Currency
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListCurrenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCurrenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgressResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Progress
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMarketplaceListingsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MarketplaceListingPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListMarketplaceListingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMarketplaceListingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketplaceListingResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MarketplaceListing
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetMarketplaceListingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketplaceListingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarketplaceAppInstallResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MarketplaceInstallResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r MarketplaceAppInstallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarketplaceAppInstallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarketplaceAppAPIKeyInstallResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MarketplaceInstallResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r MarketplaceAppAPIKeyInstallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarketplaceAppAPIKeyInstallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarketplaceOAuth2InstallGetURLResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *ClientAppStartResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r MarketplaceOAuth2InstallGetURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarketplaceOAuth2InstallGetURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarketplaceOAuth2InstallAuthorizeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r MarketplaceOAuth2InstallAuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarketplaceOAuth2InstallAuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMetersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]Meter
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListMetersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Meter
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Meter
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Meter
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MeterQueryResult
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r QueryMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryMeterPostResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MeterQueryResult
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r QueryMeterPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryMeterPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMeterSubjectsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]string
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListMeterSubjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMeterSubjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNotificationChannelsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationChannelPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListNotificationChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNotificationChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNotificationChannelResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *NotificationChannel
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateNotificationChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNotificationChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationChannelResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationChannelResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationChannel
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetNotificationChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNotificationChannelResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationChannel
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateNotificationChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNotificationChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNotificationEventsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationEventPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListNotificationEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNotificationEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationEventResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationEvent
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetNotificationEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNotificationRulesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationRulePaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListNotificationRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNotificationRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNotificationRuleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *NotificationRule
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateNotificationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNotificationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationRuleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationRuleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationRule
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetNotificationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNotificationRuleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *NotificationRule
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateNotificationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNotificationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestNotificationRuleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *NotificationEvent
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r TestNotificationRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestNotificationRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlansResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *PlanPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlanResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Plan
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreatePlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NextPlanResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Plan
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r NextPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NextPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePlanResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeletePlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Plan
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePlanResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Plan
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlanAddonsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *PlanAddonPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListPlanAddonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlanAddonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlanAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *PlanAddon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreatePlanAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlanAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePlanAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeletePlanAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePlanAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *PlanAddon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetPlanAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePlanAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *PlanAddon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePlanAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePlanAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchivePlanResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Plan
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ArchivePlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchivePlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishPlanResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Plan
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r PublishPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryPortalMeterResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MeterQueryResult
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r QueryPortalMeterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryPortalMeterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPortalTokensResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]PortalToken
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListPortalTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPortalTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePortalTokenResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *PortalToken
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreatePortalTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePortalTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InvalidatePortalTokensResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r InvalidatePortalTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InvalidatePortalTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStripeCheckoutSessionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *CreateStripeCheckoutSessionResult
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateStripeCheckoutSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStripeCheckoutSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSubjectsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]Subject
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListSubjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSubjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertSubjectResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]Subject
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpsertSubjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertSubjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubjectResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteSubjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubjectResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Subject
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetSubjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSubjectEntitlementsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]Entitlement
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListSubjectEntitlementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSubjectEntitlementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEntitlementResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Entitlement
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateEntitlementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEntitlementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEntitlementGrantsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]EntitlementGrant
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListEntitlementGrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEntitlementGrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGrantResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *EntitlementGrant
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OverrideEntitlementResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Entitlement
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r OverrideEntitlementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OverrideEntitlementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntitlementValueResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *EntitlementValue
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetEntitlementValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntitlementValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEntitlementResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteEntitlementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEntitlementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntitlementResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Entitlement
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetEntitlementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntitlementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntitlementHistoryResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *WindowedBalanceHistory
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetEntitlementHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntitlementHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetEntitlementUsageResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ResetEntitlementUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetEntitlementUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *Subscription
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *SubscriptionExpanded
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditSubscriptionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Subscription
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r EditSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSubscriptionAddonsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]SubscriptionAddon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListSubscriptionAddonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSubscriptionAddonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *SubscriptionAddon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *SubscriptionAddon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSubscriptionAddonResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *SubscriptionAddon
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UpdateSubscriptionAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSubscriptionAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSubscriptionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Subscription
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r CancelSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeSubscriptionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *SubscriptionChangeResponseBody
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ChangeSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateSubscriptionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *SubscriptionChangeResponseBody
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r MigrateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreSubscriptionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Subscription
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r RestoreSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnscheduleCancelationResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *Subscription
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON404     *NotFoundProblemResponse
	ApplicationproblemJSON409     *ConflictProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r UnscheduleCancelationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnscheduleCancelationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsV2Response struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *IngestedEventCursorPaginatedResponse
	ApplicationproblemJSON400     *BadRequestProblemResponse
	ApplicationproblemJSON401     *UnauthorizedProblemResponse
	ApplicationproblemJSON403     *ForbiddenProblemResponse
	ApplicationproblemJSON412     *PreconditionFailedProblemResponse
	ApplicationproblemJSON500     *InternalServerErrorProblemResponse
	ApplicationproblemJSON503     *ServiceUnavailableProblemResponse
	ApplicationproblemJSONDefault *UnexpectedProblemResponse
}

// Status returns HTTPResponse.Status
func (r ListEventsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAddonsWithResponse request returning *ListAddonsResponse
func (c *ClientWithResponses) ListAddonsWithResponse(ctx context.Context, params *ListAddonsParams, reqEditors ...RequestEditorFn) (*ListAddonsResponse, error) {
	rsp, err := c.ListAddons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAddonsResponse(rsp)
}

// CreateAddonWithBodyWithResponse request with arbitrary body returning *CreateAddonResponse
func (c *ClientWithResponses) CreateAddonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAddonResponse, error) {
	rsp, err := c.CreateAddonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAddonResponse(rsp)
}

func (c *ClientWithResponses) CreateAddonWithResponse(ctx context.Context, body CreateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAddonResponse, error) {
	rsp, err := c.CreateAddon(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAddonResponse(rsp)
}

// DeleteAddonWithResponse request returning *DeleteAddonResponse
func (c *ClientWithResponses) DeleteAddonWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*DeleteAddonResponse, error) {
	rsp, err := c.DeleteAddon(ctx, addonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAddonResponse(rsp)
}

// GetAddonWithResponse request returning *GetAddonResponse
func (c *ClientWithResponses) GetAddonWithResponse(ctx context.Context, addonId string, params *GetAddonParams, reqEditors ...RequestEditorFn) (*GetAddonResponse, error) {
	rsp, err := c.GetAddon(ctx, addonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonResponse(rsp)
}

// UpdateAddonWithBodyWithResponse request with arbitrary body returning *UpdateAddonResponse
func (c *ClientWithResponses) UpdateAddonWithBodyWithResponse(ctx context.Context, addonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAddonResponse, error) {
	rsp, err := c.UpdateAddonWithBody(ctx, addonId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAddonResponse(rsp)
}

func (c *ClientWithResponses) UpdateAddonWithResponse(ctx context.Context, addonId string, body UpdateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAddonResponse, error) {
	rsp, err := c.UpdateAddon(ctx, addonId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAddonResponse(rsp)
}

// ArchiveAddonWithResponse request returning *ArchiveAddonResponse
func (c *ClientWithResponses) ArchiveAddonWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*ArchiveAddonResponse, error) {
	rsp, err := c.ArchiveAddon(ctx, addonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAddonResponse(rsp)
}

// PublishAddonWithResponse request returning *PublishAddonResponse
func (c *ClientWithResponses) PublishAddonWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*PublishAddonResponse, error) {
	rsp, err := c.PublishAddon(ctx, addonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishAddonResponse(rsp)
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// AppCustomInvoicingDraftSynchronizedWithBodyWithResponse request with arbitrary body returning *AppCustomInvoicingDraftSynchronizedResponse
func (c *ClientWithResponses) AppCustomInvoicingDraftSynchronizedWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppCustomInvoicingDraftSynchronizedResponse, error) {
	rsp, err := c.AppCustomInvoicingDraftSynchronizedWithBody(ctx, invoiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppCustomInvoicingDraftSynchronizedResponse(rsp)
}

func (c *ClientWithResponses) AppCustomInvoicingDraftSynchronizedWithResponse(ctx context.Context, invoiceId string, body AppCustomInvoicingDraftSynchronizedJSONRequestBody, reqEditors ...RequestEditorFn) (*AppCustomInvoicingDraftSynchronizedResponse, error) {
	rsp, err := c.AppCustomInvoicingDraftSynchronized(ctx, invoiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppCustomInvoicingDraftSynchronizedResponse(rsp)
}

// AppCustomInvoicingIssuingSynchronizedWithBodyWithResponse request with arbitrary body returning *AppCustomInvoicingIssuingSynchronizedResponse
func (c *ClientWithResponses) AppCustomInvoicingIssuingSynchronizedWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppCustomInvoicingIssuingSynchronizedResponse, error) {
	rsp, err := c.AppCustomInvoicingIssuingSynchronizedWithBody(ctx, invoiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppCustomInvoicingIssuingSynchronizedResponse(rsp)
}

func (c *ClientWithResponses) AppCustomInvoicingIssuingSynchronizedWithResponse(ctx context.Context, invoiceId string, body AppCustomInvoicingIssuingSynchronizedJSONRequestBody, reqEditors ...RequestEditorFn) (*AppCustomInvoicingIssuingSynchronizedResponse, error) {
	rsp, err := c.AppCustomInvoicingIssuingSynchronized(ctx, invoiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppCustomInvoicingIssuingSynchronizedResponse(rsp)
}

// AppCustomInvoicingUpdatePaymentStatusWithBodyWithResponse request with arbitrary body returning *AppCustomInvoicingUpdatePaymentStatusResponse
func (c *ClientWithResponses) AppCustomInvoicingUpdatePaymentStatusWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppCustomInvoicingUpdatePaymentStatusResponse, error) {
	rsp, err := c.AppCustomInvoicingUpdatePaymentStatusWithBody(ctx, invoiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppCustomInvoicingUpdatePaymentStatusResponse(rsp)
}

func (c *ClientWithResponses) AppCustomInvoicingUpdatePaymentStatusWithResponse(ctx context.Context, invoiceId string, body AppCustomInvoicingUpdatePaymentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*AppCustomInvoicingUpdatePaymentStatusResponse, error) {
	rsp, err := c.AppCustomInvoicingUpdatePaymentStatus(ctx, invoiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppCustomInvoicingUpdatePaymentStatusResponse(rsp)
}

// UninstallAppWithResponse request returning *UninstallAppResponse
func (c *ClientWithResponses) UninstallAppWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UninstallAppResponse, error) {
	rsp, err := c.UninstallApp(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallAppResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAppResponse, error) {
	rsp, err := c.GetApp(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResponse(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResponse
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateAppWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, id string, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateApp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

// UpdateStripeAPIKeyWithBodyWithResponse request with arbitrary body returning *UpdateStripeAPIKeyResponse
func (c *ClientWithResponses) UpdateStripeAPIKeyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStripeAPIKeyResponse, error) {
	rsp, err := c.UpdateStripeAPIKeyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStripeAPIKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdateStripeAPIKeyWithResponse(ctx context.Context, id string, body UpdateStripeAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStripeAPIKeyResponse, error) {
	rsp, err := c.UpdateStripeAPIKey(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStripeAPIKeyResponse(rsp)
}

// AppStripeWebhookWithBodyWithResponse request with arbitrary body returning *AppStripeWebhookResponse
func (c *ClientWithResponses) AppStripeWebhookWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppStripeWebhookResponse, error) {
	rsp, err := c.AppStripeWebhookWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppStripeWebhookResponse(rsp)
}

func (c *ClientWithResponses) AppStripeWebhookWithResponse(ctx context.Context, id string, body AppStripeWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*AppStripeWebhookResponse, error) {
	rsp, err := c.AppStripeWebhook(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppStripeWebhookResponse(rsp)
}

// ListBillingProfileCustomerOverridesWithResponse request returning *ListBillingProfileCustomerOverridesResponse
func (c *ClientWithResponses) ListBillingProfileCustomerOverridesWithResponse(ctx context.Context, params *ListBillingProfileCustomerOverridesParams, reqEditors ...RequestEditorFn) (*ListBillingProfileCustomerOverridesResponse, error) {
	rsp, err := c.ListBillingProfileCustomerOverrides(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingProfileCustomerOverridesResponse(rsp)
}

// DeleteBillingProfileCustomerOverrideWithResponse request returning *DeleteBillingProfileCustomerOverrideResponse
func (c *ClientWithResponses) DeleteBillingProfileCustomerOverrideWithResponse(ctx context.Context, customerId string, reqEditors ...RequestEditorFn) (*DeleteBillingProfileCustomerOverrideResponse, error) {
	rsp, err := c.DeleteBillingProfileCustomerOverride(ctx, customerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBillingProfileCustomerOverrideResponse(rsp)
}

// GetBillingProfileCustomerOverrideWithResponse request returning *GetBillingProfileCustomerOverrideResponse
func (c *ClientWithResponses) GetBillingProfileCustomerOverrideWithResponse(ctx context.Context, customerId string, params *GetBillingProfileCustomerOverrideParams, reqEditors ...RequestEditorFn) (*GetBillingProfileCustomerOverrideResponse, error) {
	rsp, err := c.GetBillingProfileCustomerOverride(ctx, customerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingProfileCustomerOverrideResponse(rsp)
}

// UpsertBillingProfileCustomerOverrideWithBodyWithResponse request with arbitrary body returning *UpsertBillingProfileCustomerOverrideResponse
func (c *ClientWithResponses) UpsertBillingProfileCustomerOverrideWithBodyWithResponse(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertBillingProfileCustomerOverrideResponse, error) {
	rsp, err := c.UpsertBillingProfileCustomerOverrideWithBody(ctx, customerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertBillingProfileCustomerOverrideResponse(rsp)
}

func (c *ClientWithResponses) UpsertBillingProfileCustomerOverrideWithResponse(ctx context.Context, customerId string, body UpsertBillingProfileCustomerOverrideJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertBillingProfileCustomerOverrideResponse, error) {
	rsp, err := c.UpsertBillingProfileCustomerOverride(ctx, customerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertBillingProfileCustomerOverrideResponse(rsp)
}

// CreatePendingInvoiceLineWithBodyWithResponse request with arbitrary body returning *CreatePendingInvoiceLineResponse
func (c *ClientWithResponses) CreatePendingInvoiceLineWithBodyWithResponse(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePendingInvoiceLineResponse, error) {
	rsp, err := c.CreatePendingInvoiceLineWithBody(ctx, customerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePendingInvoiceLineResponse(rsp)
}

func (c *ClientWithResponses) CreatePendingInvoiceLineWithResponse(ctx context.Context, customerId string, body CreatePendingInvoiceLineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePendingInvoiceLineResponse, error) {
	rsp, err := c.CreatePendingInvoiceLine(ctx, customerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePendingInvoiceLineResponse(rsp)
}

// SimulateInvoiceWithBodyWithResponse request with arbitrary body returning *SimulateInvoiceResponse
func (c *ClientWithResponses) SimulateInvoiceWithBodyWithResponse(ctx context.Context, customerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SimulateInvoiceResponse, error) {
	rsp, err := c.SimulateInvoiceWithBody(ctx, customerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSimulateInvoiceResponse(rsp)
}

func (c *ClientWithResponses) SimulateInvoiceWithResponse(ctx context.Context, customerId string, body SimulateInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*SimulateInvoiceResponse, error) {
	rsp, err := c.SimulateInvoice(ctx, customerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSimulateInvoiceResponse(rsp)
}

// ListInvoicesWithResponse request returning *ListInvoicesResponse
func (c *ClientWithResponses) ListInvoicesWithResponse(ctx context.Context, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*ListInvoicesResponse, error) {
	rsp, err := c.ListInvoices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesResponse(rsp)
}

// InvoicePendingLinesActionWithBodyWithResponse request with arbitrary body returning *InvoicePendingLinesActionResponse
func (c *ClientWithResponses) InvoicePendingLinesActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvoicePendingLinesActionResponse, error) {
	rsp, err := c.InvoicePendingLinesActionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvoicePendingLinesActionResponse(rsp)
}

func (c *ClientWithResponses) InvoicePendingLinesActionWithResponse(ctx context.Context, body InvoicePendingLinesActionJSONRequestBody, reqEditors ...RequestEditorFn) (*InvoicePendingLinesActionResponse, error) {
	rsp, err := c.InvoicePendingLinesAction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvoicePendingLinesActionResponse(rsp)
}

// DeleteInvoiceWithResponse request returning *DeleteInvoiceResponse
func (c *ClientWithResponses) DeleteInvoiceWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*DeleteInvoiceResponse, error) {
	rsp, err := c.DeleteInvoice(ctx, invoiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInvoiceResponse(rsp)
}

// GetInvoiceWithResponse request returning *GetInvoiceResponse
func (c *ClientWithResponses) GetInvoiceWithResponse(ctx context.Context, invoiceId string, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*GetInvoiceResponse, error) {
	rsp, err := c.GetInvoice(ctx, invoiceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoiceResponse(rsp)
}

// UpdateInvoiceWithBodyWithResponse request with arbitrary body returning *UpdateInvoiceResponse
func (c *ClientWithResponses) UpdateInvoiceWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInvoiceResponse, error) {
	rsp, err := c.UpdateInvoiceWithBody(ctx, invoiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInvoiceResponse(rsp)
}

func (c *ClientWithResponses) UpdateInvoiceWithResponse(ctx context.Context, invoiceId string, body UpdateInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInvoiceResponse, error) {
	rsp, err := c.UpdateInvoice(ctx, invoiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInvoiceResponse(rsp)
}

// AdvanceInvoiceActionWithResponse request returning *AdvanceInvoiceActionResponse
func (c *ClientWithResponses) AdvanceInvoiceActionWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*AdvanceInvoiceActionResponse, error) {
	rsp, err := c.AdvanceInvoiceAction(ctx, invoiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdvanceInvoiceActionResponse(rsp)
}

// ApproveInvoiceActionWithResponse request returning *ApproveInvoiceActionResponse
func (c *ClientWithResponses) ApproveInvoiceActionWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*ApproveInvoiceActionResponse, error) {
	rsp, err := c.ApproveInvoiceAction(ctx, invoiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveInvoiceActionResponse(rsp)
}

// RetryInvoiceActionWithResponse request returning *RetryInvoiceActionResponse
func (c *ClientWithResponses) RetryInvoiceActionWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*RetryInvoiceActionResponse, error) {
	rsp, err := c.RetryInvoiceAction(ctx, invoiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryInvoiceActionResponse(rsp)
}

// RecalculateInvoiceTaxActionWithResponse request returning *RecalculateInvoiceTaxActionResponse
func (c *ClientWithResponses) RecalculateInvoiceTaxActionWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*RecalculateInvoiceTaxActionResponse, error) {
	rsp, err := c.RecalculateInvoiceTaxAction(ctx, invoiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecalculateInvoiceTaxActionResponse(rsp)
}

// VoidInvoiceActionWithBodyWithResponse request with arbitrary body returning *VoidInvoiceActionResponse
func (c *ClientWithResponses) VoidInvoiceActionWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VoidInvoiceActionResponse, error) {
	rsp, err := c.VoidInvoiceActionWithBody(ctx, invoiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVoidInvoiceActionResponse(rsp)
}

func (c *ClientWithResponses) VoidInvoiceActionWithResponse(ctx context.Context, invoiceId string, body VoidInvoiceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*VoidInvoiceActionResponse, error) {
	rsp, err := c.VoidInvoiceAction(ctx, invoiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVoidInvoiceActionResponse(rsp)
}

// ListBillingProfilesWithResponse request returning *ListBillingProfilesResponse
func (c *ClientWithResponses) ListBillingProfilesWithResponse(ctx context.Context, params *ListBillingProfilesParams, reqEditors ...RequestEditorFn) (*ListBillingProfilesResponse, error) {
	rsp, err := c.ListBillingProfiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingProfilesResponse(rsp)
}

// CreateBillingProfileWithBodyWithResponse request with arbitrary body returning *CreateBillingProfileResponse
func (c *ClientWithResponses) CreateBillingProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBillingProfileResponse, error) {
	rsp, err := c.CreateBillingProfileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBillingProfileResponse(rsp)
}

func (c *ClientWithResponses) CreateBillingProfileWithResponse(ctx context.Context, body CreateBillingProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBillingProfileResponse, error) {
	rsp, err := c.CreateBillingProfile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBillingProfileResponse(rsp)
}

// DeleteBillingProfileWithResponse request returning *DeleteBillingProfileResponse
func (c *ClientWithResponses) DeleteBillingProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBillingProfileResponse, error) {
	rsp, err := c.DeleteBillingProfile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBillingProfileResponse(rsp)
}

// GetBillingProfileWithResponse request returning *GetBillingProfileResponse
func (c *ClientWithResponses) GetBillingProfileWithResponse(ctx context.Context, id string, params *GetBillingProfileParams, reqEditors ...RequestEditorFn) (*GetBillingProfileResponse, error) {
	rsp, err := c.GetBillingProfile(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingProfileResponse(rsp)
}

// UpdateBillingProfileWithBodyWithResponse request with arbitrary body returning *UpdateBillingProfileResponse
func (c *ClientWithResponses) UpdateBillingProfileWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBillingProfileResponse, error) {
	rsp, err := c.UpdateBillingProfileWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillingProfileResponse(rsp)
}

func (c *ClientWithResponses) UpdateBillingProfileWithResponse(ctx context.Context, id string, body UpdateBillingProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillingProfileResponse, error) {
	rsp, err := c.UpdateBillingProfile(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillingProfileResponse(rsp)
}

// ListCustomersWithResponse request returning *ListCustomersResponse
func (c *ClientWithResponses) ListCustomersWithResponse(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*ListCustomersResponse, error) {
	rsp, err := c.ListCustomers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomersResponse(rsp)
}

// CreateCustomerWithBodyWithResponse request with arbitrary body returning *CreateCustomerResponse
func (c *ClientWithResponses) CreateCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error) {
	rsp, err := c.CreateCustomerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomerWithResponse(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error) {
	rsp, err := c.CreateCustomer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerResponse(rsp)
}

// DeleteCustomerWithResponse request returning *DeleteCustomerResponse
func (c *ClientWithResponses) DeleteCustomerWithResponse(ctx context.Context, customerIdOrKey string, reqEditors ...RequestEditorFn) (*DeleteCustomerResponse, error) {
	rsp, err := c.DeleteCustomer(ctx, customerIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomerResponse(rsp)
}

// GetCustomerWithResponse request returning *GetCustomerResponse
func (c *ClientWithResponses) GetCustomerWithResponse(ctx context.Context, customerIdOrKey string, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error) {
	rsp, err := c.GetCustomer(ctx, customerIdOrKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerResponse(rsp)
}

// UpdateCustomerWithBodyWithResponse request with arbitrary body returning *UpdateCustomerResponse
func (c *ClientWithResponses) UpdateCustomerWithBodyWithResponse(ctx context.Context, customerIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error) {
	rsp, err := c.UpdateCustomerWithBody(ctx, customerIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomerWithResponse(ctx context.Context, customerIdOrKey string, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error) {
	rsp, err := c.UpdateCustomer(ctx, customerIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerResponse(rsp)
}

// GetCustomerAccessWithResponse request returning *GetCustomerAccessResponse
func (c *ClientWithResponses) GetCustomerAccessWithResponse(ctx context.Context, customerIdOrKey string, reqEditors ...RequestEditorFn) (*GetCustomerAccessResponse, error) {
	rsp, err := c.GetCustomerAccess(ctx, customerIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerAccessResponse(rsp)
}

// ListCustomerAppDataWithResponse request returning *ListCustomerAppDataResponse
func (c *ClientWithResponses) ListCustomerAppDataWithResponse(ctx context.Context, customerIdOrKey string, params *ListCustomerAppDataParams, reqEditors ...RequestEditorFn) (*ListCustomerAppDataResponse, error) {
	rsp, err := c.ListCustomerAppData(ctx, customerIdOrKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomerAppDataResponse(rsp)
}

// UpsertCustomerAppDataWithBodyWithResponse request with arbitrary body returning *UpsertCustomerAppDataResponse
func (c *ClientWithResponses) UpsertCustomerAppDataWithBodyWithResponse(ctx context.Context, customerIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertCustomerAppDataResponse, error) {
	rsp, err := c.UpsertCustomerAppDataWithBody(ctx, customerIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertCustomerAppDataResponse(rsp)
}

func (c *ClientWithResponses) UpsertCustomerAppDataWithResponse(ctx context.Context, customerIdOrKey string, body UpsertCustomerAppDataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertCustomerAppDataResponse, error) {
	rsp, err := c.UpsertCustomerAppData(ctx, customerIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertCustomerAppDataResponse(rsp)
}

// DeleteCustomerAppDataWithResponse request returning *DeleteCustomerAppDataResponse
func (c *ClientWithResponses) DeleteCustomerAppDataWithResponse(ctx context.Context, customerIdOrKey string, appId string, reqEditors ...RequestEditorFn) (*DeleteCustomerAppDataResponse, error) {
	rsp, err := c.DeleteCustomerAppData(ctx, customerIdOrKey, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomerAppDataResponse(rsp)
}

// GetCustomerEntitlementValueWithResponse request returning *GetCustomerEntitlementValueResponse
func (c *ClientWithResponses) GetCustomerEntitlementValueWithResponse(ctx context.Context, customerIdOrKey string, featureKey string, params *GetCustomerEntitlementValueParams, reqEditors ...RequestEditorFn) (*GetCustomerEntitlementValueResponse, error) {
	rsp, err := c.GetCustomerEntitlementValue(ctx, customerIdOrKey, featureKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerEntitlementValueResponse(rsp)
}

// ListCustomerSubscriptionsWithResponse request returning *ListCustomerSubscriptionsResponse
func (c *ClientWithResponses) ListCustomerSubscriptionsWithResponse(ctx context.Context, customerIdOrKey string, params *ListCustomerSubscriptionsParams, reqEditors ...RequestEditorFn) (*ListCustomerSubscriptionsResponse, error) {
	rsp, err := c.ListCustomerSubscriptions(ctx, customerIdOrKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomerSubscriptionsResponse(rsp)
}

// GetDebugMetricsWithResponse request returning *GetDebugMetricsResponse
func (c *ClientWithResponses) GetDebugMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDebugMetricsResponse, error) {
	rsp, err := c.GetDebugMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDebugMetricsResponse(rsp)
}

// ListEntitlementsWithResponse request returning *ListEntitlementsResponse
func (c *ClientWithResponses) ListEntitlementsWithResponse(ctx context.Context, params *ListEntitlementsParams, reqEditors ...RequestEditorFn) (*ListEntitlementsResponse, error) {
	rsp, err := c.ListEntitlements(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEntitlementsResponse(rsp)
}

// GetEntitlementByIdWithResponse request returning *GetEntitlementByIdResponse
func (c *ClientWithResponses) GetEntitlementByIdWithResponse(ctx context.Context, entitlementId string, reqEditors ...RequestEditorFn) (*GetEntitlementByIdResponse, error) {
	rsp, err := c.GetEntitlementById(ctx, entitlementId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntitlementByIdResponse(rsp)
}

// ListEventsWithResponse request returning *ListEventsResponse
func (c *ClientWithResponses) ListEventsWithResponse(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResponse, error) {
	rsp, err := c.ListEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsResponse(rsp)
}

// IngestEventsWithBodyWithResponse request with arbitrary body returning *IngestEventsResponse
func (c *ClientWithResponses) IngestEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error) {
	rsp, err := c.IngestEventsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestEventsResponse(rsp)
}

func (c *ClientWithResponses) IngestEventsWithApplicationCloudeventsPlusJSONBodyWithResponse(ctx context.Context, body IngestEventsApplicationCloudeventsPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error) {
	rsp, err := c.IngestEventsWithApplicationCloudeventsPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestEventsResponse(rsp)
}

func (c *ClientWithResponses) IngestEventsWithApplicationCloudeventsBatchPlusJSONBodyWithResponse(ctx context.Context, body IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error) {
	rsp, err := c.IngestEventsWithApplicationCloudeventsBatchPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestEventsResponse(rsp)
}

func (c *ClientWithResponses) IngestEventsWithResponse(ctx context.Context, body IngestEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestEventsResponse, error) {
	rsp, err := c.IngestEvents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestEventsResponse(rsp)
}

// ListFeaturesWithResponse request returning *ListFeaturesResponse
func (c *ClientWithResponses) ListFeaturesWithResponse(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*ListFeaturesResponse, error) {
	rsp, err := c.ListFeatures(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFeaturesResponse(rsp)
}

// CreateFeatureWithBodyWithResponse request with arbitrary body returning *CreateFeatureResponse
func (c *ClientWithResponses) CreateFeatureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error) {
	rsp, err := c.CreateFeatureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFeatureResponse(rsp)
}

func (c *ClientWithResponses) CreateFeatureWithResponse(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error) {
	rsp, err := c.CreateFeature(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFeatureResponse(rsp)
}

// DeleteFeatureWithResponse request returning *DeleteFeatureResponse
func (c *ClientWithResponses) DeleteFeatureWithResponse(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*DeleteFeatureResponse, error) {
	rsp, err := c.DeleteFeature(ctx, featureId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFeatureResponse(rsp)
}

// GetFeatureWithResponse request returning *GetFeatureResponse
func (c *ClientWithResponses) GetFeatureWithResponse(ctx context.Context, featureId string, reqEditors ...RequestEditorFn) (*GetFeatureResponse, error) {
	rsp, err := c.GetFeature(ctx, featureId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeatureResponse(rsp)
}

// ListGrantsWithResponse request returning *ListGrantsResponse
func (c *ClientWithResponses) ListGrantsWithResponse(ctx context.Context, params *ListGrantsParams, reqEditors ...RequestEditorFn) (*ListGrantsResponse, error) {
	rsp, err := c.ListGrants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGrantsResponse(rsp)
}

// VoidGrantWithResponse request returning *VoidGrantResponse
func (c *ClientWithResponses) VoidGrantWithResponse(ctx context.Context, grantId string, reqEditors ...RequestEditorFn) (*VoidGrantResponse, error) {
	rsp, err := c.VoidGrant(ctx, grantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVoidGrantResponse(rsp)
}

// ListCurrenciesWithResponse request returning *ListCurrenciesResponse
func (c *ClientWithResponses) ListCurrenciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCurrenciesResponse, error) {
	rsp, err := c.ListCurrencies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCurrenciesResponse(rsp)
}

// GetProgressWithResponse request returning *GetProgressResponse
func (c *ClientWithResponses) GetProgressWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetProgressResponse, error) {
	rsp, err := c.GetProgress(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgressResponse(rsp)
}

// ListMarketplaceListingsWithResponse request returning *ListMarketplaceListingsResponse
func (c *ClientWithResponses) ListMarketplaceListingsWithResponse(ctx context.Context, params *ListMarketplaceListingsParams, reqEditors ...RequestEditorFn) (*ListMarketplaceListingsResponse, error) {
	rsp, err := c.ListMarketplaceListings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMarketplaceListingsResponse(rsp)
}

// GetMarketplaceListingWithResponse request returning *GetMarketplaceListingResponse
func (c *ClientWithResponses) GetMarketplaceListingWithResponse(ctx context.Context, pType AppType, reqEditors ...RequestEditorFn) (*GetMarketplaceListingResponse, error) {
	rsp, err := c.GetMarketplaceListing(ctx, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketplaceListingResponse(rsp)
}

// MarketplaceAppInstallWithBodyWithResponse request with arbitrary body returning *MarketplaceAppInstallResponse
func (c *ClientWithResponses) MarketplaceAppInstallWithBodyWithResponse(ctx context.Context, pType MarketplaceInstallRequestType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarketplaceAppInstallResponse, error) {
	rsp, err := c.MarketplaceAppInstallWithBody(ctx, pType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceAppInstallResponse(rsp)
}

func (c *ClientWithResponses) MarketplaceAppInstallWithResponse(ctx context.Context, pType MarketplaceInstallRequestType, body MarketplaceAppInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*MarketplaceAppInstallResponse, error) {
	rsp, err := c.MarketplaceAppInstall(ctx, pType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceAppInstallResponse(rsp)
}

// MarketplaceAppAPIKeyInstallWithBodyWithResponse request with arbitrary body returning *MarketplaceAppAPIKeyInstallResponse
func (c *ClientWithResponses) MarketplaceAppAPIKeyInstallWithBodyWithResponse(ctx context.Context, pType MarketplaceApiKeyInstallRequestType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarketplaceAppAPIKeyInstallResponse, error) {
	rsp, err := c.MarketplaceAppAPIKeyInstallWithBody(ctx, pType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceAppAPIKeyInstallResponse(rsp)
}

func (c *ClientWithResponses) MarketplaceAppAPIKeyInstallWithResponse(ctx context.Context, pType MarketplaceApiKeyInstallRequestType, body MarketplaceAppAPIKeyInstallJSONRequestBody, reqEditors ...RequestEditorFn) (*MarketplaceAppAPIKeyInstallResponse, error) {
	rsp, err := c.MarketplaceAppAPIKeyInstall(ctx, pType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceAppAPIKeyInstallResponse(rsp)
}

// MarketplaceOAuth2InstallGetURLWithResponse request returning *MarketplaceOAuth2InstallGetURLResponse
func (c *ClientWithResponses) MarketplaceOAuth2InstallGetURLWithResponse(ctx context.Context, pType AppType, reqEditors ...RequestEditorFn) (*MarketplaceOAuth2InstallGetURLResponse, error) {
	rsp, err := c.MarketplaceOAuth2InstallGetURL(ctx, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceOAuth2InstallGetURLResponse(rsp)
}

// MarketplaceOAuth2InstallAuthorizeWithResponse request returning *MarketplaceOAuth2InstallAuthorizeResponse
func (c *ClientWithResponses) MarketplaceOAuth2InstallAuthorizeWithResponse(ctx context.Context, pType MarketplaceOAuth2InstallAuthorizeRequestType, params *MarketplaceOAuth2InstallAuthorizeParams, reqEditors ...RequestEditorFn) (*MarketplaceOAuth2InstallAuthorizeResponse, error) {
	rsp, err := c.MarketplaceOAuth2InstallAuthorize(ctx, pType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarketplaceOAuth2InstallAuthorizeResponse(rsp)
}

// ListMetersWithResponse request returning *ListMetersResponse
func (c *ClientWithResponses) ListMetersWithResponse(ctx context.Context, params *ListMetersParams, reqEditors ...RequestEditorFn) (*ListMetersResponse, error) {
	rsp, err := c.ListMeters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMetersResponse(rsp)
}

// CreateMeterWithBodyWithResponse request with arbitrary body returning *CreateMeterResponse
func (c *ClientWithResponses) CreateMeterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMeterResponse, error) {
	rsp, err := c.CreateMeterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMeterResponse(rsp)
}

func (c *ClientWithResponses) CreateMeterWithResponse(ctx context.Context, body CreateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMeterResponse, error) {
	rsp, err := c.CreateMeter(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMeterResponse(rsp)
}

// DeleteMeterWithResponse request returning *DeleteMeterResponse
func (c *ClientWithResponses) DeleteMeterWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*DeleteMeterResponse, error) {
	rsp, err := c.DeleteMeter(ctx, meterIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMeterResponse(rsp)
}

// GetMeterWithResponse request returning *GetMeterResponse
func (c *ClientWithResponses) GetMeterWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*GetMeterResponse, error) {
	rsp, err := c.GetMeter(ctx, meterIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeterResponse(rsp)
}

// UpdateMeterWithBodyWithResponse request with arbitrary body returning *UpdateMeterResponse
func (c *ClientWithResponses) UpdateMeterWithBodyWithResponse(ctx context.Context, meterIdOrSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMeterResponse, error) {
	rsp, err := c.UpdateMeterWithBody(ctx, meterIdOrSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMeterResponse(rsp)
}

func (c *ClientWithResponses) UpdateMeterWithResponse(ctx context.Context, meterIdOrSlug string, body UpdateMeterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMeterResponse, error) {
	rsp, err := c.UpdateMeter(ctx, meterIdOrSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMeterResponse(rsp)
}

// QueryMeterWithResponse request returning *QueryMeterResponse
func (c *ClientWithResponses) QueryMeterWithResponse(ctx context.Context, meterIdOrSlug string, params *QueryMeterParams, reqEditors ...RequestEditorFn) (*QueryMeterResponse, error) {
	rsp, err := c.QueryMeter(ctx, meterIdOrSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryMeterResponse(rsp)
}

// QueryMeterPostWithBodyWithResponse request with arbitrary body returning *QueryMeterPostResponse
func (c *ClientWithResponses) QueryMeterPostWithBodyWithResponse(ctx context.Context, meterIdOrSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryMeterPostResponse, error) {
	rsp, err := c.QueryMeterPostWithBody(ctx, meterIdOrSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryMeterPostResponse(rsp)
}

func (c *ClientWithResponses) QueryMeterPostWithResponse(ctx context.Context, meterIdOrSlug string, body QueryMeterPostJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryMeterPostResponse, error) {
	rsp, err := c.QueryMeterPost(ctx, meterIdOrSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryMeterPostResponse(rsp)
}

// ListMeterSubjectsWithResponse request returning *ListMeterSubjectsResponse
func (c *ClientWithResponses) ListMeterSubjectsWithResponse(ctx context.Context, meterIdOrSlug string, reqEditors ...RequestEditorFn) (*ListMeterSubjectsResponse, error) {
	rsp, err := c.ListMeterSubjects(ctx, meterIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMeterSubjectsResponse(rsp)
}

// ListNotificationChannelsWithResponse request returning *ListNotificationChannelsResponse
func (c *ClientWithResponses) ListNotificationChannelsWithResponse(ctx context.Context, params *ListNotificationChannelsParams, reqEditors ...RequestEditorFn) (*ListNotificationChannelsResponse, error) {
	rsp, err := c.ListNotificationChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNotificationChannelsResponse(rsp)
}

// CreateNotificationChannelWithBodyWithResponse request with arbitrary body returning *CreateNotificationChannelResponse
func (c *ClientWithResponses) CreateNotificationChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error) {
	rsp, err := c.CreateNotificationChannelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationChannelResponse(rsp)
}

func (c *ClientWithResponses) CreateNotificationChannelWithResponse(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error) {
	rsp, err := c.CreateNotificationChannel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationChannelResponse(rsp)
}

// DeleteNotificationChannelWithResponse request returning *DeleteNotificationChannelResponse
func (c *ClientWithResponses) DeleteNotificationChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*DeleteNotificationChannelResponse, error) {
	rsp, err := c.DeleteNotificationChannel(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationChannelResponse(rsp)
}

// GetNotificationChannelWithResponse request returning *GetNotificationChannelResponse
func (c *ClientWithResponses) GetNotificationChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetNotificationChannelResponse, error) {
	rsp, err := c.GetNotificationChannel(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationChannelResponse(rsp)
}

// UpdateNotificationChannelWithBodyWithResponse request with arbitrary body returning *UpdateNotificationChannelResponse
func (c *ClientWithResponses) UpdateNotificationChannelWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelResponse, error) {
	rsp, err := c.UpdateNotificationChannelWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationChannelResponse(rsp)
}

func (c *ClientWithResponses) UpdateNotificationChannelWithResponse(ctx context.Context, channelId string, body UpdateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelResponse, error) {
	rsp, err := c.UpdateNotificationChannel(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationChannelResponse(rsp)
}

// ListNotificationEventsWithResponse request returning *ListNotificationEventsResponse
func (c *ClientWithResponses) ListNotificationEventsWithResponse(ctx context.Context, params *ListNotificationEventsParams, reqEditors ...RequestEditorFn) (*ListNotificationEventsResponse, error) {
	rsp, err := c.ListNotificationEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNotificationEventsResponse(rsp)
}

// GetNotificationEventWithResponse request returning *GetNotificationEventResponse
func (c *ClientWithResponses) GetNotificationEventWithResponse(ctx context.Context, eventId string, reqEditors ...RequestEditorFn) (*GetNotificationEventResponse, error) {
	rsp, err := c.GetNotificationEvent(ctx, eventId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationEventResponse(rsp)
}

// ListNotificationRulesWithResponse request returning *ListNotificationRulesResponse
func (c *ClientWithResponses) ListNotificationRulesWithResponse(ctx context.Context, params *ListNotificationRulesParams, reqEditors ...RequestEditorFn) (*ListNotificationRulesResponse, error) {
	rsp, err := c.ListNotificationRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNotificationRulesResponse(rsp)
}

// CreateNotificationRuleWithBodyWithResponse request with arbitrary body returning *CreateNotificationRuleResponse
func (c *ClientWithResponses) CreateNotificationRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationRuleResponse, error) {
	rsp, err := c.CreateNotificationRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateNotificationRuleWithResponse(ctx context.Context, body CreateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationRuleResponse, error) {
	rsp, err := c.CreateNotificationRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationRuleResponse(rsp)
}

// DeleteNotificationRuleWithResponse request returning *DeleteNotificationRuleResponse
func (c *ClientWithResponses) DeleteNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*DeleteNotificationRuleResponse, error) {
	rsp, err := c.DeleteNotificationRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationRuleResponse(rsp)
}

// GetNotificationRuleWithResponse request returning *GetNotificationRuleResponse
func (c *ClientWithResponses) GetNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*GetNotificationRuleResponse, error) {
	rsp, err := c.GetNotificationRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationRuleResponse(rsp)
}

// UpdateNotificationRuleWithBodyWithResponse request with arbitrary body returning *UpdateNotificationRuleResponse
func (c *ClientWithResponses) UpdateNotificationRuleWithBodyWithResponse(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationRuleResponse, error) {
	rsp, err := c.UpdateNotificationRuleWithBody(ctx, ruleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateNotificationRuleWithResponse(ctx context.Context, ruleId string, body UpdateNotificationRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationRuleResponse, error) {
	rsp, err := c.UpdateNotificationRule(ctx, ruleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationRuleResponse(rsp)
}

// TestNotificationRuleWithResponse request returning *TestNotificationRuleResponse
func (c *ClientWithResponses) TestNotificationRuleWithResponse(ctx context.Context, ruleId string, reqEditors ...RequestEditorFn) (*TestNotificationRuleResponse, error) {
	rsp, err := c.TestNotificationRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestNotificationRuleResponse(rsp)
}

// ListPlansWithResponse request returning *ListPlansResponse
func (c *ClientWithResponses) ListPlansWithResponse(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*ListPlansResponse, error) {
	rsp, err := c.ListPlans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlansResponse(rsp)
}

// CreatePlanWithBodyWithResponse request with arbitrary body returning *CreatePlanResponse
func (c *ClientWithResponses) CreatePlanWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlanResponse, error) {
	rsp, err := c.CreatePlanWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlanResponse(rsp)
}

func (c *ClientWithResponses) CreatePlanWithResponse(ctx context.Context, body CreatePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlanResponse, error) {
	rsp, err := c.CreatePlan(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlanResponse(rsp)
}

// NextPlanWithResponse request returning *NextPlanResponse
func (c *ClientWithResponses) NextPlanWithResponse(ctx context.Context, planIdOrKey string, reqEditors ...RequestEditorFn) (*NextPlanResponse, error) {
	rsp, err := c.NextPlan(ctx, planIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNextPlanResponse(rsp)
}

// DeletePlanWithResponse request returning *DeletePlanResponse
func (c *ClientWithResponses) DeletePlanWithResponse(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*DeletePlanResponse, error) {
	rsp, err := c.DeletePlan(ctx, planId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePlanResponse(rsp)
}

// GetPlanWithResponse request returning *GetPlanResponse
func (c *ClientWithResponses) GetPlanWithResponse(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*GetPlanResponse, error) {
	rsp, err := c.GetPlan(ctx, planId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanResponse(rsp)
}

// UpdatePlanWithBodyWithResponse request with arbitrary body returning *UpdatePlanResponse
func (c *ClientWithResponses) UpdatePlanWithBodyWithResponse(ctx context.Context, planId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlanResponse, error) {
	rsp, err := c.UpdatePlanWithBody(ctx, planId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlanResponse(rsp)
}

func (c *ClientWithResponses) UpdatePlanWithResponse(ctx context.Context, planId string, body UpdatePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlanResponse, error) {
	rsp, err := c.UpdatePlan(ctx, planId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlanResponse(rsp)
}

// ListPlanAddonsWithResponse request returning *ListPlanAddonsResponse
func (c *ClientWithResponses) ListPlanAddonsWithResponse(ctx context.Context, planId string, params *ListPlanAddonsParams, reqEditors ...RequestEditorFn) (*ListPlanAddonsResponse, error) {
	rsp, err := c.ListPlanAddons(ctx, planId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlanAddonsResponse(rsp)
}

// CreatePlanAddonWithBodyWithResponse request with arbitrary body returning *CreatePlanAddonResponse
func (c *ClientWithResponses) CreatePlanAddonWithBodyWithResponse(ctx context.Context, planId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlanAddonResponse, error) {
	rsp, err := c.CreatePlanAddonWithBody(ctx, planId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlanAddonResponse(rsp)
}

func (c *ClientWithResponses) CreatePlanAddonWithResponse(ctx context.Context, planId string, body CreatePlanAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlanAddonResponse, error) {
	rsp, err := c.CreatePlanAddon(ctx, planId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlanAddonResponse(rsp)
}

// DeletePlanAddonWithResponse request returning *DeletePlanAddonResponse
func (c *ClientWithResponses) DeletePlanAddonWithResponse(ctx context.Context, planId string, planAddonId string, reqEditors ...RequestEditorFn) (*DeletePlanAddonResponse, error) {
	rsp, err := c.DeletePlanAddon(ctx, planId, planAddonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePlanAddonResponse(rsp)
}

// GetPlanAddonWithResponse request returning *GetPlanAddonResponse
func (c *ClientWithResponses) GetPlanAddonWithResponse(ctx context.Context, planId string, planAddonId string, reqEditors ...RequestEditorFn) (*GetPlanAddonResponse, error) {
	rsp, err := c.GetPlanAddon(ctx, planId, planAddonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanAddonResponse(rsp)
}

// UpdatePlanAddonWithBodyWithResponse request with arbitrary body returning *UpdatePlanAddonResponse
func (c *ClientWithResponses) UpdatePlanAddonWithBodyWithResponse(ctx context.Context, planId string, planAddonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlanAddonResponse, error) {
	rsp, err := c.UpdatePlanAddonWithBody(ctx, planId, planAddonId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlanAddonResponse(rsp)
}

func (c *ClientWithResponses) UpdatePlanAddonWithResponse(ctx context.Context, planId string, planAddonId string, body UpdatePlanAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlanAddonResponse, error) {
	rsp, err := c.UpdatePlanAddon(ctx, planId, planAddonId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlanAddonResponse(rsp)
}

// ArchivePlanWithResponse request returning *ArchivePlanResponse
func (c *ClientWithResponses) ArchivePlanWithResponse(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*ArchivePlanResponse, error) {
	rsp, err := c.ArchivePlan(ctx, planId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchivePlanResponse(rsp)
}

// PublishPlanWithResponse request returning *PublishPlanResponse
func (c *ClientWithResponses) PublishPlanWithResponse(ctx context.Context, planId string, reqEditors ...RequestEditorFn) (*PublishPlanResponse, error) {
	rsp, err := c.PublishPlan(ctx, planId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishPlanResponse(rsp)
}

// QueryPortalMeterWithResponse request returning *QueryPortalMeterResponse
func (c *ClientWithResponses) QueryPortalMeterWithResponse(ctx context.Context, meterSlug string, params *QueryPortalMeterParams, reqEditors ...RequestEditorFn) (*QueryPortalMeterResponse, error) {
	rsp, err := c.QueryPortalMeter(ctx, meterSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryPortalMeterResponse(rsp)
}

// ListPortalTokensWithResponse request returning *ListPortalTokensResponse
func (c *ClientWithResponses) ListPortalTokensWithResponse(ctx context.Context, params *ListPortalTokensParams, reqEditors ...RequestEditorFn) (*ListPortalTokensResponse, error) {
	rsp, err := c.ListPortalTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPortalTokensResponse(rsp)
}

// CreatePortalTokenWithBodyWithResponse request with arbitrary body returning *CreatePortalTokenResponse
func (c *ClientWithResponses) CreatePortalTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePortalTokenResponse, error) {
	rsp, err := c.CreatePortalTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePortalTokenResponse(rsp)
}

func (c *ClientWithResponses) CreatePortalTokenWithResponse(ctx context.Context, body CreatePortalTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePortalTokenResponse, error) {
	rsp, err := c.CreatePortalToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePortalTokenResponse(rsp)
}

// InvalidatePortalTokensWithBodyWithResponse request with arbitrary body returning *InvalidatePortalTokensResponse
func (c *ClientWithResponses) InvalidatePortalTokensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvalidatePortalTokensResponse, error) {
	rsp, err := c.InvalidatePortalTokensWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvalidatePortalTokensResponse(rsp)
}

func (c *ClientWithResponses) InvalidatePortalTokensWithResponse(ctx context.Context, body InvalidatePortalTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*InvalidatePortalTokensResponse, error) {
	rsp, err := c.InvalidatePortalTokens(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvalidatePortalTokensResponse(rsp)
}

// CreateStripeCheckoutSessionWithBodyWithResponse request with arbitrary body returning *CreateStripeCheckoutSessionResponse
func (c *ClientWithResponses) CreateStripeCheckoutSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStripeCheckoutSessionResponse, error) {
	rsp, err := c.CreateStripeCheckoutSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStripeCheckoutSessionResponse(rsp)
}

func (c *ClientWithResponses) CreateStripeCheckoutSessionWithResponse(ctx context.Context, body CreateStripeCheckoutSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStripeCheckoutSessionResponse, error) {
	rsp, err := c.CreateStripeCheckoutSession(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStripeCheckoutSessionResponse(rsp)
}

// ListSubjectsWithResponse request returning *ListSubjectsResponse
func (c *ClientWithResponses) ListSubjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSubjectsResponse, error) {
	rsp, err := c.ListSubjects(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSubjectsResponse(rsp)
}

// UpsertSubjectWithBodyWithResponse request with arbitrary body returning *UpsertSubjectResponse
func (c *ClientWithResponses) UpsertSubjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertSubjectResponse, error) {
	rsp, err := c.UpsertSubjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertSubjectResponse(rsp)
}

func (c *ClientWithResponses) UpsertSubjectWithResponse(ctx context.Context, body UpsertSubjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertSubjectResponse, error) {
	rsp, err := c.UpsertSubject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertSubjectResponse(rsp)
}

// DeleteSubjectWithResponse request returning *DeleteSubjectResponse
func (c *ClientWithResponses) DeleteSubjectWithResponse(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*DeleteSubjectResponse, error) {
	rsp, err := c.DeleteSubject(ctx, subjectIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubjectResponse(rsp)
}

// GetSubjectWithResponse request returning *GetSubjectResponse
func (c *ClientWithResponses) GetSubjectWithResponse(ctx context.Context, subjectIdOrKey string, reqEditors ...RequestEditorFn) (*GetSubjectResponse, error) {
	rsp, err := c.GetSubject(ctx, subjectIdOrKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubjectResponse(rsp)
}

// ListSubjectEntitlementsWithResponse request returning *ListSubjectEntitlementsResponse
func (c *ClientWithResponses) ListSubjectEntitlementsWithResponse(ctx context.Context, subjectIdOrKey string, params *ListSubjectEntitlementsParams, reqEditors ...RequestEditorFn) (*ListSubjectEntitlementsResponse, error) {
	rsp, err := c.ListSubjectEntitlements(ctx, subjectIdOrKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSubjectEntitlementsResponse(rsp)
}

// CreateEntitlementWithBodyWithResponse request with arbitrary body returning *CreateEntitlementResponse
func (c *ClientWithResponses) CreateEntitlementWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEntitlementResponse, error) {
	rsp, err := c.CreateEntitlementWithBody(ctx, subjectIdOrKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEntitlementResponse(rsp)
}

func (c *ClientWithResponses) CreateEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, body CreateEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEntitlementResponse, error) {
	rsp, err := c.CreateEntitlement(ctx, subjectIdOrKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEntitlementResponse(rsp)
}

// ListEntitlementGrantsWithResponse request returning *ListEntitlementGrantsResponse
func (c *ClientWithResponses) ListEntitlementGrantsWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *ListEntitlementGrantsParams, reqEditors ...RequestEditorFn) (*ListEntitlementGrantsResponse, error) {
	rsp, err := c.ListEntitlementGrants(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEntitlementGrantsResponse(rsp)
}

// CreateGrantWithBodyWithResponse request with arbitrary body returning *CreateGrantResponse
func (c *ClientWithResponses) CreateGrantWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error) {
	rsp, err := c.CreateGrantWithBody(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGrantResponse(rsp)
}

func (c *ClientWithResponses) CreateGrantWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error) {
	rsp, err := c.CreateGrant(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGrantResponse(rsp)
}

// OverrideEntitlementWithBodyWithResponse request with arbitrary body returning *OverrideEntitlementResponse
func (c *ClientWithResponses) OverrideEntitlementWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OverrideEntitlementResponse, error) {
	rsp, err := c.OverrideEntitlementWithBody(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOverrideEntitlementResponse(rsp)
}

func (c *ClientWithResponses) OverrideEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, body OverrideEntitlementJSONRequestBody, reqEditors ...RequestEditorFn) (*OverrideEntitlementResponse, error) {
	rsp, err := c.OverrideEntitlement(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOverrideEntitlementResponse(rsp)
}

// GetEntitlementValueWithResponse request returning *GetEntitlementValueResponse
func (c *ClientWithResponses) GetEntitlementValueWithResponse(ctx context.Context, subjectIdOrKey string, entitlementIdOrFeatureKey string, params *GetEntitlementValueParams, reqEditors ...RequestEditorFn) (*GetEntitlementValueResponse, error) {
	rsp, err := c.GetEntitlementValue(ctx, subjectIdOrKey, entitlementIdOrFeatureKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntitlementValueResponse(rsp)
}

// DeleteEntitlementWithResponse request returning *DeleteEntitlementResponse
func (c *ClientWithResponses) DeleteEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*DeleteEntitlementResponse, error) {
	rsp, err := c.DeleteEntitlement(ctx, subjectIdOrKey, entitlementId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEntitlementResponse(rsp)
}

// GetEntitlementWithResponse request returning *GetEntitlementResponse
func (c *ClientWithResponses) GetEntitlementWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, reqEditors ...RequestEditorFn) (*GetEntitlementResponse, error) {
	rsp, err := c.GetEntitlement(ctx, subjectIdOrKey, entitlementId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntitlementResponse(rsp)
}

// GetEntitlementHistoryWithResponse request returning *GetEntitlementHistoryResponse
func (c *ClientWithResponses) GetEntitlementHistoryWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, params *GetEntitlementHistoryParams, reqEditors ...RequestEditorFn) (*GetEntitlementHistoryResponse, error) {
	rsp, err := c.GetEntitlementHistory(ctx, subjectIdOrKey, entitlementId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntitlementHistoryResponse(rsp)
}

// ResetEntitlementUsageWithBodyWithResponse request with arbitrary body returning *ResetEntitlementUsageResponse
func (c *ClientWithResponses) ResetEntitlementUsageWithBodyWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetEntitlementUsageResponse, error) {
	rsp, err := c.ResetEntitlementUsageWithBody(ctx, subjectIdOrKey, entitlementId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetEntitlementUsageResponse(rsp)
}

func (c *ClientWithResponses) ResetEntitlementUsageWithResponse(ctx context.Context, subjectIdOrKey string, entitlementId string, body ResetEntitlementUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetEntitlementUsageResponse, error) {
	rsp, err := c.ResetEntitlementUsage(ctx, subjectIdOrKey, entitlementId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetEntitlementUsageResponse(rsp)
}

// CreateSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionResponse
func (c *ClientWithResponses) CreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) CreateSubscriptionWithResponse(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

// DeleteSubscriptionWithResponse request returning *DeleteSubscriptionResponse
func (c *ClientWithResponses) DeleteSubscriptionWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error) {
	rsp, err := c.DeleteSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionResponse(rsp)
}

// GetSubscriptionWithResponse request returning *GetSubscriptionResponse
func (c *ClientWithResponses) GetSubscriptionWithResponse(ctx context.Context, subscriptionId string, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error) {
	rsp, err := c.GetSubscription(ctx, subscriptionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionResponse(rsp)
}

// EditSubscriptionWithBodyWithResponse request with arbitrary body returning *EditSubscriptionResponse
func (c *ClientWithResponses) EditSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditSubscriptionResponse, error) {
	rsp, err := c.EditSubscriptionWithBody(ctx, subscriptionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) EditSubscriptionWithResponse(ctx context.Context, subscriptionId string, body EditSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*EditSubscriptionResponse, error) {
	rsp, err := c.EditSubscription(ctx, subscriptionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditSubscriptionResponse(rsp)
}

// ListSubscriptionAddonsWithResponse request returning *ListSubscriptionAddonsResponse
func (c *ClientWithResponses) ListSubscriptionAddonsWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*ListSubscriptionAddonsResponse, error) {
	rsp, err := c.ListSubscriptionAddons(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSubscriptionAddonsResponse(rsp)
}

// CreateSubscriptionAddonWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionAddonResponse
func (c *ClientWithResponses) CreateSubscriptionAddonWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionAddonResponse, error) {
	rsp, err := c.CreateSubscriptionAddonWithBody(ctx, subscriptionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionAddonResponse(rsp)
}

func (c *ClientWithResponses) CreateSubscriptionAddonWithResponse(ctx context.Context, subscriptionId string, body CreateSubscriptionAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionAddonResponse, error) {
	rsp, err := c.CreateSubscriptionAddon(ctx, subscriptionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionAddonResponse(rsp)
}

// GetSubscriptionAddonWithResponse request returning *GetSubscriptionAddonResponse
func (c *ClientWithResponses) GetSubscriptionAddonWithResponse(ctx context.Context, subscriptionId string, subscriptionAddonId string, reqEditors ...RequestEditorFn) (*GetSubscriptionAddonResponse, error) {
	rsp, err := c.GetSubscriptionAddon(ctx, subscriptionId, subscriptionAddonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionAddonResponse(rsp)
}

// UpdateSubscriptionAddonWithBodyWithResponse request with arbitrary body returning *UpdateSubscriptionAddonResponse
func (c *ClientWithResponses) UpdateSubscriptionAddonWithBodyWithResponse(ctx context.Context, subscriptionId string, subscriptionAddonId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubscriptionAddonResponse, error) {
	rsp, err := c.UpdateSubscriptionAddonWithBody(ctx, subscriptionId, subscriptionAddonId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubscriptionAddonResponse(rsp)
}

func (c *ClientWithResponses) UpdateSubscriptionAddonWithResponse(ctx context.Context, subscriptionId string, subscriptionAddonId string, body UpdateSubscriptionAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubscriptionAddonResponse, error) {
	rsp, err := c.UpdateSubscriptionAddon(ctx, subscriptionId, subscriptionAddonId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubscriptionAddonResponse(rsp)
}

// CancelSubscriptionWithBodyWithResponse request with arbitrary body returning *CancelSubscriptionResponse
func (c *ClientWithResponses) CancelSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelSubscriptionResponse, error) {
	rsp, err := c.CancelSubscriptionWithBody(ctx, subscriptionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) CancelSubscriptionWithResponse(ctx context.Context, subscriptionId string, body CancelSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelSubscriptionResponse, error) {
	rsp, err := c.CancelSubscription(ctx, subscriptionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSubscriptionResponse(rsp)
}

// ChangeSubscriptionWithBodyWithResponse request with arbitrary body returning *ChangeSubscriptionResponse
func (c *ClientWithResponses) ChangeSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeSubscriptionResponse, error) {
	rsp, err := c.ChangeSubscriptionWithBody(ctx, subscriptionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) ChangeSubscriptionWithResponse(ctx context.Context, subscriptionId string, body ChangeSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeSubscriptionResponse, error) {
	rsp, err := c.ChangeSubscription(ctx, subscriptionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeSubscriptionResponse(rsp)
}

// MigrateSubscriptionWithBodyWithResponse request with arbitrary body returning *MigrateSubscriptionResponse
func (c *ClientWithResponses) MigrateSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateSubscriptionResponse, error) {
	rsp, err := c.MigrateSubscriptionWithBody(ctx, subscriptionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) MigrateSubscriptionWithResponse(ctx context.Context, subscriptionId string, body MigrateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateSubscriptionResponse, error) {
	rsp, err := c.MigrateSubscription(ctx, subscriptionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateSubscriptionResponse(rsp)
}

// RestoreSubscriptionWithResponse request returning *RestoreSubscriptionResponse
func (c *ClientWithResponses) RestoreSubscriptionWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*RestoreSubscriptionResponse, error) {
	rsp, err := c.RestoreSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreSubscriptionResponse(rsp)
}

// UnscheduleCancelationWithResponse request returning *UnscheduleCancelationResponse
func (c *ClientWithResponses) UnscheduleCancelationWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*UnscheduleCancelationResponse, error) {
	rsp, err := c.UnscheduleCancelation(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnscheduleCancelationResponse(rsp)
}

// ListEventsV2WithResponse request returning *ListEventsV2Response
func (c *ClientWithResponses) ListEventsV2WithResponse(ctx context.Context, params *ListEventsV2Params, reqEditors ...RequestEditorFn) (*ListEventsV2Response, error) {
	rsp, err := c.ListEventsV2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsV2Response(rsp)
}

// ParseListAddonsResponse parses an HTTP response from a ListAddonsWithResponse call
func ParseListAddonsResponse(rsp *http.Response) (*ListAddonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAddonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddonPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAddonResponse parses an HTTP response from a CreateAddonWithResponse call
func ParseCreateAddonResponse(rsp *http.Response) (*CreateAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAddonResponse parses an HTTP response from a DeleteAddonWithResponse call
func ParseDeleteAddonResponse(rsp *http.Response) (*DeleteAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetAddonResponse parses an HTTP response from a GetAddonWithResponse call
func ParseGetAddonResponse(rsp *http.Response) (*GetAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAddonResponse parses an HTTP response from a UpdateAddonWithResponse call
func ParseUpdateAddonResponse(rsp *http.Response) (*UpdateAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseArchiveAddonResponse parses an HTTP response from a ArchiveAddonWithResponse call
func ParseArchiveAddonResponse(rsp *http.Response) (*ArchiveAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePublishAddonResponse parses an HTTP response from a PublishAddonWithResponse call
func ParsePublishAddonResponse(rsp *http.Response) (*PublishAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseAppCustomInvoicingDraftSynchronizedResponse parses an HTTP response from a AppCustomInvoicingDraftSynchronizedWithResponse call
func ParseAppCustomInvoicingDraftSynchronizedResponse(rsp *http.Response) (*AppCustomInvoicingDraftSynchronizedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppCustomInvoicingDraftSynchronizedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseAppCustomInvoicingIssuingSynchronizedResponse parses an HTTP response from a AppCustomInvoicingIssuingSynchronizedWithResponse call
func ParseAppCustomInvoicingIssuingSynchronizedResponse(rsp *http.Response) (*AppCustomInvoicingIssuingSynchronizedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppCustomInvoicingIssuingSynchronizedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseAppCustomInvoicingUpdatePaymentStatusResponse parses an HTTP response from a AppCustomInvoicingUpdatePaymentStatusWithResponse call
func ParseAppCustomInvoicingUpdatePaymentStatusResponse(rsp *http.Response) (*AppCustomInvoicingUpdatePaymentStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppCustomInvoicingUpdatePaymentStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUninstallAppResponse parses an HTTP response from a UninstallAppWithResponse call
func ParseUninstallAppResponse(rsp *http.Response) (*UninstallAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UninstallAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAppResponse parses an HTTP response from a UpdateAppWithResponse call
func ParseUpdateAppResponse(rsp *http.Response) (*UpdateAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateStripeAPIKeyResponse parses an HTTP response from a UpdateStripeAPIKeyWithResponse call
func ParseUpdateStripeAPIKeyResponse(rsp *http.Response) (*UpdateStripeAPIKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateStripeAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseAppStripeWebhookResponse parses an HTTP response from a AppStripeWebhookWithResponse call
func ParseAppStripeWebhookResponse(rsp *http.Response) (*AppStripeWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppStripeWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StripeWebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListBillingProfileCustomerOverridesResponse parses an HTTP response from a ListBillingProfileCustomerOverridesWithResponse call
func ParseListBillingProfileCustomerOverridesResponse(rsp *http.Response) (*ListBillingProfileCustomerOverridesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillingProfileCustomerOverridesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillingProfileCustomerOverrideWithDetailsPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBillingProfileCustomerOverrideResponse parses an HTTP response from a DeleteBillingProfileCustomerOverrideWithResponse call
func ParseDeleteBillingProfileCustomerOverrideResponse(rsp *http.Response) (*DeleteBillingProfileCustomerOverrideResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBillingProfileCustomerOverrideResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingProfileCustomerOverrideResponse parses an HTTP response from a GetBillingProfileCustomerOverrideWithResponse call
func ParseGetBillingProfileCustomerOverrideResponse(rsp *http.Response) (*GetBillingProfileCustomerOverrideResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingProfileCustomerOverrideResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillingProfileCustomerOverrideWithDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpsertBillingProfileCustomerOverrideResponse parses an HTTP response from a UpsertBillingProfileCustomerOverrideWithResponse call
func ParseUpsertBillingProfileCustomerOverrideResponse(rsp *http.Response) (*UpsertBillingProfileCustomerOverrideResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertBillingProfileCustomerOverrideResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillingProfileCustomerOverrideWithDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePendingInvoiceLineResponse parses an HTTP response from a CreatePendingInvoiceLineWithResponse call
func ParseCreatePendingInvoiceLineResponse(rsp *http.Response) (*CreatePendingInvoiceLineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePendingInvoiceLineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest InvoicePendingLineCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseSimulateInvoiceResponse parses an HTTP response from a SimulateInvoiceWithResponse call
func ParseSimulateInvoiceResponse(rsp *http.Response) (*SimulateInvoiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SimulateInvoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListInvoicesResponse parses an HTTP response from a ListInvoicesWithResponse call
func ParseListInvoicesResponse(rsp *http.Response) (*ListInvoicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvoicePaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseInvoicePendingLinesActionResponse parses an HTTP response from a InvoicePendingLinesActionWithResponse call
func ParseInvoicePendingLinesActionResponse(rsp *http.Response) (*InvoicePendingLinesActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InvoicePendingLinesActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []Invoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteInvoiceResponse parses an HTTP response from a DeleteInvoiceWithResponse call
func ParseDeleteInvoiceResponse(rsp *http.Response) (*DeleteInvoiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInvoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetInvoiceResponse parses an HTTP response from a GetInvoiceWithResponse call
func ParseGetInvoiceResponse(rsp *http.Response) (*GetInvoiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateInvoiceResponse parses an HTTP response from a UpdateInvoiceWithResponse call
func ParseUpdateInvoiceResponse(rsp *http.Response) (*UpdateInvoiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInvoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseAdvanceInvoiceActionResponse parses an HTTP response from a AdvanceInvoiceActionWithResponse call
func ParseAdvanceInvoiceActionResponse(rsp *http.Response) (*AdvanceInvoiceActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdvanceInvoiceActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseApproveInvoiceActionResponse parses an HTTP response from a ApproveInvoiceActionWithResponse call
func ParseApproveInvoiceActionResponse(rsp *http.Response) (*ApproveInvoiceActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveInvoiceActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRetryInvoiceActionResponse parses an HTTP response from a RetryInvoiceActionWithResponse call
func ParseRetryInvoiceActionResponse(rsp *http.Response) (*RetryInvoiceActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetryInvoiceActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRecalculateInvoiceTaxActionResponse parses an HTTP response from a RecalculateInvoiceTaxActionWithResponse call
func ParseRecalculateInvoiceTaxActionResponse(rsp *http.Response) (*RecalculateInvoiceTaxActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecalculateInvoiceTaxActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseVoidInvoiceActionResponse parses an HTTP response from a VoidInvoiceActionWithResponse call
func ParseVoidInvoiceActionResponse(rsp *http.Response) (*VoidInvoiceActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VoidInvoiceActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListBillingProfilesResponse parses an HTTP response from a ListBillingProfilesWithResponse call
func ParseListBillingProfilesResponse(rsp *http.Response) (*ListBillingProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillingProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillingProfilePaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBillingProfileResponse parses an HTTP response from a CreateBillingProfileWithResponse call
func ParseCreateBillingProfileResponse(rsp *http.Response) (*CreateBillingProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBillingProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BillingProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBillingProfileResponse parses an HTTP response from a DeleteBillingProfileWithResponse call
func ParseDeleteBillingProfileResponse(rsp *http.Response) (*DeleteBillingProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBillingProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingProfileResponse parses an HTTP response from a GetBillingProfileWithResponse call
func ParseGetBillingProfileResponse(rsp *http.Response) (*GetBillingProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillingProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateBillingProfileResponse parses an HTTP response from a UpdateBillingProfileWithResponse call
func ParseUpdateBillingProfileResponse(rsp *http.Response) (*UpdateBillingProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBillingProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillingProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListCustomersResponse parses an HTTP response from a ListCustomersWithResponse call
func ParseListCustomersResponse(rsp *http.Response) (*ListCustomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomerPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCustomerResponse parses an HTTP response from a CreateCustomerWithResponse call
func ParseCreateCustomerResponse(rsp *http.Response) (*CreateCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCustomerResponse parses an HTTP response from a DeleteCustomerWithResponse call
func ParseDeleteCustomerResponse(rsp *http.Response) (*DeleteCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetCustomerResponse parses an HTTP response from a GetCustomerWithResponse call
func ParseGetCustomerResponse(rsp *http.Response) (*GetCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateCustomerResponse parses an HTTP response from a UpdateCustomerWithResponse call
func ParseUpdateCustomerResponse(rsp *http.Response) (*UpdateCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetCustomerAccessResponse parses an HTTP response from a GetCustomerAccessWithResponse call
func ParseGetCustomerAccessResponse(rsp *http.Response) (*GetCustomerAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomerAccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListCustomerAppDataResponse parses an HTTP response from a ListCustomerAppDataWithResponse call
func ParseListCustomerAppDataResponse(rsp *http.Response) (*ListCustomerAppDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomerAppDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomerAppDataPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpsertCustomerAppDataResponse parses an HTTP response from a UpsertCustomerAppDataWithResponse call
func ParseUpsertCustomerAppDataResponse(rsp *http.Response) (*UpsertCustomerAppDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertCustomerAppDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CustomerAppData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCustomerAppDataResponse parses an HTTP response from a DeleteCustomerAppDataWithResponse call
func ParseDeleteCustomerAppDataResponse(rsp *http.Response) (*DeleteCustomerAppDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomerAppDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetCustomerEntitlementValueResponse parses an HTTP response from a GetCustomerEntitlementValueWithResponse call
func ParseGetCustomerEntitlementValueResponse(rsp *http.Response) (*GetCustomerEntitlementValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerEntitlementValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntitlementValue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListCustomerSubscriptionsResponse parses an HTTP response from a ListCustomerSubscriptionsWithResponse call
func ParseListCustomerSubscriptionsResponse(rsp *http.Response) (*ListCustomerSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomerSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscriptionPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetDebugMetricsResponse parses an HTTP response from a GetDebugMetricsWithResponse call
func ParseGetDebugMetricsResponse(rsp *http.Response) (*GetDebugMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDebugMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListEntitlementsResponse parses an HTTP response from a ListEntitlementsWithResponse call
func ParseListEntitlementsResponse(rsp *http.Response) (*ListEntitlementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEntitlementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListEntitlementsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntitlementByIdResponse parses an HTTP response from a GetEntitlementByIdWithResponse call
func ParseGetEntitlementByIdResponse(rsp *http.Response) (*GetEntitlementByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntitlementByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entitlement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListEventsResponse parses an HTTP response from a ListEventsWithResponse call
func ParseListEventsResponse(rsp *http.Response) (*ListEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IngestedEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseIngestEventsResponse parses an HTTP response from a IngestEventsWithResponse call
func ParseIngestEventsResponse(rsp *http.Response) (*IngestEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IngestEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListFeaturesResponse parses an HTTP response from a ListFeaturesWithResponse call
func ParseListFeaturesResponse(rsp *http.Response) (*ListFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListFeaturesResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFeatureResponse parses an HTTP response from a CreateFeatureWithResponse call
func ParseCreateFeatureResponse(rsp *http.Response) (*CreateFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Feature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFeatureResponse parses an HTTP response from a DeleteFeatureWithResponse call
func ParseDeleteFeatureResponse(rsp *http.Response) (*DeleteFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetFeatureResponse parses an HTTP response from a GetFeatureWithResponse call
func ParseGetFeatureResponse(rsp *http.Response) (*GetFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Feature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListGrantsResponse parses an HTTP response from a ListGrantsWithResponse call
func ParseListGrantsResponse(rsp *http.Response) (*ListGrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseVoidGrantResponse parses an HTTP response from a VoidGrantWithResponse call
func ParseVoidGrantResponse(rsp *http.Response) (*VoidGrantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VoidGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListCurrenciesResponse parses an HTTP response from a ListCurrenciesWithResponse call
func ParseListCurrenciesResponse(rsp *http.Response) (*ListCurrenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCurrenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Currency
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetProgressResponse parses an HTTP response from a GetProgressWithResponse call
func ParseGetProgressResponse(rsp *http.Response) (*GetProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Progress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListMarketplaceListingsResponse parses an HTTP response from a ListMarketplaceListingsWithResponse call
func ParseListMarketplaceListingsResponse(rsp *http.Response) (*ListMarketplaceListingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMarketplaceListingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketplaceListingPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetMarketplaceListingResponse parses an HTTP response from a GetMarketplaceListingWithResponse call
func ParseGetMarketplaceListingResponse(rsp *http.Response) (*GetMarketplaceListingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketplaceListingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketplaceListing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMarketplaceAppInstallResponse parses an HTTP response from a MarketplaceAppInstallWithResponse call
func ParseMarketplaceAppInstallResponse(rsp *http.Response) (*MarketplaceAppInstallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarketplaceAppInstallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketplaceInstallResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMarketplaceAppAPIKeyInstallResponse parses an HTTP response from a MarketplaceAppAPIKeyInstallWithResponse call
func ParseMarketplaceAppAPIKeyInstallResponse(rsp *http.Response) (*MarketplaceAppAPIKeyInstallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarketplaceAppAPIKeyInstallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketplaceInstallResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMarketplaceOAuth2InstallGetURLResponse parses an HTTP response from a MarketplaceOAuth2InstallGetURLWithResponse call
func ParseMarketplaceOAuth2InstallGetURLResponse(rsp *http.Response) (*MarketplaceOAuth2InstallGetURLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarketplaceOAuth2InstallGetURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientAppStartResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMarketplaceOAuth2InstallAuthorizeResponse parses an HTTP response from a MarketplaceOAuth2InstallAuthorizeWithResponse call
func ParseMarketplaceOAuth2InstallAuthorizeResponse(rsp *http.Response) (*MarketplaceOAuth2InstallAuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarketplaceOAuth2InstallAuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListMetersResponse parses an HTTP response from a ListMetersWithResponse call
func ParseListMetersResponse(rsp *http.Response) (*ListMetersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMetersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Meter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateMeterResponse parses an HTTP response from a CreateMeterWithResponse call
func ParseCreateMeterResponse(rsp *http.Response) (*CreateMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Meter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMeterResponse parses an HTTP response from a DeleteMeterWithResponse call
func ParseDeleteMeterResponse(rsp *http.Response) (*DeleteMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetMeterResponse parses an HTTP response from a GetMeterWithResponse call
func ParseGetMeterResponse(rsp *http.Response) (*GetMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Meter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateMeterResponse parses an HTTP response from a UpdateMeterWithResponse call
func ParseUpdateMeterResponse(rsp *http.Response) (*UpdateMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Meter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseQueryMeterResponse parses an HTTP response from a QueryMeterWithResponse call
func ParseQueryMeterResponse(rsp *http.Response) (*QueryMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeterQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseQueryMeterPostResponse parses an HTTP response from a QueryMeterPostWithResponse call
func ParseQueryMeterPostResponse(rsp *http.Response) (*QueryMeterPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryMeterPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeterQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListMeterSubjectsResponse parses an HTTP response from a ListMeterSubjectsWithResponse call
func ParseListMeterSubjectsResponse(rsp *http.Response) (*ListMeterSubjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMeterSubjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListNotificationChannelsResponse parses an HTTP response from a ListNotificationChannelsWithResponse call
func ParseListNotificationChannelsResponse(rsp *http.Response) (*ListNotificationChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNotificationChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationChannelPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNotificationChannelResponse parses an HTTP response from a CreateNotificationChannelWithResponse call
func ParseCreateNotificationChannelResponse(rsp *http.Response) (*CreateNotificationChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNotificationChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NotificationChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteNotificationChannelResponse parses an HTTP response from a DeleteNotificationChannelWithResponse call
func ParseDeleteNotificationChannelResponse(rsp *http.Response) (*DeleteNotificationChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetNotificationChannelResponse parses an HTTP response from a GetNotificationChannelWithResponse call
func ParseGetNotificationChannelResponse(rsp *http.Response) (*GetNotificationChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateNotificationChannelResponse parses an HTTP response from a UpdateNotificationChannelWithResponse call
func ParseUpdateNotificationChannelResponse(rsp *http.Response) (*UpdateNotificationChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNotificationChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListNotificationEventsResponse parses an HTTP response from a ListNotificationEventsWithResponse call
func ParseListNotificationEventsResponse(rsp *http.Response) (*ListNotificationEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNotificationEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationEventPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetNotificationEventResponse parses an HTTP response from a GetNotificationEventWithResponse call
func ParseGetNotificationEventResponse(rsp *http.Response) (*GetNotificationEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListNotificationRulesResponse parses an HTTP response from a ListNotificationRulesWithResponse call
func ParseListNotificationRulesResponse(rsp *http.Response) (*ListNotificationRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNotificationRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationRulePaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNotificationRuleResponse parses an HTTP response from a CreateNotificationRuleWithResponse call
func ParseCreateNotificationRuleResponse(rsp *http.Response) (*CreateNotificationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNotificationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NotificationRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteNotificationRuleResponse parses an HTTP response from a DeleteNotificationRuleWithResponse call
func ParseDeleteNotificationRuleResponse(rsp *http.Response) (*DeleteNotificationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetNotificationRuleResponse parses an HTTP response from a GetNotificationRuleWithResponse call
func ParseGetNotificationRuleResponse(rsp *http.Response) (*GetNotificationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateNotificationRuleResponse parses an HTTP response from a UpdateNotificationRuleWithResponse call
func ParseUpdateNotificationRuleResponse(rsp *http.Response) (*UpdateNotificationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNotificationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseTestNotificationRuleResponse parses an HTTP response from a TestNotificationRuleWithResponse call
func ParseTestNotificationRuleResponse(rsp *http.Response) (*TestNotificationRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestNotificationRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NotificationEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListPlansResponse parses an HTTP response from a ListPlansWithResponse call
func ParseListPlansResponse(rsp *http.Response) (*ListPlansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePlanResponse parses an HTTP response from a CreatePlanWithResponse call
func ParseCreatePlanResponse(rsp *http.Response) (*CreatePlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Plan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseNextPlanResponse parses an HTTP response from a NextPlanWithResponse call
func ParseNextPlanResponse(rsp *http.Response) (*NextPlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NextPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Plan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePlanResponse parses an HTTP response from a DeletePlanWithResponse call
func ParseDeletePlanResponse(rsp *http.Response) (*DeletePlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPlanResponse parses an HTTP response from a GetPlanWithResponse call
func ParseGetPlanResponse(rsp *http.Response) (*GetPlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePlanResponse parses an HTTP response from a UpdatePlanWithResponse call
func ParseUpdatePlanResponse(rsp *http.Response) (*UpdatePlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListPlanAddonsResponse parses an HTTP response from a ListPlanAddonsWithResponse call
func ParseListPlanAddonsResponse(rsp *http.Response) (*ListPlanAddonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlanAddonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanAddonPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePlanAddonResponse parses an HTTP response from a CreatePlanAddonWithResponse call
func ParseCreatePlanAddonResponse(rsp *http.Response) (*CreatePlanAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlanAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PlanAddon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePlanAddonResponse parses an HTTP response from a DeletePlanAddonWithResponse call
func ParseDeletePlanAddonResponse(rsp *http.Response) (*DeletePlanAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePlanAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPlanAddonResponse parses an HTTP response from a GetPlanAddonWithResponse call
func ParseGetPlanAddonResponse(rsp *http.Response) (*GetPlanAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanAddon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePlanAddonResponse parses an HTTP response from a UpdatePlanAddonWithResponse call
func ParseUpdatePlanAddonResponse(rsp *http.Response) (*UpdatePlanAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePlanAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanAddon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseArchivePlanResponse parses an HTTP response from a ArchivePlanWithResponse call
func ParseArchivePlanResponse(rsp *http.Response) (*ArchivePlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchivePlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePublishPlanResponse parses an HTTP response from a PublishPlanWithResponse call
func ParsePublishPlanResponse(rsp *http.Response) (*PublishPlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseQueryPortalMeterResponse parses an HTTP response from a QueryPortalMeterWithResponse call
func ParseQueryPortalMeterResponse(rsp *http.Response) (*QueryPortalMeterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryPortalMeterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeterQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseListPortalTokensResponse parses an HTTP response from a ListPortalTokensWithResponse call
func ParseListPortalTokensResponse(rsp *http.Response) (*ListPortalTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPortalTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PortalToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePortalTokenResponse parses an HTTP response from a CreatePortalTokenWithResponse call
func ParseCreatePortalTokenResponse(rsp *http.Response) (*CreatePortalTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePortalTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortalToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseInvalidatePortalTokensResponse parses an HTTP response from a InvalidatePortalTokensWithResponse call
func ParseInvalidatePortalTokensResponse(rsp *http.Response) (*InvalidatePortalTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InvalidatePortalTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStripeCheckoutSessionResponse parses an HTTP response from a CreateStripeCheckoutSessionWithResponse call
func ParseCreateStripeCheckoutSessionResponse(rsp *http.Response) (*CreateStripeCheckoutSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStripeCheckoutSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateStripeCheckoutSessionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListSubjectsResponse parses an HTTP response from a ListSubjectsWithResponse call
func ParseListSubjectsResponse(rsp *http.Response) (*ListSubjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSubjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Subject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpsertSubjectResponse parses an HTTP response from a UpsertSubjectWithResponse call
func ParseUpsertSubjectResponse(rsp *http.Response) (*UpsertSubjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertSubjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Subject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSubjectResponse parses an HTTP response from a DeleteSubjectWithResponse call
func ParseDeleteSubjectResponse(rsp *http.Response) (*DeleteSubjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetSubjectResponse parses an HTTP response from a GetSubjectWithResponse call
func ParseGetSubjectResponse(rsp *http.Response) (*GetSubjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListSubjectEntitlementsResponse parses an HTTP response from a ListSubjectEntitlementsWithResponse call
func ParseListSubjectEntitlementsResponse(rsp *http.Response) (*ListSubjectEntitlementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSubjectEntitlementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Entitlement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateEntitlementResponse parses an HTTP response from a CreateEntitlementWithResponse call
func ParseCreateEntitlementResponse(rsp *http.Response) (*CreateEntitlementResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEntitlementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Entitlement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListEntitlementGrantsResponse parses an HTTP response from a ListEntitlementGrantsWithResponse call
func ParseListEntitlementGrantsResponse(rsp *http.Response) (*ListEntitlementGrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEntitlementGrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EntitlementGrant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateGrantResponse parses an HTTP response from a CreateGrantWithResponse call
func ParseCreateGrantResponse(rsp *http.Response) (*CreateGrantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EntitlementGrant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseOverrideEntitlementResponse parses an HTTP response from a OverrideEntitlementWithResponse call
func ParseOverrideEntitlementResponse(rsp *http.Response) (*OverrideEntitlementResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OverrideEntitlementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Entitlement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntitlementValueResponse parses an HTTP response from a GetEntitlementValueWithResponse call
func ParseGetEntitlementValueResponse(rsp *http.Response) (*GetEntitlementValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntitlementValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntitlementValue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEntitlementResponse parses an HTTP response from a DeleteEntitlementWithResponse call
func ParseDeleteEntitlementResponse(rsp *http.Response) (*DeleteEntitlementResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEntitlementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntitlementResponse parses an HTTP response from a GetEntitlementWithResponse call
func ParseGetEntitlementResponse(rsp *http.Response) (*GetEntitlementResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntitlementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entitlement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntitlementHistoryResponse parses an HTTP response from a GetEntitlementHistoryWithResponse call
func ParseGetEntitlementHistoryResponse(rsp *http.Response) (*GetEntitlementHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntitlementHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WindowedBalanceHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseResetEntitlementUsageResponse parses an HTTP response from a ResetEntitlementUsageWithResponse call
func ParseResetEntitlementUsageResponse(rsp *http.Response) (*ResetEntitlementUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetEntitlementUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSubscriptionResponse parses an HTTP response from a CreateSubscriptionWithResponse call
func ParseCreateSubscriptionResponse(rsp *http.Response) (*CreateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSubscriptionResponse parses an HTTP response from a DeleteSubscriptionWithResponse call
func ParseDeleteSubscriptionResponse(rsp *http.Response) (*DeleteSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetSubscriptionResponse parses an HTTP response from a GetSubscriptionWithResponse call
func ParseGetSubscriptionResponse(rsp *http.Response) (*GetSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscriptionExpanded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseEditSubscriptionResponse parses an HTTP response from a EditSubscriptionWithResponse call
func ParseEditSubscriptionResponse(rsp *http.Response) (*EditSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListSubscriptionAddonsResponse parses an HTTP response from a ListSubscriptionAddonsWithResponse call
func ParseListSubscriptionAddonsResponse(rsp *http.Response) (*ListSubscriptionAddonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSubscriptionAddonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SubscriptionAddon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSubscriptionAddonResponse parses an HTTP response from a CreateSubscriptionAddonWithResponse call
func ParseCreateSubscriptionAddonResponse(rsp *http.Response) (*CreateSubscriptionAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SubscriptionAddon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetSubscriptionAddonResponse parses an HTTP response from a GetSubscriptionAddonWithResponse call
func ParseGetSubscriptionAddonResponse(rsp *http.Response) (*GetSubscriptionAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscriptionAddon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSubscriptionAddonResponse parses an HTTP response from a UpdateSubscriptionAddonWithResponse call
func ParseUpdateSubscriptionAddonResponse(rsp *http.Response) (*UpdateSubscriptionAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSubscriptionAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscriptionAddon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCancelSubscriptionResponse parses an HTTP response from a CancelSubscriptionWithResponse call
func ParseCancelSubscriptionResponse(rsp *http.Response) (*CancelSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseChangeSubscriptionResponse parses an HTTP response from a ChangeSubscriptionWithResponse call
func ParseChangeSubscriptionResponse(rsp *http.Response) (*ChangeSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscriptionChangeResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseMigrateSubscriptionResponse parses an HTTP response from a MigrateSubscriptionWithResponse call
func ParseMigrateSubscriptionResponse(rsp *http.Response) (*MigrateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscriptionChangeResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreSubscriptionResponse parses an HTTP response from a RestoreSubscriptionWithResponse call
func ParseRestoreSubscriptionResponse(rsp *http.Response) (*RestoreSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUnscheduleCancelationResponse parses an HTTP response from a UnscheduleCancelationWithResponse call
func ParseUnscheduleCancelationResponse(rsp *http.Response) (*UnscheduleCancelationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnscheduleCancelationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListEventsV2Response parses an HTTP response from a ListEventsV2WithResponse call
func ParseListEventsV2Response(rsp *http.Response) (*ListEventsV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IngestedEventCursorPaginatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest PreconditionFailedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest UnexpectedProblemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
