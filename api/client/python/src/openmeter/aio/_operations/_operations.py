# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/python@6.13.7)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ..._operations._operations import (
    build_create_entitlement_request,
    build_create_feature_request,
    build_create_grant_request,
    build_create_meter_request,
    build_create_portal_token_request,
    build_delete_entitlement_request,
    build_delete_feature_request,
    build_delete_meter_request,
    build_delete_subject_request,
    build_get_entitlement_history_request,
    build_get_entitlement_request,
    build_get_entitlement_value_request,
    build_get_feature_request,
    build_get_meter_request,
    build_get_subject_request,
    build_ingest_events_request,
    build_invalidate_portal_tokens_request,
    build_list_entitlement_grants_request,
    build_list_entitlements_request,
    build_list_events_request,
    build_list_features_request,
    build_list_grants_request,
    build_list_meter_subjects_request,
    build_list_meters_request,
    build_list_portal_tokens_request,
    build_list_subject_entitlements_request,
    build_list_subjects_request,
    build_query_meter_request,
    build_query_portal_meter_request,
    build_reset_entitlement_usage_request,
    build_upsert_subject_request,
    build_void_grant_request,
)
from .._vendor import ClientMixinABC

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class ClientOperationsMixin(ClientMixinABC):  # pylint: disable=too-many-public-methods
    @distributed_trace_async
    async def list_events(
        self,
        *,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        limit: int = 100,
        **kwargs: Any
    ) -> List[JSON]:
        # pylint: disable=line-too-long
        """List ingested events.

        List ingested events within a time range.

        :keyword from_parameter: Start date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype to: ~datetime.datetime
        :keyword limit: Number of events to return. Default value is 100.
        :paramtype limit: int
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "event": {
                            "id": "str",  # Identifies the event. Required.
                            "source": "str",  # Identifies the context in which an event
                              happened. Required.
                            "specversion": "str",  # The version of the CloudEvents
                              specification which the event uses. Required.
                            "subject": "str",  # Describes the subject of the event in
                              the context of the event producer (identified by source). Required.
                            "type": "str",  # Describes the type of event related to the
                              originating occurrence. Required.
                            "data": {
                                "str": {}  # Optional. The event payload.
                            },
                            "datacontenttype": "str",  # Optional. Content type of the
                              data value. Must adhere to RFC 2046 format. "application/json"
                            "dataschema": "str",  # Optional. Identifies the schema that
                              data adheres to.
                            "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when
                              the occurrence happened. Must adhere to RFC 3339.
                        },
                        "validationError": "str"  # Optional.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_events_request(
            from_parameter=from_parameter,
            to=to,
            limit=limit,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def ingest_events(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/cloudevents+json", **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Ingest events.

        Ingests an event or batch of events following the CloudEvents specification.

        :param body: The event or batch of events to ingest.
         The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
         The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
         Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/cloudevents+json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Identifies the event. Required.
                    "source": "str",  # Identifies the context in which an event happened.
                      Required.
                    "specversion": "str",  # The version of the CloudEvents specification which
                      the event uses. Required.
                    "subject": "str",  # Describes the subject of the event in the context of the
                      event producer (identified by source). Required.
                    "type": "str",  # Describes the type of event related to the originating
                      occurrence. Required.
                    "data": {
                        "str": {}  # Optional. The event payload.
                    },
                    "datacontenttype": "str",  # Optional. Content type of the data value. Must
                      adhere to RFC 2046 format. "application/json"
                    "dataschema": "str",  # Optional. Identifies the schema that data adheres to.
                    "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when the occurrence
                      happened. Must adhere to RFC 3339.
                }
        """

    @overload
    async def ingest_events(  # pylint: disable=inconsistent-return-statements
        self, body: List[JSON], *, content_type: str = "application/cloudevents-batch+json", **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Ingest events.

        Ingests an event or batch of events following the CloudEvents specification.

        :param body: The event or batch of events to ingest.
         The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
         The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
         Required.
        :type body: list[JSON]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/cloudevents-batch+json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = [
                    {
                        "id": "str",  # Identifies the event. Required.
                        "source": "str",  # Identifies the context in which an event
                          happened. Required.
                        "specversion": "str",  # The version of the CloudEvents specification
                          which the event uses. Required.
                        "subject": "str",  # Describes the subject of the event in the
                          context of the event producer (identified by source). Required.
                        "type": "str",  # Describes the type of event related to the
                          originating occurrence. Required.
                        "data": {
                            "str": {}  # Optional. The event payload.
                        },
                        "datacontenttype": "str",  # Optional. Content type of the data
                          value. Must adhere to RFC 2046 format. "application/json"
                        "dataschema": "str",  # Optional. Identifies the schema that data
                          adheres to.
                        "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when the
                          occurrence happened. Must adhere to RFC 3339.
                    }
                ]
        """

    @distributed_trace_async
    async def ingest_events(  # pylint: disable=inconsistent-return-statements
        self, body: Union[JSON, List[JSON]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Ingest events.

        Ingests an event or batch of events following the CloudEvents specification.

        :param body: The event or batch of events to ingest.
         The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
         The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema. Is
         either a JSON type or a [JSON] type. Required.
        :type body: JSON or list[JSON]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Identifies the event. Required.
                    "source": "str",  # Identifies the context in which an event happened.
                      Required.
                    "specversion": "str",  # The version of the CloudEvents specification which
                      the event uses. Required.
                    "subject": "str",  # Describes the subject of the event in the context of the
                      event producer (identified by source). Required.
                    "type": "str",  # Describes the type of event related to the originating
                      occurrence. Required.
                    "data": {
                        "str": {}  # Optional. The event payload.
                    },
                    "datacontenttype": "str",  # Optional. Content type of the data value. Must
                      adhere to RFC 2046 format. "application/json"
                    "dataschema": "str",  # Optional. Identifies the schema that data adheres to.
                    "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when the occurrence
                      happened. Must adhere to RFC 3339.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _json = None
        if isinstance(body, MutableMapping):
            content_type = content_type or "application/cloudevents+json"
            _json = body
        elif isinstance(body, list):
            content_type = content_type or "application/cloudevents-batch+json"
            _json = body

        _request = build_ingest_events_request(
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_meters(self, **kwargs: Any) -> List[JSON]:
        # pylint: disable=line-too-long
        """List meters.

        List meters.

        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "aggregation": "str",  # The aggregation type to use for the meter.
                          Required. Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and
                          "MAX".
                        "eventType": "str",  # The event type to aggregate. Required.
                        "slug": "str",  # A unique, human-readable identifier for the meter.
                          Must consist only alphanumeric and underscore characters. Required.
                        "windowSize": "str",  # Aggregation window size. Required. Known
                          values are: "MINUTE", "HOUR", and "DAY".
                        "description": "str",  # Optional. A description of the meter.
                        "groupBy": {
                            "str": "str"  # Optional. Named JSONPath expressions to
                              extract the group by values from the event data. Keys must be unique and
                              consist only alphanumeric and underscore characters.
                        },
                        "id": "str",  # Optional. A unique identifier for the meter.
                        "valueProperty": "str"  # Optional. JSONPath expression to extract
                          the value from the ingested event's data property. The ingested value for
                          SUM, AVG, MIN, and MAX aggregations is a number or a string that can be
                          parsed to a number. For UNIQUE_COUNT aggregation, the ingested value must be
                          a string. For COUNT aggregation the valueProperty is ignored.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_meters_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def create_meter(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """☁ Create meter.

        *Available in OpenMeter Cloud.*
        *In the open-source version, meters are created in the configuration file.*

        Create a meter.

        :param body: The meter to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }

                # response body for status code(s): 201
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """

    @overload
    async def create_meter(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """☁ Create meter.

        *Available in OpenMeter Cloud.*
        *In the open-source version, meters are created in the configuration file.*

        Create a meter.

        :param body: The meter to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """

    @distributed_trace_async
    async def create_meter(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """☁ Create meter.

        *Available in OpenMeter Cloud.*
        *In the open-source version, meters are created in the configuration file.*

        Create a meter.

        :param body: The meter to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }

                # response body for status code(s): 201
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_meter_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_meter(self, meter_id_or_slug: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get meter.

        Get meter by ID or slug.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_meter_request(
            meter_id_or_slug=meter_id_or_slug,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_meter(  # pylint: disable=inconsistent-return-statements
        self, meter_id_or_slug: str, **kwargs: Any
    ) -> None:
        """☁ Delete meter.

        *Available in OpenMeter Cloud.*

        Delete a meter by ID or slug.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            404: lambda response: ResourceNotFoundError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_meter_request(
            meter_id_or_slug=meter_id_or_slug,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def query_meter(
        self,
        meter_id_or_slug: str,
        *,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        window_size: Optional[str] = None,
        window_time_zone: str = "UTC",
        subject: Optional[List[str]] = None,
        filter_group_by: Optional[Dict[str, str]] = None,
        group_by: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Union[JSON, str]:
        """Query meter.

        Query meter for usage.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :keyword from_parameter: Start date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype to: ~datetime.datetime
        :keyword window_size: If not specified, a single usage aggregate will be returned for the
         entirety of the specified period for each subject and group. Known values are: "MINUTE",
         "HOUR", and "DAY". Default value is None.
        :paramtype window_size: str
        :keyword window_time_zone: The value is the name of the time zone as defined in the IANA Time
         Zone Database (http://www.iana.org/time-zones).
         If not specified, the UTC timezone will be used. Default value is "UTC".
        :paramtype window_time_zone: str
        :keyword subject: Filtering by multiple subjects.

         Usage: ?subject=customer-1&subject=customer-2. Default value is None.
        :paramtype subject: list[str]
        :keyword filter_group_by: Default value is None.
        :paramtype filter_group_by: dict[str, str]
        :keyword group_by: If not specified a single aggregate will be returned for each subject and
         time window.
         ``subject`` is a reserved group by value. Default value is None.
        :paramtype group_by: list[str]
        :return: JSON object or str
        :rtype: JSON or str
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "value": 0.0,  # Required.
                            "windowEnd": "2020-02-20 00:00:00",  # Required.
                            "windowStart": "2020-02-20 00:00:00",  # Required.
                            "groupBy": {
                                "str": "str"  # Optional. Dictionary of
                                  :code:`<string>`.
                            },
                            "subject": "str"  # Optional. The subject of the meter value.
                        }
                    ],
                    "from": "2020-02-20 00:00:00",  # Optional.
                    "to": "2020-02-20 00:00:00",  # Optional.
                    "windowSize": "str"  # Optional. Aggregation window size. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[JSON, str]] = kwargs.pop("cls", None)

        _request = build_query_meter_request(
            meter_id_or_slug=meter_id_or_slug,
            from_parameter=from_parameter,
            to=to,
            window_size=window_size,
            window_time_zone=window_time_zone,
            subject=subject,
            filter_group_by=filter_group_by,
            group_by=group_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[JSON, str], deserialized), {})  # type: ignore

        return cast(Union[JSON, str], deserialized)  # type: ignore

    @distributed_trace_async
    async def list_meter_subjects(self, meter_id_or_slug: str, **kwargs: Any) -> List[str]:
        """List meter subjects.

        List subjects for a meter.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :return: list of str
        :rtype: list[str]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    "str"  # Optional.
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[str]] = kwargs.pop("cls", None)

        _request = build_list_meter_subjects_request(
            meter_id_or_slug=meter_id_or_slug,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[str], deserialized), {})  # type: ignore

        return cast(List[str], deserialized)  # type: ignore

    @overload
    async def create_portal_token(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        """Create portal token.

        Create a consumer portal token.

        :param body: The portal token to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }

                # response body for status code(s): 200
                response == {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }
        """

    @overload
    async def create_portal_token(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create portal token.

        Create a consumer portal token.

        :param body: The portal token to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }
        """

    @distributed_trace_async
    async def create_portal_token(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create portal token.

        Create a consumer portal token.

        :param body: The portal token to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }

                # response body for status code(s): 200
                response == {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_portal_token_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_portal_tokens(self, *, limit: int = 25, **kwargs: Any) -> List[JSON]:
        """☁ List portal tokens.

        *Available in OpenMeter Cloud.*

        List consumer portal tokens.

        :keyword limit: Number of portal tokens to return. Default is 25. Default value is 25.
        :paramtype limit: int
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "subject": "str",  # Required.
                        "allowedMeterSlugs": [
                            "str"  # Optional. Optional, if defined only the specified
                              meters will be allowed.
                        ],
                        "createdAt": "2020-02-20 00:00:00",  # Optional.
                        "expired": bool,  # Optional.
                        "expiresAt": "2020-02-20 00:00:00",  # Optional.
                        "id": "str",  # Optional.
                        "token": "str"  # Optional. The token is only returned at creation.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_portal_tokens_request(
            limit=limit,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def invalidate_portal_tokens(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """☁ Invalidate portal tokens.

        *Available in OpenMeter Cloud.*

        Invalidates consumer portal tokens by ID or subject.

        :param body: If no id or subject is specified, all tokens will be invalidated. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Optional. Invalidate a portal token by ID.
                    "subject": "str"  # Optional. Invalidate all portal tokens for a subject.
                }
        """

    @overload
    async def invalidate_portal_tokens(  # pylint: disable=inconsistent-return-statements
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """☁ Invalidate portal tokens.

        *Available in OpenMeter Cloud.*

        Invalidates consumer portal tokens by ID or subject.

        :param body: If no id or subject is specified, all tokens will be invalidated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def invalidate_portal_tokens(  # pylint: disable=inconsistent-return-statements
        self, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        """☁ Invalidate portal tokens.

        *Available in OpenMeter Cloud.*

        Invalidates consumer portal tokens by ID or subject.

        :param body: If no id or subject is specified, all tokens will be invalidated. Is either a JSON
         type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Optional. Invalidate a portal token by ID.
                    "subject": "str"  # Optional. Invalidate all portal tokens for a subject.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_invalidate_portal_tokens_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_subjects(self, **kwargs: Any) -> List[JSON]:
        """☁ List subjects.

        *Available in OpenMeter Cloud.*

        List subjects.

        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_subjects_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def upsert_subject(
        self, body: List[JSON], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[JSON]:
        """☁ Upsert subject.

        *Available in OpenMeter Cloud.*

        Upserts a subject. Creates or updates subject.
        If the subject doesn't exist, it will be created.
        If the subject exists, it will be partially updated with the provided fields.

        :param body: The subject to upsert. Required.
        :type body: list[JSON]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """

    @overload
    async def upsert_subject(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[JSON]:
        """☁ Upsert subject.

        *Available in OpenMeter Cloud.*

        Upserts a subject. Creates or updates subject.
        If the subject doesn't exist, it will be created.
        If the subject exists, it will be partially updated with the provided fields.

        :param body: The subject to upsert. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """

    @distributed_trace_async
    async def upsert_subject(self, body: Union[List[JSON], IO[bytes]], **kwargs: Any) -> List[JSON]:
        """☁ Upsert subject.

        *Available in OpenMeter Cloud.*

        Upserts a subject. Creates or updates subject.
        If the subject doesn't exist, it will be created.
        If the subject exists, it will be partially updated with the provided fields.

        :param body: The subject to upsert. Is either a [JSON] type or a IO[bytes] type. Required.
        :type body: list[JSON] or IO[bytes]
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_upsert_subject_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def get_subject(self, subject_id_or_key: str, **kwargs: Any) -> JSON:
        """☁ Get subject.

        *Available in OpenMeter Cloud.*

        Get subject by ID or key.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "key": "str",  # Required.
                    "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                    "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                    "displayName": "str",  # Optional.
                    "id": "str",  # Optional.
                    "metadata": {
                        "str": {}  # Optional. Dictionary of :code:`<any>`.
                    },
                    "stripeCustomerId": "str"  # Optional.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_subject_request(
            subject_id_or_key=subject_id_or_key,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_subject(  # pylint: disable=inconsistent-return-statements
        self, subject_id_or_key: str, **kwargs: Any
    ) -> None:
        """☁ Delete subject.

        *Available in OpenMeter Cloud.*

        Delete a subject by ID or key.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_subject_request(
            subject_id_or_key=subject_id_or_key,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def query_portal_meter(
        self,
        meter_slug: str,
        *,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        window_size: Optional[str] = None,
        window_time_zone: str = "UTC",
        filter_group_by: Optional[Dict[str, str]] = None,
        group_by: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Union[JSON, str]:
        """Query portal meter.

        Query meter for consumer portal. This endpoint is publicly exposable to consumers.

        :param meter_slug: A unique identifier for the meter. Required.
        :type meter_slug: str
        :keyword from_parameter: Start date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype to: ~datetime.datetime
        :keyword window_size: If not specified, a single usage aggregate will be returned for the
         entirety of the specified period for each subject and group. Known values are: "MINUTE",
         "HOUR", and "DAY". Default value is None.
        :paramtype window_size: str
        :keyword window_time_zone: The value is the name of the time zone as defined in the IANA Time
         Zone Database (http://www.iana.org/time-zones).
         If not specified, the UTC timezone will be used. Default value is "UTC".
        :paramtype window_time_zone: str
        :keyword filter_group_by: Default value is None.
        :paramtype filter_group_by: dict[str, str]
        :keyword group_by: If not specified a single aggregate will be returned for each subject and
         time window.
         ``subject`` is a reserved group by value. Default value is None.
        :paramtype group_by: list[str]
        :return: JSON object or str
        :rtype: JSON or str
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "value": 0.0,  # Required.
                            "windowEnd": "2020-02-20 00:00:00",  # Required.
                            "windowStart": "2020-02-20 00:00:00",  # Required.
                            "groupBy": {
                                "str": "str"  # Optional. Dictionary of
                                  :code:`<string>`.
                            },
                            "subject": "str"  # Optional. The subject of the meter value.
                        }
                    ],
                    "from": "2020-02-20 00:00:00",  # Optional.
                    "to": "2020-02-20 00:00:00",  # Optional.
                    "windowSize": "str"  # Optional. Aggregation window size. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[JSON, str]] = kwargs.pop("cls", None)

        _request = build_query_portal_meter_request(
            meter_slug=meter_slug,
            from_parameter=from_parameter,
            to=to,
            window_size=window_size,
            window_time_zone=window_time_zone,
            filter_group_by=filter_group_by,
            group_by=group_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[JSON, str], deserialized), {})  # type: ignore

        return cast(Union[JSON, str], deserialized)  # type: ignore

    @distributed_trace_async
    async def list_entitlements(
        self, *, limit: int = 1000, offset: int = 0, order_by: str = "createdAt", **kwargs: Any
    ) -> List[JSON]:
        """List entitlements.

        List entitlements.

        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword offset: Number of entries to skip. Default value is 0.
        :paramtype offset: int
        :keyword order_by: Order by field. Known values are: "createdAt" and "updatedAt". Default value
         is "createdAt".
        :paramtype order_by: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {}
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_entitlements_request(
            limit=limit,
            offset=offset,
            order_by=order_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def list_features(
        self, *, limit: int = 1000, offset: int = 0, order_by: str = "id", include_archived: bool = False, **kwargs: Any
    ) -> List[JSON]:
        # pylint: disable=line-too-long
        """List features.

        List features.

        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword offset: Number of entries to skip. Default value is 0.
        :paramtype offset: int
        :keyword order_by: Order by field. Known values are: "id", "createdAt", and "updatedAt".
         Default value is "id".
        :paramtype order_by: str
        :keyword include_archived: Include archived features. Default value is False.
        :paramtype include_archived: bool
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "createdAt": "2020-02-20 00:00:00",  # The date and time the resource
                          was created. Required.
                        "id": "str",  # Readonly unique ULID identifier. Required.
                        "key": "str",  # The unique key of the feature to reference it from
                          your application. Required.
                        "name": "str",  # The name of the feature. Required.
                        "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource
                          was last updated. Defaults to createdAt if not updated. Required.
                        "archivedAt": "2020-02-20 00:00:00",  # Optional. If the feature is
                          archived, it will not be used for grants or usage.
                        "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time
                          the resource was deleted. Null if not deleted.
                        "metadata": {
                            "str": "str"  # Optional. Additional metadata for the
                              feature.
                        },
                        "meterGroupByFilters": {
                            "str": "str"  # Optional. Optional meter group by filters.
                              Useful if the meter scope is broader than what feature tracks.
                        },
                        "meterSlug": "str"  # Optional. The meter that the feature is
                          associated with and decreases grants by usage. If present, the usage of the
                          feature can be metered.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_features_request(
            limit=limit,
            offset=offset,
            order_by=order_by,
            include_archived=include_archived,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def create_feature(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create feature.

        Creates a feature.

        :param body: The feature to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "key": "str",  # The unique key of the feature to reference it from your
                      application. Required.
                    "name": "str",  # The name of the feature. Required.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and decreases grants by usage. If present, the usage of the feature can be
                      metered.
                }

                # response body for status code(s): 201
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "key": "str",  # The unique key of the feature to reference it from your
                      application. Required.
                    "name": "str",  # The name of the feature. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. Defaults to createdAt if not updated. Required.
                    "archivedAt": "2020-02-20 00:00:00",  # Optional. If the feature is archived,
                      it will not be used for grants or usage.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted. Null if not deleted.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and decreases grants by usage. If present, the usage of the feature can be
                      metered.
                }
        """

    @overload
    async def create_feature(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create feature.

        Creates a feature.

        :param body: The feature to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "key": "str",  # The unique key of the feature to reference it from your
                      application. Required.
                    "name": "str",  # The name of the feature. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. Defaults to createdAt if not updated. Required.
                    "archivedAt": "2020-02-20 00:00:00",  # Optional. If the feature is archived,
                      it will not be used for grants or usage.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted. Null if not deleted.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and decreases grants by usage. If present, the usage of the feature can be
                      metered.
                }
        """

    @distributed_trace_async
    async def create_feature(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create feature.

        Creates a feature.

        :param body: The feature to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "key": "str",  # The unique key of the feature to reference it from your
                      application. Required.
                    "name": "str",  # The name of the feature. Required.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and decreases grants by usage. If present, the usage of the feature can be
                      metered.
                }

                # response body for status code(s): 201
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "key": "str",  # The unique key of the feature to reference it from your
                      application. Required.
                    "name": "str",  # The name of the feature. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. Defaults to createdAt if not updated. Required.
                    "archivedAt": "2020-02-20 00:00:00",  # Optional. If the feature is archived,
                      it will not be used for grants or usage.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted. Null if not deleted.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and decreases grants by usage. If present, the usage of the feature can be
                      metered.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_feature_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_feature(self, feature_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get feature.

        Get feature by id.

        :param feature_id: A unique ULID identifier for a feature. Required.
        :type feature_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "key": "str",  # The unique key of the feature to reference it from your
                      application. Required.
                    "name": "str",  # The name of the feature. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. Defaults to createdAt if not updated. Required.
                    "archivedAt": "2020-02-20 00:00:00",  # Optional. If the feature is archived,
                      it will not be used for grants or usage.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted. Null if not deleted.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and decreases grants by usage. If present, the usage of the feature can be
                      metered.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_feature_request(
            feature_id=feature_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_feature(  # pylint: disable=inconsistent-return-statements
        self, feature_id: str, **kwargs: Any
    ) -> None:
        """Delete feature.

        Delete a feature by key.

        :param feature_id: A unique ULID identifier for a feature. Required.
        :type feature_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_feature_request(
            feature_id=feature_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_grants(
        self,
        *,
        limit: int = 1000,
        offset: int = 0,
        order_by: str = "updatedAt",
        include_deleted: bool = False,
        **kwargs: Any
    ) -> List[JSON]:
        # pylint: disable=line-too-long
        """List grants.

        List all grants.

        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword offset: Number of entries to skip. Default value is 0.
        :paramtype offset: int
        :keyword order_by: Order by field. Known values are: "id", "createdAt", and "updatedAt".
         Default value is "updatedAt".
        :paramtype order_by: str
        :keyword include_deleted: Include deleted entries. Default value is False.
        :paramtype include_deleted: bool
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "amount": 0.0,  # The amount to grant. Should be a positive number.
                          Required.
                        "createdAt": "2020-02-20 00:00:00",  # The date and time the resource
                          was created. Required.
                        "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants
                          and anchor for recurring grants. Provided value will be ceiled to metering
                          windowSize (minute). Required.
                        "entitlementId": "str",  # The unique entitlement ULID that the grant
                          is associated with. Required.
                        "expiration": {
                            "count": 0,  # The expiration period count like 12 months.
                              Required.
                            "duration": "str"  # The expiration period duration like
                              month. Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and
                              "YEAR".
                        },
                        "id": "str",  # Readonly unique ULID identifier. Required.
                        "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource
                          was last updated. Defaults to createdAt if not updated. Required.
                        "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time
                          the resource was deleted. Null if not deleted.
                        "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date
                          of the grant.
                        "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are
                          rolled over at reset, after which they can have a different balance compared
                          to what they had before the reset.  Balance after the reset is calculated as:
                          Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                          MinRolloverAmount)).
                        "metadata": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        },
                        "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are
                          rolled over at reset, after which they can have a different balance compared
                          to what they had before the reset.  Balance after the reset is calculated as:
                          Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                          MinRolloverAmount)).
                        "nextRecurrence": "2020-02-20 00:00:00",  # Optional. The next time
                          the grant will recurr.
                        "priority": 1,  # Optional. Default value is 1. The priority of the
                          grant. Grants with higher priority are applied first. Priority is a positive
                          decimal numbers. With lower numbers indicating higher importance. For
                          example, a priority of 1 is more urgent than a priority of 2. When there are
                          several grants available for the same subject, the system selects the grant
                          with the highest priority. In cases where grants share the same priority
                          level, the grant closest to its expiration will be used first. In the case of
                          two grants have identical priorities and expiration dates, the system will
                          use the grant that was created first.
                        "recurrence": {
                            "anchor": "2020-02-20 00:00:00",  # An arbitrary anchor to
                              base the recurring period on. Required.
                            "interval": "str"  # List of pre-defined periods that can be
                              used for recurring & scheduling.  DAY:      Every day WEEK:     Every
                              week MONTH:    Every month YEAR:     Every year. Required. Known values
                              are: "DAY", "WEEK", "MONTH", and "YEAR".
                        },
                        "voidedAt": "2020-02-20 00:00:00"  # Optional. The date and time the
                          grant was voided (cannot be used after that).
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_grants_request(
            limit=limit,
            offset=offset,
            order_by=order_by,
            include_deleted=include_deleted,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def void_grant(self, grant_id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete a grant.

        Void (delete) a grant. A grant can only be deleted if it hasn't been used.

        :param grant_id: A unique identifier for a grant. Required.
        :type grant_id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        _request = build_void_grant_request(
            grant_id=grant_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 409]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 409:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_entitlement(
        self, subject_id_or_key: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create entitlement.

        Create an entitlement for a subject.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param body: The entitlement to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @overload
    async def create_entitlement(
        self, subject_id_or_key: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create entitlement.

        Create an entitlement for a subject.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param body: The entitlement to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @distributed_trace_async
    async def create_entitlement(self, subject_id_or_key: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create entitlement.

        Create an entitlement for a subject.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param body: The entitlement to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_entitlement_request(
            subject_id_or_key=subject_id_or_key,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 409:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_subject_entitlements(
        self, subject_id_or_key: str, *, include_deleted: bool = False, **kwargs: Any
    ) -> List[JSON]:
        """List entitlements.

        List all entitlements for a subject.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :keyword include_deleted: Include deleted entries. Default value is False.
        :paramtype include_deleted: bool
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {}
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_subject_entitlements_request(
            subject_id_or_key=subject_id_or_key,
            include_deleted=include_deleted,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def get_entitlement(self, subject_id_or_key: str, entitlement_id: str, **kwargs: Any) -> JSON:
        """Get entitlement.

        Get entitlement by id.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "lastReset": "2020-02-20 00:00:00"  # Optional. The last time usage was
                      reset.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_entitlement_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id=entitlement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_entitlement(  # pylint: disable=inconsistent-return-statements
        self, subject_id_or_key: str, entitlement_id: str, **kwargs: Any
    ) -> None:
        """Delete entitlement.

        Delete an entitlement by id.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_entitlement_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id=entitlement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_entitlement_grants(
        self,
        subject_id_or_key: str,
        entitlement_id: str,
        *,
        include_deleted: bool = False,
        order_by: str = "updatedAt",
        **kwargs: Any
    ) -> List[JSON]:
        # pylint: disable=line-too-long
        """List grants for an entitlement.

        List all grants for an entitlement.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :keyword include_deleted: Include deleted entries. Default value is False.
        :paramtype include_deleted: bool
        :keyword order_by: Order by field. Known values are: "id", "createdAt", and "updatedAt".
         Default value is "updatedAt".
        :paramtype order_by: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "amount": 0.0,  # The amount to grant. Should be a positive number.
                          Required.
                        "createdAt": "2020-02-20 00:00:00",  # The date and time the resource
                          was created. Required.
                        "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants
                          and anchor for recurring grants. Provided value will be ceiled to metering
                          windowSize (minute). Required.
                        "entitlementId": "str",  # The unique entitlement ULID that the grant
                          is associated with. Required.
                        "expiration": {
                            "count": 0,  # The expiration period count like 12 months.
                              Required.
                            "duration": "str"  # The expiration period duration like
                              month. Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and
                              "YEAR".
                        },
                        "id": "str",  # Readonly unique ULID identifier. Required.
                        "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource
                          was last updated. Defaults to createdAt if not updated. Required.
                        "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time
                          the resource was deleted. Null if not deleted.
                        "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date
                          of the grant.
                        "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are
                          rolled over at reset, after which they can have a different balance compared
                          to what they had before the reset.  Balance after the reset is calculated as:
                          Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                          MinRolloverAmount)).
                        "metadata": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        },
                        "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are
                          rolled over at reset, after which they can have a different balance compared
                          to what they had before the reset.  Balance after the reset is calculated as:
                          Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                          MinRolloverAmount)).
                        "nextRecurrence": "2020-02-20 00:00:00",  # Optional. The next time
                          the grant will recurr.
                        "priority": 1,  # Optional. Default value is 1. The priority of the
                          grant. Grants with higher priority are applied first. Priority is a positive
                          decimal numbers. With lower numbers indicating higher importance. For
                          example, a priority of 1 is more urgent than a priority of 2. When there are
                          several grants available for the same subject, the system selects the grant
                          with the highest priority. In cases where grants share the same priority
                          level, the grant closest to its expiration will be used first. In the case of
                          two grants have identical priorities and expiration dates, the system will
                          use the grant that was created first.
                        "recurrence": {
                            "anchor": "2020-02-20 00:00:00",  # An arbitrary anchor to
                              base the recurring period on. Required.
                            "interval": "str"  # List of pre-defined periods that can be
                              used for recurring & scheduling.  DAY:      Every day WEEK:     Every
                              week MONTH:    Every month YEAR:     Every year. Required. Known values
                              are: "DAY", "WEEK", "MONTH", and "YEAR".
                        },
                        "voidedAt": "2020-02-20 00:00:00"  # Optional. The date and time the
                          grant was voided (cannot be used after that).
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_entitlement_grants_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id=entitlement_id,
            include_deleted=include_deleted,
            order_by=order_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def create_grant(
        self,
        subject_id_or_key: str,
        entitlement_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create grant.

        Create a grant for an entitlement.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :param body: The grant to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "amount": 0.0,  # The amount to grant. Should be a positive number. Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants and anchor
                      for recurring grants. Provided value will be ceiled to metering windowSize
                      (minute). Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "recurrence": {
                        "interval": "str",  # List of pre-defined periods that can be used
                          for recurring & scheduling.  DAY:      Every day WEEK:     Every week MONTH:
                          Every month YEAR:     Every year. Required. Known values are: "DAY", "WEEK",
                          "MONTH", and "YEAR".
                        "anchor": "2020-02-20 00:00:00"  # Optional. An arbitrary anchor to
                          base the recurring period on. If not provided then defaults to now truncated
                          to the hour.
                    }
                }

                # response body for status code(s): 201
                response == {
                    "amount": 0.0,  # The amount to grant. Should be a positive number. Required.
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants and anchor
                      for recurring grants. Provided value will be ceiled to metering windowSize
                      (minute). Required.
                    "entitlementId": "str",  # The unique entitlement ULID that the grant is
                      associated with. Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. Defaults to createdAt if not updated. Required.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted. Null if not deleted.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date of the
                      grant.
                    "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "nextRecurrence": "2020-02-20 00:00:00",  # Optional. The next time the grant
                      will recurr.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "recurrence": {
                        "anchor": "2020-02-20 00:00:00",  # An arbitrary anchor to base the
                          recurring period on. Required.
                        "interval": "str"  # List of pre-defined periods that can be used for
                          recurring & scheduling.  DAY:      Every day WEEK:     Every week MONTH:
                          Every month YEAR:     Every year. Required. Known values are: "DAY", "WEEK",
                          "MONTH", and "YEAR".
                    },
                    "voidedAt": "2020-02-20 00:00:00"  # Optional. The date and time the grant
                      was voided (cannot be used after that).
                }
        """

    @overload
    async def create_grant(
        self,
        subject_id_or_key: str,
        entitlement_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create grant.

        Create a grant for an entitlement.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :param body: The grant to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "amount": 0.0,  # The amount to grant. Should be a positive number. Required.
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants and anchor
                      for recurring grants. Provided value will be ceiled to metering windowSize
                      (minute). Required.
                    "entitlementId": "str",  # The unique entitlement ULID that the grant is
                      associated with. Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. Defaults to createdAt if not updated. Required.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted. Null if not deleted.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date of the
                      grant.
                    "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "nextRecurrence": "2020-02-20 00:00:00",  # Optional. The next time the grant
                      will recurr.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "recurrence": {
                        "anchor": "2020-02-20 00:00:00",  # An arbitrary anchor to base the
                          recurring period on. Required.
                        "interval": "str"  # List of pre-defined periods that can be used for
                          recurring & scheduling.  DAY:      Every day WEEK:     Every week MONTH:
                          Every month YEAR:     Every year. Required. Known values are: "DAY", "WEEK",
                          "MONTH", and "YEAR".
                    },
                    "voidedAt": "2020-02-20 00:00:00"  # Optional. The date and time the grant
                      was voided (cannot be used after that).
                }
        """

    @distributed_trace_async
    async def create_grant(
        self, subject_id_or_key: str, entitlement_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create grant.

        Create a grant for an entitlement.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :param body: The grant to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "amount": 0.0,  # The amount to grant. Should be a positive number. Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants and anchor
                      for recurring grants. Provided value will be ceiled to metering windowSize
                      (minute). Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "recurrence": {
                        "interval": "str",  # List of pre-defined periods that can be used
                          for recurring & scheduling.  DAY:      Every day WEEK:     Every week MONTH:
                          Every month YEAR:     Every year. Required. Known values are: "DAY", "WEEK",
                          "MONTH", and "YEAR".
                        "anchor": "2020-02-20 00:00:00"  # Optional. An arbitrary anchor to
                          base the recurring period on. If not provided then defaults to now truncated
                          to the hour.
                    }
                }

                # response body for status code(s): 201
                response == {
                    "amount": 0.0,  # The amount to grant. Should be a positive number. Required.
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants and anchor
                      for recurring grants. Provided value will be ceiled to metering windowSize
                      (minute). Required.
                    "entitlementId": "str",  # The unique entitlement ULID that the grant is
                      associated with. Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. Defaults to createdAt if not updated. Required.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted. Null if not deleted.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date of the
                      grant.
                    "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "nextRecurrence": "2020-02-20 00:00:00",  # Optional. The next time the grant
                      will recurr.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "recurrence": {
                        "anchor": "2020-02-20 00:00:00",  # An arbitrary anchor to base the
                          recurring period on. Required.
                        "interval": "str"  # List of pre-defined periods that can be used for
                          recurring & scheduling.  DAY:      Every day WEEK:     Every week MONTH:
                          Every month YEAR:     Every year. Required. Known values are: "DAY", "WEEK",
                          "MONTH", and "YEAR".
                    },
                    "voidedAt": "2020-02-20 00:00:00"  # Optional. The date and time the grant
                      was voided (cannot be used after that).
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_grant_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id=entitlement_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_entitlement_value(
        self,
        subject_id_or_key: str,
        entitlement_id_or_feature_key: str,
        *,
        time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> JSON:
        """Get the balance of a specific entitlement.

        Get the balance of a specific entitlement.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id_or_feature_key: The id of the entitlement or the key of the feature.
         Required.
        :type entitlement_id_or_feature_key: str
        :keyword time: Point of time to check value: date-time in RFC 3339 format. Defaults to now.
         Default value is None.
        :paramtype time: ~datetime.datetime
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "hasAccess": bool,  # Whether the subject has access to the feature.
                      Required.
                    "balance": 0.0,  # Optional. The balance of a metered entitlement.
                    "config": "str",  # Optional. The JSON parseable configuration value of a
                      static entitlement.
                    "overage": 0.0,  # Optional. The overage of a metered entitlement.
                    "usage": 0.0  # Optional. Total usage of the feature in the period. Includes
                      overages.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_entitlement_value_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id_or_feature_key=entitlement_id_or_feature_key,
            time=time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_entitlement_history(
        self,
        subject_id_or_key: str,
        entitlement_id: str,
        *,
        window_size: str,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        window_time_zone: str = "UTC",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get the balance history of a specific entitlement.

        Get the balance history of a specific entitlement.

        The windows are inclusive at their start and exclusive at their end.
        The last window may be smaller than the window size and is inclusive at both ends.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :keyword window_size: Size of the time window to group the history by. Cannot be shorter than
         meter granularity. Known values are: "MINUTE", "HOUR", and "DAY". Required.
        :paramtype window_size: str
        :keyword from_parameter: Start of time range to query entitlement: date-time in RFC 3339
         format. Defaults to
         the last reset.
         Gets truncated to the granularity of the underlying meter. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End of time range to query entitlement: date-time in RFC 3339 format. Defaults to
         now.
         If not now then gets truncated to the granularity of the underlying meter. Default value is
         None.
        :paramtype to: ~datetime.datetime
        :keyword window_time_zone: The value is the name of the time zone as defined in the IANA Time
         Zone Database (http://www.iana.org/time-zones).
         If not specified, the UTC timezone will be used. Default value is "UTC".
        :paramtype window_time_zone: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "burndownHistory": [
                        {
                            "balanceAtEnd": 0.0,  # Optional. The entitlement balance at
                              the end of the period.
                            "balanceAtStart": 0.0,  # Optional. The entitlement balance
                              at the start of the period.
                            "grantBalancesAtEnd": {
                                "str": 0.0  # Optional. The balance breakdown of each
                                  active grant at the start of the period: GrantID: Balance.
                            },
                            "grantBalancesAtStart": {
                                "str": 0.0  # Optional. The balance breakdown of each
                                  active grant at the start of the period: GrantID: Balance.
                            },
                            "grantUsages": [
                                {
                                    "grantId": "str",  # Optional. The id of the
                                      grant.
                                    "usage": 0.0  # Optional. The usage of the
                                      grant.
                                }
                            ],
                            "overage": 0.0,  # Optional. Overuse that wasn't covered by
                              grants.
                            "period": {
                                "from": "2020-02-20 00:00:00",  # Period start time
                                  where the amount was applied. If applicable. Required.
                                "to": "2020-02-20 00:00:00"  # Period end time where
                                  the amount was applied. If applicable. Required.
                            },
                            "usage": 0.0  # Optional. The usage of the grant in the
                              period.
                        }
                    ],
                    "windowedHistory": [
                        {
                            "balanceAtStart": 0.0,  # Optional. The entitlement balance
                              at the start of the period.
                            "period": {
                                "from": "2020-02-20 00:00:00",  # Period start time
                                  where the amount was applied. If applicable. Required.
                                "to": "2020-02-20 00:00:00"  # Period end time where
                                  the amount was applied. If applicable. Required.
                            },
                            "usage": 0.0  # Optional. The total usage of the feature in
                              the period.
                        }
                    ]
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_entitlement_history_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id=entitlement_id,
            window_size=window_size,
            from_parameter=from_parameter,
            to=to,
            window_time_zone=window_time_zone,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def reset_entitlement_usage(  # pylint: disable=inconsistent-return-statements
        self,
        subject_id_or_key: str,
        entitlement_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Reset entitlement.

        Reset the entitlement usage and start a new period. Grants that can be are rolled over.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "effectiveAt": "2020-02-20 00:00:00",  # Optional. The time at which the
                      reset takes effect, defaults to now. The reset cannot be in the future. The
                      provided value is truncated to the granularity of the underlying meter.
                    "retainAnchor": bool  # Optional. Should the reset retain the usage period
                      anchor. If true, the usage period anchor is retained. If false, the usage period
                      anchor is reset to the effectiveAt time.
                }
        """

    @overload
    async def reset_entitlement_usage(  # pylint: disable=inconsistent-return-statements
        self,
        subject_id_or_key: str,
        entitlement_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Reset entitlement.

        Reset the entitlement usage and start a new period. Grants that can be are rolled over.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def reset_entitlement_usage(  # pylint: disable=inconsistent-return-statements
        self, subject_id_or_key: str, entitlement_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Reset entitlement.

        Reset the entitlement usage and start a new period. Grants that can be are rolled over.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "effectiveAt": "2020-02-20 00:00:00",  # Optional. The time at which the
                      reset takes effect, defaults to now. The reset cannot be in the future. The
                      provided value is truncated to the granularity of the underlying meter.
                    "retainAnchor": bool  # Optional. Should the reset retain the usage period
                      anchor. If true, the usage period anchor is retained. If false, the usage period
                      anchor is reset to the effectiveAt time.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_reset_entitlement_usage_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id=entitlement_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore
