# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/python@6.13.7)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ..._operations._operations import (
    build_create_feature_request,
    build_create_ledger_grant_request,
    build_create_ledger_request,
    build_create_meter_request,
    build_create_portal_token_request,
    build_delete_feature_request,
    build_delete_meter_request,
    build_delete_subject_request,
    build_get_feature_request,
    build_get_ledger_balance_request,
    build_get_ledger_grant_request,
    build_get_ledger_history_request,
    build_get_meter_request,
    build_get_subject_request,
    build_ingest_events_request,
    build_invalidate_portal_tokens_request,
    build_list_events_request,
    build_list_features_request,
    build_list_ledger_grants_by_ledger_request,
    build_list_ledger_grants_request,
    build_list_ledgers_request,
    build_list_meter_subjects_request,
    build_list_meters_request,
    build_list_portal_tokens_request,
    build_list_subjects_request,
    build_query_meter_request,
    build_query_portal_meter_request,
    build_reset_ledger_request,
    build_upsert_subject_request,
    build_void_ledger_grant_request,
)
from .._vendor import ClientMixinABC

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class ClientOperationsMixin(ClientMixinABC):  # pylint: disable=too-many-public-methods
    @distributed_trace_async
    async def list_events(
        self,
        *,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        limit: int = 100,
        **kwargs: Any
    ) -> List[JSON]:
        # pylint: disable=line-too-long
        """List ingested events.

        List ingested events within a time range.

        :keyword from_parameter: Start date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype to: ~datetime.datetime
        :keyword limit: Number of events to return. Default value is 100.
        :paramtype limit: int
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "event": {
                            "id": "str",  # Identifies the event. Required.
                            "source": "str",  # Identifies the context in which an event
                              happened. Required.
                            "specversion": "str",  # The version of the CloudEvents
                              specification which the event uses. Required.
                            "subject": "str",  # Describes the subject of the event in
                              the context of the event producer (identified by source). Required.
                            "type": "str",  # Describes the type of event related to the
                              originating occurrence. Required.
                            "data": {
                                "str": {}  # Optional. The event payload.
                            },
                            "datacontenttype": "str",  # Optional. Content type of the
                              data value. Must adhere to RFC 2046 format. "application/json"
                            "dataschema": "str",  # Optional. Identifies the schema that
                              data adheres to.
                            "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when
                              the occurrence happened. Must adhere to RFC 3339.
                        },
                        "validationError": "str"  # Optional.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_events_request(
            from_parameter=from_parameter,
            to=to,
            limit=limit,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def ingest_events(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/cloudevents+json", **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Ingest events.

        Ingests an event or batch of events following the CloudEvents specification.

        :param body: The event or batch of events to ingest.
         The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
         The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
         Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/cloudevents+json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Identifies the event. Required.
                    "source": "str",  # Identifies the context in which an event happened.
                      Required.
                    "specversion": "str",  # The version of the CloudEvents specification which
                      the event uses. Required.
                    "subject": "str",  # Describes the subject of the event in the context of the
                      event producer (identified by source). Required.
                    "type": "str",  # Describes the type of event related to the originating
                      occurrence. Required.
                    "data": {
                        "str": {}  # Optional. The event payload.
                    },
                    "datacontenttype": "str",  # Optional. Content type of the data value. Must
                      adhere to RFC 2046 format. "application/json"
                    "dataschema": "str",  # Optional. Identifies the schema that data adheres to.
                    "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when the occurrence
                      happened. Must adhere to RFC 3339.
                }
        """

    @overload
    async def ingest_events(  # pylint: disable=inconsistent-return-statements
        self, body: List[JSON], *, content_type: str = "application/cloudevents-batch+json", **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Ingest events.

        Ingests an event or batch of events following the CloudEvents specification.

        :param body: The event or batch of events to ingest.
         The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
         The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
         Required.
        :type body: list[JSON]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/cloudevents-batch+json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = [
                    {
                        "id": "str",  # Identifies the event. Required.
                        "source": "str",  # Identifies the context in which an event
                          happened. Required.
                        "specversion": "str",  # The version of the CloudEvents specification
                          which the event uses. Required.
                        "subject": "str",  # Describes the subject of the event in the
                          context of the event producer (identified by source). Required.
                        "type": "str",  # Describes the type of event related to the
                          originating occurrence. Required.
                        "data": {
                            "str": {}  # Optional. The event payload.
                        },
                        "datacontenttype": "str",  # Optional. Content type of the data
                          value. Must adhere to RFC 2046 format. "application/json"
                        "dataschema": "str",  # Optional. Identifies the schema that data
                          adheres to.
                        "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when the
                          occurrence happened. Must adhere to RFC 3339.
                    }
                ]
        """

    @distributed_trace_async
    async def ingest_events(  # pylint: disable=inconsistent-return-statements
        self, body: Union[JSON, List[JSON]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Ingest events.

        Ingests an event or batch of events following the CloudEvents specification.

        :param body: The event or batch of events to ingest.
         The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
         The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema. Is
         either a JSON type or a [JSON] type. Required.
        :type body: JSON or list[JSON]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Identifies the event. Required.
                    "source": "str",  # Identifies the context in which an event happened.
                      Required.
                    "specversion": "str",  # The version of the CloudEvents specification which
                      the event uses. Required.
                    "subject": "str",  # Describes the subject of the event in the context of the
                      event producer (identified by source). Required.
                    "type": "str",  # Describes the type of event related to the originating
                      occurrence. Required.
                    "data": {
                        "str": {}  # Optional. The event payload.
                    },
                    "datacontenttype": "str",  # Optional. Content type of the data value. Must
                      adhere to RFC 2046 format. "application/json"
                    "dataschema": "str",  # Optional. Identifies the schema that data adheres to.
                    "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when the occurrence
                      happened. Must adhere to RFC 3339.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _json = None
        if isinstance(body, MutableMapping):
            content_type = content_type or "application/cloudevents+json"
            _json = body
        elif isinstance(body, list):
            content_type = content_type or "application/cloudevents-batch+json"
            _json = body

        _request = build_ingest_events_request(
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_meters(self, **kwargs: Any) -> List[JSON]:
        # pylint: disable=line-too-long
        """List meters.

        List meters.

        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "aggregation": "str",  # The aggregation type to use for the meter.
                          Required. Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and
                          "MAX".
                        "eventType": "str",  # The event type to aggregate. Required.
                        "slug": "str",  # A unique, human-readable identifier for the meter.
                          Must consist only alphanumeric and underscore characters. Required.
                        "windowSize": "str",  # Aggregation window size. Required. Known
                          values are: "MINUTE", "HOUR", and "DAY".
                        "description": "str",  # Optional. A description of the meter.
                        "groupBy": {
                            "str": "str"  # Optional. Named JSONPath expressions to
                              extract the group by values from the event data. Keys must be unique and
                              consist only alphanumeric and underscore characters.
                        },
                        "id": "str",  # Optional. A unique identifier for the meter.
                        "valueProperty": "str"  # Optional. JSONPath expression to extract
                          the value from the ingested event's data property. The ingested value for
                          SUM, AVG, MIN, and MAX aggregations is a number or a string that can be
                          parsed to a number. For UNIQUE_COUNT aggregation, the ingested value must be
                          a string. For COUNT aggregation the valueProperty is ignored.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_meters_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def create_meter(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """☁ Create meter.

        *Available in OpenMeter Cloud.*
        *In the open-source version, meters are created in the configuration file.*

        Create a meter.

        :param body: The meter to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }

                # response body for status code(s): 201
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """

    @overload
    async def create_meter(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """☁ Create meter.

        *Available in OpenMeter Cloud.*
        *In the open-source version, meters are created in the configuration file.*

        Create a meter.

        :param body: The meter to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """

    @distributed_trace_async
    async def create_meter(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """☁ Create meter.

        *Available in OpenMeter Cloud.*
        *In the open-source version, meters are created in the configuration file.*

        Create a meter.

        :param body: The meter to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }

                # response body for status code(s): 201
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_meter_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_meter(self, meter_id_or_slug: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get meter.

        Get meter by ID or slug.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_meter_request(
            meter_id_or_slug=meter_id_or_slug,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_meter(  # pylint: disable=inconsistent-return-statements
        self, meter_id_or_slug: str, **kwargs: Any
    ) -> None:
        """☁ Delete meter.

        *Available in OpenMeter Cloud.*

        Delete a meter by ID or slug.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            404: lambda response: ResourceNotFoundError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_meter_request(
            meter_id_or_slug=meter_id_or_slug,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def query_meter(
        self,
        meter_id_or_slug: str,
        *,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        window_size: Optional[str] = None,
        window_time_zone: str = "UTC",
        subject: Optional[List[str]] = None,
        filter_group_by: Optional[Dict[str, str]] = None,
        group_by: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Union[JSON, str]:
        """Query meter.

        Query meter for usage.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :keyword from_parameter: Start date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype to: ~datetime.datetime
        :keyword window_size: If not specified, a single usage aggregate will be returned for the
         entirety of the specified period for each subject and group. Known values are: "MINUTE",
         "HOUR", and "DAY". Default value is None.
        :paramtype window_size: str
        :keyword window_time_zone: The value is the name of the time zone as defined in the IANA Time
         Zone Database (http://www.iana.org/time-zones).
         If not specified, the UTC timezone will be used. Default value is "UTC".
        :paramtype window_time_zone: str
        :keyword subject: Filtering by multiple subjects.

         Usage: ?subject=customer-1&subject=customer-2. Default value is None.
        :paramtype subject: list[str]
        :keyword filter_group_by: Default value is None.
        :paramtype filter_group_by: dict[str, str]
        :keyword group_by: If not specified a single aggregate will be returned for each subject and
         time window.
         ``subject`` is a reserved group by value. Default value is None.
        :paramtype group_by: list[str]
        :return: JSON object or str
        :rtype: JSON or str
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "value": 0.0,  # Required.
                            "windowEnd": "2020-02-20 00:00:00",  # Required.
                            "windowStart": "2020-02-20 00:00:00",  # Required.
                            "groupBy": {
                                "str": "str"  # Optional. Dictionary of
                                  :code:`<string>`.
                            },
                            "subject": "str"  # Optional. The subject of the meter value.
                        }
                    ],
                    "from": "2020-02-20 00:00:00",  # Optional.
                    "to": "2020-02-20 00:00:00",  # Optional.
                    "windowSize": "str"  # Optional. Aggregation window size. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[JSON, str]] = kwargs.pop("cls", None)

        _request = build_query_meter_request(
            meter_id_or_slug=meter_id_or_slug,
            from_parameter=from_parameter,
            to=to,
            window_size=window_size,
            window_time_zone=window_time_zone,
            subject=subject,
            filter_group_by=filter_group_by,
            group_by=group_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[JSON, str], deserialized), {})  # type: ignore

        return cast(Union[JSON, str], deserialized)  # type: ignore

    @distributed_trace_async
    async def list_meter_subjects(self, meter_id_or_slug: str, **kwargs: Any) -> List[str]:
        """List meter subjects.

        List subjects for a meter.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :return: list of str
        :rtype: list[str]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    "str"  # Optional.
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[str]] = kwargs.pop("cls", None)

        _request = build_list_meter_subjects_request(
            meter_id_or_slug=meter_id_or_slug,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[str], deserialized), {})  # type: ignore

        return cast(List[str], deserialized)  # type: ignore

    @overload
    async def create_portal_token(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        """Create portal token.

        Create a consumer portal token.

        :param body: The portal token to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }

                # response body for status code(s): 200
                response == {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }
        """

    @overload
    async def create_portal_token(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create portal token.

        Create a consumer portal token.

        :param body: The portal token to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }
        """

    @distributed_trace_async
    async def create_portal_token(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create portal token.

        Create a consumer portal token.

        :param body: The portal token to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }

                # response body for status code(s): 200
                response == {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_portal_token_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_portal_tokens(self, *, limit: int = 25, **kwargs: Any) -> List[JSON]:
        """☁ List portal tokens.

        *Available in OpenMeter Cloud.*

        List consumer portal tokens.

        :keyword limit: Number of portal tokens to return. Default is 25. Default value is 25.
        :paramtype limit: int
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "subject": "str",  # Required.
                        "allowedMeterSlugs": [
                            "str"  # Optional. Optional, if defined only the specified
                              meters will be allowed.
                        ],
                        "createdAt": "2020-02-20 00:00:00",  # Optional.
                        "expired": bool,  # Optional.
                        "expiresAt": "2020-02-20 00:00:00",  # Optional.
                        "id": "str",  # Optional.
                        "token": "str"  # Optional. The token is only returned at creation.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_portal_tokens_request(
            limit=limit,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def invalidate_portal_tokens(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """☁ Invalidate portal tokens.

        *Available in OpenMeter Cloud.*

        Invalidates consumer portal tokens by ID or subject.

        :param body: If no id or subject is specified, all tokens will be invalidated. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Optional. Invalidate a portal token by ID.
                    "subject": "str"  # Optional. Invalidate all portal tokens for a subject.
                }
        """

    @overload
    async def invalidate_portal_tokens(  # pylint: disable=inconsistent-return-statements
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """☁ Invalidate portal tokens.

        *Available in OpenMeter Cloud.*

        Invalidates consumer portal tokens by ID or subject.

        :param body: If no id or subject is specified, all tokens will be invalidated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def invalidate_portal_tokens(  # pylint: disable=inconsistent-return-statements
        self, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        """☁ Invalidate portal tokens.

        *Available in OpenMeter Cloud.*

        Invalidates consumer portal tokens by ID or subject.

        :param body: If no id or subject is specified, all tokens will be invalidated. Is either a JSON
         type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Optional. Invalidate a portal token by ID.
                    "subject": "str"  # Optional. Invalidate all portal tokens for a subject.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_invalidate_portal_tokens_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_subjects(self, **kwargs: Any) -> List[JSON]:
        """☁ List subjects.

        *Available in OpenMeter Cloud.*

        List subjects.

        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_subjects_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def upsert_subject(
        self, body: List[JSON], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[JSON]:
        """☁ Upsert subject.

        *Available in OpenMeter Cloud.*

        Upserts a subject. Creates or updates subject.
        If the subject doesn't exist, it will be created.
        If the subject exists, it will be partially updated with the provided fields.

        :param body: The subject to upsert. Required.
        :type body: list[JSON]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """

    @overload
    async def upsert_subject(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[JSON]:
        """☁ Upsert subject.

        *Available in OpenMeter Cloud.*

        Upserts a subject. Creates or updates subject.
        If the subject doesn't exist, it will be created.
        If the subject exists, it will be partially updated with the provided fields.

        :param body: The subject to upsert. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """

    @distributed_trace_async
    async def upsert_subject(self, body: Union[List[JSON], IO[bytes]], **kwargs: Any) -> List[JSON]:
        """☁ Upsert subject.

        *Available in OpenMeter Cloud.*

        Upserts a subject. Creates or updates subject.
        If the subject doesn't exist, it will be created.
        If the subject exists, it will be partially updated with the provided fields.

        :param body: The subject to upsert. Is either a [JSON] type or a IO[bytes] type. Required.
        :type body: list[JSON] or IO[bytes]
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_upsert_subject_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def get_subject(self, subject_id_or_key: str, **kwargs: Any) -> JSON:
        """☁ Get subject.

        *Available in OpenMeter Cloud.*

        Get subject by ID or key.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "key": "str",  # Required.
                    "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                    "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                    "displayName": "str",  # Optional.
                    "id": "str",  # Optional.
                    "metadata": {
                        "str": {}  # Optional. Dictionary of :code:`<any>`.
                    },
                    "stripeCustomerId": "str"  # Optional.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_subject_request(
            subject_id_or_key=subject_id_or_key,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_subject(  # pylint: disable=inconsistent-return-statements
        self, subject_id_or_key: str, **kwargs: Any
    ) -> None:
        """☁ Delete subject.

        *Available in OpenMeter Cloud.*

        Delete a subject by ID or key.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_subject_request(
            subject_id_or_key=subject_id_or_key,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def query_portal_meter(
        self,
        meter_slug: str,
        *,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        window_size: Optional[str] = None,
        window_time_zone: str = "UTC",
        filter_group_by: Optional[Dict[str, str]] = None,
        group_by: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Union[JSON, str]:
        """Query portal meter.

        Query meter for consumer portal. This endpoint is publicly exposable to consumers.

        :param meter_slug: A unique identifier for the meter. Required.
        :type meter_slug: str
        :keyword from_parameter: Start date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype to: ~datetime.datetime
        :keyword window_size: If not specified, a single usage aggregate will be returned for the
         entirety of the specified period for each subject and group. Known values are: "MINUTE",
         "HOUR", and "DAY". Default value is None.
        :paramtype window_size: str
        :keyword window_time_zone: The value is the name of the time zone as defined in the IANA Time
         Zone Database (http://www.iana.org/time-zones).
         If not specified, the UTC timezone will be used. Default value is "UTC".
        :paramtype window_time_zone: str
        :keyword filter_group_by: Default value is None.
        :paramtype filter_group_by: dict[str, str]
        :keyword group_by: If not specified a single aggregate will be returned for each subject and
         time window.
         ``subject`` is a reserved group by value. Default value is None.
        :paramtype group_by: list[str]
        :return: JSON object or str
        :rtype: JSON or str
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "value": 0.0,  # Required.
                            "windowEnd": "2020-02-20 00:00:00",  # Required.
                            "windowStart": "2020-02-20 00:00:00",  # Required.
                            "groupBy": {
                                "str": "str"  # Optional. Dictionary of
                                  :code:`<string>`.
                            },
                            "subject": "str"  # Optional. The subject of the meter value.
                        }
                    ],
                    "from": "2020-02-20 00:00:00",  # Optional.
                    "to": "2020-02-20 00:00:00",  # Optional.
                    "windowSize": "str"  # Optional. Aggregation window size. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[JSON, str]] = kwargs.pop("cls", None)

        _request = build_query_portal_meter_request(
            meter_slug=meter_slug,
            from_parameter=from_parameter,
            to=to,
            window_size=window_size,
            window_time_zone=window_time_zone,
            filter_group_by=filter_group_by,
            group_by=group_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[JSON, str], deserialized), {})  # type: ignore

        return cast(Union[JSON, str], deserialized)  # type: ignore

    @distributed_trace_async
    async def list_features(
        self, *, limit: int = 1000, offset: int = 0, order_by: str = "id", include_archived: bool = False, **kwargs: Any
    ) -> List[JSON]:
        # pylint: disable=line-too-long
        """List features.

        List features.

        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword offset: Number of entries to skip. Default value is 0.
        :paramtype offset: int
        :keyword order_by: Order by field. Known values are: "id", "createdAt", and "updatedAt".
         Default value is "id".
        :paramtype order_by: str
        :keyword include_archived: Include archived features. Default value is False.
        :paramtype include_archived: bool
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "id": "str",  # Readonly unique ULID identifier of the feature.
                          Required.
                        "meterSlug": "str",  # The meter that the feature is associated with
                          and decreases grants by usage. Required.
                        "name": "str",  # The name of the feature. Required.
                        "archived": bool,  # Optional. If the feature is archived, it will
                          not be used for grants or usage.
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The time the feature
                          was created.
                        "meterGroupByFilters": {
                            "str": "str"  # Optional. Optional meter group by filters.
                              Useful if the meter scope is broader than what feature tracks.
                        },
                        "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the feature
                          was last updated.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_features_request(
            limit=limit,
            offset=offset,
            order_by=order_by,
            include_archived=include_archived,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def create_feature(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create feature.

        Creates a feature.

        :param body: The feature to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "meterSlug": "str",  # The meter that the feature is associated with and
                      decreases grants by usage. Required.
                    "name": "str",  # The name of the feature. Required.
                    "archived": bool,  # Optional. If the feature is archived, it will not be
                      used for grants or usage.
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    }
                }

                # response body for status code(s): 201
                response == {
                    "id": "str",  # Readonly unique ULID identifier of the feature. Required.
                    "meterSlug": "str",  # The meter that the feature is associated with and
                      decreases grants by usage. Required.
                    "name": "str",  # The name of the feature. Required.
                    "archived": bool,  # Optional. If the feature is archived, it will not be
                      used for grants or usage.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the feature was
                      created.
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    },
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the feature was last
                      updated.
                }
        """

    @overload
    async def create_feature(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create feature.

        Creates a feature.

        :param body: The feature to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "id": "str",  # Readonly unique ULID identifier of the feature. Required.
                    "meterSlug": "str",  # The meter that the feature is associated with and
                      decreases grants by usage. Required.
                    "name": "str",  # The name of the feature. Required.
                    "archived": bool,  # Optional. If the feature is archived, it will not be
                      used for grants or usage.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the feature was
                      created.
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    },
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the feature was last
                      updated.
                }
        """

    @distributed_trace_async
    async def create_feature(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create feature.

        Creates a feature.

        :param body: The feature to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "meterSlug": "str",  # The meter that the feature is associated with and
                      decreases grants by usage. Required.
                    "name": "str",  # The name of the feature. Required.
                    "archived": bool,  # Optional. If the feature is archived, it will not be
                      used for grants or usage.
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    }
                }

                # response body for status code(s): 201
                response == {
                    "id": "str",  # Readonly unique ULID identifier of the feature. Required.
                    "meterSlug": "str",  # The meter that the feature is associated with and
                      decreases grants by usage. Required.
                    "name": "str",  # The name of the feature. Required.
                    "archived": bool,  # Optional. If the feature is archived, it will not be
                      used for grants or usage.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the feature was
                      created.
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    },
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the feature was last
                      updated.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_feature_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_feature(self, feature_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get feature.

        Get feature by key.

        :param feature_id: A unique ULID identifier for a feature. Required.
        :type feature_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Readonly unique ULID identifier of the feature. Required.
                    "meterSlug": "str",  # The meter that the feature is associated with and
                      decreases grants by usage. Required.
                    "name": "str",  # The name of the feature. Required.
                    "archived": bool,  # Optional. If the feature is archived, it will not be
                      used for grants or usage.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the feature was
                      created.
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks.
                    },
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the feature was last
                      updated.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_feature_request(
            feature_id=feature_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_feature(  # pylint: disable=inconsistent-return-statements
        self, feature_id: str, **kwargs: Any
    ) -> None:
        """Delete feature.

        Delete a feature by key.

        :param feature_id: A unique ULID identifier for a feature. Required.
        :type feature_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_feature_request(
            feature_id=feature_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_ledgers(
        self,
        *,
        subject: Optional[List[str]] = None,
        subject_similar_to: Optional[str] = None,
        limit: int = 1000,
        offset: int = 0,
        order_by: str = "id",
        **kwargs: Any
    ) -> List[JSON]:
        """List the already defined ledgers.

        List the already defined ledgers.

        :keyword subject: Query ledgers specific to subjects. Default value is None.
        :paramtype subject: list[str]
        :keyword subject_similar_to: Query ledgers with subjects that are similar to the provided text.
         Default value is None.
        :paramtype subject_similar_to: str
        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword offset: Number of entries to skip. Default value is 0.
        :paramtype offset: int
        :keyword order_by: Order by field. Known values are: "subject", "createdAt", and "id". Default
         value is "id".
        :paramtype order_by: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "id": "str",  # Readonly unique ULID identifier of the ledger.
                          Required.
                        "subject": "str",  # The metering subject this ledger used to track
                          grants for. Required.
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The time the ledger
                          was created.
                        "metadata": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_ledgers_request(
            subject=subject,
            subject_similar_to=subject_similar_to,
            limit=limit,
            offset=offset,
            order_by=order_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def create_ledger(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        """Creates the specified ledger.

        Create or update the specified ledger.

        :param body: The ledger to be created. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "subject": "str",  # The metering subject this ledger used to track grants
                      for. Required.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    }
                }

                # response body for status code(s): 201
                response == {
                    "id": "str",  # Readonly unique ULID identifier of the ledger. Required.
                    "subject": "str",  # The metering subject this ledger used to track grants
                      for. Required.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the ledger was
                      created.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    }
                }
                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "conflictingEntity": {
                        "id": "str",  # Readonly unique ULID identifier of the ledger.
                          Required.
                        "subject": "str",  # The metering subject this ledger used to track
                          grants for. Required.
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The time the ledger
                          was created.
                        "metadata": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @overload
    async def create_ledger(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        """Creates the specified ledger.

        Create or update the specified ledger.

        :param body: The ledger to be created. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "id": "str",  # Readonly unique ULID identifier of the ledger. Required.
                    "subject": "str",  # The metering subject this ledger used to track grants
                      for. Required.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the ledger was
                      created.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    }
                }
                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "conflictingEntity": {
                        "id": "str",  # Readonly unique ULID identifier of the ledger.
                          Required.
                        "subject": "str",  # The metering subject this ledger used to track
                          grants for. Required.
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The time the ledger
                          was created.
                        "metadata": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @distributed_trace_async
    async def create_ledger(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Creates the specified ledger.

        Create or update the specified ledger.

        :param body: The ledger to be created. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "subject": "str",  # The metering subject this ledger used to track grants
                      for. Required.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    }
                }

                # response body for status code(s): 201
                response == {
                    "id": "str",  # Readonly unique ULID identifier of the ledger. Required.
                    "subject": "str",  # The metering subject this ledger used to track grants
                      for. Required.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the ledger was
                      created.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    }
                }
                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "conflictingEntity": {
                        "id": "str",  # Readonly unique ULID identifier of the ledger.
                          Required.
                        "subject": "str",  # The metering subject this ledger used to track
                          grants for. Required.
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The time the ledger
                          was created.
                        "metadata": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_ledger_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 409:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_ledger_balance(
        self, ledger_id: str, *, time: Optional[datetime.datetime] = None, **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get the balance of a specific subject.

        Get the balance of a specific subject.

        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :keyword time: Point of time to query balances: date-time in RFC 3339 format. Defaults to now.
         Default value is None.
        :paramtype time: ~datetime.datetime
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "featureBalances": [
                        {
                            "balance": 0.0,  # The balance of the feature. Required.
                            "id": "str",  # Readonly unique ULID identifier of the
                              feature. Required.
                            "meterSlug": "str",  # The meter that the feature is
                              associated with and decreases grants by usage. Required.
                            "name": "str",  # The name of the feature. Required.
                            "usage": 0.0,  # The usage of the feature. Required.
                            "archived": bool,  # Optional. If the feature is archived, it
                              will not be used for grants or usage.
                            "createdAt": "2020-02-20 00:00:00",  # Optional. The time the
                              feature was created.
                            "meterGroupByFilters": {
                                "str": "str"  # Optional. Optional meter group by
                                  filters. Useful if the meter scope is broader than what feature
                                  tracks.
                            },
                            "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the
                              feature was last updated.
                        }
                    ],
                    "grantBalances": [
                        {
                            "amount": 0.0,  # The amount to grant. Can be positive or
                              negative number. Required.
                            "balance": 0.0,  # The balance of the grant. Required.
                            "effectiveAt": "2020-02-20 00:00:00",  # The effective time.
                              Provided value will be ceiled to metering windowSize (minute). Required.
                            "expiration": {
                                "count": 0,  # The expiration period count like 12
                                  months. Required.
                                "duration": "str"  # The expiration period duration
                                  like month. Required. Known values are: "HOUR", "DAY", "WEEK",
                                  "MONTH", and "YEAR".
                            },
                            "featureID": "str",  # The unique feature ULID that the grant
                              is associated with, if any. Required.
                            "id": "str",  # Readonly unique ULID identifier of the grant.
                              Required.
                            "ledgerID": "str",  # The ledger ID. Required.
                            "type": "str",  # The grant type:   * ``USAGE`` - Increase
                              balance by the amount in the unit of the associated meter. Required.
                              "USAGE"
                            "void": bool,  # If the grant is voided, it will not be
                              applied to the subject's balance anymore. Required.
                            "createdAt": "2020-02-20 00:00:00",  # Optional. The time the
                              grant was created.
                            "expiresAt": "2020-02-20 00:00:00",  # Optional. The
                              expiration date of the grant.
                            "metadata": {
                                "str": "str"  # Optional. Dictionary of
                                  :code:`<string>`.
                            },
                            "parentId": "str",  # Optional. The parent grant ULID that
                              the grant is associated with, if any.
                            "priority": 1,  # Optional. Default value is 1. The priority
                              of the grant. Grants with higher priority are applied first. Priority is
                              a positive decimal numbers. With lower numbers indicating higher
                              importance. For example, a priority of 1 is more urgent than a priority
                              of 2. When there are several grants available for the same subject, the
                              system selects the grant with the highest priority. In cases where grants
                              share the same priority level, the grant closest to its expiration will
                              be used first. In the case of two grants have identical priorities and
                              expiration dates, the system will use the grant that was created first.
                            "rollover": {
                                "type": "str",  # The rollover type to use:   *
                                  ``REMAINING_AMOUNT`` - Rollover remaining amount. *
                                  ``ORIGINAL_AMOUNT`` - Rollover re-applies the full grant amount.
                                  Required. Known values are: "REMAINING_AMOUNT" and "ORIGINAL_AMOUNT".
                                "maxAmount": 0.0  # Optional. Maximum amount to
                                  rollover.
                            },
                            "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the
                              grant was last updated.
                        }
                    ],
                    "subject": "str",  # The subject of the ledger. Required.
                    "lastReset": "2020-02-20 00:00:00",  # Optional. The last reset of the
                      ledger.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    }
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_ledger_balance_request(
            ledger_id=ledger_id,
            time=time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_ledger_history(
        self,
        ledger_id: str,
        *,
        from_parameter: datetime.datetime,
        limit: int = 1000,
        offset: int = 0,
        to: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Get the history of a ledger.

        Get the history of a specific ledger.

        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :keyword from_parameter: Start of time range to query ledger: date-time in RFC 3339 format.
         Required.
        :paramtype from_parameter: ~datetime.datetime
        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword offset: Number of entries to skip. Default value is 0.
        :paramtype offset: int
        :keyword to: End of time range to query ledger: date-time in RFC 3339 format. Defaults to now.
         Default value is None.
        :paramtype to: ~datetime.datetime
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "amount": 0.0,  # The amount to apply. Can be positive or negative
                          number. If applicable. Required.
                        "featureID": "str",  # The unique feature ULID that the entry is
                          associated with. Required.
                        "id": "str",  # Readonly unique ULID identifier of the ledger entry.
                          Required.
                        "time": "2020-02-20 00:00:00",  # The time the ledger entry was
                          created. Required.
                        "type": "str",  # Required. Known values are: "GRANT", "VOID",
                          "RESET", and "GRANT_USAGE".
                        "period": {
                            "from": "2020-02-20 00:00:00",  # Period start time where the
                              amount was applied. If applicable. Required.
                            "to": "2020-02-20 00:00:00"  # Period end time where the
                              amount was applied. If applicable. Required.
                        }
                    }
                ]
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_get_ledger_history_request(
            ledger_id=ledger_id,
            from_parameter=from_parameter,
            limit=limit,
            offset=offset,
            to=to,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def reset_ledger(
        self, ledger_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Reset the ledger's balance.

        Resets the ledger's balances to zero for a specific subject and re-apply active grants with
        rollover configuration.

        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :param body: Details for the reset. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "effectiveAt": "2020-02-20 00:00:00",  # The time to reset the ledger. It
                      cannot be in the future. The value will be floored to metering windowSize
                      (minute). Required.
                    "id": "str"  # Readonly unique ULID identifier of the reset. Required.
                }

                # response body for status code(s): 201
                response == {
                    "effectiveAt": "2020-02-20 00:00:00",  # The time to reset the ledger. It
                      cannot be in the future. The value will be floored to metering windowSize
                      (minute). Required.
                    "id": "str"  # Readonly unique ULID identifier of the reset. Required.
                }
        """

    @overload
    async def reset_ledger(
        self, ledger_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Reset the ledger's balance.

        Resets the ledger's balances to zero for a specific subject and re-apply active grants with
        rollover configuration.

        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :param body: Details for the reset. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "effectiveAt": "2020-02-20 00:00:00",  # The time to reset the ledger. It
                      cannot be in the future. The value will be floored to metering windowSize
                      (minute). Required.
                    "id": "str"  # Readonly unique ULID identifier of the reset. Required.
                }
        """

    @distributed_trace_async
    async def reset_ledger(self, ledger_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Reset the ledger's balance.

        Resets the ledger's balances to zero for a specific subject and re-apply active grants with
        rollover configuration.

        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :param body: Details for the reset. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "effectiveAt": "2020-02-20 00:00:00",  # The time to reset the ledger. It
                      cannot be in the future. The value will be floored to metering windowSize
                      (minute). Required.
                    "id": "str"  # Readonly unique ULID identifier of the reset. Required.
                }

                # response body for status code(s): 201
                response == {
                    "effectiveAt": "2020-02-20 00:00:00",  # The time to reset the ledger. It
                      cannot be in the future. The value will be floored to metering windowSize
                      (minute). Required.
                    "id": "str"  # Readonly unique ULID identifier of the reset. Required.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_reset_ledger_request(
            ledger_id=ledger_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_ledger_grants(
        self, *, ledger_id: Optional[str] = None, limit: int = 1000, include_voids: bool = False, **kwargs: Any
    ) -> List[JSON]:
        # pylint: disable=line-too-long
        """List grants for multiple ledgers.

        List grants for multiple ledgers.

        :keyword ledger_id: Filtering and group by multiple subjects.

         Usage: ``?ledgerID=01HX6VK5C498B3ABY9PR1069PP``. Default value is None.
        :paramtype ledger_id: str
        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword include_voids: Include void entries in the response. Default value is False.
        :paramtype include_voids: bool
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "amount": 0.0,  # The amount to grant. Can be positive or negative
                          number. Required.
                        "effectiveAt": "2020-02-20 00:00:00",  # The effective time. Provided
                          value will be ceiled to metering windowSize (minute). Required.
                        "expiration": {
                            "count": 0,  # The expiration period count like 12 months.
                              Required.
                            "duration": "str"  # The expiration period duration like
                              month. Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and
                              "YEAR".
                        },
                        "featureID": "str",  # The unique feature ULID that the grant is
                          associated with, if any. Required.
                        "id": "str",  # Readonly unique ULID identifier of the grant.
                          Required.
                        "ledgerID": "str",  # The ledger ID. Required.
                        "type": "str",  # The grant type:   * ``USAGE`` - Increase balance by
                          the amount in the unit of the associated meter. Required. "USAGE"
                        "void": bool,  # If the grant is voided, it will not be applied to
                          the subject's balance anymore. Required.
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The time the grant
                          was created.
                        "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date
                          of the grant.
                        "metadata": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        },
                        "parentId": "str",  # Optional. The parent grant ULID that the grant
                          is associated with, if any.
                        "priority": 1,  # Optional. Default value is 1. The priority of the
                          grant. Grants with higher priority are applied first. Priority is a positive
                          decimal numbers. With lower numbers indicating higher importance. For
                          example, a priority of 1 is more urgent than a priority of 2. When there are
                          several grants available for the same subject, the system selects the grant
                          with the highest priority. In cases where grants share the same priority
                          level, the grant closest to its expiration will be used first. In the case of
                          two grants have identical priorities and expiration dates, the system will
                          use the grant that was created first.
                        "rollover": {
                            "type": "str",  # The rollover type to use:   *
                              ``REMAINING_AMOUNT`` - Rollover remaining amount. * ``ORIGINAL_AMOUNT`` -
                              Rollover re-applies the full grant amount. Required. Known values are:
                              "REMAINING_AMOUNT" and "ORIGINAL_AMOUNT".
                            "maxAmount": 0.0  # Optional. Maximum amount to rollover.
                        },
                        "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the grant
                          was last updated.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_ledger_grants_request(
            ledger_id=ledger_id,
            limit=limit,
            include_voids=include_voids,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def list_ledger_grants_by_ledger(
        self, ledger_id: str, *, limit: int = 1000, include_voids: bool = False, **kwargs: Any
    ) -> List[JSON]:
        # pylint: disable=line-too-long
        """List ledger grants.

        List ledger grants for a specific ledger.

        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword include_voids: Include void entries in the response. Default value is False.
        :paramtype include_voids: bool
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "amount": 0.0,  # The amount to grant. Can be positive or negative
                          number. Required.
                        "effectiveAt": "2020-02-20 00:00:00",  # The effective time. Provided
                          value will be ceiled to metering windowSize (minute). Required.
                        "expiration": {
                            "count": 0,  # The expiration period count like 12 months.
                              Required.
                            "duration": "str"  # The expiration period duration like
                              month. Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and
                              "YEAR".
                        },
                        "featureID": "str",  # The unique feature ULID that the grant is
                          associated with, if any. Required.
                        "id": "str",  # Readonly unique ULID identifier of the grant.
                          Required.
                        "ledgerID": "str",  # The ledger ID. Required.
                        "type": "str",  # The grant type:   * ``USAGE`` - Increase balance by
                          the amount in the unit of the associated meter. Required. "USAGE"
                        "void": bool,  # If the grant is voided, it will not be applied to
                          the subject's balance anymore. Required.
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The time the grant
                          was created.
                        "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date
                          of the grant.
                        "metadata": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        },
                        "parentId": "str",  # Optional. The parent grant ULID that the grant
                          is associated with, if any.
                        "priority": 1,  # Optional. Default value is 1. The priority of the
                          grant. Grants with higher priority are applied first. Priority is a positive
                          decimal numbers. With lower numbers indicating higher importance. For
                          example, a priority of 1 is more urgent than a priority of 2. When there are
                          several grants available for the same subject, the system selects the grant
                          with the highest priority. In cases where grants share the same priority
                          level, the grant closest to its expiration will be used first. In the case of
                          two grants have identical priorities and expiration dates, the system will
                          use the grant that was created first.
                        "rollover": {
                            "type": "str",  # The rollover type to use:   *
                              ``REMAINING_AMOUNT`` - Rollover remaining amount. * ``ORIGINAL_AMOUNT`` -
                              Rollover re-applies the full grant amount. Required. Known values are:
                              "REMAINING_AMOUNT" and "ORIGINAL_AMOUNT".
                            "maxAmount": 0.0  # Optional. Maximum amount to rollover.
                        },
                        "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the grant
                          was last updated.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_ledger_grants_by_ledger_request(
            ledger_id=ledger_id,
            limit=limit,
            include_voids=include_voids,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def create_ledger_grant(
        self, ledger_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a grant on a specific ledger.

        Create a grant on a specific ledger.

        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :param body: The grant to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "amount": 0.0,  # The amount to grant. Can be positive or negative number.
                      Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # The effective time. Provided value
                      will be ceiled to metering windowSize (minute). Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "featureID": "str",  # The unique feature ULID that the grant is associated
                      with, if any. Required.
                    "type": "str",  # The grant type:   * ``USAGE`` - Increase balance by the
                      amount in the unit of the associated meter. Required. "USAGE"
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the grant was
                      created.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "parentId": "str",  # Optional. The parent grant ULID that the grant is
                      associated with, if any.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "rollover": {
                        "type": "str",  # The rollover type to use:   * ``REMAINING_AMOUNT``
                          - Rollover remaining amount. * ``ORIGINAL_AMOUNT`` - Rollover re-applies the
                          full grant amount. Required. Known values are: "REMAINING_AMOUNT" and
                          "ORIGINAL_AMOUNT".
                        "maxAmount": 0.0  # Optional. Maximum amount to rollover.
                    },
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the grant was last
                      updated.
                }

                # response body for status code(s): 201
                response == {
                    "amount": 0.0,  # The amount to grant. Can be positive or negative number.
                      Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # The effective time. Provided value
                      will be ceiled to metering windowSize (minute). Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "featureID": "str",  # The unique feature ULID that the grant is associated
                      with, if any. Required.
                    "id": "str",  # Readonly unique ULID identifier of the grant. Required.
                    "ledgerID": "str",  # The ledger ID. Required.
                    "type": "str",  # The grant type:   * ``USAGE`` - Increase balance by the
                      amount in the unit of the associated meter. Required. "USAGE"
                    "void": bool,  # If the grant is voided, it will not be applied to the
                      subject's balance anymore. Required.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the grant was
                      created.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date of the
                      grant.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "parentId": "str",  # Optional. The parent grant ULID that the grant is
                      associated with, if any.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "rollover": {
                        "type": "str",  # The rollover type to use:   * ``REMAINING_AMOUNT``
                          - Rollover remaining amount. * ``ORIGINAL_AMOUNT`` - Rollover re-applies the
                          full grant amount. Required. Known values are: "REMAINING_AMOUNT" and
                          "ORIGINAL_AMOUNT".
                        "maxAmount": 0.0  # Optional. Maximum amount to rollover.
                    },
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the grant was last
                      updated.
                }
        """

    @overload
    async def create_ledger_grant(
        self, ledger_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a grant on a specific ledger.

        Create a grant on a specific ledger.

        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :param body: The grant to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "amount": 0.0,  # The amount to grant. Can be positive or negative number.
                      Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # The effective time. Provided value
                      will be ceiled to metering windowSize (minute). Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "featureID": "str",  # The unique feature ULID that the grant is associated
                      with, if any. Required.
                    "id": "str",  # Readonly unique ULID identifier of the grant. Required.
                    "ledgerID": "str",  # The ledger ID. Required.
                    "type": "str",  # The grant type:   * ``USAGE`` - Increase balance by the
                      amount in the unit of the associated meter. Required. "USAGE"
                    "void": bool,  # If the grant is voided, it will not be applied to the
                      subject's balance anymore. Required.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the grant was
                      created.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date of the
                      grant.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "parentId": "str",  # Optional. The parent grant ULID that the grant is
                      associated with, if any.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "rollover": {
                        "type": "str",  # The rollover type to use:   * ``REMAINING_AMOUNT``
                          - Rollover remaining amount. * ``ORIGINAL_AMOUNT`` - Rollover re-applies the
                          full grant amount. Required. Known values are: "REMAINING_AMOUNT" and
                          "ORIGINAL_AMOUNT".
                        "maxAmount": 0.0  # Optional. Maximum amount to rollover.
                    },
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the grant was last
                      updated.
                }
        """

    @distributed_trace_async
    async def create_ledger_grant(self, ledger_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a grant on a specific ledger.

        Create a grant on a specific ledger.

        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :param body: The grant to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "amount": 0.0,  # The amount to grant. Can be positive or negative number.
                      Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # The effective time. Provided value
                      will be ceiled to metering windowSize (minute). Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "featureID": "str",  # The unique feature ULID that the grant is associated
                      with, if any. Required.
                    "type": "str",  # The grant type:   * ``USAGE`` - Increase balance by the
                      amount in the unit of the associated meter. Required. "USAGE"
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the grant was
                      created.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "parentId": "str",  # Optional. The parent grant ULID that the grant is
                      associated with, if any.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "rollover": {
                        "type": "str",  # The rollover type to use:   * ``REMAINING_AMOUNT``
                          - Rollover remaining amount. * ``ORIGINAL_AMOUNT`` - Rollover re-applies the
                          full grant amount. Required. Known values are: "REMAINING_AMOUNT" and
                          "ORIGINAL_AMOUNT".
                        "maxAmount": 0.0  # Optional. Maximum amount to rollover.
                    },
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the grant was last
                      updated.
                }

                # response body for status code(s): 201
                response == {
                    "amount": 0.0,  # The amount to grant. Can be positive or negative number.
                      Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # The effective time. Provided value
                      will be ceiled to metering windowSize (minute). Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "featureID": "str",  # The unique feature ULID that the grant is associated
                      with, if any. Required.
                    "id": "str",  # Readonly unique ULID identifier of the grant. Required.
                    "ledgerID": "str",  # The ledger ID. Required.
                    "type": "str",  # The grant type:   * ``USAGE`` - Increase balance by the
                      amount in the unit of the associated meter. Required. "USAGE"
                    "void": bool,  # If the grant is voided, it will not be applied to the
                      subject's balance anymore. Required.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the grant was
                      created.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date of the
                      grant.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "parentId": "str",  # Optional. The parent grant ULID that the grant is
                      associated with, if any.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "rollover": {
                        "type": "str",  # The rollover type to use:   * ``REMAINING_AMOUNT``
                          - Rollover remaining amount. * ``ORIGINAL_AMOUNT`` - Rollover re-applies the
                          full grant amount. Required. Known values are: "REMAINING_AMOUNT" and
                          "ORIGINAL_AMOUNT".
                        "maxAmount": 0.0  # Optional. Maximum amount to rollover.
                    },
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the grant was last
                      updated.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_ledger_grant_request(
            ledger_id=ledger_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_ledger_grant(self, ledger_id: str, ledger_grant_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a single grant.

        Gets the grant for a ledger by ID.

        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :param ledger_grant_id: A unique identifier for a ledger grant. Required.
        :type ledger_grant_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "amount": 0.0,  # The amount to grant. Can be positive or negative number.
                      Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # The effective time. Provided value
                      will be ceiled to metering windowSize (minute). Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "featureID": "str",  # The unique feature ULID that the grant is associated
                      with, if any. Required.
                    "id": "str",  # Readonly unique ULID identifier of the grant. Required.
                    "ledgerID": "str",  # The ledger ID. Required.
                    "type": "str",  # The grant type:   * ``USAGE`` - Increase balance by the
                      amount in the unit of the associated meter. Required. "USAGE"
                    "void": bool,  # If the grant is voided, it will not be applied to the
                      subject's balance anymore. Required.
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The time the grant was
                      created.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date of the
                      grant.
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "parentId": "str",  # Optional. The parent grant ULID that the grant is
                      associated with, if any.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "rollover": {
                        "type": "str",  # The rollover type to use:   * ``REMAINING_AMOUNT``
                          - Rollover remaining amount. * ``ORIGINAL_AMOUNT`` - Rollover re-applies the
                          full grant amount. Required. Known values are: "REMAINING_AMOUNT" and
                          "ORIGINAL_AMOUNT".
                        "maxAmount": 0.0  # Optional. Maximum amount to rollover.
                    },
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The time the grant was last
                      updated.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_ledger_grant_request(
            ledger_id=ledger_id,
            ledger_grant_id=ledger_grant_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def void_ledger_grant(  # pylint: disable=inconsistent-return-statements
        self, ledger_grant_id: str, ledger_id: str, **kwargs: Any
    ) -> None:
        """Void ledger grant.

        Void a ledger grant by ID. Partially or fully used grants cannot be voided.
        Voided grant won't be applied to the subject's balance anymore.

        :param ledger_grant_id: A unique identifier for a ledger grant. Required.
        :type ledger_grant_id: str
        :param ledger_id: A unique identifier for a ledger. Required.
        :type ledger_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_void_ledger_grant_request(
            ledger_grant_id=ledger_grant_id,
            ledger_id=ledger_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore
