# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/python@6.13.7)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ..._operations._operations import (
    build_create_entitlement_request,
    build_create_feature_request,
    build_create_grant_request,
    build_create_meter_request,
    build_create_notification_channel_request,
    build_create_notification_rule_request,
    build_create_portal_token_request,
    build_delete_entitlement_request,
    build_delete_feature_request,
    build_delete_meter_request,
    build_delete_notification_channel_request,
    build_delete_notification_rule_request,
    build_delete_subject_request,
    build_get_debug_metrics_request,
    build_get_entitlement_by_id_request,
    build_get_entitlement_history_request,
    build_get_entitlement_request,
    build_get_entitlement_value_request,
    build_get_feature_request,
    build_get_meter_request,
    build_get_notification_channel_request,
    build_get_notification_event_request,
    build_get_notification_rule_request,
    build_get_subject_request,
    build_ingest_events_request,
    build_invalidate_portal_tokens_request,
    build_list_entitlement_grants_request,
    build_list_entitlements_request,
    build_list_events_request,
    build_list_features_request,
    build_list_grants_request,
    build_list_meter_subjects_request,
    build_list_meters_request,
    build_list_notification_channels_request,
    build_list_notification_events_request,
    build_list_notification_rules_request,
    build_list_portal_tokens_request,
    build_list_subject_entitlements_request,
    build_list_subjects_request,
    build_override_entitlement_request,
    build_query_meter_request,
    build_query_portal_meter_request,
    build_receive_svix_operational_event_request,
    build_reset_entitlement_usage_request,
    build_test_notification_rule_request,
    build_update_notification_channel_request,
    build_update_notification_rule_request,
    build_upsert_subject_request,
    build_void_grant_request,
)
from .._vendor import ClientMixinABC

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class ClientOperationsMixin(ClientMixinABC):  # pylint: disable=too-many-public-methods
    @distributed_trace_async
    async def list_events(
        self,
        *,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        limit: int = 100,
        **kwargs: Any
    ) -> List[JSON]:
        # pylint: disable=line-too-long
        """List ingested events.

        List ingested events within a time range.

        :keyword from_parameter: Start date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype to: ~datetime.datetime
        :keyword limit: Number of events to return. Default value is 100.
        :paramtype limit: int
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "event": {
                            "id": "str",  # Identifies the event. Required.
                            "source": "str",  # Identifies the context in which an event
                              happened. Required.
                            "specversion": "str",  # The version of the CloudEvents
                              specification which the event uses. Required.
                            "subject": "str",  # Describes the subject of the event in
                              the context of the event producer (identified by source). Required.
                            "type": "str",  # Describes the type of event related to the
                              originating occurrence. Required.
                            "data": {
                                "str": {}  # Optional. The event payload.
                            },
                            "datacontenttype": "str",  # Optional. Content type of the
                              data value. Must adhere to RFC 2046 format. "application/json"
                            "dataschema": "str",  # Optional. Identifies the schema that
                              data adheres to.
                            "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when
                              the occurrence happened. Must adhere to RFC 3339.
                        },
                        "ingestedAt": "2020-02-20 00:00:00",  # The date and time the event
                          was ingested. Required.
                        "storedAt": "2020-02-20 00:00:00",  # The date and time the event was
                          stored. Required.
                        "validationError": "str"  # Optional.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_events_request(
            from_parameter=from_parameter,
            to=to,
            limit=limit,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def ingest_events(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/cloudevents+json", **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Ingest events.

        Ingests an event or batch of events following the CloudEvents specification.

        :param body: The event or batch of events to ingest.
         The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
         The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
         Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/cloudevents+json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Identifies the event. Required.
                    "source": "str",  # Identifies the context in which an event happened.
                      Required.
                    "specversion": "str",  # The version of the CloudEvents specification which
                      the event uses. Required.
                    "subject": "str",  # Describes the subject of the event in the context of the
                      event producer (identified by source). Required.
                    "type": "str",  # Describes the type of event related to the originating
                      occurrence. Required.
                    "data": {
                        "str": {}  # Optional. The event payload.
                    },
                    "datacontenttype": "str",  # Optional. Content type of the data value. Must
                      adhere to RFC 2046 format. "application/json"
                    "dataschema": "str",  # Optional. Identifies the schema that data adheres to.
                    "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when the occurrence
                      happened. Must adhere to RFC 3339.
                }
        """

    @overload
    async def ingest_events(  # pylint: disable=inconsistent-return-statements
        self, body: List[JSON], *, content_type: str = "application/cloudevents-batch+json", **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Ingest events.

        Ingests an event or batch of events following the CloudEvents specification.

        :param body: The event or batch of events to ingest.
         The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
         The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
         Required.
        :type body: list[JSON]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/cloudevents-batch+json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = [
                    {
                        "id": "str",  # Identifies the event. Required.
                        "source": "str",  # Identifies the context in which an event
                          happened. Required.
                        "specversion": "str",  # The version of the CloudEvents specification
                          which the event uses. Required.
                        "subject": "str",  # Describes the subject of the event in the
                          context of the event producer (identified by source). Required.
                        "type": "str",  # Describes the type of event related to the
                          originating occurrence. Required.
                        "data": {
                            "str": {}  # Optional. The event payload.
                        },
                        "datacontenttype": "str",  # Optional. Content type of the data
                          value. Must adhere to RFC 2046 format. "application/json"
                        "dataschema": "str",  # Optional. Identifies the schema that data
                          adheres to.
                        "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when the
                          occurrence happened. Must adhere to RFC 3339.
                    }
                ]
        """

    @distributed_trace_async
    async def ingest_events(  # pylint: disable=inconsistent-return-statements
        self, body: Union[JSON, List[JSON]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Ingest events.

        Ingests an event or batch of events following the CloudEvents specification.

        :param body: The event or batch of events to ingest.
         The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
         The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema. Is
         either a JSON type or a [JSON] type. Required.
        :type body: JSON or list[JSON]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Identifies the event. Required.
                    "source": "str",  # Identifies the context in which an event happened.
                      Required.
                    "specversion": "str",  # The version of the CloudEvents specification which
                      the event uses. Required.
                    "subject": "str",  # Describes the subject of the event in the context of the
                      event producer (identified by source). Required.
                    "type": "str",  # Describes the type of event related to the originating
                      occurrence. Required.
                    "data": {
                        "str": {}  # Optional. The event payload.
                    },
                    "datacontenttype": "str",  # Optional. Content type of the data value. Must
                      adhere to RFC 2046 format. "application/json"
                    "dataschema": "str",  # Optional. Identifies the schema that data adheres to.
                    "time": "2020-02-20 00:00:00"  # Optional. Timestamp of when the occurrence
                      happened. Must adhere to RFC 3339.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _json = None
        if isinstance(body, MutableMapping):
            content_type = content_type or "application/cloudevents+json"
            _json = body
        elif isinstance(body, list):
            content_type = content_type or "application/cloudevents-batch+json"
            _json = body

        _request = build_ingest_events_request(
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_meters(self, **kwargs: Any) -> List[JSON]:
        # pylint: disable=line-too-long
        """List meters.

        List meters.

        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "aggregation": "str",  # The aggregation type to use for the meter.
                          Required. Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and
                          "MAX".
                        "eventType": "str",  # The event type to aggregate. Required.
                        "slug": "str",  # A unique, human-readable identifier for the meter.
                          Must consist only alphanumeric and underscore characters. Required.
                        "windowSize": "str",  # Aggregation window size. Required. Known
                          values are: "MINUTE", "HOUR", and "DAY".
                        "description": "str",  # Optional. A description of the meter.
                        "groupBy": {
                            "str": "str"  # Optional. Named JSONPath expressions to
                              extract the group by values from the event data. Keys must be unique and
                              consist only alphanumeric and underscore characters.
                        },
                        "id": "str",  # Optional. A unique identifier for the meter.
                        "valueProperty": "str"  # Optional. JSONPath expression to extract
                          the value from the ingested event's data property. The ingested value for
                          SUM, AVG, MIN, and MAX aggregations is a number or a string that can be
                          parsed to a number. For UNIQUE_COUNT aggregation, the ingested value must be
                          a string. For COUNT aggregation the valueProperty is ignored.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_meters_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def create_meter(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """☁ Create meter.

        *Available in OpenMeter Cloud.*
        *In the open-source version, meters are created in the configuration file.*

        Create a meter.

        :param body: The meter to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }

                # response body for status code(s): 201
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """

    @overload
    async def create_meter(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """☁ Create meter.

        *Available in OpenMeter Cloud.*
        *In the open-source version, meters are created in the configuration file.*

        Create a meter.

        :param body: The meter to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """

    @distributed_trace_async
    async def create_meter(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """☁ Create meter.

        *Available in OpenMeter Cloud.*
        *In the open-source version, meters are created in the configuration file.*

        Create a meter.

        :param body: The meter to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }

                # response body for status code(s): 201
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_meter_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_meter(self, meter_id_or_slug: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get meter.

        Get meter by ID or slug.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aggregation": "str",  # The aggregation type to use for the meter. Required.
                      Known values are: "SUM", "COUNT", "UNIQUE_COUNT", "AVG", "MIN", and "MAX".
                    "eventType": "str",  # The event type to aggregate. Required.
                    "slug": "str",  # A unique, human-readable identifier for the meter. Must
                      consist only alphanumeric and underscore characters. Required.
                    "windowSize": "str",  # Aggregation window size. Required. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                    "description": "str",  # Optional. A description of the meter.
                    "groupBy": {
                        "str": "str"  # Optional. Named JSONPath expressions to extract the
                          group by values from the event data. Keys must be unique and consist only
                          alphanumeric and underscore characters.
                    },
                    "id": "str",  # Optional. A unique identifier for the meter.
                    "valueProperty": "str"  # Optional. JSONPath expression to extract the value
                      from the ingested event's data property. The ingested value for SUM, AVG, MIN,
                      and MAX aggregations is a number or a string that can be parsed to a number. For
                      UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT
                      aggregation the valueProperty is ignored.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_meter_request(
            meter_id_or_slug=meter_id_or_slug,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_meter(  # pylint: disable=inconsistent-return-statements
        self, meter_id_or_slug: str, **kwargs: Any
    ) -> None:
        """☁ Delete meter.

        *Available in OpenMeter Cloud.*

        Delete a meter by ID or slug.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            404: lambda response: ResourceNotFoundError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_meter_request(
            meter_id_or_slug=meter_id_or_slug,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def query_meter(
        self,
        meter_id_or_slug: str,
        *,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        window_size: Optional[str] = None,
        window_time_zone: str = "UTC",
        subject: Optional[List[str]] = None,
        filter_group_by: Optional[Dict[str, str]] = None,
        group_by: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Union[JSON, str]:
        """Query meter.

        Query meter for usage.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :keyword from_parameter: Start date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype to: ~datetime.datetime
        :keyword window_size: If not specified, a single usage aggregate will be returned for the
         entirety of the specified period for each subject and group. Known values are: "MINUTE",
         "HOUR", and "DAY". Default value is None.
        :paramtype window_size: str
        :keyword window_time_zone: The value is the name of the time zone as defined in the IANA Time
         Zone Database (http://www.iana.org/time-zones).
         If not specified, the UTC timezone will be used. Default value is "UTC".
        :paramtype window_time_zone: str
        :keyword subject: Filtering by multiple subjects.

         Usage: ``?subject=customer-1&subject=customer-2``. Default value is None.
        :paramtype subject: list[str]
        :keyword filter_group_by: Default value is None.
        :paramtype filter_group_by: dict[str, str]
        :keyword group_by: If not specified a single aggregate will be returned for each subject and
         time window.
         ``subject`` is a reserved group by value. Default value is None.
        :paramtype group_by: list[str]
        :return: JSON object or str
        :rtype: JSON or str
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "value": 0.0,  # Required.
                            "windowEnd": "2020-02-20 00:00:00",  # Required.
                            "windowStart": "2020-02-20 00:00:00",  # Required.
                            "groupBy": {
                                "str": "str"  # Optional. Dictionary of
                                  :code:`<string>`.
                            },
                            "subject": "str"  # Optional. The subject of the meter value.
                        }
                    ],
                    "from": "2020-02-20 00:00:00",  # Optional.
                    "to": "2020-02-20 00:00:00",  # Optional.
                    "windowSize": "str"  # Optional. Aggregation window size. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[JSON, str]] = kwargs.pop("cls", None)

        _request = build_query_meter_request(
            meter_id_or_slug=meter_id_or_slug,
            from_parameter=from_parameter,
            to=to,
            window_size=window_size,
            window_time_zone=window_time_zone,
            subject=subject,
            filter_group_by=filter_group_by,
            group_by=group_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[JSON, str], deserialized), {})  # type: ignore

        return cast(Union[JSON, str], deserialized)  # type: ignore

    @distributed_trace_async
    async def list_meter_subjects(self, meter_id_or_slug: str, **kwargs: Any) -> List[str]:
        """List meter subjects.

        List subjects for a meter.

        :param meter_id_or_slug: A unique identifier for the meter. Required.
        :type meter_id_or_slug: str
        :return: list of str
        :rtype: list[str]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    "str"  # Optional.
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[str]] = kwargs.pop("cls", None)

        _request = build_list_meter_subjects_request(
            meter_id_or_slug=meter_id_or_slug,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[str], deserialized), {})  # type: ignore

        return cast(List[str], deserialized)  # type: ignore

    @overload
    async def create_portal_token(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        """Create portal token.

        Create a consumer portal token.

        :param body: The portal token to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }

                # response body for status code(s): 200
                response == {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }
        """

    @overload
    async def create_portal_token(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create portal token.

        Create a consumer portal token.

        :param body: The portal token to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }
        """

    @distributed_trace_async
    async def create_portal_token(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create portal token.

        Create a consumer portal token.

        :param body: The portal token to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }

                # response body for status code(s): 200
                response == {
                    "subject": "str",  # Required.
                    "allowedMeterSlugs": [
                        "str"  # Optional. Optional, if defined only the specified meters
                          will be allowed.
                    ],
                    "createdAt": "2020-02-20 00:00:00",  # Optional.
                    "expired": bool,  # Optional.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "token": "str"  # Optional. The token is only returned at creation.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_portal_token_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_portal_tokens(self, *, limit: int = 25, **kwargs: Any) -> List[JSON]:
        """☁ List portal tokens.

        *Available in OpenMeter Cloud.*

        List consumer portal tokens.

        :keyword limit: Number of portal tokens to return. Default is 25. Default value is 25.
        :paramtype limit: int
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "subject": "str",  # Required.
                        "allowedMeterSlugs": [
                            "str"  # Optional. Optional, if defined only the specified
                              meters will be allowed.
                        ],
                        "createdAt": "2020-02-20 00:00:00",  # Optional.
                        "expired": bool,  # Optional.
                        "expiresAt": "2020-02-20 00:00:00",  # Optional.
                        "id": "str",  # Optional.
                        "token": "str"  # Optional. The token is only returned at creation.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_portal_tokens_request(
            limit=limit,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def invalidate_portal_tokens(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """☁ Invalidate portal tokens.

        *Available in OpenMeter Cloud.*

        Invalidates consumer portal tokens by ID or subject.

        :param body: If no id or subject is specified, all tokens will be invalidated. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Optional. Invalidate a portal token by ID.
                    "subject": "str"  # Optional. Invalidate all portal tokens for a subject.
                }
        """

    @overload
    async def invalidate_portal_tokens(  # pylint: disable=inconsistent-return-statements
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """☁ Invalidate portal tokens.

        *Available in OpenMeter Cloud.*

        Invalidates consumer portal tokens by ID or subject.

        :param body: If no id or subject is specified, all tokens will be invalidated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def invalidate_portal_tokens(  # pylint: disable=inconsistent-return-statements
        self, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        """☁ Invalidate portal tokens.

        *Available in OpenMeter Cloud.*

        Invalidates consumer portal tokens by ID or subject.

        :param body: If no id or subject is specified, all tokens will be invalidated. Is either a JSON
         type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Optional. Invalidate a portal token by ID.
                    "subject": "str"  # Optional. Invalidate all portal tokens for a subject.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_invalidate_portal_tokens_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_subjects(self, **kwargs: Any) -> List[JSON]:
        """☁ List subjects.

        *Available in OpenMeter Cloud.*

        List subjects.

        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_subjects_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def upsert_subject(
        self, body: List[JSON], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[JSON]:
        """☁ Upsert subject.

        *Available in OpenMeter Cloud.*

        Upserts a subject. Creates or updates subject.
        If the subject doesn't exist, it will be created.
        If the subject exists, it will be partially updated with the provided fields.

        :param body: The subject to upsert. Required.
        :type body: list[JSON]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """

    @overload
    async def upsert_subject(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[JSON]:
        """☁ Upsert subject.

        *Available in OpenMeter Cloud.*

        Upserts a subject. Creates or updates subject.
        If the subject doesn't exist, it will be created.
        If the subject exists, it will be partially updated with the provided fields.

        :param body: The subject to upsert. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """

    @distributed_trace_async
    async def upsert_subject(self, body: Union[List[JSON], IO[bytes]], **kwargs: Any) -> List[JSON]:
        """☁ Upsert subject.

        *Available in OpenMeter Cloud.*

        Upserts a subject. Creates or updates subject.
        If the subject doesn't exist, it will be created.
        If the subject exists, it will be partially updated with the provided fields.

        :param body: The subject to upsert. Is either a [JSON] type or a IO[bytes] type. Required.
        :type body: list[JSON] or IO[bytes]
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "key": "str",  # Required.
                        "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                        "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                        "displayName": "str",  # Optional.
                        "id": "str",  # Optional.
                        "metadata": {
                            "str": {}  # Optional. Dictionary of :code:`<any>`.
                        },
                        "stripeCustomerId": "str"  # Optional.
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_upsert_subject_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def get_subject(self, subject_id_or_key: str, **kwargs: Any) -> JSON:
        """☁ Get subject.

        *Available in OpenMeter Cloud.*

        Get subject by ID or key.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "key": "str",  # Required.
                    "currentPeriodEnd": "2020-02-20 00:00:00",  # Optional.
                    "currentPeriodStart": "2020-02-20 00:00:00",  # Optional.
                    "displayName": "str",  # Optional.
                    "id": "str",  # Optional.
                    "metadata": {
                        "str": {}  # Optional. Dictionary of :code:`<any>`.
                    },
                    "stripeCustomerId": "str"  # Optional.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_subject_request(
            subject_id_or_key=subject_id_or_key,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_subject(  # pylint: disable=inconsistent-return-statements
        self, subject_id_or_key: str, **kwargs: Any
    ) -> None:
        """☁ Delete subject.

        *Available in OpenMeter Cloud.*

        Delete a subject by ID or key.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_subject_request(
            subject_id_or_key=subject_id_or_key,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def query_portal_meter(
        self,
        meter_slug: str,
        *,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        window_size: Optional[str] = None,
        window_time_zone: str = "UTC",
        filter_group_by: Optional[Dict[str, str]] = None,
        group_by: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Union[JSON, str]:
        """Query portal meter.

        Query meter for consumer portal. This endpoint is publicly exposable to consumers.

        :param meter_slug: A unique identifier for the meter. Required.
        :type meter_slug: str
        :keyword from_parameter: Start date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype to: ~datetime.datetime
        :keyword window_size: If not specified, a single usage aggregate will be returned for the
         entirety of the specified period for each subject and group. Known values are: "MINUTE",
         "HOUR", and "DAY". Default value is None.
        :paramtype window_size: str
        :keyword window_time_zone: The value is the name of the time zone as defined in the IANA Time
         Zone Database (http://www.iana.org/time-zones).
         If not specified, the UTC timezone will be used. Default value is "UTC".
        :paramtype window_time_zone: str
        :keyword filter_group_by: Default value is None.
        :paramtype filter_group_by: dict[str, str]
        :keyword group_by: If not specified a single aggregate will be returned for each subject and
         time window.
         ``subject`` is a reserved group by value. Default value is None.
        :paramtype group_by: list[str]
        :return: JSON object or str
        :rtype: JSON or str
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "value": 0.0,  # Required.
                            "windowEnd": "2020-02-20 00:00:00",  # Required.
                            "windowStart": "2020-02-20 00:00:00",  # Required.
                            "groupBy": {
                                "str": "str"  # Optional. Dictionary of
                                  :code:`<string>`.
                            },
                            "subject": "str"  # Optional. The subject of the meter value.
                        }
                    ],
                    "from": "2020-02-20 00:00:00",  # Optional.
                    "to": "2020-02-20 00:00:00",  # Optional.
                    "windowSize": "str"  # Optional. Aggregation window size. Known values are:
                      "MINUTE", "HOUR", and "DAY".
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[JSON, str]] = kwargs.pop("cls", None)

        _request = build_query_portal_meter_request(
            meter_slug=meter_slug,
            from_parameter=from_parameter,
            to=to,
            window_size=window_size,
            window_time_zone=window_time_zone,
            filter_group_by=filter_group_by,
            group_by=group_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(Union[JSON, str], deserialized), {})  # type: ignore

        return cast(Union[JSON, str], deserialized)  # type: ignore

    @distributed_trace_async
    async def list_entitlements(
        self,
        *,
        page: int = 1,
        page_size: int = 100,
        limit: int = 1000,
        offset: int = 0,
        subject: Optional[List[str]] = None,
        feature: Optional[List[str]] = None,
        entitlement_type: Optional[List[str]] = None,
        order: str = "ASC",
        order_by: str = "createdAt",
        **kwargs: Any
    ) -> Any:
        """List entitlements.

        List all entitlements regardless of subject. This endpoint is intended for administrative
        purposes.
        If page is provided that takes precedence and the paginated response is returned.

        :keyword page: Page number to return. Default value is 1.
        :paramtype page: int
        :keyword page_size: Number of entries to return per page. Default value is 100.
        :paramtype page_size: int
        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword offset: Number of entries to skip. Default value is 0.
        :paramtype offset: int
        :keyword subject: Filtering by multiple subjects.

         Usage: ``?subject=customer-1&subject=customer-2``. Default value is None.
        :paramtype subject: list[str]
        :keyword feature: Filtering by multiple features.

         Usage: ``?feature=feature-1&feature=feature-2``. Default value is None.
        :paramtype feature: list[str]
        :keyword entitlement_type: Filtering by multiple entitlement types.

         Usage: ``?entitlementType=metered&entitlementType=static``. Default value is None.
        :paramtype entitlement_type: list[str]
        :keyword order: Order by field.

         Usage: ``?order=ASC``. Known values are: "ASC" and "DESC". Default value is "ASC".
        :paramtype order: str
        :keyword order_by: Order by field. Known values are: "createdAt" and "updatedAt". Default value
         is "createdAt".
        :paramtype order_by: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_list_entitlements_request(
            page=page,
            page_size=page_size,
            limit=limit,
            offset=offset,
            subject=subject,
            feature=feature,
            entitlement_type=entitlement_type,
            order=order,
            order_by=order_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_entitlement_by_id(self, entitlement_id: str, **kwargs: Any) -> JSON:
        """Get an entitlement.

        Get entitlement by id.

        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "lastReset": "2020-02-20 00:00:00"  # Optional. The last time usage was
                      reset.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_entitlement_by_id_request(
            entitlement_id=entitlement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_features(
        self,
        *,
        page: int = 1,
        page_size: int = 100,
        limit: int = 1000,
        offset: int = 0,
        meter_slug: Optional[List[str]] = None,
        order: str = "ASC",
        order_by: str = "updatedAt",
        include_archived: bool = False,
        **kwargs: Any
    ) -> Any:
        """List features.

        List all features. If page is provided that takes precedence and the paginated response is
        returned.

        :keyword page: Page number to return. Default value is 1.
        :paramtype page: int
        :keyword page_size: Number of entries to return per page. Default value is 100.
        :paramtype page_size: int
        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword offset: Number of entries to skip. Default value is 0.
        :paramtype offset: int
        :keyword meter_slug: Filtering by multiple meterSlug.

         Usage: ``?meterSlug=meter-1&meterSlug=meter-2``. Default value is None.
        :paramtype meter_slug: list[str]
        :keyword order: Order by field.

         Usage: ``?order=ASC``. Known values are: "ASC" and "DESC". Default value is "ASC".
        :paramtype order: str
        :keyword order_by: Order by field. Known values are: "id", "createdAt", and "updatedAt".
         Default value is "updatedAt".
        :paramtype order_by: str
        :keyword include_archived: Include archived features. Default value is False.
        :paramtype include_archived: bool
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_list_features_request(
            page=page,
            page_size=page_size,
            limit=limit,
            offset=offset,
            meter_slug=meter_slug,
            order=order,
            order_by=order_by,
            include_archived=include_archived,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @overload
    async def create_feature(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a feature.

        Features are either metered or static. A feature is metered if meterSlug is provided at
        creation.
        For metered features you can pass additional filters that will be applied when calculating
        feature usage, based on the meter's groupBy fields. Only meters with SUM and COUNT aggregation
        are supported for features.

        Features cannot be updated later, only archived.

        :param body: The feature to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "key": "str",  # The key is an immutable unique identifier of the feature
                      used throughout the API, for example when interacting with a subject's
                      entitlements. The key has to be unique across all active features, but archived
                      features can share the same key. The key should consist of lowercase alphanumeric
                      characters and dashes. Required.
                    "name": "str",  # The name of the feature. Required.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature, useful
                          for syncing with external systems and annotating custom fields.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks. Example scenario would
                          be a meter tracking all token use with groupBy fields for the model, then the
                          feature could filter for model=gpt-4.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and and based on which usage is calculated. The meter selected must have SUM or
                      COUNT aggregation.
                }

                # response body for status code(s): 201
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "key": "str",  # The key is an immutable unique identifier of the feature
                      used throughout the API, for example when interacting with a subject's
                      entitlements. The key has to be unique across all active features, but archived
                      features can share the same key. The key should consist of lowercase alphanumeric
                      characters and dashes. Required.
                    "name": "str",  # The name of the feature. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. The initial value is the same as createdAt. Required.
                    "archivedAt": "2020-02-20 00:00:00",  # Optional. If the feature is archived,
                      no new entitlements can be created for it.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature, useful
                          for syncing with external systems and annotating custom fields.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks. Example scenario would
                          be a meter tracking all token use with groupBy fields for the model, then the
                          feature could filter for model=gpt-4.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and and based on which usage is calculated. The meter selected must have SUM or
                      COUNT aggregation.
                }
        """

    @overload
    async def create_feature(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a feature.

        Features are either metered or static. A feature is metered if meterSlug is provided at
        creation.
        For metered features you can pass additional filters that will be applied when calculating
        feature usage, based on the meter's groupBy fields. Only meters with SUM and COUNT aggregation
        are supported for features.

        Features cannot be updated later, only archived.

        :param body: The feature to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "key": "str",  # The key is an immutable unique identifier of the feature
                      used throughout the API, for example when interacting with a subject's
                      entitlements. The key has to be unique across all active features, but archived
                      features can share the same key. The key should consist of lowercase alphanumeric
                      characters and dashes. Required.
                    "name": "str",  # The name of the feature. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. The initial value is the same as createdAt. Required.
                    "archivedAt": "2020-02-20 00:00:00",  # Optional. If the feature is archived,
                      no new entitlements can be created for it.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature, useful
                          for syncing with external systems and annotating custom fields.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks. Example scenario would
                          be a meter tracking all token use with groupBy fields for the model, then the
                          feature could filter for model=gpt-4.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and and based on which usage is calculated. The meter selected must have SUM or
                      COUNT aggregation.
                }
        """

    @distributed_trace_async
    async def create_feature(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Create a feature.

        Features are either metered or static. A feature is metered if meterSlug is provided at
        creation.
        For metered features you can pass additional filters that will be applied when calculating
        feature usage, based on the meter's groupBy fields. Only meters with SUM and COUNT aggregation
        are supported for features.

        Features cannot be updated later, only archived.

        :param body: The feature to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "key": "str",  # The key is an immutable unique identifier of the feature
                      used throughout the API, for example when interacting with a subject's
                      entitlements. The key has to be unique across all active features, but archived
                      features can share the same key. The key should consist of lowercase alphanumeric
                      characters and dashes. Required.
                    "name": "str",  # The name of the feature. Required.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature, useful
                          for syncing with external systems and annotating custom fields.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks. Example scenario would
                          be a meter tracking all token use with groupBy fields for the model, then the
                          feature could filter for model=gpt-4.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and and based on which usage is calculated. The meter selected must have SUM or
                      COUNT aggregation.
                }

                # response body for status code(s): 201
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "key": "str",  # The key is an immutable unique identifier of the feature
                      used throughout the API, for example when interacting with a subject's
                      entitlements. The key has to be unique across all active features, but archived
                      features can share the same key. The key should consist of lowercase alphanumeric
                      characters and dashes. Required.
                    "name": "str",  # The name of the feature. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. The initial value is the same as createdAt. Required.
                    "archivedAt": "2020-02-20 00:00:00",  # Optional. If the feature is archived,
                      no new entitlements can be created for it.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature, useful
                          for syncing with external systems and annotating custom fields.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks. Example scenario would
                          be a meter tracking all token use with groupBy fields for the model, then the
                          feature could filter for model=gpt-4.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and and based on which usage is calculated. The meter selected must have SUM or
                      COUNT aggregation.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_feature_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_feature(self, feature_id: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get feature.

        Get a feature by id.

        :param feature_id: A unique ULID identifier for a feature. Required.
        :type feature_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "key": "str",  # The key is an immutable unique identifier of the feature
                      used throughout the API, for example when interacting with a subject's
                      entitlements. The key has to be unique across all active features, but archived
                      features can share the same key. The key should consist of lowercase alphanumeric
                      characters and dashes. Required.
                    "name": "str",  # The name of the feature. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. The initial value is the same as createdAt. Required.
                    "archivedAt": "2020-02-20 00:00:00",  # Optional. If the feature is archived,
                      no new entitlements can be created for it.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted.
                    "metadata": {
                        "str": "str"  # Optional. Additional metadata for the feature, useful
                          for syncing with external systems and annotating custom fields.
                    },
                    "meterGroupByFilters": {
                        "str": "str"  # Optional. Optional meter group by filters. Useful if
                          the meter scope is broader than what feature tracks. Example scenario would
                          be a meter tracking all token use with groupBy fields for the model, then the
                          feature could filter for model=gpt-4.
                    },
                    "meterSlug": "str"  # Optional. The meter that the feature is associated with
                      and and based on which usage is calculated. The meter selected must have SUM or
                      COUNT aggregation.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_feature_request(
            feature_id=feature_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_feature(  # pylint: disable=inconsistent-return-statements
        self, feature_id: str, **kwargs: Any
    ) -> None:
        """Archive a feature.

        Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements
        cannot be created for it, but archiving the feature does not affect existing entitlements. This
        means, if you want to create a new feature with the same key, and then create entitlements for
        it, the previous entitlements have to be deleted first on a per subject basis.

        :param feature_id: A unique ULID identifier for a feature. Required.
        :type feature_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_feature_request(
            feature_id=feature_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_grants(
        self,
        *,
        page: int = 1,
        page_size: int = 100,
        limit: int = 1000,
        offset: int = 0,
        subject: Optional[List[str]] = None,
        feature: Optional[List[str]] = None,
        order: str = "ASC",
        order_by: str = "updatedAt",
        include_deleted: bool = False,
        **kwargs: Any
    ) -> Any:
        """List grants.

        List all grants for all the subjects and entitlements. This endpoint is intended for
        administrative purposes only. To fetch the grants of a specific entitlement please use the
        /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.

        If page is provided that takes precedence and the paginated response is returned.

        :keyword page: Page number to return. Default value is 1.
        :paramtype page: int
        :keyword page_size: Number of entries to return per page. Default value is 100.
        :paramtype page_size: int
        :keyword limit: Number of entries to return. Default value is 1000.
        :paramtype limit: int
        :keyword offset: Number of entries to skip. Default value is 0.
        :paramtype offset: int
        :keyword subject: Filtering by multiple subjects.

         Usage: ``?subject=customer-1&subject=customer-2``. Default value is None.
        :paramtype subject: list[str]
        :keyword feature: Filtering by multiple features.

         Usage: ``?feature=feature-1&feature=feature-2``. Default value is None.
        :paramtype feature: list[str]
        :keyword order: Order by field.

         Usage: ``?order=ASC``. Known values are: "ASC" and "DESC". Default value is "ASC".
        :paramtype order: str
        :keyword order_by: Order by field. Known values are: "id", "createdAt", and "updatedAt".
         Default value is "updatedAt".
        :paramtype order_by: str
        :keyword include_deleted: Include deleted entries. Default value is False.
        :paramtype include_deleted: bool
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_list_grants_request(
            page=page,
            page_size=page_size,
            limit=limit,
            offset=offset,
            subject=subject,
            feature=feature,
            order=order,
            order_by=order_by,
            include_deleted=include_deleted,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace_async
    async def void_grant(self, grant_id: str, **kwargs: Any) -> Optional[JSON]:
        """Void a grant.

        Voiding a grant means it is no longer valid, it doesn't take part in further balance
        calculations. Voiding a grant does not retroactively take effect, meaning any usage that has
        already been attributed to the grant will remain, but future usage cannot be burnt down from
        the grant.

        For example, if you have a single grant for your metered entitlement with an initial amount of
        100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a
        balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will
        not be affected.

        :param grant_id: A unique identifier for a grant. Required.
        :type grant_id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        _request = build_void_grant_request(
            grant_id=grant_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 409]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 409:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_entitlement(
        self, subject_id_or_key: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an entitlement.

        OpenMeter has three types of entitlements: metered, boolean, and static. The type property
        determines the type of entitlement. The underlying feature has to be compatible with the
        entitlement type specified in the request (e.g., a metered entitlement needs a feature
        associated with a meter).


        * Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
        * Static entitlements let you pass along a configuration while granting access, e.g. "Using
        this feature with X Y settings" (passed in the config).
        * Metered entitlements have many use cases, from setting up usage-based access to implementing
        complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period
        of the entitlement.

        A given subject can only have one active (non-deleted) entitlement per featureKey. If you try
        to create a new entitlement for a featureKey that already has an active entitlement, the
        request will fail with a 409 error.

        Once an entitlement is created you cannot modify it, only delete it.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param body: The entitlement to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @overload
    async def create_entitlement(
        self, subject_id_or_key: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an entitlement.

        OpenMeter has three types of entitlements: metered, boolean, and static. The type property
        determines the type of entitlement. The underlying feature has to be compatible with the
        entitlement type specified in the request (e.g., a metered entitlement needs a feature
        associated with a meter).


        * Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
        * Static entitlements let you pass along a configuration while granting access, e.g. "Using
        this feature with X Y settings" (passed in the config).
        * Metered entitlements have many use cases, from setting up usage-based access to implementing
        complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period
        of the entitlement.

        A given subject can only have one active (non-deleted) entitlement per featureKey. If you try
        to create a new entitlement for a featureKey that already has an active entitlement, the
        request will fail with a 409 error.

        Once an entitlement is created you cannot modify it, only delete it.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param body: The entitlement to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @distributed_trace_async
    async def create_entitlement(self, subject_id_or_key: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create an entitlement.

        OpenMeter has three types of entitlements: metered, boolean, and static. The type property
        determines the type of entitlement. The underlying feature has to be compatible with the
        entitlement type specified in the request (e.g., a metered entitlement needs a feature
        associated with a meter).


        * Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
        * Static entitlements let you pass along a configuration while granting access, e.g. "Using
        this feature with X Y settings" (passed in the config).
        * Metered entitlements have many use cases, from setting up usage-based access to implementing
        complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period
        of the entitlement.

        A given subject can only have one active (non-deleted) entitlement per featureKey. If you try
        to create a new entitlement for a featureKey that already has an active entitlement, the
        request will fail with a 409 error.

        Once an entitlement is created you cannot modify it, only delete it.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param body: The entitlement to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_entitlement_request(
            subject_id_or_key=subject_id_or_key,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 409:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_subject_entitlements(
        self, subject_id_or_key: str, *, include_deleted: bool = False, **kwargs: Any
    ) -> List[JSON]:
        """List entitlements of a subject.

        List all entitlements for a subject. For checking entitlement access, use the /value endpoint
        instead.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :keyword include_deleted: Include deleted entries. Default value is False.
        :paramtype include_deleted: bool
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {}
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_subject_entitlements_request(
            subject_id_or_key=subject_id_or_key,
            include_deleted=include_deleted,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def get_entitlement(self, subject_id_or_key: str, entitlement_id: str, **kwargs: Any) -> JSON:
        """Get an entitlement.

        Get entitlement by id. For checking entitlement access, use the /value endpoint instead.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "lastReset": "2020-02-20 00:00:00"  # Optional. The last time usage was
                      reset.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_entitlement_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id=entitlement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_entitlement(  # pylint: disable=inconsistent-return-statements
        self, subject_id_or_key: str, entitlement_id: str, **kwargs: Any
    ) -> None:
        """Delete an entitlement.

        Deleting an entitlement revokes access to the associated feature. As a single subject can only
        have one entitlement per featureKey, when "migrating" features you have to delete the old
        entitlements as well.
        As access and status checks can be historical queries, deleting an entitlement populates the
        deletedAt timestamp. When queried for a time before that, the entitlement is still considered
        active, you cannot have retroactive changes to access, which is important for, among other
        things, auditing.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_entitlement_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id=entitlement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def override_entitlement(
        self,
        subject_id_or_key: str,
        entitlement_id_or_feature_key: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Override an entitlement.

        Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes
        the previous entitlement for the provided subject-feature pair. If the previous entitlement is
        already deleted or otherwise doesnt exist, the override will fail.

        This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require
        a new entitlement to be created with zero downtime.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id_or_feature_key: The id of the entitlement or the key of the feature.
         Required.
        :type entitlement_id_or_feature_key: str
        :param body: The entitlement to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @overload
    async def override_entitlement(
        self,
        subject_id_or_key: str,
        entitlement_id_or_feature_key: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Override an entitlement.

        Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes
        the previous entitlement for the provided subject-feature pair. If the previous entitlement is
        already deleted or otherwise doesnt exist, the override will fail.

        This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require
        a new entitlement to be created with zero downtime.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id_or_feature_key: The id of the entitlement or the key of the feature.
         Required.
        :type entitlement_id_or_feature_key: str
        :param body: The entitlement to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @distributed_trace_async
    async def override_entitlement(
        self, subject_id_or_key: str, entitlement_id_or_feature_key: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        """Override an entitlement.

        Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes
        the previous entitlement for the provided subject-feature pair. If the previous entitlement is
        already deleted or otherwise doesnt exist, the override will fail.

        This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require
        a new entitlement to be created with zero downtime.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id_or_feature_key: The id of the entitlement or the key of the feature.
         Required.
        :type entitlement_id_or_feature_key: str
        :param body: The entitlement to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_override_entitlement_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id_or_feature_key=entitlement_id_or_feature_key,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 409:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_entitlement_grants(
        self,
        subject_id_or_key: str,
        entitlement_id_or_feature_key: str,
        *,
        include_deleted: bool = False,
        order_by: str = "updatedAt",
        **kwargs: Any
    ) -> List[JSON]:
        # pylint: disable=line-too-long
        """List grants for an entitlement.

        List all grants issued for an entitlement. The entitlement can be defined either by its id or
        featureKey.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id_or_feature_key: The id of the entitlement or the key of the feature.
         Required.
        :type entitlement_id_or_feature_key: str
        :keyword include_deleted: Include deleted entries. Default value is False.
        :paramtype include_deleted: bool
        :keyword order_by: Order by field. Known values are: "id", "createdAt", and "updatedAt".
         Default value is "updatedAt".
        :paramtype order_by: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "amount": 0.0,  # The amount to grant. Should be a positive number.
                          Required.
                        "createdAt": "2020-02-20 00:00:00",  # The date and time the resource
                          was created. Required.
                        "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants
                          and anchor for recurring grants. Provided value will be ceiled to metering
                          windowSize (minute). Required.
                        "entitlementId": "str",  # The unique entitlement ULID that the grant
                          is associated with. Required.
                        "expiration": {
                            "count": 0,  # The expiration period count like 12 months.
                              Required.
                            "duration": "str"  # The expiration period duration like
                              month. Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and
                              "YEAR".
                        },
                        "id": "str",  # Readonly unique ULID identifier. Required.
                        "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource
                          was last updated. The initial value is the same as createdAt. Required.
                        "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time
                          the resource was deleted.
                        "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date
                          of the grant.
                        "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are
                          rolled over at reset, after which they can have a different balance compared
                          to what they had before the reset.  Balance after the reset is calculated as:
                          Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                          MinRolloverAmount)).
                        "metadata": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        },
                        "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are
                          rolled over at reset, after which they can have a different balance compared
                          to what they had before the reset.  Balance after the reset is calculated as:
                          Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                          MinRolloverAmount)).
                        "nextRecurrence": "2020-02-20 00:00:00",  # Optional. The next time
                          the grant will recurr.
                        "priority": 1,  # Optional. Default value is 1. The priority of the
                          grant. Grants with higher priority are applied first. Priority is a positive
                          decimal numbers. With lower numbers indicating higher importance. For
                          example, a priority of 1 is more urgent than a priority of 2. When there are
                          several grants available for the same subject, the system selects the grant
                          with the highest priority. In cases where grants share the same priority
                          level, the grant closest to its expiration will be used first. In the case of
                          two grants have identical priorities and expiration dates, the system will
                          use the grant that was created first.
                        "recurrence": {
                            "anchor": "2020-02-20 00:00:00",  # An arbitrary anchor to
                              base the recurring period on. Required.
                            "interval": "str"  # List of pre-defined periods that can be
                              used for recurring & scheduling.  DAY:      Every day WEEK:     Every
                              week MONTH:    Every month YEAR:     Every year. Required. Known values
                              are: "DAY", "WEEK", "MONTH", and "YEAR".
                        },
                        "voidedAt": "2020-02-20 00:00:00"  # Optional. The date and time the
                          grant was voided (cannot be used after that).
                    }
                ]
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_list_entitlement_grants_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id_or_feature_key=entitlement_id_or_feature_key,
            include_deleted=include_deleted,
            order_by=order_by,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def create_grant(
        self,
        subject_id_or_key: str,
        entitlement_id_or_feature_key: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a grant.

        Grants define a behavior of granting usage for a metered entitlement. They can have complicated
        recurrence and rollover rules, thanks to which you can define a wide range of access patterns
        with a single grant, in most cases you don't have to periodically create new grants. You can
        only issue grants for active metered entitlements.

        A grant defines a given amount of usage that can be consumed for the entitlement. The grant is
        in effect between its effective date and its expiration date. Specifying both is mandatory for
        new grants.

        Grants have a priority setting that determines their order of use. Lower numbers have higher
        priority, with 0 being the highest priority.

        Grants can have a recurrence setting intended to automate the manual reissuing of grants. For
        example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover
        settings).

        Rollover settings define what happens to the remaining balance of a grant at a reset.
        Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))

        Grants cannot be changed once created, only deleted. This is to ensure that balance is
        deterministic regardless of when it is queried.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id_or_feature_key: The id of the entitlement or the key of the feature.
         Required.
        :type entitlement_id_or_feature_key: str
        :param body: The grant to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "amount": 0.0,  # The amount to grant. Should be a positive number. Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants and anchor
                      for recurring grants. Provided value will be ceiled to metering windowSize
                      (minute). Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "recurrence": {
                        "interval": "str",  # List of pre-defined periods that can be used
                          for recurring & scheduling.  DAY:      Every day WEEK:     Every week MONTH:
                          Every month YEAR:     Every year. Required. Known values are: "DAY", "WEEK",
                          "MONTH", and "YEAR".
                        "anchor": "2020-02-20 00:00:00"  # Optional. An arbitrary anchor to
                          base the recurring period on. If not provided then defaults to now truncated
                          to the hour.
                    }
                }

                # response body for status code(s): 201
                response == {
                    "amount": 0.0,  # The amount to grant. Should be a positive number. Required.
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants and anchor
                      for recurring grants. Provided value will be ceiled to metering windowSize
                      (minute). Required.
                    "entitlementId": "str",  # The unique entitlement ULID that the grant is
                      associated with. Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. The initial value is the same as createdAt. Required.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date of the
                      grant.
                    "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "nextRecurrence": "2020-02-20 00:00:00",  # Optional. The next time the grant
                      will recurr.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "recurrence": {
                        "anchor": "2020-02-20 00:00:00",  # An arbitrary anchor to base the
                          recurring period on. Required.
                        "interval": "str"  # List of pre-defined periods that can be used for
                          recurring & scheduling.  DAY:      Every day WEEK:     Every week MONTH:
                          Every month YEAR:     Every year. Required. Known values are: "DAY", "WEEK",
                          "MONTH", and "YEAR".
                    },
                    "voidedAt": "2020-02-20 00:00:00"  # Optional. The date and time the grant
                      was voided (cannot be used after that).
                }
        """

    @overload
    async def create_grant(
        self,
        subject_id_or_key: str,
        entitlement_id_or_feature_key: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a grant.

        Grants define a behavior of granting usage for a metered entitlement. They can have complicated
        recurrence and rollover rules, thanks to which you can define a wide range of access patterns
        with a single grant, in most cases you don't have to periodically create new grants. You can
        only issue grants for active metered entitlements.

        A grant defines a given amount of usage that can be consumed for the entitlement. The grant is
        in effect between its effective date and its expiration date. Specifying both is mandatory for
        new grants.

        Grants have a priority setting that determines their order of use. Lower numbers have higher
        priority, with 0 being the highest priority.

        Grants can have a recurrence setting intended to automate the manual reissuing of grants. For
        example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover
        settings).

        Rollover settings define what happens to the remaining balance of a grant at a reset.
        Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))

        Grants cannot be changed once created, only deleted. This is to ensure that balance is
        deterministic regardless of when it is queried.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id_or_feature_key: The id of the entitlement or the key of the feature.
         Required.
        :type entitlement_id_or_feature_key: str
        :param body: The grant to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "amount": 0.0,  # The amount to grant. Should be a positive number. Required.
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants and anchor
                      for recurring grants. Provided value will be ceiled to metering windowSize
                      (minute). Required.
                    "entitlementId": "str",  # The unique entitlement ULID that the grant is
                      associated with. Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. The initial value is the same as createdAt. Required.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date of the
                      grant.
                    "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "nextRecurrence": "2020-02-20 00:00:00",  # Optional. The next time the grant
                      will recurr.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "recurrence": {
                        "anchor": "2020-02-20 00:00:00",  # An arbitrary anchor to base the
                          recurring period on. Required.
                        "interval": "str"  # List of pre-defined periods that can be used for
                          recurring & scheduling.  DAY:      Every day WEEK:     Every week MONTH:
                          Every month YEAR:     Every year. Required. Known values are: "DAY", "WEEK",
                          "MONTH", and "YEAR".
                    },
                    "voidedAt": "2020-02-20 00:00:00"  # Optional. The date and time the grant
                      was voided (cannot be used after that).
                }
        """

    @distributed_trace_async
    async def create_grant(
        self, subject_id_or_key: str, entitlement_id_or_feature_key: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Create a grant.

        Grants define a behavior of granting usage for a metered entitlement. They can have complicated
        recurrence and rollover rules, thanks to which you can define a wide range of access patterns
        with a single grant, in most cases you don't have to periodically create new grants. You can
        only issue grants for active metered entitlements.

        A grant defines a given amount of usage that can be consumed for the entitlement. The grant is
        in effect between its effective date and its expiration date. Specifying both is mandatory for
        new grants.

        Grants have a priority setting that determines their order of use. Lower numbers have higher
        priority, with 0 being the highest priority.

        Grants can have a recurrence setting intended to automate the manual reissuing of grants. For
        example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover
        settings).

        Rollover settings define what happens to the remaining balance of a grant at a reset.
        Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))

        Grants cannot be changed once created, only deleted. This is to ensure that balance is
        deterministic regardless of when it is queried.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id_or_feature_key: The id of the entitlement or the key of the feature.
         Required.
        :type entitlement_id_or_feature_key: str
        :param body: The grant to create. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "amount": 0.0,  # The amount to grant. Should be a positive number. Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants and anchor
                      for recurring grants. Provided value will be ceiled to metering windowSize
                      (minute). Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "recurrence": {
                        "interval": "str",  # List of pre-defined periods that can be used
                          for recurring & scheduling.  DAY:      Every day WEEK:     Every week MONTH:
                          Every month YEAR:     Every year. Required. Known values are: "DAY", "WEEK",
                          "MONTH", and "YEAR".
                        "anchor": "2020-02-20 00:00:00"  # Optional. An arbitrary anchor to
                          base the recurring period on. If not provided then defaults to now truncated
                          to the hour.
                    }
                }

                # response body for status code(s): 201
                response == {
                    "amount": 0.0,  # The amount to grant. Should be a positive number. Required.
                    "createdAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      created. Required.
                    "effectiveAt": "2020-02-20 00:00:00",  # Effective date for grants and anchor
                      for recurring grants. Provided value will be ceiled to metering windowSize
                      (minute). Required.
                    "entitlementId": "str",  # The unique entitlement ULID that the grant is
                      associated with. Required.
                    "expiration": {
                        "count": 0,  # The expiration period count like 12 months. Required.
                        "duration": "str"  # The expiration period duration like month.
                          Required. Known values are: "HOUR", "DAY", "WEEK", "MONTH", and "YEAR".
                    },
                    "id": "str",  # Readonly unique ULID identifier. Required.
                    "updatedAt": "2020-02-20 00:00:00",  # The date and time the resource was
                      last updated. The initial value is the same as createdAt. Required.
                    "deletedAt": "2020-02-20 00:00:00",  # Optional. The date and time the
                      resource was deleted.
                    "expiresAt": "2020-02-20 00:00:00",  # Optional. The expiration date of the
                      grant.
                    "maxRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "metadata": {
                        "str": "str"  # Optional. Dictionary of :code:`<string>`.
                    },
                    "minRolloverAmount": 0,  # Optional. Default value is 0. Grants are rolled
                      over at reset, after which they can have a different balance compared to what
                      they had before the reset.  Balance after the reset is calculated as:
                      Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset,
                      MinRolloverAmount)).
                    "nextRecurrence": "2020-02-20 00:00:00",  # Optional. The next time the grant
                      will recurr.
                    "priority": 1,  # Optional. Default value is 1. The priority of the grant.
                      Grants with higher priority are applied first. Priority is a positive decimal
                      numbers. With lower numbers indicating higher importance. For example, a priority
                      of 1 is more urgent than a priority of 2. When there are several grants available
                      for the same subject, the system selects the grant with the highest priority. In
                      cases where grants share the same priority level, the grant closest to its
                      expiration will be used first. In the case of two grants have identical
                      priorities and expiration dates, the system will use the grant that was created
                      first.
                    "recurrence": {
                        "anchor": "2020-02-20 00:00:00",  # An arbitrary anchor to base the
                          recurring period on. Required.
                        "interval": "str"  # List of pre-defined periods that can be used for
                          recurring & scheduling.  DAY:      Every day WEEK:     Every week MONTH:
                          Every month YEAR:     Every year. Required. Known values are: "DAY", "WEEK",
                          "MONTH", and "YEAR".
                    },
                    "voidedAt": "2020-02-20 00:00:00"  # Optional. The date and time the grant
                      was voided (cannot be used after that).
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_grant_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id_or_feature_key=entitlement_id_or_feature_key,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_entitlement_value(
        self,
        subject_id_or_key: str,
        entitlement_id_or_feature_key: str,
        *,
        time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get the current value and access of an entitlement.

        This endpoint should be used for access checks and enforcement. All entitlement types share the
        hasAccess property in their value response, but multiple other properties are returned based on
        the entitlement type.

        For convenience reasons, /value works with both entitlementId and featureKey.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id_or_feature_key: The id of the entitlement or the key of the feature.
         Required.
        :type entitlement_id_or_feature_key: str
        :keyword time: Point of time to check value: date-time in RFC 3339 format. Defaults to now.
         Default value is None.
        :paramtype time: ~datetime.datetime
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "hasAccess": bool,  # Whether the subject has access to the feature. Shared
                      accross all entitlement types. Required.
                    "balance": 0.0,  # Optional. Only available for metered entitlements. Metered
                      entitlements are built around a balance calculation where feature usage is
                      deducted from the issued grants. Balance represents the remaining balance of the
                      entitlement, it's value never turns negative.
                    "config": "str",  # Optional. Only available for static entitlements. The
                      JSON parsable config of the entitlement.
                    "overage": 0.0,  # Optional. Only available for metered entitlements. Overage
                      represents the usage that wasn't covered by grants, e.g. if the subject had a
                      total feature usage of 100 in the period but they were only granted 80, there
                      would be 20 overage.
                    "usage": 0.0  # Optional. Only available for metered entitlements. Returns
                      the total feature usage in the current period.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_entitlement_value_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id_or_feature_key=entitlement_id_or_feature_key,
            time=time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_entitlement_history(
        self,
        subject_id_or_key: str,
        entitlement_id: str,
        *,
        window_size: str,
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        window_time_zone: str = "UTC",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get the balance history of a specific entitlement.

        Returns historical balance and usage data for the entitlement. The queried history can span
        accross multiple reset events.

        BurndownHistory returns a continous history of segments, where the segments are seperated by
        events that changed either the grant burndown priority or the usage period.

        WindowedHistory returns windowed usage data for the period enriched with balance information
        and the list of grants that were being burnt down in that window.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :keyword window_size: Size of the time window to group the history by. Cannot be shorter than
         meter granularity. Known values are: "MINUTE", "HOUR", and "DAY". Required.
        :paramtype window_size: str
        :keyword from_parameter: Start of time range to query entitlement: date-time in RFC 3339
         format. Defaults to
         the last reset.
         Gets truncated to the granularity of the underlying meter. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End of time range to query entitlement: date-time in RFC 3339 format. Defaults to
         now.
         If not now then gets truncated to the granularity of the underlying meter. Default value is
         None.
        :paramtype to: ~datetime.datetime
        :keyword window_time_zone: The value is the name of the time zone as defined in the IANA Time
         Zone Database (http://www.iana.org/time-zones).
         If not specified, the UTC timezone will be used. Default value is "UTC".
        :paramtype window_time_zone: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "burndownHistory": [
                        {
                            "balanceAtEnd": 0.0,  # Optional. The entitlement balance at
                              the end of the period.
                            "balanceAtStart": 0.0,  # Optional. The entitlement balance
                              at the start of the period.
                            "grantBalancesAtEnd": {
                                "str": 0.0  # Optional. The balance breakdown of each
                                  active grant at the start of the period: GrantID: Balance.
                            },
                            "grantBalancesAtStart": {
                                "str": 0.0  # Optional. The balance breakdown of each
                                  active grant at the start of the period: GrantID: Balance.
                            },
                            "grantUsages": [
                                {
                                    "grantId": "str",  # Optional. The id of the
                                      grant.
                                    "usage": 0.0  # Optional. The usage of the
                                      grant.
                                }
                            ],
                            "overage": 0.0,  # Optional. Overuse that wasn't covered by
                              grants.
                            "period": {
                                "from": "2020-02-20 00:00:00",  # Period start time
                                  where the amount was applied. If applicable. Required.
                                "to": "2020-02-20 00:00:00"  # Period end time where
                                  the amount was applied. If applicable. Required.
                            },
                            "usage": 0.0  # Optional. The usage of the grant in the
                              period.
                        }
                    ],
                    "windowedHistory": [
                        {
                            "balanceAtStart": 0.0,  # Optional. The entitlement balance
                              at the start of the period.
                            "period": {
                                "from": "2020-02-20 00:00:00",  # Period start time
                                  where the amount was applied. If applicable. Required.
                                "to": "2020-02-20 00:00:00"  # Period end time where
                                  the amount was applied. If applicable. Required.
                            },
                            "usage": 0.0  # Optional. The total usage of the feature in
                              the period.
                        }
                    ]
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_entitlement_history_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id=entitlement_id,
            window_size=window_size,
            from_parameter=from_parameter,
            to=to,
            window_time_zone=window_time_zone,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def reset_entitlement_usage(  # pylint: disable=inconsistent-return-statements
        self,
        subject_id_or_key: str,
        entitlement_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Reset an entitlement.

        Reset marks the start of a new usage period for the entitlement and initiates grant rollover.
        At the start of a period usage is zerod out and grants are rolled over based on their rollover
        settings. It would typically be synced with the subjects billing period to enforce usage based
        on their subscription.

        Usage is automatically reset for metered entitlements based on their usage period, but this
        endpoint allows to manually reset it at any time. When doing so the period anchor of the
        entitlement can be changed if needed.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "effectiveAt": "2020-02-20 00:00:00",  # Optional. The time at which the
                      reset takes effect, defaults to now. The reset cannot be in the future. The
                      provided value is truncated to the minute due to how historical meter data is
                      stored.
                    "preserveOverage": bool,  # Optional. Determines whether the overage is
                      preserved or forgiven, overriding the entitlement's default behavior.   * If
                      true, the overage is preserved. * If false, the overage is forgiven.
                    "retainAnchor": bool  # Optional. Determines whether the usage period anchor
                      is retained or reset to the effectiveAt time.   * If true, the usage period
                      anchor is retained. * If false, the usage period anchor is reset to the
                      effectiveAt time.
                }
        """

    @overload
    async def reset_entitlement_usage(  # pylint: disable=inconsistent-return-statements
        self,
        subject_id_or_key: str,
        entitlement_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Reset an entitlement.

        Reset marks the start of a new usage period for the entitlement and initiates grant rollover.
        At the start of a period usage is zerod out and grants are rolled over based on their rollover
        settings. It would typically be synced with the subjects billing period to enforce usage based
        on their subscription.

        Usage is automatically reset for metered entitlements based on their usage period, but this
        endpoint allows to manually reset it at any time. When doing so the period anchor of the
        entitlement can be changed if needed.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def reset_entitlement_usage(  # pylint: disable=inconsistent-return-statements
        self, subject_id_or_key: str, entitlement_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Reset an entitlement.

        Reset marks the start of a new usage period for the entitlement and initiates grant rollover.
        At the start of a period usage is zerod out and grants are rolled over based on their rollover
        settings. It would typically be synced with the subjects billing period to enforce usage based
        on their subscription.

        Usage is automatically reset for metered entitlements based on their usage period, but this
        endpoint allows to manually reset it at any time. When doing so the period anchor of the
        entitlement can be changed if needed.

        :param subject_id_or_key: A unique identifier for a subject. Required.
        :type subject_id_or_key: str
        :param entitlement_id: A unique ULID for an entitlement. Required.
        :type entitlement_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "effectiveAt": "2020-02-20 00:00:00",  # Optional. The time at which the
                      reset takes effect, defaults to now. The reset cannot be in the future. The
                      provided value is truncated to the minute due to how historical meter data is
                      stored.
                    "preserveOverage": bool,  # Optional. Determines whether the overage is
                      preserved or forgiven, overriding the entitlement's default behavior.   * If
                      true, the overage is preserved. * If false, the overage is forgiven.
                    "retainAnchor": bool  # Optional. Determines whether the usage period anchor
                      is retained or reset to the effectiveAt time.   * If true, the usage period
                      anchor is retained. * If false, the usage period anchor is reset to the
                      effectiveAt time.
                }
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_reset_entitlement_usage_request(
            subject_id_or_key=subject_id_or_key,
            entitlement_id=entitlement_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_debug_metrics(self, **kwargs: Any) -> str:
        """Get event metrics.

        Returns debug metrics like the number of ingested events since mindnight UTC.
        The OpenMetrics Counter(s) reset every day at midnight UTC.

        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[str] = kwargs.pop("cls", None)

        _request = build_get_debug_metrics_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(str, deserialized), {})  # type: ignore

        return cast(str, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_notification_channels(
        self,
        *,
        page: int = 1,
        page_size: int = 100,
        order_by: str = "id",
        order: str = "ASC",
        include_disabled: bool = False,
        include_deleted: bool = False,
        **kwargs: Any
    ) -> JSON:
        """List notification channels.

        List all notification channels.

        :keyword page: Page number to return. Default value is 1.
        :paramtype page: int
        :keyword page_size: Number of entries to return per page. Default value is 100.
        :paramtype page_size: int
        :keyword order_by: Order by field. Known values are: "id", "type", "createdAt", and
         "updatedAt". Default value is "id".
        :paramtype order_by: str
        :keyword order: Order by field.

         Usage: ``?order=ASC``. Known values are: "ASC" and "DESC". Default value is "ASC".
        :paramtype order: str
        :keyword include_disabled: Include disabled entries. Default value is False.
        :paramtype include_disabled: bool
        :keyword include_deleted: Include deleted entries. Default value is False.
        :paramtype include_deleted: bool
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "items": [
                        {}
                    ],
                    "page": 0,  # Current page number. Required.
                    "pageSize": 0,  # Number of items per page. Required.
                    "totalCount": 0  # Total number of items. Required.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_list_notification_channels_request(
            page=page,
            page_size=page_size,
            order_by=order_by,
            order=order,
            include_disabled=include_disabled,
            include_deleted=include_deleted,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def create_notification_channel(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a notification channel.

        Create a new notification channel.

        :param body: The notification channel to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @overload
    async def create_notification_channel(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a notification channel.

        Create a new notification channel.

        :param body: The notification channel to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @distributed_trace_async
    async def create_notification_channel(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create a notification channel.

        Create a new notification channel.

        :param body: The notification channel to create. Is either a JSON type or a IO[bytes] type.
         Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_notification_channel_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 409:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_notification_channel(self, channel_id: str, **kwargs: Any) -> JSON:
        """Get notification channel.

        Get a notification channel by id.

        :param channel_id: A unique ULID identifier for a notification channel. Required.
        :type channel_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_notification_channel_request(
            channel_id=channel_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_notification_channel(  # pylint: disable=inconsistent-return-statements
        self, channel_id: str, **kwargs: Any
    ) -> None:
        """Delete a notification channel.

        Delete notification channel by id.

        :param channel_id: A unique ULID identifier for a notification channel. Required.
        :type channel_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_notification_channel_request(
            channel_id=channel_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_notification_channel(
        self, channel_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Update notification channel.

        Update a notification channel by id.

        :param channel_id: A unique ULID identifier for a notification channel. Required.
        :type channel_id: str
        :param body: The notification channel to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """

    @overload
    async def update_notification_channel(
        self, channel_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Update notification channel.

        Update a notification channel by id.

        :param channel_id: A unique ULID identifier for a notification channel. Required.
        :type channel_id: str
        :param body: The notification channel to update. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_notification_channel(self, channel_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Update notification channel.

        Update a notification channel by id.

        :param channel_id: A unique ULID identifier for a notification channel. Required.
        :type channel_id: str
        :param body: The notification channel to update. Is either a JSON type or a IO[bytes] type.
         Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_update_notification_channel_request(
            channel_id=channel_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_notification_rules(
        self,
        *,
        page: int = 1,
        page_size: int = 100,
        order_by: str = "id",
        order: str = "ASC",
        include_disabled: bool = False,
        include_deleted: bool = False,
        feature: Optional[List[str]] = None,
        channel: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """List notification rules.

        List all notification rules.

        :keyword page: Page number to return. Default value is 1.
        :paramtype page: int
        :keyword page_size: Number of entries to return per page. Default value is 100.
        :paramtype page_size: int
        :keyword order_by: Order by field. Known values are: "id", "type", "createdAt", and
         "updatedAt". Default value is "id".
        :paramtype order_by: str
        :keyword order: Order by field.

         Usage: ``?order=ASC``. Known values are: "ASC" and "DESC". Default value is "ASC".
        :paramtype order: str
        :keyword include_disabled: Include disabled entries. Default value is False.
        :paramtype include_disabled: bool
        :keyword include_deleted: Include deleted entries. Default value is False.
        :paramtype include_deleted: bool
        :keyword feature: Filtering by multiple features.

         Usage: ``?feature=feature-1&feature=feature-2``. Default value is None.
        :paramtype feature: list[str]
        :keyword channel: Filtering by multiple notification channels.

         Usage: ``?channel=channel-1&channel=channel-2``. Default value is None.
        :paramtype channel: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "items": [
                        {}
                    ],
                    "page": 0,  # Current page number. Required.
                    "pageSize": 0,  # Number of items per page. Required.
                    "totalCount": 0  # Total number of items. Required.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_list_notification_rules_request(
            page=page,
            page_size=page_size,
            order_by=order_by,
            order=order,
            include_disabled=include_disabled,
            include_deleted=include_deleted,
            feature=feature,
            channel=channel,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def create_notification_rule(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a notification rule.

        Create a new notification rule.

        :param body: The notification rule to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @overload
    async def create_notification_rule(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a notification rule.

        Create a new notification rule.

        :param body: The notification rule to create. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """

    @distributed_trace_async
    async def create_notification_rule(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create a notification rule.

        Create a new notification rule.

        :param body: The notification rule to create. Is either a JSON type or a IO[bytes] type.
         Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_create_notification_rule_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 409:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_notification_rule(self, rule_id: str, **kwargs: Any) -> JSON:
        """Get notification rule.

        Get a notification rule by id.

        :param rule_id: A unique ULID identifier for a notification rule. Required.
        :type rule_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_notification_rule_request(
            rule_id=rule_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_notification_rule(  # pylint: disable=inconsistent-return-statements
        self, rule_id: str, **kwargs: Any
    ) -> None:
        """Delete a notification rule.

        Delete notification rule by id.

        :param rule_id: A unique ULID identifier for a notification rule. Required.
        :type rule_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_notification_rule_request(
            rule_id=rule_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_notification_rule(
        self, rule_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Update a notification rule.

        Update a notification rule by id.

        :param rule_id: A unique ULID identifier for a notification rule. Required.
        :type rule_id: str
        :param body: The notification rule to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """

    @overload
    async def update_notification_rule(
        self, rule_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Update a notification rule.

        Update a notification rule by id.

        :param rule_id: A unique ULID identifier for a notification rule. Required.
        :type rule_id: str
        :param body: The notification rule to update. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_notification_rule(self, rule_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Update a notification rule.

        Update a notification rule by id.

        :param rule_id: A unique ULID identifier for a notification rule. Required.
        :type rule_id: str
        :param body: The notification rule to update. Is either a JSON type or a IO[bytes] type.
         Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_update_notification_rule_request(
            rule_id=rule_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def test_notification_rule(self, rule_id: str, **kwargs: Any) -> JSON:
        """Test notification rule.

        Test a notification rule by sending a test event with random data.

        :param rule_id: A unique ULID identifier for a notification rule. Required.
        :type rule_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 409
                response == {
                    "detail": "str",  # A human-readable explanation specific to this occurrence
                      of the problem. Required.
                    "status": 0,  # The HTTP status code generated by the origin server for this
                      occurrence of the problem. Required.
                    "title": "str",  # A a short, human-readable summary of the problem type.
                      Required.
                    "type": "str",  # Type contains a URI that identifies the problem type.
                      Required.
                    "extensions": {
                        "conflictingEntityId": "str"  # The id of the conflicting entity.
                          Required.
                    },
                    "instance": "str"  # Optional. A URI reference that identifies the specific
                      occurrence of the problem.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_test_notification_rule_request(
            rule_id=rule_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 409:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def list_notification_events(
        self,
        *,
        page: int = 1,
        page_size: int = 100,
        order_by: str = "createdAt",
        order: str = "ASC",
        from_parameter: Optional[datetime.datetime] = None,
        to: Optional[datetime.datetime] = None,
        feature: Optional[List[str]] = None,
        subject: Optional[List[str]] = None,
        rule: Optional[List[str]] = None,
        channel: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """List notification evens.

        List all notification events.

        :keyword page: Page number to return. Default value is 1.
        :paramtype page: int
        :keyword page_size: Number of entries to return per page. Default value is 100.
        :paramtype page_size: int
        :keyword order_by: Order by field. Known values are: "id" and "createdAt". Default value is
         "createdAt".
        :paramtype order_by: str
        :keyword order: Order by field.

         Usage: ``?order=ASC``. Known values are: "ASC" and "DESC". Default value is "ASC".
        :paramtype order: str
        :keyword from_parameter: Start date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype from_parameter: ~datetime.datetime
        :keyword to: End date-time in RFC 3339 format.
         Inclusive. Default value is None.
        :paramtype to: ~datetime.datetime
        :keyword feature: Filtering by multiple features.

         Usage: ``?feature=feature-1&feature=feature-2``. Default value is None.
        :paramtype feature: list[str]
        :keyword subject: Filtering by multiple subjects.

         Usage: ``?subject=customer-1&subject=customer-2``. Default value is None.
        :paramtype subject: list[str]
        :keyword rule: Filtering by multiple rules.

         Usage: ``?rule=ID1&rule=rule=ID2``. Default value is None.
        :paramtype rule: list[str]
        :keyword channel: Filtering by multiple channels.

         Usage: ``?channel=ID1&channel=ID2``. Default value is None.
        :paramtype channel: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "items": [
                        {
                            "createdAt": "2020-02-20 00:00:00",  # Timestamp when the
                              notification event was created. Required.
                            "deliveryStatus": [
                                {
                                    "channel": {
                                        "id": "str",  # A unique identifier
                                          for the notification channel. Required.
                                        "type": "str"  # The type of the
                                          notification channel. Required. "WEBHOOK"
                                    },
                                    "state": "str",  # Required. Known values
                                      are: "SUCCESS", "FAILED", "SENDING", and "PENDING".
                                    "updatedAt": "2020-02-20 00:00:00",  #
                                      Required.
                                    "reason": "str"  # Optional. The delivery
                                      status of the notification event. Required.
                                }
                            ],
                            "id": "str",  # A unique identifier for the notification
                              event. Required.
                            "payload": {},
                            "rule": {},
                            "type": "str",  # The type of the notification event.
                              Required. "entitlements.balance.threshold"
                            "annotations": {
                                "str": {}  # Optional. List of annotations managed by
                                  the system.
                            }
                        }
                    ],
                    "page": 0,  # Current page number. Required.
                    "pageSize": 0,  # Number of items per page. Required.
                    "totalCount": 0  # Total number of items. Required.
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_list_notification_events_request(
            page=page,
            page_size=page_size,
            order_by=order_by,
            order=order,
            from_parameter=from_parameter,
            to=to,
            feature=feature,
            subject=subject,
            rule=rule,
            channel=channel,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_notification_event(self, event_id: str, **kwargs: Any) -> JSON:
        """Get notification event.

        Get a notification event by id.

        :param event_id: A unique ULID identifier for a notification event. Required.
        :type event_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            401: lambda response: ClientAuthenticationError(response=response),
            404: lambda response: ResourceNotFoundError(response=response),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_get_notification_event_request(
            event_id=event_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def receive_svix_operational_event(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Receive Svix operational events.

        Callback endpoint used by Svix to notify about operational events.

        :param body: The operational event. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "data": {
                        "str": {}  # Dictionary of :code:`<any>`. Required.
                    },
                    "type": "str"  # Required. Known values are: "endpoint.created",
                      "endpoint.deleted", "endpoint.disabled", "endpoint.updated",
                      "message.attempt.exhausted", "message.attempt.failing", and
                      "message.attempt.recovered".
                }
        """

    @overload
    async def receive_svix_operational_event(  # pylint: disable=inconsistent-return-statements
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Receive Svix operational events.

        Callback endpoint used by Svix to notify about operational events.

        :param body: The operational event. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def receive_svix_operational_event(  # pylint: disable=inconsistent-return-statements
        self, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """Receive Svix operational events.

        Callback endpoint used by Svix to notify about operational events.

        :param body: The operational event. Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "data": {
                        "str": {}  # Dictionary of :code:`<any>`. Required.
                    },
                    "type": "str"  # Required. Known values are: "endpoint.created",
                      "endpoint.deleted", "endpoint.disabled", "endpoint.updated",
                      "message.attempt.exhausted", "message.attempt.failing", and
                      "message.attempt.recovered".
                }
        """
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: HttpResponseError,
            401: lambda response: ClientAuthenticationError(response=response),
            501: HttpResponseError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_receive_svix_operational_event_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)  # type: ignore
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore
