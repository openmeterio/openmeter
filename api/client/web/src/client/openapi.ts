/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] }

export interface paths {
  '/api/v1/apps': {
    /** @description List apps. */
    get: operations['listApps']
  }
  '/api/v1/apps/{id}': {
    /** @description Get the app. */
    get: operations['getApp']
    /** @description Uninstall an app. */
    delete: operations['uninstallApp']
  }
  '/api/v1/apps/{id}/stripe/webhook': {
    /** @description Stripe webhook. */
    post: operations['appStripeWebhook']
  }
  '/api/v1/customers': {
    /** @description List customers. */
    get: operations['listCustomers']
    /** @description Create a new customer. */
    post: operations['createCustomer']
  }
  '/api/v1/customers/{customerIdOrKey}': {
    /** @description Get a customer by ID or key. */
    get: operations['getCustomer']
    /** @description Update a customer by ID or key. */
    put: operations['updateCustomer']
    /** @description Delete a customer by ID or key. */
    delete: operations['deleteCustomer']
  }
  '/api/v1/debug/metrics': {
    /**
     * Get event metrics
     * @description Returns debug metrics (in OpenMetrics format) like the number of ingested events since mindnight UTC.
     *
     * The OpenMetrics Counter(s) reset every day at midnight UTC.
     */
    get: operations['getDebugMetrics']
  }
  '/api/v1/entitlements': {
    /**
     * List all entitlements
     * @description List all entitlements for all the subjects and features. This endpoint is intended for administrative purposes only.
     * To fetch the entitlements of a specific subject please use the /api/v1/subjects/{subjectKeyOrID}/entitlements endpoint.
     * If page is provided that takes precedence and the paginated response is returned.
     */
    get: operations['listEntitlements']
  }
  '/api/v1/entitlements/{entitlementId}': {
    /** @description Get entitlement by id. */
    get: operations['getEntitlementById']
  }
  '/api/v1/events': {
    /**
     * List ingested events
     * @description List ingested events within a time range.
     *
     * If the from query param is not provided it defaults to last 72 hours.
     */
    get: operations['listEvents']
    /** @description Ingests an event or batch of events following the CloudEvents specification. */
    post: operations['ingestEvents']
  }
  '/api/v1/features': {
    /** @description List features. */
    get: operations['listFeatures']
    /**
     * @description Features are either metered or static. A feature is metered if meterSlug is provided at creation.
     * For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter's groupBy fields.
     * Only meters with SUM and COUNT aggregation are supported for features.
     * Features cannot be updated later, only archived.
     */
    post: operations['createFeature']
  }
  '/api/v1/features/{featureId}': {
    /** @description Get a feature by ID. */
    get: operations['getFeature']
    /**
     * @description Archive a feature by ID.
     *
     * Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements.
     * This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis.
     */
    delete: operations['deleteFeature']
  }
  '/api/v1/grants': {
    /**
     * @description List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only.
     * To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.
     * If page is provided that takes precedence and the paginated response is returned.
     */
    get: operations['listGrants']
  }
  '/api/v1/grants/{grantId}': {
    /**
     * @description Voiding a grant means it is no longer valid, it doesn't take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.
     * For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected.
     */
    delete: operations['voidGrant']
  }
  '/api/v1/integration/stripe/checkout/sessions': {
    /** @description Create checkout session. */
    post: operations['createStripeCheckoutSession']
  }
  '/api/v1/marketplace/listings': {
    /** @description List available apps of the app marketplace. */
    get: operations['listMarketplaceListings']
  }
  '/api/v1/marketplace/listings/{type}': {
    /** @description Get a marketplace listing by type. */
    get: operations['getMarketplaceListing']
  }
  '/api/v1/marketplace/listings/{type}/install/apikey': {
    /** @description Install an marketplace via API Key. */
    post: operations['marketplaceAppAPIKeyInstall']
  }
  '/api/v1/marketplace/listings/{type}/install/oauth2': {
    /**
     * @description Install an app via OAuth.
     * Returns a URL to start the OAuth 2.0 flow.
     */
    get: operations['marketplaceOAuth2InstallGetURL']
  }
  '/api/v1/marketplace/listings/{type}/install/oauth2/authorize': {
    /**
     * @description Authorize OAuth2 code.
     * Verifies the OAuth code and exchanges it for a token and refresh token
     */
    get: operations['marketplaceOAuth2InstallAuthorize']
  }
  '/api/v1/meters': {
    /** @description List meters. */
    get: operations['listMeters']
    /** @description Create a meter. */
    post: operations['createMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}': {
    /** @description Get a meter by ID or slug. */
    get: operations['getMeter']
    /** @description Delete a meter. */
    delete: operations['deleteMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/query': {
    /** @description Query meter for usage. Query meter for usage. */
    get: operations['queryMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/subjects': {
    /** @description List subjects for a meter. */
    get: operations['listMeterSubjects']
  }
  '/api/v1/notification/channels': {
    /**
     * List notification channels
     * @description List all notification channels.
     */
    get: operations['listNotificationChannels']
    /**
     * Create a notification channel
     * @description Create a new notification channel.
     */
    post: operations['createNotificationChannel']
  }
  '/api/v1/notification/channels/{channelId}': {
    /**
     * Get notification channel
     * @description Get a notification channel by id.
     */
    get: operations['getNotificationChannel']
    /**
     * Update a notification channel
     * @description Update notification channel.
     */
    put: operations['updateNotificationChannel']
    /**
     * Delete a notification channel
     * @description Soft delete notification channel by id.
     *
     * Once a notification channel is deleted it cannot be undeleted.
     */
    delete: operations['deleteNotificationChannel']
  }
  '/api/v1/notification/events': {
    /**
     * List notification events
     * @description List all notification events.
     */
    get: operations['listNotificationEvents']
  }
  '/api/v1/notification/events/{eventId}': {
    /**
     * Get notification event
     * @description Get a notification event by id.
     */
    get: operations['getNotificationEvent']
  }
  '/api/v1/notification/rules': {
    /**
     * List notification rules
     * @description List all notification rules.
     */
    get: operations['listNotificationRules']
    /**
     * Create a notification rule
     * @description Create a new notification rule.
     */
    post: operations['createNotificationRule']
  }
  '/api/v1/notification/rules/{ruleId}': {
    /**
     * Get notification rule
     * @description Get a notification rule by id.
     */
    get: operations['getNotificationRule']
    /**
     * Update a notification rule
     * @description Update notification rule.
     */
    put: operations['updateNotificationRule']
    /**
     * Delete a notification rule
     * @description Soft delete notification rule by id.
     *
     * Once a notification rule is deleted it cannot be undeleted.
     */
    delete: operations['deleteNotificationRule']
  }
  '/api/v1/notification/rules/{ruleId}/test': {
    /** @description Test a notification rule by sending a test event with random data. */
    post: operations['testNotificationRule']
  }
  '/api/v1/notification/webhook/svix': {
    /**
     * Receive Svix operational events
     * @description Callback endpoint used by Svix to notify about operational events.
     */
    post: operations['receiveSvixOperationalEvent']
  }
  '/api/v1/portal/meters/{meterSlug}/query': {
    /** @description Query meter for consumer portal. This endpoint is publicly exposable to consumers. Query meter for consumer portal. This endpoint is publicly exposable to consumers. */
    get: operations['queryPortalMeter']
  }
  '/api/v1/portal/tokens': {
    /** @description List tokens. */
    get: operations['listPortalTokens']
    /** @description Create a consumer portal token. */
    post: operations['createPortalToken']
  }
  '/api/v1/portal/tokens/invalidate': {
    /** @description Invalidates consumer portal tokens by ID or subject. */
    post: operations['invalidatePortalTokens']
  }
  '/api/v1/subjects': {
    /** @description List subjects. */
    get: operations['listSubjects']
    /**
     * @description Upserts a subject. Creates or updates subject.
     *
     * If the subject doesn't exist, it will be created.
     * If the subject exists, it will be partially updated with the provided fields.
     */
    post: operations['upsertSubject']
  }
  '/api/v1/subjects/{subjectIdOrKey}': {
    /** @description Get subject by ID or key. */
    get: operations['getSubject']
    /** @description Delete subject by ID or key. */
    delete: operations['deleteSubject']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements': {
    /** @description List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead. */
    get: operations['listSubjectEntitlements']
    /**
     * Create an entitlement
     * @description OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).
     *
     * - Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
     * - Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
     * - Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.
     *
     * A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.
     *
     * Once an entitlement is created you cannot modify it, only delete it.
     */
    post: operations['createEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants': {
    /** @description List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey. */
    get: operations['listEntitlementGrants']
    /**
     * @description Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.
     *
     * A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.
     *
     * Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.
     *
     * Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).
     *
     * Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
     *
     * Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.
     */
    post: operations['createGrant']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override': {
    /**
     * @description Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided subject-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.
     *
     * This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime.
     */
    put: operations['overrideEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value': {
    /**
     * @description This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
     *
     * For convenience reasons, /value works with both entitlementId and featureKey.
     */
    get: operations['getEntitlementValue']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}': {
    /** @description Get entitlement by id. For checking entitlement access, use the /value endpoint instead. */
    get: operations['getEntitlement']
    /**
     * @description Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
     * As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.
     */
    delete: operations['deleteEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history': {
    /**
     * @description Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.
     *
     * BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.
     *
     * WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.
     */
    get: operations['getEntitlementHistory']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset': {
    /**
     * @description Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.
     *
     * Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.
     */
    post: operations['resetEntitlementUsage']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    /** @description Address */
    Address: {
      country?: components['schemas']['CountryCode']
      postalCode?: string
      state?: string
      city?: string
      line1?: string
      line2?: string
      phoneNumber?: string
    }
    /**
     * @description Set of key-value pairs managed by the system. Cannot be modified by user.
     * @example {
     *   "externalId": "019142cc-a016-796a-8113-1a942fecd26d"
     * }
     */
    Annotations: {
      [key: string]: unknown
    }
    /**
     * @description App.
     * One of: stripe
     */
    App: components['schemas']['StripeApp']
    /**
     * @description Abstract base model for installed apps.
     *
     * Represent an app installed to the organization.
     * This is an actual instance, with its own configuration and credentials.
     */
    AppBase: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description The marketplace listing that this installed app is based on. */
      listing: components['schemas']['MarketplaceListing']
      /** @description Status of the app connection. */
      status: components['schemas']['OpenMeter.App.AppStatus']
    }
    /**
     * @description App capability.
     *
     * Capabilities only exist in config so they don't extend the Resource model.
     * @example {
     *   "type": "collectPayments",
     *   "key": "stripe_collect_payment",
     *   "name": "Collect Payments",
     *   "description": "Stripe payments collects outstanding revenue with Stripe customer's default payment method."
     * }
     */
    AppCapability: {
      /** @description The capability type. */
      type: components['schemas']['AppCapabilityType']
      /** @description Key */
      key: string
      /** @description The capability name. */
      name: string
      /** @description The capability description. */
      description: string
    }
    /**
     * @description App capability type.
     * @enum {string}
     */
    AppCapabilityType:
      | 'reportUsage'
      | 'reportEvents'
      | 'calculateTax'
      | 'invoiceCustomers'
      | 'collectPayments'
    /** @description A page of results. */
    AppList: {
      /** @description The page number. */
      page: number
      /** @description The number of items in the page. */
      pageSize: number
      /** @description The total number of items. */
      totalCount: number
      /** @description The items in the page. */
      items: components['schemas']['App'][]
    }
    /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
    BadRequestProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /** @description The balance history window. */
    BalanceHistoryWindow: {
      period: components['schemas']['Period']
      /**
       * Format: double
       * @description The total usage of the feature in the period.
       * @example 100
       */
      usage: number
      /**
       * Format: double
       * @description The entitlement balance at the start of the period.
       * @example 100
       */
      balanceAtStart: number
    }
    /** @description Stripe CheckoutSession.custom_text */
    CheckoutSessionCustomTextAfterSubmitParams: {
      afterSubmit?: {
        message?: string
      }
      shippingAddress?: {
        message?: string
      }
      submit?: {
        message?: string
      }
      termsOfServiceAcceptance?: {
        message?: string
      }
    }
    /**
     * @description Stripe CheckoutSession.ui_mode
     * @enum {string}
     */
    CheckoutSessionUIMode: 'embedded' | 'hosted'
    /** @description Response from the client app (OpenMeter backend) to start the OAuth2 flow. */
    ClientAppStartResponse: {
      /** @description The URL to start the OAuth2 authorization code grant flow. */
      url: string
    }
    /** @description The request could not be completed due to a conflict with the current state of the target resource. */
    ConflictProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.
     * Custom two-letter country codes are also supported for convenience.
     * @example US
     */
    CountryCode: string
    /** @description Create Stripe checkout session request. */
    CreateStripeCheckoutSessionRequest: {
      /**
       * @description If not provided, the default Stripe app is used if any.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      appId?: string
      /**
       * @description Provide a customer ID to use an existing OpenMeter customer.
       * or provide a customer object to create a new customer.
       */
      customer:
        | components['schemas']['CustomerId']
        | components['schemas']['Customer']
      /**
       * @description Stripe customer ID.
       * If not provided OpenMeter creates a new Stripe customer or
       * uses the OpenMeter customer's default Stripe customer ID.
       */
      stripeCustomerId?: string
      /** @description Options passed to Stripe when creating the checkout session. */
      options: components['schemas']['CreateStripeCheckoutSessionRequestOptions']
    }
    /** @description Create Stripe checkout session options */
    CreateStripeCheckoutSessionRequestOptions: {
      currency?: components['schemas']['CurrencyCode']
      cancelURL?: string
      clientReferenceID?: string
      customText?: components['schemas']['CheckoutSessionCustomTextAfterSubmitParams']
      metadata?: {
        [key: string]: string
      }
      returnURL?: string
      successURL?: string
      uiMode?: components['schemas']['CheckoutSessionUIMode']
      paymentMethodTypes?: string[]
    }
    /** @description Create Stripe Checkout Session response. */
    CreateStripeCheckoutSessionResponse: {
      /**
       * @description The OpenMeter customer ID.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      customerId: string
      /** @description The Stripe customer ID. */
      stripeCustomerId: string
      /** @description The checkout session ID. */
      sessionId: string
      /** @description The checkout session setup intent ID. */
      setupIntentId: string
      /** @description URL to show the checkout session. */
      url: string
      /**
       * @description Mode
       * Always `setup` for now.
       */
      mode: components['schemas']['StripeCheckoutSessionMode']
      /** @description Cancel URL. */
      cancelURL?: string
      /** @description Success URL. */
      successURL?: string
      /** @description Return URL. */
      returnURL?: string
    }
    /**
     * @description Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.
     * Custom three-letter currency codes are also supported for convenience.
     * @example USD
     */
    CurrencyCode: string
    /**
     * @description A customer object.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "name": "ACME Inc.",
     *   "usageAttribution": {
     *     "subjectKeys": [
     *       "my_subject_key"
     *     ]
     *   },
     *   "external": {
     *     "stripeCustomerId": "cus_xxxxxxxxxxxxxx"
     *   },
     *   "createdAt": "2024-01-01T01:01:01.001Z",
     *   "updatedAt": "2024-01-01T01:01:01.001Z"
     * }
     */
    Customer: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Timezone
       * @description Timezone of the customer.
       */
      timezone?: string
      /**
       * Usage Attribution
       * @description Mapping to attribute metered usage to the customer
       */
      usageAttribution: components['schemas']['CustomerUsageAttribution']
      /**
       * Primary Email
       * @description The primary email address of the customer.
       */
      primaryEmail?: string
      /**
       * Currency
       * @description Currency of the customer.
       * Used for billing, tax and invoicing.
       */
      currency?: components['schemas']['CurrencyCode']
      /**
       * Billing Address
       * @description The billing address of the customer.
       * Used for tax and invoicing.
       */
      billingAddress?: components['schemas']['Address']
      /**
       * External Mappings
       * @description External mappings for the customer.
       */
      external?: components['schemas']['CustomerExternalMapping']
    }
    /** @description External mappings for the customer. */
    CustomerExternalMapping: {
      /**
       * Stripe Customer
       * @description The Stripe customer ID.
       * Mapping to a Stripe Customer object.
       * Required to use Stripe as an invocing provider.
       */
      stripeCustomerId?: string
    }
    /** @description Create Stripe checkout session customer ID. */
    CustomerId: {
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
    }
    /** @description A unique customer identifier. */
    CustomerIdentifier: string
    /** @description A page of results. */
    CustomerList: {
      /** @description The page number. */
      page: number
      /** @description The number of items in the page. */
      pageSize: number
      /** @description The total number of items. */
      totalCount: number
      /** @description The items in the page. */
      items: components['schemas']['Customer'][]
    }
    /**
     * @description Mapping to attribute metered usage to the customer.
     * One customer can have multiple subjects,
     * but one subject can only belong to one customer.
     */
    CustomerUsageAttribution: {
      /**
       * SubjectKeys
       * @description The subjects that are attributed to the customer.
       */
      subjectKeys: string[]
    }
    /**
     * @description Entitlement templates are used to define the entitlements of a plan.
     * Features are omitted from the entitlement template, as they are defined in the rate card.
     */
    Entitlement:
      | components['schemas']['EntitlementMetered']
      | components['schemas']['EntitlementStatic']
      | components['schemas']['EntitlementBoolean']
    /** @description Shared fields of the entitlement templates. */
    EntitlementBaseTemplate: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /**
       * @description Readonly unique ULID identifier.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Type
       * @description The type of the entitlement.
       */
      type: components['schemas']['EntitlementType']
      /**
       * @description The identifier key unique to the subject
       * @example customer-1
       */
      subjectKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example example-feature-key
       */
      featureKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId: string
      /** @description The current usage period. */
      currentUsagePeriod?: components['schemas']['Period']
      /** @description The defined usage period of the entitlement */
      usagePeriod?: components['schemas']['RecurringPeriod']
    }
    /** @description Entitlement template of a boolean entitlement. */
    EntitlementBoolean: WithRequired<
      {
        /** @enum {string} */
        type: 'boolean'
        /**
         * Creation Time
         * Format: date-time
         * @description Timestamp of when the resource was created.
         * @example "2024-01-01T01:01:01.001Z"
         */
        createdAt: string
        /**
         * Last Update Time
         * Format: date-time
         * @description Timestamp of when the resource was last updated.
         * @example "2024-01-01T01:01:01.001Z"
         */
        updatedAt: string
        /**
         * Deletion Time
         * Format: date-time
         * @description Timestamp of when the resource was permanently deleted.
         * @example "2024-01-01T01:01:01.001Z"
         */
        deletedAt?: string
        /** @description Additional metadata for the feature. */
        metadata?: components['schemas']['Metadata']
        /**
         * @description Readonly unique ULID identifier.
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        id: string
        /**
         * @description The identifier key unique to the subject
         * @example customer-1
         */
        subjectKey: string
        /**
         * @description The feature the subject is entitled to use.
         * @example example-feature-key
         */
        featureKey: string
        /**
         * @description The feature the subject is entitled to use.
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        featureId: string
        /** @description The current usage period. */
        currentUsagePeriod?: components['schemas']['Period']
        /** @description The defined usage period of the entitlement */
        usagePeriod?: components['schemas']['RecurringPeriod']
      } & components['schemas']['EntitlementBaseTemplate'],
      | 'type'
      | 'createdAt'
      | 'updatedAt'
      | 'id'
      | 'subjectKey'
      | 'featureKey'
      | 'featureId'
    >
    /** @description Create inputs for boolean entitlement */
    EntitlementBooleanCreateInputs: {
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example example-feature-key
       */
      featureKey?: string
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /** @description The usage period associated with the entitlement. */
      usagePeriod?: components['schemas']['RecurringPeriodCreateInput']
      /** @enum {string} */
      type: 'boolean'
    }
    /** @description Create inputs for entitlement */
    EntitlementCreateInputs:
      | components['schemas']['EntitlementMeteredCreateInputs']
      | components['schemas']['EntitlementStaticCreateInputs']
      | components['schemas']['EntitlementBooleanCreateInputs']
    /** @description The grant. */
    EntitlementGrant: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Format: double
       * @description The amount to grant. Should be a positive number.
       * @example 100
       */
      amount: number
      /**
       * Format: int8
       * @description The priority of the grant. Grants with higher priority are applied first.
       * Priority is a positive decimal numbers. With lower numbers indicating higher importance.
       * For example, a priority of 1 is more urgent than a priority of 2.
       * When there are several grants available for the same subject, the system selects the grant with the highest priority.
       * In cases where grants share the same priority level, the grant closest to its expiration will be used first.
       * In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
       * @example 1
       */
      priority?: number
      /**
       * Format: date-time
       * @description Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
       * @example "2023-01-01T01:01:01.001Z"
       */
      effectiveAt: string
      /** @description The grant expiration definition */
      expiration: components['schemas']['ExpirationPeriod']
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       * Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       * @default 0
       * @example 100
       */
      maxRolloverAmount?: number
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       * Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       * @default 0
       * @example 100
       */
      minRolloverAmount?: number
      /**
       * @description The grant metadata.
       * @example {
       *   "stripePaymentId": "pi_4OrAkhLvyihio9p51h9iiFnB"
       * }
       */
      metadata?: components['schemas']['Metadata']
      /**
       * @description Readonly unique ULID identifier.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * @description The unique entitlement ULID that the grant is associated with.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      entitlementId: string
      /**
       * Format: date-time
       * @description The next time the grant will recurr.
       * @example "2023-01-01T01:01:01.001Z"
       */
      nextRecurrence?: string
      /**
       * Format: date-time
       * @description The time the grant expires.
       * @example "2023-01-01T01:01:01.001Z"
       */
      expiresAt?: string
      /**
       * Format: date-time
       * @description The time the grant was voided.
       * @example "2023-01-01T01:01:01.001Z"
       */
      voidedAt?: string
      /** @description The recurrence period of the grant. */
      recurrence?: components['schemas']['RecurringPeriod']
    }
    /** @description The grant creation input. */
    EntitlementGrantCreateInput: {
      /**
       * Format: double
       * @description The amount to grant. Should be a positive number.
       * @example 100
       */
      amount: number
      /**
       * Format: int8
       * @description The priority of the grant. Grants with higher priority are applied first.
       * Priority is a positive decimal numbers. With lower numbers indicating higher importance.
       * For example, a priority of 1 is more urgent than a priority of 2.
       * When there are several grants available for the same subject, the system selects the grant with the highest priority.
       * In cases where grants share the same priority level, the grant closest to its expiration will be used first.
       * In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
       * @example 1
       */
      priority?: number
      /**
       * Format: date-time
       * @description Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
       * @example "2023-01-01T01:01:01.001Z"
       */
      effectiveAt: string
      /** @description The grant expiration definition */
      expiration: components['schemas']['ExpirationPeriod']
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       * Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       * @default 0
       * @example 100
       */
      maxRolloverAmount?: number
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       * Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       * @default 0
       * @example 100
       */
      minRolloverAmount?: number
      /**
       * @description The grant metadata.
       * @example {
       *   "stripePaymentId": "pi_4OrAkhLvyihio9p51h9iiFnB"
       * }
       */
      metadata?: components['schemas']['Metadata']
      /** @description The subject of the grant. */
      recurrence?: components['schemas']['RecurringPeriodCreateInput']
    }
    /**
     * @description Metered entitlements are useful for many different use cases, from setting up usage based access to implementing complex credit systems.
     * Access is determined based on feature usage using a balance calculation (the "usage allowance" provided by the issued grants is "burnt down" by the usage).
     */
    EntitlementMetered: {
      /** @enum {string} */
      type: 'metered'
      /**
       * Soft limit
       * @description If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
       * @default false
       */
      isSoftLimit?: boolean
      /**
       * @deprecated
       * @description Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
       * @default false
       */
      isUnlimited?: boolean
      /**
       * Initial grant amount
       * Format: double
       * @description You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
       * If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
       * That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
       * Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
       */
      issueAfterReset?: number
      /**
       * Issue grant after reset priority
       * Format: uint8
       * @description Defines the grant priority for the default grant.
       * @default 1
       */
      issueAfterResetPriority?: number
      /**
       * Preserve overage at reset
       * @description If true, the overage is preserved at reset. If false, the usage is reset to 0.
       * @default false
       */
      preserveOverageAtReset?: boolean
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /**
       * @description Readonly unique ULID identifier.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * @description The identifier key unique to the subject
       * @example customer-1
       */
      subjectKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example example-feature-key
       */
      featureKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId: string
      /**
       * Format: date-time
       * @description The time the last reset happened.
       * @example "2023-01-01T01:01:01.001Z"
       */
      lastReset: string
      /** @description The current usage period. */
      currentUsagePeriod: components['schemas']['Period']
      /**
       * Format: date-time
       * @description The time from which usage is measured. If not specified on creation, defaults to entitlement creation time.
       * @example "2023-01-01T01:01:01.001Z"
       */
      measureUsageFrom: string
      /** @description THe usage period of the entitlement. */
      usagePeriod: components['schemas']['RecurringPeriod']
    }
    /** @description Create inpurs for metered entitlement */
    EntitlementMeteredCreateInputs: {
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example example-feature-key
       */
      featureKey?: string
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /** @enum {string} */
      type: 'metered'
      /**
       * Soft limit
       * @description If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
       * @default false
       */
      isSoftLimit?: boolean
      /**
       * @deprecated
       * @description Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
       * @default false
       */
      isUnlimited?: boolean
      /** @description The usage period associated with the entitlement. */
      usagePeriod: components['schemas']['RecurringPeriodCreateInput']
      /** @description Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time. */
      measureUsageFrom?: components['schemas']['MeasureUsageFrom']
      /**
       * Initial grant amount
       * Format: double
       * @description You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
       * If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
       * That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
       * Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
       */
      issueAfterReset?: number
      /**
       * Issue grant after reset priority
       * Format: uint8
       * @description Defines the grant priority for the default grant.
       * @default 1
       */
      issueAfterResetPriority?: number
      /**
       * Preserve overage at reset
       * @description If true, the overage is preserved at reset. If false, the usage is reset to 0.
       * @default false
       */
      preserveOverageAtReset?: boolean
    }
    /**
     * @description Order by options for entitlements.
     * @enum {string}
     */
    EntitlementOrderBy: 'createdAt' | 'updatedAt'
    /** @description Paginated response */
    EntitlementPaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['Entitlement'][]
    }
    /** @description A static entitlement. */
    EntitlementStatic: {
      /** @enum {string} */
      type: 'static'
      /**
       * Format: json
       * @description The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
       * @example { "integrations": ["github"] }
       */
      config: string
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /**
       * @description Readonly unique ULID identifier.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * @description The identifier key unique to the subject
       * @example customer-1
       */
      subjectKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example example-feature-key
       */
      featureKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId: string
      /** @description The current usage period. */
      currentUsagePeriod?: components['schemas']['Period']
      /** @description The defined usage period of the entitlement */
      usagePeriod?: components['schemas']['RecurringPeriod']
    }
    /** @description Create inputs for static entitlement */
    EntitlementStaticCreateInputs: {
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example example-feature-key
       */
      featureKey?: string
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /** @description The usage period associated with the entitlement. */
      usagePeriod?: components['schemas']['RecurringPeriodCreateInput']
      /** @enum {string} */
      type: 'static'
      /**
       * Format: json
       * @description The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
       * @example { "integrations": ["github"] }
       */
      config: string
    }
    /**
     * @description Type of the entitlement.
     * @enum {string}
     */
    EntitlementType: 'metered' | 'boolean' | 'static'
    /** @description Entitlements are the core of OpenMeter access management. They define access to features for subjects. Entitlements can be metered, boolean, or static. */
    EntitlementValue: {
      /**
       * @description Whether the subject has access to the feature. Shared accross all entitlement types.
       * @example true
       */
      hasAccess: boolean
      /**
       * Format: double
       * @description Only available for metered entitlements. Metered entitlements are built around a balance calculation where feature usage is deducted from the issued grants. Balance represents the remaining balance of the entitlement, it's value never turns negative.
       * @example 100
       */
      balance?: number
      /**
       * Format: double
       * @description Only available for metered entitlements. Returns the total feature usage in the current period.
       * @example 50
       */
      usage?: number
      /**
       * Format: double
       * @description Only available for metered entitlements. Overage represents the usage that wasn't covered by grants, e.g. if the subject had a total feature usage of 100 in the period but they were only granted 80, there would be 20 overage.
       * @example 0
       */
      overage?: number
      /**
       * @description Only available for static entitlements. The JSON parsable config of the entitlement.
       * @example { key: "value" }
       */
      config?: string
    }
    /**
     * @description CloudEvents Specification JSON Schema
     * @example {
     *   "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3c",
     *   "source": "service-name",
     *   "specversion": "1.0",
     *   "type": "prompt",
     *   "subject": "customer-id",
     *   "time": "2023-01-01T01:01:01.001Z"
     * }
     */
    Event: {
      /**
       * @description Identifies the event.
       * @example 5c10fade-1c9e-4d6c-8275-c52c36731d3c
       */
      id: string
      /**
       * Format: uri-reference
       * @description Identifies the context in which an event happened.
       * @example service-name
       */
      source: string
      /**
       * @description The version of the CloudEvents specification which the event uses.
       * @default 1.0
       * @example 1.0
       */
      specversion: string
      /**
       * @description Contains a value describing the type of event related to the originating occurrence.
       * @example com.example.someevent
       */
      type: string
      /**
       * @description Content type of the data value. Must adhere to RFC 2046 format.
       * @example application/json
       */
      datacontenttype?: string | null
      /**
       * Format: uri
       * @description Identifies the schema that data adheres to.
       */
      dataschema?: string | null
      /**
       * @description Describes the subject of the event in the context of the event producer (identified by source).
       * @example customer-id
       */
      subject?: string
      /**
       * Format: date-time
       * @description Timestamp of when the occurrence happened. Must adhere to RFC 3339.
       * @example "2023-01-01T01:01:01.001Z"
       */
      time?: string | null
      /** @description The event payload. */
      data?: Record<string, never> | string | null
    }
    /**
     * @description The expiration duration enum
     * @enum {string}
     */
    ExpirationDuration: 'HOUR' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
    /** @description The grant expiration definition */
    ExpirationPeriod: {
      /** @description The unit of time for the expiration period. */
      duration: components['schemas']['ExpirationDuration']
      /**
       * @description The number of time units in the expiration period.
       * @example 12
       */
      count: number
    }
    /**
     * @description Represents a feature that can be enabled or disabled for a plan.
     * Used both for product catalog and entitlements.
     */
    Feature: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Archival Time
       * Format: date-time
       * @description Timestamp of when the resource was archived.
       * @example "2023-01-01T01:01:01.001Z"
       */
      archivedAt?: string
      /**
       * The unique key of the feature
       * @description A key is a unique string that is used to identify a resource.
       */
      key: string
      /** The human-readable name of the feature */
      name: string
      /**
       * Optional metadata
       * @example {
       *   "key": "value"
       * }
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Meter slug
       * @description A key is a unique string that is used to identify a resource.
       * @example tokens_total
       */
      meterSlug?: string
      /**
       * Meter group by filters
       * @description Optional meter group by filters.
       * Useful if the meter scope is broader than what feature tracks.
       * Example scenario would be a meter tracking all token use with groupBy fields for the model,
       * then the feature could filter for model=gpt-4.
       * @example {
       *   "model": "gpt-4",
       *   "type": "input"
       * }
       */
      meterGroupByFilters?: {
        [key: string]: string
      }
      /**
       * @description Readonly unique ULID identifier.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
    }
    /**
     * @description Represents a feature that can be enabled or disabled for a plan.
     * Used both for product catalog and entitlements.
     */
    FeatureCreateInputs: {
      /**
       * The unique key of the feature
       * @description A key is a unique string that is used to identify a resource.
       */
      key: string
      /** The human-readable name of the feature */
      name: string
      /**
       * Optional metadata
       * @example {
       *   "key": "value"
       * }
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Meter slug
       * @description A key is a unique string that is used to identify a resource.
       * @example tokens_total
       */
      meterSlug?: string
      /**
       * Meter group by filters
       * @description Optional meter group by filters.
       * Useful if the meter scope is broader than what feature tracks.
       * Example scenario would be a meter tracking all token use with groupBy fields for the model,
       * then the feature could filter for model=gpt-4.
       * @example {
       *   "model": "gpt-4",
       *   "type": "input"
       * }
       */
      meterGroupByFilters?: {
        [key: string]: string
      }
    }
    /** @description Limited representation of a feature resource which includes only its unique identifiers (id, key). */
    FeatureMeta: {
      /**
       * Feature Unique Identifier
       * @description Unique identifier of a feature.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Feature Key
       * @description The key is an immutable unique identifier of the feature used throughout the API,
       * for example when interacting with a subject's entitlements.
       * @example gpt4_tokens
       */
      key: string
    }
    /**
     * @description Order by options for features.
     * @enum {string}
     */
    FeatureOrderBy: 'id' | 'createdAt' | 'updatedAt'
    /** @description Paginated response */
    FeaturePaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['Feature'][]
    }
    /** @description The server understood the request but refuses to authorize it. */
    ForbiddenProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /** @description The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server it needed to access in order to complete the request. */
    GatewayTimeoutProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description A segment of the grant burn down history.
     *
     * A given segment represents the usage of a grant between events that changed either the grant burn down priority order or the usag period.
     */
    GrantBurnDownHistorySegment: {
      /** @description The period of the segment. */
      period: components['schemas']['Period']
      /**
       * Format: double
       * @description The total usage of the grant in the period.
       * @example 100
       */
      usage: number
      /**
       * Format: double
       * @description Overuse that wasn't covered by grants.
       * @example 100
       */
      overage: number
      /**
       * Format: double
       * @description entitlement balance at the start of the period.
       * @example 100
       */
      balanceAtStart: number
      /**
       * @description The balance breakdown of each active grant at the start of the period: GrantID: Balance
       * @example {
       *   "01G65Z755AFWAKHE12NY0CQ9FH": 100
       * }
       */
      grantBalancesAtStart: {
        [key: string]: number
      }
      /**
       * Format: double
       * @description The entitlement balance at the end of the period.
       * @example 100
       */
      balanceAtEnd: number
      /**
       * @description The balance breakdown of each active grant at the end of the period: GrantID: Balance
       * @example {
       *   "01G65Z755AFWAKHE12NY0CQ9FH": 100
       * }
       */
      grantBalancesAtEnd: {
        [key: string]: number
      }
      /** @description Which grants were actually burnt down in the period and by what amount. */
      grantUsages: readonly components['schemas']['GrantUsageRecord'][]
    }
    /**
     * @description Order by options for grants.
     * @enum {string}
     */
    GrantOrderBy: 'id' | 'createdAt' | 'updatedAt'
    /** @description Paginated response */
    GrantPaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['EntitlementGrant'][]
    }
    /** @description Usage Record */
    GrantUsageRecord: {
      /**
       * @description The id of the grant
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      grantId: string
      /**
       * Format: double
       * @description The usage in the period
       * @example 100
       */
      usage: number
    }
    /**
     * @description An ingested event with optional validation error.
     * @example {
     *   "event": {
     *     "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3c",
     *     "source": "service-name",
     *     "specversion": "1.0",
     *     "type": "prompt",
     *     "subject": "customer-id",
     *     "time": "2023-01-01T01:01:01.001Z"
     *   },
     *   "ingestedAt": "2023-01-01T01:01:01.001Z",
     *   "storedAt": "2023-01-01T01:01:02.001Z"
     * }
     */
    IngestedEvent: {
      event: components['schemas']['Event']
      /** @description The validation error if the event failed validation. */
      validationError?: string
      /**
       * Format: date-time
       * @description The date and time the event was ingested.
       * @example "2023-01-01T01:01:01.001Z"
       */
      ingestedAt: string
      /**
       * Format: date-time
       * @description The date and time the event was stored.
       * @example "2023-01-01T01:01:01.001Z"
       */
      storedAt: string
    }
    /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
    InternalServerErrorProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description A marketplace listing.
     * Represent an available app in the app marketplace that can be installed to the organization.
     *
     * Marketplace apps only exist in config so they don't extend the Resource model.
     * @example {
     *   "type": "stripe",
     *   "name": "Stripe",
     *   "description": "Stripe interation allows you to collect payments with Stripe.",
     *   "iconUrl": "/images/stripe.png",
     *   "capabilities": [
     *     {
     *       "type": "calculateTax",
     *       "key": "stripe_calculate_tax",
     *       "name": "Calculate Tax",
     *       "description": "Stripe Tax calculates tax portion of the invoices."
     *     },
     *     {
     *       "type": "invoiceCustomers",
     *       "key": "stripe_invoice_customers",
     *       "name": "Invoice Customers",
     *       "description": "Stripe invoices customers with due amount."
     *     },
     *     {
     *       "type": "collectPayments",
     *       "key": "stripe_collect_payments",
     *       "name": "Collect Payments",
     *       "description": "Stripe payments collects outstanding revenue with Stripe customer's default payment method."
     *     }
     *   ]
     * }
     */
    MarketplaceListing: {
      /** @description The app's type */
      type: components['schemas']['OpenMeter.App.Type']
      /** @description The app's name. */
      name: string
      /** @description The app's description. */
      description: string
      /** @description The app's icon URL. */
      iconUrl: string
      /** @description The app's capabilities. */
      capabilities: components['schemas']['AppCapability'][]
    }
    /** @description A page of results. */
    MarketplaceListingList: {
      /** @description The page number. */
      page: number
      /** @description The number of items in the page. */
      pageSize: number
      /** @description The total number of items. */
      totalCount: number
      /** @description The items in the page. */
      items: components['schemas']['MarketplaceListing'][]
    }
    /** @description Measure usage from */
    MeasureUsageFrom:
      | components['schemas']['MeasureUsageFromEnum']
      | components['schemas']['MeasureUsageFromTime']
    /**
     * @description Start of measurement options
     * @enum {string}
     */
    MeasureUsageFromEnum: 'CURRENT_PERIOD_START' | 'NOW'
    /**
     * Format: date-time
     * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
     * @example "2023-01-01T01:01:01.001Z"
     */
    MeasureUsageFromTime: string
    /**
     * @description Set of key-value pairs.
     * Metadata can be used to store additional information about a resource.
     * @example {
     *   "externalId": "019142cc-a016-796a-8113-1a942fecd26d"
     * }
     */
    Metadata: {
      [key: string]: string
    }
    /**
     * @description A meter is a configuration that defines how to match and aggregate events.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "slug": "tokens_total",
     *   "description": "AI Token Usage",
     *   "aggregation": "SUM",
     *   "windowSize": "MINUTE",
     *   "eventType": "prompt",
     *   "valueProperty": "$.tokens",
     *   "groupBy": {
     *     "model": "$.model",
     *     "type": "$.type"
     *   }
     * }
     */
    Meter: {
      /**
       * @description A unique identifier for the meter.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * @description A unique, human-readable identifier for the meter.
       * Must consist only alphanumeric and underscore characters.
       * @example tokens_total
       */
      slug: string
      /**
       * @description A description of the meter.
       * @example AI Token Usage
       */
      description?: string
      /** @example SUM */
      aggregation: components['schemas']['MeterAggregation']
      /** @example MINUTE */
      windowSize: components['schemas']['WindowSize']
      /**
       * @description The event type to aggregate.
       * @example prompt
       */
      eventType: string
      /**
       * @description JSONPath expression to extract the value from the ingested event's data property.
       *
       * The ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.
       *
       * For UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.
       * @example $.tokens
       */
      valueProperty: string
      /**
       * @description Named JSONPath expressions to extract the group by values from the event data.
       *
       * Keys must be unique and consist only alphanumeric and underscore characters.
       *
       * TODO: add key format enforcement
       * @example {
       *   "type": "$.type"
       * }
       */
      groupBy?: {
        [key: string]: string
      }
    }
    /**
     * @description The aggregation type to use for the meter.
     * @enum {string}
     */
    MeterAggregation: 'SUM' | 'COUNT' | 'UNIQUE_COUNT' | 'AVG' | 'MIN' | 'MAX'
    /**
     * @description The result of a meter query.
     * @example {
     *   "from": "2023-01-01T00:00:00.000Z",
     *   "to": "2023-01-02T00:00:00.000Z",
     *   "windowSize": "DAY",
     *   "data": [
     *     {
     *       "value": 12,
     *       "windowStart": "2023-01-01T00:00:00.000Z",
     *       "windowEnd": "2023-01-02T00:00:00.000Z",
     *       "subject": "customer-1",
     *       "groupBy": {
     *         "model": "gpt-4-turbo",
     *         "type": "prompt"
     *       }
     *     }
     *   ]
     * }
     */
    MeterQueryResult: {
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      from?: string
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      to?: string
      windowSize?: components['schemas']['WindowSize']
      data: components['schemas']['MeterQueryRow'][]
    }
    /**
     * @description A row in the result of a meter query.
     * @example {
     *   "value": 12,
     *   "windowStart": "2023-01-01T00:00:00.000Z",
     *   "windowEnd": "2023-01-02T00:00:00.000Z",
     *   "subject": "customer-1",
     *   "groupBy": {
     *     "model": "gpt-4-turbo",
     *     "type": "prompt"
     *   }
     * }
     */
    MeterQueryRow: {
      value: number
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      windowStart: string
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      windowEnd: string
      subject?: string
      groupBy?: {
        [key: string]: string
      }
    }
    /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
    NotFoundProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /** @description The server does not support the functionality required to fulfill the request. */
    NotImplementedProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /** @description Notification channel. */
    NotificationChannel: components['schemas']['NotificationChannelWebhook']
    /** @description Union type for requests creating new notification channel with certain type. */
    NotificationChannelCreateRequest: components['schemas']['NotificationChannelWebhookCreateRequest']
    /** @description Metadata only fields of a notification channel. */
    NotificationChannelMeta: {
      /**
       * Channel Unique Identifier
       * @description Identifies the notification channel.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Channel Type
       * @description Notification channel type.
       */
      type: components['schemas']['NotificationChannelType']
    }
    /**
     * @description Order by options for notification channels.
     * @enum {string}
     */
    NotificationChannelOrderBy: 'id' | 'type' | 'createdAt' | 'updatedAt'
    /** @description Paginated response */
    NotificationChannelPaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['NotificationChannel'][]
    }
    /**
     * @description Type of the notification channel.
     * @enum {string}
     */
    NotificationChannelType: 'WEBHOOK'
    /** @description Notification channel with webhook type. */
    NotificationChannelWebhook: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Channel Unique Identifier
       * @description Identifies the notification channel.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Channel Type
       * @description Notification channel type.
       * @enum {string}
       */
      type: 'WEBHOOK'
      /**
       * Channel Name
       * @description User friendly name of the channel.
       * @example customer-webhook
       */
      name: string
      /**
       * Channel Disabled
       * @description Whether the channel is disabled or not.
       * @default false
       * @example true
       */
      disabled?: boolean
      /**
       * Webhook URL
       * @description Webhook URL where the notification is sent.
       * @example https://example.com/webhook
       */
      url: string
      /**
       * Custom HTTP Headers
       * @description Custom HTTP headers sent as part of the webhook request.
       */
      customHeaders?: {
        [key: string]: string
      }
      /**
       * Signing Secret
       * @description Signing secret used for webhook request validation on the receiving end.
       *
       * Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
       * @example whsec_S6g2HLnTwd9AhHwUIMFggVS9OfoPafN8
       */
      signingSecret?: string
    }
    /** @description Request with input parameters for creating new notification channel with webhook type. */
    NotificationChannelWebhookCreateRequest: {
      /**
       * Channel Type
       * @description Notification channel type.
       * @enum {string}
       */
      type: 'WEBHOOK'
      /**
       * Channel Name
       * @description User friendly name of the channel.
       * @example customer-webhook
       */
      name: string
      /**
       * Channel Disabled
       * @description Whether the channel is disabled or not.
       * @default false
       * @example true
       */
      disabled?: boolean
      /**
       * Webhook URL
       * @description Webhook URL where the notification is sent.
       * @example https://example.com/webhook
       */
      url: string
      /**
       * Custom HTTP Headers
       * @description Custom HTTP headers sent as part of the webhook request.
       */
      customHeaders?: {
        [key: string]: string
      }
      /**
       * Signing Secret
       * @description Signing secret used for webhook request validation on the receiving end.
       *
       * Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
       * @example whsec_S6g2HLnTwd9AhHwUIMFggVS9OfoPafN8
       */
      signingSecret?: string
    }
    /** @description Type of the notification event. */
    NotificationEvent: {
      /**
       * Event Identifier
       * @description A unique identifier of the notification event.
       * @example 01J2KNP1YTXQRXHTDJ4KPR7PZ0
       */
      id: string
      /**
       * Event Type
       * @description Type of the notification event.
       */
      type: components['schemas']['NotificationEventType']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp when the notification event was created in RFC 3339 format.
       * @example "2023-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Owner Rule
       * @description The nnotification rule which generated this event.
       */
      rule: components['schemas']['NotificationRule']
      /**
       * Delivery Status
       * @description The delivery status of the notification event.
       */
      deliveryStatus: readonly components['schemas']['NotificationEventDeliveryStatus'][]
      /**
       * Event Payload
       * @description Timestamp when the notification event was created in RFC 3339 format.
       */
      payload: components['schemas']['NotificationEventPayload']
      /**
       * Annotations
       * @description Set of key-value pairs managed by the system. Cannot be modified by user.
       */
      annotations?: components['schemas']['Annotations']
    }
    /** @description Payload for notification event with `entitlements.balance.threshold` type. */
    NotificationEventBalanceThresholdPayload: {
      /**
       * Notification Event Identifier
       * @description A unique identifier for the notification event the payload belongs to.
       * @example 01J2KNP1YTXQRXHTDJ4KPR7PZ0
       */
      id: string
      /**
       * Notification Event Type
       * @description Type of the notification event.
       * @enum {string}
       */
      type: 'entitlements.balance.threshold'
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp when the notification event was created in RFC 3339 format.
       * @example "2023-01-01T01:01:01.001Z"
       */
      timestamp: string
      /**
       * Payload Data
       * @description The data of the payload.
       */
      data: components['schemas']['NotificationEventBalanceThresholdPayloadData']
    }
    /** @description Data of the payload for notification event with `entitlements.balance.threshold` type. */
    NotificationEventBalanceThresholdPayloadData: {
      /** Entitlement */
      entitlement: components['schemas']['EntitlementMetered']
      /** Feature */
      feature: components['schemas']['Feature']
      /** Subject */
      subject: components['schemas']['Subject']
      /** Entitlement Value */
      value: components['schemas']['EntitlementValue']
      /** Threshold */
      threshold: components['schemas']['NotificationRuleBalanceThresholdValue']
    }
    /** @description The delivery status of the notification event. */
    NotificationEventDeliveryStatus: {
      /**
       * Delivery State
       * @description Delivery state of the notification event to the channel.
       * @example SUCCESS
       * @enum {string}
       */
      state: 'SUCCESS' | 'FAILED' | 'SENDING' | 'PENDING'
      /**
       * State Reason
       * @description The reason of the last deliverry state update.
       * @example Failed to dispatch event due to provider error.
       */
      reason: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the status was last updated in RFC 3339 format.
       * @example "2023-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Notification Channel
       * @description Notification channel the delivery sattus associated with.
       */
      channel: components['schemas']['NotificationChannelMeta']
    }
    /**
     * @description Order by options for notification channels.
     * @enum {string}
     */
    NotificationEventOrderBy: 'id' | 'createdAt'
    /** @description Paginated response */
    NotificationEventPaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['NotificationEvent'][]
    }
    /** @description The delivery status of the notification event. */
    NotificationEventPayload: components['schemas']['NotificationEventBalanceThresholdPayload']
    /**
     * @description Type of the notification event.
     * @enum {string}
     */
    NotificationEventType: 'entitlements.balance.threshold'
    /** @description Notification Rule. */
    NotificationRule: components['schemas']['NotificationRuleBalanceThreshold']
    /** @description Notification rule with entitlements.balance.threshold type. */
    NotificationRuleBalanceThreshold: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Rule Unique Identifier
       * @description Identifies the notification rule.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Rule Type
       * @description Notification rule type.
       * @enum {string}
       */
      type: 'entitlements.balance.threshold'
      /**
       * Rule Name
       * @description The user friendly name of the notification rule.
       * @example Balance threshold reached
       */
      name: string
      /**
       * Rule Disabled
       * @description Whether the rule is disabled or not.
       * @default false
       * @example true
       */
      disabled?: boolean
      /**
       * Channels assigned to Rule
       * @description List of notification channels the rule applies to.
       */
      channels: components['schemas']['NotificationChannelMeta'][]
      /**
       * Entitlement Balance Thresholds
       * @description List of thresholds the rule suppose to be triggered.
       */
      thresholds: components['schemas']['NotificationRuleBalanceThresholdValue'][]
      /**
       * Features
       * @description Optional field containing list of features the rule applies to.
       */
      features?: components['schemas']['FeatureMeta'][]
    }
    /** @description Request with input parameters for creating new notification rule with entitlements.balance.threashold type. */
    NotificationRuleBalanceThresholdCreateRequest: {
      /**
       * Rule Type
       * @description Notification rule type.
       * @enum {string}
       */
      type: 'entitlements.balance.threshold'
      /**
       * Rule Name
       * @description The user friendly name of the notification rule.
       * @example Balance threshold reached
       */
      name: string
      /**
       * Rule Disabled
       * @description Whether the rule is disabled or not.
       * @default false
       * @example true
       */
      disabled?: boolean
      /**
       * Entitlement Balance Thresholds
       * @description List of thresholds the rule suppose to be triggered.
       */
      thresholds: components['schemas']['NotificationRuleBalanceThresholdValue'][]
      /**
       * Channels
       * @description List of notification channels the rule is applied to.
       */
      channels: string[]
      /**
       * Features
       * @description Optional field for defining the scope of notification by feature. It may contain features by id or key.
       */
      features?: string[]
    }
    /** @description Threshold value with multiple supported types. */
    NotificationRuleBalanceThresholdValue: {
      /**
       * Threshold Value
       * Format: double
       * @description Value of the threshold.
       * @example 100
       */
      value: number
      /**
       * Threshold Type
       * @description Type of the threshold.
       * @example NUMBER
       * @enum {string}
       */
      type: 'PERCENT' | 'NUMBER'
    }
    /** @description Union type for requests creating new notification rule with certain type. */
    NotificationRuleCreateRequest: components['schemas']['NotificationRuleBalanceThresholdCreateRequest']
    /**
     * @description Order by options for notification channels.
     * @enum {string}
     */
    NotificationRuleOrderBy: 'id' | 'type' | 'createdAt' | 'updatedAt'
    /** @description Paginated response */
    NotificationRulePaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['NotificationRule'][]
    }
    /**
     * @description OAuth2 authorization code grant error types.
     * @enum {string}
     */
    OAuth2AuthorizationCodeGrantErrorType:
      | 'invalid_request'
      | 'unauthorized_client'
      | 'access_denied'
      | 'unsupported_response_type'
      | 'invalid_scope'
      | 'server_error'
      | 'temporarily_unavailable'
    /**
     * @description App installed status.
     * @enum {string}
     */
    'OpenMeter.App.AppStatus': 'ready' | 'unauthorized'
    /**
     * @description Stripe payment intent status.
     * @enum {string}
     */
    'OpenMeter.App.StripePaymentIntentStatus':
      | 'canceled'
      | 'processing'
      | 'requires_action'
      | 'requires_confirmation'
      | 'requires_payment_method'
      | 'succeeded'
    /**
     * @description Type of the app.
     * @enum {string}
     */
    'OpenMeter.App.Type': 'stripe'
    /**
     * @description The order direction.
     * @enum {string}
     */
    Order: 'ASC' | 'DESC'
    /** @description A period with a start and end time. */
    Period: {
      /**
       * Format: date-time
       * @description Period start time.
       * @example "2023-01-01T01:01:01.001Z"
       */
      from: string
      /**
       * Format: date-time
       * @description Period end time.
       * @example "2023-02-01T01:01:01.001Z"
       */
      to: string
    }
    /**
     * @description A consumer portal token.
     *
     * Validator doesn't obey required for readOnly properties
     * See: https://github.com/stoplightio/spectral/issues/1274
     */
    PortalToken: {
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id?: string
      /** @example customer-1 */
      subject: string
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      expiresAt?: string
      expired?: boolean
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      createdAt?: string
      /**
       * @description The token is only returned at creation.
       * @example om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo
       */
      token?: string
      /**
       * @description Optional, if defined only the specified meters will be allowed.
       * @example [
       *   "tokens_total"
       * ]
       */
      allowedMeterSlugs?: string[]
    }
    /** @description One or more conditions given in the request header fields evaluated to false when tested on the server. */
    PreconditionFailedProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description Recurring period with an interval and an anchor.
     * @example {
     *   "interval": "DAY",
     *   "anchor": "2023-01-01T01:01:01.001Z"
     * }
     */
    RecurringPeriod: {
      /**
       * Interval
       * @description The unit of time for the interval.
       */
      interval: components['schemas']['RecurringPeriodInterval']
      /**
       * Anchor time
       * Format: date-time
       * @description A date-time anchor to base the recurring period on.
       * @example "2023-01-01T01:01:01.001Z"
       */
      anchor: string
    }
    /**
     * @description Recurring period with an interval and an anchor.
     * @example {
     *   "interval": "DAY",
     *   "anchor": "2023-01-01T01:01:01.001Z"
     * }
     */
    RecurringPeriodCreateInput: {
      /**
       * Interval
       * @description The unit of time for the interval.
       */
      interval: components['schemas']['RecurringPeriodInterval']
      /**
       * Anchor time
       * Format: date-time
       * @description A date-time anchor to base the recurring period on.
       * @example "2023-01-01T01:01:01.001Z"
       */
      anchor?: string
    }
    /**
     * @description The unit of time for the interval.
     * One of: `day`, `week`, `month`, or `year`.
     * @enum {string}
     */
    RecurringPeriodInterval: 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
    /** @description Reset parameters */
    ResetEntitlementUsageInput: {
      /**
       * Format: date-time
       * @description The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.
       * @example "2023-01-01T01:01:01.001Z"
       */
      effectiveAt?: string
      /**
       * @description Determines whether the usage period anchor is retained or reset to the effectiveAt time.
       * - If true, the usage period anchor is retained.
       * - If false, the usage period anchor is reset to the effectiveAt time.
       */
      retainAnchor?: boolean
      /**
       * @description Determines whether the overage is preserved or forgiven, overriding the entitlement's default behavior.
       * - If true, the overage is preserved.
       * - If false, the overage is forgiven.
       */
      preserveOverage?: boolean
    }
    /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
    ServiceUnavailableProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description A installed Stripe app object.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "type": "stripe",
     *   "name": "Stripe",
     *   "status": "ready",
     *   "listing": {
     *     "type": "stripe",
     *     "name": "Stripe",
     *     "description": "Stripe interation allows you to collect payments with Stripe.",
     *     "iconUrl": "/images/stripe.png",
     *     "capabilities": [
     *       {
     *         "type": "calculateTax",
     *         "key": "stripe_calculate_tax",
     *         "name": "Calculate Tax",
     *         "description": "Stripe Tax calculates tax portion of the invoices."
     *       },
     *       {
     *         "type": "invoiceCustomers",
     *         "key": "stripe_invoice_customers",
     *         "name": "Invoice Customers",
     *         "description": "Stripe invoices customers with due amount."
     *       },
     *       {
     *         "type": "collectPayments",
     *         "key": "stripe_collect_payments",
     *         "name": "Collect Payments",
     *         "description": "Stripe payments collects outstanding revenue with Stripe customer's default payment method."
     *       }
     *     ]
     *   },
     *   "createdAt": "2024-01-01T01:01:01.001Z",
     *   "updatedAt": "2024-01-01T01:01:01.001Z",
     *   "stripeAccountId": "acct_123456789",
     *   "livemode": true
     * }
     */
    StripeApp: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description The marketplace listing that this installed app is based on. */
      listing: components['schemas']['MarketplaceListing']
      /** @description Status of the app connection. */
      status: components['schemas']['OpenMeter.App.AppStatus']
      /**
       * @description The app's type is Stripe.
       * @enum {string}
       */
      type: 'stripe'
      /** @description The Stripe account ID. */
      stripeAccountId: string
      /** @description Livemode, true if the app is in production mode. */
      livemode: boolean
    }
    /**
     * @description Stripe CheckoutSession.mode
     * @enum {string}
     */
    StripeCheckoutSessionMode: 'setup'
    /** @description Stripe setup intent. */
    StripeSetupIntent: {
      /** @description The setup intent id. */
      id: string
      /** @description The setup intent status. */
      status: components['schemas']['OpenMeter.App.StripePaymentIntentStatus']
      /** @description The setup intent payment method. */
      payment_method?: string
      /** @description The setup intent payment method types. */
      payment_method_types?: string[]
      /** @description The setup intent customer. */
      customer: string
      /** @description The setup intent metadata. */
      metadata: {
        [key: string]: string
      }
    }
    /** @description Stripe webhook event. */
    StripeWebhookEvent: {
      /** @description The event ID. */
      id: string
      /** @description The event type. */
      type: string
      /** @description Live mode. */
      livemode: boolean
      /**
       * Format: int32
       * @description The event created timestamp.
       */
      created: number
      /** @description The event data. */
      data: {
        object: components['schemas']['StripeSetupIntent']
      }
    }
    /** @description Stripe webhook response. */
    StripeWebhookResponse: {
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      namespaceId: string
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      appId: string
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      customerId?: string
    }
    /**
     * @description A subject is a unique identifier for a user or entity.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "key": "customer-id",
     *   "displayName": "Customer Name",
     *   "metadata": {
     *     "hubspotId": "123456"
     *   },
     *   "currentPeriodStart": "2023-01-01T00:00:00.000Z",
     *   "currentPeriodEnd": "2023-02-01T00:00:00.000Z",
     *   "stripeCustomerId": "cus_JMOlctsKV8"
     * }
     */
    Subject: {
      /**
       * @description A unique identifier for the subject.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * @description A unique, human-readable identifier for the subject.
       * @example customer-id
       */
      key: string
      /**
       * @description A human-readable display name for the subject.
       * @example Customer Name
       */
      displayName?: string
      /** @example {} */
      metadata?: {
        [key: string]: unknown
      } | null
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T00:00:00.000Z"
       */
      currentPeriodStart?: string
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-02-01T00:00:00.000Z"
       */
      currentPeriodEnd?: string
      /** @example cus_JMOlctsKV8 */
      stripeCustomerId?: string | null
    }
    /**
     * @description A subject is a unique identifier for a user or entity.
     * @example {
     *   "key": "customer-id",
     *   "displayName": "Customer Name",
     *   "metadata": {
     *     "hubspotId": "123456"
     *   },
     *   "currentPeriodStart": "2023-01-01T00:00:00.000Z",
     *   "currentPeriodEnd": "2023-02-01T00:00:00.000Z",
     *   "stripeCustomerId": "cus_JMOlctsKV8"
     * }
     */
    SubjectUpsert: {
      /**
       * @description A unique, human-readable identifier for the subject.
       * @example customer-id
       */
      key: string
      /**
       * @description A human-readable display name for the subject.
       * @example Customer Name
       */
      displayName?: string
      /** @example {} */
      metadata?: {
        [key: string]: unknown
      } | null
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T00:00:00.000Z"
       */
      currentPeriodStart?: string
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-02-01T00:00:00.000Z"
       */
      currentPeriodEnd?: string
      /** @example cus_JMOlctsKV8 */
      stripeCustomerId?: string | null
    }
    /** @description Operational webhook reqeuest sent by Svix. */
    SvixOperationalWebhookRequest: {
      /**
       * Operational Webhook Type
       * @description The type of the Svix operational webhook request.
       * @enum {string}
       */
      type:
        | 'endpoint.created'
        | 'endpoint.deleted'
        | 'endpoint.disabled'
        | 'endpoint.updated'
        | 'message.attempt.exhausted'
        | 'message.attempt.failing'
        | 'message.attempt.recovered'
      /**
       * Operational Webhook Payload
       * @description The payload of the Svix operational webhook request.
       */
      data: {
        [key: string]: string
      }
    }
    /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
    UnauthorizedProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description A Problem Details object (RFC 7807).
     * Additional properties specific to the problem type may be present.
     */
    UnexpectedProblemResponse: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @default about:blank
       * @example about:blank
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int16
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status?: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example The request body must be a JSON object.
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance: string
      [key: string]: (string | number) | undefined
    }
    /**
     * @description Aggregation window size.
     * @enum {string}
     */
    WindowSize: 'MINUTE' | 'HOUR' | 'DAY'
    /** @description The windowed balance history. */
    WindowedBalanceHistory: {
      /**
       * @description The windowed balance history.
       * - It only returns rows for windows where there was usage.
       * - The windows are inclusive at their start and exclusive at their end.
       * - The last window may be smaller than the window size and is inclusive at both ends.
       */
      windowedHistory: components['schemas']['BalanceHistoryWindow'][]
      /** @description Grant burndown history. */
      burndownHistory: components['schemas']['GrantBurnDownHistorySegment'][]
    }
  }
  responses: never
  parameters: {
    /** @description The order direction. */
    'EntitlementOrderByOrdering.order'?: components['schemas']['Order']
    /** @description The order by field. */
    'EntitlementOrderByOrdering.orderBy'?: components['schemas']['EntitlementOrderBy']
    /** @description The order direction. */
    'FeatureOrderByOrdering.order'?: components['schemas']['Order']
    /** @description The order by field. */
    'FeatureOrderByOrdering.orderBy'?: components['schemas']['FeatureOrderBy']
    /** @description The order direction. */
    'GrantOrderByOrdering.order'?: components['schemas']['Order']
    /** @description The order by field. */
    'GrantOrderByOrdering.orderBy'?: components['schemas']['GrantOrderBy']
    /**
     * @description Number of items to return.
     *
     * Default is 100.
     */
    'LimitOffset.limit'?: number
    /**
     * @description Number of items to skip.
     *
     * Default is 0.
     */
    'LimitOffset.offset'?: number
    /** @description The type of the app to install. */
    'MarketplaceApiKeyInstallRequest.type': components['schemas']['OpenMeter.App.Type']
    /** @description The type of the app to install. */
    'MarketplaceOAuth2InstallAuthorizeRequest.type': components['schemas']['OpenMeter.App.Type']
    /** @description Simple filter for group bys with exact match. */
    'MeterQuery.filterGroupBy'?: {
      [key: string]: string
    }
    /**
     * @description Start date-time in RFC 3339 format.
     *
     * Inclusive.
     */
    'MeterQuery.from'?: string
    /**
     * @description If not specified a single aggregate will be returned for each subject and time window.
     * `subject` is a reserved group by value.
     */
    'MeterQuery.groupBy'?: string[]
    /** @description Filtering by multiple subjects. */
    'MeterQuery.subject'?: string[]
    /**
     * @description End date-time in RFC 3339 format.
     *
     * Inclusive.
     */
    'MeterQuery.to'?: string
    /** @description If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group. */
    'MeterQuery.windowSize'?: components['schemas']['WindowSize']
    /**
     * @description The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
     * If not specified, the UTC timezone will be used.
     */
    'MeterQuery.windowTimeZone'?: string
    /** @description The order direction. */
    'NotificationChannelOrderByOrdering.order'?: components['schemas']['Order']
    /** @description The order by field. */
    'NotificationChannelOrderByOrdering.orderBy'?: components['schemas']['NotificationChannelOrderBy']
    /** @description The order direction. */
    'NotificationEventOrderByOrdering.order'?: components['schemas']['Order']
    /** @description The order by field. */
    'NotificationEventOrderByOrdering.orderBy'?: components['schemas']['NotificationEventOrderBy']
    /** @description The order direction. */
    'NotificationRuleOrderByOrdering.order'?: components['schemas']['Order']
    /** @description The order by field. */
    'NotificationRuleOrderByOrdering.orderBy'?: components['schemas']['NotificationRuleOrderBy']
    /**
     * @description Error code.
     * Required with the error response.
     */
    'OAuth2AuthorizationCodeGrantErrorParams.error'?: components['schemas']['OAuth2AuthorizationCodeGrantErrorType']
    /**
     * @description Optional human-readable text providing additional information,
     * used to assist the client developer in understanding the error that occurred.
     */
    'OAuth2AuthorizationCodeGrantErrorParams.error_description'?: string
    /**
     * @description Optional uri identifying a human-readable web page with
     * information about the error, used to provide the client
     * developer with additional information about the error
     */
    'OAuth2AuthorizationCodeGrantErrorParams.error_uri'?: string
    /**
     * @description Authorization code which the client will later exchange for an access token.
     * Required with the success response.
     */
    'OAuth2AuthorizationCodeGrantSuccessParams.code'?: string
    /**
     * @description Required if the "state" parameter was present in the client authorization request.
     * The exact value received from the client:
     *
     * Unique, randomly generated, opaque, and non-guessable string that is sent
     * when starting an authentication request and validated when processing the response.
     */
    'OAuth2AuthorizationCodeGrantSuccessParams.state'?: string
    /** @description The page number. */
    'PaginatedQuery.page'?: number
    /** @description The number of items in the page. */
    'PaginatedQuery.pageSize'?: number
    /**
     * @description Start date-time in RFC 3339 format.
     *
     * Inclusive.
     */
    'Pagination.page'?: number
    /**
     * @description Number of items per page.
     *
     * Default is 100.
     */
    'Pagination.pageSize'?: number
    /** @description Include deleted customers. */
    queryCustomerList?: boolean
  }
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /** @description List apps. */
  listApps: {
    parameters: {
      query?: {
        page?: components['parameters']['PaginatedQuery.page']
        pageSize?: components['parameters']['PaginatedQuery.pageSize']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['AppList'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get the app. */
  getApp: {
    parameters: {
      path: {
        id: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['App']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Uninstall an app. */
  uninstallApp: {
    parameters: {
      path: {
        id: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Stripe webhook. */
  appStripeWebhook: {
    parameters: {
      path: {
        id: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['StripeWebhookEvent']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['StripeWebhookResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List customers. */
  listCustomers: {
    parameters: {
      query?: {
        includeDeleted?: components['parameters']['queryCustomerList']
        page?: components['parameters']['PaginatedQuery.page']
        pageSize?: components['parameters']['PaginatedQuery.pageSize']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['CustomerList'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Create a new customer. */
  createCustomer: {
    requestBody: {
      content: {
        'application/json': components['schemas']['Customer']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get a customer by ID or key. */
  getCustomer: {
    parameters: {
      path: {
        customerIdOrKey: components['schemas']['CustomerIdentifier']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Update a customer by ID or key. */
  updateCustomer: {
    parameters: {
      path: {
        customerIdOrKey: components['schemas']['CustomerIdentifier']
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['Customer']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Delete a customer by ID or key. */
  deleteCustomer: {
    parameters: {
      path: {
        customerIdOrKey: components['schemas']['CustomerIdentifier']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get event metrics
   * @description Returns debug metrics (in OpenMetrics format) like the number of ingested events since mindnight UTC.
   *
   * The OpenMetrics Counter(s) reset every day at midnight UTC.
   */
  getDebugMetrics: {
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'text/plain': string
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List all entitlements
   * @description List all entitlements for all the subjects and features. This endpoint is intended for administrative purposes only.
   * To fetch the entitlements of a specific subject please use the /api/v1/subjects/{subjectKeyOrID}/entitlements endpoint.
   * If page is provided that takes precedence and the paginated response is returned.
   */
  listEntitlements: {
    parameters: {
      query?: {
        /**
         * @description Filtering by multiple features.
         *
         * Usage: `?feature=feature-1&feature=feature-2`
         */
        feature?: string[]
        /**
         * @description Filtering by multiple subjects.
         *
         * Usage: `?subject=customer-1&subject=customer-2`
         */
        subject?: string[]
        /**
         * @description Filtering by multiple entitlement types.
         *
         * Usage: `?entitlementType=metered&entitlementType=boolean`
         */
        entitlementType?: components['schemas']['EntitlementType'][]
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        offset?: components['parameters']['LimitOffset.offset']
        limit?: components['parameters']['LimitOffset.limit']
        order?: components['parameters']['EntitlementOrderByOrdering.order']
        orderBy?: components['parameters']['EntitlementOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json':
            | components['schemas']['Entitlement'][]
            | components['schemas']['EntitlementPaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get entitlement by id. */
  getEntitlementById: {
    parameters: {
      path: {
        entitlementId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List ingested events
   * @description List ingested events within a time range.
   *
   * If the from query param is not provided it defaults to last 72 hours.
   */
  listEvents: {
    parameters: {
      query?: {
        /**
         * @description Start date-time in RFC 3339 format.
         *
         * Inclusive.
         */
        ingestedAtFrom?: string
        /**
         * @description End date-time in RFC 3339 format.
         *
         * Inclusive.
         */
        ingestedAtTo?: string
        /**
         * @description If not provided lists all events.
         *
         * If provided with true, only list events with processing error.
         *
         * If provided with false, only list events without processing error.
         */
        hasError?: boolean
        /**
         * @description The event ID.
         *
         * Accepts partial ID.
         */
        id?: string
        /**
         * @description The event subject.
         *
         * Accepts partial subject.
         */
        subject?: string
        /**
         * @description Start date-time in RFC 3339 format.
         *
         * Inclusive.
         */
        from?: string
        /**
         * @description End date-time in RFC 3339 format.
         *
         * Inclusive.
         */
        to?: string
        /** @description Number of events to return. */
        limit?: number
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['IngestedEvent'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Ingests an event or batch of events following the CloudEvents specification. */
  ingestEvents: {
    requestBody: {
      content: {
        'application/cloudevents+json': components['schemas']['Event']
        'application/cloudevents-batch+json': components['schemas']['Event'][]
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/cloudevents+json': components['schemas']['Event']
          'application/cloudevents-batch+json': components['schemas']['Event'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List features. */
  listFeatures: {
    parameters: {
      query?: {
        /** @description Filter by meterSlug */
        meterSlug?: string[]
        /** @description Filter by meterGroupByFilters */
        includeArchived?: boolean
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        offset?: components['parameters']['LimitOffset.offset']
        limit?: components['parameters']['LimitOffset.limit']
        order?: components['parameters']['FeatureOrderByOrdering.order']
        orderBy?: components['parameters']['FeatureOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json':
            | components['schemas']['Feature'][]
            | components['schemas']['FeaturePaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Features are either metered or static. A feature is metered if meterSlug is provided at creation.
   * For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter's groupBy fields.
   * Only meters with SUM and COUNT aggregation are supported for features.
   * Features cannot be updated later, only archived.
   */
  createFeature: {
    requestBody: {
      content: {
        'application/json': components['schemas']['FeatureCreateInputs']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get a feature by ID. */
  getFeature: {
    parameters: {
      path: {
        featureId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Archive a feature by ID.
   *
   * Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements.
   * This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis.
   */
  deleteFeature: {
    parameters: {
      path: {
        featureId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only.
   * To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.
   * If page is provided that takes precedence and the paginated response is returned.
   */
  listGrants: {
    parameters: {
      query?: {
        /**
         * @description Filtering by multiple features.
         *
         * Usage: `?feature=feature-1&feature=feature-2`
         */
        feature?: string[]
        /**
         * @description Filtering by multiple subjects.
         *
         * Usage: `?subject=customer-1&subject=customer-2`
         */
        subject?: string[]
        /** @description Include deleted */
        includeDeleted?: boolean
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        offset?: components['parameters']['LimitOffset.offset']
        limit?: components['parameters']['LimitOffset.limit']
        order?: components['parameters']['GrantOrderByOrdering.order']
        orderBy?: components['parameters']['GrantOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json':
            | components['schemas']['EntitlementGrant'][]
            | components['schemas']['GrantPaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Voiding a grant means it is no longer valid, it doesn't take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.
   * For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected.
   */
  voidGrant: {
    parameters: {
      path: {
        grantId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Create checkout session. */
  createStripeCheckoutSession: {
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateStripeCheckoutSessionRequest']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['CreateStripeCheckoutSessionResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List available apps of the app marketplace. */
  listMarketplaceListings: {
    parameters: {
      query?: {
        page?: components['parameters']['PaginatedQuery.page']
        pageSize?: components['parameters']['PaginatedQuery.pageSize']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['MarketplaceListingList']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get a marketplace listing by type. */
  getMarketplaceListing: {
    parameters: {
      path: {
        type: components['schemas']['OpenMeter.App.Type']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['MarketplaceListing']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Install an marketplace via API Key. */
  marketplaceAppAPIKeyInstall: {
    parameters: {
      path: {
        type: components['parameters']['MarketplaceApiKeyInstallRequest.type']
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description The API key for the provider.
           * For example, the Stripe API key.
           */
          apiKey: string
        }
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['AppBase']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Install an app via OAuth.
   * Returns a URL to start the OAuth 2.0 flow.
   */
  marketplaceOAuth2InstallGetURL: {
    parameters: {
      path: {
        type: components['schemas']['OpenMeter.App.Type']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['ClientAppStartResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Authorize OAuth2 code.
   * Verifies the OAuth code and exchanges it for a token and refresh token
   */
  marketplaceOAuth2InstallAuthorize: {
    parameters: {
      query?: {
        state?: components['parameters']['OAuth2AuthorizationCodeGrantSuccessParams.state']
        code?: components['parameters']['OAuth2AuthorizationCodeGrantSuccessParams.code']
        error?: components['parameters']['OAuth2AuthorizationCodeGrantErrorParams.error']
        error_description?: components['parameters']['OAuth2AuthorizationCodeGrantErrorParams.error_description']
        error_uri?: components['parameters']['OAuth2AuthorizationCodeGrantErrorParams.error_uri']
      }
      path: {
        type: components['parameters']['MarketplaceOAuth2InstallAuthorizeRequest.type']
      }
    }
    responses: {
      /** @description Redirection */
      303: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List meters. */
  listMeters: {
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Meter'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Create a meter. */
  createMeter: {
    requestBody: {
      content: {
        'application/json': components['schemas']['Meter']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get a meter by ID or slug. */
  getMeter: {
    parameters: {
      path: {
        meterIdOrSlug: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Delete a meter. */
  deleteMeter: {
    parameters: {
      path: {
        meterIdOrSlug: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Query meter for usage. Query meter for usage. */
  queryMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['MeterQuery.from']
        to?: components['parameters']['MeterQuery.to']
        windowSize?: components['parameters']['MeterQuery.windowSize']
        windowTimeZone?: components['parameters']['MeterQuery.windowTimeZone']
        subject?: components['parameters']['MeterQuery.subject']
        filterGroupBy?: components['parameters']['MeterQuery.filterGroupBy']
        groupBy?: components['parameters']['MeterQuery.groupBy']
      }
      path: {
        meterIdOrSlug: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List subjects for a meter. */
  listMeterSubjects: {
    parameters: {
      path: {
        meterIdOrSlug: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': string[]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List notification channels
   * @description List all notification channels.
   */
  listNotificationChannels: {
    parameters: {
      query?: {
        /**
         * @description Include deleted notification channels in response.
         *
         * Usage: `?includeDeleted=true`
         */
        includeDeleted?: boolean
        /**
         * @description Include disabled notification channels in response.
         *
         * Usage: `?includeDisabled=false`
         */
        includeDisabled?: boolean
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        order?: components['parameters']['NotificationChannelOrderByOrdering.order']
        orderBy?: components['parameters']['NotificationChannelOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationChannelPaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create a notification channel
   * @description Create a new notification channel.
   */
  createNotificationChannel: {
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationChannelCreateRequest']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['NotificationChannel']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get notification channel
   * @description Get a notification channel by id.
   */
  getNotificationChannel: {
    parameters: {
      path: {
        channelId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationChannel']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Update a notification channel
   * @description Update notification channel.
   */
  updateNotificationChannel: {
    parameters: {
      path: {
        channelId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationChannelCreateRequest']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationChannel']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Delete a notification channel
   * @description Soft delete notification channel by id.
   *
   * Once a notification channel is deleted it cannot be undeleted.
   */
  deleteNotificationChannel: {
    parameters: {
      path: {
        channelId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List notification events
   * @description List all notification events.
   */
  listNotificationEvents: {
    parameters: {
      query?: {
        /**
         * @description Start date-time in RFC 3339 format.
         * Inclusive.
         */
        from?: string
        /**
         * @description End date-time in RFC 3339 format.
         * Inclusive.
         */
        to?: string
        /**
         * @description Filtering by multiple feature ids or keys.
         *
         * Usage: `?feature=feature-1&feature=feature-2`
         */
        feature?: string[]
        /**
         * @description Filtering by multiple subject ids or keys.
         *
         * Usage: `?subject=subject-1&subject=subject-2`
         */
        subject?: string[]
        /**
         * @description Filtering by multiple rule ids.
         *
         * Usage: `?rule=01J8J2XYZ2N5WBYK09EDZFBSZM&rule=01J8J4R4VZH180KRKQ63NB2VA5`
         */
        rule?: string[]
        /**
         * @description Filtering by multiple channel ids.
         *
         * Usage: `?channel=01J8J4RXH778XB056JS088PCYT&channel=01J8J4S1R1G9EVN62RG23A9M6J`
         */
        channel?: string[]
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        order?: components['parameters']['NotificationEventOrderByOrdering.order']
        orderBy?: components['parameters']['NotificationEventOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationEventPaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get notification event
   * @description Get a notification event by id.
   */
  getNotificationEvent: {
    parameters: {
      path: {
        eventId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Event']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List notification rules
   * @description List all notification rules.
   */
  listNotificationRules: {
    parameters: {
      query?: {
        /**
         * @description Include deleted notification rules in response.
         *
         * Usage: `?includeDeleted=true`
         */
        includeDeleted?: boolean
        /**
         * @description Include disabled notification rules in response.
         *
         * Usage: `?includeDisabled=false`
         */
        includeDisabled?: boolean
        /**
         * @description Filtering by multiple feature ids/keys.
         *
         * Usage: `?feature=feature-1&feature=feature-2`
         */
        feature?: string[]
        /**
         * @description Filtering by multiple notifiaction channel ids.
         *
         * Usage: `?channel=01ARZ3NDEKTSV4RRFFQ69G5FAV&channel=01J8J2Y5X4NNGQS32CF81W95E3`
         */
        channel?: string[]
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        order?: components['parameters']['NotificationRuleOrderByOrdering.order']
        orderBy?: components['parameters']['NotificationRuleOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRulePaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create a notification rule
   * @description Create a new notification rule.
   */
  createNotificationRule: {
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationRuleCreateRequest']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['NotificationRule']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get notification rule
   * @description Get a notification rule by id.
   */
  getNotificationRule: {
    parameters: {
      path: {
        ruleId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRule']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Update a notification rule
   * @description Update notification rule.
   */
  updateNotificationRule: {
    parameters: {
      path: {
        ruleId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationRuleCreateRequest']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRule']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Delete a notification rule
   * @description Soft delete notification rule by id.
   *
   * Once a notification rule is deleted it cannot be undeleted.
   */
  deleteNotificationRule: {
    parameters: {
      path: {
        ruleId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Test a notification rule by sending a test event with random data. */
  testNotificationRule: {
    parameters: {
      path: {
        ruleId: string
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['Event']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Receive Svix operational events
   * @description Callback endpoint used by Svix to notify about operational events.
   */
  receiveSvixOperationalEvent: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SvixOperationalWebhookRequest']
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Query meter for consumer portal. This endpoint is publicly exposable to consumers. Query meter for consumer portal. This endpoint is publicly exposable to consumers. */
  queryPortalMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['MeterQuery.from']
        to?: components['parameters']['MeterQuery.to']
        windowSize?: components['parameters']['MeterQuery.windowSize']
        windowTimeZone?: components['parameters']['MeterQuery.windowTimeZone']
        filterGroupBy?: components['parameters']['MeterQuery.filterGroupBy']
        groupBy?: components['parameters']['MeterQuery.groupBy']
      }
      path: {
        meterSlug: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List tokens. */
  listPortalTokens: {
    parameters: {
      query?: {
        limit?: number
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Create a consumer portal token. */
  createPortalToken: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PortalToken']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Invalidates consumer portal tokens by ID or subject. */
  invalidatePortalTokens: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Invalidate a portal token by ID. */
          id?: string
          /** @description Invalidate all portal tokens for a subject. */
          subject?: string
        }
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List subjects. */
  listSubjects: {
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Upserts a subject. Creates or updates subject.
   *
   * If the subject doesn't exist, it will be created.
   * If the subject exists, it will be partially updated with the provided fields.
   */
  upsertSubject: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SubjectUpsert'][]
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get subject by ID or key. */
  getSubject: {
    parameters: {
      path: {
        subjectIdOrKey: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subject']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Delete subject by ID or key. */
  deleteSubject: {
    parameters: {
      path: {
        subjectIdOrKey: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead. */
  listSubjectEntitlements: {
    parameters: {
      query?: {
        includeDeleted?: boolean
      }
      path: {
        subjectIdOrKey: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create an entitlement
   * @description OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).
   *
   * - Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
   * - Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
   * - Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.
   *
   * A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.
   *
   * Once an entitlement is created you cannot modify it, only delete it.
   */
  createEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementCreateInputs']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['EntitlementCreateInputs']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey. */
  listEntitlementGrants: {
    parameters: {
      query?: {
        includeDeleted?: boolean
        orderBy?: components['schemas']['GrantOrderBy']
      }
      path: {
        subjectIdOrKey: string
        entitlementIdOrFeatureKey: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementGrant'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.
   *
   * A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.
   *
   * Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.
   *
   * Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).
   *
   * Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
   *
   * Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.
   */
  createGrant: {
    parameters: {
      path: {
        subjectIdOrKey: string
        entitlementIdOrFeatureKey: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementGrantCreateInput']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['EntitlementGrant']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided subject-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.
   *
   * This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime.
   */
  overrideEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: string
        entitlementIdOrFeatureKey: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementCreateInputs']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
   *
   * For convenience reasons, /value works with both entitlementId and featureKey.
   */
  getEntitlementValue: {
    parameters: {
      query?: {
        time?: string
      }
      path: {
        subjectIdOrKey: string
        entitlementIdOrFeatureKey: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementValue']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get entitlement by id. For checking entitlement access, use the /value endpoint instead. */
  getEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: string
        entitlementId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
   * As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.
   */
  deleteEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: string
        entitlementId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.
   *
   * BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.
   *
   * WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.
   */
  getEntitlementHistory: {
    parameters: {
      query: {
        /** @description Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to the last reset. Gets truncated to the granularity of the underlying meter. */
        from?: string
        /**
         * @description End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.
         * If not now then gets truncated to the granularity of the underlying meter.
         */
        to?: string
        /** @description Windowsize */
        windowSize: components['schemas']['WindowSize']
        /** @description The timezone used when calculating the windows. */
        windowTimeZone?: string
      }
      path: {
        subjectIdOrKey: string
        entitlementId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['WindowedBalanceHistory']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.
   *
   * Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.
   */
  resetEntitlementUsage: {
    parameters: {
      path: {
        subjectIdOrKey: string
        entitlementId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['ResetEntitlementUsageInput']
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
}
