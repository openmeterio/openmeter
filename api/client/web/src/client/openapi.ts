/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/customers': {
    /** @description List customers. */
    get: operations['listCustomers']
    /** @description Create a new customer. */
    post: operations['createCustomer']
  }
  '/api/v1/customers/{customerIdOrKey}': {
    /** @description Get a customer by ID or key. */
    get: operations['getCustomer']
    /** @description Update a customer by ID or key. */
    put: operations['updateCustomer']
    /** @description Delete a customer by ID or key. */
    delete: operations['deleteCustomer']
  }
  '/api/v1/events': {
    /**
     * List ingested events
     * @description List ingested events within a time range.
     * If the from query param is not provided it defaults to last 72 hours.
     */
    get: operations['listEvents']
    /**
     * Ingest events
     * @description Ingests an event or batch of events following the CloudEvents specification.
     */
    post: operations['ingestEvents']
  }
  '/api/v1/meters': {
    /**
     * List meters
     * @description List meters.
     */
    get: operations['listMeters']
    /**
     * ☁ Create meter
     * @description *Available in OpenMeter Cloud.*
     * *In the open-source version, meters are created in the configuration file.*
     *
     * Create a meter.
     */
    post: operations['createMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}': {
    /**
     * Get meter
     * @description Get meter by ID or slug
     */
    get: operations['getMeter']
    /**
     * ☁ Delete meter
     * @description *Available in OpenMeter Cloud.*
     *
     * Delete a meter by ID or slug.
     */
    delete: operations['deleteMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/query': {
    /**
     * Query meter
     * @description Query meter for usage.
     */
    get: operations['queryMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/subjects': {
    /**
     * List meter subjects
     * @description List subjects for a meter.
     */
    get: operations['listMeterSubjects']
  }
  '/api/v1/portal/tokens': {
    /**
     * ☁ List portal tokens
     * @description *Available in OpenMeter Cloud.*
     *
     * List consumer portal tokens.
     */
    get: operations['listPortalTokens']
    /**
     * Create portal token
     * @description Create a consumer portal token.
     */
    post: operations['createPortalToken']
  }
  '/api/v1/portal/tokens/invalidate': {
    /**
     * ☁ Invalidate portal tokens
     * @description *Available in OpenMeter Cloud.*
     *
     * Invalidates consumer portal tokens by ID or subject.
     */
    post: operations['invalidatePortalTokens']
  }
  '/api/v1/subjects': {
    /**
     * ☁ List subjects
     * @description *Available in OpenMeter Cloud.*
     *
     * List subjects.
     */
    get: operations['listSubjects']
    /**
     * ☁ Upsert subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Upserts a subject. Creates or updates subject.
     * If the subject doesn't exist, it will be created.
     * If the subject exists, it will be partially updated with the provided fields.
     */
    post: operations['upsertSubject']
  }
  '/api/v1/subjects/{subjectIdOrKey}': {
    /**
     * ☁ Get subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Get subject by ID or key.
     */
    get: operations['getSubject']
    /**
     * ☁ Delete subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Delete a subject by ID or key.
     */
    delete: operations['deleteSubject']
  }
  '/api/v1/portal/meters/{meterSlug}/query': {
    /**
     * Query portal meter
     * @description Query meter for consumer portal. This endpoint is publicly exposable to consumers.
     */
    get: operations['queryPortalMeter']
  }
  '/api/v1/entitlements': {
    /**
     * List entitlements
     * @description List all entitlements regardless of subject. This endpoint is intended for administrative purposes.
     * If page is provided that takes precedence and the paginated response is returned.
     */
    get: operations['listEntitlements']
  }
  '/api/v1/entitlements/{entitlementId}': {
    /**
     * Get an entitlement
     * @description Get entitlement by id.
     */
    get: operations['getEntitlementById']
  }
  '/api/v1/features': {
    /**
     * List features
     * @description List all features. If page is provided that takes precedence and the paginated response is returned.
     */
    get: operations['listFeatures']
    /**
     * Create a feature
     * @description Features are either metered or static. A feature is metered if meterSlug is provided at creation.
     * For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter's groupBy fields. Only meters with SUM and COUNT aggregation are supported for features.
     *
     * Features cannot be updated later, only archived.
     */
    post: operations['createFeature']
  }
  '/api/v1/features/{featureId}': {
    /**
     * Get feature
     * @description Get a feature by id.
     */
    get: operations['getFeature']
    /**
     * Archive a feature
     * @description Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements. This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis.
     */
    delete: operations['deleteFeature']
  }
  '/api/v1/grants': {
    /**
     * List grants
     * @description List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only. To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.
     *
     * If page is provided that takes precedence and the paginated response is returned.
     */
    get: operations['listGrants']
  }
  '/api/v1/grants/{grantId}': {
    /**
     * Void a grant
     * @description Voiding a grant means it is no longer valid, it doesn't take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.
     *
     * For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected.
     */
    delete: operations['voidGrant']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements': {
    /**
     * List entitlements of a subject
     * @description List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead.
     */
    get: operations['listSubjectEntitlements']
    /**
     * Create an entitlement
     * @description OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).
     *
     * - Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
     * - Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
     * - Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.
     *
     * A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.
     *
     * Once an entitlement is created you cannot modify it, only delete it.
     */
    post: operations['createEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}': {
    /**
     * Get an entitlement
     * @description Get entitlement by id. For checking entitlement access, use the /value endpoint instead.
     */
    get: operations['getEntitlement']
    /**
     * Delete an entitlement
     * @description Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
     * As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.
     */
    delete: operations['deleteEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override': {
    /**
     * Override an entitlement
     * @description Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided subject-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.
     *
     * This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime.
     */
    put: operations['overrideEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants': {
    /**
     * List grants for an entitlement
     * @description List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey.
     */
    get: operations['listEntitlementGrants']
    /**
     * Create a grant
     * @description Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.
     *
     * A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.
     *
     * Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.
     *
     * Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).
     *
     * Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
     *
     * Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.
     */
    post: operations['createGrant']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value': {
    /**
     * Get the current value and access of an entitlement
     * @description This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
     *
     * For convenience reasons, /value works with both entitlementId and featureKey.
     */
    get: operations['getEntitlementValue']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history': {
    /**
     * Get the balance history of a specific entitlement.
     * @description Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.
     *
     * BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.
     *
     * WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.
     */
    get: operations['getEntitlementHistory']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset': {
    /**
     * Reset an entitlement
     * @description Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.
     *
     * Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.
     */
    post: operations['resetEntitlementUsage']
  }
  '/api/v1/debug/metrics': {
    /**
     * Get event metrics
     * @description Returns debug metrics like the number of ingested events since mindnight UTC.
     * The OpenMetrics Counter(s) reset every day at midnight UTC.
     */
    get: operations['getDebugMetrics']
  }
  '/api/v1/notification/channels': {
    /**
     * List notification channels
     * @description List all notification channels.
     */
    get: operations['listNotificationChannels']
    /**
     * Create a notification channel
     * @description Create a new notification channel.
     */
    post: operations['createNotificationChannel']
  }
  '/api/v1/notification/channels/{channelId}': {
    /**
     * Get notification channel
     * @description Get a notification channel by id.
     */
    get: operations['getNotificationChannel']
    /**
     * Update notification channel
     * @description Update a notification channel by id.
     */
    put: operations['updateNotificationChannel']
    /**
     * Delete a notification channel
     * @description Delete notification channel by id.
     */
    delete: operations['deleteNotificationChannel']
  }
  '/api/v1/notification/rules': {
    /**
     * List notification rules
     * @description List all notification rules.
     */
    get: operations['listNotificationRules']
    /**
     * Create a notification rule
     * @description Create a new notification rule.
     */
    post: operations['createNotificationRule']
  }
  '/api/v1/notification/rules/{ruleId}': {
    /**
     * Get notification rule
     * @description Get a notification rule by id.
     */
    get: operations['getNotificationRule']
    /**
     * Update a notification rule
     * @description Update a notification rule by id.
     */
    put: operations['updateNotificationRule']
    /**
     * Delete a notification rule
     * @description Delete notification rule by id.
     */
    delete: operations['deleteNotificationRule']
  }
  '/api/v1/notification/rules/{ruleId}/test': {
    /**
     * Test notification rule
     * @description Test a notification rule by sending a test event with random data.
     */
    post: operations['testNotificationRule']
  }
  '/api/v1/notification/events': {
    /**
     * List notification evens
     * @description List all notification events.
     */
    get: operations['listNotificationEvents']
  }
  '/api/v1/notification/events/{eventId}': {
    /**
     * Get notification event
     * @description Get a notification event by id.
     */
    get: operations['getNotificationEvent']
  }
  '/api/v1/notification/webhook/svix': {
    /**
     * Receive Svix operational events
     * @description Callback endpoint used by Svix to notify about operational events
     */
    post: operations['receiveSvixOperationalEvent']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    /** @description Address */
    Address: {
      country?: components['schemas']['CountryCode']
      postalCode?: string
      state?: string
      city?: string
      line1?: string
      line2?: string
      phoneNumber?: string
    }
    /**
     * @description Metadata fields for all resources.
     * These fields are automatically populated by the system for managed entities. Their use and meaning is uniform across all resources.
     */
    SharedMetaFields: {
      /**
       * @description Readonly unique ULID identifier.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Format: date-time
       * @description The date and time the resource was created.
       * @example 2023-01-01T00:00:00Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description The date and time the resource was last updated. The initial value is the same as createdAt.
       * @example 2023-01-01T00:00:00Z
       */
      updatedAt: string
      /**
       * Format: date-time
       * @description The date and time the resource was deleted.
       * @example 2023-01-01T00:00:00Z
       */
      deletedAt?: string
    }
    /**
     * @description Conflict
     * @example {
     *   "type": "about:blank",
     *   "title": "Conflict",
     *   "status": 409,
     *   "detail": "ledger (default.01HXVNDJR532E8GTBVSC2XK5D4) already exitst for subject subject-1",
     *   "instance": "urn:request:local/JMOlctsKV8-000001",
     *   "conflictingEntityId": "01HXVNDJR532E8GTBVSC2XK5D4"
     * }
     */
    ConflictProblem: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @example urn:problem-type:bad-request
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int32
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example body must be a JSON object
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance?: string
      extensions?: {
        /**
         * @description The id of the conflicting entity.
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        conflictingEntityId: string
      }
      [key: string]: unknown
    }
    /**
     * @description A Problem Details object (RFC 7807).
     * Additional properties specific to the problem type may be present.
     * @example {
     *   "type": "urn:problem-type:bad-request",
     *   "title": "Bad Request",
     *   "status": 400,
     *   "detail": "body must be a JSON object"
     * }
     */
    Problem: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @example urn:problem-type:bad-request
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int32
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example body must be a JSON object
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance?: string
      [key: string]: unknown
    }
    /**
     * @description [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.
     * Custom two-letter country codes are also supported for convenience.
     * @example US
     */
    CountryCode: string
    /**
     * @description Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.
     * Custom three-letter currency codes are also supported for convenience.
     * @example USD
     */
    CurrencyCode: string
    /**
     * @description A customer object.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "key": "my_customer_key",
     *   "name": "ACME Inc.",
     *   "usageAttribution": {
     *     "subjectKeys": [
     *       "my_subject_key"
     *     ]
     *   },
     *   "taxProvider": "stripe_tax",
     *   "invoicingProvider": "stripe_invoicing",
     *   "paymentProvider": "stripe_payments",
     *   "external": {
     *     "stripeCustomerId": "cus_xxxxxxxxxxxxxx"
     *   }
     * }
     */
    Customer: {
      /**
       * ID
       * @description A unique identifier for the customer.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: components['schemas']['ULID']
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * @description Timestamp of when the resource was created.
       */
      createdAt?: components['schemas']['DateTime']
      /**
       * Last Update Time
       * @description Timestamp of when the resource was last updated.
       */
      updatedAt?: components['schemas']['DateTime']
      /**
       * Deletion Time
       * @description Timestamp of when the resource was permanently deleted.
       */
      deletedAt?: components['schemas']['DateTime']
      /**
       * Archival Time
       * @description Timestamp of when the resource was archived.
       */
      archivedAt?: components['schemas']['DateTime']
      /**
       * Usage Attribution
       * @description Mapping to attribute metered usage to the customer
       */
      usageAttribution: components['schemas']['CustomerUsageAttribution']
      /**
       * Primary Email
       * @description The primary email address of the customer.
       */
      primaryEmail?: string
      /**
       * Currency
       * @description Currency of the customer.
       * Used for billing, tax and invoicing.
       */
      currency?: components['schemas']['CurrencyCode']
      /**
       * Timezone
       * @description Timezone of the customer.
       */
      timezone?: string
      /**
       * Billing Address
       * @description The billing address of the customer.
       * Used for tax and invoicing.
       */
      billingAddress?: components['schemas']['Address']
      /**
       * External Mappings
       * @description External mappings for the customer.
       */
      external?: components['schemas']['CustomerExternalMapping']
    }
    /** @description A unique customer identifier. */
    CustomerIdentifier:
      | components['schemas']['ULID']
      | components['schemas']['Key']
    /** @description External mappings for the customer. */
    CustomerExternalMapping: {
      /**
       * Stripe Customer
       * @description The Stripe customer ID.
       * Mapping to a Stripe Customer object.
       * Required to use Stripe as an invocing provider.
       */
      stripeCustomerId?: string
    }
    /** @description A page of results. */
    CustomerList: {
      /** @description The page number. */
      page: number
      /** @description The number of items in the page. */
      pageSize: number
      /** @description The total number of items. */
      totalCount: number
      /** @description The items in the page. */
      items: components['schemas']['Customer'][]
    }
    /**
     * @description Mapping to attribute metered usage to the customer.
     * One customer can have multiple subjects,
     * but one subject can only belong to one customer.
     */
    CustomerUsageAttribution: {
      /**
       * SubjectKeys
       * @description The subjects that are attributed to the customer.
       */
      subjectKeys: string[]
    }
    /**
     * @description CloudEvents Specification JSON Schema
     * @example {
     *   "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3c",
     *   "source": "service-name",
     *   "specversion": "1.0",
     *   "type": "prompt",
     *   "subject": "customer-id",
     *   "time": "2023-01-01T01:01:01.001Z",
     *   "data": {
     *     "tokens": "1234",
     *     "model": "gpt-4-turbo",
     *     "type": "input"
     *   }
     * }
     */
    Event: {
      /**
       * @description Identifies the event.
       * @example 5c10fade-1c9e-4d6c-8275-c52c36731d3c
       */
      id: string
      /**
       * Format: uri-reference
       * @description Identifies the context in which an event happened.
       * @example service-name
       */
      source: string
      /**
       * @description The version of the CloudEvents specification which the event uses.
       * @example 1.0
       */
      specversion: string
      /**
       * @description Describes the type of event related to the originating occurrence.
       * @example prompt
       */
      type: string
      /**
       * @description Content type of the data value. Must adhere to RFC 2046 format.
       * @example application/json
       * @enum {string|null}
       */
      datacontenttype?: 'application/json' | null
      /**
       * Format: uri
       * @description Identifies the schema that data adheres to.
       */
      dataschema?: string | null
      /**
       * @description Describes the subject of the event in the context of the event producer (identified by source).
       * @example customer-id
       */
      subject: string
      /**
       * Format: date-time
       * @description Timestamp of when the occurrence happened. Must adhere to RFC 3339.
       * @example 2023-01-01T01:01:01.001Z
       */
      time?: string | null
      /**
       * @description The event payload.
       * @example {
       *   "tokens": "1234",
       *   "model": "gpt-4-turbo"
       * }
       */
      data?: {
        [key: string]: unknown
      }
    }
    /**
     * @description An ingested event with optional validation error.
     * @example {
     *   "event": {
     *     "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3d",
     *     "source": "service-name",
     *     "specversion": "1.0",
     *     "type": "prompt",
     *     "subject": "customer-id",
     *     "time": "2024-01-01T01:01:01.001Z",
     *     "data": {
     *       "tokens": "1234",
     *       "model": "gpt-4-turbo"
     *     }
     *   },
     *   "validationError": "meter not found for event",
     *   "ingestedAt": "2024-01-01T00:00:00Z",
     *   "storedAt": "2024-01-01T00:00:00Z"
     * }
     */
    readonly IngestedEvent: {
      readonly event: components['schemas']['Event']
      /** @example invalid event */
      readonly validationError?: string
      /**
       * Format: date-time
       * @description The date and time the event was ingested.
       * @example 2024-01-01T00:00:00Z
       */
      readonly ingestedAt: string
      /**
       * Format: date-time
       * @description The date and time the event was stored.
       * @example 2024-01-01T00:00:00Z
       */
      readonly storedAt: string
    }
    /**
     * @description A invoicing provider.
     * @enum {string}
     */
    InvoicingProvider: 'openmeter_sandbox' | 'stripe_invoicing'
    /**
     * @description A feature is a feature or service offered to a customer.
     * For example: CPU-Hours, Tokens, API Calls, etc.
     */
    FeatureCreateInputs: {
      /**
       * @description The key is an immutable unique identifier of the feature used throughout the API, for example when interacting with a subject's entitlements. The key has to be unique across all active features, but archived features can share the same key. The key should consist of lowercase alphanumeric characters and dashes.
       *
       * @example gpt4_tokens
       */
      key: string
      /**
       * @description The name of the feature.
       *
       * @example AI Tokens
       */
      name: string
      /** @description Additional metadata for the feature, useful for syncing with external systems and annotating custom fields. */
      metadata?: {
        [key: string]: string
      }
      /**
       * @description The meter that the feature is associated with and and based on which usage is calculated.
       * The meter selected must have SUM or COUNT aggregation.
       *
       * @example tokens_total
       */
      meterSlug?: string
      /**
       * @description Optional meter group by filters. Useful if the meter scope is broader than what feature tracks. Example scenario would be a meter tracking all token use with groupBy fields for the model, then the feature could filter for model=gpt-4.
       *
       * @example {
       *   "model": "gpt-4"
       * }
       */
      meterGroupByFilters?: {
        [key: string]: string
      }
    }
    /**
     * @description A feature is a feature or service offered to a customer.
     * For example: CPU-Hours, Tokens, API Calls, etc.
     */
    Feature: {
      /**
       * Format: date-time
       * @description If the feature is archived, no new entitlements can be created for it.
       *
       * @example 2023-01-01T00:00:00Z
       */
      archivedAt?: string
    } & components['schemas']['FeatureCreateInputs'] &
      components['schemas']['SharedMetaFields']
    ListFeaturePaginatedResponse: components['schemas']['PaginationInfo'] & {
      /** @description List of features. */
      items: components['schemas']['Feature'][]
    }
    ListFeatureResponse:
      | components['schemas']['Feature'][]
      | components['schemas']['ListFeaturePaginatedResponse']
    /** @description Limited representation of a feature resource which includes only its unique identifiers (id, key). */
    FeatureMeta: {
      /**
       * @description A unique identifier for the notification rule.
       * @example 01J2KNP1YTXQRXHTDJ4KPR7PZ0
       */
      id: string
      /**
       * @description The key is an immutable unique identifier of the feature used throughout the API,
       * for example when interacting with a subject's entitlements.
       *
       * @example gpt4_tokens
       */
      key: string
    }
    /**
     * Format: date-time
     * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
     * @example "2023-01-01T01:01:01.001Z"
     */
    DateTime: string
    EntitlementCreateSharedFields: {
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       *
       * @example example-feature-key
       */
      featureKey?: string
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId?: string
      /** @description Additional metadata for the feature. */
      metadata?: {
        [key: string]: string
      }
      usagePeriod?: components['schemas']['RecurringPeriodCreateInput']
    }
    EntitlementSharedFields: components['schemas']['SharedMetaFields'] &
      components['schemas']['EntitlementCreateSharedFields'] & {
        /**
         * @description The feature the subject is entitled to use.
         * Either featureKey or featureId is required.
         *
         * @example example-feature-key
         */
        featureKey: string
        /**
         * @description The feature the subject is entitled to use.
         * Either featureKey or featureId is required.
         *
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        featureId: string
        /**
         * @description The identifier key unique to the subject
         * @example customer-1
         */
        subjectKey: string
        usagePeriod?: components['schemas']['RecurringPeriod']
        currentUsagePeriod?: components['schemas']['Period']
      }
    /** @enum {string} */
    MeasureUsageFromEnum: 'CURRENT_PERIOD_START' | 'NOW'
    /** Format: date-time */
    MeasureUsageFromTime: string
    /**
     * @description The time from which usage is measured, defaults to the entitlement creation time.
     * The provided value is truncated to the granularity of the underlying meter.
     */
    MeasureUsageFrom:
      | components['schemas']['MeasureUsageFromEnum']
      | components['schemas']['MeasureUsageFromTime']
    EntitlementMeteredCreateInputs: components['schemas']['EntitlementCreateSharedFields'] & {
      /**
       * @example metered
       * @enum {string}
       */
      type: 'metered'
      /**
       * @description If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
       *
       * @default false
       */
      isSoftLimit?: boolean
      /**
       * @description Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
       *
       * @default false
       */
      isUnlimited?: boolean
      usagePeriod: components['schemas']['RecurringPeriodCreateInput']
      measureUsageFrom?: components['schemas']['MeasureUsageFrom']
      /**
       * Format: double
       * @description You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance. If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
       * That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
       *
       * Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
       */
      issueAfterReset?: number
      /**
       * @description Defines the grant priority for the default grant. If provided, issueAfterReset must have a value.
       *
       * @default 1
       * @example 1
       */
      issueAfterResetPriority?: number
      /**
       * @description If true, the overage is preserved at reset. If false, the usage is forgiven.
       *
       * @default false
       */
      preserveOverageAtReset?: boolean
    }
    EntitlementCreateInputs:
      | components['schemas']['EntitlementMeteredCreateInputs']
      | components['schemas']['EntitlementStaticCreateInputs']
      | components['schemas']['EntitlementBooleanCreateInputs']
    /** @description Metered entitlements are useful for many different use cases, from setting up usage based access to implementing complex credit systems. Access is determined based on feature usage using a balance calculation (the "usage allowance" provided by the issued grants is "burnt down" by the usage). */
    EntitlementMetered: components['schemas']['EntitlementMeteredCreateInputs'] &
      components['schemas']['EntitlementMeteredCalculatedFields'] &
      components['schemas']['EntitlementSharedFields']
    /** @description Calculated fields for a metered entitlement. */
    EntitlementMeteredCalculatedFields: {
      /**
       * Format: date-time
       * @description The last time a reset happened.
       *
       * @example 2023-01-01T00:00:00Z
       */
      lastReset: string
      currentUsagePeriod: components['schemas']['Period']
      /**
       * Format: date-time
       * @description The time from which usage is measured. If not specified on creation, defaults to the entitlement creation time.
       */
      measureUsageFrom: string
    }
    EntitlementStaticCreateInputs: components['schemas']['EntitlementCreateSharedFields'] & {
      /**
       * @example static
       * @enum {string}
       */
      type: 'static'
      /**
       * @description The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
       *
       * @example {"key1": "value1"}
       */
      config: string
    }
    /** @description Entitles a subject to use a feature. */
    EntitlementStatic: components['schemas']['EntitlementStaticCreateInputs'] &
      components['schemas']['EntitlementSharedFields']
    EntitlementBooleanCreateInputs: components['schemas']['EntitlementCreateSharedFields'] & {
      /**
       * @example boolean
       * @enum {string}
       */
      type: 'boolean'
    }
    /** @description Entitles a subject to use a feature. */
    EntitlementBoolean: components['schemas']['EntitlementBooleanCreateInputs'] &
      components['schemas']['EntitlementSharedFields']
    Entitlement:
      | components['schemas']['EntitlementMetered']
      | components['schemas']['EntitlementStatic']
      | components['schemas']['EntitlementBoolean']
    ListEntitlementPaginatedResponse: components['schemas']['PaginationInfo'] & {
      /** @description List of entitlements. */
      items: components['schemas']['Entitlement'][]
    }
    ListEntitlementResponse:
      | components['schemas']['Entitlement'][]
      | components['schemas']['ListEntitlementPaginatedResponse']
    /**
     * @description A segment of the grant burn down history.
     *
     * A given segment represents the usage of a grant between events that changed either the grant burn down priority order or the usag period.
     */
    GrantBurnDownHistorySegment: {
      period?: components['schemas']['Period']
      /**
       * Format: double
       * @description The usage of the grant in the period.
       *
       * @example 100
       */
      usage?: number
      /**
       * Format: double
       * @description Overuse that wasn't covered by grants.
       *
       * @example 25
       */
      overage?: number
      /**
       * Format: double
       * @description The entitlement balance at the start of the period.
       *
       * @example 100
       */
      balanceAtStart?: number
      /**
       * @description The balance breakdown of each active grant at the start of the period: GrantID: Balance
       *
       * @example {
       *   "01ARZ3NDEKTSV4RRFFQ69G5FAV": 100
       * }
       */
      grantBalancesAtStart?: {
        [key: string]: number
      }
      /**
       * Format: double
       * @description The entitlement balance at the end of the period.
       *
       * @example 100
       */
      balanceAtEnd?: number
      /**
       * @description The balance breakdown of each active grant at the start of the period: GrantID: Balance
       *
       * @example {
       *   "01ARZ3NDEKTSV4RRFFQ69G5FAV": 100
       * }
       */
      grantBalancesAtEnd?: {
        [key: string]: number
      }
      /** @description Which grants were actually burnt down in the period and by what amount. */
      grantUsages?: readonly components['schemas']['GrantUsageRecord'][]
    }
    GrantUsageRecord: {
      /**
       * @description The id of the grant.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      grantId?: string
      /**
       * Format: double
       * @description The usage of the grant.
       *
       * @example 100
       */
      usage?: number
    }
    /** @description Windowed usage and balance information. */
    BalanceHistoryWindow: {
      period?: components['schemas']['Period']
      /**
       * Format: double
       * @description The total usage of the feature in the period.
       *
       * @example 100
       */
      usage?: number
      /**
       * Format: double
       * @description The entitlement balance at the start of the period.
       *
       * @example 100
       */
      balanceAtStart?: number
    }
    /** @description The windowed balance history. */
    WindowedBalanceHistory: {
      /**
       * @description The windowed balance history.
       * - It only returns rows for windows where there was usage.
       * - The windows are inclusive at their start and exclusive at their end.
       * - The last window may be smaller than the window size and is inclusive at both ends.
       */
      windowedHistory?: components['schemas']['BalanceHistoryWindow'][]
      /** @description Grant burndown history. */
      burndownHistory?: components['schemas']['GrantBurnDownHistorySegment'][]
    }
    /** @description A time period */
    Period: {
      /**
       * Format: date-time
       * @description Period start time where the amount was applied. If applicable.
       *
       * @example 2023-01-01T00:00:00Z
       */
      from: string
      /**
       * Format: date-time
       * @description Period end time where the amount was applied. If applicable.
       *
       * @example 2023-01-01T00:00:00Z
       */
      to: string
    }
    /**
     * @description List of pre-defined periods that can be used for recurring & scheduling.
     *
     * DAY:      Every day
     * WEEK:     Every week
     * MONTH:    Every month
     * YEAR:     Every year
     *
     * @enum {string}
     */
    RecurringPeriodEnum: 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
    /** @description Recurring period of an entitlement. */
    RecurringPeriodCreateInput: {
      interval: components['schemas']['RecurringPeriodEnum']
      /**
       * Format: date-time
       * @description An arbitrary anchor to base the recurring period on.
       * If not provided then defaults to now truncated to the hour.
       */
      anchor?: string
    }
    /** @description Recurring period of an entitlement. */
    RecurringPeriod: {
      interval: components['schemas']['RecurringPeriodEnum']
      /**
       * Format: date-time
       * @description An arbitrary anchor to base the recurring period on.
       */
      anchor: string
    }
    /** @description Grants are used to increase balance of specific subjects. */
    EntitlementGrantCreateInput: {
      /**
       * Format: double
       * @description The amount to grant. Should be a positive number.
       *
       * @example 100
       */
      amount: number
      /**
       * @description The priority of the grant. Grants with higher priority are applied first.
       * Priority is a positive decimal numbers. With lower numbers indicating higher importance.
       * For example, a priority of 1 is more urgent than a priority of 2.
       * When there are several grants available for the same subject, the system selects the grant with the highest priority.
       * In cases where grants share the same priority level, the grant closest to its expiration will be used first.
       * In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
       *
       * @default 1
       * @example 1
       */
      priority?: number
      /**
       * Format: date-time
       * @description Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
       *
       * @example 2023-01-01T00:00:00Z
       */
      effectiveAt: string
      expiration: components['schemas']['ExpirationPeriod']
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       *
       * Balance after the reset is calculated as:
       * Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       *
       * @default 0
       * @example 100
       */
      maxRolloverAmount?: number
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       *
       * Balance after the reset is calculated as:
       * Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       *
       * @default 0
       * @example 100
       */
      minRolloverAmount?: number
      /**
       * @example {
       *   "stripePaymentId": "pi_4OrAkhLvyihio9p51h9iiFnB"
       * }
       */
      metadata?: {
        [key: string]: string
      }
      recurrence?: components['schemas']['RecurringPeriodCreateInput']
    }
    EntitlementGrant: components['schemas']['EntitlementGrantCreateInput'] &
      components['schemas']['SharedMetaFields'] & {
        /**
         * @description The unique entitlement ULID that the grant is associated with.
         *
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        entitlementId: string
        /**
         * Format: date-time
         * @description The next time the grant will recurr.
         *
         * @example 2023-01-01T00:00:00Z
         */
        nextRecurrence?: string
        /**
         * Format: date-time
         * @description The expiration date of the grant.
         *
         * @example 2023-01-01T00:00:00Z
         */
        expiresAt?: string
        /**
         * Format: date-time
         * @description The date and time the grant was voided (cannot be used after that).
         */
        voidedAt?: string
        recurrence?: components['schemas']['RecurringPeriod']
      }
    ListEntitlementGrantPaginatedResponse: components['schemas']['PaginationInfo'] & {
      /** @description List of grants. */
      items: components['schemas']['EntitlementGrant'][]
    }
    ListEntitlementGrantResponse:
      | components['schemas']['EntitlementGrant'][]
      | components['schemas']['ListEntitlementGrantPaginatedResponse']
    EntitlementValue: {
      /**
       * @description Whether the subject has access to the feature. Shared accross all entitlement types.
       *
       * @example true
       */
      hasAccess: boolean
      /**
       * Format: double
       * @description Only available for metered entitlements. Metered entitlements are built around a balance calculation where feature usage is deducted from the issued grants. Balance represents the remaining balance of the entitlement, it's value never turns negative.
       *
       * @example 100
       */
      balance?: number
      /**
       * Format: double
       * @description Only available for metered entitlements. Returns the total feature usage in the current period.
       *
       * @example 50
       */
      usage?: number
      /**
       * Format: double
       * @description Only available for metered entitlements. Overage represents the usage that wasn't covered by grants, e.g. if the subject had a total feature usage of 100 in the period but they were only granted 80, there would be 20 overage.
       *
       * @example 0
       */
      overage?: number
      /**
       * @description Only available for static entitlements. The JSON parsable config of the entitlement.
       *
       * @example {"key1": "value1"}
       */
      config?: string
    }
    /** @description Expiration period of a grant. */
    ExpirationPeriod: {
      /**
       * @description The expiration period duration like month.
       *
       * @enum {string}
       */
      duration: 'HOUR' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
      /**
       * @description The expiration period count like 12 months.
       *
       * @example 12
       */
      count: number
    }
    /**
     * @description A meter is a configuration that defines how to match and aggregate events.
     * @example {
     *   "slug": "tokens_total",
     *   "description": "AI token usage",
     *   "aggregation": "SUM",
     *   "windowSize": "MINUTE",
     *   "eventType": "prompt",
     *   "valueProperty": "$.tokens",
     *   "groupBy": {
     *     "model": "$.model",
     *     "type": "$.type"
     *   }
     * }
     */
    Meter: {
      /**
       * @description A unique identifier for the meter.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id?: string
      /**
       * @description A unique, human-readable identifier for the meter. Must consist only alphanumeric and underscore characters.
       * @example tokens_total
       */
      slug: string
      /**
       * @description A description of the meter.
       * @example AI Token Usage
       */
      description?: string | null
      aggregation: components['schemas']['MeterAggregation']
      windowSize: components['schemas']['WindowSize']
      /**
       * @description The event type to aggregate.
       * @example prompt
       */
      eventType: string
      /**
       * @description JSONPath expression to extract the value from the ingested event's data property.
       * The ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.
       * For UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.
       *
       * @example $.tokens
       */
      valueProperty?: string
      /**
       * @description Named JSONPath expressions to extract the group by values from the event data. Keys must be unique and consist only alphanumeric and underscore characters.
       * @example {
       *   "model": "$.model",
       *   "type": "$.type"
       * }
       */
      groupBy?: {
        [key: string]: string
      }
    }
    /**
     * @description The aggregation type to use for the meter.
     * @example SUM
     * @enum {string}
     */
    MeterAggregation: 'SUM' | 'COUNT' | 'UNIQUE_COUNT' | 'AVG' | 'MIN' | 'MAX'
    /**
     * @description Set of key-value pairs.
     * Metadata can be used to store additional information about a resource.
     * @example {
     *   "externalId": "019142cc-a016-796a-8113-1a942fecd26d"
     * }
     */
    Metadata: {
      [key: string]: string
    }
    /**
     * @description Aggregation window size.
     * @example MINUTE
     * @enum {string}
     */
    WindowSize: 'MINUTE' | 'HOUR' | 'DAY'
    /**
     * @description The result of a meter query.
     * @example {
     *   "from": "2023-01-01T00:00:00Z",
     *   "to": "2023-01-02T00:00:00Z",
     *   "windowSize": "MINUTE",
     *   "data": [
     *     {
     *       "value": 12,
     *       "windowStart": "2023-01-01T00:00:00Z",
     *       "windowEnd": "2023-01-02T00:00:00Z",
     *       "subject": "customer-id",
     *       "groupBy": {
     *         "model": "gpt-4-turbo",
     *         "type": "prompt"
     *       }
     *     }
     *   ]
     * }
     */
    MeterQueryResult: {
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      from?: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      to?: string
      windowSize?: components['schemas']['WindowSize']
      /**
       * @example [
       *   {
       *     "value": 12,
       *     "windowStart": "2023-01-01T00:00:00Z",
       *     "windowEnd": "2023-01-02T00:00:00Z",
       *     "subject": "customer-id",
       *     "groupBy": {
       *       "model": "gpt-4-turbo",
       *       "type": "prompt"
       *     }
       *   }
       * ]
       */
      data: components['schemas']['MeterQueryRow'][]
    }
    /**
     * @description A row in the result of a meter query.
     * @example {
     *   "value": 12,
     *   "windowStart": "2023-01-01T00:00:00Z",
     *   "windowEnd": "2023-01-02T00:00:00Z",
     *   "subject": "customer-id",
     *   "groupBy": {
     *     "model": "gpt-4-turbo",
     *     "type": "prompt"
     *   }
     * }
     */
    MeterQueryRow: {
      /** @example 12 */
      value: number
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      windowStart: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      windowEnd: string
      /**
       * @description The subject of the meter value.
       * @example customer-id
       */
      subject?: string | null
      /**
       * @example {
       *   "model": "gpt-4-turbo",
       *   "type": "prompt"
       * }
       */
      groupBy?: {
        [key: string]: string
      } | null
    }
    /**
     * @description A consumer portal token.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "subject": "customer-id",
     *   "expiresAt": "2023-01-02T00:00:00Z",
     *   "expired": false,
     *   "createdAt": "2023-01-01T00:00:00Z",
     *   "token": "om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo",
     *   "allowedMeterSlugs": [
     *     "tokens_total"
     *   ]
     * }
     */
    PortalToken: {
      /** @example 01G65Z755AFWAKHE12NY0CQ9FH */
      id?: string
      /** @example customer-id */
      subject: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      expiresAt?: string
      expired?: boolean
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      createdAt?: string
      /**
       * @description The token is only returned at creation.
       * @example om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo
       */
      token?: string
      /**
       * @description Optional, if defined only the specified meters will be allowed
       * @example [
       *   "tokens_total"
       * ]
       */
      allowedMeterSlugs?: string[]
    }
    /**
     * @description A subject is a unique identifier for a user or entity.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "key": "customer-id",
     *   "displayName": "Customer Name",
     *   "metadata": {
     *     "hubspotId": "123456"
     *   },
     *   "currentPeriodStart": "2023-01-01T00:00:00Z",
     *   "currentPeriodEnd": "2023-02-01T00:00:00Z",
     *   "stripeCustomerId": "cus_JMOlctsKV8"
     * }
     */
    Subject: {
      /** @example 01G65Z755AFWAKHE12NY0CQ9FH */
      id: string
      /** @example customer-id */
      key: string
      /** @example Customer Name */
      displayName?: string | null
      /**
       * @example {
       *   "hubspotId": "123456"
       * }
       */
      metadata?: {
        [key: string]: unknown
      } | null
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      currentPeriodStart?: string | null
      /**
       * Format: date-time
       * @example 2023-02-01T00:00:00Z
       */
      currentPeriodEnd?: string | null
      /** @example cus_JMOlctsKV8 */
      stripeCustomerId?: string | null
    }
    /**
     * @description A unique identifier.
     * @example tokens_total
     */
    IdOrSlug: string
    NotificationChannelCreateRequest: components['schemas']['NotificationChannelWebhookCreateRequest']
    NotificationChannel: components['schemas']['NotificationChannelWebhook']
    /** @description List of channels. */
    NotificationChannels: components['schemas']['NotificationChannel'][]
    NotificationChannelsResponse: components['schemas']['PaginationInfo'] & {
      items: components['schemas']['NotificationChannels']
    }
    NotificationChannelWebhookCreateRequest: components['schemas']['NotificationChannelCommonCreateRequest'] & {
      /**
       * @description Webhook URL where the notification is sent.
       * @example https://example.com/webhook
       */
      url: string
      /**
       * @description Custom HTTP headers sent as part of the webhook request.
       * @example {
       *   "X-CUSTOM-HEADER": "value"
       * }
       */
      customHeaders?: {
        [key: string]: unknown
      } | null
      /**
       * @description Signing secret used for webhook request validation on the receiving end. Automatically generated if not provided.
       *
       * Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
       *
       * @example whsec_S6g2HLnTwd9AhHwUIMFggVS9OfoPafN8
       */
      signingSecret?: string | null
    }
    /** @description Notification channel with webhook type. */
    NotificationChannelWebhook: components['schemas']['NotificationChannelCommon'] & {
      /**
       * @description Webhook URL where the notification is sent.
       * @example https://example.com/webhook
       */
      url: string
      /**
       * @description Custom HTTP headers sent as part of the webhook request.
       * @example {
       *   "X-CUSTOM-HEADER": "value"
       * }
       */
      customHeaders?: {
        [key: string]: unknown
      } | null
      /**
       * @description Signing secret used for webhook request validation on the receiving end.
       *
       * Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
       *
       * @example whsec_S6g2HLnTwd9AhHwUIMFggVS9OfoPafN8
       */
      signingSecret: string
    }
    /**
     * @description The type of the notification channel.
     * @example WEBHOOK
     * @enum {string}
     */
    NotificationChannelType: 'WEBHOOK'
    /** @description Common fields for create notification channel request. */
    NotificationChannelCommonCreateRequest: {
      /**
       * @description User friendly name of the channel.
       * @example customer-webhook
       */
      name: string
      /**
       * @description Whether the channel is disabled or not.
       * @default false
       * @example false
       */
      disabled?: boolean
      type: components['schemas']['NotificationChannelType']
    }
    /** @description Limited representation of notification channel which includes only the channel identifier and its type. */
    NotificationChannelMeta: {
      /**
       * @description A unique identifier for the notification channel.
       * @example 01J2KNP1YTXQRXHTDJ4KPR7PZ0
       */
      id: string
      type: components['schemas']['NotificationChannelType']
    }
    /** @description Common fields for notification channel resources. */
    NotificationChannelCommon: components['schemas']['NotificationChannelMeta'] & {
      /**
       * @description User friendly name of the channel.
       * @example customer-webhook
       */
      name: string
      /**
       * Format: date-time
       * @description Timestamp when the channel was created.
       * @example 2023-01-01T00:00:00Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description Timestamp when the channel was modified.
       * @example 2023-01-02T00:00:00Z
       */
      updatedAt: string
      /**
       * Format: date-time
       * @description Timestamp when the channel was deleted.
       * @example 2023-01-02T00:00:00Z
       */
      deletedAt?: string
      /**
       * @description Whether the channel is disabled or not.
       * @default false
       * @example false
       */
      disabled: boolean
    }
    NotificationRuleCreateRequest: components['schemas']['NotificationRuleBalanceThresholdCreateRequest']
    NotificationRule: components['schemas']['NotificationRuleBalanceThreshold']
    /** @description List of rules. */
    NotificationRules: components['schemas']['NotificationRule'][]
    NotificationRulesResponse: components['schemas']['PaginationInfo'] & {
      items: components['schemas']['NotificationRules']
    }
    /**
     * @description Request for creating new notification rule for triggering notification events base on conditions
     * applied to current balance of entitlements.
     */
    NotificationRuleBalanceThresholdCreateRequest: components['schemas']['NotificationRuleCommonCreateRequest'] & {
      /**
       * @description List of thresholds the rule suppose to be triggered.
       * @example [
       *   {
       *     "value": 100,
       *     "type": "PERCENT"
       *   },
       *   {
       *     "value": 10000,
       *     "type": "NUMBER"
       *   }
       * ]
       */
      thresholds: components['schemas']['NotificationRuleBalanceThresholdValue'][]
      /**
       * @description Optional field for defining the scope of notification by feature. It may contain features by id or key.
       *
       * @example [
       *   "gpt4_tokens",
       *   "01ARZ3NDEKTSV4RRFFQ69G5FAV"
       * ]
       */
      features?: string[] | null
    }
    /** @description Threshold value with multiple supported types. */
    NotificationRuleBalanceThresholdValue: {
      /** Format: double */
      value: number
      /** @enum {string} */
      type: 'NUMBER' | 'PERCENT'
    }
    /** @description Notification rule for triggering notification events by applying conditions to current balance of entitlements. */
    NotificationRuleBalanceThreshold: components['schemas']['NotificationRuleCommon'] & {
      /**
       * @description List of thresholds the rule suppose to be triggered.
       * @example [
       *   {
       *     "value": 100,
       *     "type": "PERCENT"
       *   },
       *   {
       *     "value": 10000,
       *     "type": "NUMBER"
       *   }
       * ]
       */
      thresholds: components['schemas']['NotificationRuleBalanceThresholdValue'][]
      /** @description Optional field containing list of features the rule applies to. */
      features?: components['schemas']['FeatureMeta'][] | null
    }
    /**
     * @description The type of the notification event.
     * @example entitlements.balance.threshold
     * @enum {string}
     */
    NotificationEventType: 'entitlements.balance.threshold'
    /** @description Defines the common fields for create notification rule request. */
    NotificationRuleCommonCreateRequest: {
      type: components['schemas']['NotificationEventType']
      /**
       * @description The user friendly name of the notification rule.
       * @example Balance threshold reached
       */
      name: string
      /**
       * @description List of notification channel identifiers or names the rule applies to.
       * @example [
       *   "01G65Z755AFWAKHE12NY0CQ9FH"
       * ]
       */
      channels: string[]
      /**
       * @description Whether the rule is disabled or not.
       * @default false
       * @example false
       */
      disabled?: boolean
    }
    /** @description Defines the common fields of a notification rule. */
    NotificationRuleMeta: {
      /**
       * @description A unique identifier for the notification rule.
       * @example 01J2KNP1YTXQRXHTDJ4KPR7PZ0
       */
      id: string
      type: components['schemas']['NotificationEventType']
    }
    /** @description Common fields for notification rules. */
    NotificationRuleCommon: components['schemas']['NotificationRuleMeta'] & {
      /**
       * @description The user friendly name of the notification rule.
       * @example Balance threshold reached
       */
      name: string
      /** @description List of notification channels the rule applies to. */
      channels: components['schemas']['NotificationChannelMeta'][]
      /**
       * Format: date-time
       * @description Timestamp when the rule was created.
       * @example 2023-01-01T00:00:00Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description Timestamp when the rule was modified.
       * @example 2023-01-02T00:00:00Z
       */
      updatedAt: string
      /**
       * Format: date-time
       * @description Timestamp when the channel was deleted.
       * @example 2023-01-02T00:00:00Z
       */
      deletedAt?: string
      /**
       * @description Whether the rule is disabled or not.
       * @default false
       * @example false
       */
      disabled: boolean
    }
    /** @description Request for creating new notification event with specific type and payload. */
    NotificationEventCreateRequest: {
      type: components['schemas']['NotificationEventType']
      payload: components['schemas']['NotificationEventPayload']
      /** @example 01J2KNP1YTXQRXHTDJ4KPR7PZ0 */
      ruleId: string
    }
    /**
     * @description Notification event generated by the system based on the criteria defined in the corresponding
     * a notification rule.
     *
     * The `payload` field contains the actual message sent to the notification channel.
     */
    NotificationEvent: {
      /**
       * @description A unique identifier for the notification event.
       * @example 01J2KNP1YTXQRXHTDJ4KPR7PZ0
       */
      id: string
      type: components['schemas']['NotificationEventType']
      /**
       * Format: date-time
       * @description Timestamp when the notification event was created.
       * @example 2023-01-01T00:00:00Z
       */
      createdAt: string
      rule: components['schemas']['NotificationRule']
      /** @description The delivery status of the notification event. */
      deliveryStatus: components['schemas']['NotificationEventDeliveryStatus'][]
      payload: components['schemas']['NotificationEventPayload']
      /**
       * @description List of annotations managed by the system.
       *
       * @example {
       *   "test-event": "true"
       * }
       */
      annotations?: {
        [key: string]: unknown
      }
    }
    /** @description The actual payload sent to channel as part of the notification event. */
    NotificationEventPayload: components['schemas']['NotificationEventBalanceThresholdPayload']
    /** @description Common fields for notification event payload. */
    NotificationEventCommonPayload: {
      /**
       * @description A unique identifier for the notification event the payload belongs to.
       * @example 01J2KNP1YTXQRXHTDJ4KPR7PZ0
       */
      id: string
      type: components['schemas']['NotificationEventType']
      /**
       * Format: date-time
       * @description Timestamp when the notification event was created.
       * @example 2023-01-01T00:00:00Z
       */
      timestamp: string
    }
    /**
     * @description Defines payload for notification event which is triggered when the `balance` of the `entitlement`
     * surpass the user defined `threshold`.
     */
    NotificationEventBalanceThresholdPayload: components['schemas']['NotificationEventCommonPayload'] & {
      data: {
        entitlement: components['schemas']['EntitlementMetered']
        feature: components['schemas']['Feature']
        subject: components['schemas']['Subject']
        value: components['schemas']['EntitlementValue']
        threshold: components['schemas']['NotificationRuleBalanceThresholdValue']
      }
    }
    NotificationEventDeliveryStatus: {
      channel: components['schemas']['NotificationChannelMeta']
      /** @enum {string} */
      state: 'SUCCESS' | 'FAILED' | 'SENDING' | 'PENDING'
      /** @example Failed to dispatch event */
      reason?: string
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      updatedAt: string
    }
    /** @description List of notification events. */
    NotificationEvents: components['schemas']['NotificationEvent'][]
    NotificationEventsResponse: components['schemas']['PaginationInfo'] & {
      items: components['schemas']['NotificationEvents']
    }
    SvixOperationalWebhookRequest: {
      /** @enum {string} */
      type:
        | 'endpoint.created'
        | 'endpoint.deleted'
        | 'endpoint.disabled'
        | 'endpoint.updated'
        | 'message.attempt.exhausted'
        | 'message.attempt.failing'
        | 'message.attempt.recovered'
      data: {
        [key: string]: unknown
      }
    }
    /** @description Pagination information. */
    PaginationInfo: {
      /**
       * @description Total number of items.
       * @example 500
       */
      totalCount: number
      /**
       * @description Current page number.
       * @example 1
       */
      page: number
      /**
       * @description Number of items per page.
       * @example 100
       */
      pageSize: number
    }
    /**
     * @description A payment provider.
     * @enum {string}
     */
    PaymentProvider: 'openmeter_sandbox' | 'stripe_payments'
    /** @description Represents common fields of resources. */
    Resource: {
      /**
       * Key
       * @description A semi-unique identifier for the resource.
       */
      key: components['schemas']['Key']
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * @description Timestamp of when the resource was created.
       */
      createdAt?: components['schemas']['DateTime']
      /**
       * Last Update Time
       * @description Timestamp of when the resource was last updated.
       */
      updatedAt?: components['schemas']['DateTime']
      /**
       * Deletion Time
       * @description Timestamp of when the resource was permanently deleted.
       */
      deletedAt?: components['schemas']['DateTime']
      /**
       * Archival Time
       * @description Timestamp of when the resource was archived.
       */
      archivedAt?: components['schemas']['DateTime']
    }
    /**
     * @description A tax provider.
     * @enum {string}
     */
    TaxProvider: 'openmeter_sandbox' | 'stripe_tax'
    /** @description A key is a unique string that is used to identify a resource. */
    Key: string
    /**
     * @description ULID (Universally Unique Lexicographically Sortable Identifier).
     * @example 01G65Z755AFWAKHE12NY0CQ9FH
     */
    ULID: string
  }
  responses: {
    /** @description Conflict */
    ConflictProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['ConflictProblem']
      }
    }
    /** @description Bad Request */
    BadRequestProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Unauthorized */
    UnauthorizedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Not Found */
    NotFoundProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Not Implemented */
    NotImplementedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Unexpected error */
    UnexpectedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
  }
  parameters: {
    /** @description The page number. */
    'PaginatedQuery.page'?: number
    /** @description The number of items in the page. */
    'PaginatedQuery.pageSize'?: number
    /** @description Include deleted customers. */
    queryCustomerList?: boolean
    /** @description A unique identifier for the meter. */
    meterIdOrSlug: components['schemas']['IdOrSlug']
    /** @description A unique identifier for a subject. */
    subjectIdOrKey: string
    /** @description A unique ULID identifier for a feature. */
    featureId: string
    /** @description A unique identifier for a grant. */
    grantId: string
    /** @description A unique ULID for an entitlement. */
    entitlementId: string
    /** @description The id of the entitlement or the key of the feature. */
    entitlementIdOrFeatureKey: string
    /** @description Include deleted entries. */
    includeDeleted?: boolean
    /** @description Page number to return */
    queryPage?: number
    /** @description Number of entries to return per page */
    queryPageSize?: number
    /** @description Number of entries to return */
    queryLimit?: number
    /** @description Number of entries to skip */
    queryOffset?: number
    /**
     * @description Start date-time in RFC 3339 format.
     * Inclusive.
     */
    queryFrom?: string
    /**
     * @description End date-time in RFC 3339 format.
     * Inclusive.
     */
    queryTo?: string
    /** @description If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group. */
    queryWindowSize?: components['schemas']['WindowSize']
    /**
     * @description The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
     * If not specified, the UTC timezone will be used.
     */
    queryWindowTimeZone?: string
    /**
     * @description Filtering by multiple subjects.
     *
     * Usage: `?subject=customer-1&subject=customer-2`
     */
    queryFilterSubject?: string[]
    /**
     * @description Filtering by multiple features.
     *
     * Usage: `?feature=feature-1&feature=feature-2`
     */
    queryFilterFeature?: string[]
    /**
     * @description Filtering by multiple meterSlug.
     *
     * Usage: `?meterSlug=meter-1&meterSlug=meter-2`
     */
    queryFilterMeterSlug?: string[]
    /**
     * @description Filtering by multiple entitlement types.
     *
     * Usage: `?entitlementType=metered&entitlementType=static`
     */
    queryFilterEntitlementType?: string[]
    /**
     * @description Filtering by multiple notification channels.
     *
     * Usage: `?channel=channel-1&channel=channel-2`
     */
    queryFilterChannel?: string[]
    queryFilterGroupBy?: {
      [key: string]: string
    }
    /**
     * @description If not specified a single aggregate will be returned for each subject and time window.
     * `subject` is a reserved group by value.
     */
    queryGroupBy?: string[]
    /** @description A unique ULID identifier for a notification channel. */
    channelId: string
    /** @description A unique ULID identifier for a notification rule. */
    ruleId: string
    /** @description A unique ULID identifier for a notification event. */
    eventId: string
    /** @description Include disabled entries. */
    queryIncludeDisabled?: boolean
    /**
     * @description Order by field.
     *
     * Usage: `?order=ASC`
     */
    order?: 'ASC' | 'DESC'
  }
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /** @description List customers. */
  listCustomers: {
    parameters: {
      query?: {
        includeDeleted?: components['parameters']['queryCustomerList']
        page?: components['parameters']['PaginatedQuery.page']
        pageSize?: components['parameters']['PaginatedQuery.pageSize']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['CustomerList'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /** @description Create a new customer. */
  createCustomer: {
    requestBody: {
      content: {
        'application/json': components['schemas']['Customer']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /** @description Get a customer by ID or key. */
  getCustomer: {
    parameters: {
      path: {
        customerIdOrKey: components['schemas']['CustomerIdentifier']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /** @description Update a customer by ID or key. */
  updateCustomer: {
    parameters: {
      path: {
        customerIdOrKey: components['schemas']['CustomerIdentifier']
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['Customer']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /** @description Delete a customer by ID or key. */
  deleteCustomer: {
    parameters: {
      path: {
        customerIdOrKey: components['schemas']['CustomerIdentifier']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List ingested events
   * @description List ingested events within a time range.
   * If the from query param is not provided it defaults to last 72 hours.
   */
  listEvents: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        /**
         * @description Start date-time in RFC 3339 format.
         * Inclusive.
         */
        ingestedAtFrom?: string
        /**
         * @description End date-time in RFC 3339 format.
         * Inclusive.
         */
        ingestedAtTo?: string
        /**
         * @description If not provided lists all events.
         * If provided with true, only list events with processing error.
         * If provided with false, only list events without processing error.
         */
        hasError?: boolean
        /**
         * @description The event ID.
         * Accepts partial ID.
         */
        id?: string
        /** @description The event subject. Full match. */
        subject?: string
        /** @description Number of events to return */
        limit?: number
      }
    }
    responses: {
      /** @description List of events for debugging. */
      200: {
        content: {
          'application/json': components['schemas']['IngestedEvent'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Ingest events
   * @description Ingests an event or batch of events following the CloudEvents specification.
   */
  ingestEvents: {
    /**
     * @description The event or batch of events to ingest.
     * The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
     * The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
     */
    requestBody: {
      content: {
        'application/cloudevents+json': components['schemas']['Event']
        'application/cloudevents-batch+json': components['schemas']['Event'][]
      }
    }
    responses: {
      /** @description Successfully ingested. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List meters
   * @description List meters.
   */
  listMeters: {
    responses: {
      /** @description List of meters. */
      200: {
        content: {
          'application/json': components['schemas']['Meter'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Create meter
   * @description *Available in OpenMeter Cloud.*
   * *In the open-source version, meters are created in the configuration file.*
   *
   * Create a meter.
   */
  createMeter: {
    /** @description The meter to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['Meter']
      }
    }
    responses: {
      /** @description Created. */
      201: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get meter
   * @description Get meter by ID or slug
   */
  getMeter: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Meter found. */
      200: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Delete meter
   * @description *Available in OpenMeter Cloud.*
   *
   * Delete a meter by ID or slug.
   */
  deleteMeter: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Meter deleted. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Query meter
   * @description Query meter for usage.
   */
  queryMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        windowSize?: components['parameters']['queryWindowSize']
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
        subject?: components['parameters']['queryFilterSubject']
        filterGroupBy?: components['parameters']['queryFilterGroupBy']
        groupBy?: components['parameters']['queryGroupBy']
      }
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Usage data. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List meter subjects
   * @description List subjects for a meter.
   */
  listMeterSubjects: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description List of subjects. */
      200: {
        content: {
          'application/json': string[]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ List portal tokens
   * @description *Available in OpenMeter Cloud.*
   *
   * List consumer portal tokens.
   */
  listPortalTokens: {
    parameters: {
      query?: {
        /** @description Number of portal tokens to return. Default is 25. */
        limit?: number
      }
    }
    responses: {
      /** @description List of portal tokens. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create portal token
   * @description Create a consumer portal token.
   */
  createPortalToken: {
    /** @description The portal token to create. */
    requestBody: {
      content: {
        /**
         * @example {
         *   "subject": "customer-id",
         *   "allowedMeterSlugs": [
         *     "tokens_total"
         *   ]
         * }
         */
        'application/json': components['schemas']['PortalToken']
      }
    }
    responses: {
      /** @description Created. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Invalidate portal tokens
   * @description *Available in OpenMeter Cloud.*
   *
   * Invalidates consumer portal tokens by ID or subject.
   */
  invalidatePortalTokens: {
    /** @description If no id or subject is specified, all tokens will be invalidated. */
    requestBody: {
      content: {
        'application/json': {
          /** @description Invalidate a portal token by ID. */
          id?: string
          /** @description Invalidate all portal tokens for a subject. */
          subject?: string
        }
      }
    }
    responses: {
      /** @description Portal tokens invalidated. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ List subjects
   * @description *Available in OpenMeter Cloud.*
   *
   * List subjects.
   */
  listSubjects: {
    responses: {
      /** @description List of subjects. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Upsert subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Upserts a subject. Creates or updates subject.
   * If the subject doesn't exist, it will be created.
   * If the subject exists, it will be partially updated with the provided fields.
   */
  upsertSubject: {
    /** @description The subject to upsert. */
    requestBody: {
      content: {
        'application/json': components['schemas']['Subject'][]
      }
    }
    responses: {
      /** @description Subject upserted. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Get subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Get subject by ID or key.
   */
  getSubject: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description Subject found. */
      200: {
        content: {
          'application/json': components['schemas']['Subject']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Delete subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Delete a subject by ID or key.
   */
  deleteSubject: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description Subject deleted. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Query portal meter
   * @description Query meter for consumer portal. This endpoint is publicly exposable to consumers.
   */
  queryPortalMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        windowSize?: components['parameters']['queryWindowSize']
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
        filterGroupBy?: components['parameters']['queryFilterGroupBy']
        groupBy?: components['parameters']['queryGroupBy']
      }
      path: {
        /** @description A unique identifier for the meter. */
        meterSlug: string
      }
    }
    responses: {
      /** @description Usage data. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List entitlements
   * @description List all entitlements regardless of subject. This endpoint is intended for administrative purposes.
   * If page is provided that takes precedence and the paginated response is returned.
   */
  listEntitlements: {
    parameters: {
      query?: {
        page?: components['parameters']['queryPage']
        pageSize?: components['parameters']['queryPageSize']
        limit?: components['parameters']['queryLimit']
        offset?: components['parameters']['queryOffset']
        subject?: components['parameters']['queryFilterSubject']
        feature?: components['parameters']['queryFilterFeature']
        entitlementType?: components['parameters']['queryFilterEntitlementType']
        order?: components['parameters']['order']
        /** @description Order by field */
        orderBy?: 'createdAt' | 'updatedAt'
      }
    }
    responses: {
      /** @description List of entitlements. If page is provided that takes precedence and the paginated response is returned. */
      200: {
        content: {
          'application/json': components['schemas']['ListEntitlementResponse']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get an entitlement
   * @description Get entitlement by id.
   */
  getEntitlementById: {
    parameters: {
      path: {
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description Entitlement found. */
      200: {
        content: {
          'application/json': {
            type: 'json'
          } & Omit<components['schemas']['Entitlement'], 'type'> & {
              /**
               * Format: date-time
               * @description The last time usage was reset.
               * @example 2023-01-01T00:00:00Z
               */
              lastReset?: string
            }
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List features
   * @description List all features. If page is provided that takes precedence and the paginated response is returned.
   */
  listFeatures: {
    parameters: {
      query?: {
        page?: components['parameters']['queryPage']
        pageSize?: components['parameters']['queryPageSize']
        limit?: components['parameters']['queryLimit']
        offset?: components['parameters']['queryOffset']
        meterSlug?: components['parameters']['queryFilterMeterSlug']
        order?: components['parameters']['order']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt' | 'updatedAt'
        /** @description Include archived features. */
        includeArchived?: boolean
      }
    }
    responses: {
      /** @description List of features. If page is provided that takes precedence and the paginated response is returned. */
      200: {
        content: {
          'application/json': components['schemas']['ListFeatureResponse']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create a feature
   * @description Features are either metered or static. A feature is metered if meterSlug is provided at creation.
   * For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter's groupBy fields. Only meters with SUM and COUNT aggregation are supported for features.
   *
   * Features cannot be updated later, only archived.
   */
  createFeature: {
    /** @description The feature to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['FeatureCreateInputs']
      }
    }
    responses: {
      /** @description Feature created. */
      201: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get feature
   * @description Get a feature by id.
   */
  getFeature: {
    parameters: {
      path: {
        featureId: components['parameters']['featureId']
      }
    }
    responses: {
      /** @description Feature found. */
      200: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Archive a feature
   * @description Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements. This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis.
   */
  deleteFeature: {
    parameters: {
      path: {
        featureId: components['parameters']['featureId']
      }
    }
    responses: {
      /** @description Feature deleted. */
      204: {
        content: never
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List grants
   * @description List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only. To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.
   *
   * If page is provided that takes precedence and the paginated response is returned.
   */
  listGrants: {
    parameters: {
      query?: {
        page?: components['parameters']['queryPage']
        pageSize?: components['parameters']['queryPageSize']
        limit?: components['parameters']['queryLimit']
        offset?: components['parameters']['queryOffset']
        subject?: components['parameters']['queryFilterSubject']
        feature?: components['parameters']['queryFilterFeature']
        order?: components['parameters']['order']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt' | 'updatedAt'
        includeDeleted?: components['parameters']['includeDeleted']
      }
    }
    responses: {
      /** @description List of grants. If page is provided that takes precedence and the paginated response is returned. */
      200: {
        content: {
          'application/json': components['schemas']['ListEntitlementGrantResponse']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Void a grant
   * @description Voiding a grant means it is no longer valid, it doesn't take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.
   *
   * For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected.
   */
  voidGrant: {
    parameters: {
      path: {
        grantId: components['parameters']['grantId']
      }
    }
    responses: {
      /** @description Grant has been voided. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      409: components['responses']['ConflictProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List entitlements of a subject
   * @description List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead.
   */
  listSubjectEntitlements: {
    parameters: {
      query?: {
        includeDeleted?: components['parameters']['includeDeleted']
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description List of entitlements. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create an entitlement
   * @description OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).
   *
   * - Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
   * - Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
   * - Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.
   *
   * A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.
   *
   * Once an entitlement is created you cannot modify it, only delete it.
   */
  createEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    /** @description The entitlement to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementCreateInputs']
      }
    }
    responses: {
      /** @description Entitlement created. */
      201: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      409: components['responses']['ConflictProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get an entitlement
   * @description Get entitlement by id. For checking entitlement access, use the /value endpoint instead.
   */
  getEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description Entitlement found. */
      200: {
        content: {
          'application/json': {
            type: 'json'
          } & Omit<components['schemas']['Entitlement'], 'type'> & {
              /**
               * Format: date-time
               * @description The last time usage was reset.
               * @example 2023-01-01T00:00:00Z
               */
              lastReset?: string
            }
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Delete an entitlement
   * @description Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
   * As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.
   */
  deleteEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description Entitlement deleted. */
      204: {
        content: never
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Override an entitlement
   * @description Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided subject-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.
   *
   * This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime.
   */
  overrideEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementIdOrFeatureKey: components['parameters']['entitlementIdOrFeatureKey']
      }
    }
    /** @description The entitlement to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementCreateInputs']
      }
    }
    responses: {
      /** @description Entitlement created. */
      201: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      409: components['responses']['ConflictProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List grants for an entitlement
   * @description List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey.
   */
  listEntitlementGrants: {
    parameters: {
      query?: {
        includeDeleted?: components['parameters']['includeDeleted']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt' | 'updatedAt'
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementIdOrFeatureKey: components['parameters']['entitlementIdOrFeatureKey']
      }
    }
    responses: {
      /** @description List of grants. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementGrant'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create a grant
   * @description Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.
   *
   * A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.
   *
   * Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.
   *
   * Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).
   *
   * Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
   *
   * Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.
   */
  createGrant: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementIdOrFeatureKey: components['parameters']['entitlementIdOrFeatureKey']
      }
    }
    /** @description The grant to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementGrantCreateInput']
      }
    }
    responses: {
      /** @description Grant created. */
      201: {
        content: {
          'application/json': components['schemas']['EntitlementGrant']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get the current value and access of an entitlement
   * @description This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
   *
   * For convenience reasons, /value works with both entitlementId and featureKey.
   */
  getEntitlementValue: {
    parameters: {
      query?: {
        /** @description Point of time to check value: date-time in RFC 3339 format. Defaults to now. */
        time?: string
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementIdOrFeatureKey: components['parameters']['entitlementIdOrFeatureKey']
      }
    }
    responses: {
      /** @description The entitlement value. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementValue']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get the balance history of a specific entitlement.
   * @description Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.
   *
   * BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.
   *
   * WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.
   */
  getEntitlementHistory: {
    parameters: {
      query: {
        /**
         * @description Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to
         * the last reset.
         * Gets truncated to the granularity of the underlying meter.
         */
        from?: string
        /**
         * @description End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.
         * If not now then gets truncated to the granularity of the underlying meter.
         */
        to?: string
        /** @description Size of the time window to group the history by. Cannot be shorter than meter granularity. */
        windowSize: 'MINUTE' | 'HOUR' | 'DAY'
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description The history response. */
      200: {
        content: {
          'application/json': components['schemas']['WindowedBalanceHistory']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Reset an entitlement
   * @description Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.
   *
   * Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.
   */
  resetEntitlementUsage: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * Format: date-time
           * @description The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.
           *
           * @example 2023-01-01T00:00:00Z
           */
          effectiveAt?: string
          /**
           * @description Determines whether the usage period anchor is retained or reset to the effectiveAt time.
           * - If true, the usage period anchor is retained.
           * - If false, the usage period anchor is reset to the effectiveAt time.
           */
          retainAnchor?: boolean
          /**
           * @description Determines whether the overage is preserved or forgiven, overriding the entitlement's default behavior.
           * - If true, the overage is preserved.
           * - If false, the overage is forgiven.
           */
          preserveOverage?: boolean
        }
      }
    }
    responses: {
      /** @description Entitlement reset. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get event metrics
   * @description Returns debug metrics like the number of ingested events since mindnight UTC.
   * The OpenMetrics Counter(s) reset every day at midnight UTC.
   */
  getDebugMetrics: {
    responses: {
      /** @description Dbeug metrics, like number of ingested events. */
      200: {
        content: {
          'text/plain': string
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List notification channels
   * @description List all notification channels.
   */
  listNotificationChannels: {
    parameters: {
      query?: {
        page?: components['parameters']['queryPage']
        pageSize?: components['parameters']['queryPageSize']
        /** @description Order by field */
        orderBy?: 'id' | 'type' | 'createdAt' | 'updatedAt'
        order?: components['parameters']['order']
        includeDisabled?: components['parameters']['queryIncludeDisabled']
        includeDeleted?: components['parameters']['includeDeleted']
      }
    }
    responses: {
      /** @description List of notification channels. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationChannelsResponse']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create a notification channel
   * @description Create a new notification channel.
   */
  createNotificationChannel: {
    /** @description The notification channel to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationChannelCreateRequest']
      }
    }
    responses: {
      /** @description Notification channel created. */
      201: {
        content: {
          'application/json': components['schemas']['NotificationChannel']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      409: components['responses']['ConflictProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get notification channel
   * @description Get a notification channel by id.
   */
  getNotificationChannel: {
    parameters: {
      path: {
        channelId: components['parameters']['channelId']
      }
    }
    responses: {
      /** @description Notification channel found. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationChannel']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Update notification channel
   * @description Update a notification channel by id.
   */
  updateNotificationChannel: {
    parameters: {
      path: {
        channelId: components['parameters']['channelId']
      }
    }
    /** @description The notification channel to update. */
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationChannelCreateRequest']
      }
    }
    responses: {
      /** @description Notification channel updated. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationChannel']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Delete a notification channel
   * @description Delete notification channel by id.
   */
  deleteNotificationChannel: {
    parameters: {
      path: {
        channelId: components['parameters']['channelId']
      }
    }
    responses: {
      /** @description Notification channel deleted. */
      204: {
        content: never
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List notification rules
   * @description List all notification rules.
   */
  listNotificationRules: {
    parameters: {
      query?: {
        page?: components['parameters']['queryPage']
        pageSize?: components['parameters']['queryPageSize']
        /** @description Order by field */
        orderBy?: 'id' | 'type' | 'createdAt' | 'updatedAt'
        order?: components['parameters']['order']
        includeDisabled?: components['parameters']['queryIncludeDisabled']
        includeDeleted?: components['parameters']['includeDeleted']
        feature?: components['parameters']['queryFilterFeature']
        channel?: components['parameters']['queryFilterChannel']
      }
    }
    responses: {
      /** @description List of notification rules. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRulesResponse']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create a notification rule
   * @description Create a new notification rule.
   */
  createNotificationRule: {
    /** @description The notification rule to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationRuleCreateRequest']
      }
    }
    responses: {
      /** @description Notification rule created. */
      201: {
        content: {
          'application/json': components['schemas']['NotificationRule']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      409: components['responses']['ConflictProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get notification rule
   * @description Get a notification rule by id.
   */
  getNotificationRule: {
    parameters: {
      path: {
        ruleId: components['parameters']['ruleId']
      }
    }
    responses: {
      /** @description Rule found. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRule']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Update a notification rule
   * @description Update a notification rule by id.
   */
  updateNotificationRule: {
    parameters: {
      path: {
        ruleId: components['parameters']['ruleId']
      }
    }
    /** @description The notification rule to update. */
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationRuleCreateRequest']
      }
    }
    responses: {
      /** @description Notification Rule updated. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRule']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Delete a notification rule
   * @description Delete notification rule by id.
   */
  deleteNotificationRule: {
    parameters: {
      path: {
        ruleId: components['parameters']['ruleId']
      }
    }
    responses: {
      /** @description Notification rule deleted. */
      204: {
        content: never
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Test notification rule
   * @description Test a notification rule by sending a test event with random data.
   */
  testNotificationRule: {
    parameters: {
      path: {
        ruleId: components['parameters']['ruleId']
      }
    }
    responses: {
      /** @description Test notification event sent. */
      201: {
        content: {
          'application/json': components['schemas']['NotificationEvent']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      409: components['responses']['ConflictProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List notification evens
   * @description List all notification events.
   */
  listNotificationEvents: {
    parameters: {
      query?: {
        page?: components['parameters']['queryPage']
        pageSize?: components['parameters']['queryPageSize']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt'
        order?: components['parameters']['order']
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        feature?: components['parameters']['queryFilterFeature']
        subject?: components['parameters']['queryFilterSubject']
        /**
         * @description Filtering by multiple rules.
         *
         * Usage: `?rule=ID1&rule=rule=ID2`
         */
        rule?: string[]
        /**
         * @description Filtering by multiple channels.
         *
         * Usage: `?channel=ID1&channel=ID2`
         */
        channel?: string[]
      }
    }
    responses: {
      /** @description List of notification events. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationEventsResponse']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get notification event
   * @description Get a notification event by id.
   */
  getNotificationEvent: {
    parameters: {
      path: {
        eventId: components['parameters']['eventId']
      }
    }
    responses: {
      /** @description Notification event found. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationEvent']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Receive Svix operational events
   * @description Callback endpoint used by Svix to notify about operational events
   */
  receiveSvixOperationalEvent: {
    /** @description The operational event. */
    requestBody: {
      content: {
        'application/json': components['schemas']['SvixOperationalWebhookRequest']
      }
    }
    responses: {
      /** @description Operational webhook request accepted */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
}
