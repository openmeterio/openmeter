/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/events': {
    /**
     * List ingested events
     * @description List ingested events within a time range.
     */
    get: operations['listEvents']
    /**
     * Ingest events
     * @description Ingests an event or batch of events following the CloudEvents specification.
     */
    post: operations['ingestEvents']
  }
  '/api/v1/meters': {
    /**
     * List meters
     * @description List meters.
     */
    get: operations['listMeters']
    /**
     * ☁ Create meter
     * @description *Available in OpenMeter Cloud.*
     * *In the open-source version, meters are created in the configuration file.*
     *
     * Create a meter.
     */
    post: operations['createMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}': {
    /**
     * Get meter
     * @description Get meter by ID or slug
     */
    get: operations['getMeter']
    /**
     * ☁ Delete meter
     * @description *Available in OpenMeter Cloud.*
     *
     * Delete a meter by ID or slug.
     */
    delete: operations['deleteMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/query': {
    /**
     * Query meter
     * @description Query meter for usage.
     */
    get: operations['queryMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/subjects': {
    /**
     * List meter subjects
     * @description List subjects for a meter.
     */
    get: operations['listMeterSubjects']
  }
  '/api/v1/portal/tokens': {
    /**
     * ☁ List portal tokens
     * @description *Available in OpenMeter Cloud.*
     *
     * List consumer portal tokens.
     */
    get: operations['listPortalTokens']
    /**
     * Create portal token
     * @description Create a consumer portal token.
     */
    post: operations['createPortalToken']
  }
  '/api/v1/portal/tokens/invalidate': {
    /**
     * ☁ Invalidate portal tokens
     * @description *Available in OpenMeter Cloud.*
     *
     * Invalidates consumer portal tokens by ID or subject.
     */
    post: operations['invalidatePortalTokens']
  }
  '/api/v1/subjects': {
    /**
     * ☁ List subjects
     * @description *Available in OpenMeter Cloud.*
     *
     * List subjects.
     */
    get: operations['listSubjects']
    /**
     * ☁ Upsert subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Upserts a subject. Creates or updates subject.
     * If the subject doesn't exist, it will be created.
     * If the subject exists, it will be partially updated with the provided fields.
     */
    post: operations['upsertSubject']
  }
  '/api/v1/subjects/{subjectIdOrKey}': {
    /**
     * ☁ Get subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Get subject by ID or key.
     */
    get: operations['getSubject']
    /**
     * ☁ Delete subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Delete a subject by ID or key.
     */
    delete: operations['deleteSubject']
  }
  '/api/v1/portal/meters/{meterSlug}/query': {
    /**
     * Query portal meter
     * @description Query meter for consumer portal. This endpoint is publicly exposable to consumers.
     */
    get: operations['queryPortalMeter']
  }
  '/api/v1/entitlements': {
    /**
     * List entitlements
     * @description List all entitlements regardless of subject. This endpoint is intended for administrative purposes.
     */
    get: operations['listEntitlements']
  }
  '/api/v1/features': {
    /**
     * List features
     * @description List all features.
     */
    get: operations['listFeatures']
    /**
     * Create a feature
     * @description Features are either metered or static. A feature is metered if meterSlug is provided at creation.
     * For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter's groupBy fields. Only meters with SUM and COUNT aggregation are supported for features.
     *
     * Features cannot be updated later, only archived.
     */
    post: operations['createFeature']
  }
  '/api/v1/features/{featureId}': {
    /**
     * Get feature
     * @description Get a feature by id.
     */
    get: operations['getFeature']
    /**
     * Archive a feature
     * @description Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements. This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis.
     */
    delete: operations['deleteFeature']
  }
  '/api/v1/grants': {
    /**
     * List grants
     * @description List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only. To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.
     */
    get: operations['listGrants']
  }
  '/api/v1/grants/{grantId}': {
    /**
     * Void a grant
     * @description Voiding a grant means it is no longer valid, it doesn't take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.
     *
     * For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected.
     */
    delete: operations['voidGrant']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements': {
    /**
     * List entitlements of a subject
     * @description List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead.
     */
    get: operations['listSubjectEntitlements']
    /**
     * Create an entitlement
     * @description OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).
     *
     * - Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
     * - Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
     * - Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.
     *
     * A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.
     *
     * Once an entitlement is created you cannot modify it, only delete it.
     */
    post: operations['createEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}': {
    /**
     * Get an entitlement
     * @description Get entitlement by id. For checking entitlement access, use the /value endpoint instead.
     */
    get: operations['getEntitlement']
    /**
     * Delete an entitlement
     * @description Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
     * As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.
     */
    delete: operations['deleteEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants': {
    /**
     * List grants for an entitlement
     * @description List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey.
     */
    get: operations['listEntitlementGrants']
    /**
     * Create a grant
     * @description Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.
     *
     * A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.
     *
     * Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.
     *
     * Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).
     *
     * Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
     *
     * Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.
     */
    post: operations['createGrant']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value': {
    /**
     * Get the current value and access of an entitlement
     * @description This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
     *
     * For convenience reasons, /value works with both entitlementId and featureKey.
     */
    get: operations['getEntitlementValue']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history': {
    /**
     * Get the balance history of a specific entitlement.
     * @description Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.
     *
     * BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.
     *
     * WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.
     */
    get: operations['getEntitlementHistory']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset': {
    /**
     * Reset an entitlement
     * @description Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.
     *
     * Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.
     */
    post: operations['resetEntitlementUsage']
  }
  '/api/v1/debug/metrics': {
    /**
     * Get event metrics
     * @description Returns debug metrics like the number of ingested events since mindnight UTC.
     * The OpenMetrics Counter(s) reset every day at midnight UTC.
     */
    get: operations['getDebugMetrics']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    /**
     * @description Metadata fields for all resources.
     * These fields are automatically populated by the system for managed entities. Their use and meaning is uniform across all resources.
     */
    SharedMetaFields: {
      /**
       * @description Readonly unique ULID identifier.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Format: date-time
       * @description The date and time the resource was created.
       * @example 2023-01-01T00:00:00Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description The date and time the resource was last updated. The initial value is the same as createdAt.
       * @example 2023-01-01T00:00:00Z
       */
      updatedAt: string
      /**
       * Format: date-time
       * @description The date and time the resource was deleted.
       * @example 2023-01-01T00:00:00Z
       */
      deletedAt?: string
    }
    /**
     * @description Conflict
     * @example {
     *   "type": "about:blank",
     *   "title": "Conflict",
     *   "status": 409,
     *   "detail": "ledger (default.01HXVNDJR532E8GTBVSC2XK5D4) already exitst for subject subject-1",
     *   "instance": "urn:request:local/JMOlctsKV8-000001",
     *   "conflictingEntityId": "01HXVNDJR532E8GTBVSC2XK5D4"
     * }
     */
    ConflictProblem: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @example urn:problem-type:bad-request
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int32
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example body must be a JSON object
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance?: string
      extensions?: {
        /**
         * @description The id of the conflicting entity.
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        conflictingEntityId: string
      }
      [key: string]: unknown
    }
    /**
     * @description A Problem Details object (RFC 7807).
     * Additional properties specific to the problem type may be present.
     * @example {
     *   "type": "urn:problem-type:bad-request",
     *   "title": "Bad Request",
     *   "status": 400,
     *   "detail": "body must be a JSON object"
     * }
     */
    Problem: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @example urn:problem-type:bad-request
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int32
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example body must be a JSON object
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance?: string
      [key: string]: unknown
    }
    /**
     * @description CloudEvents Specification JSON Schema
     * @example {
     *   "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3c",
     *   "source": "service-name",
     *   "specversion": "1.0",
     *   "type": "prompt",
     *   "subject": "customer-id",
     *   "time": "2023-01-01T01:01:01.001Z",
     *   "data": {
     *     "tokens": "1234",
     *     "model": "gpt-4-turbo",
     *     "type": "input"
     *   }
     * }
     */
    Event: {
      /**
       * @description Identifies the event.
       * @example 5c10fade-1c9e-4d6c-8275-c52c36731d3c
       */
      id: string
      /**
       * Format: uri-reference
       * @description Identifies the context in which an event happened.
       * @example service-name
       */
      source: string
      /**
       * @description The version of the CloudEvents specification which the event uses.
       * @example 1.0
       */
      specversion: string
      /**
       * @description Describes the type of event related to the originating occurrence.
       * @example prompt
       */
      type: string
      /**
       * @description Content type of the data value. Must adhere to RFC 2046 format.
       * @example application/json
       * @enum {string|null}
       */
      datacontenttype?: 'application/json' | null
      /**
       * Format: uri
       * @description Identifies the schema that data adheres to.
       */
      dataschema?: string | null
      /**
       * @description Describes the subject of the event in the context of the event producer (identified by source).
       * @example customer-id
       */
      subject: string
      /**
       * Format: date-time
       * @description Timestamp of when the occurrence happened. Must adhere to RFC 3339.
       * @example 2023-01-01T01:01:01.001Z
       */
      time?: string | null
      /**
       * @description The event payload.
       * @example {
       *   "tokens": "1234",
       *   "model": "gpt-4-turbo"
       * }
       */
      data?: {
        [key: string]: unknown
      }
    }
    /**
     * @description An ingested event with optional validation error.
     * @example {
     *   "event": {
     *     "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3d",
     *     "source": "service-name",
     *     "specversion": "1.0",
     *     "type": "prompt",
     *     "subject": "customer-id",
     *     "time": "2023-01-01T01:01:01.001Z",
     *     "data": {
     *       "tokens": "1234",
     *       "model": "gpt-4-turbo"
     *     }
     *   },
     *   "validationError": "meter not found for event"
     * }
     */
    IngestedEvent: {
      event: components['schemas']['Event']
      /** @example invalid event */
      validationError?: string
    }
    /**
     * @description A feature is a feature or service offered to a customer.
     * For example: CPU-Hours, Tokens, API Calls, etc.
     */
    FeatureCreateInputs: {
      /**
       * @description The key is an immutable unique identifier of the feature used throughout the API, for example when interacting with a subject's entitlements. The key has to be unique across all active features, but archived features can share the same key. The key should consist of lowercase alphanumeric characters and dashes.
       *
       * @example gpt4_tokens
       */
      key: string
      /**
       * @description The name of the feature.
       *
       * @example AI Tokens
       */
      name: string
      /** @description Additional metadata for the feature, useful for syncing with external systems and annotating custom fields. */
      metadata?: {
        [key: string]: string
      }
      /**
       * @description The meter that the feature is associated with and and based on which usage is calculated.
       * The meter selected must have SUM or COUNT aggregation.
       *
       * @example tokens_total
       */
      meterSlug?: string
      /**
       * @description Optional meter group by filters. Useful if the meter scope is broader than what feature tracks. Example scenario would be a meter tracking all token use with groupBy fields for the model, then the feature could filter for model=gpt-4.
       *
       * @example {
       *   "model": "gpt-4"
       * }
       */
      meterGroupByFilters?: {
        [key: string]: string
      }
    }
    /**
     * @description A feature is a feature or service offered to a customer.
     * For example: CPU-Hours, Tokens, API Calls, etc.
     */
    Feature: {
      /**
       * Format: date-time
       * @description If the feature is archived, no new entitlements can be created for it.
       *
       * @example 2023-01-01T00:00:00Z
       */
      archivedAt?: string
    } & components['schemas']['FeatureCreateInputs'] &
      components['schemas']['SharedMetaFields']
    EntitlementCreateSharedFields: {
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       *
       * @example example-feature-key
       */
      featureKey?: string
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId?: string
      /** @description Additional metadata for the feature. */
      metadata?: {
        [key: string]: string
      }
      usagePeriod?: components['schemas']['RecurringPeriodCreateInput']
    }
    EntitlementSharedFields: components['schemas']['SharedMetaFields'] &
      components['schemas']['EntitlementCreateSharedFields'] & {
        /**
         * @description The feature the subject is entitled to use.
         * Either featureKey or featureId is required.
         *
         * @example example-feature-key
         */
        featureKey: string
        /**
         * @description The feature the subject is entitled to use.
         * Either featureKey or featureId is required.
         *
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        featureId: string
        /**
         * @description The identifier key unique to the subject
         * @example customer-1
         */
        subjectKey: string
        usagePeriod?: components['schemas']['RecurringPeriod']
        currentUsagePeriod?: components['schemas']['Period']
      }
    EntitlementMeteredCreateInputs: components['schemas']['EntitlementCreateSharedFields'] & {
      /**
       * @example metered
       * @enum {string}
       */
      type: 'metered'
      /**
       * @description If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
       *
       * @default false
       */
      isSoftLimit?: boolean
      /**
       * @description Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
       *
       * @default false
       */
      isUnlimited?: boolean
      usagePeriod: components['schemas']['RecurringPeriodCreateInput']
      /**
       * Format: double
       * @description You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance. If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
       * That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
       *
       * Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
       */
      issueAfterReset?: number
      /**
       * @description Defines the grant priority for the default grant. If provided, issueAfterReset must have a value.
       *
       * @default 1
       * @example 1
       */
      issueAfterResetPriority?: number
    }
    EntitlementCreateInputs:
      | components['schemas']['EntitlementMeteredCreateInputs']
      | components['schemas']['EntitlementStaticCreateInputs']
      | components['schemas']['EntitlementBooleanCreateInputs']
    /** @description Metered entitlements are useful for many different use cases, from setting up usage based access to implementing complex credit systems. Access is determined based on feature usage using a balance calculation (the "usage allowance" provided by the issued grants is "burnt down" by the usage). */
    EntitlementMetered: components['schemas']['EntitlementMeteredCreateInputs'] &
      components['schemas']['EntitlementMeteredCalculatedFields'] &
      components['schemas']['EntitlementSharedFields']
    /** @description Calculated fields for a metered entitlement. */
    EntitlementMeteredCalculatedFields: {
      /**
       * Format: date-time
       * @description The last time a reset happened.
       *
       * @example 2023-01-01T00:00:00Z
       */
      lastReset: string
      currentUsagePeriod: components['schemas']['Period']
    }
    EntitlementStaticCreateInputs: components['schemas']['EntitlementCreateSharedFields'] & {
      /**
       * @example static
       * @enum {string}
       */
      type: 'static'
      /**
       * @description The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
       *
       * @example {"key1": "value1"}
       */
      config: string
    }
    /** @description Entitles a subject to use a feature. */
    EntitlementStatic: components['schemas']['EntitlementStaticCreateInputs'] &
      components['schemas']['EntitlementSharedFields']
    EntitlementBooleanCreateInputs: components['schemas']['EntitlementCreateSharedFields'] & {
      /**
       * @example boolean
       * @enum {string}
       */
      type: 'boolean'
    }
    /** @description Entitles a subject to use a feature. */
    EntitlementBoolean: components['schemas']['EntitlementBooleanCreateInputs'] &
      components['schemas']['EntitlementSharedFields']
    Entitlement:
      | components['schemas']['EntitlementMetered']
      | components['schemas']['EntitlementStatic']
      | components['schemas']['EntitlementBoolean']
    /**
     * @description A segment of the grant burn down history.
     *
     * A given segment represents the usage of a grant between events that changed either the grant burn down priority order or the usag period.
     */
    GrantBurnDownHistorySegment: {
      period?: components['schemas']['Period']
      /**
       * Format: double
       * @description The usage of the grant in the period.
       *
       * @example 100
       */
      usage?: number
      /**
       * Format: double
       * @description Overuse that wasn't covered by grants.
       *
       * @example 25
       */
      overage?: number
      /**
       * Format: double
       * @description The entitlement balance at the start of the period.
       *
       * @example 100
       */
      balanceAtStart?: number
      /**
       * @description The balance breakdown of each active grant at the start of the period: GrantID: Balance
       *
       * @example {
       *   "01ARZ3NDEKTSV4RRFFQ69G5FAV": 100
       * }
       */
      grantBalancesAtStart?: {
        [key: string]: number
      }
      /**
       * Format: double
       * @description The entitlement balance at the end of the period.
       *
       * @example 100
       */
      balanceAtEnd?: number
      /**
       * @description The balance breakdown of each active grant at the start of the period: GrantID: Balance
       *
       * @example {
       *   "01ARZ3NDEKTSV4RRFFQ69G5FAV": 100
       * }
       */
      grantBalancesAtEnd?: {
        [key: string]: number
      }
      /** @description Which grants were actually burnt down in the period and by what amount. */
      grantUsages?: readonly components['schemas']['GrantUsageRecord'][]
    }
    GrantUsageRecord: {
      /**
       * @description The id of the grant.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      grantId?: string
      /**
       * Format: double
       * @description The usage of the grant.
       *
       * @example 100
       */
      usage?: number
    }
    /** @description Windowed usage and balance information. */
    BalanceHistoryWindow: {
      period?: components['schemas']['Period']
      /**
       * Format: double
       * @description The total usage of the feature in the period.
       *
       * @example 100
       */
      usage?: number
      /**
       * Format: double
       * @description The entitlement balance at the start of the period.
       *
       * @example 100
       */
      balanceAtStart?: number
    }
    /** @description The windowed balance history. */
    WindowedBalanceHistory: {
      /**
       * @description The windowed balance history.
       * - It only returns rows for windows where there was usage.
       * - The windows are inclusive at their start and exclusive at their end.
       * - The last window may be smaller than the window size and is inclusive at both ends.
       */
      windowedHistory?: components['schemas']['BalanceHistoryWindow'][]
      /** @description Grant burndown history. */
      burndownHistory?: components['schemas']['GrantBurnDownHistorySegment'][]
    }
    /** @description A time period */
    Period: {
      /**
       * Format: date-time
       * @description Period start time where the amount was applied. If applicable.
       *
       * @example 2023-01-01T00:00:00Z
       */
      from: string
      /**
       * Format: date-time
       * @description Period end time where the amount was applied. If applicable.
       *
       * @example 2023-01-01T00:00:00Z
       */
      to: string
    }
    /**
     * @description List of pre-defined periods that can be used for recurring & scheduling.
     *
     * DAY:      Every day
     * WEEK:     Every week
     * MONTH:    Every month
     * YEAR:     Every year
     *
     * @enum {string}
     */
    RecurringPeriodEnum: 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
    /** @description Recurring period of an entitlement. */
    RecurringPeriodCreateInput: {
      interval: components['schemas']['RecurringPeriodEnum']
      /**
       * Format: date-time
       * @description An arbitrary anchor to base the recurring period on.
       * If not provided then defaults to now truncated to the hour.
       */
      anchor?: string
    }
    /** @description Recurring period of an entitlement. */
    RecurringPeriod: {
      interval: components['schemas']['RecurringPeriodEnum']
      /**
       * Format: date-time
       * @description An arbitrary anchor to base the recurring period on.
       */
      anchor: string
    }
    /** @description Grants are used to increase balance of specific subjects. */
    EntitlementGrantCreateInput: {
      /**
       * Format: double
       * @description The amount to grant. Should be a positive number.
       *
       * @example 100
       */
      amount: number
      /**
       * @description The priority of the grant. Grants with higher priority are applied first.
       * Priority is a positive decimal numbers. With lower numbers indicating higher importance.
       * For example, a priority of 1 is more urgent than a priority of 2.
       * When there are several grants available for the same subject, the system selects the grant with the highest priority.
       * In cases where grants share the same priority level, the grant closest to its expiration will be used first.
       * In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
       *
       * @default 1
       * @example 1
       */
      priority?: number
      /**
       * Format: date-time
       * @description Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
       *
       * @example 2023-01-01T00:00:00Z
       */
      effectiveAt: string
      expiration: components['schemas']['ExpirationPeriod']
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       *
       * Balance after the reset is calculated as:
       * Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       *
       * @default 0
       * @example 100
       */
      maxRolloverAmount?: number
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       *
       * Balance after the reset is calculated as:
       * Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       *
       * @default 0
       * @example 100
       */
      minRolloverAmount?: number
      /**
       * @example {
       *   "stripePaymentId": "pi_4OrAkhLvyihio9p51h9iiFnB"
       * }
       */
      metadata?: {
        [key: string]: string
      }
      recurrence?: components['schemas']['RecurringPeriodCreateInput']
    }
    EntitlementGrant: components['schemas']['EntitlementGrantCreateInput'] &
      components['schemas']['SharedMetaFields'] & {
        /**
         * @description The unique entitlement ULID that the grant is associated with.
         *
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        entitlementId: string
        /**
         * Format: date-time
         * @description The next time the grant will recurr.
         *
         * @example 2023-01-01T00:00:00Z
         */
        nextRecurrence?: string
        /**
         * Format: date-time
         * @description The expiration date of the grant.
         *
         * @example 2023-01-01T00:00:00Z
         */
        expiresAt?: string
        /**
         * Format: date-time
         * @description The date and time the grant was voided (cannot be used after that).
         */
        voidedAt?: string
        recurrence?: components['schemas']['RecurringPeriod']
      }
    EntitlementValue: {
      /**
       * @description Whether the subject has access to the feature. Shared accross all entitlement types.
       *
       * @example true
       */
      hasAccess: boolean
      /**
       * Format: double
       * @description Only available for metered entitlements. Metered entitlements are built around a balance calculation where feature usage is deducted from the issued grants. Balance represents the remaining balance of the entitlement, it's value never turns negative.
       *
       * @example 100
       */
      balance?: number
      /**
       * Format: double
       * @description Only available for metered entitlements. Returns the total feature usage in the current period.
       *
       * @example 50
       */
      usage?: number
      /**
       * Format: double
       * @description Only available for metered entitlements. Overage represents the usage that wasn't covered by grants, e.g. if the subject had a total feature usage of 100 in the period but they were only granted 80, there would be 20 overage.
       *
       * @example 0
       */
      overage?: number
      /**
       * @description Only available for static entitlements. The JSON parsable config of the entitlement.
       *
       * @example {"key1": "value1"}
       */
      config?: string
    }
    /** @description Expiration period of a grant. */
    ExpirationPeriod: {
      /**
       * @description The expiration period duration like month.
       *
       * @enum {string}
       */
      duration: 'HOUR' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
      /**
       * @description The expiration period count like 12 months.
       *
       * @example 12
       */
      count: number
    }
    /**
     * @description A meter is a configuration that defines how to match and aggregate events.
     * @example {
     *   "slug": "tokens_total",
     *   "description": "AI token usage",
     *   "aggregation": "SUM",
     *   "windowSize": "MINUTE",
     *   "eventType": "prompt",
     *   "valueProperty": "$.tokens",
     *   "groupBy": {
     *     "model": "$.model",
     *     "type": "$.type"
     *   }
     * }
     */
    Meter: {
      /**
       * @description A unique identifier for the meter.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id?: string
      /**
       * @description A unique, human-readable identifier for the meter. Must consist only alphanumeric and underscore characters.
       * @example tokens_total
       */
      slug: string
      /**
       * @description A description of the meter.
       * @example AI Token Usage
       */
      description?: string | null
      aggregation: components['schemas']['MeterAggregation']
      windowSize: components['schemas']['WindowSize']
      /**
       * @description The event type to aggregate.
       * @example prompt
       */
      eventType: string
      /**
       * @description JSONPath expression to extract the value from the ingested event's data property.
       * The ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.
       * For UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.
       *
       * @example $.tokens
       */
      valueProperty?: string
      /**
       * @description Named JSONPath expressions to extract the group by values from the event data. Keys must be unique and consist only alphanumeric and underscore characters.
       * @example {
       *   "model": "$.model",
       *   "type": "$.type"
       * }
       */
      groupBy?: {
        [key: string]: string
      }
    }
    /**
     * @description The aggregation type to use for the meter.
     * @example SUM
     * @enum {string}
     */
    MeterAggregation: 'SUM' | 'COUNT' | 'UNIQUE_COUNT' | 'AVG' | 'MIN' | 'MAX'
    /**
     * @description Aggregation window size.
     * @example MINUTE
     * @enum {string}
     */
    WindowSize: 'MINUTE' | 'HOUR' | 'DAY'
    /**
     * @description The result of a meter query.
     * @example {
     *   "from": "2023-01-01T00:00:00Z",
     *   "to": "2023-01-02T00:00:00Z",
     *   "windowSize": "MINUTE",
     *   "data": [
     *     {
     *       "value": 12,
     *       "windowStart": "2023-01-01T00:00:00Z",
     *       "windowEnd": "2023-01-02T00:00:00Z",
     *       "subject": "customer-id",
     *       "groupBy": {
     *         "model": "gpt-4-turbo",
     *         "type": "prompt"
     *       }
     *     }
     *   ]
     * }
     */
    MeterQueryResult: {
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      from?: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      to?: string
      windowSize?: components['schemas']['WindowSize']
      /**
       * @example [
       *   {
       *     "value": 12,
       *     "windowStart": "2023-01-01T00:00:00Z",
       *     "windowEnd": "2023-01-02T00:00:00Z",
       *     "subject": "customer-id",
       *     "groupBy": {
       *       "model": "gpt-4-turbo",
       *       "type": "prompt"
       *     }
       *   }
       * ]
       */
      data: components['schemas']['MeterQueryRow'][]
    }
    /**
     * @description A row in the result of a meter query.
     * @example {
     *   "value": 12,
     *   "windowStart": "2023-01-01T00:00:00Z",
     *   "windowEnd": "2023-01-02T00:00:00Z",
     *   "subject": "customer-id",
     *   "groupBy": {
     *     "model": "gpt-4-turbo",
     *     "type": "prompt"
     *   }
     * }
     */
    MeterQueryRow: {
      /** @example 12 */
      value: number
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      windowStart: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      windowEnd: string
      /**
       * @description The subject of the meter value.
       * @example customer-id
       */
      subject?: string | null
      /**
       * @example {
       *   "model": "gpt-4-turbo",
       *   "type": "prompt"
       * }
       */
      groupBy?: {
        [key: string]: string
      } | null
    }
    /**
     * @description A consumer portal token.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "subject": "customer-id",
     *   "expiresAt": "2023-01-02T00:00:00Z",
     *   "expired": false,
     *   "createdAt": "2023-01-01T00:00:00Z",
     *   "token": "om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo",
     *   "allowedMeterSlugs": [
     *     "tokens_total"
     *   ]
     * }
     */
    PortalToken: {
      /** @example 01G65Z755AFWAKHE12NY0CQ9FH */
      id?: string
      /** @example customer-id */
      subject: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      expiresAt?: string
      expired?: boolean
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      createdAt?: string
      /**
       * @description The token is only returned at creation.
       * @example om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo
       */
      token?: string
      /**
       * @description Optional, if defined only the specified meters will be allowed
       * @example [
       *   "tokens_total"
       * ]
       */
      allowedMeterSlugs?: string[]
    }
    /**
     * @description A subject is a unique identifier for a user or entity.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "key": "customer-id",
     *   "displayName": "Customer Name",
     *   "metadata": {
     *     "hubspotId": "123456"
     *   },
     *   "currentPeriodStart": "2023-01-01T00:00:00Z",
     *   "currentPeriodEnd": "2023-02-01T00:00:00Z",
     *   "stripeCustomerId": "cus_JMOlctsKV8"
     * }
     */
    Subject: {
      /** @example 01G65Z755AFWAKHE12NY0CQ9FH */
      id?: string
      /** @example customer-id */
      key: string
      /** @example Customer Name */
      displayName?: string | null
      /**
       * @example {
       *   "hubspotId": "123456"
       * }
       */
      metadata?: {
        [key: string]: unknown
      } | null
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      currentPeriodStart?: string | null
      /**
       * Format: date-time
       * @example 2023-02-01T00:00:00Z
       */
      currentPeriodEnd?: string | null
      /** @example cus_JMOlctsKV8 */
      stripeCustomerId?: string | null
    }
    /**
     * @description A unique identifier.
     * @example tokens_total
     */
    IdOrSlug: string
  }
  responses: {
    /** @description Ledger Exists */
    ConflictProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['ConflictProblem']
      }
    }
    /** @description Bad Request */
    BadRequestProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Unauthorized */
    UnauthorizedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Not Found */
    NotFoundProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Not Implemented */
    NotImplementedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Unexpected error */
    UnexpectedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
  }
  parameters: {
    /** @description A unique identifier for the meter. */
    meterIdOrSlug: components['schemas']['IdOrSlug']
    /** @description A unique identifier for a subject. */
    subjectIdOrKey: string
    /** @description A unique ULID identifier for a feature. */
    featureId: string
    /** @description A unique identifier for a grant. */
    grantId: string
    /** @description A unique ULID for an entitlement. */
    entitlementId: string
    /** @description The id of the entitlement or the key of the feature. */
    entitlementIdOrFeatureKey: string
    /** @description Include deleted entries. */
    includeDeleted?: boolean
    /** @description Number of entries to return */
    queryLimit?: number
    /** @description Number of entries to skip */
    queryOffset?: number
    /**
     * @description Start date-time in RFC 3339 format.
     * Inclusive.
     */
    queryFrom?: string
    /**
     * @description End date-time in RFC 3339 format.
     * Inclusive.
     */
    queryTo?: string
    /** @description If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group. */
    queryWindowSize?: components['schemas']['WindowSize']
    /**
     * @description The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
     * If not specified, the UTC timezone will be used.
     */
    queryWindowTimeZone?: string
    /**
     * @description Filtering by multiple subjects.
     *
     * Usage: ?subject=customer-1&subject=customer-2
     */
    queryFilterSubject?: string[]
    queryFilterGroupBy?: {
      [key: string]: string
    }
    /**
     * @description If not specified a single aggregate will be returned for each subject and time window.
     * `subject` is a reserved group by value.
     */
    queryGroupBy?: string[]
  }
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /**
   * List ingested events
   * @description List ingested events within a time range.
   */
  listEvents: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        /** @description Number of events to return */
        limit?: number
      }
    }
    responses: {
      /** @description List of events for debugging. */
      200: {
        content: {
          'application/json': components['schemas']['IngestedEvent'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Ingest events
   * @description Ingests an event or batch of events following the CloudEvents specification.
   */
  ingestEvents: {
    /**
     * @description The event or batch of events to ingest.
     * The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
     * The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
     */
    requestBody: {
      content: {
        'application/cloudevents+json': components['schemas']['Event']
        'application/cloudevents-batch+json': components['schemas']['Event'][]
      }
    }
    responses: {
      /** @description Successfully ingested. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List meters
   * @description List meters.
   */
  listMeters: {
    responses: {
      /** @description List of meters. */
      200: {
        content: {
          'application/json': components['schemas']['Meter'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Create meter
   * @description *Available in OpenMeter Cloud.*
   * *In the open-source version, meters are created in the configuration file.*
   *
   * Create a meter.
   */
  createMeter: {
    /** @description The meter to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['Meter']
      }
    }
    responses: {
      /** @description Created. */
      201: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get meter
   * @description Get meter by ID or slug
   */
  getMeter: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Meter found. */
      200: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Delete meter
   * @description *Available in OpenMeter Cloud.*
   *
   * Delete a meter by ID or slug.
   */
  deleteMeter: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Meter deleted. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Query meter
   * @description Query meter for usage.
   */
  queryMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        windowSize?: components['parameters']['queryWindowSize']
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
        subject?: components['parameters']['queryFilterSubject']
        filterGroupBy?: components['parameters']['queryFilterGroupBy']
        groupBy?: components['parameters']['queryGroupBy']
      }
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Usage data. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List meter subjects
   * @description List subjects for a meter.
   */
  listMeterSubjects: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description List of subjects. */
      200: {
        content: {
          'application/json': string[]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ List portal tokens
   * @description *Available in OpenMeter Cloud.*
   *
   * List consumer portal tokens.
   */
  listPortalTokens: {
    parameters: {
      query?: {
        /** @description Number of portal tokens to return. Default is 25. */
        limit?: number
      }
    }
    responses: {
      /** @description List of portal tokens. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create portal token
   * @description Create a consumer portal token.
   */
  createPortalToken: {
    /** @description The portal token to create. */
    requestBody: {
      content: {
        /**
         * @example {
         *   "subject": "customer-id",
         *   "allowedMeterSlugs": [
         *     "tokens_total"
         *   ]
         * }
         */
        'application/json': components['schemas']['PortalToken']
      }
    }
    responses: {
      /** @description Created. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Invalidate portal tokens
   * @description *Available in OpenMeter Cloud.*
   *
   * Invalidates consumer portal tokens by ID or subject.
   */
  invalidatePortalTokens: {
    /** @description If no id or subject is specified, all tokens will be invalidated. */
    requestBody: {
      content: {
        'application/json': {
          /** @description Invalidate a portal token by ID. */
          id?: string
          /** @description Invalidate all portal tokens for a subject. */
          subject?: string
        }
      }
    }
    responses: {
      /** @description Portal tokens invalidated. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ List subjects
   * @description *Available in OpenMeter Cloud.*
   *
   * List subjects.
   */
  listSubjects: {
    responses: {
      /** @description List of subjects. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Upsert subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Upserts a subject. Creates or updates subject.
   * If the subject doesn't exist, it will be created.
   * If the subject exists, it will be partially updated with the provided fields.
   */
  upsertSubject: {
    /** @description The subject to upsert. */
    requestBody: {
      content: {
        'application/json': components['schemas']['Subject'][]
      }
    }
    responses: {
      /** @description Subject upserted. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Get subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Get subject by ID or key.
   */
  getSubject: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description Subject found. */
      200: {
        content: {
          'application/json': components['schemas']['Subject']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Delete subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Delete a subject by ID or key.
   */
  deleteSubject: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description Subject deleted. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Query portal meter
   * @description Query meter for consumer portal. This endpoint is publicly exposable to consumers.
   */
  queryPortalMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        windowSize?: components['parameters']['queryWindowSize']
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
        filterGroupBy?: components['parameters']['queryFilterGroupBy']
        groupBy?: components['parameters']['queryGroupBy']
      }
      path: {
        /** @description A unique identifier for the meter. */
        meterSlug: string
      }
    }
    responses: {
      /** @description Usage data. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List entitlements
   * @description List all entitlements regardless of subject. This endpoint is intended for administrative purposes.
   */
  listEntitlements: {
    parameters: {
      query?: {
        limit?: components['parameters']['queryLimit']
        offset?: components['parameters']['queryOffset']
        /** @description Order by field */
        orderBy?: 'createdAt' | 'updatedAt'
      }
    }
    responses: {
      /** @description List of entitlements. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List features
   * @description List all features.
   */
  listFeatures: {
    parameters: {
      query?: {
        limit?: components['parameters']['queryLimit']
        offset?: components['parameters']['queryOffset']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt' | 'updatedAt'
        /** @description Include archived features. */
        includeArchived?: boolean
      }
    }
    responses: {
      /** @description List of features. */
      200: {
        content: {
          'application/json': components['schemas']['Feature'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create a feature
   * @description Features are either metered or static. A feature is metered if meterSlug is provided at creation.
   * For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter's groupBy fields. Only meters with SUM and COUNT aggregation are supported for features.
   *
   * Features cannot be updated later, only archived.
   */
  createFeature: {
    /** @description The feature to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['FeatureCreateInputs']
      }
    }
    responses: {
      /** @description Feature created. */
      201: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get feature
   * @description Get a feature by id.
   */
  getFeature: {
    parameters: {
      path: {
        featureId: components['parameters']['featureId']
      }
    }
    responses: {
      /** @description Feature found. */
      200: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Archive a feature
   * @description Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements. This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis.
   */
  deleteFeature: {
    parameters: {
      path: {
        featureId: components['parameters']['featureId']
      }
    }
    responses: {
      /** @description Feature deleted. */
      204: {
        content: never
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List grants
   * @description List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only. To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.
   */
  listGrants: {
    parameters: {
      query?: {
        limit?: components['parameters']['queryLimit']
        offset?: components['parameters']['queryOffset']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt' | 'updatedAt'
        includeDeleted?: components['parameters']['includeDeleted']
      }
    }
    responses: {
      /** @description List of grants. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementGrant'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Void a grant
   * @description Voiding a grant means it is no longer valid, it doesn't take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.
   *
   * For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected.
   */
  voidGrant: {
    parameters: {
      path: {
        grantId: components['parameters']['grantId']
      }
    }
    responses: {
      /** @description Grant has been voided. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      409: components['responses']['ConflictProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List entitlements of a subject
   * @description List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead.
   */
  listSubjectEntitlements: {
    parameters: {
      query?: {
        includeDeleted?: components['parameters']['includeDeleted']
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description List of entitlements. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create an entitlement
   * @description OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).
   *
   * - Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
   * - Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
   * - Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.
   *
   * A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.
   *
   * Once an entitlement is created you cannot modify it, only delete it.
   */
  createEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    /** @description The entitlement to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementCreateInputs']
      }
    }
    responses: {
      /** @description Entitlement created. */
      201: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      409: components['responses']['ConflictProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get an entitlement
   * @description Get entitlement by id. For checking entitlement access, use the /value endpoint instead.
   */
  getEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description Entitlement found. */
      200: {
        content: {
          'application/json': {
            type: 'json'
          } & Omit<components['schemas']['Entitlement'], 'type'> & {
              /**
               * Format: date-time
               * @description The last time usage was reset.
               * @example 2023-01-01T00:00:00Z
               */
              lastReset?: string
            }
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Delete an entitlement
   * @description Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
   * As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.
   */
  deleteEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description Entitlement deleted. */
      204: {
        content: never
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List grants for an entitlement
   * @description List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey.
   */
  listEntitlementGrants: {
    parameters: {
      query?: {
        includeDeleted?: components['parameters']['includeDeleted']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt' | 'updatedAt'
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementIdOrFeatureKey: components['parameters']['entitlementIdOrFeatureKey']
      }
    }
    responses: {
      /** @description List of grants. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementGrant'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create a grant
   * @description Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.
   *
   * A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.
   *
   * Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.
   *
   * Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).
   *
   * Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
   *
   * Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.
   */
  createGrant: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementIdOrFeatureKey: components['parameters']['entitlementIdOrFeatureKey']
      }
    }
    /** @description The grant to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementGrantCreateInput']
      }
    }
    responses: {
      /** @description Grant created. */
      201: {
        content: {
          'application/json': components['schemas']['EntitlementGrant']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get the current value and access of an entitlement
   * @description This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
   *
   * For convenience reasons, /value works with both entitlementId and featureKey.
   */
  getEntitlementValue: {
    parameters: {
      query?: {
        /** @description Point of time to check value: date-time in RFC 3339 format. Defaults to now. */
        time?: string
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementIdOrFeatureKey: components['parameters']['entitlementIdOrFeatureKey']
      }
    }
    responses: {
      /** @description The entitlement value. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementValue']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get the balance history of a specific entitlement.
   * @description Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.
   *
   * BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.
   *
   * WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.
   */
  getEntitlementHistory: {
    parameters: {
      query: {
        /**
         * @description Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to
         * the last reset.
         * Gets truncated to the granularity of the underlying meter.
         */
        from?: string
        /**
         * @description End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.
         * If not now then gets truncated to the granularity of the underlying meter.
         */
        to?: string
        /** @description Size of the time window to group the history by. Cannot be shorter than meter granularity. */
        windowSize: 'MINUTE' | 'HOUR' | 'DAY'
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description The history response. */
      200: {
        content: {
          'application/json': components['schemas']['WindowedBalanceHistory']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Reset an entitlement
   * @description Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.
   *
   * Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.
   */
  resetEntitlementUsage: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * Format: date-time
           * @description The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.
           *
           * @example 2023-01-01T00:00:00Z
           */
          effectiveAt?: string
          /**
           * @description Determines whether the usage period anchor is retained or reset to the effectiveAt time.
           * - If true, the usage period anchor is retained.
           * - If false, the usage period anchor is reset to the effectiveAt time.
           */
          retainAnchor?: boolean
        }
      }
    }
    responses: {
      /** @description Entitlement reset. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get event metrics
   * @description Returns debug metrics like the number of ingested events since mindnight UTC.
   * The OpenMetrics Counter(s) reset every day at midnight UTC.
   */
  getDebugMetrics: {
    responses: {
      /** @description Dbeug metrics, like number of ingested events. */
      200: {
        content: {
          'text/plain': string
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
}
