/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/events': {
    /**
     * List ingested events
     * @description List ingested events within a time range.
     */
    get: operations['listEvents']
    /**
     * Ingest events
     * @description Ingests an event or batch of events following the CloudEvents specification.
     */
    post: operations['ingestEvents']
  }
  '/api/v1/meters': {
    /**
     * List meters
     * @description List meters.
     */
    get: operations['listMeters']
    /**
     * ☁ Create meter
     * @description *Available in OpenMeter Cloud.*
     * *In the open-source version, meters are created in the configuration file.*
     *
     * Create a meter.
     */
    post: operations['createMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}': {
    /**
     * Get meter
     * @description Get meter by ID or slug
     */
    get: operations['getMeter']
    /**
     * ☁ Delete meter
     * @description *Available in OpenMeter Cloud.*
     *
     * Delete a meter by ID or slug.
     */
    delete: operations['deleteMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/query': {
    /**
     * Query meter
     * @description Query meter for usage.
     */
    get: operations['queryMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/subjects': {
    /**
     * List meter subjects
     * @description List subjects for a meter.
     */
    get: operations['listMeterSubjects']
  }
  '/api/v1/portal/tokens': {
    /**
     * ☁ List portal tokens
     * @description *Available in OpenMeter Cloud.*
     *
     * List consumer portal tokens.
     */
    get: operations['listPortalTokens']
    /**
     * Create portal token
     * @description Create a consumer portal token.
     */
    post: operations['createPortalToken']
  }
  '/api/v1/portal/tokens/invalidate': {
    /**
     * ☁ Invalidate portal tokens
     * @description *Available in OpenMeter Cloud.*
     *
     * Invalidates consumer portal tokens by ID or subject.
     */
    post: operations['invalidatePortalTokens']
  }
  '/api/v1/subjects': {
    /**
     * ☁ List subjects
     * @description *Available in OpenMeter Cloud.*
     *
     * List subjects.
     */
    get: operations['listSubjects']
    /**
     * ☁ Upsert subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Upserts a subject. Creates or updates subject.
     * If the subject doesn't exist, it will be created.
     * If the subject exists, it will be partially updated with the provided fields.
     */
    post: operations['upsertSubject']
  }
  '/api/v1/subjects/{subjectIdOrKey}': {
    /**
     * ☁ Get subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Get subject by ID or key.
     */
    get: operations['getSubject']
    /**
     * ☁ Delete subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Delete a subject by ID or key.
     */
    delete: operations['deleteSubject']
  }
  '/api/v1/portal/meters/{meterSlug}/query': {
    /**
     * Query portal meter
     * @description Query meter for consumer portal. This endpoint is publicly exposable to consumers.
     */
    get: operations['queryPortalMeter']
  }
  '/api/v1/features': {
    /**
     * List features
     * @description List features.
     */
    get: operations['listFeatures']
    /**
     * Create feature
     * @description Creates a feature.
     */
    post: operations['createFeature']
  }
  '/api/v1/features/{featureID}': {
    /**
     * Get feature
     * @description Get feature by key.
     */
    get: operations['getFeature']
    /**
     * Delete feature
     * @description Delete a feature by key.
     */
    delete: operations['deleteFeature']
  }
  '/api/v1/ledgers': {
    /**
     * List the already defined ledgers.
     * @description List the already defined ledgers.
     */
    get: operations['listLedgers']
    /**
     * Creates the specified ledger
     * @description Create or update the specified ledger.
     */
    post: operations['createLedger']
  }
  '/api/v1/ledgers/{ledgerID}/balance': {
    /**
     * Get the balance of a specific subject.
     * @description Get the balance of a specific subject.
     */
    get: operations['getLedgerBalance']
  }
  '/api/v1/ledgers/{ledgerID}/history': {
    /**
     * Get the history of a ledger
     * @description Get the history of a specific ledger
     */
    get: operations['getLedgerHistory']
  }
  '/api/v1/ledgers/{ledgerID}/reset': {
    /**
     * Reset the ledger's balance
     * @description Resets the ledger's balances to zero for a specific subject and re-apply active grants with rollover configuration.
     */
    post: operations['resetLedger']
  }
  '/api/v1/ledgers/grants': {
    /**
     * List grants for multiple ledgers.
     * @description List grants for multiple ledgers.
     */
    get: operations['listLedgerGrants']
  }
  '/api/v1/ledgers/{ledgerID}/grants': {
    /**
     * List ledger grants
     * @description List ledger grants for a specific ledger.
     */
    get: operations['listLedgerGrantsByLedger']
    /**
     * Create a grant on a specific ledger.
     * @description Create a grant on a specific ledger.
     */
    post: operations['createLedgerGrant']
  }
  '/api/v1/ledgers/{ledgerID}/grants/{ledgerGrantID}': {
    /**
     * Get a single grant.
     * @description Gets the grant for a ledger by ID.
     */
    get: operations['getLedgerGrant']
    /**
     * Void ledger grant
     * @description Void a ledger grant by ID. Partially or fully used grants cannot be voided.
     * Voided grant won't be applied to the subject's balance anymore.
     */
    delete: operations['voidLedgerGrant']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    /**
     * @description A Problem Details object (RFC 7807).
     * Additional properties specific to the problem type may be present.
     * @example {
     *   "type": "urn:problem-type:bad-request",
     *   "title": "Bad Request",
     *   "status": 400,
     *   "detail": "body must be a JSON object"
     * }
     */
    Problem: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @example urn:problem-type:bad-request
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int32
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example body must be a JSON object
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance?: string
      [key: string]: unknown
    }
    /**
     * @description CloudEvents Specification JSON Schema
     * @example {
     *   "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3c",
     *   "source": "service-name",
     *   "specversion": "1.0",
     *   "type": "prompt",
     *   "subject": "customer-id",
     *   "time": "2023-01-01T01:01:01.001Z",
     *   "data": {
     *     "tokens": "1234",
     *     "model": "gpt-4-turbo",
     *     "type": "input"
     *   }
     * }
     */
    Event: {
      /**
       * @description Identifies the event.
       * @example 5c10fade-1c9e-4d6c-8275-c52c36731d3c
       */
      id: string
      /**
       * Format: uri-reference
       * @description Identifies the context in which an event happened.
       * @example service-name
       */
      source: string
      /**
       * @description The version of the CloudEvents specification which the event uses.
       * @example 1.0
       */
      specversion: string
      /**
       * @description Describes the type of event related to the originating occurrence.
       * @example prompt
       */
      type: string
      /**
       * @description Content type of the data value. Must adhere to RFC 2046 format.
       * @example application/json
       * @enum {string|null}
       */
      datacontenttype?: 'application/json' | null
      /**
       * Format: uri
       * @description Identifies the schema that data adheres to.
       */
      dataschema?: string | null
      /**
       * @description Describes the subject of the event in the context of the event producer (identified by source).
       * @example customer-id
       */
      subject: string
      /**
       * Format: date-time
       * @description Timestamp of when the occurrence happened. Must adhere to RFC 3339.
       * @example 2023-01-01T01:01:01.001Z
       */
      time?: string | null
      /**
       * @description The event payload.
       * @example {
       *   "tokens": "1234",
       *   "model": "gpt-4-turbo"
       * }
       */
      data?: {
        [key: string]: unknown
      }
    }
    /**
     * @description An ingested event with optional validation error.
     * @example {
     *   "event": {
     *     "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3d",
     *     "source": "service-name",
     *     "specversion": "1.0",
     *     "type": "prompt",
     *     "subject": "customer-id",
     *     "time": "2023-01-01T01:01:01.001Z",
     *     "data": {
     *       "tokens": "1234",
     *       "model": "gpt-4-turbo"
     *     }
     *   },
     *   "validationError": "meter not found for event"
     * }
     */
    IngestedEvent: {
      event: components['schemas']['Event']
      /** @example invalid event */
      validationError?: string
    }
    /**
     * @description A feature is a feature or service offered to a customer.
     * For example: CPU-Hours, Tokens, API Calls, etc.
     */
    CreateFeatureRequest: {
      /**
       * @description The name of the feature.
       *
       * @example AI Tokens
       */
      name: string
      /**
       * @description The meter that the feature is associated with and decreases grants by usage.
       *
       * @example tokens_total
       */
      meterSlug: string
      /**
       * @description Optional meter group by filters. Useful if the meter scope is broader than what feature tracks.
       *
       * @example {
       *   "model": "gpt-4"
       * }
       */
      meterGroupByFilters?: {
        [key: string]: string
      }
      /**
       * @description If the feature is archived, it will not be used for grants or usage.
       *
       * @example false
       */
      archived?: boolean
    }
    /**
     * @description A feature is a feature or service offered to a customer.
     * For example: CPU-Hours, Tokens, API Calls, etc.
     */
    Feature: components['schemas']['CreateFeatureRequest'] & {
      /**
       * @description Readonly unique ULID identifier of the feature.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Format: date-time
       * @description The time the feature was created.
       *
       * @example 2023-01-01T00:00:00Z
       */
      createdAt?: string
      /**
       * Format: date-time
       * @description The time the feature was last updated.
       *
       * @example 2023-01-01T00:00:00Z
       */
      updatedAt?: string
    }
    /**
     * @description A ledger represented in open meter. A ledger must be assigned to a single
     * subject.
     */
    CreateLedger: {
      /** @description The metering subject this ledger used to track grants for. */
      subject: string
      /**
       * @example {
       *   "stripePaymentId": "pi_4OrAkhLvyihio9p51h9iiFnB"
       * }
       */
      metadata?: {
        [key: string]: string
      }
    }
    /**
     * @description Ledger Exists
     * @example {
     *   "type": "about:blank",
     *   "title": "Conflict",
     *   "status": 409,
     *   "detail": "ledger (default.01HXVNDJR532E8GTBVSC2XK5D4) already exitst for subject subject-1",
     *   "instance": "urn:request:local/JMOlctsKV8-000001",
     *   "conflictingEntity": {
     *     "id": "01HXVNDJR532E8GTBVSC2XK5D4",
     *     "subject": "subject-1"
     *   }
     * }
     */
    LedgerAlreadyExistsProblem: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @example urn:problem-type:bad-request
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int32
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example body must be a JSON object
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance?: string
      conflictingEntity?: components['schemas']['Ledger']
      [key: string]: unknown
    }
    /** @description A ledger represented in our system. */
    Ledger: components['schemas']['CreateLedger'] & {
      /**
       * @description Readonly unique ULID identifier of the ledger.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Format: date-time
       * @description The time the ledger was created.
       *
       * @example 2023-01-01T00:00:00Z
       */
      createdAt?: string
    }
    /** @description A ledger entry. */
    LedgerEntry: {
      /**
       * @description Readonly unique ULID identifier of the ledger entry.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      type: components['schemas']['LedgerEntryType']
      /**
       * Format: date-time
       * @description The time the ledger entry was created.
       *
       * @example 2023-01-01T00:00:00Z
       */
      time: string
      /**
       * Format: double
       * @description The amount to apply. Can be positive or negative number. If applicable.
       *
       * @example 100
       */
      amount: number
      /**
       * @description The unique feature ULID that the entry is associated with.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureID: string
      period?: components['schemas']['Period']
    }
    /** @description A time period */
    Period: {
      /**
       * Format: date-time
       * @description Period start time where the amount was applied. If applicable.
       *
       * @example 2023-01-01T00:00:00Z
       */
      from: string
      /**
       * Format: date-time
       * @description Period end time where the amount was applied. If applicable.
       *
       * @example 2023-01-01T00:00:00Z
       */
      to: string
    }
    /**
     * @example GRANT
     * @enum {string}
     */
    LedgerEntryType: 'GRANT' | 'VOID' | 'RESET' | 'GRANT_USAGE'
    /** @description Balance of a subject. */
    LedgerBalance: {
      /** @description Features with balances. */
      featureBalances: components['schemas']['FeatureBalance'][]
      /** @description The grants applied to the subject. */
      grantBalances: components['schemas']['LedgerGrantBalance'][]
      /**
       * @example {
       *   "stripePaymentId": "pi_4OrAkhLvyihio9p51h9iiFnB"
       * }
       */
      metadata?: {
        [key: string]: string
      }
      /**
       * @description The subject of the ledger.
       *
       * @example subject-1
       */
      subject: string
      /**
       * Format: date-time
       * @description The last reset of the ledger.
       *
       * @example 2023-01-01T00:00:00Z
       */
      lastReset?: string
    }
    /** @description Ledger reset configuration. */
    LedgerReset: {
      /**
       * @description Readonly unique ULID identifier of the reset.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Format: date-time
       * @description The time to reset the ledger. It cannot be in the future.
       *
       * @example 2023-01-01T00:00:00Z
       */
      effectiveAt: string
    }
    LedgerGrantBalance: components['schemas']['LedgerGrantResponse'] & {
      /**
       * Format: double
       * @description The balance of the grant.
       *
       * @example 100
       */
      balance: number
    }
    FeatureBalance: components['schemas']['Feature'] & {
      /**
       * Format: double
       * @description The balance of the feature.
       *
       * @example 100
       */
      balance: number
      /**
       * Format: double
       * @description The usage of the feature.
       *
       * @example 100
       */
      usage: number
    }
    /** @description Grants are used to increase balance of specific subjects. */
    CreateLedgerGrantRequest: {
      type: components['schemas']['LedgerGrantType']
      /**
       * Format: double
       * @description The amount to grant. Can be positive or negative number.
       *
       * @example 100
       */
      amount: number
      /**
       * @description The unique feature ULID that the grant is associated with, if any.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureID: string
      /**
       * @description The priority of the grant. Grants with higher priority are applied first.
       * Priority is a positive decimal numbers. With lower numbers indicating higher importance.
       * For example, a priority of 1 is more urgent than a priority of 2.
       * When there are several grants available for the same subject, the system selects the grant with the highest priority.
       * In cases where grants share the same priority level, the grant closest to its expiration will be used first.
       * In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
       *
       * @default 1
       * @example 1
       */
      priority?: number
      /**
       * Format: date-time
       * @description The effective date.
       *
       * @example 2023-01-01T00:00:00Z
       */
      effectiveAt: string
      expiration: components['schemas']['LedgerGrantExpirationPeriod']
      rollover?: components['schemas']['LedgerGrantRollover']
      /**
       * @example {
       *   "stripePaymentId": "pi_4OrAkhLvyihio9p51h9iiFnB"
       * }
       */
      metadata?: {
        [key: string]: string
      }
      /**
       * @description The parent grant ULID that the grant is associated with, if any.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      parentId?: string
      /**
       * Format: date-time
       * @description The time the grant was created.
       *
       * @example 2023-01-01T00:00:00Z
       */
      createdAt?: string
      /**
       * Format: date-time
       * @description The time the grant was last updated.
       *
       * @example 2023-01-01T00:00:00Z
       */
      updatedAt?: string
    }
    LedgerGrantResponse: components['schemas']['CreateLedgerGrantRequest'] & {
      /**
       * @description Readonly unique ULID identifier of the grant.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * @description The ledger ID.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      ledgerID: string
      /**
       * @description If the grant is voided, it will not be applied to the subject's balance anymore.
       *
       * @example false
       */
      void: boolean
      /**
       * Format: date-time
       * @description The expiration date of the grant.
       *
       * @example 2023-01-01T00:00:00Z
       */
      expiresAt?: string
    }
    /**
     * @description The grant type:
     * - `USAGE` - Increase balance by the amount in the unit of the associated meter.
     *
     * @example USAGE
     * @enum {string}
     */
    LedgerGrantType: 'USAGE'
    /** @description Grant rollover configuration. */
    LedgerGrantRollover: {
      type: components['schemas']['LedgerGrantRolloverType']
      /** @description Maximum amount to rollover. */
      maxAmount?: number
    }
    /**
     * @description The rollover type to use:
     * - `REMAINING_AMOUNT` - Rollover remaining amount.
     * - `ORIGINAL_AMOUNT` - Rollover re-applies the full grant amount.
     *
     * @example ORIGINAL_AMOUNT
     * @enum {string}
     */
    LedgerGrantRolloverType: 'REMAINING_AMOUNT' | 'ORIGINAL_AMOUNT'
    /** @description Expiration period of a ledger grant. */
    LedgerGrantExpirationPeriod: {
      /**
       * @description The expiration period duration like month.
       *
       * @enum {string}
       */
      duration: 'HOUR' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
      /**
       * @description The expiration period count like 12 months.
       *
       * @example 12
       */
      count: number
    }
    /**
     * @description A meter is a configuration that defines how to match and aggregate events.
     * @example {
     *   "slug": "tokens_total",
     *   "description": "AI token usage",
     *   "aggregation": "SUM",
     *   "windowSize": "MINUTE",
     *   "eventType": "prompt",
     *   "valueProperty": "$.tokens",
     *   "groupBy": {
     *     "model": "$.model",
     *     "type": "$.type"
     *   }
     * }
     */
    Meter: {
      /**
       * @description A unique identifier for the meter.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id?: string
      /**
       * @description A unique, human-readable identifier for the meter. Must consist only alphanumeric and underscore characters.
       * @example tokens_total
       */
      slug: string
      /**
       * @description A description of the meter.
       * @example AI Token Usage
       */
      description?: string | null
      aggregation: components['schemas']['MeterAggregation']
      windowSize: components['schemas']['WindowSize']
      /**
       * @description The event type to aggregate.
       * @example prompt
       */
      eventType: string
      /**
       * @description JSONPath expression to extract the value from the ingested event's data property.
       * The ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.
       * For UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.
       *
       * @example $.tokens
       */
      valueProperty?: string
      /**
       * @description Named JSONPath expressions to extract the group by values from the event data. Keys must be unique and consist only alphanumeric and underscore characters.
       * @example {
       *   "model": "$.model",
       *   "type": "$.type"
       * }
       */
      groupBy?: {
        [key: string]: string
      }
    }
    /**
     * @description The aggregation type to use for the meter.
     * @example SUM
     * @enum {string}
     */
    MeterAggregation: 'SUM' | 'COUNT' | 'UNIQUE_COUNT' | 'AVG' | 'MIN' | 'MAX'
    /**
     * @description Aggregation window size.
     * @example MINUTE
     * @enum {string}
     */
    WindowSize: 'MINUTE' | 'HOUR' | 'DAY'
    /**
     * @description The result of a meter query.
     * @example {
     *   "from": "2023-01-01T00:00:00Z",
     *   "to": "2023-01-02T00:00:00Z",
     *   "windowSize": "MINUTE",
     *   "data": [
     *     {
     *       "value": 12,
     *       "windowStart": "2023-01-01T00:00:00Z",
     *       "windowEnd": "2023-01-02T00:00:00Z",
     *       "subject": "customer-id",
     *       "groupBy": {
     *         "model": "gpt-4-turbo",
     *         "type": "prompt"
     *       }
     *     }
     *   ]
     * }
     */
    MeterQueryResult: {
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      from?: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      to?: string
      windowSize?: components['schemas']['WindowSize']
      /**
       * @example [
       *   {
       *     "value": 12,
       *     "windowStart": "2023-01-01T00:00:00Z",
       *     "windowEnd": "2023-01-02T00:00:00Z",
       *     "subject": "customer-id",
       *     "groupBy": {
       *       "model": "gpt-4-turbo",
       *       "type": "prompt"
       *     }
       *   }
       * ]
       */
      data: components['schemas']['MeterQueryRow'][]
    }
    /**
     * @description A row in the result of a meter query.
     * @example {
     *   "value": 12,
     *   "windowStart": "2023-01-01T00:00:00Z",
     *   "windowEnd": "2023-01-02T00:00:00Z",
     *   "subject": "customer-id",
     *   "groupBy": {
     *     "model": "gpt-4-turbo",
     *     "type": "prompt"
     *   }
     * }
     */
    MeterQueryRow: {
      /** @example 12 */
      value: number
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      windowStart: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      windowEnd: string
      /**
       * @description The subject of the meter value.
       * @example customer-id
       */
      subject?: string | null
      /**
       * @example {
       *   "model": "gpt-4-turbo",
       *   "type": "prompt"
       * }
       */
      groupBy?: {
        [key: string]: string
      } | null
    }
    /**
     * @description A consumer portal token.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "subject": "customer-id",
     *   "expiresAt": "2023-01-02T00:00:00Z",
     *   "expired": false,
     *   "createdAt": "2023-01-01T00:00:00Z",
     *   "token": "om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo",
     *   "allowedMeterSlugs": [
     *     "tokens_total"
     *   ]
     * }
     */
    PortalToken: {
      /** @example 01G65Z755AFWAKHE12NY0CQ9FH */
      id?: string
      /** @example customer-id */
      subject: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      expiresAt?: string
      expired?: boolean
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      createdAt?: string
      /**
       * @description The token is only returned at creation.
       * @example om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo
       */
      token?: string
      /**
       * @description Optional, if defined only the specified meters will be allowed
       * @example [
       *   "tokens_total"
       * ]
       */
      allowedMeterSlugs?: string[]
    }
    /**
     * @description A subject is a unique identifier for a user or entity.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "key": "customer-id",
     *   "displayName": "Customer Name",
     *   "metadata": {
     *     "hubspotId": "123456"
     *   },
     *   "currentPeriodStart": "2023-01-01T00:00:00Z",
     *   "currentPeriodEnd": "2023-02-01T00:00:00Z",
     *   "stripeCustomerId": "cus_JMOlctsKV8"
     * }
     */
    Subject: {
      /** @example 01G65Z755AFWAKHE12NY0CQ9FH */
      id?: string
      /** @example customer-id */
      key: string
      /** @example Customer Name */
      displayName?: string | null
      /**
       * @example {
       *   "hubspotId": "123456"
       * }
       */
      metadata?: {
        [key: string]: unknown
      } | null
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      currentPeriodStart?: string | null
      /**
       * Format: date-time
       * @example 2023-02-01T00:00:00Z
       */
      currentPeriodEnd?: string | null
      /** @example cus_JMOlctsKV8 */
      stripeCustomerId?: string | null
    }
    /**
     * @description A unique identifier.
     * @example tokens_total
     */
    IdOrSlug: string
  }
  responses: {
    /** @description Bad Request */
    BadRequestProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Unauthorized */
    UnauthorizedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Ledger Exists */
    LedgerAlreadyExistsProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['LedgerAlreadyExistsProblem']
      }
    }
    /** @description Not Found */
    NotFoundProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Not Implemented */
    NotImplementedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Unexpected error */
    UnexpectedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
  }
  parameters: {
    /** @description A unique identifier for the meter. */
    meterIdOrSlug: components['schemas']['IdOrSlug']
    /** @description A unique identifier for a subject. */
    subjectIdOrKey: string
    /** @description A unique ULID identifier for a feature. */
    featureID: string
    /** @description A unique identifier for a ledger grant. */
    ledgerGrantID: string
    /** @description A unique identifier for a ledger. */
    ledgerID: string
    /** @description Include void entries in the response. */
    ledgerIncludeVoids?: boolean
    /** @description Number of entries to return */
    ledgerQueryLimit?: number
    /** @description Number of entries to skip */
    ledgerQueryOffset?: number
    /**
     * @description Start date-time in RFC 3339 format.
     * Inclusive.
     */
    queryFrom?: string
    /**
     * @description End date-time in RFC 3339 format.
     * Inclusive.
     */
    queryTo?: string
    /** @description If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group. */
    queryWindowSize?: components['schemas']['WindowSize']
    /**
     * @description The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
     * If not specified, the UTC timezone will be used.
     */
    queryWindowTimeZone?: string
    /**
     * @description Filtering and group by multiple subjects.
     *
     * Usage: `?ledgerID=01HX6VK5C498B3ABY9PR1069PP`
     *
     * @example 01HX6VK5C498B3ABY9PR1069PP
     */
    queryFilterLedgerID?: string
    /**
     * @description Filtering by multiple subjects.
     *
     * Usage: ?subject=customer-1&subject=customer-2
     */
    queryFilterSubject?: string[]
    queryFilterGroupBy?: {
      [key: string]: string
    }
    /**
     * @description If not specified a single aggregate will be returned for each subject and time window.
     * `subject` is a reserved group by value.
     */
    queryGroupBy?: string[]
  }
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /**
   * List ingested events
   * @description List ingested events within a time range.
   */
  listEvents: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        /** @description Number of events to return */
        limit?: number
      }
    }
    responses: {
      /** @description List of events for debugging. */
      200: {
        content: {
          'application/json': components['schemas']['IngestedEvent'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Ingest events
   * @description Ingests an event or batch of events following the CloudEvents specification.
   */
  ingestEvents: {
    /**
     * @description The event or batch of events to ingest.
     * The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
     * The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
     */
    requestBody: {
      content: {
        'application/cloudevents+json': components['schemas']['Event']
        'application/cloudevents-batch+json': components['schemas']['Event'][]
      }
    }
    responses: {
      /** @description Successfully ingested. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List meters
   * @description List meters.
   */
  listMeters: {
    responses: {
      /** @description List of meters. */
      200: {
        content: {
          'application/json': components['schemas']['Meter'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Create meter
   * @description *Available in OpenMeter Cloud.*
   * *In the open-source version, meters are created in the configuration file.*
   *
   * Create a meter.
   */
  createMeter: {
    /** @description The meter to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['Meter']
      }
    }
    responses: {
      /** @description Created. */
      201: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get meter
   * @description Get meter by ID or slug
   */
  getMeter: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Meter found. */
      200: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Delete meter
   * @description *Available in OpenMeter Cloud.*
   *
   * Delete a meter by ID or slug.
   */
  deleteMeter: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Meter deleted. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Query meter
   * @description Query meter for usage.
   */
  queryMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        windowSize?: components['parameters']['queryWindowSize']
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
        subject?: components['parameters']['queryFilterSubject']
        filterGroupBy?: components['parameters']['queryFilterGroupBy']
        groupBy?: components['parameters']['queryGroupBy']
      }
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Usage data. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List meter subjects
   * @description List subjects for a meter.
   */
  listMeterSubjects: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description List of subjects. */
      200: {
        content: {
          'application/json': string[]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ List portal tokens
   * @description *Available in OpenMeter Cloud.*
   *
   * List consumer portal tokens.
   */
  listPortalTokens: {
    parameters: {
      query?: {
        /** @description Number of portal tokens to return. Default is 25. */
        limit?: number
      }
    }
    responses: {
      /** @description List of portal tokens. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create portal token
   * @description Create a consumer portal token.
   */
  createPortalToken: {
    /** @description The portal token to create. */
    requestBody: {
      content: {
        /**
         * @example {
         *   "subject": "customer-id",
         *   "allowedMeterSlugs": [
         *     "tokens_total"
         *   ]
         * }
         */
        'application/json': components['schemas']['PortalToken']
      }
    }
    responses: {
      /** @description Created. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Invalidate portal tokens
   * @description *Available in OpenMeter Cloud.*
   *
   * Invalidates consumer portal tokens by ID or subject.
   */
  invalidatePortalTokens: {
    /** @description If no id or subject is specified, all tokens will be invalidated. */
    requestBody: {
      content: {
        'application/json': {
          /** @description Invalidate a portal token by ID. */
          id?: string
          /** @description Invalidate all portal tokens for a subject. */
          subject?: string
        }
      }
    }
    responses: {
      /** @description Portal tokens invalidated. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ List subjects
   * @description *Available in OpenMeter Cloud.*
   *
   * List subjects.
   */
  listSubjects: {
    responses: {
      /** @description List of subjects. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Upsert subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Upserts a subject. Creates or updates subject.
   * If the subject doesn't exist, it will be created.
   * If the subject exists, it will be partially updated with the provided fields.
   */
  upsertSubject: {
    /** @description The subject to upsert. */
    requestBody: {
      content: {
        'application/json': components['schemas']['Subject'][]
      }
    }
    responses: {
      /** @description Subject upserted. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Get subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Get subject by ID or key.
   */
  getSubject: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description Subject found. */
      200: {
        content: {
          'application/json': components['schemas']['Subject']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Delete subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Delete a subject by ID or key.
   */
  deleteSubject: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description Subject deleted. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Query portal meter
   * @description Query meter for consumer portal. This endpoint is publicly exposable to consumers.
   */
  queryPortalMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        windowSize?: components['parameters']['queryWindowSize']
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
        filterGroupBy?: components['parameters']['queryFilterGroupBy']
        groupBy?: components['parameters']['queryGroupBy']
      }
      path: {
        /** @description A unique identifier for the meter. */
        meterSlug: string
      }
    }
    responses: {
      /** @description Usage data. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List features
   * @description List features.
   */
  listFeatures: {
    parameters: {
      query?: {
        limit?: components['parameters']['ledgerQueryLimit']
        offset?: components['parameters']['ledgerQueryOffset']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt' | 'updatedAt'
        /** @description Include archived features. */
        includeArchived?: boolean
      }
    }
    responses: {
      /** @description List of features. */
      200: {
        content: {
          'application/json': components['schemas']['Feature'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create feature
   * @description Creates a feature.
   */
  createFeature: {
    /** @description The feature to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateFeatureRequest']
      }
    }
    responses: {
      /** @description Feature created. */
      201: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get feature
   * @description Get feature by key.
   */
  getFeature: {
    parameters: {
      path: {
        featureID: components['parameters']['featureID']
      }
    }
    responses: {
      /** @description Feature found. */
      200: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Delete feature
   * @description Delete a feature by key.
   */
  deleteFeature: {
    parameters: {
      path: {
        featureID: components['parameters']['featureID']
      }
    }
    responses: {
      /** @description Feature deleted. */
      204: {
        content: never
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List the already defined ledgers.
   * @description List the already defined ledgers.
   */
  listLedgers: {
    parameters: {
      query?: {
        /** @description Query ledgers specific to subjects. */
        subject?: string[]
        /** @description Query ledgers with subjects that are similar to the provided text. */
        subjectSimilarTo?: string
        limit?: components['parameters']['ledgerQueryLimit']
        offset?: components['parameters']['ledgerQueryOffset']
        /** @description Order by field */
        orderBy?: 'subject' | 'createdAt' | 'id'
      }
    }
    responses: {
      /** @description List of the matching ledgers. */
      200: {
        content: {
          'application/json': components['schemas']['Ledger'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Creates the specified ledger
   * @description Create or update the specified ledger.
   */
  createLedger: {
    /** @description The ledger to be created */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateLedger']
      }
    }
    responses: {
      /** @description The created ledger. */
      201: {
        content: {
          'application/json': components['schemas']['Ledger']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      409: components['responses']['LedgerAlreadyExistsProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get the balance of a specific subject.
   * @description Get the balance of a specific subject.
   */
  getLedgerBalance: {
    parameters: {
      query?: {
        /** @description Point of time to query balances: date-time in RFC 3339 format. Defaults to now. */
        time?: string
      }
      path: {
        ledgerID: components['parameters']['ledgerID']
      }
    }
    responses: {
      /** @description Ledger balances available. */
      200: {
        content: {
          'application/json': components['schemas']['LedgerBalance']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get the history of a ledger
   * @description Get the history of a specific ledger
   */
  getLedgerHistory: {
    parameters: {
      query: {
        limit?: components['parameters']['ledgerQueryLimit']
        offset?: components['parameters']['ledgerQueryOffset']
        /** @description Start of time range to query ledger: date-time in RFC 3339 format. */
        from: string
        /** @description End of time range to query ledger: date-time in RFC 3339 format. Defaults to now. */
        to?: string
      }
      path: {
        ledgerID: components['parameters']['ledgerID']
      }
    }
    responses: {
      /** @description Ledger balance history. */
      200: {
        content: {
          'application/json': components['schemas']['LedgerEntry'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Reset the ledger's balance
   * @description Resets the ledger's balances to zero for a specific subject and re-apply active grants with rollover configuration.
   */
  resetLedger: {
    parameters: {
      path: {
        ledgerID: components['parameters']['ledgerID']
      }
    }
    /** @description Details for the reset. */
    requestBody: {
      content: {
        'application/json': components['schemas']['LedgerReset']
      }
    }
    responses: {
      /** @description Ledger balance reset. */
      201: {
        content: {
          'application/json': components['schemas']['LedgerReset']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List grants for multiple ledgers.
   * @description List grants for multiple ledgers.
   */
  listLedgerGrants: {
    parameters: {
      query?: {
        ledgerID?: components['parameters']['queryFilterLedgerID']
        limit?: components['parameters']['ledgerQueryLimit']
        includeVoids?: components['parameters']['ledgerIncludeVoids']
      }
    }
    responses: {
      /** @description List of ledger grants. */
      200: {
        content: {
          'application/json': components['schemas']['LedgerGrantResponse'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List ledger grants
   * @description List ledger grants for a specific ledger.
   */
  listLedgerGrantsByLedger: {
    parameters: {
      query?: {
        limit?: components['parameters']['ledgerQueryLimit']
        includeVoids?: components['parameters']['ledgerIncludeVoids']
      }
      path: {
        ledgerID: components['parameters']['ledgerID']
      }
    }
    responses: {
      /** @description List of ledger grants created. */
      200: {
        content: {
          'application/json': components['schemas']['LedgerGrantResponse'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create a grant on a specific ledger.
   * @description Create a grant on a specific ledger.
   */
  createLedgerGrant: {
    parameters: {
      path: {
        ledgerID: components['parameters']['ledgerID']
      }
    }
    /** @description The grant to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateLedgerGrantRequest']
      }
    }
    responses: {
      /** @description LedgerGrant created. */
      201: {
        content: {
          'application/json': components['schemas']['LedgerGrantResponse']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get a single grant.
   * @description Gets the grant for a ledger by ID.
   */
  getLedgerGrant: {
    parameters: {
      path: {
        ledgerID: components['parameters']['ledgerID']
        ledgerGrantID: components['parameters']['ledgerGrantID']
      }
    }
    responses: {
      /** @description Ledger grant found. */
      200: {
        content: {
          'application/json': components['schemas']['LedgerGrantResponse']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Void ledger grant
   * @description Void a ledger grant by ID. Partially or fully used grants cannot be voided.
   * Voided grant won't be applied to the subject's balance anymore.
   */
  voidLedgerGrant: {
    parameters: {
      path: {
        ledgerGrantID: components['parameters']['ledgerGrantID']
        ledgerID: components['parameters']['ledgerID']
      }
    }
    responses: {
      /** @description Ledger grant voided. */
      204: {
        content: never
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
}
